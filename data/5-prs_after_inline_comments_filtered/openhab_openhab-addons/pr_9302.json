{"pr_number": 9302, "pr_title": "[tivo] Update tivo binding for OH3", "pr_createdAt": "2020-12-09T00:31:43Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/9302", "timeline": [{"oid": "76591febae63b36f3e1b144261a183614d935764", "url": "https://github.com/openhab/openhab-addons/commit/76591febae63b36f3e1b144261a183614d935764", "message": "Baseline original code from AndyXMB\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-12-08T15:22:01Z", "type": "commit"}, {"oid": "5af1bc1975878edba950cbbdf990bd67f90b8e12", "url": "https://github.com/openhab/openhab-addons/commit/5af1bc1975878edba950cbbdf990bd67f90b8e12", "message": "Initial updates for OH3\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-12-09T00:18:30Z", "type": "commit"}, {"oid": "dc20b9efb28d7391d58c8f21d8e44cfe27936934", "url": "https://github.com/openhab/openhab-addons/commit/dc20b9efb28d7391d58c8f21d8e44cfe27936934", "message": "fix null warnings and add sub-channel handling\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-12-10T23:17:37Z", "type": "commit"}, {"oid": "8d58ca3a35ec9520fd0c312491cfd76c18a7d6bc", "url": "https://github.com/openhab/openhab-addons/commit/8d58ca3a35ec9520fd0c312491cfd76c18a7d6bc", "message": "finish\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-12-12T01:21:34Z", "type": "commit"}, {"oid": "aa8457fa2e41b8f90f00ae89373654cbafa22e08", "url": "https://github.com/openhab/openhab-addons/commit/aa8457fa2e41b8f90f00ae89373654cbafa22e08", "message": "Add isRecording Channel\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-12-13T22:23:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU0OTk2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543549961", "bodyText": "I know this is legacy code from the OH 1.x binding, but could you read this with getConfigAs()?", "author": "fwolter", "createdAt": "2020-12-15T17:39:31Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/handler/TiVoHandler.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.handler;\n+\n+import static org.openhab.binding.tivo.TiVoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.internal.service.TivoConfigData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.openhab.binding.tivo.internal.service.TivoStatusProvider;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TiVoHandler} is the BaseThingHandler responsible for handling commands that are\n+ * sent to one of the Tivo's channels.\n+ *\n+ * @author Jayson Kubilis (DigitalBytes) - Initial contribution\n+ * @author Andrew Black (AndyXMB) - Updates / compilation corrections. Addition of channel scanning functionality.\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TiVoHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(TiVoHandler.class);\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+    private ConnectionStatus lastConnectionStatus = ConnectionStatus.UNKNOWN;\n+    private Optional<TivoStatusProvider> tivoConnection = Optional.empty();\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    /**\n+     * Instantiates a new TiVo handler.\n+     *\n+     * @param thing the thing\n+     */\n+    public TiVoHandler(Thing thing) {\n+        super(thing);\n+        logger.debug(\"TiVoHandler '{}' - creating\", getThing().getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Handles the commands from the various TiVo channel objects\n+        logger.debug(\"handleCommand '{}', parameter: {}\", channelUID, command);\n+\n+        if (!isInitialized() || !tivoConnection.isPresent()) {\n+            logger.debug(\"handleCommand '{}' device is not intialised yet, command '{}' will be ignored.\",\n+                    getThing().getUID(), channelUID + \" \" + command);\n+            return;\n+        }\n+\n+        TivoStatusData currentStatus = tivoConnection.get().getServiceStatus();\n+        String commandKeyword = \"\";\n+\n+        String commandParameter = command.toString().toUpperCase();\n+        if (command instanceof RefreshType) {\n+            // Future enhancement, if we can come up with a sensible set of actions when a REFRESH is issued\n+            logger.debug(\"TiVo '{}' skipping REFRESH command for channel: '{}'.\", getThing().getUID(),\n+                    channelUID.getId());\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TIVO_CHANNEL_FORCE:\n+                commandKeyword = \"FORCECH\";\n+                break;\n+            case CHANNEL_TIVO_CHANNEL_SET:\n+                commandKeyword = \"SETCH\";\n+                break;\n+            case CHANNEL_TIVO_TELEPORT:\n+                commandKeyword = \"TELEPORT\";\n+                break;\n+            case CHANNEL_TIVO_IRCMD:\n+                commandKeyword = \"IRCODE\";\n+                break;\n+            case CHANNEL_TIVO_KBDCMD:\n+                commandKeyword = \"KEYBOARD\";\n+                break;\n+        }\n+        sendCommand(commandKeyword, commandParameter, currentStatus);\n+    }\n+\n+    public void setStatusOffline() {\n+        this.updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                \"Power on device or check network configuration/connection.\");\n+    }\n+\n+    private void sendCommand(String commandKeyword, String commandParameter, TivoStatusData currentStatus) {\n+        if (!tivoConnection.isPresent()) {\n+            return;\n+        }\n+\n+        TivoStatusData deviceStatus = tivoConnection.get().getServiceStatus();\n+        TivoStatusData commandResult = null;\n+        logger.debug(\"handleCommand '{}' - {} found!\", getThing().getUID(), commandKeyword);\n+        // Re-write command keyword if we are in STANDBY, as only IRCODE TIVO will wake the unit from\n+        // standby mode\n+        if (deviceStatus.getConnectionStatus() == ConnectionStatus.STANDBY && commandKeyword.contentEquals(\"TELEPORT\")\n+                && commandParameter.contentEquals(\"TIVO\")) {\n+            commandKeyword = \"IRCODE \" + commandParameter;\n+            logger.debug(\"TiVo '{}' TELEPORT re-mapped to IRCODE as we are in standby: '{}'\", getThing().getUID(),\n+                    commandKeyword);\n+        }\n+        // Execute command\n+        if (commandKeyword.contentEquals(\"FORCECH\") || commandKeyword.contentEquals(\"SETCH\")) {\n+            commandResult = chChannelChange(commandKeyword, commandParameter);\n+        } else {\n+            commandResult = tivoConnection.get().cmdTivoSend(commandKeyword + \" \" + commandParameter);\n+        }\n+\n+        // Post processing\n+        if (commandResult != null && commandParameter.contentEquals(\"STANDBY\")) {\n+            // Force thing state into STANDBY as this command does not return a status when executed\n+            commandResult.setConnectionStatus(ConnectionStatus.STANDBY);\n+        }\n+\n+        // Push status updates\n+        if (commandResult != null && commandResult.isCmdOk()) {\n+            updateTivoStatus(currentStatus, commandResult);\n+        }\n+\n+        // disconnect once command is complete (really only disconnects if isCfgKeepConnOpen = false)\n+        tivoConnection.get().connTivoDisconnect(false);\n+    }\n+\n+    int convertValueToInt(Object value) {\n+        if (value instanceof BigDecimal) {\n+            return ((BigDecimal) value).intValue();\n+        }\n+        if (value instanceof String) {\n+            return Integer.valueOf((String) value);\n+        }\n+        if (value instanceof Double) {\n+            return ((Double) value).intValue();\n+        }\n+        return (Integer) value;\n+    }\n+\n+    boolean convertValueToBoolean(Object value) {\n+        return value instanceof Boolean ? ((Boolean) value) : Boolean.valueOf((String) value);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing a TiVo '{}' with config options\", getThing().getUID());\n+\n+        Configuration conf = this.getConfig();\n+\n+        Object value;\n+        value = conf.get(CONFIG_ADDRESS);\n+        if (value != null) {\n+            tivoConfigData.setCfgHost(String.valueOf(value));\n+        }", "originalCommit": "aa8457fa2e41b8f90f00ae89373654cbafa22e08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgwNjg4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543806887", "bodyText": "done", "author": "mlobstein", "createdAt": "2020-12-16T01:21:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU0OTk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU1MDM2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543550367", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-12-15T17:40:03Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/handler/TiVoHandler.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.handler;\n+\n+import static org.openhab.binding.tivo.TiVoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.internal.service.TivoConfigData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.openhab.binding.tivo.internal.service.TivoStatusProvider;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TiVoHandler} is the BaseThingHandler responsible for handling commands that are\n+ * sent to one of the Tivo's channels.\n+ *\n+ * @author Jayson Kubilis (DigitalBytes) - Initial contribution\n+ * @author Andrew Black (AndyXMB) - Updates / compilation corrections. Addition of channel scanning functionality.\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TiVoHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(TiVoHandler.class);\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+    private ConnectionStatus lastConnectionStatus = ConnectionStatus.UNKNOWN;\n+    private Optional<TivoStatusProvider> tivoConnection = Optional.empty();\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    /**\n+     * Instantiates a new TiVo handler.\n+     *\n+     * @param thing the thing\n+     */\n+    public TiVoHandler(Thing thing) {\n+        super(thing);\n+        logger.debug(\"TiVoHandler '{}' - creating\", getThing().getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Handles the commands from the various TiVo channel objects\n+        logger.debug(\"handleCommand '{}', parameter: {}\", channelUID, command);\n+\n+        if (!isInitialized() || !tivoConnection.isPresent()) {\n+            logger.debug(\"handleCommand '{}' device is not intialised yet, command '{}' will be ignored.\",\n+                    getThing().getUID(), channelUID + \" \" + command);\n+            return;\n+        }\n+\n+        TivoStatusData currentStatus = tivoConnection.get().getServiceStatus();\n+        String commandKeyword = \"\";\n+\n+        String commandParameter = command.toString().toUpperCase();\n+        if (command instanceof RefreshType) {\n+            // Future enhancement, if we can come up with a sensible set of actions when a REFRESH is issued\n+            logger.debug(\"TiVo '{}' skipping REFRESH command for channel: '{}'.\", getThing().getUID(),\n+                    channelUID.getId());\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TIVO_CHANNEL_FORCE:\n+                commandKeyword = \"FORCECH\";\n+                break;\n+            case CHANNEL_TIVO_CHANNEL_SET:\n+                commandKeyword = \"SETCH\";\n+                break;\n+            case CHANNEL_TIVO_TELEPORT:\n+                commandKeyword = \"TELEPORT\";\n+                break;\n+            case CHANNEL_TIVO_IRCMD:\n+                commandKeyword = \"IRCODE\";\n+                break;\n+            case CHANNEL_TIVO_KBDCMD:\n+                commandKeyword = \"KEYBOARD\";\n+                break;\n+        }\n+        sendCommand(commandKeyword, commandParameter, currentStatus);\n+    }\n+\n+    public void setStatusOffline() {\n+        this.updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                \"Power on device or check network configuration/connection.\");\n+    }\n+\n+    private void sendCommand(String commandKeyword, String commandParameter, TivoStatusData currentStatus) {\n+        if (!tivoConnection.isPresent()) {\n+            return;\n+        }\n+\n+        TivoStatusData deviceStatus = tivoConnection.get().getServiceStatus();\n+        TivoStatusData commandResult = null;\n+        logger.debug(\"handleCommand '{}' - {} found!\", getThing().getUID(), commandKeyword);\n+        // Re-write command keyword if we are in STANDBY, as only IRCODE TIVO will wake the unit from\n+        // standby mode\n+        if (deviceStatus.getConnectionStatus() == ConnectionStatus.STANDBY && commandKeyword.contentEquals(\"TELEPORT\")\n+                && commandParameter.contentEquals(\"TIVO\")) {\n+            commandKeyword = \"IRCODE \" + commandParameter;\n+            logger.debug(\"TiVo '{}' TELEPORT re-mapped to IRCODE as we are in standby: '{}'\", getThing().getUID(),\n+                    commandKeyword);\n+        }\n+        // Execute command\n+        if (commandKeyword.contentEquals(\"FORCECH\") || commandKeyword.contentEquals(\"SETCH\")) {\n+            commandResult = chChannelChange(commandKeyword, commandParameter);\n+        } else {\n+            commandResult = tivoConnection.get().cmdTivoSend(commandKeyword + \" \" + commandParameter);\n+        }\n+\n+        // Post processing\n+        if (commandResult != null && commandParameter.contentEquals(\"STANDBY\")) {\n+            // Force thing state into STANDBY as this command does not return a status when executed\n+            commandResult.setConnectionStatus(ConnectionStatus.STANDBY);\n+        }\n+\n+        // Push status updates\n+        if (commandResult != null && commandResult.isCmdOk()) {\n+            updateTivoStatus(currentStatus, commandResult);\n+        }\n+\n+        // disconnect once command is complete (really only disconnects if isCfgKeepConnOpen = false)\n+        tivoConnection.get().connTivoDisconnect(false);\n+    }\n+\n+    int convertValueToInt(Object value) {\n+        if (value instanceof BigDecimal) {\n+            return ((BigDecimal) value).intValue();\n+        }\n+        if (value instanceof String) {\n+            return Integer.valueOf((String) value);\n+        }\n+        if (value instanceof Double) {\n+            return ((Double) value).intValue();\n+        }\n+        return (Integer) value;\n+    }\n+\n+    boolean convertValueToBoolean(Object value) {\n+        return value instanceof Boolean ? ((Boolean) value) : Boolean.valueOf((String) value);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing a TiVo '{}' with config options\", getThing().getUID());\n+\n+        Configuration conf = this.getConfig();\n+\n+        Object value;\n+        value = conf.get(CONFIG_ADDRESS);\n+        if (value != null) {\n+            tivoConfigData.setCfgHost(String.valueOf(value));\n+        }\n+\n+        value = conf.get(CONFIG_PORT);\n+        if (value != null) {\n+            tivoConfigData.setCfgTcpPort(convertValueToInt(value));\n+        }\n+\n+        value = conf.get(CONFIG_CONNECTION_RETRY);\n+        if (value != null) {\n+            tivoConfigData.setCfgNumConnRetry(convertValueToInt(value));\n+        }\n+\n+        value = conf.get(CONFIG_POLL_INTERVAL);\n+        if (value != null) {\n+            tivoConfigData.setCfgPollInterval(convertValueToInt(value));\n+        }\n+\n+        value = conf.get(CONFIG_POLL_FOR_CHANGES);\n+        if (value != null) {\n+            tivoConfigData.setCfgPollChanges(convertValueToBoolean(value));\n+        }\n+\n+        value = conf.get(CONFIG_KEEP_CONNECTION_OPEN);\n+        if (value != null) {\n+            tivoConfigData.setCfgKeepConnOpen(convertValueToBoolean(value));\n+        }\n+\n+        value = conf.get(CONFIG_CMD_WAIT_INTERVAL);\n+        if (value != null) {\n+            tivoConfigData.setCfgCmdWait(convertValueToInt(value));\n+        }\n+\n+        tivoConfigData.setCfgIdentifier(String.valueOf(getThing().getUID()));\n+        logger.debug(\"TivoConfigData Obj: '{}'\", tivoConfigData);\n+        tivoConnection = Optional.of(new TivoStatusProvider(tivoConfigData, this));\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        lastConnectionStatus = ConnectionStatus.UNKNOWN;\n+        logger.debug(\"Initializing a TiVo handler for thing '{}' - finished!\", getThing().getUID());\n+\n+        startPollStatus();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing of a TiVo handler for thing '{}'\", getThing().getUID());\n+\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null) {\n+            logger.debug(\"'{}' - Polling cancelled by dispose()\", getThing().getUID());", "originalCommit": "aa8457fa2e41b8f90f00ae89373654cbafa22e08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU1MjQzMw==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543552433", "bodyText": "You could make this a lambda.", "author": "fwolter", "createdAt": "2020-12-15T17:42:54Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/handler/TiVoHandler.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.handler;\n+\n+import static org.openhab.binding.tivo.TiVoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.internal.service.TivoConfigData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.openhab.binding.tivo.internal.service.TivoStatusProvider;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TiVoHandler} is the BaseThingHandler responsible for handling commands that are\n+ * sent to one of the Tivo's channels.\n+ *\n+ * @author Jayson Kubilis (DigitalBytes) - Initial contribution\n+ * @author Andrew Black (AndyXMB) - Updates / compilation corrections. Addition of channel scanning functionality.\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TiVoHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(TiVoHandler.class);\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+    private ConnectionStatus lastConnectionStatus = ConnectionStatus.UNKNOWN;\n+    private Optional<TivoStatusProvider> tivoConnection = Optional.empty();\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    /**\n+     * Instantiates a new TiVo handler.\n+     *\n+     * @param thing the thing\n+     */\n+    public TiVoHandler(Thing thing) {\n+        super(thing);\n+        logger.debug(\"TiVoHandler '{}' - creating\", getThing().getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Handles the commands from the various TiVo channel objects\n+        logger.debug(\"handleCommand '{}', parameter: {}\", channelUID, command);\n+\n+        if (!isInitialized() || !tivoConnection.isPresent()) {\n+            logger.debug(\"handleCommand '{}' device is not intialised yet, command '{}' will be ignored.\",\n+                    getThing().getUID(), channelUID + \" \" + command);\n+            return;\n+        }\n+\n+        TivoStatusData currentStatus = tivoConnection.get().getServiceStatus();\n+        String commandKeyword = \"\";\n+\n+        String commandParameter = command.toString().toUpperCase();\n+        if (command instanceof RefreshType) {\n+            // Future enhancement, if we can come up with a sensible set of actions when a REFRESH is issued\n+            logger.debug(\"TiVo '{}' skipping REFRESH command for channel: '{}'.\", getThing().getUID(),\n+                    channelUID.getId());\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TIVO_CHANNEL_FORCE:\n+                commandKeyword = \"FORCECH\";\n+                break;\n+            case CHANNEL_TIVO_CHANNEL_SET:\n+                commandKeyword = \"SETCH\";\n+                break;\n+            case CHANNEL_TIVO_TELEPORT:\n+                commandKeyword = \"TELEPORT\";\n+                break;\n+            case CHANNEL_TIVO_IRCMD:\n+                commandKeyword = \"IRCODE\";\n+                break;\n+            case CHANNEL_TIVO_KBDCMD:\n+                commandKeyword = \"KEYBOARD\";\n+                break;\n+        }\n+        sendCommand(commandKeyword, commandParameter, currentStatus);\n+    }\n+\n+    public void setStatusOffline() {\n+        this.updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                \"Power on device or check network configuration/connection.\");\n+    }\n+\n+    private void sendCommand(String commandKeyword, String commandParameter, TivoStatusData currentStatus) {\n+        if (!tivoConnection.isPresent()) {\n+            return;\n+        }\n+\n+        TivoStatusData deviceStatus = tivoConnection.get().getServiceStatus();\n+        TivoStatusData commandResult = null;\n+        logger.debug(\"handleCommand '{}' - {} found!\", getThing().getUID(), commandKeyword);\n+        // Re-write command keyword if we are in STANDBY, as only IRCODE TIVO will wake the unit from\n+        // standby mode\n+        if (deviceStatus.getConnectionStatus() == ConnectionStatus.STANDBY && commandKeyword.contentEquals(\"TELEPORT\")\n+                && commandParameter.contentEquals(\"TIVO\")) {\n+            commandKeyword = \"IRCODE \" + commandParameter;\n+            logger.debug(\"TiVo '{}' TELEPORT re-mapped to IRCODE as we are in standby: '{}'\", getThing().getUID(),\n+                    commandKeyword);\n+        }\n+        // Execute command\n+        if (commandKeyword.contentEquals(\"FORCECH\") || commandKeyword.contentEquals(\"SETCH\")) {\n+            commandResult = chChannelChange(commandKeyword, commandParameter);\n+        } else {\n+            commandResult = tivoConnection.get().cmdTivoSend(commandKeyword + \" \" + commandParameter);\n+        }\n+\n+        // Post processing\n+        if (commandResult != null && commandParameter.contentEquals(\"STANDBY\")) {\n+            // Force thing state into STANDBY as this command does not return a status when executed\n+            commandResult.setConnectionStatus(ConnectionStatus.STANDBY);\n+        }\n+\n+        // Push status updates\n+        if (commandResult != null && commandResult.isCmdOk()) {\n+            updateTivoStatus(currentStatus, commandResult);\n+        }\n+\n+        // disconnect once command is complete (really only disconnects if isCfgKeepConnOpen = false)\n+        tivoConnection.get().connTivoDisconnect(false);\n+    }\n+\n+    int convertValueToInt(Object value) {\n+        if (value instanceof BigDecimal) {\n+            return ((BigDecimal) value).intValue();\n+        }\n+        if (value instanceof String) {\n+            return Integer.valueOf((String) value);\n+        }\n+        if (value instanceof Double) {\n+            return ((Double) value).intValue();\n+        }\n+        return (Integer) value;\n+    }\n+\n+    boolean convertValueToBoolean(Object value) {\n+        return value instanceof Boolean ? ((Boolean) value) : Boolean.valueOf((String) value);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing a TiVo '{}' with config options\", getThing().getUID());\n+\n+        Configuration conf = this.getConfig();\n+\n+        Object value;\n+        value = conf.get(CONFIG_ADDRESS);\n+        if (value != null) {\n+            tivoConfigData.setCfgHost(String.valueOf(value));\n+        }\n+\n+        value = conf.get(CONFIG_PORT);\n+        if (value != null) {\n+            tivoConfigData.setCfgTcpPort(convertValueToInt(value));\n+        }\n+\n+        value = conf.get(CONFIG_CONNECTION_RETRY);\n+        if (value != null) {\n+            tivoConfigData.setCfgNumConnRetry(convertValueToInt(value));\n+        }\n+\n+        value = conf.get(CONFIG_POLL_INTERVAL);\n+        if (value != null) {\n+            tivoConfigData.setCfgPollInterval(convertValueToInt(value));\n+        }\n+\n+        value = conf.get(CONFIG_POLL_FOR_CHANGES);\n+        if (value != null) {\n+            tivoConfigData.setCfgPollChanges(convertValueToBoolean(value));\n+        }\n+\n+        value = conf.get(CONFIG_KEEP_CONNECTION_OPEN);\n+        if (value != null) {\n+            tivoConfigData.setCfgKeepConnOpen(convertValueToBoolean(value));\n+        }\n+\n+        value = conf.get(CONFIG_CMD_WAIT_INTERVAL);\n+        if (value != null) {\n+            tivoConfigData.setCfgCmdWait(convertValueToInt(value));\n+        }\n+\n+        tivoConfigData.setCfgIdentifier(String.valueOf(getThing().getUID()));\n+        logger.debug(\"TivoConfigData Obj: '{}'\", tivoConfigData);\n+        tivoConnection = Optional.of(new TivoStatusProvider(tivoConfigData, this));\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        lastConnectionStatus = ConnectionStatus.UNKNOWN;\n+        logger.debug(\"Initializing a TiVo handler for thing '{}' - finished!\", getThing().getUID());\n+\n+        startPollStatus();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing of a TiVo handler for thing '{}'\", getThing().getUID());\n+\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null) {\n+            logger.debug(\"'{}' - Polling cancelled by dispose()\", getThing().getUID());\n+            refreshJob.cancel(false);\n+            this.refreshJob = null;\n+        }\n+\n+        if (tivoConnection.isPresent()) {\n+            tivoConnection.get().connTivoDisconnect(true);\n+            tivoConnection = Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * {@link startPollStatus} scheduled job to poll for changes in state.\n+     */\n+    private void startPollStatus() {\n+        Runnable runnable = new Runnable() {\n+            @Override\n+            public void run() {\n+                logger.debug(\"startPollStatus '{}' @ rate of '{}' seconds\", getThing().getUID(),\n+                        tivoConfigData.getCfgPollInterval());\n+                if (tivoConnection.isPresent())\n+                    tivoConnection.get().statusRefresh();\n+            }\n+        };", "originalCommit": "aa8457fa2e41b8f90f00ae89373654cbafa22e08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU1NDU4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543554589", "bodyText": "Syntactical sugar\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (tivoConnection.isPresent())\n          \n          \n            \n                            tivoConnection.get().statusRefresh();\n          \n          \n            \n                        tivoConnection.ifPresent(TivoStatusProvider::statusRefresh);", "author": "fwolter", "createdAt": "2020-12-15T17:45:58Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/handler/TiVoHandler.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.handler;\n+\n+import static org.openhab.binding.tivo.TiVoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.internal.service.TivoConfigData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.openhab.binding.tivo.internal.service.TivoStatusProvider;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TiVoHandler} is the BaseThingHandler responsible for handling commands that are\n+ * sent to one of the Tivo's channels.\n+ *\n+ * @author Jayson Kubilis (DigitalBytes) - Initial contribution\n+ * @author Andrew Black (AndyXMB) - Updates / compilation corrections. Addition of channel scanning functionality.\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TiVoHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(TiVoHandler.class);\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+    private ConnectionStatus lastConnectionStatus = ConnectionStatus.UNKNOWN;\n+    private Optional<TivoStatusProvider> tivoConnection = Optional.empty();\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    /**\n+     * Instantiates a new TiVo handler.\n+     *\n+     * @param thing the thing\n+     */\n+    public TiVoHandler(Thing thing) {\n+        super(thing);\n+        logger.debug(\"TiVoHandler '{}' - creating\", getThing().getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Handles the commands from the various TiVo channel objects\n+        logger.debug(\"handleCommand '{}', parameter: {}\", channelUID, command);\n+\n+        if (!isInitialized() || !tivoConnection.isPresent()) {\n+            logger.debug(\"handleCommand '{}' device is not intialised yet, command '{}' will be ignored.\",\n+                    getThing().getUID(), channelUID + \" \" + command);\n+            return;\n+        }\n+\n+        TivoStatusData currentStatus = tivoConnection.get().getServiceStatus();\n+        String commandKeyword = \"\";\n+\n+        String commandParameter = command.toString().toUpperCase();\n+        if (command instanceof RefreshType) {\n+            // Future enhancement, if we can come up with a sensible set of actions when a REFRESH is issued\n+            logger.debug(\"TiVo '{}' skipping REFRESH command for channel: '{}'.\", getThing().getUID(),\n+                    channelUID.getId());\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TIVO_CHANNEL_FORCE:\n+                commandKeyword = \"FORCECH\";\n+                break;\n+            case CHANNEL_TIVO_CHANNEL_SET:\n+                commandKeyword = \"SETCH\";\n+                break;\n+            case CHANNEL_TIVO_TELEPORT:\n+                commandKeyword = \"TELEPORT\";\n+                break;\n+            case CHANNEL_TIVO_IRCMD:\n+                commandKeyword = \"IRCODE\";\n+                break;\n+            case CHANNEL_TIVO_KBDCMD:\n+                commandKeyword = \"KEYBOARD\";\n+                break;\n+        }\n+        sendCommand(commandKeyword, commandParameter, currentStatus);\n+    }\n+\n+    public void setStatusOffline() {\n+        this.updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                \"Power on device or check network configuration/connection.\");\n+    }\n+\n+    private void sendCommand(String commandKeyword, String commandParameter, TivoStatusData currentStatus) {\n+        if (!tivoConnection.isPresent()) {\n+            return;\n+        }\n+\n+        TivoStatusData deviceStatus = tivoConnection.get().getServiceStatus();\n+        TivoStatusData commandResult = null;\n+        logger.debug(\"handleCommand '{}' - {} found!\", getThing().getUID(), commandKeyword);\n+        // Re-write command keyword if we are in STANDBY, as only IRCODE TIVO will wake the unit from\n+        // standby mode\n+        if (deviceStatus.getConnectionStatus() == ConnectionStatus.STANDBY && commandKeyword.contentEquals(\"TELEPORT\")\n+                && commandParameter.contentEquals(\"TIVO\")) {\n+            commandKeyword = \"IRCODE \" + commandParameter;\n+            logger.debug(\"TiVo '{}' TELEPORT re-mapped to IRCODE as we are in standby: '{}'\", getThing().getUID(),\n+                    commandKeyword);\n+        }\n+        // Execute command\n+        if (commandKeyword.contentEquals(\"FORCECH\") || commandKeyword.contentEquals(\"SETCH\")) {\n+            commandResult = chChannelChange(commandKeyword, commandParameter);\n+        } else {\n+            commandResult = tivoConnection.get().cmdTivoSend(commandKeyword + \" \" + commandParameter);\n+        }\n+\n+        // Post processing\n+        if (commandResult != null && commandParameter.contentEquals(\"STANDBY\")) {\n+            // Force thing state into STANDBY as this command does not return a status when executed\n+            commandResult.setConnectionStatus(ConnectionStatus.STANDBY);\n+        }\n+\n+        // Push status updates\n+        if (commandResult != null && commandResult.isCmdOk()) {\n+            updateTivoStatus(currentStatus, commandResult);\n+        }\n+\n+        // disconnect once command is complete (really only disconnects if isCfgKeepConnOpen = false)\n+        tivoConnection.get().connTivoDisconnect(false);\n+    }\n+\n+    int convertValueToInt(Object value) {\n+        if (value instanceof BigDecimal) {\n+            return ((BigDecimal) value).intValue();\n+        }\n+        if (value instanceof String) {\n+            return Integer.valueOf((String) value);\n+        }\n+        if (value instanceof Double) {\n+            return ((Double) value).intValue();\n+        }\n+        return (Integer) value;\n+    }\n+\n+    boolean convertValueToBoolean(Object value) {\n+        return value instanceof Boolean ? ((Boolean) value) : Boolean.valueOf((String) value);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing a TiVo '{}' with config options\", getThing().getUID());\n+\n+        Configuration conf = this.getConfig();\n+\n+        Object value;\n+        value = conf.get(CONFIG_ADDRESS);\n+        if (value != null) {\n+            tivoConfigData.setCfgHost(String.valueOf(value));\n+        }\n+\n+        value = conf.get(CONFIG_PORT);\n+        if (value != null) {\n+            tivoConfigData.setCfgTcpPort(convertValueToInt(value));\n+        }\n+\n+        value = conf.get(CONFIG_CONNECTION_RETRY);\n+        if (value != null) {\n+            tivoConfigData.setCfgNumConnRetry(convertValueToInt(value));\n+        }\n+\n+        value = conf.get(CONFIG_POLL_INTERVAL);\n+        if (value != null) {\n+            tivoConfigData.setCfgPollInterval(convertValueToInt(value));\n+        }\n+\n+        value = conf.get(CONFIG_POLL_FOR_CHANGES);\n+        if (value != null) {\n+            tivoConfigData.setCfgPollChanges(convertValueToBoolean(value));\n+        }\n+\n+        value = conf.get(CONFIG_KEEP_CONNECTION_OPEN);\n+        if (value != null) {\n+            tivoConfigData.setCfgKeepConnOpen(convertValueToBoolean(value));\n+        }\n+\n+        value = conf.get(CONFIG_CMD_WAIT_INTERVAL);\n+        if (value != null) {\n+            tivoConfigData.setCfgCmdWait(convertValueToInt(value));\n+        }\n+\n+        tivoConfigData.setCfgIdentifier(String.valueOf(getThing().getUID()));\n+        logger.debug(\"TivoConfigData Obj: '{}'\", tivoConfigData);\n+        tivoConnection = Optional.of(new TivoStatusProvider(tivoConfigData, this));\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        lastConnectionStatus = ConnectionStatus.UNKNOWN;\n+        logger.debug(\"Initializing a TiVo handler for thing '{}' - finished!\", getThing().getUID());\n+\n+        startPollStatus();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing of a TiVo handler for thing '{}'\", getThing().getUID());\n+\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null) {\n+            logger.debug(\"'{}' - Polling cancelled by dispose()\", getThing().getUID());\n+            refreshJob.cancel(false);\n+            this.refreshJob = null;\n+        }\n+\n+        if (tivoConnection.isPresent()) {\n+            tivoConnection.get().connTivoDisconnect(true);\n+            tivoConnection = Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * {@link startPollStatus} scheduled job to poll for changes in state.\n+     */\n+    private void startPollStatus() {\n+        Runnable runnable = new Runnable() {\n+            @Override\n+            public void run() {\n+                logger.debug(\"startPollStatus '{}' @ rate of '{}' seconds\", getThing().getUID(),\n+                        tivoConfigData.getCfgPollInterval());\n+                if (tivoConnection.isPresent())\n+                    tivoConnection.get().statusRefresh();\n+            }\n+        };\n+\n+        if (tivoConfigData.isCfgKeepConnOpen()) {\n+            // Run once\n+            refreshJob = scheduler.schedule(runnable, INIT_POLLING_DELAY_S, TimeUnit.SECONDS);\n+            logger.debug(\"Status collection '{}' will start in '{}' seconds.\", getThing().getUID(),\n+                    INIT_POLLING_DELAY_S);\n+        } else if (tivoConfigData.doPollChanges()) {\n+            // Run at intervals\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, INIT_POLLING_DELAY_S,\n+                    tivoConfigData.getCfgPollInterval(), TimeUnit.SECONDS);\n+            logger.debug(\"Status polling '{}' will start in '{}' seconds.\", getThing().getUID(), INIT_POLLING_DELAY_S);\n+        } else {\n+            // Just update the status now\n+            if (tivoConnection.isPresent())\n+                tivoConnection.get().statusRefresh();", "originalCommit": "aa8457fa2e41b8f90f00ae89373654cbafa22e08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU1NTM0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543555343", "bodyText": "This will crash if the last character is a dot. Should this be handled?", "author": "fwolter", "createdAt": "2020-12-15T17:47:00Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/handler/TiVoHandler.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.handler;\n+\n+import static org.openhab.binding.tivo.TiVoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.internal.service.TivoConfigData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.openhab.binding.tivo.internal.service.TivoStatusProvider;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TiVoHandler} is the BaseThingHandler responsible for handling commands that are\n+ * sent to one of the Tivo's channels.\n+ *\n+ * @author Jayson Kubilis (DigitalBytes) - Initial contribution\n+ * @author Andrew Black (AndyXMB) - Updates / compilation corrections. Addition of channel scanning functionality.\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TiVoHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(TiVoHandler.class);\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+    private ConnectionStatus lastConnectionStatus = ConnectionStatus.UNKNOWN;\n+    private Optional<TivoStatusProvider> tivoConnection = Optional.empty();\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    /**\n+     * Instantiates a new TiVo handler.\n+     *\n+     * @param thing the thing\n+     */\n+    public TiVoHandler(Thing thing) {\n+        super(thing);\n+        logger.debug(\"TiVoHandler '{}' - creating\", getThing().getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Handles the commands from the various TiVo channel objects\n+        logger.debug(\"handleCommand '{}', parameter: {}\", channelUID, command);\n+\n+        if (!isInitialized() || !tivoConnection.isPresent()) {\n+            logger.debug(\"handleCommand '{}' device is not intialised yet, command '{}' will be ignored.\",\n+                    getThing().getUID(), channelUID + \" \" + command);\n+            return;\n+        }\n+\n+        TivoStatusData currentStatus = tivoConnection.get().getServiceStatus();\n+        String commandKeyword = \"\";\n+\n+        String commandParameter = command.toString().toUpperCase();\n+        if (command instanceof RefreshType) {\n+            // Future enhancement, if we can come up with a sensible set of actions when a REFRESH is issued\n+            logger.debug(\"TiVo '{}' skipping REFRESH command for channel: '{}'.\", getThing().getUID(),\n+                    channelUID.getId());\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TIVO_CHANNEL_FORCE:\n+                commandKeyword = \"FORCECH\";\n+                break;\n+            case CHANNEL_TIVO_CHANNEL_SET:\n+                commandKeyword = \"SETCH\";\n+                break;\n+            case CHANNEL_TIVO_TELEPORT:\n+                commandKeyword = \"TELEPORT\";\n+                break;\n+            case CHANNEL_TIVO_IRCMD:\n+                commandKeyword = \"IRCODE\";\n+                break;\n+            case CHANNEL_TIVO_KBDCMD:\n+                commandKeyword = \"KEYBOARD\";\n+                break;\n+        }\n+        sendCommand(commandKeyword, commandParameter, currentStatus);\n+    }\n+\n+    public void setStatusOffline() {\n+        this.updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                \"Power on device or check network configuration/connection.\");\n+    }\n+\n+    private void sendCommand(String commandKeyword, String commandParameter, TivoStatusData currentStatus) {\n+        if (!tivoConnection.isPresent()) {\n+            return;\n+        }\n+\n+        TivoStatusData deviceStatus = tivoConnection.get().getServiceStatus();\n+        TivoStatusData commandResult = null;\n+        logger.debug(\"handleCommand '{}' - {} found!\", getThing().getUID(), commandKeyword);\n+        // Re-write command keyword if we are in STANDBY, as only IRCODE TIVO will wake the unit from\n+        // standby mode\n+        if (deviceStatus.getConnectionStatus() == ConnectionStatus.STANDBY && commandKeyword.contentEquals(\"TELEPORT\")\n+                && commandParameter.contentEquals(\"TIVO\")) {\n+            commandKeyword = \"IRCODE \" + commandParameter;\n+            logger.debug(\"TiVo '{}' TELEPORT re-mapped to IRCODE as we are in standby: '{}'\", getThing().getUID(),\n+                    commandKeyword);\n+        }\n+        // Execute command\n+        if (commandKeyword.contentEquals(\"FORCECH\") || commandKeyword.contentEquals(\"SETCH\")) {\n+            commandResult = chChannelChange(commandKeyword, commandParameter);\n+        } else {\n+            commandResult = tivoConnection.get().cmdTivoSend(commandKeyword + \" \" + commandParameter);\n+        }\n+\n+        // Post processing\n+        if (commandResult != null && commandParameter.contentEquals(\"STANDBY\")) {\n+            // Force thing state into STANDBY as this command does not return a status when executed\n+            commandResult.setConnectionStatus(ConnectionStatus.STANDBY);\n+        }\n+\n+        // Push status updates\n+        if (commandResult != null && commandResult.isCmdOk()) {\n+            updateTivoStatus(currentStatus, commandResult);\n+        }\n+\n+        // disconnect once command is complete (really only disconnects if isCfgKeepConnOpen = false)\n+        tivoConnection.get().connTivoDisconnect(false);\n+    }\n+\n+    int convertValueToInt(Object value) {\n+        if (value instanceof BigDecimal) {\n+            return ((BigDecimal) value).intValue();\n+        }\n+        if (value instanceof String) {\n+            return Integer.valueOf((String) value);\n+        }\n+        if (value instanceof Double) {\n+            return ((Double) value).intValue();\n+        }\n+        return (Integer) value;\n+    }\n+\n+    boolean convertValueToBoolean(Object value) {\n+        return value instanceof Boolean ? ((Boolean) value) : Boolean.valueOf((String) value);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing a TiVo '{}' with config options\", getThing().getUID());\n+\n+        Configuration conf = this.getConfig();\n+\n+        Object value;\n+        value = conf.get(CONFIG_ADDRESS);\n+        if (value != null) {\n+            tivoConfigData.setCfgHost(String.valueOf(value));\n+        }\n+\n+        value = conf.get(CONFIG_PORT);\n+        if (value != null) {\n+            tivoConfigData.setCfgTcpPort(convertValueToInt(value));\n+        }\n+\n+        value = conf.get(CONFIG_CONNECTION_RETRY);\n+        if (value != null) {\n+            tivoConfigData.setCfgNumConnRetry(convertValueToInt(value));\n+        }\n+\n+        value = conf.get(CONFIG_POLL_INTERVAL);\n+        if (value != null) {\n+            tivoConfigData.setCfgPollInterval(convertValueToInt(value));\n+        }\n+\n+        value = conf.get(CONFIG_POLL_FOR_CHANGES);\n+        if (value != null) {\n+            tivoConfigData.setCfgPollChanges(convertValueToBoolean(value));\n+        }\n+\n+        value = conf.get(CONFIG_KEEP_CONNECTION_OPEN);\n+        if (value != null) {\n+            tivoConfigData.setCfgKeepConnOpen(convertValueToBoolean(value));\n+        }\n+\n+        value = conf.get(CONFIG_CMD_WAIT_INTERVAL);\n+        if (value != null) {\n+            tivoConfigData.setCfgCmdWait(convertValueToInt(value));\n+        }\n+\n+        tivoConfigData.setCfgIdentifier(String.valueOf(getThing().getUID()));\n+        logger.debug(\"TivoConfigData Obj: '{}'\", tivoConfigData);\n+        tivoConnection = Optional.of(new TivoStatusProvider(tivoConfigData, this));\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        lastConnectionStatus = ConnectionStatus.UNKNOWN;\n+        logger.debug(\"Initializing a TiVo handler for thing '{}' - finished!\", getThing().getUID());\n+\n+        startPollStatus();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing of a TiVo handler for thing '{}'\", getThing().getUID());\n+\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null) {\n+            logger.debug(\"'{}' - Polling cancelled by dispose()\", getThing().getUID());\n+            refreshJob.cancel(false);\n+            this.refreshJob = null;\n+        }\n+\n+        if (tivoConnection.isPresent()) {\n+            tivoConnection.get().connTivoDisconnect(true);\n+            tivoConnection = Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * {@link startPollStatus} scheduled job to poll for changes in state.\n+     */\n+    private void startPollStatus() {\n+        Runnable runnable = new Runnable() {\n+            @Override\n+            public void run() {\n+                logger.debug(\"startPollStatus '{}' @ rate of '{}' seconds\", getThing().getUID(),\n+                        tivoConfigData.getCfgPollInterval());\n+                if (tivoConnection.isPresent())\n+                    tivoConnection.get().statusRefresh();\n+            }\n+        };\n+\n+        if (tivoConfigData.isCfgKeepConnOpen()) {\n+            // Run once\n+            refreshJob = scheduler.schedule(runnable, INIT_POLLING_DELAY_S, TimeUnit.SECONDS);\n+            logger.debug(\"Status collection '{}' will start in '{}' seconds.\", getThing().getUID(),\n+                    INIT_POLLING_DELAY_S);\n+        } else if (tivoConfigData.doPollChanges()) {\n+            // Run at intervals\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, INIT_POLLING_DELAY_S,\n+                    tivoConfigData.getCfgPollInterval(), TimeUnit.SECONDS);\n+            logger.debug(\"Status polling '{}' will start in '{}' seconds.\", getThing().getUID(), INIT_POLLING_DELAY_S);\n+        } else {\n+            // Just update the status now\n+            if (tivoConnection.isPresent())\n+                tivoConnection.get().statusRefresh();\n+        }\n+    }\n+\n+    /**\n+     * {@link chChannelChange} performs channel changing operations.\n+     *\n+     * @param commandKeyword the TiVo command object.\n+     * @param command the command parameter.\n+     * @return TivoStatusData status of the command.\n+     */\n+    private TivoStatusData chChannelChange(String commandKeyword, String command) {\n+        int channel = -1;\n+        int subChannel = -1;\n+\n+        TivoStatusData tmpStatus = tivoConnection.get().getServiceStatus();\n+        try {\n+            // If desired channel has decimal (OTA channels), parse the sub channel number\n+            if (command.contains(\".\")) {\n+                String[] channelArray = command.split(\"\\\\.\");\n+                channel = Integer.valueOf(channelArray[0]).intValue();\n+                subChannel = Integer.valueOf(channelArray[1]).intValue();", "originalCommit": "aa8457fa2e41b8f90f00ae89373654cbafa22e08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgxMjgxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543812814", "bodyText": "The user should be sending valid channel numbers like '105' or '4.1'. I will add IndexOutOfBoundsException to the catch block below to trap it along with NumberFormatException.", "author": "mlobstein", "createdAt": "2020-12-16T01:37:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU1NTM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDExNDg1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r544114852", "bodyText": "Catching IndexOutOfBoundsException should be avoided. Better check the length beforehand.", "author": "fwolter", "createdAt": "2020-12-16T08:47:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU1NTM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4NDkzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r544684931", "bodyText": "I changed it to use a regex similar to the status parsing.", "author": "mlobstein", "createdAt": "2020-12-16T22:59:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU1NTM0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU1NjMyOA==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543556328", "bodyText": "You could throw the InterruptedException to exit the current thread fast.", "author": "fwolter", "createdAt": "2020-12-15T17:48:17Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/handler/TiVoHandler.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.handler;\n+\n+import static org.openhab.binding.tivo.TiVoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.internal.service.TivoConfigData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.openhab.binding.tivo.internal.service.TivoStatusProvider;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TiVoHandler} is the BaseThingHandler responsible for handling commands that are\n+ * sent to one of the Tivo's channels.\n+ *\n+ * @author Jayson Kubilis (DigitalBytes) - Initial contribution\n+ * @author Andrew Black (AndyXMB) - Updates / compilation corrections. Addition of channel scanning functionality.\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TiVoHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(TiVoHandler.class);\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+    private ConnectionStatus lastConnectionStatus = ConnectionStatus.UNKNOWN;\n+    private Optional<TivoStatusProvider> tivoConnection = Optional.empty();\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    /**\n+     * Instantiates a new TiVo handler.\n+     *\n+     * @param thing the thing\n+     */\n+    public TiVoHandler(Thing thing) {\n+        super(thing);\n+        logger.debug(\"TiVoHandler '{}' - creating\", getThing().getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Handles the commands from the various TiVo channel objects\n+        logger.debug(\"handleCommand '{}', parameter: {}\", channelUID, command);\n+\n+        if (!isInitialized() || !tivoConnection.isPresent()) {\n+            logger.debug(\"handleCommand '{}' device is not intialised yet, command '{}' will be ignored.\",\n+                    getThing().getUID(), channelUID + \" \" + command);\n+            return;\n+        }\n+\n+        TivoStatusData currentStatus = tivoConnection.get().getServiceStatus();\n+        String commandKeyword = \"\";\n+\n+        String commandParameter = command.toString().toUpperCase();\n+        if (command instanceof RefreshType) {\n+            // Future enhancement, if we can come up with a sensible set of actions when a REFRESH is issued\n+            logger.debug(\"TiVo '{}' skipping REFRESH command for channel: '{}'.\", getThing().getUID(),\n+                    channelUID.getId());\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TIVO_CHANNEL_FORCE:\n+                commandKeyword = \"FORCECH\";\n+                break;\n+            case CHANNEL_TIVO_CHANNEL_SET:\n+                commandKeyword = \"SETCH\";\n+                break;\n+            case CHANNEL_TIVO_TELEPORT:\n+                commandKeyword = \"TELEPORT\";\n+                break;\n+            case CHANNEL_TIVO_IRCMD:\n+                commandKeyword = \"IRCODE\";\n+                break;\n+            case CHANNEL_TIVO_KBDCMD:\n+                commandKeyword = \"KEYBOARD\";\n+                break;\n+        }\n+        sendCommand(commandKeyword, commandParameter, currentStatus);\n+    }\n+\n+    public void setStatusOffline() {\n+        this.updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                \"Power on device or check network configuration/connection.\");\n+    }\n+\n+    private void sendCommand(String commandKeyword, String commandParameter, TivoStatusData currentStatus) {\n+        if (!tivoConnection.isPresent()) {\n+            return;\n+        }\n+\n+        TivoStatusData deviceStatus = tivoConnection.get().getServiceStatus();\n+        TivoStatusData commandResult = null;\n+        logger.debug(\"handleCommand '{}' - {} found!\", getThing().getUID(), commandKeyword);\n+        // Re-write command keyword if we are in STANDBY, as only IRCODE TIVO will wake the unit from\n+        // standby mode\n+        if (deviceStatus.getConnectionStatus() == ConnectionStatus.STANDBY && commandKeyword.contentEquals(\"TELEPORT\")\n+                && commandParameter.contentEquals(\"TIVO\")) {\n+            commandKeyword = \"IRCODE \" + commandParameter;\n+            logger.debug(\"TiVo '{}' TELEPORT re-mapped to IRCODE as we are in standby: '{}'\", getThing().getUID(),\n+                    commandKeyword);\n+        }\n+        // Execute command\n+        if (commandKeyword.contentEquals(\"FORCECH\") || commandKeyword.contentEquals(\"SETCH\")) {\n+            commandResult = chChannelChange(commandKeyword, commandParameter);\n+        } else {\n+            commandResult = tivoConnection.get().cmdTivoSend(commandKeyword + \" \" + commandParameter);\n+        }\n+\n+        // Post processing\n+        if (commandResult != null && commandParameter.contentEquals(\"STANDBY\")) {\n+            // Force thing state into STANDBY as this command does not return a status when executed\n+            commandResult.setConnectionStatus(ConnectionStatus.STANDBY);\n+        }\n+\n+        // Push status updates\n+        if (commandResult != null && commandResult.isCmdOk()) {\n+            updateTivoStatus(currentStatus, commandResult);\n+        }\n+\n+        // disconnect once command is complete (really only disconnects if isCfgKeepConnOpen = false)\n+        tivoConnection.get().connTivoDisconnect(false);\n+    }\n+\n+    int convertValueToInt(Object value) {\n+        if (value instanceof BigDecimal) {\n+            return ((BigDecimal) value).intValue();\n+        }\n+        if (value instanceof String) {\n+            return Integer.valueOf((String) value);\n+        }\n+        if (value instanceof Double) {\n+            return ((Double) value).intValue();\n+        }\n+        return (Integer) value;\n+    }\n+\n+    boolean convertValueToBoolean(Object value) {\n+        return value instanceof Boolean ? ((Boolean) value) : Boolean.valueOf((String) value);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing a TiVo '{}' with config options\", getThing().getUID());\n+\n+        Configuration conf = this.getConfig();\n+\n+        Object value;\n+        value = conf.get(CONFIG_ADDRESS);\n+        if (value != null) {\n+            tivoConfigData.setCfgHost(String.valueOf(value));\n+        }\n+\n+        value = conf.get(CONFIG_PORT);\n+        if (value != null) {\n+            tivoConfigData.setCfgTcpPort(convertValueToInt(value));\n+        }\n+\n+        value = conf.get(CONFIG_CONNECTION_RETRY);\n+        if (value != null) {\n+            tivoConfigData.setCfgNumConnRetry(convertValueToInt(value));\n+        }\n+\n+        value = conf.get(CONFIG_POLL_INTERVAL);\n+        if (value != null) {\n+            tivoConfigData.setCfgPollInterval(convertValueToInt(value));\n+        }\n+\n+        value = conf.get(CONFIG_POLL_FOR_CHANGES);\n+        if (value != null) {\n+            tivoConfigData.setCfgPollChanges(convertValueToBoolean(value));\n+        }\n+\n+        value = conf.get(CONFIG_KEEP_CONNECTION_OPEN);\n+        if (value != null) {\n+            tivoConfigData.setCfgKeepConnOpen(convertValueToBoolean(value));\n+        }\n+\n+        value = conf.get(CONFIG_CMD_WAIT_INTERVAL);\n+        if (value != null) {\n+            tivoConfigData.setCfgCmdWait(convertValueToInt(value));\n+        }\n+\n+        tivoConfigData.setCfgIdentifier(String.valueOf(getThing().getUID()));\n+        logger.debug(\"TivoConfigData Obj: '{}'\", tivoConfigData);\n+        tivoConnection = Optional.of(new TivoStatusProvider(tivoConfigData, this));\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        lastConnectionStatus = ConnectionStatus.UNKNOWN;\n+        logger.debug(\"Initializing a TiVo handler for thing '{}' - finished!\", getThing().getUID());\n+\n+        startPollStatus();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing of a TiVo handler for thing '{}'\", getThing().getUID());\n+\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null) {\n+            logger.debug(\"'{}' - Polling cancelled by dispose()\", getThing().getUID());\n+            refreshJob.cancel(false);\n+            this.refreshJob = null;\n+        }\n+\n+        if (tivoConnection.isPresent()) {\n+            tivoConnection.get().connTivoDisconnect(true);\n+            tivoConnection = Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * {@link startPollStatus} scheduled job to poll for changes in state.\n+     */\n+    private void startPollStatus() {\n+        Runnable runnable = new Runnable() {\n+            @Override\n+            public void run() {\n+                logger.debug(\"startPollStatus '{}' @ rate of '{}' seconds\", getThing().getUID(),\n+                        tivoConfigData.getCfgPollInterval());\n+                if (tivoConnection.isPresent())\n+                    tivoConnection.get().statusRefresh();\n+            }\n+        };\n+\n+        if (tivoConfigData.isCfgKeepConnOpen()) {\n+            // Run once\n+            refreshJob = scheduler.schedule(runnable, INIT_POLLING_DELAY_S, TimeUnit.SECONDS);\n+            logger.debug(\"Status collection '{}' will start in '{}' seconds.\", getThing().getUID(),\n+                    INIT_POLLING_DELAY_S);\n+        } else if (tivoConfigData.doPollChanges()) {\n+            // Run at intervals\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, INIT_POLLING_DELAY_S,\n+                    tivoConfigData.getCfgPollInterval(), TimeUnit.SECONDS);\n+            logger.debug(\"Status polling '{}' will start in '{}' seconds.\", getThing().getUID(), INIT_POLLING_DELAY_S);\n+        } else {\n+            // Just update the status now\n+            if (tivoConnection.isPresent())\n+                tivoConnection.get().statusRefresh();\n+        }\n+    }\n+\n+    /**\n+     * {@link chChannelChange} performs channel changing operations.\n+     *\n+     * @param commandKeyword the TiVo command object.\n+     * @param command the command parameter.\n+     * @return TivoStatusData status of the command.\n+     */\n+    private TivoStatusData chChannelChange(String commandKeyword, String command) {\n+        int channel = -1;\n+        int subChannel = -1;\n+\n+        TivoStatusData tmpStatus = tivoConnection.get().getServiceStatus();\n+        try {\n+            // If desired channel has decimal (OTA channels), parse the sub channel number\n+            if (command.contains(\".\")) {\n+                String[] channelArray = command.split(\"\\\\.\");\n+                channel = Integer.valueOf(channelArray[0]).intValue();\n+                subChannel = Integer.valueOf(channelArray[1]).intValue();\n+            } else {\n+                channel = Integer.valueOf(command.toString()).intValue();\n+            }\n+\n+            String tmpCommand = commandKeyword + \" \" + channel + ((subChannel != -1) ? (\" \" + subChannel) : \"\");\n+            logger.debug(\"chChannelChange '{}' sending command to tivo: '{}'\", getThing().getUID(), tmpCommand);\n+\n+            // Attempt to execute the command on the tivo\n+            tivoConnection.get().cmdTivoSend(tmpCommand);\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(tivoConfigData.getCfgCmdWait() * 2);\n+            } catch (Exception e) {\n+            }", "originalCommit": "aa8457fa2e41b8f90f00ae89373654cbafa22e08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg0NTEzNg==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543845136", "bodyText": "I am not sure that I understand. I should catch InterruptedException instead of the generic Exception here.", "author": "mlobstein", "createdAt": "2020-12-16T02:34:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU1NjMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDExNjM4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r544116381", "bodyText": "Yes, but only if it's reasonable to catch it. It might be better to not catch it here to have more control over the thread finishing.", "author": "fwolter", "createdAt": "2020-12-16T08:49:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU1NjMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4NzI2MA==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r544687260", "bodyText": "It is a checked exception so it has to be caught somewhere. I think the intent of the catch was to just discard the exception. If it is not caught, this method and everything upstream would have to have a thows added.", "author": "mlobstein", "createdAt": "2020-12-16T23:04:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU1NjMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkzODk1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r544938953", "bodyText": "You're completely right. The goal is to exit the current program flow at the shortest path, when an InterruptedException raises (aka OH is being stopped). So, a good approach is to throw the InterruptedException and catch it at the highest level you can. To achieve this, you need to declare throws.", "author": "fwolter", "createdAt": "2020-12-17T09:29:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU1NjMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ4MTU4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r545481583", "bodyText": "OK, I changed it to throw InterruptedException up to the overridden methods in the handler.", "author": "mlobstein", "createdAt": "2020-12-17T23:52:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU1NjMyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU1Nzc3OA==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543557778", "bodyText": "INITIALIZING must not be set by a binding. This could be OFFLINE.", "author": "fwolter", "createdAt": "2020-12-15T17:50:18Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/handler/TiVoHandler.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.handler;\n+\n+import static org.openhab.binding.tivo.TiVoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.internal.service.TivoConfigData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.openhab.binding.tivo.internal.service.TivoStatusProvider;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TiVoHandler} is the BaseThingHandler responsible for handling commands that are\n+ * sent to one of the Tivo's channels.\n+ *\n+ * @author Jayson Kubilis (DigitalBytes) - Initial contribution\n+ * @author Andrew Black (AndyXMB) - Updates / compilation corrections. Addition of channel scanning functionality.\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TiVoHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(TiVoHandler.class);\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+    private ConnectionStatus lastConnectionStatus = ConnectionStatus.UNKNOWN;\n+    private Optional<TivoStatusProvider> tivoConnection = Optional.empty();\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    /**\n+     * Instantiates a new TiVo handler.\n+     *\n+     * @param thing the thing\n+     */\n+    public TiVoHandler(Thing thing) {\n+        super(thing);\n+        logger.debug(\"TiVoHandler '{}' - creating\", getThing().getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Handles the commands from the various TiVo channel objects\n+        logger.debug(\"handleCommand '{}', parameter: {}\", channelUID, command);\n+\n+        if (!isInitialized() || !tivoConnection.isPresent()) {\n+            logger.debug(\"handleCommand '{}' device is not intialised yet, command '{}' will be ignored.\",\n+                    getThing().getUID(), channelUID + \" \" + command);\n+            return;\n+        }\n+\n+        TivoStatusData currentStatus = tivoConnection.get().getServiceStatus();\n+        String commandKeyword = \"\";\n+\n+        String commandParameter = command.toString().toUpperCase();\n+        if (command instanceof RefreshType) {\n+            // Future enhancement, if we can come up with a sensible set of actions when a REFRESH is issued\n+            logger.debug(\"TiVo '{}' skipping REFRESH command for channel: '{}'.\", getThing().getUID(),\n+                    channelUID.getId());\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TIVO_CHANNEL_FORCE:\n+                commandKeyword = \"FORCECH\";\n+                break;\n+            case CHANNEL_TIVO_CHANNEL_SET:\n+                commandKeyword = \"SETCH\";\n+                break;\n+            case CHANNEL_TIVO_TELEPORT:\n+                commandKeyword = \"TELEPORT\";\n+                break;\n+            case CHANNEL_TIVO_IRCMD:\n+                commandKeyword = \"IRCODE\";\n+                break;\n+            case CHANNEL_TIVO_KBDCMD:\n+                commandKeyword = \"KEYBOARD\";\n+                break;\n+        }\n+        sendCommand(commandKeyword, commandParameter, currentStatus);\n+    }\n+\n+    public void setStatusOffline() {\n+        this.updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                \"Power on device or check network configuration/connection.\");\n+    }\n+\n+    private void sendCommand(String commandKeyword, String commandParameter, TivoStatusData currentStatus) {\n+        if (!tivoConnection.isPresent()) {\n+            return;\n+        }\n+\n+        TivoStatusData deviceStatus = tivoConnection.get().getServiceStatus();\n+        TivoStatusData commandResult = null;\n+        logger.debug(\"handleCommand '{}' - {} found!\", getThing().getUID(), commandKeyword);\n+        // Re-write command keyword if we are in STANDBY, as only IRCODE TIVO will wake the unit from\n+        // standby mode\n+        if (deviceStatus.getConnectionStatus() == ConnectionStatus.STANDBY && commandKeyword.contentEquals(\"TELEPORT\")\n+                && commandParameter.contentEquals(\"TIVO\")) {\n+            commandKeyword = \"IRCODE \" + commandParameter;\n+            logger.debug(\"TiVo '{}' TELEPORT re-mapped to IRCODE as we are in standby: '{}'\", getThing().getUID(),\n+                    commandKeyword);\n+        }\n+        // Execute command\n+        if (commandKeyword.contentEquals(\"FORCECH\") || commandKeyword.contentEquals(\"SETCH\")) {\n+            commandResult = chChannelChange(commandKeyword, commandParameter);\n+        } else {\n+            commandResult = tivoConnection.get().cmdTivoSend(commandKeyword + \" \" + commandParameter);\n+        }\n+\n+        // Post processing\n+        if (commandResult != null && commandParameter.contentEquals(\"STANDBY\")) {\n+            // Force thing state into STANDBY as this command does not return a status when executed\n+            commandResult.setConnectionStatus(ConnectionStatus.STANDBY);\n+        }\n+\n+        // Push status updates\n+        if (commandResult != null && commandResult.isCmdOk()) {\n+            updateTivoStatus(currentStatus, commandResult);\n+        }\n+\n+        // disconnect once command is complete (really only disconnects if isCfgKeepConnOpen = false)\n+        tivoConnection.get().connTivoDisconnect(false);\n+    }\n+\n+    int convertValueToInt(Object value) {\n+        if (value instanceof BigDecimal) {\n+            return ((BigDecimal) value).intValue();\n+        }\n+        if (value instanceof String) {\n+            return Integer.valueOf((String) value);\n+        }\n+        if (value instanceof Double) {\n+            return ((Double) value).intValue();\n+        }\n+        return (Integer) value;\n+    }\n+\n+    boolean convertValueToBoolean(Object value) {\n+        return value instanceof Boolean ? ((Boolean) value) : Boolean.valueOf((String) value);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing a TiVo '{}' with config options\", getThing().getUID());\n+\n+        Configuration conf = this.getConfig();\n+\n+        Object value;\n+        value = conf.get(CONFIG_ADDRESS);\n+        if (value != null) {\n+            tivoConfigData.setCfgHost(String.valueOf(value));\n+        }\n+\n+        value = conf.get(CONFIG_PORT);\n+        if (value != null) {\n+            tivoConfigData.setCfgTcpPort(convertValueToInt(value));\n+        }\n+\n+        value = conf.get(CONFIG_CONNECTION_RETRY);\n+        if (value != null) {\n+            tivoConfigData.setCfgNumConnRetry(convertValueToInt(value));\n+        }\n+\n+        value = conf.get(CONFIG_POLL_INTERVAL);\n+        if (value != null) {\n+            tivoConfigData.setCfgPollInterval(convertValueToInt(value));\n+        }\n+\n+        value = conf.get(CONFIG_POLL_FOR_CHANGES);\n+        if (value != null) {\n+            tivoConfigData.setCfgPollChanges(convertValueToBoolean(value));\n+        }\n+\n+        value = conf.get(CONFIG_KEEP_CONNECTION_OPEN);\n+        if (value != null) {\n+            tivoConfigData.setCfgKeepConnOpen(convertValueToBoolean(value));\n+        }\n+\n+        value = conf.get(CONFIG_CMD_WAIT_INTERVAL);\n+        if (value != null) {\n+            tivoConfigData.setCfgCmdWait(convertValueToInt(value));\n+        }\n+\n+        tivoConfigData.setCfgIdentifier(String.valueOf(getThing().getUID()));\n+        logger.debug(\"TivoConfigData Obj: '{}'\", tivoConfigData);\n+        tivoConnection = Optional.of(new TivoStatusProvider(tivoConfigData, this));\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        lastConnectionStatus = ConnectionStatus.UNKNOWN;\n+        logger.debug(\"Initializing a TiVo handler for thing '{}' - finished!\", getThing().getUID());\n+\n+        startPollStatus();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing of a TiVo handler for thing '{}'\", getThing().getUID());\n+\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null) {\n+            logger.debug(\"'{}' - Polling cancelled by dispose()\", getThing().getUID());\n+            refreshJob.cancel(false);\n+            this.refreshJob = null;\n+        }\n+\n+        if (tivoConnection.isPresent()) {\n+            tivoConnection.get().connTivoDisconnect(true);\n+            tivoConnection = Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * {@link startPollStatus} scheduled job to poll for changes in state.\n+     */\n+    private void startPollStatus() {\n+        Runnable runnable = new Runnable() {\n+            @Override\n+            public void run() {\n+                logger.debug(\"startPollStatus '{}' @ rate of '{}' seconds\", getThing().getUID(),\n+                        tivoConfigData.getCfgPollInterval());\n+                if (tivoConnection.isPresent())\n+                    tivoConnection.get().statusRefresh();\n+            }\n+        };\n+\n+        if (tivoConfigData.isCfgKeepConnOpen()) {\n+            // Run once\n+            refreshJob = scheduler.schedule(runnable, INIT_POLLING_DELAY_S, TimeUnit.SECONDS);\n+            logger.debug(\"Status collection '{}' will start in '{}' seconds.\", getThing().getUID(),\n+                    INIT_POLLING_DELAY_S);\n+        } else if (tivoConfigData.doPollChanges()) {\n+            // Run at intervals\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, INIT_POLLING_DELAY_S,\n+                    tivoConfigData.getCfgPollInterval(), TimeUnit.SECONDS);\n+            logger.debug(\"Status polling '{}' will start in '{}' seconds.\", getThing().getUID(), INIT_POLLING_DELAY_S);\n+        } else {\n+            // Just update the status now\n+            if (tivoConnection.isPresent())\n+                tivoConnection.get().statusRefresh();\n+        }\n+    }\n+\n+    /**\n+     * {@link chChannelChange} performs channel changing operations.\n+     *\n+     * @param commandKeyword the TiVo command object.\n+     * @param command the command parameter.\n+     * @return TivoStatusData status of the command.\n+     */\n+    private TivoStatusData chChannelChange(String commandKeyword, String command) {\n+        int channel = -1;\n+        int subChannel = -1;\n+\n+        TivoStatusData tmpStatus = tivoConnection.get().getServiceStatus();\n+        try {\n+            // If desired channel has decimal (OTA channels), parse the sub channel number\n+            if (command.contains(\".\")) {\n+                String[] channelArray = command.split(\"\\\\.\");\n+                channel = Integer.valueOf(channelArray[0]).intValue();\n+                subChannel = Integer.valueOf(channelArray[1]).intValue();\n+            } else {\n+                channel = Integer.valueOf(command.toString()).intValue();\n+            }\n+\n+            String tmpCommand = commandKeyword + \" \" + channel + ((subChannel != -1) ? (\" \" + subChannel) : \"\");\n+            logger.debug(\"chChannelChange '{}' sending command to tivo: '{}'\", getThing().getUID(), tmpCommand);\n+\n+            // Attempt to execute the command on the tivo\n+            tivoConnection.get().cmdTivoSend(tmpCommand);\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(tivoConfigData.getCfgCmdWait() * 2);\n+            } catch (Exception e) {\n+            }\n+\n+            tmpStatus = tivoConnection.get().getServiceStatus();\n+\n+            // Check to see if the command was successful\n+            if (tmpStatus.getConnectionStatus() != ConnectionStatus.INIT && tmpStatus.isCmdOk()) {\n+                if (tmpStatus.getMsg().contains(\"CH_STATUS\")) {\n+                    return tmpStatus;\n+                }\n+            } else if (tmpStatus.getConnectionStatus() != ConnectionStatus.INIT) {\n+                logger.warn(\"TiVo'{}' set channel command failed '{}' with msg '{}'\", getThing().getUID(), tmpCommand,\n+                        tmpStatus.getMsg());\n+                switch (tmpStatus.getMsg()) {\n+                    case \"CH_FAILED NO_LIVE\":\n+                        tmpStatus.setChannelNum(channel);\n+                        tmpStatus.setSubChannelNum(subChannel);\n+                        return tmpStatus;\n+                    case \"CH_FAILED RECORDING\":\n+                        return tmpStatus;\n+                    case \"CH_FAILED MISSING_CHANNEL\":\n+                        return tmpStatus;\n+                    case \"CH_FAILED MALFORMED_CHANNEL\":\n+                        return tmpStatus;\n+                    case \"CH_FAILED INVALID_CHANNEL\":\n+                        return tmpStatus;\n+                    case \"NO_STATUS_DATA_RETURNED\":\n+                        tmpStatus.setChannelNum(-1);\n+                        tmpStatus.setSubChannelNum(-1);\n+                        tmpStatus.setRecording(false);\n+                        return tmpStatus;\n+                }\n+            }\n+\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"TiVo'{}' unable to parse channel integer from CHANNEL_TIVO_CHANNEL: '{}'\", getThing().getUID(),\n+                    command.toString());\n+        }\n+        return tmpStatus;\n+    }\n+\n+    /**\n+     * {@link updateTivoStatus} populates the items with the status / channel information.\n+     *\n+     * @param tivoStatusData the {@link TivoStatusData}\n+     */\n+    public void updateTivoStatus(TivoStatusData oldStatusData, TivoStatusData newStatusData) {\n+        if (newStatusData.getConnectionStatus() != ConnectionStatus.INIT) {\n+            // Update Item Status\n+            if (newStatusData.getPubToUI()) {\n+                if (oldStatusData.getConnectionStatus() == ConnectionStatus.INIT\n+                        || !(oldStatusData.getMsg().contentEquals(newStatusData.getMsg()))) {\n+                    updateState(CHANNEL_TIVO_STATUS, new StringType(newStatusData.getMsg()));\n+                }\n+                // If the cmd was successful, publish the channel channel numbers\n+                if (newStatusData.isCmdOk() && newStatusData.getChannelNum() != -1) {\n+                    if (oldStatusData.getConnectionStatus() == ConnectionStatus.INIT\n+                            || oldStatusData.getChannelNum() != newStatusData.getChannelNum()\n+                            || oldStatusData.getSubChannelNum() != newStatusData.getSubChannelNum()) {\n+                        if (newStatusData.getSubChannelNum() == -1) {\n+                            updateState(CHANNEL_TIVO_CHANNEL_FORCE, new DecimalType(newStatusData.getChannelNum()));\n+                            updateState(CHANNEL_TIVO_CHANNEL_SET, new DecimalType(newStatusData.getChannelNum()));\n+                        } else {\n+                            updateState(CHANNEL_TIVO_CHANNEL_FORCE, new DecimalType(\n+                                    newStatusData.getChannelNum() + \".\" + newStatusData.getSubChannelNum()));\n+                            updateState(CHANNEL_TIVO_CHANNEL_SET, new DecimalType(\n+                                    newStatusData.getChannelNum() + \".\" + newStatusData.getSubChannelNum()));\n+                        }\n+                    }\n+                    updateState(CHANNEL_TIVO_IS_RECORDING, newStatusData.isRecording() ? OnOffType.ON : OnOffType.OFF);\n+                }\n+\n+                // Now set the pubToUI flag to false, as we have already published this status\n+                if (isLinked(CHANNEL_TIVO_STATUS) || isLinked(CHANNEL_TIVO_CHANNEL_FORCE)\n+                        || isLinked(CHANNEL_TIVO_CHANNEL_SET)) {\n+                    newStatusData.setPubToUI(false);\n+                    tivoConnection.get().setServiceStatus(newStatusData);\n+                }\n+            }\n+\n+            // Update Thing status\n+            if (newStatusData.getConnectionStatus() != lastConnectionStatus) {\n+                switch (newStatusData.getConnectionStatus()) {\n+                    case OFFLINE:\n+                        this.setStatusOffline();\n+                        break;\n+                    case ONLINE:\n+                        updateStatus(ThingStatus.ONLINE);\n+                        break;\n+                    case STANDBY:\n+                        updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                                \"STANDBY MODE: Send command TIVO to Remote Control Button (IRCODE) item to wakeup.\");\n+                        break;\n+                    case UNKNOWN:\n+                        updateStatus(ThingStatus.INITIALIZING);", "originalCommit": "aa8457fa2e41b8f90f00ae89373654cbafa22e08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU1ODY2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543558666", "bodyText": "ONLINE has no status message. See https://www.openhab.org/docs/concepts/things.html#status-details", "author": "fwolter", "createdAt": "2020-12-15T17:51:31Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/handler/TiVoHandler.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.handler;\n+\n+import static org.openhab.binding.tivo.TiVoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.internal.service.TivoConfigData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.openhab.binding.tivo.internal.service.TivoStatusProvider;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TiVoHandler} is the BaseThingHandler responsible for handling commands that are\n+ * sent to one of the Tivo's channels.\n+ *\n+ * @author Jayson Kubilis (DigitalBytes) - Initial contribution\n+ * @author Andrew Black (AndyXMB) - Updates / compilation corrections. Addition of channel scanning functionality.\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TiVoHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(TiVoHandler.class);\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+    private ConnectionStatus lastConnectionStatus = ConnectionStatus.UNKNOWN;\n+    private Optional<TivoStatusProvider> tivoConnection = Optional.empty();\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    /**\n+     * Instantiates a new TiVo handler.\n+     *\n+     * @param thing the thing\n+     */\n+    public TiVoHandler(Thing thing) {\n+        super(thing);\n+        logger.debug(\"TiVoHandler '{}' - creating\", getThing().getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Handles the commands from the various TiVo channel objects\n+        logger.debug(\"handleCommand '{}', parameter: {}\", channelUID, command);\n+\n+        if (!isInitialized() || !tivoConnection.isPresent()) {\n+            logger.debug(\"handleCommand '{}' device is not intialised yet, command '{}' will be ignored.\",\n+                    getThing().getUID(), channelUID + \" \" + command);\n+            return;\n+        }\n+\n+        TivoStatusData currentStatus = tivoConnection.get().getServiceStatus();\n+        String commandKeyword = \"\";\n+\n+        String commandParameter = command.toString().toUpperCase();\n+        if (command instanceof RefreshType) {\n+            // Future enhancement, if we can come up with a sensible set of actions when a REFRESH is issued\n+            logger.debug(\"TiVo '{}' skipping REFRESH command for channel: '{}'.\", getThing().getUID(),\n+                    channelUID.getId());\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TIVO_CHANNEL_FORCE:\n+                commandKeyword = \"FORCECH\";\n+                break;\n+            case CHANNEL_TIVO_CHANNEL_SET:\n+                commandKeyword = \"SETCH\";\n+                break;\n+            case CHANNEL_TIVO_TELEPORT:\n+                commandKeyword = \"TELEPORT\";\n+                break;\n+            case CHANNEL_TIVO_IRCMD:\n+                commandKeyword = \"IRCODE\";\n+                break;\n+            case CHANNEL_TIVO_KBDCMD:\n+                commandKeyword = \"KEYBOARD\";\n+                break;\n+        }\n+        sendCommand(commandKeyword, commandParameter, currentStatus);\n+    }\n+\n+    public void setStatusOffline() {\n+        this.updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                \"Power on device or check network configuration/connection.\");\n+    }\n+\n+    private void sendCommand(String commandKeyword, String commandParameter, TivoStatusData currentStatus) {\n+        if (!tivoConnection.isPresent()) {\n+            return;\n+        }\n+\n+        TivoStatusData deviceStatus = tivoConnection.get().getServiceStatus();\n+        TivoStatusData commandResult = null;\n+        logger.debug(\"handleCommand '{}' - {} found!\", getThing().getUID(), commandKeyword);\n+        // Re-write command keyword if we are in STANDBY, as only IRCODE TIVO will wake the unit from\n+        // standby mode\n+        if (deviceStatus.getConnectionStatus() == ConnectionStatus.STANDBY && commandKeyword.contentEquals(\"TELEPORT\")\n+                && commandParameter.contentEquals(\"TIVO\")) {\n+            commandKeyword = \"IRCODE \" + commandParameter;\n+            logger.debug(\"TiVo '{}' TELEPORT re-mapped to IRCODE as we are in standby: '{}'\", getThing().getUID(),\n+                    commandKeyword);\n+        }\n+        // Execute command\n+        if (commandKeyword.contentEquals(\"FORCECH\") || commandKeyword.contentEquals(\"SETCH\")) {\n+            commandResult = chChannelChange(commandKeyword, commandParameter);\n+        } else {\n+            commandResult = tivoConnection.get().cmdTivoSend(commandKeyword + \" \" + commandParameter);\n+        }\n+\n+        // Post processing\n+        if (commandResult != null && commandParameter.contentEquals(\"STANDBY\")) {\n+            // Force thing state into STANDBY as this command does not return a status when executed\n+            commandResult.setConnectionStatus(ConnectionStatus.STANDBY);\n+        }\n+\n+        // Push status updates\n+        if (commandResult != null && commandResult.isCmdOk()) {\n+            updateTivoStatus(currentStatus, commandResult);\n+        }\n+\n+        // disconnect once command is complete (really only disconnects if isCfgKeepConnOpen = false)\n+        tivoConnection.get().connTivoDisconnect(false);\n+    }\n+\n+    int convertValueToInt(Object value) {\n+        if (value instanceof BigDecimal) {\n+            return ((BigDecimal) value).intValue();\n+        }\n+        if (value instanceof String) {\n+            return Integer.valueOf((String) value);\n+        }\n+        if (value instanceof Double) {\n+            return ((Double) value).intValue();\n+        }\n+        return (Integer) value;\n+    }\n+\n+    boolean convertValueToBoolean(Object value) {\n+        return value instanceof Boolean ? ((Boolean) value) : Boolean.valueOf((String) value);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing a TiVo '{}' with config options\", getThing().getUID());\n+\n+        Configuration conf = this.getConfig();\n+\n+        Object value;\n+        value = conf.get(CONFIG_ADDRESS);\n+        if (value != null) {\n+            tivoConfigData.setCfgHost(String.valueOf(value));\n+        }\n+\n+        value = conf.get(CONFIG_PORT);\n+        if (value != null) {\n+            tivoConfigData.setCfgTcpPort(convertValueToInt(value));\n+        }\n+\n+        value = conf.get(CONFIG_CONNECTION_RETRY);\n+        if (value != null) {\n+            tivoConfigData.setCfgNumConnRetry(convertValueToInt(value));\n+        }\n+\n+        value = conf.get(CONFIG_POLL_INTERVAL);\n+        if (value != null) {\n+            tivoConfigData.setCfgPollInterval(convertValueToInt(value));\n+        }\n+\n+        value = conf.get(CONFIG_POLL_FOR_CHANGES);\n+        if (value != null) {\n+            tivoConfigData.setCfgPollChanges(convertValueToBoolean(value));\n+        }\n+\n+        value = conf.get(CONFIG_KEEP_CONNECTION_OPEN);\n+        if (value != null) {\n+            tivoConfigData.setCfgKeepConnOpen(convertValueToBoolean(value));\n+        }\n+\n+        value = conf.get(CONFIG_CMD_WAIT_INTERVAL);\n+        if (value != null) {\n+            tivoConfigData.setCfgCmdWait(convertValueToInt(value));\n+        }\n+\n+        tivoConfigData.setCfgIdentifier(String.valueOf(getThing().getUID()));\n+        logger.debug(\"TivoConfigData Obj: '{}'\", tivoConfigData);\n+        tivoConnection = Optional.of(new TivoStatusProvider(tivoConfigData, this));\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        lastConnectionStatus = ConnectionStatus.UNKNOWN;\n+        logger.debug(\"Initializing a TiVo handler for thing '{}' - finished!\", getThing().getUID());\n+\n+        startPollStatus();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing of a TiVo handler for thing '{}'\", getThing().getUID());\n+\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null) {\n+            logger.debug(\"'{}' - Polling cancelled by dispose()\", getThing().getUID());\n+            refreshJob.cancel(false);\n+            this.refreshJob = null;\n+        }\n+\n+        if (tivoConnection.isPresent()) {\n+            tivoConnection.get().connTivoDisconnect(true);\n+            tivoConnection = Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * {@link startPollStatus} scheduled job to poll for changes in state.\n+     */\n+    private void startPollStatus() {\n+        Runnable runnable = new Runnable() {\n+            @Override\n+            public void run() {\n+                logger.debug(\"startPollStatus '{}' @ rate of '{}' seconds\", getThing().getUID(),\n+                        tivoConfigData.getCfgPollInterval());\n+                if (tivoConnection.isPresent())\n+                    tivoConnection.get().statusRefresh();\n+            }\n+        };\n+\n+        if (tivoConfigData.isCfgKeepConnOpen()) {\n+            // Run once\n+            refreshJob = scheduler.schedule(runnable, INIT_POLLING_DELAY_S, TimeUnit.SECONDS);\n+            logger.debug(\"Status collection '{}' will start in '{}' seconds.\", getThing().getUID(),\n+                    INIT_POLLING_DELAY_S);\n+        } else if (tivoConfigData.doPollChanges()) {\n+            // Run at intervals\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, INIT_POLLING_DELAY_S,\n+                    tivoConfigData.getCfgPollInterval(), TimeUnit.SECONDS);\n+            logger.debug(\"Status polling '{}' will start in '{}' seconds.\", getThing().getUID(), INIT_POLLING_DELAY_S);\n+        } else {\n+            // Just update the status now\n+            if (tivoConnection.isPresent())\n+                tivoConnection.get().statusRefresh();\n+        }\n+    }\n+\n+    /**\n+     * {@link chChannelChange} performs channel changing operations.\n+     *\n+     * @param commandKeyword the TiVo command object.\n+     * @param command the command parameter.\n+     * @return TivoStatusData status of the command.\n+     */\n+    private TivoStatusData chChannelChange(String commandKeyword, String command) {\n+        int channel = -1;\n+        int subChannel = -1;\n+\n+        TivoStatusData tmpStatus = tivoConnection.get().getServiceStatus();\n+        try {\n+            // If desired channel has decimal (OTA channels), parse the sub channel number\n+            if (command.contains(\".\")) {\n+                String[] channelArray = command.split(\"\\\\.\");\n+                channel = Integer.valueOf(channelArray[0]).intValue();\n+                subChannel = Integer.valueOf(channelArray[1]).intValue();\n+            } else {\n+                channel = Integer.valueOf(command.toString()).intValue();\n+            }\n+\n+            String tmpCommand = commandKeyword + \" \" + channel + ((subChannel != -1) ? (\" \" + subChannel) : \"\");\n+            logger.debug(\"chChannelChange '{}' sending command to tivo: '{}'\", getThing().getUID(), tmpCommand);\n+\n+            // Attempt to execute the command on the tivo\n+            tivoConnection.get().cmdTivoSend(tmpCommand);\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(tivoConfigData.getCfgCmdWait() * 2);\n+            } catch (Exception e) {\n+            }\n+\n+            tmpStatus = tivoConnection.get().getServiceStatus();\n+\n+            // Check to see if the command was successful\n+            if (tmpStatus.getConnectionStatus() != ConnectionStatus.INIT && tmpStatus.isCmdOk()) {\n+                if (tmpStatus.getMsg().contains(\"CH_STATUS\")) {\n+                    return tmpStatus;\n+                }\n+            } else if (tmpStatus.getConnectionStatus() != ConnectionStatus.INIT) {\n+                logger.warn(\"TiVo'{}' set channel command failed '{}' with msg '{}'\", getThing().getUID(), tmpCommand,\n+                        tmpStatus.getMsg());\n+                switch (tmpStatus.getMsg()) {\n+                    case \"CH_FAILED NO_LIVE\":\n+                        tmpStatus.setChannelNum(channel);\n+                        tmpStatus.setSubChannelNum(subChannel);\n+                        return tmpStatus;\n+                    case \"CH_FAILED RECORDING\":\n+                        return tmpStatus;\n+                    case \"CH_FAILED MISSING_CHANNEL\":\n+                        return tmpStatus;\n+                    case \"CH_FAILED MALFORMED_CHANNEL\":\n+                        return tmpStatus;\n+                    case \"CH_FAILED INVALID_CHANNEL\":\n+                        return tmpStatus;\n+                    case \"NO_STATUS_DATA_RETURNED\":\n+                        tmpStatus.setChannelNum(-1);\n+                        tmpStatus.setSubChannelNum(-1);\n+                        tmpStatus.setRecording(false);\n+                        return tmpStatus;\n+                }\n+            }\n+\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"TiVo'{}' unable to parse channel integer from CHANNEL_TIVO_CHANNEL: '{}'\", getThing().getUID(),\n+                    command.toString());\n+        }\n+        return tmpStatus;\n+    }\n+\n+    /**\n+     * {@link updateTivoStatus} populates the items with the status / channel information.\n+     *\n+     * @param tivoStatusData the {@link TivoStatusData}\n+     */\n+    public void updateTivoStatus(TivoStatusData oldStatusData, TivoStatusData newStatusData) {\n+        if (newStatusData.getConnectionStatus() != ConnectionStatus.INIT) {\n+            // Update Item Status\n+            if (newStatusData.getPubToUI()) {\n+                if (oldStatusData.getConnectionStatus() == ConnectionStatus.INIT\n+                        || !(oldStatusData.getMsg().contentEquals(newStatusData.getMsg()))) {\n+                    updateState(CHANNEL_TIVO_STATUS, new StringType(newStatusData.getMsg()));\n+                }\n+                // If the cmd was successful, publish the channel channel numbers\n+                if (newStatusData.isCmdOk() && newStatusData.getChannelNum() != -1) {\n+                    if (oldStatusData.getConnectionStatus() == ConnectionStatus.INIT\n+                            || oldStatusData.getChannelNum() != newStatusData.getChannelNum()\n+                            || oldStatusData.getSubChannelNum() != newStatusData.getSubChannelNum()) {\n+                        if (newStatusData.getSubChannelNum() == -1) {\n+                            updateState(CHANNEL_TIVO_CHANNEL_FORCE, new DecimalType(newStatusData.getChannelNum()));\n+                            updateState(CHANNEL_TIVO_CHANNEL_SET, new DecimalType(newStatusData.getChannelNum()));\n+                        } else {\n+                            updateState(CHANNEL_TIVO_CHANNEL_FORCE, new DecimalType(\n+                                    newStatusData.getChannelNum() + \".\" + newStatusData.getSubChannelNum()));\n+                            updateState(CHANNEL_TIVO_CHANNEL_SET, new DecimalType(\n+                                    newStatusData.getChannelNum() + \".\" + newStatusData.getSubChannelNum()));\n+                        }\n+                    }\n+                    updateState(CHANNEL_TIVO_IS_RECORDING, newStatusData.isRecording() ? OnOffType.ON : OnOffType.OFF);\n+                }\n+\n+                // Now set the pubToUI flag to false, as we have already published this status\n+                if (isLinked(CHANNEL_TIVO_STATUS) || isLinked(CHANNEL_TIVO_CHANNEL_FORCE)\n+                        || isLinked(CHANNEL_TIVO_CHANNEL_SET)) {\n+                    newStatusData.setPubToUI(false);\n+                    tivoConnection.get().setServiceStatus(newStatusData);\n+                }\n+            }\n+\n+            // Update Thing status\n+            if (newStatusData.getConnectionStatus() != lastConnectionStatus) {\n+                switch (newStatusData.getConnectionStatus()) {\n+                    case OFFLINE:\n+                        this.setStatusOffline();\n+                        break;\n+                    case ONLINE:\n+                        updateStatus(ThingStatus.ONLINE);\n+                        break;\n+                    case STANDBY:\n+                        updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                                \"STANDBY MODE: Send command TIVO to Remote Control Button (IRCODE) item to wakeup.\");", "originalCommit": "aa8457fa2e41b8f90f00ae89373654cbafa22e08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgwODcwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543808709", "bodyText": "fixed", "author": "mlobstein", "createdAt": "2020-12-16T01:26:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU1ODY2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU1OTIzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543559239", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-12-15T17:52:18Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/internal/discovery/TiVoDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.internal.discovery;\n+\n+import java.net.InetAddress;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.TiVoBindingConstants;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Class TiVoDiscoveryParticipant.\n+ * *\n+ *\n+ * @author Jayson Kubilis (DigitalBytes) - Initial contribution\n+ * @author Andrew Black (AndyXMB) - minor updates.\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+@NonNullByDefault\n+@Component(immediate = true, configurationPid = \"discovery.tivo\")\n+public class TiVoDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+    private final Logger logger = LoggerFactory.getLogger(TiVoDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return Collections.singleton(TiVoBindingConstants.THING_TYPE_TIVO);\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        logger.debug(\"TiVo Discover getServiceType\");", "originalCommit": "aa8457fa2e41b8f90f00ae89373654cbafa22e08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU1OTQzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543559439", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-12-15T17:52:33Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/internal/discovery/TiVoDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.internal.discovery;\n+\n+import java.net.InetAddress;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.TiVoBindingConstants;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Class TiVoDiscoveryParticipant.\n+ * *\n+ *\n+ * @author Jayson Kubilis (DigitalBytes) - Initial contribution\n+ * @author Andrew Black (AndyXMB) - minor updates.\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+@NonNullByDefault\n+@Component(immediate = true, configurationPid = \"discovery.tivo\")\n+public class TiVoDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+    private final Logger logger = LoggerFactory.getLogger(TiVoDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return Collections.singleton(TiVoBindingConstants.THING_TYPE_TIVO);\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        logger.debug(\"TiVo Discover getServiceType\");\n+        return \"_tivo-remote._tcp.local.\";\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        logger.debug(\"TiVo Discover createResult\");", "originalCommit": "aa8457fa2e41b8f90f00ae89373654cbafa22e08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU1OTgyMw==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543559823", "bodyText": "Can you add the representation property?", "author": "fwolter", "createdAt": "2020-12-15T17:53:04Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/internal/discovery/TiVoDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.internal.discovery;\n+\n+import java.net.InetAddress;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.TiVoBindingConstants;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Class TiVoDiscoveryParticipant.\n+ * *\n+ *\n+ * @author Jayson Kubilis (DigitalBytes) - Initial contribution\n+ * @author Andrew Black (AndyXMB) - minor updates.\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+@NonNullByDefault\n+@Component(immediate = true, configurationPid = \"discovery.tivo\")\n+public class TiVoDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+    private final Logger logger = LoggerFactory.getLogger(TiVoDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return Collections.singleton(TiVoBindingConstants.THING_TYPE_TIVO);\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        logger.debug(\"TiVo Discover getServiceType\");\n+        return \"_tivo-remote._tcp.local.\";\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        logger.debug(\"TiVo Discover createResult\");\n+        DiscoveryResult result = null;\n+\n+        ThingUID uid = getThingUID(service);\n+        if (uid != null) {\n+            Map<String, Object> properties = new HashMap<>(2);\n+            // remove the domain from the name\n+            InetAddress ip = getIpAddress(service);\n+            if (ip == null) {\n+                return null;\n+            }\n+            String inetAddress = ip.toString().substring(1); // trim leading slash\n+            String label = service.getName();\n+            int port = service.getPort();\n+\n+            properties.put(TiVoBindingConstants.CONFIG_ADDRESS, inetAddress);\n+            properties.put(TiVoBindingConstants.CONFIG_PORT, port);\n+\n+            result = DiscoveryResultBuilder.create(uid).withProperties(properties).withLabel(\"Tivo: \" + label).build();", "originalCommit": "aa8457fa2e41b8f90f00ae89373654cbafa22e08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU2MDA3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543560077", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-12-15T17:53:28Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/internal/discovery/TiVoDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.internal.discovery;\n+\n+import java.net.InetAddress;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.TiVoBindingConstants;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Class TiVoDiscoveryParticipant.\n+ * *\n+ *\n+ * @author Jayson Kubilis (DigitalBytes) - Initial contribution\n+ * @author Andrew Black (AndyXMB) - minor updates.\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+@NonNullByDefault\n+@Component(immediate = true, configurationPid = \"discovery.tivo\")\n+public class TiVoDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+    private final Logger logger = LoggerFactory.getLogger(TiVoDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return Collections.singleton(TiVoBindingConstants.THING_TYPE_TIVO);\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        logger.debug(\"TiVo Discover getServiceType\");\n+        return \"_tivo-remote._tcp.local.\";\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        logger.debug(\"TiVo Discover createResult\");\n+        DiscoveryResult result = null;\n+\n+        ThingUID uid = getThingUID(service);\n+        if (uid != null) {\n+            Map<String, Object> properties = new HashMap<>(2);\n+            // remove the domain from the name\n+            InetAddress ip = getIpAddress(service);\n+            if (ip == null) {\n+                return null;\n+            }\n+            String inetAddress = ip.toString().substring(1); // trim leading slash\n+            String label = service.getName();\n+            int port = service.getPort();\n+\n+            properties.put(TiVoBindingConstants.CONFIG_ADDRESS, inetAddress);\n+            properties.put(TiVoBindingConstants.CONFIG_PORT, port);\n+\n+            result = DiscoveryResultBuilder.create(uid).withProperties(properties).withLabel(\"Tivo: \" + label).build();\n+            logger.debug(\"Created {} for TiVo host '{}' name '{}'\", result,\n+                    properties.get(TiVoBindingConstants.CONFIG_ADDRESS), label);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * @see org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant#getThingUID(javax.jmdns.ServiceInfo)\n+     */\n+    @Override\n+    public @Nullable ThingUID getThingUID(ServiceInfo service) {\n+        logger.debug(\"TiVo Discover getThingUID\");\n+        logger.trace(\"ServiceInfo: {}\", service);", "originalCommit": "aa8457fa2e41b8f90f00ae89373654cbafa22e08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU2MjczNg==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543562736", "bodyText": "@param is only valid for the class' parameter types here. Javadoc for the fields should be added directly to the field.", "author": "fwolter", "createdAt": "2020-12-15T17:57:02Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/internal/service/TivoStatusData.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.internal.service;\n+\n+import java.util.Date;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * {@link TivoStatusData} class stores the data from the last status query from the TiVo and any other errors / status\n+ * codes.\n+ *\n+ * @param cmdOk boolean true = last command executed correctly, false = last command failed with error message\n+ * @param channelNum int = channel number, -1 indicates no channel received. Valid channel range 1-9999.\n+ * @param msg string status message from the TiVo socket\n+ * @param pubToUI boolean true = this status needs to be published to the UI / Thing, false = do not publish (or it\n+ *            already has been)\n+ * @param connectionStatus ConnectionStatus enum UNKNOWN= test not run/default, OFFLINE = offline, STANDBY = TiVo is in\n+ *            standby,\n+ *            ONLINE = Online", "originalCommit": "aa8457fa2e41b8f90f00ae89373654cbafa22e08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgzODQwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543838401", "bodyText": "fixed", "author": "mlobstein", "createdAt": "2020-12-16T02:25:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU2MjczNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU2OTIwMw==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543569203", "bodyText": "Stopping of the Thread seems quite cumbersome. You could use Thread.join(timeout) here. That would also make the CountDownLatch unnecessary.", "author": "fwolter", "createdAt": "2020-12-15T18:06:12Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/internal/service/TivoStatusProvider.java", "diffHunk": "@@ -0,0 +1,491 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.internal.service;\n+\n+import static org.openhab.binding.tivo.TiVoBindingConstants.CONFIG_SOCKET_TIMEOUT_MS;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.handler.TiVoHandler;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * TivoStatusProvider class to maintain a connection out to the Tivo, monitor and process status messages returned..\n+ *\n+ * @author Jayson Kubilis - Initial contribution\n+ * @author Andrew Black - Updates / compilation corrections\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TivoStatusProvider {\n+    private final Logger logger = LoggerFactory.getLogger(TivoStatusProvider.class);\n+    private @Nullable Socket tivoSocket = null;\n+    private @Nullable PrintStream streamWriter = null;\n+    private @Nullable StreamReader streamReader = null;\n+    private @Nullable TiVoHandler tivoHandler = null;\n+    private TivoStatusData tivoStatusData = new TivoStatusData();\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+\n+    private static final Integer READ_TIMEOUT = 1000;\n+\n+    /**\n+     * Instantiates a new TivoConfigStatusProvider.\n+     *\n+     * @param tivoConfigData {@link TivoConfigData} configuration data for the specific thing.\n+     * @param tivoStatusData {@link TivoStatusData} status data for the specific thing.\n+     * @param tivoHandler {@link TivoHandler} parent handler object for the TivoConfigStatusProvider.\n+     *\n+     */\n+\n+    public TivoStatusProvider(TivoConfigData tivoConfigData, TiVoHandler tivoHandler) {\n+        this.tivoStatusData = new TivoStatusData(false, -1, -1, false, \"INITIALISING\", false, ConnectionStatus.UNKNOWN);\n+        this.tivoConfigData = tivoConfigData;\n+        this.tivoHandler = tivoHandler;\n+    }\n+\n+    /**\n+     * {@link statusRefresh} initiates a connection to the TiVo. When a new connection is made and the TiVo is online,\n+     * the current channel is always returned. The connection is then closed (allows the socket to be used by other\n+     * devices).\n+     *\n+     * * @return {@link TivoStatusData} object\n+     */\n+    public void statusRefresh() {\n+        if (tivoStatusData.getConnectionStatus() != ConnectionStatus.INIT) {\n+            logger.debug(\" statusRefresh '{}' - EXISTING status data - '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    tivoStatusData.toString());\n+        }\n+        connTivoConnect();\n+        doNappTime();\n+        connTivoDisconnect(false);\n+    }\n+\n+    /**\n+     * {@link cmdTivoSend} sends a command to the Tivo.\n+     *\n+     * @param tivoCommand the complete command string (KEYWORD + PARAMETERS e.g. SETCH 102) to send.\n+     * @return {@link TivoStatusData} status data object, contains the result of the command.\n+     */\n+    public @Nullable TivoStatusData cmdTivoSend(String tivoCommand) {\n+        boolean connected = connTivoConnect();\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (!connected || streamWriter == null) {\n+            return new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false, ConnectionStatus.OFFLINE);\n+        }\n+        logger.debug(\"TiVo '{}' - sending command: '{}'\", tivoConfigData.getCfgIdentifier(), tivoCommand);\n+        int repeatCount = 1;\n+        // Handle special keyboard \"repeat\" commands\n+        if (tivoCommand.contains(\"*\")) {\n+            repeatCount = Integer.parseInt(tivoCommand.substring(tivoCommand.indexOf(\"*\") + 1));\n+            tivoCommand = tivoCommand.substring(0, tivoCommand.indexOf(\"*\"));\n+            logger.debug(\"TiVo '{}' - repeating command: '{}' for '{}' times\", tivoConfigData.getCfgIdentifier(),\n+                    tivoCommand, repeatCount);\n+        }\n+        for (int i = 1; i <= repeatCount; i++) {\n+            // Send the command\n+            streamWriter.println(tivoCommand.toString() + \"\\r\");\n+            if (streamWriter.checkError()) {\n+                logger.debug(\"TiVo '{}' - called cmdTivoSend and encountered an IO error\",\n+                        tivoConfigData.getCfgIdentifier());\n+                tivoStatusData = new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false,\n+                        ConnectionStatus.OFFLINE);\n+                connTivoReconnect();\n+            }\n+        }\n+        return tivoStatusData;\n+    }\n+\n+    /**\n+     * {@link statusParse} processes the {@link TivoStatusData} status message returned from the TiVo.\n+     *\n+     * For channel status messages form 'CH_STATUS channel reason' or 'CH_STATUS channel sub-channel reason' calls\n+     * {@link getParsedChannel} and returns the channel number (if a match is found in a valid formatted message).\n+     *\n+     * @param rawStatus string representing the message text returned by the TiVo\n+     * @return TivoStatusData object conditionally populated based upon the raw status message\n+     */\n+    private TivoStatusData statusParse(String rawStatus) {\n+        logger.debug(\" statusParse '{}' - running on string '{}'\", tivoConfigData.getCfgIdentifier(), rawStatus);\n+\n+        if (rawStatus.contentEquals(\"COMMAND_TIMEOUT\")) {\n+            // Ignore COMMAND_TIMEOUT, they occur a few seconds after each successful command, just return existing\n+            // status again\n+            return this.tivoStatusData;\n+        } else {\n+            switch (rawStatus) {\n+                case \"\":\n+                    return new TivoStatusData(false, -1, -1, false, \"NO_STATUS_DATA_RETURNED\", false,\n+                            tivoStatusData.getConnectionStatus());\n+                case \"LIVETV_READY\":\n+                    return new TivoStatusData(true, -1, -1, false, \"LIVETV_READY\", true, ConnectionStatus.ONLINE);\n+                case \"CH_FAILED NO_LIVE\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED NO_LIVE\", true,\n+                            ConnectionStatus.STANDBY);\n+                case \"CH_FAILED RECORDING\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED RECORDING\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MISSING_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MISSING_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MALFORMED_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MALFORMED_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED INVALID_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED INVALID_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"INVALID_COMMAND\":\n+                    return new TivoStatusData(false, -1, -1, false, \"INVALID_COMMAND\", false, ConnectionStatus.ONLINE);\n+                case \"CONNECTION_RETRIES_EXHAUSTED\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CONNECTION_RETRIES_EXHAUSTED\", true,\n+                            ConnectionStatus.OFFLINE);\n+            }\n+        }\n+\n+        // Only other documented status is in the form 'CH_STATUS channel reason' or\n+        // 'CH_STATUS channel sub-channel reason'\n+        Pattern tivoStatusPattern = Pattern.compile(\"^CH_STATUS (\\\\d{4}) (?:(\\\\d{4}))?\");\n+        Matcher matcher = tivoStatusPattern.matcher(rawStatus);\n+        Integer chNum = -1; // -1 used globally to indicate channel number error\n+        Integer subChNum = -1;\n+        boolean isRecording = false;\n+\n+        if (matcher.find()) {\n+            logger.debug(\" statusParse '{}' - groups '{}' with group count of '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    matcher.group(), matcher.groupCount());\n+            if (matcher.groupCount() == 1 || matcher.groupCount() == 2) {\n+                chNum = Integer.parseInt(matcher.group(1).trim());\n+                logger.debug(\" statusParse '{}' - parsed channel '{}'\", tivoConfigData.getCfgIdentifier(), chNum);\n+            }\n+            if (matcher.groupCount() == 2) {\n+                subChNum = Integer.parseInt(matcher.group(2).trim());\n+                logger.debug(\" statusParse '{}' - parsed sub-channel '{}'\", tivoConfigData.getCfgIdentifier(),\n+                        subChNum);\n+            }\n+\n+            if (rawStatus.contains(\"RECORDING\")) {\n+                isRecording = true;\n+            }\n+\n+            rawStatus = rawStatus.replace(\" REMOTE\", \"\");\n+            rawStatus = rawStatus.replace(\" LOCAL\", \"\");\n+            return new TivoStatusData(true, chNum, subChNum, isRecording, rawStatus, true, ConnectionStatus.ONLINE);\n+        }\n+        logger.warn(\" TiVo '{}' - Unhandled/unexpected status message: '{}'\", tivoConfigData.getCfgIdentifier(),\n+                rawStatus);\n+        return new TivoStatusData(false, -1, -1, false, rawStatus, false, tivoStatusData.getConnectionStatus());\n+    }\n+\n+    /**\n+     * {@link connIsConnected} returns the connection state of the Socket, streamWriter and streamReader objects.\n+     *\n+     * @return true = connection exists and all objects look OK, false = connection does not exist or a problem has\n+     *         occurred\n+     *\n+     */\n+    private boolean connIsConnected() {\n+        Socket tivoSocket = this.tivoSocket;\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (tivoSocket == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (!tivoSocket.isConnected()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isConnected=false\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (tivoSocket.isClosed()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isClosed=true\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter.checkError()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand.checkError()=true\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamReader == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: streamReader=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * {@link connTivoConnect} manages the creation / retry process of the socket connection.\n+     *\n+     * @return true = connected, false = not connected\n+     */\n+    public boolean connTivoConnect() {\n+        for (int iL = 1; iL <= tivoConfigData.getCfgNumConnRetry(); iL++) {\n+            logger.debug(\" connTivoConnect '{}' - starting connection process '{}' of '{}'.\",\n+                    tivoConfigData.getCfgIdentifier(), iL, tivoConfigData.getCfgNumConnRetry());\n+\n+            // Sort out the socket connection\n+            if (connSocketConnect()) {\n+                logger.debug(\" connTivoConnect '{}' - Socket created / connection made.\",\n+                        tivoConfigData.getCfgIdentifier());\n+                StreamReader streamReader = this.streamReader;\n+                if (streamReader != null && streamReader.isAlive()) {\n+                    return true;\n+                }\n+            } else {\n+                logger.debug(\" connTivoConnect '{}' - Socket creation failed.\", tivoConfigData.getCfgIdentifier());\n+                TiVoHandler tivoHandler = this.tivoHandler;\n+                if (tivoHandler != null) {\n+                    tivoHandler.setStatusOffline();\n+                }\n+            }\n+            // Sleep and retry\n+            doNappTime();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@link connTivoDisconnect} conditionally closes the Socket connection. When 'keep connection open' or 'channel\n+     * scanning' is true, the disconnection process is ignored. Disconnect can be forced by setting forceDisconnect to\n+     * true.\n+     *\n+     * @param forceDisconnect true = forces a disconnection , false = disconnects in specific situations\n+     */\n+    public void connTivoDisconnect(boolean forceDisconnect) {\n+        if (forceDisconnect) {\n+            connSocketDisconnect();\n+        } else {\n+            if (!tivoConfigData.isCfgKeepConnOpen()) {\n+                doNappTime();\n+                connSocketDisconnect();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@link connTivoReconnect} disconnect and reconnect the socket connection to the TiVo.\n+     *\n+     * @return boolean true = connection succeeded, false = connection failed\n+     */\n+    public boolean connTivoReconnect() {\n+        connSocketDisconnect();\n+        doNappTime();\n+        return connTivoConnect();\n+    }\n+\n+    /**\n+     * {@link connSocketDisconnect} cleanly closes the socket connection and dependent objects\n+     *\n+     */\n+    private void connSocketDisconnect() {\n+        TiVoHandler tivoHandler = this.tivoHandler;\n+        StreamReader streamReader = this.streamReader;\n+        PrintStream streamWriter = this.streamWriter;\n+        Socket tivoSocket = this.tivoSocket;\n+\n+        logger.debug(\" connTivoSocket '{}' - requested to disconnect/cleanup connection objects\",\n+                tivoConfigData.getCfgIdentifier());\n+\n+        // if isCfgKeepConnOpen = false, don't set status to OFFLINE since the socket is closed after each command\n+        if (tivoHandler != null && tivoConfigData.isCfgKeepConnOpen()) {\n+            tivoHandler.setStatusOffline();\n+        }\n+\n+        try {\n+            if (streamReader != null) {\n+                while (streamReader.isAlive()) {\n+                    streamReader.stopReader();\n+                }", "originalCommit": "aa8457fa2e41b8f90f00ae89373654cbafa22e08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkzODYzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543938639", "bodyText": "Fixed by removing the stopReader() method and moving the logic up to connSocketDisconnect()", "author": "mlobstein", "createdAt": "2020-12-16T04:38:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU2OTIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU3MDE2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543570169", "bodyText": "Better throw the InterruptedException to finish the thread fast.", "author": "fwolter", "createdAt": "2020-12-15T18:07:33Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/internal/service/TivoStatusProvider.java", "diffHunk": "@@ -0,0 +1,491 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.internal.service;\n+\n+import static org.openhab.binding.tivo.TiVoBindingConstants.CONFIG_SOCKET_TIMEOUT_MS;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.handler.TiVoHandler;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * TivoStatusProvider class to maintain a connection out to the Tivo, monitor and process status messages returned..\n+ *\n+ * @author Jayson Kubilis - Initial contribution\n+ * @author Andrew Black - Updates / compilation corrections\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TivoStatusProvider {\n+    private final Logger logger = LoggerFactory.getLogger(TivoStatusProvider.class);\n+    private @Nullable Socket tivoSocket = null;\n+    private @Nullable PrintStream streamWriter = null;\n+    private @Nullable StreamReader streamReader = null;\n+    private @Nullable TiVoHandler tivoHandler = null;\n+    private TivoStatusData tivoStatusData = new TivoStatusData();\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+\n+    private static final Integer READ_TIMEOUT = 1000;\n+\n+    /**\n+     * Instantiates a new TivoConfigStatusProvider.\n+     *\n+     * @param tivoConfigData {@link TivoConfigData} configuration data for the specific thing.\n+     * @param tivoStatusData {@link TivoStatusData} status data for the specific thing.\n+     * @param tivoHandler {@link TivoHandler} parent handler object for the TivoConfigStatusProvider.\n+     *\n+     */\n+\n+    public TivoStatusProvider(TivoConfigData tivoConfigData, TiVoHandler tivoHandler) {\n+        this.tivoStatusData = new TivoStatusData(false, -1, -1, false, \"INITIALISING\", false, ConnectionStatus.UNKNOWN);\n+        this.tivoConfigData = tivoConfigData;\n+        this.tivoHandler = tivoHandler;\n+    }\n+\n+    /**\n+     * {@link statusRefresh} initiates a connection to the TiVo. When a new connection is made and the TiVo is online,\n+     * the current channel is always returned. The connection is then closed (allows the socket to be used by other\n+     * devices).\n+     *\n+     * * @return {@link TivoStatusData} object\n+     */\n+    public void statusRefresh() {\n+        if (tivoStatusData.getConnectionStatus() != ConnectionStatus.INIT) {\n+            logger.debug(\" statusRefresh '{}' - EXISTING status data - '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    tivoStatusData.toString());\n+        }\n+        connTivoConnect();\n+        doNappTime();\n+        connTivoDisconnect(false);\n+    }\n+\n+    /**\n+     * {@link cmdTivoSend} sends a command to the Tivo.\n+     *\n+     * @param tivoCommand the complete command string (KEYWORD + PARAMETERS e.g. SETCH 102) to send.\n+     * @return {@link TivoStatusData} status data object, contains the result of the command.\n+     */\n+    public @Nullable TivoStatusData cmdTivoSend(String tivoCommand) {\n+        boolean connected = connTivoConnect();\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (!connected || streamWriter == null) {\n+            return new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false, ConnectionStatus.OFFLINE);\n+        }\n+        logger.debug(\"TiVo '{}' - sending command: '{}'\", tivoConfigData.getCfgIdentifier(), tivoCommand);\n+        int repeatCount = 1;\n+        // Handle special keyboard \"repeat\" commands\n+        if (tivoCommand.contains(\"*\")) {\n+            repeatCount = Integer.parseInt(tivoCommand.substring(tivoCommand.indexOf(\"*\") + 1));\n+            tivoCommand = tivoCommand.substring(0, tivoCommand.indexOf(\"*\"));\n+            logger.debug(\"TiVo '{}' - repeating command: '{}' for '{}' times\", tivoConfigData.getCfgIdentifier(),\n+                    tivoCommand, repeatCount);\n+        }\n+        for (int i = 1; i <= repeatCount; i++) {\n+            // Send the command\n+            streamWriter.println(tivoCommand.toString() + \"\\r\");\n+            if (streamWriter.checkError()) {\n+                logger.debug(\"TiVo '{}' - called cmdTivoSend and encountered an IO error\",\n+                        tivoConfigData.getCfgIdentifier());\n+                tivoStatusData = new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false,\n+                        ConnectionStatus.OFFLINE);\n+                connTivoReconnect();\n+            }\n+        }\n+        return tivoStatusData;\n+    }\n+\n+    /**\n+     * {@link statusParse} processes the {@link TivoStatusData} status message returned from the TiVo.\n+     *\n+     * For channel status messages form 'CH_STATUS channel reason' or 'CH_STATUS channel sub-channel reason' calls\n+     * {@link getParsedChannel} and returns the channel number (if a match is found in a valid formatted message).\n+     *\n+     * @param rawStatus string representing the message text returned by the TiVo\n+     * @return TivoStatusData object conditionally populated based upon the raw status message\n+     */\n+    private TivoStatusData statusParse(String rawStatus) {\n+        logger.debug(\" statusParse '{}' - running on string '{}'\", tivoConfigData.getCfgIdentifier(), rawStatus);\n+\n+        if (rawStatus.contentEquals(\"COMMAND_TIMEOUT\")) {\n+            // Ignore COMMAND_TIMEOUT, they occur a few seconds after each successful command, just return existing\n+            // status again\n+            return this.tivoStatusData;\n+        } else {\n+            switch (rawStatus) {\n+                case \"\":\n+                    return new TivoStatusData(false, -1, -1, false, \"NO_STATUS_DATA_RETURNED\", false,\n+                            tivoStatusData.getConnectionStatus());\n+                case \"LIVETV_READY\":\n+                    return new TivoStatusData(true, -1, -1, false, \"LIVETV_READY\", true, ConnectionStatus.ONLINE);\n+                case \"CH_FAILED NO_LIVE\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED NO_LIVE\", true,\n+                            ConnectionStatus.STANDBY);\n+                case \"CH_FAILED RECORDING\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED RECORDING\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MISSING_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MISSING_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MALFORMED_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MALFORMED_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED INVALID_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED INVALID_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"INVALID_COMMAND\":\n+                    return new TivoStatusData(false, -1, -1, false, \"INVALID_COMMAND\", false, ConnectionStatus.ONLINE);\n+                case \"CONNECTION_RETRIES_EXHAUSTED\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CONNECTION_RETRIES_EXHAUSTED\", true,\n+                            ConnectionStatus.OFFLINE);\n+            }\n+        }\n+\n+        // Only other documented status is in the form 'CH_STATUS channel reason' or\n+        // 'CH_STATUS channel sub-channel reason'\n+        Pattern tivoStatusPattern = Pattern.compile(\"^CH_STATUS (\\\\d{4}) (?:(\\\\d{4}))?\");\n+        Matcher matcher = tivoStatusPattern.matcher(rawStatus);\n+        Integer chNum = -1; // -1 used globally to indicate channel number error\n+        Integer subChNum = -1;\n+        boolean isRecording = false;\n+\n+        if (matcher.find()) {\n+            logger.debug(\" statusParse '{}' - groups '{}' with group count of '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    matcher.group(), matcher.groupCount());\n+            if (matcher.groupCount() == 1 || matcher.groupCount() == 2) {\n+                chNum = Integer.parseInt(matcher.group(1).trim());\n+                logger.debug(\" statusParse '{}' - parsed channel '{}'\", tivoConfigData.getCfgIdentifier(), chNum);\n+            }\n+            if (matcher.groupCount() == 2) {\n+                subChNum = Integer.parseInt(matcher.group(2).trim());\n+                logger.debug(\" statusParse '{}' - parsed sub-channel '{}'\", tivoConfigData.getCfgIdentifier(),\n+                        subChNum);\n+            }\n+\n+            if (rawStatus.contains(\"RECORDING\")) {\n+                isRecording = true;\n+            }\n+\n+            rawStatus = rawStatus.replace(\" REMOTE\", \"\");\n+            rawStatus = rawStatus.replace(\" LOCAL\", \"\");\n+            return new TivoStatusData(true, chNum, subChNum, isRecording, rawStatus, true, ConnectionStatus.ONLINE);\n+        }\n+        logger.warn(\" TiVo '{}' - Unhandled/unexpected status message: '{}'\", tivoConfigData.getCfgIdentifier(),\n+                rawStatus);\n+        return new TivoStatusData(false, -1, -1, false, rawStatus, false, tivoStatusData.getConnectionStatus());\n+    }\n+\n+    /**\n+     * {@link connIsConnected} returns the connection state of the Socket, streamWriter and streamReader objects.\n+     *\n+     * @return true = connection exists and all objects look OK, false = connection does not exist or a problem has\n+     *         occurred\n+     *\n+     */\n+    private boolean connIsConnected() {\n+        Socket tivoSocket = this.tivoSocket;\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (tivoSocket == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (!tivoSocket.isConnected()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isConnected=false\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (tivoSocket.isClosed()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isClosed=true\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter.checkError()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand.checkError()=true\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamReader == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: streamReader=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * {@link connTivoConnect} manages the creation / retry process of the socket connection.\n+     *\n+     * @return true = connected, false = not connected\n+     */\n+    public boolean connTivoConnect() {\n+        for (int iL = 1; iL <= tivoConfigData.getCfgNumConnRetry(); iL++) {\n+            logger.debug(\" connTivoConnect '{}' - starting connection process '{}' of '{}'.\",\n+                    tivoConfigData.getCfgIdentifier(), iL, tivoConfigData.getCfgNumConnRetry());\n+\n+            // Sort out the socket connection\n+            if (connSocketConnect()) {\n+                logger.debug(\" connTivoConnect '{}' - Socket created / connection made.\",\n+                        tivoConfigData.getCfgIdentifier());\n+                StreamReader streamReader = this.streamReader;\n+                if (streamReader != null && streamReader.isAlive()) {\n+                    return true;\n+                }\n+            } else {\n+                logger.debug(\" connTivoConnect '{}' - Socket creation failed.\", tivoConfigData.getCfgIdentifier());\n+                TiVoHandler tivoHandler = this.tivoHandler;\n+                if (tivoHandler != null) {\n+                    tivoHandler.setStatusOffline();\n+                }\n+            }\n+            // Sleep and retry\n+            doNappTime();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@link connTivoDisconnect} conditionally closes the Socket connection. When 'keep connection open' or 'channel\n+     * scanning' is true, the disconnection process is ignored. Disconnect can be forced by setting forceDisconnect to\n+     * true.\n+     *\n+     * @param forceDisconnect true = forces a disconnection , false = disconnects in specific situations\n+     */\n+    public void connTivoDisconnect(boolean forceDisconnect) {\n+        if (forceDisconnect) {\n+            connSocketDisconnect();\n+        } else {\n+            if (!tivoConfigData.isCfgKeepConnOpen()) {\n+                doNappTime();\n+                connSocketDisconnect();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@link connTivoReconnect} disconnect and reconnect the socket connection to the TiVo.\n+     *\n+     * @return boolean true = connection succeeded, false = connection failed\n+     */\n+    public boolean connTivoReconnect() {\n+        connSocketDisconnect();\n+        doNappTime();\n+        return connTivoConnect();\n+    }\n+\n+    /**\n+     * {@link connSocketDisconnect} cleanly closes the socket connection and dependent objects\n+     *\n+     */\n+    private void connSocketDisconnect() {\n+        TiVoHandler tivoHandler = this.tivoHandler;\n+        StreamReader streamReader = this.streamReader;\n+        PrintStream streamWriter = this.streamWriter;\n+        Socket tivoSocket = this.tivoSocket;\n+\n+        logger.debug(\" connTivoSocket '{}' - requested to disconnect/cleanup connection objects\",\n+                tivoConfigData.getCfgIdentifier());\n+\n+        // if isCfgKeepConnOpen = false, don't set status to OFFLINE since the socket is closed after each command\n+        if (tivoHandler != null && tivoConfigData.isCfgKeepConnOpen()) {\n+            tivoHandler.setStatusOffline();\n+        }\n+\n+        try {\n+            if (streamReader != null) {\n+                while (streamReader.isAlive()) {\n+                    streamReader.stopReader();\n+                }\n+                this.streamReader = null;\n+            }\n+            if (streamWriter != null) {\n+                streamWriter.close();\n+                this.streamWriter = null;\n+            }\n+            if (tivoSocket != null) {\n+                tivoSocket.close();\n+                this.tivoSocket = null;\n+            }\n+\n+        } catch (IOException e) {\n+            logger.debug(\" TiVo '{}' - I/O exception while disconnecting: '{}'.  Connection closed.\",\n+                    tivoConfigData.getCfgIdentifier(), e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * {@link connSocketConnect} opens a Socket connection to the TiVo. Creates a {@link StreamReader} (Input)\n+     * thread to read the responses from the TiVo and a PrintStream (Output) {@link cmdTivoSend}\n+     * to send commands to the device.\n+     *\n+     * @param pConnect true = make a new connection , false = close existing connection\n+     * @return boolean true = connection succeeded, false = connection failed\n+     */\n+    private synchronized boolean connSocketConnect() {\n+        logger.debug(\" connSocketConnect '{}' - attempting connection to host '{}', port '{}'\",\n+                tivoConfigData.getCfgIdentifier(), tivoConfigData.getCfgHost(), tivoConfigData.getCfgTcpPort());\n+\n+        if (connIsConnected()) {\n+            logger.debug(\" connSocketConnect '{}' - already connected to host '{}', port '{}'\",\n+                    tivoConfigData.getCfgIdentifier(), tivoConfigData.getCfgHost(), tivoConfigData.getCfgTcpPort());\n+            return true;\n+        } else {\n+            // something is wrong, so force a disconnect/clean up so we can try again\n+            connTivoDisconnect(true);\n+        }\n+\n+        try {\n+            Socket tivoSocket = new Socket(tivoConfigData.getCfgHost(), tivoConfigData.getCfgTcpPort());\n+            tivoSocket.setKeepAlive(true);\n+            tivoSocket.setSoTimeout(CONFIG_SOCKET_TIMEOUT_MS);\n+            tivoSocket.setReuseAddress(true);\n+\n+            if (tivoSocket.isConnected() && !tivoSocket.isClosed()) {\n+                if (streamWriter == null) {\n+                    streamWriter = new PrintStream(tivoSocket.getOutputStream(), false);\n+                }\n+                if (this.streamReader == null) {\n+                    StreamReader streamReader = new StreamReader(tivoSocket.getInputStream());\n+                    streamReader.start();\n+                    this.streamReader = streamReader;\n+                }\n+                this.tivoSocket = tivoSocket;\n+            } else {\n+                logger.debug(\" connSocketConnect '{}' - socket creation failed to host '{}', port '{}'\",\n+                        tivoConfigData.getCfgIdentifier(), tivoConfigData.getCfgHost(), tivoConfigData.getCfgTcpPort());\n+                return false;\n+            }\n+\n+            return true;\n+\n+        } catch (UnknownHostException e) {\n+            logger.debug(\" TiVo '{}' - while connecting, unexpected host error: '{}'\",\n+                    tivoConfigData.getCfgIdentifier(), e.getMessage());\n+        } catch (IOException e) {\n+            if (tivoStatusData.getConnectionStatus() != ConnectionStatus.OFFLINE) {\n+                logger.debug(\" TiVo '{}' - I/O exception while connecting: '{}'\", tivoConfigData.getCfgIdentifier(),\n+                        e.getMessage());\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@link doNappTime} sleeps for the period specified by the getCfgCmdWait parameter. Primarily used to allow the\n+     * TiVo time to process responses after a command is issued.\n+     */\n+    public void doNappTime() {\n+        try {\n+            logger.debug(\" doNappTime '{}' - I feel like napping for '{}' milliseconds\",\n+                    tivoConfigData.getCfgIdentifier(), tivoConfigData.getCfgCmdWait());\n+            TimeUnit.MILLISECONDS.sleep(tivoConfigData.getCfgCmdWait());\n+        } catch (Exception e) {\n+        }", "originalCommit": "aa8457fa2e41b8f90f00ae89373654cbafa22e08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg1NjMxNw==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543856317", "bodyText": "Why throw InterruptedException during the sleep?", "author": "mlobstein", "createdAt": "2020-12-16T02:49:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU3MDE2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDExNzE0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r544117141", "bodyText": "It is raised when OH stops. In this case you need to exit the current program flow on the shortest path.", "author": "fwolter", "createdAt": "2020-12-16T08:50:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU3MDE2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4NzUxNw==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r544687517", "bodyText": "same comment as above", "author": "mlobstein", "createdAt": "2020-12-16T23:05:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU3MDE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU3MDkwNw==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543570907", "bodyText": "The thread name should be OH-binding-<ThingUID>-...", "author": "fwolter", "createdAt": "2020-12-15T18:08:41Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/internal/service/TivoStatusProvider.java", "diffHunk": "@@ -0,0 +1,491 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.internal.service;\n+\n+import static org.openhab.binding.tivo.TiVoBindingConstants.CONFIG_SOCKET_TIMEOUT_MS;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.handler.TiVoHandler;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * TivoStatusProvider class to maintain a connection out to the Tivo, monitor and process status messages returned..\n+ *\n+ * @author Jayson Kubilis - Initial contribution\n+ * @author Andrew Black - Updates / compilation corrections\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TivoStatusProvider {\n+    private final Logger logger = LoggerFactory.getLogger(TivoStatusProvider.class);\n+    private @Nullable Socket tivoSocket = null;\n+    private @Nullable PrintStream streamWriter = null;\n+    private @Nullable StreamReader streamReader = null;\n+    private @Nullable TiVoHandler tivoHandler = null;\n+    private TivoStatusData tivoStatusData = new TivoStatusData();\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+\n+    private static final Integer READ_TIMEOUT = 1000;\n+\n+    /**\n+     * Instantiates a new TivoConfigStatusProvider.\n+     *\n+     * @param tivoConfigData {@link TivoConfigData} configuration data for the specific thing.\n+     * @param tivoStatusData {@link TivoStatusData} status data for the specific thing.\n+     * @param tivoHandler {@link TivoHandler} parent handler object for the TivoConfigStatusProvider.\n+     *\n+     */\n+\n+    public TivoStatusProvider(TivoConfigData tivoConfigData, TiVoHandler tivoHandler) {\n+        this.tivoStatusData = new TivoStatusData(false, -1, -1, false, \"INITIALISING\", false, ConnectionStatus.UNKNOWN);\n+        this.tivoConfigData = tivoConfigData;\n+        this.tivoHandler = tivoHandler;\n+    }\n+\n+    /**\n+     * {@link statusRefresh} initiates a connection to the TiVo. When a new connection is made and the TiVo is online,\n+     * the current channel is always returned. The connection is then closed (allows the socket to be used by other\n+     * devices).\n+     *\n+     * * @return {@link TivoStatusData} object\n+     */\n+    public void statusRefresh() {\n+        if (tivoStatusData.getConnectionStatus() != ConnectionStatus.INIT) {\n+            logger.debug(\" statusRefresh '{}' - EXISTING status data - '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    tivoStatusData.toString());\n+        }\n+        connTivoConnect();\n+        doNappTime();\n+        connTivoDisconnect(false);\n+    }\n+\n+    /**\n+     * {@link cmdTivoSend} sends a command to the Tivo.\n+     *\n+     * @param tivoCommand the complete command string (KEYWORD + PARAMETERS e.g. SETCH 102) to send.\n+     * @return {@link TivoStatusData} status data object, contains the result of the command.\n+     */\n+    public @Nullable TivoStatusData cmdTivoSend(String tivoCommand) {\n+        boolean connected = connTivoConnect();\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (!connected || streamWriter == null) {\n+            return new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false, ConnectionStatus.OFFLINE);\n+        }\n+        logger.debug(\"TiVo '{}' - sending command: '{}'\", tivoConfigData.getCfgIdentifier(), tivoCommand);\n+        int repeatCount = 1;\n+        // Handle special keyboard \"repeat\" commands\n+        if (tivoCommand.contains(\"*\")) {\n+            repeatCount = Integer.parseInt(tivoCommand.substring(tivoCommand.indexOf(\"*\") + 1));\n+            tivoCommand = tivoCommand.substring(0, tivoCommand.indexOf(\"*\"));\n+            logger.debug(\"TiVo '{}' - repeating command: '{}' for '{}' times\", tivoConfigData.getCfgIdentifier(),\n+                    tivoCommand, repeatCount);\n+        }\n+        for (int i = 1; i <= repeatCount; i++) {\n+            // Send the command\n+            streamWriter.println(tivoCommand.toString() + \"\\r\");\n+            if (streamWriter.checkError()) {\n+                logger.debug(\"TiVo '{}' - called cmdTivoSend and encountered an IO error\",\n+                        tivoConfigData.getCfgIdentifier());\n+                tivoStatusData = new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false,\n+                        ConnectionStatus.OFFLINE);\n+                connTivoReconnect();\n+            }\n+        }\n+        return tivoStatusData;\n+    }\n+\n+    /**\n+     * {@link statusParse} processes the {@link TivoStatusData} status message returned from the TiVo.\n+     *\n+     * For channel status messages form 'CH_STATUS channel reason' or 'CH_STATUS channel sub-channel reason' calls\n+     * {@link getParsedChannel} and returns the channel number (if a match is found in a valid formatted message).\n+     *\n+     * @param rawStatus string representing the message text returned by the TiVo\n+     * @return TivoStatusData object conditionally populated based upon the raw status message\n+     */\n+    private TivoStatusData statusParse(String rawStatus) {\n+        logger.debug(\" statusParse '{}' - running on string '{}'\", tivoConfigData.getCfgIdentifier(), rawStatus);\n+\n+        if (rawStatus.contentEquals(\"COMMAND_TIMEOUT\")) {\n+            // Ignore COMMAND_TIMEOUT, they occur a few seconds after each successful command, just return existing\n+            // status again\n+            return this.tivoStatusData;\n+        } else {\n+            switch (rawStatus) {\n+                case \"\":\n+                    return new TivoStatusData(false, -1, -1, false, \"NO_STATUS_DATA_RETURNED\", false,\n+                            tivoStatusData.getConnectionStatus());\n+                case \"LIVETV_READY\":\n+                    return new TivoStatusData(true, -1, -1, false, \"LIVETV_READY\", true, ConnectionStatus.ONLINE);\n+                case \"CH_FAILED NO_LIVE\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED NO_LIVE\", true,\n+                            ConnectionStatus.STANDBY);\n+                case \"CH_FAILED RECORDING\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED RECORDING\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MISSING_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MISSING_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MALFORMED_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MALFORMED_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED INVALID_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED INVALID_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"INVALID_COMMAND\":\n+                    return new TivoStatusData(false, -1, -1, false, \"INVALID_COMMAND\", false, ConnectionStatus.ONLINE);\n+                case \"CONNECTION_RETRIES_EXHAUSTED\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CONNECTION_RETRIES_EXHAUSTED\", true,\n+                            ConnectionStatus.OFFLINE);\n+            }\n+        }\n+\n+        // Only other documented status is in the form 'CH_STATUS channel reason' or\n+        // 'CH_STATUS channel sub-channel reason'\n+        Pattern tivoStatusPattern = Pattern.compile(\"^CH_STATUS (\\\\d{4}) (?:(\\\\d{4}))?\");\n+        Matcher matcher = tivoStatusPattern.matcher(rawStatus);\n+        Integer chNum = -1; // -1 used globally to indicate channel number error\n+        Integer subChNum = -1;\n+        boolean isRecording = false;\n+\n+        if (matcher.find()) {\n+            logger.debug(\" statusParse '{}' - groups '{}' with group count of '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    matcher.group(), matcher.groupCount());\n+            if (matcher.groupCount() == 1 || matcher.groupCount() == 2) {\n+                chNum = Integer.parseInt(matcher.group(1).trim());\n+                logger.debug(\" statusParse '{}' - parsed channel '{}'\", tivoConfigData.getCfgIdentifier(), chNum);\n+            }\n+            if (matcher.groupCount() == 2) {\n+                subChNum = Integer.parseInt(matcher.group(2).trim());\n+                logger.debug(\" statusParse '{}' - parsed sub-channel '{}'\", tivoConfigData.getCfgIdentifier(),\n+                        subChNum);\n+            }\n+\n+            if (rawStatus.contains(\"RECORDING\")) {\n+                isRecording = true;\n+            }\n+\n+            rawStatus = rawStatus.replace(\" REMOTE\", \"\");\n+            rawStatus = rawStatus.replace(\" LOCAL\", \"\");\n+            return new TivoStatusData(true, chNum, subChNum, isRecording, rawStatus, true, ConnectionStatus.ONLINE);\n+        }\n+        logger.warn(\" TiVo '{}' - Unhandled/unexpected status message: '{}'\", tivoConfigData.getCfgIdentifier(),\n+                rawStatus);\n+        return new TivoStatusData(false, -1, -1, false, rawStatus, false, tivoStatusData.getConnectionStatus());\n+    }\n+\n+    /**\n+     * {@link connIsConnected} returns the connection state of the Socket, streamWriter and streamReader objects.\n+     *\n+     * @return true = connection exists and all objects look OK, false = connection does not exist or a problem has\n+     *         occurred\n+     *\n+     */\n+    private boolean connIsConnected() {\n+        Socket tivoSocket = this.tivoSocket;\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (tivoSocket == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (!tivoSocket.isConnected()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isConnected=false\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (tivoSocket.isClosed()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isClosed=true\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter.checkError()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand.checkError()=true\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamReader == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: streamReader=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * {@link connTivoConnect} manages the creation / retry process of the socket connection.\n+     *\n+     * @return true = connected, false = not connected\n+     */\n+    public boolean connTivoConnect() {\n+        for (int iL = 1; iL <= tivoConfigData.getCfgNumConnRetry(); iL++) {\n+            logger.debug(\" connTivoConnect '{}' - starting connection process '{}' of '{}'.\",\n+                    tivoConfigData.getCfgIdentifier(), iL, tivoConfigData.getCfgNumConnRetry());\n+\n+            // Sort out the socket connection\n+            if (connSocketConnect()) {\n+                logger.debug(\" connTivoConnect '{}' - Socket created / connection made.\",\n+                        tivoConfigData.getCfgIdentifier());\n+                StreamReader streamReader = this.streamReader;\n+                if (streamReader != null && streamReader.isAlive()) {\n+                    return true;\n+                }\n+            } else {\n+                logger.debug(\" connTivoConnect '{}' - Socket creation failed.\", tivoConfigData.getCfgIdentifier());\n+                TiVoHandler tivoHandler = this.tivoHandler;\n+                if (tivoHandler != null) {\n+                    tivoHandler.setStatusOffline();\n+                }\n+            }\n+            // Sleep and retry\n+            doNappTime();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@link connTivoDisconnect} conditionally closes the Socket connection. When 'keep connection open' or 'channel\n+     * scanning' is true, the disconnection process is ignored. Disconnect can be forced by setting forceDisconnect to\n+     * true.\n+     *\n+     * @param forceDisconnect true = forces a disconnection , false = disconnects in specific situations\n+     */\n+    public void connTivoDisconnect(boolean forceDisconnect) {\n+        if (forceDisconnect) {\n+            connSocketDisconnect();\n+        } else {\n+            if (!tivoConfigData.isCfgKeepConnOpen()) {\n+                doNappTime();\n+                connSocketDisconnect();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@link connTivoReconnect} disconnect and reconnect the socket connection to the TiVo.\n+     *\n+     * @return boolean true = connection succeeded, false = connection failed\n+     */\n+    public boolean connTivoReconnect() {\n+        connSocketDisconnect();\n+        doNappTime();\n+        return connTivoConnect();\n+    }\n+\n+    /**\n+     * {@link connSocketDisconnect} cleanly closes the socket connection and dependent objects\n+     *\n+     */\n+    private void connSocketDisconnect() {\n+        TiVoHandler tivoHandler = this.tivoHandler;\n+        StreamReader streamReader = this.streamReader;\n+        PrintStream streamWriter = this.streamWriter;\n+        Socket tivoSocket = this.tivoSocket;\n+\n+        logger.debug(\" connTivoSocket '{}' - requested to disconnect/cleanup connection objects\",\n+                tivoConfigData.getCfgIdentifier());\n+\n+        // if isCfgKeepConnOpen = false, don't set status to OFFLINE since the socket is closed after each command\n+        if (tivoHandler != null && tivoConfigData.isCfgKeepConnOpen()) {\n+            tivoHandler.setStatusOffline();\n+        }\n+\n+        try {\n+            if (streamReader != null) {\n+                while (streamReader.isAlive()) {\n+                    streamReader.stopReader();\n+                }\n+                this.streamReader = null;\n+            }\n+            if (streamWriter != null) {\n+                streamWriter.close();\n+                this.streamWriter = null;\n+            }\n+            if (tivoSocket != null) {\n+                tivoSocket.close();\n+                this.tivoSocket = null;\n+            }\n+\n+        } catch (IOException e) {\n+            logger.debug(\" TiVo '{}' - I/O exception while disconnecting: '{}'.  Connection closed.\",\n+                    tivoConfigData.getCfgIdentifier(), e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * {@link connSocketConnect} opens a Socket connection to the TiVo. Creates a {@link StreamReader} (Input)\n+     * thread to read the responses from the TiVo and a PrintStream (Output) {@link cmdTivoSend}\n+     * to send commands to the device.\n+     *\n+     * @param pConnect true = make a new connection , false = close existing connection\n+     * @return boolean true = connection succeeded, false = connection failed\n+     */\n+    private synchronized boolean connSocketConnect() {\n+        logger.debug(\" connSocketConnect '{}' - attempting connection to host '{}', port '{}'\",\n+                tivoConfigData.getCfgIdentifier(), tivoConfigData.getCfgHost(), tivoConfigData.getCfgTcpPort());\n+\n+        if (connIsConnected()) {\n+            logger.debug(\" connSocketConnect '{}' - already connected to host '{}', port '{}'\",\n+                    tivoConfigData.getCfgIdentifier(), tivoConfigData.getCfgHost(), tivoConfigData.getCfgTcpPort());\n+            return true;\n+        } else {\n+            // something is wrong, so force a disconnect/clean up so we can try again\n+            connTivoDisconnect(true);\n+        }\n+\n+        try {\n+            Socket tivoSocket = new Socket(tivoConfigData.getCfgHost(), tivoConfigData.getCfgTcpPort());\n+            tivoSocket.setKeepAlive(true);\n+            tivoSocket.setSoTimeout(CONFIG_SOCKET_TIMEOUT_MS);\n+            tivoSocket.setReuseAddress(true);\n+\n+            if (tivoSocket.isConnected() && !tivoSocket.isClosed()) {\n+                if (streamWriter == null) {\n+                    streamWriter = new PrintStream(tivoSocket.getOutputStream(), false);\n+                }\n+                if (this.streamReader == null) {\n+                    StreamReader streamReader = new StreamReader(tivoSocket.getInputStream());\n+                    streamReader.start();\n+                    this.streamReader = streamReader;\n+                }\n+                this.tivoSocket = tivoSocket;\n+            } else {\n+                logger.debug(\" connSocketConnect '{}' - socket creation failed to host '{}', port '{}'\",\n+                        tivoConfigData.getCfgIdentifier(), tivoConfigData.getCfgHost(), tivoConfigData.getCfgTcpPort());\n+                return false;\n+            }\n+\n+            return true;\n+\n+        } catch (UnknownHostException e) {\n+            logger.debug(\" TiVo '{}' - while connecting, unexpected host error: '{}'\",\n+                    tivoConfigData.getCfgIdentifier(), e.getMessage());\n+        } catch (IOException e) {\n+            if (tivoStatusData.getConnectionStatus() != ConnectionStatus.OFFLINE) {\n+                logger.debug(\" TiVo '{}' - I/O exception while connecting: '{}'\", tivoConfigData.getCfgIdentifier(),\n+                        e.getMessage());\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@link doNappTime} sleeps for the period specified by the getCfgCmdWait parameter. Primarily used to allow the\n+     * TiVo time to process responses after a command is issued.\n+     */\n+    public void doNappTime() {\n+        try {\n+            logger.debug(\" doNappTime '{}' - I feel like napping for '{}' milliseconds\",\n+                    tivoConfigData.getCfgIdentifier(), tivoConfigData.getCfgCmdWait());\n+            TimeUnit.MILLISECONDS.sleep(tivoConfigData.getCfgCmdWait());\n+        } catch (Exception e) {\n+        }\n+    }\n+\n+    public TivoStatusData getServiceStatus() {\n+        return tivoStatusData;\n+    }\n+\n+    public void setServiceStatus(TivoStatusData tivoStatusData) {\n+        this.tivoStatusData = tivoStatusData;\n+    }\n+\n+    /**\n+     * {@link StreamReader} data stream reader that reads the status data returned from the TiVo.\n+     *\n+     */\n+    public class StreamReader extends Thread {\n+        private @Nullable BufferedReader bufferedReader = null;\n+        private volatile boolean stopReader;\n+\n+        private CountDownLatch stopLatch;\n+\n+        /**\n+         * {@link StreamReader} construct a data stream reader that reads the status data returned from the TiVo via a\n+         * BufferedReader.\n+         *\n+         * @param inputStream socket input stream.\n+         * @throws IOException\n+         */\n+        public StreamReader(InputStream inputStream) {\n+            this.setName(\"OH-binding-\" + tivoConfigData.getCfgIdentifier() + \"-\" + tivoConfigData.getCfgHost() + \".\"\n+                    + tivoConfigData.getCfgTcpPort());", "originalCommit": "aa8457fa2e41b8f90f00ae89373654cbafa22e08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgxOTczMA==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543819730", "bodyText": "cfgIdentifier is populated in the handler like this:\ntivoConfigData.setCfgIdentifier(String.valueOf(getThing().getUID()));\nBut I will change it to use a local field to avoid confusion.", "author": "mlobstein", "createdAt": "2020-12-16T01:55:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU3MDkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU3MTc4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543571781", "bodyText": "You could invoke Thread.interrupt() if you want to stop the thread. That would make the flag unnecessary.", "author": "fwolter", "createdAt": "2020-12-15T18:09:58Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/internal/service/TivoStatusProvider.java", "diffHunk": "@@ -0,0 +1,491 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.internal.service;\n+\n+import static org.openhab.binding.tivo.TiVoBindingConstants.CONFIG_SOCKET_TIMEOUT_MS;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.handler.TiVoHandler;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * TivoStatusProvider class to maintain a connection out to the Tivo, monitor and process status messages returned..\n+ *\n+ * @author Jayson Kubilis - Initial contribution\n+ * @author Andrew Black - Updates / compilation corrections\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TivoStatusProvider {\n+    private final Logger logger = LoggerFactory.getLogger(TivoStatusProvider.class);\n+    private @Nullable Socket tivoSocket = null;\n+    private @Nullable PrintStream streamWriter = null;\n+    private @Nullable StreamReader streamReader = null;\n+    private @Nullable TiVoHandler tivoHandler = null;\n+    private TivoStatusData tivoStatusData = new TivoStatusData();\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+\n+    private static final Integer READ_TIMEOUT = 1000;\n+\n+    /**\n+     * Instantiates a new TivoConfigStatusProvider.\n+     *\n+     * @param tivoConfigData {@link TivoConfigData} configuration data for the specific thing.\n+     * @param tivoStatusData {@link TivoStatusData} status data for the specific thing.\n+     * @param tivoHandler {@link TivoHandler} parent handler object for the TivoConfigStatusProvider.\n+     *\n+     */\n+\n+    public TivoStatusProvider(TivoConfigData tivoConfigData, TiVoHandler tivoHandler) {\n+        this.tivoStatusData = new TivoStatusData(false, -1, -1, false, \"INITIALISING\", false, ConnectionStatus.UNKNOWN);\n+        this.tivoConfigData = tivoConfigData;\n+        this.tivoHandler = tivoHandler;\n+    }\n+\n+    /**\n+     * {@link statusRefresh} initiates a connection to the TiVo. When a new connection is made and the TiVo is online,\n+     * the current channel is always returned. The connection is then closed (allows the socket to be used by other\n+     * devices).\n+     *\n+     * * @return {@link TivoStatusData} object\n+     */\n+    public void statusRefresh() {\n+        if (tivoStatusData.getConnectionStatus() != ConnectionStatus.INIT) {\n+            logger.debug(\" statusRefresh '{}' - EXISTING status data - '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    tivoStatusData.toString());\n+        }\n+        connTivoConnect();\n+        doNappTime();\n+        connTivoDisconnect(false);\n+    }\n+\n+    /**\n+     * {@link cmdTivoSend} sends a command to the Tivo.\n+     *\n+     * @param tivoCommand the complete command string (KEYWORD + PARAMETERS e.g. SETCH 102) to send.\n+     * @return {@link TivoStatusData} status data object, contains the result of the command.\n+     */\n+    public @Nullable TivoStatusData cmdTivoSend(String tivoCommand) {\n+        boolean connected = connTivoConnect();\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (!connected || streamWriter == null) {\n+            return new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false, ConnectionStatus.OFFLINE);\n+        }\n+        logger.debug(\"TiVo '{}' - sending command: '{}'\", tivoConfigData.getCfgIdentifier(), tivoCommand);\n+        int repeatCount = 1;\n+        // Handle special keyboard \"repeat\" commands\n+        if (tivoCommand.contains(\"*\")) {\n+            repeatCount = Integer.parseInt(tivoCommand.substring(tivoCommand.indexOf(\"*\") + 1));\n+            tivoCommand = tivoCommand.substring(0, tivoCommand.indexOf(\"*\"));\n+            logger.debug(\"TiVo '{}' - repeating command: '{}' for '{}' times\", tivoConfigData.getCfgIdentifier(),\n+                    tivoCommand, repeatCount);\n+        }\n+        for (int i = 1; i <= repeatCount; i++) {\n+            // Send the command\n+            streamWriter.println(tivoCommand.toString() + \"\\r\");\n+            if (streamWriter.checkError()) {\n+                logger.debug(\"TiVo '{}' - called cmdTivoSend and encountered an IO error\",\n+                        tivoConfigData.getCfgIdentifier());\n+                tivoStatusData = new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false,\n+                        ConnectionStatus.OFFLINE);\n+                connTivoReconnect();\n+            }\n+        }\n+        return tivoStatusData;\n+    }\n+\n+    /**\n+     * {@link statusParse} processes the {@link TivoStatusData} status message returned from the TiVo.\n+     *\n+     * For channel status messages form 'CH_STATUS channel reason' or 'CH_STATUS channel sub-channel reason' calls\n+     * {@link getParsedChannel} and returns the channel number (if a match is found in a valid formatted message).\n+     *\n+     * @param rawStatus string representing the message text returned by the TiVo\n+     * @return TivoStatusData object conditionally populated based upon the raw status message\n+     */\n+    private TivoStatusData statusParse(String rawStatus) {\n+        logger.debug(\" statusParse '{}' - running on string '{}'\", tivoConfigData.getCfgIdentifier(), rawStatus);\n+\n+        if (rawStatus.contentEquals(\"COMMAND_TIMEOUT\")) {\n+            // Ignore COMMAND_TIMEOUT, they occur a few seconds after each successful command, just return existing\n+            // status again\n+            return this.tivoStatusData;\n+        } else {\n+            switch (rawStatus) {\n+                case \"\":\n+                    return new TivoStatusData(false, -1, -1, false, \"NO_STATUS_DATA_RETURNED\", false,\n+                            tivoStatusData.getConnectionStatus());\n+                case \"LIVETV_READY\":\n+                    return new TivoStatusData(true, -1, -1, false, \"LIVETV_READY\", true, ConnectionStatus.ONLINE);\n+                case \"CH_FAILED NO_LIVE\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED NO_LIVE\", true,\n+                            ConnectionStatus.STANDBY);\n+                case \"CH_FAILED RECORDING\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED RECORDING\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MISSING_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MISSING_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MALFORMED_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MALFORMED_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED INVALID_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED INVALID_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"INVALID_COMMAND\":\n+                    return new TivoStatusData(false, -1, -1, false, \"INVALID_COMMAND\", false, ConnectionStatus.ONLINE);\n+                case \"CONNECTION_RETRIES_EXHAUSTED\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CONNECTION_RETRIES_EXHAUSTED\", true,\n+                            ConnectionStatus.OFFLINE);\n+            }\n+        }\n+\n+        // Only other documented status is in the form 'CH_STATUS channel reason' or\n+        // 'CH_STATUS channel sub-channel reason'\n+        Pattern tivoStatusPattern = Pattern.compile(\"^CH_STATUS (\\\\d{4}) (?:(\\\\d{4}))?\");\n+        Matcher matcher = tivoStatusPattern.matcher(rawStatus);\n+        Integer chNum = -1; // -1 used globally to indicate channel number error\n+        Integer subChNum = -1;\n+        boolean isRecording = false;\n+\n+        if (matcher.find()) {\n+            logger.debug(\" statusParse '{}' - groups '{}' with group count of '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    matcher.group(), matcher.groupCount());\n+            if (matcher.groupCount() == 1 || matcher.groupCount() == 2) {\n+                chNum = Integer.parseInt(matcher.group(1).trim());\n+                logger.debug(\" statusParse '{}' - parsed channel '{}'\", tivoConfigData.getCfgIdentifier(), chNum);\n+            }\n+            if (matcher.groupCount() == 2) {\n+                subChNum = Integer.parseInt(matcher.group(2).trim());\n+                logger.debug(\" statusParse '{}' - parsed sub-channel '{}'\", tivoConfigData.getCfgIdentifier(),\n+                        subChNum);\n+            }\n+\n+            if (rawStatus.contains(\"RECORDING\")) {\n+                isRecording = true;\n+            }\n+\n+            rawStatus = rawStatus.replace(\" REMOTE\", \"\");\n+            rawStatus = rawStatus.replace(\" LOCAL\", \"\");\n+            return new TivoStatusData(true, chNum, subChNum, isRecording, rawStatus, true, ConnectionStatus.ONLINE);\n+        }\n+        logger.warn(\" TiVo '{}' - Unhandled/unexpected status message: '{}'\", tivoConfigData.getCfgIdentifier(),\n+                rawStatus);\n+        return new TivoStatusData(false, -1, -1, false, rawStatus, false, tivoStatusData.getConnectionStatus());\n+    }\n+\n+    /**\n+     * {@link connIsConnected} returns the connection state of the Socket, streamWriter and streamReader objects.\n+     *\n+     * @return true = connection exists and all objects look OK, false = connection does not exist or a problem has\n+     *         occurred\n+     *\n+     */\n+    private boolean connIsConnected() {\n+        Socket tivoSocket = this.tivoSocket;\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (tivoSocket == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (!tivoSocket.isConnected()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isConnected=false\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (tivoSocket.isClosed()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isClosed=true\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter.checkError()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand.checkError()=true\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamReader == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: streamReader=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * {@link connTivoConnect} manages the creation / retry process of the socket connection.\n+     *\n+     * @return true = connected, false = not connected\n+     */\n+    public boolean connTivoConnect() {\n+        for (int iL = 1; iL <= tivoConfigData.getCfgNumConnRetry(); iL++) {\n+            logger.debug(\" connTivoConnect '{}' - starting connection process '{}' of '{}'.\",\n+                    tivoConfigData.getCfgIdentifier(), iL, tivoConfigData.getCfgNumConnRetry());\n+\n+            // Sort out the socket connection\n+            if (connSocketConnect()) {\n+                logger.debug(\" connTivoConnect '{}' - Socket created / connection made.\",\n+                        tivoConfigData.getCfgIdentifier());\n+                StreamReader streamReader = this.streamReader;\n+                if (streamReader != null && streamReader.isAlive()) {\n+                    return true;\n+                }\n+            } else {\n+                logger.debug(\" connTivoConnect '{}' - Socket creation failed.\", tivoConfigData.getCfgIdentifier());\n+                TiVoHandler tivoHandler = this.tivoHandler;\n+                if (tivoHandler != null) {\n+                    tivoHandler.setStatusOffline();\n+                }\n+            }\n+            // Sleep and retry\n+            doNappTime();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@link connTivoDisconnect} conditionally closes the Socket connection. When 'keep connection open' or 'channel\n+     * scanning' is true, the disconnection process is ignored. Disconnect can be forced by setting forceDisconnect to\n+     * true.\n+     *\n+     * @param forceDisconnect true = forces a disconnection , false = disconnects in specific situations\n+     */\n+    public void connTivoDisconnect(boolean forceDisconnect) {\n+        if (forceDisconnect) {\n+            connSocketDisconnect();\n+        } else {\n+            if (!tivoConfigData.isCfgKeepConnOpen()) {\n+                doNappTime();\n+                connSocketDisconnect();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@link connTivoReconnect} disconnect and reconnect the socket connection to the TiVo.\n+     *\n+     * @return boolean true = connection succeeded, false = connection failed\n+     */\n+    public boolean connTivoReconnect() {\n+        connSocketDisconnect();\n+        doNappTime();\n+        return connTivoConnect();\n+    }\n+\n+    /**\n+     * {@link connSocketDisconnect} cleanly closes the socket connection and dependent objects\n+     *\n+     */\n+    private void connSocketDisconnect() {\n+        TiVoHandler tivoHandler = this.tivoHandler;\n+        StreamReader streamReader = this.streamReader;\n+        PrintStream streamWriter = this.streamWriter;\n+        Socket tivoSocket = this.tivoSocket;\n+\n+        logger.debug(\" connTivoSocket '{}' - requested to disconnect/cleanup connection objects\",\n+                tivoConfigData.getCfgIdentifier());\n+\n+        // if isCfgKeepConnOpen = false, don't set status to OFFLINE since the socket is closed after each command\n+        if (tivoHandler != null && tivoConfigData.isCfgKeepConnOpen()) {\n+            tivoHandler.setStatusOffline();\n+        }\n+\n+        try {\n+            if (streamReader != null) {\n+                while (streamReader.isAlive()) {\n+                    streamReader.stopReader();\n+                }\n+                this.streamReader = null;\n+            }\n+            if (streamWriter != null) {\n+                streamWriter.close();\n+                this.streamWriter = null;\n+            }\n+            if (tivoSocket != null) {\n+                tivoSocket.close();\n+                this.tivoSocket = null;\n+            }\n+\n+        } catch (IOException e) {\n+            logger.debug(\" TiVo '{}' - I/O exception while disconnecting: '{}'.  Connection closed.\",\n+                    tivoConfigData.getCfgIdentifier(), e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * {@link connSocketConnect} opens a Socket connection to the TiVo. Creates a {@link StreamReader} (Input)\n+     * thread to read the responses from the TiVo and a PrintStream (Output) {@link cmdTivoSend}\n+     * to send commands to the device.\n+     *\n+     * @param pConnect true = make a new connection , false = close existing connection\n+     * @return boolean true = connection succeeded, false = connection failed\n+     */\n+    private synchronized boolean connSocketConnect() {\n+        logger.debug(\" connSocketConnect '{}' - attempting connection to host '{}', port '{}'\",\n+                tivoConfigData.getCfgIdentifier(), tivoConfigData.getCfgHost(), tivoConfigData.getCfgTcpPort());\n+\n+        if (connIsConnected()) {\n+            logger.debug(\" connSocketConnect '{}' - already connected to host '{}', port '{}'\",\n+                    tivoConfigData.getCfgIdentifier(), tivoConfigData.getCfgHost(), tivoConfigData.getCfgTcpPort());\n+            return true;\n+        } else {\n+            // something is wrong, so force a disconnect/clean up so we can try again\n+            connTivoDisconnect(true);\n+        }\n+\n+        try {\n+            Socket tivoSocket = new Socket(tivoConfigData.getCfgHost(), tivoConfigData.getCfgTcpPort());\n+            tivoSocket.setKeepAlive(true);\n+            tivoSocket.setSoTimeout(CONFIG_SOCKET_TIMEOUT_MS);\n+            tivoSocket.setReuseAddress(true);\n+\n+            if (tivoSocket.isConnected() && !tivoSocket.isClosed()) {\n+                if (streamWriter == null) {\n+                    streamWriter = new PrintStream(tivoSocket.getOutputStream(), false);\n+                }\n+                if (this.streamReader == null) {\n+                    StreamReader streamReader = new StreamReader(tivoSocket.getInputStream());\n+                    streamReader.start();\n+                    this.streamReader = streamReader;\n+                }\n+                this.tivoSocket = tivoSocket;\n+            } else {\n+                logger.debug(\" connSocketConnect '{}' - socket creation failed to host '{}', port '{}'\",\n+                        tivoConfigData.getCfgIdentifier(), tivoConfigData.getCfgHost(), tivoConfigData.getCfgTcpPort());\n+                return false;\n+            }\n+\n+            return true;\n+\n+        } catch (UnknownHostException e) {\n+            logger.debug(\" TiVo '{}' - while connecting, unexpected host error: '{}'\",\n+                    tivoConfigData.getCfgIdentifier(), e.getMessage());\n+        } catch (IOException e) {\n+            if (tivoStatusData.getConnectionStatus() != ConnectionStatus.OFFLINE) {\n+                logger.debug(\" TiVo '{}' - I/O exception while connecting: '{}'\", tivoConfigData.getCfgIdentifier(),\n+                        e.getMessage());\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@link doNappTime} sleeps for the period specified by the getCfgCmdWait parameter. Primarily used to allow the\n+     * TiVo time to process responses after a command is issued.\n+     */\n+    public void doNappTime() {\n+        try {\n+            logger.debug(\" doNappTime '{}' - I feel like napping for '{}' milliseconds\",\n+                    tivoConfigData.getCfgIdentifier(), tivoConfigData.getCfgCmdWait());\n+            TimeUnit.MILLISECONDS.sleep(tivoConfigData.getCfgCmdWait());\n+        } catch (Exception e) {\n+        }\n+    }\n+\n+    public TivoStatusData getServiceStatus() {\n+        return tivoStatusData;\n+    }\n+\n+    public void setServiceStatus(TivoStatusData tivoStatusData) {\n+        this.tivoStatusData = tivoStatusData;\n+    }\n+\n+    /**\n+     * {@link StreamReader} data stream reader that reads the status data returned from the TiVo.\n+     *\n+     */\n+    public class StreamReader extends Thread {\n+        private @Nullable BufferedReader bufferedReader = null;\n+        private volatile boolean stopReader;\n+\n+        private CountDownLatch stopLatch;\n+\n+        /**\n+         * {@link StreamReader} construct a data stream reader that reads the status data returned from the TiVo via a\n+         * BufferedReader.\n+         *\n+         * @param inputStream socket input stream.\n+         * @throws IOException\n+         */\n+        public StreamReader(InputStream inputStream) {\n+            this.setName(\"OH-binding-\" + tivoConfigData.getCfgIdentifier() + \"-\" + tivoConfigData.getCfgHost() + \".\"\n+                    + tivoConfigData.getCfgTcpPort());\n+            this.bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n+            this.stopLatch = new CountDownLatch(1);\n+            this.setDaemon(true);\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                logger.debug(\"streamReader {} is running. \", tivoConfigData.getCfgIdentifier());\n+                while (!stopReader && !Thread.currentThread().isInterrupted()) {", "originalCommit": "aa8457fa2e41b8f90f00ae89373654cbafa22e08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkzODgzMA==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r543938830", "bodyText": "I removed the flag", "author": "mlobstein", "createdAt": "2020-12-16T04:39:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU3MTc4MQ=="}], "type": "inlineReview"}, {"oid": "978fced9047a015b5ec6f719d2ba3c93c19685e2", "url": "https://github.com/openhab/openhab-addons/commit/978fced9047a015b5ec6f719d2ba3c93c19685e2", "message": "First pass review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-12-16T01:13:48Z", "type": "commit"}, {"oid": "3ac47ab52a98a56685af4dd85f9f24d1ce74ad5b", "url": "https://github.com/openhab/openhab-addons/commit/3ac47ab52a98a56685af4dd85f9f24d1ce74ad5b", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-12-16T04:35:26Z", "type": "commit"}, {"oid": "25ff9846c37a0a0f97537c9787882f689895b0d5", "url": "https://github.com/openhab/openhab-addons/commit/25ff9846c37a0a0f97537c9787882f689895b0d5", "message": "fix representation property\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-12-16T06:27:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3NzA0MA==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r544177040", "bodyText": "Any reason this is not in the internal package? Same for the constants.", "author": "fwolter", "createdAt": "2020-12-16T10:17:37Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/handler/TiVoHandler.java", "diffHunk": "@@ -0,0 +1,364 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.handler;", "originalCommit": "25ff9846c37a0a0f97537c9787882f689895b0d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4NzYwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r544687601", "bodyText": "fixed", "author": "mlobstein", "createdAt": "2020-12-16T23:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3NzA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3NzkzNw==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r544177937", "bodyText": "It's bad practice to re-assign method arguments. You could create a new local variable.", "author": "fwolter", "createdAt": "2020-12-16T10:19:02Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/handler/TiVoHandler.java", "diffHunk": "@@ -0,0 +1,364 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.handler;\n+\n+import static org.openhab.binding.tivo.TiVoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.internal.service.TivoConfigData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.openhab.binding.tivo.internal.service.TivoStatusProvider;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TiVoHandler} is the BaseThingHandler responsible for handling commands that are\n+ * sent to one of the Tivo's channels.\n+ *\n+ * @author Jayson Kubilis (DigitalBytes) - Initial contribution\n+ * @author Andrew Black (AndyXMB) - Updates / compilation corrections. Addition of channel scanning functionality.\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TiVoHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(TiVoHandler.class);\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+    private ConnectionStatus lastConnectionStatus = ConnectionStatus.UNKNOWN;\n+    private Optional<TivoStatusProvider> tivoConnection = Optional.empty();\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    /**\n+     * Instantiates a new TiVo handler.\n+     *\n+     * @param thing the thing\n+     */\n+    public TiVoHandler(Thing thing) {\n+        super(thing);\n+        logger.debug(\"TiVoHandler '{}' - creating\", getThing().getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Handles the commands from the various TiVo channel objects\n+        logger.debug(\"handleCommand '{}', parameter: {}\", channelUID, command);\n+\n+        if (!isInitialized() || !tivoConnection.isPresent()) {\n+            logger.debug(\"handleCommand '{}' device is not intialised yet, command '{}' will be ignored.\",\n+                    getThing().getUID(), channelUID + \" \" + command);\n+            return;\n+        }\n+\n+        TivoStatusData currentStatus = tivoConnection.get().getServiceStatus();\n+        String commandKeyword = \"\";\n+\n+        String commandParameter = command.toString().toUpperCase();\n+        if (command instanceof RefreshType) {\n+            // Future enhancement, if we can come up with a sensible set of actions when a REFRESH is issued\n+            logger.debug(\"TiVo '{}' skipping REFRESH command for channel: '{}'.\", getThing().getUID(),\n+                    channelUID.getId());\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TIVO_CHANNEL_FORCE:\n+                commandKeyword = \"FORCECH\";\n+                break;\n+            case CHANNEL_TIVO_CHANNEL_SET:\n+                commandKeyword = \"SETCH\";\n+                break;\n+            case CHANNEL_TIVO_TELEPORT:\n+                commandKeyword = \"TELEPORT\";\n+                break;\n+            case CHANNEL_TIVO_IRCMD:\n+                commandKeyword = \"IRCODE\";\n+                break;\n+            case CHANNEL_TIVO_KBDCMD:\n+                commandKeyword = \"KEYBOARD\";\n+                break;\n+        }\n+        sendCommand(commandKeyword, commandParameter, currentStatus);\n+    }\n+\n+    public void setStatusOffline() {\n+        this.updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                \"Power on device or check network configuration/connection.\");\n+    }\n+\n+    private void sendCommand(String commandKeyword, String commandParameter, TivoStatusData currentStatus) {\n+        if (!tivoConnection.isPresent()) {\n+            return;\n+        }\n+\n+        TivoStatusData deviceStatus = tivoConnection.get().getServiceStatus();\n+        TivoStatusData commandResult = null;\n+        logger.debug(\"handleCommand '{}' - {} found!\", getThing().getUID(), commandKeyword);\n+        // Re-write command keyword if we are in STANDBY, as only IRCODE TIVO will wake the unit from\n+        // standby mode\n+        if (deviceStatus.getConnectionStatus() == ConnectionStatus.STANDBY && commandKeyword.contentEquals(\"TELEPORT\")\n+                && commandParameter.contentEquals(\"TIVO\")) {\n+            commandKeyword = \"IRCODE \" + commandParameter;", "originalCommit": "25ff9846c37a0a0f97537c9787882f689895b0d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4NzcxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r544687711", "bodyText": "done", "author": "mlobstein", "createdAt": "2020-12-16T23:05:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3NzkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3ODAzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r544178031", "bodyText": "Are these still used?", "author": "fwolter", "createdAt": "2020-12-16T10:19:13Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/handler/TiVoHandler.java", "diffHunk": "@@ -0,0 +1,364 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.handler;\n+\n+import static org.openhab.binding.tivo.TiVoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.internal.service.TivoConfigData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.openhab.binding.tivo.internal.service.TivoStatusProvider;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TiVoHandler} is the BaseThingHandler responsible for handling commands that are\n+ * sent to one of the Tivo's channels.\n+ *\n+ * @author Jayson Kubilis (DigitalBytes) - Initial contribution\n+ * @author Andrew Black (AndyXMB) - Updates / compilation corrections. Addition of channel scanning functionality.\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TiVoHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(TiVoHandler.class);\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+    private ConnectionStatus lastConnectionStatus = ConnectionStatus.UNKNOWN;\n+    private Optional<TivoStatusProvider> tivoConnection = Optional.empty();\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    /**\n+     * Instantiates a new TiVo handler.\n+     *\n+     * @param thing the thing\n+     */\n+    public TiVoHandler(Thing thing) {\n+        super(thing);\n+        logger.debug(\"TiVoHandler '{}' - creating\", getThing().getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Handles the commands from the various TiVo channel objects\n+        logger.debug(\"handleCommand '{}', parameter: {}\", channelUID, command);\n+\n+        if (!isInitialized() || !tivoConnection.isPresent()) {\n+            logger.debug(\"handleCommand '{}' device is not intialised yet, command '{}' will be ignored.\",\n+                    getThing().getUID(), channelUID + \" \" + command);\n+            return;\n+        }\n+\n+        TivoStatusData currentStatus = tivoConnection.get().getServiceStatus();\n+        String commandKeyword = \"\";\n+\n+        String commandParameter = command.toString().toUpperCase();\n+        if (command instanceof RefreshType) {\n+            // Future enhancement, if we can come up with a sensible set of actions when a REFRESH is issued\n+            logger.debug(\"TiVo '{}' skipping REFRESH command for channel: '{}'.\", getThing().getUID(),\n+                    channelUID.getId());\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TIVO_CHANNEL_FORCE:\n+                commandKeyword = \"FORCECH\";\n+                break;\n+            case CHANNEL_TIVO_CHANNEL_SET:\n+                commandKeyword = \"SETCH\";\n+                break;\n+            case CHANNEL_TIVO_TELEPORT:\n+                commandKeyword = \"TELEPORT\";\n+                break;\n+            case CHANNEL_TIVO_IRCMD:\n+                commandKeyword = \"IRCODE\";\n+                break;\n+            case CHANNEL_TIVO_KBDCMD:\n+                commandKeyword = \"KEYBOARD\";\n+                break;\n+        }\n+        sendCommand(commandKeyword, commandParameter, currentStatus);\n+    }\n+\n+    public void setStatusOffline() {\n+        this.updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                \"Power on device or check network configuration/connection.\");\n+    }\n+\n+    private void sendCommand(String commandKeyword, String commandParameter, TivoStatusData currentStatus) {\n+        if (!tivoConnection.isPresent()) {\n+            return;\n+        }\n+\n+        TivoStatusData deviceStatus = tivoConnection.get().getServiceStatus();\n+        TivoStatusData commandResult = null;\n+        logger.debug(\"handleCommand '{}' - {} found!\", getThing().getUID(), commandKeyword);\n+        // Re-write command keyword if we are in STANDBY, as only IRCODE TIVO will wake the unit from\n+        // standby mode\n+        if (deviceStatus.getConnectionStatus() == ConnectionStatus.STANDBY && commandKeyword.contentEquals(\"TELEPORT\")\n+                && commandParameter.contentEquals(\"TIVO\")) {\n+            commandKeyword = \"IRCODE \" + commandParameter;\n+            logger.debug(\"TiVo '{}' TELEPORT re-mapped to IRCODE as we are in standby: '{}'\", getThing().getUID(),\n+                    commandKeyword);\n+        }\n+        // Execute command\n+        if (commandKeyword.contentEquals(\"FORCECH\") || commandKeyword.contentEquals(\"SETCH\")) {\n+            commandResult = chChannelChange(commandKeyword, commandParameter);\n+        } else {\n+            commandResult = tivoConnection.get().cmdTivoSend(commandKeyword + \" \" + commandParameter);\n+        }\n+\n+        // Post processing\n+        if (commandResult != null && commandParameter.contentEquals(\"STANDBY\")) {\n+            // Force thing state into STANDBY as this command does not return a status when executed\n+            commandResult.setConnectionStatus(ConnectionStatus.STANDBY);\n+        }\n+\n+        // Push status updates\n+        if (commandResult != null && commandResult.isCmdOk()) {\n+            updateTivoStatus(currentStatus, commandResult);\n+        }\n+\n+        // disconnect once command is complete (really only disconnects if isCfgKeepConnOpen = false)\n+        tivoConnection.get().connTivoDisconnect(false);\n+    }\n+\n+    int convertValueToInt(Object value) {\n+        if (value instanceof BigDecimal) {\n+            return ((BigDecimal) value).intValue();\n+        }\n+        if (value instanceof String) {\n+            return Integer.valueOf((String) value);\n+        }\n+        if (value instanceof Double) {\n+            return ((Double) value).intValue();\n+        }\n+        return (Integer) value;\n+    }\n+\n+    boolean convertValueToBoolean(Object value) {\n+        return value instanceof Boolean ? ((Boolean) value) : Boolean.valueOf((String) value);\n+    }", "originalCommit": "25ff9846c37a0a0f97537c9787882f689895b0d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4Nzc3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r544687777", "bodyText": "no, removed.", "author": "mlobstein", "createdAt": "2020-12-16T23:05:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3ODAzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3ODM0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r544178349", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-12-16T10:19:40Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/handler/TiVoHandler.java", "diffHunk": "@@ -0,0 +1,364 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.handler;\n+\n+import static org.openhab.binding.tivo.TiVoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.internal.service.TivoConfigData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.openhab.binding.tivo.internal.service.TivoStatusProvider;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TiVoHandler} is the BaseThingHandler responsible for handling commands that are\n+ * sent to one of the Tivo's channels.\n+ *\n+ * @author Jayson Kubilis (DigitalBytes) - Initial contribution\n+ * @author Andrew Black (AndyXMB) - Updates / compilation corrections. Addition of channel scanning functionality.\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TiVoHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(TiVoHandler.class);\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+    private ConnectionStatus lastConnectionStatus = ConnectionStatus.UNKNOWN;\n+    private Optional<TivoStatusProvider> tivoConnection = Optional.empty();\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    /**\n+     * Instantiates a new TiVo handler.\n+     *\n+     * @param thing the thing\n+     */\n+    public TiVoHandler(Thing thing) {\n+        super(thing);\n+        logger.debug(\"TiVoHandler '{}' - creating\", getThing().getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Handles the commands from the various TiVo channel objects\n+        logger.debug(\"handleCommand '{}', parameter: {}\", channelUID, command);\n+\n+        if (!isInitialized() || !tivoConnection.isPresent()) {\n+            logger.debug(\"handleCommand '{}' device is not intialised yet, command '{}' will be ignored.\",\n+                    getThing().getUID(), channelUID + \" \" + command);\n+            return;\n+        }\n+\n+        TivoStatusData currentStatus = tivoConnection.get().getServiceStatus();\n+        String commandKeyword = \"\";\n+\n+        String commandParameter = command.toString().toUpperCase();\n+        if (command instanceof RefreshType) {\n+            // Future enhancement, if we can come up with a sensible set of actions when a REFRESH is issued\n+            logger.debug(\"TiVo '{}' skipping REFRESH command for channel: '{}'.\", getThing().getUID(),\n+                    channelUID.getId());\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TIVO_CHANNEL_FORCE:\n+                commandKeyword = \"FORCECH\";\n+                break;\n+            case CHANNEL_TIVO_CHANNEL_SET:\n+                commandKeyword = \"SETCH\";\n+                break;\n+            case CHANNEL_TIVO_TELEPORT:\n+                commandKeyword = \"TELEPORT\";\n+                break;\n+            case CHANNEL_TIVO_IRCMD:\n+                commandKeyword = \"IRCODE\";\n+                break;\n+            case CHANNEL_TIVO_KBDCMD:\n+                commandKeyword = \"KEYBOARD\";\n+                break;\n+        }\n+        sendCommand(commandKeyword, commandParameter, currentStatus);\n+    }\n+\n+    public void setStatusOffline() {\n+        this.updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                \"Power on device or check network configuration/connection.\");\n+    }\n+\n+    private void sendCommand(String commandKeyword, String commandParameter, TivoStatusData currentStatus) {\n+        if (!tivoConnection.isPresent()) {\n+            return;\n+        }\n+\n+        TivoStatusData deviceStatus = tivoConnection.get().getServiceStatus();\n+        TivoStatusData commandResult = null;\n+        logger.debug(\"handleCommand '{}' - {} found!\", getThing().getUID(), commandKeyword);\n+        // Re-write command keyword if we are in STANDBY, as only IRCODE TIVO will wake the unit from\n+        // standby mode\n+        if (deviceStatus.getConnectionStatus() == ConnectionStatus.STANDBY && commandKeyword.contentEquals(\"TELEPORT\")\n+                && commandParameter.contentEquals(\"TIVO\")) {\n+            commandKeyword = \"IRCODE \" + commandParameter;\n+            logger.debug(\"TiVo '{}' TELEPORT re-mapped to IRCODE as we are in standby: '{}'\", getThing().getUID(),\n+                    commandKeyword);\n+        }\n+        // Execute command\n+        if (commandKeyword.contentEquals(\"FORCECH\") || commandKeyword.contentEquals(\"SETCH\")) {\n+            commandResult = chChannelChange(commandKeyword, commandParameter);\n+        } else {\n+            commandResult = tivoConnection.get().cmdTivoSend(commandKeyword + \" \" + commandParameter);\n+        }\n+\n+        // Post processing\n+        if (commandResult != null && commandParameter.contentEquals(\"STANDBY\")) {\n+            // Force thing state into STANDBY as this command does not return a status when executed\n+            commandResult.setConnectionStatus(ConnectionStatus.STANDBY);\n+        }\n+\n+        // Push status updates\n+        if (commandResult != null && commandResult.isCmdOk()) {\n+            updateTivoStatus(currentStatus, commandResult);\n+        }\n+\n+        // disconnect once command is complete (really only disconnects if isCfgKeepConnOpen = false)\n+        tivoConnection.get().connTivoDisconnect(false);\n+    }\n+\n+    int convertValueToInt(Object value) {\n+        if (value instanceof BigDecimal) {\n+            return ((BigDecimal) value).intValue();\n+        }\n+        if (value instanceof String) {\n+            return Integer.valueOf((String) value);\n+        }\n+        if (value instanceof Double) {\n+            return ((Double) value).intValue();\n+        }\n+        return (Integer) value;\n+    }\n+\n+    boolean convertValueToBoolean(Object value) {\n+        return value instanceof Boolean ? ((Boolean) value) : Boolean.valueOf((String) value);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing a TiVo '{}' with config options\", getThing().getUID());\n+\n+        tivoConfigData = getConfigAs(TivoConfigData.class);\n+\n+        tivoConfigData.setCfgIdentifier(getThing().getUID().getAsString());\n+        logger.debug(\"TivoConfigData Obj: '{}'\", tivoConfigData);", "originalCommit": "25ff9846c37a0a0f97537c9787882f689895b0d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3ODY2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r544178669", "bodyText": "Can you make this a lambda?", "author": "fwolter", "createdAt": "2020-12-16T10:20:07Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/handler/TiVoHandler.java", "diffHunk": "@@ -0,0 +1,364 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.handler;\n+\n+import static org.openhab.binding.tivo.TiVoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.internal.service.TivoConfigData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.openhab.binding.tivo.internal.service.TivoStatusProvider;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TiVoHandler} is the BaseThingHandler responsible for handling commands that are\n+ * sent to one of the Tivo's channels.\n+ *\n+ * @author Jayson Kubilis (DigitalBytes) - Initial contribution\n+ * @author Andrew Black (AndyXMB) - Updates / compilation corrections. Addition of channel scanning functionality.\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TiVoHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(TiVoHandler.class);\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+    private ConnectionStatus lastConnectionStatus = ConnectionStatus.UNKNOWN;\n+    private Optional<TivoStatusProvider> tivoConnection = Optional.empty();\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    /**\n+     * Instantiates a new TiVo handler.\n+     *\n+     * @param thing the thing\n+     */\n+    public TiVoHandler(Thing thing) {\n+        super(thing);\n+        logger.debug(\"TiVoHandler '{}' - creating\", getThing().getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Handles the commands from the various TiVo channel objects\n+        logger.debug(\"handleCommand '{}', parameter: {}\", channelUID, command);\n+\n+        if (!isInitialized() || !tivoConnection.isPresent()) {\n+            logger.debug(\"handleCommand '{}' device is not intialised yet, command '{}' will be ignored.\",\n+                    getThing().getUID(), channelUID + \" \" + command);\n+            return;\n+        }\n+\n+        TivoStatusData currentStatus = tivoConnection.get().getServiceStatus();\n+        String commandKeyword = \"\";\n+\n+        String commandParameter = command.toString().toUpperCase();\n+        if (command instanceof RefreshType) {\n+            // Future enhancement, if we can come up with a sensible set of actions when a REFRESH is issued\n+            logger.debug(\"TiVo '{}' skipping REFRESH command for channel: '{}'.\", getThing().getUID(),\n+                    channelUID.getId());\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TIVO_CHANNEL_FORCE:\n+                commandKeyword = \"FORCECH\";\n+                break;\n+            case CHANNEL_TIVO_CHANNEL_SET:\n+                commandKeyword = \"SETCH\";\n+                break;\n+            case CHANNEL_TIVO_TELEPORT:\n+                commandKeyword = \"TELEPORT\";\n+                break;\n+            case CHANNEL_TIVO_IRCMD:\n+                commandKeyword = \"IRCODE\";\n+                break;\n+            case CHANNEL_TIVO_KBDCMD:\n+                commandKeyword = \"KEYBOARD\";\n+                break;\n+        }\n+        sendCommand(commandKeyword, commandParameter, currentStatus);\n+    }\n+\n+    public void setStatusOffline() {\n+        this.updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                \"Power on device or check network configuration/connection.\");\n+    }\n+\n+    private void sendCommand(String commandKeyword, String commandParameter, TivoStatusData currentStatus) {\n+        if (!tivoConnection.isPresent()) {\n+            return;\n+        }\n+\n+        TivoStatusData deviceStatus = tivoConnection.get().getServiceStatus();\n+        TivoStatusData commandResult = null;\n+        logger.debug(\"handleCommand '{}' - {} found!\", getThing().getUID(), commandKeyword);\n+        // Re-write command keyword if we are in STANDBY, as only IRCODE TIVO will wake the unit from\n+        // standby mode\n+        if (deviceStatus.getConnectionStatus() == ConnectionStatus.STANDBY && commandKeyword.contentEquals(\"TELEPORT\")\n+                && commandParameter.contentEquals(\"TIVO\")) {\n+            commandKeyword = \"IRCODE \" + commandParameter;\n+            logger.debug(\"TiVo '{}' TELEPORT re-mapped to IRCODE as we are in standby: '{}'\", getThing().getUID(),\n+                    commandKeyword);\n+        }\n+        // Execute command\n+        if (commandKeyword.contentEquals(\"FORCECH\") || commandKeyword.contentEquals(\"SETCH\")) {\n+            commandResult = chChannelChange(commandKeyword, commandParameter);\n+        } else {\n+            commandResult = tivoConnection.get().cmdTivoSend(commandKeyword + \" \" + commandParameter);\n+        }\n+\n+        // Post processing\n+        if (commandResult != null && commandParameter.contentEquals(\"STANDBY\")) {\n+            // Force thing state into STANDBY as this command does not return a status when executed\n+            commandResult.setConnectionStatus(ConnectionStatus.STANDBY);\n+        }\n+\n+        // Push status updates\n+        if (commandResult != null && commandResult.isCmdOk()) {\n+            updateTivoStatus(currentStatus, commandResult);\n+        }\n+\n+        // disconnect once command is complete (really only disconnects if isCfgKeepConnOpen = false)\n+        tivoConnection.get().connTivoDisconnect(false);\n+    }\n+\n+    int convertValueToInt(Object value) {\n+        if (value instanceof BigDecimal) {\n+            return ((BigDecimal) value).intValue();\n+        }\n+        if (value instanceof String) {\n+            return Integer.valueOf((String) value);\n+        }\n+        if (value instanceof Double) {\n+            return ((Double) value).intValue();\n+        }\n+        return (Integer) value;\n+    }\n+\n+    boolean convertValueToBoolean(Object value) {\n+        return value instanceof Boolean ? ((Boolean) value) : Boolean.valueOf((String) value);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing a TiVo '{}' with config options\", getThing().getUID());\n+\n+        tivoConfigData = getConfigAs(TivoConfigData.class);\n+\n+        tivoConfigData.setCfgIdentifier(getThing().getUID().getAsString());\n+        logger.debug(\"TivoConfigData Obj: '{}'\", tivoConfigData);\n+        tivoConnection = Optional.of(new TivoStatusProvider(tivoConfigData, this));\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        lastConnectionStatus = ConnectionStatus.UNKNOWN;\n+        logger.debug(\"Initializing a TiVo handler for thing '{}' - finished!\", getThing().getUID());\n+\n+        startPollStatus();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing of a TiVo handler for thing '{}'\", getThing().getUID());\n+\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null) {\n+            refreshJob.cancel(false);\n+            this.refreshJob = null;\n+        }\n+\n+        if (tivoConnection.isPresent()) {\n+            tivoConnection.get().connTivoDisconnect(true);\n+            tivoConnection = Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * {@link startPollStatus} scheduled job to poll for changes in state.\n+     */\n+    private void startPollStatus() {\n+        Runnable runnable = new Runnable() {\n+            @Override\n+            public void run() {\n+                logger.debug(\"startPollStatus '{}' @ rate of '{}' seconds\", getThing().getUID(),\n+                        tivoConfigData.getPollInterval());\n+                tivoConnection.ifPresent(TivoStatusProvider::statusRefresh);\n+            }\n+        };", "originalCommit": "25ff9846c37a0a0f97537c9787882f689895b0d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE4MDYzNA==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r544180634", "bodyText": "The representation property should be something more unique like the ip address.", "author": "fwolter", "createdAt": "2020-12-16T10:23:09Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/internal/discovery/TiVoDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.internal.discovery;\n+\n+import static org.openhab.binding.tivo.TiVoBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Class TiVoDiscoveryParticipant.\n+ * *\n+ *\n+ * @author Jayson Kubilis (DigitalBytes) - Initial contribution\n+ * @author Andrew Black (AndyXMB) - minor updates.\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+@NonNullByDefault\n+@Component(immediate = true, configurationPid = \"discovery.tivo\")\n+public class TiVoDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+    private final Logger logger = LoggerFactory.getLogger(TiVoDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return Collections.singleton(THING_TYPE_TIVO);\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return \"_tivo-remote._tcp.local.\";\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        DiscoveryResult result = null;\n+\n+        ThingUID uid = getThingUID(service);\n+        if (uid != null) {\n+            Map<String, Object> properties = new HashMap<>(2);\n+            // remove the domain from the name\n+            InetAddress ip = getIpAddress(service);\n+            if (ip == null) {\n+                return null;\n+            }\n+            String inetAddress = ip.toString().substring(1); // trim leading slash\n+            String label = service.getName();\n+            int port = service.getPort();\n+\n+            properties.put(CONFIG_HOST, inetAddress);\n+            properties.put(CONFIG_PORT, port);\n+\n+            result = DiscoveryResultBuilder.create(uid).withProperties(properties).withLabel(\"Tivo: \" + label)\n+                    .withProperty(CONFIG_NAME, label).withRepresentationProperty(CONFIG_NAME).build();", "originalCommit": "25ff9846c37a0a0f97537c9787882f689895b0d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE4MjY0NA==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r544182644", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-12-16T10:25:57Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/internal/service/TivoStatusProvider.java", "diffHunk": "@@ -0,0 +1,475 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.internal.service;\n+\n+import static org.openhab.binding.tivo.TiVoBindingConstants.CONFIG_SOCKET_TIMEOUT_MS;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.handler.TiVoHandler;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * TivoStatusProvider class to maintain a connection out to the Tivo, monitor and process status messages returned..\n+ *\n+ * @author Jayson Kubilis - Initial contribution\n+ * @author Andrew Black - Updates / compilation corrections\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TivoStatusProvider {\n+    private final Logger logger = LoggerFactory.getLogger(TivoStatusProvider.class);\n+    private @Nullable Socket tivoSocket = null;\n+    private @Nullable PrintStream streamWriter = null;\n+    private @Nullable StreamReader streamReader = null;\n+    private @Nullable TiVoHandler tivoHandler = null;\n+    private TivoStatusData tivoStatusData = new TivoStatusData();\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+    private final String thingUid;\n+\n+    private static final Integer READ_TIMEOUT = 3000;\n+\n+    /**\n+     * Instantiates a new TivoConfigStatusProvider.\n+     *\n+     * @param tivoConfigData {@link TivoConfigData} configuration data for the specific thing.\n+     * @param tivoStatusData {@link TivoStatusData} status data for the specific thing.\n+     * @param tivoHandler {@link TivoHandler} parent handler object for the TivoConfigStatusProvider.\n+     *\n+     */\n+\n+    public TivoStatusProvider(TivoConfigData tivoConfigData, TiVoHandler tivoHandler) {\n+        this.tivoStatusData = new TivoStatusData(false, -1, -1, false, \"INITIALISING\", false, ConnectionStatus.UNKNOWN);\n+        this.tivoConfigData = tivoConfigData;\n+        this.tivoHandler = tivoHandler;\n+        this.thingUid = tivoHandler.getThing().getUID().getAsString();\n+    }\n+\n+    /**\n+     * {@link statusRefresh} initiates a connection to the TiVo. When a new connection is made and the TiVo is online,\n+     * the current channel is always returned. The connection is then closed (allows the socket to be used by other\n+     * devices).\n+     *\n+     * * @return {@link TivoStatusData} object\n+     */\n+    public void statusRefresh() {\n+        if (tivoStatusData.getConnectionStatus() != ConnectionStatus.INIT) {\n+            logger.debug(\" statusRefresh '{}' - EXISTING status data - '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    tivoStatusData.toString());\n+        }\n+        connTivoConnect();\n+        doNappTime();\n+        connTivoDisconnect(false);\n+    }\n+\n+    /**\n+     * {@link cmdTivoSend} sends a command to the Tivo.\n+     *\n+     * @param tivoCommand the complete command string (KEYWORD + PARAMETERS e.g. SETCH 102) to send.\n+     * @return {@link TivoStatusData} status data object, contains the result of the command.\n+     */\n+    public @Nullable TivoStatusData cmdTivoSend(String tivoCommand) {\n+        boolean connected = connTivoConnect();\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (!connected || streamWriter == null) {\n+            return new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false, ConnectionStatus.OFFLINE);\n+        }\n+        logger.debug(\"TiVo '{}' - sending command: '{}'\", tivoConfigData.getCfgIdentifier(), tivoCommand);\n+        int repeatCount = 1;\n+        // Handle special keyboard \"repeat\" commands\n+        if (tivoCommand.contains(\"*\")) {\n+            repeatCount = Integer.parseInt(tivoCommand.substring(tivoCommand.indexOf(\"*\") + 1));\n+            tivoCommand = tivoCommand.substring(0, tivoCommand.indexOf(\"*\"));\n+            logger.debug(\"TiVo '{}' - repeating command: '{}' for '{}' times\", tivoConfigData.getCfgIdentifier(),\n+                    tivoCommand, repeatCount);\n+        }\n+        for (int i = 1; i <= repeatCount; i++) {\n+            // Send the command\n+            streamWriter.println(tivoCommand.toString() + \"\\r\");\n+            if (streamWriter.checkError()) {\n+                logger.debug(\"TiVo '{}' - called cmdTivoSend and encountered an IO error\",\n+                        tivoConfigData.getCfgIdentifier());\n+                tivoStatusData = new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false,\n+                        ConnectionStatus.OFFLINE);\n+                connTivoReconnect();\n+            }\n+        }\n+        return tivoStatusData;\n+    }\n+\n+    /**\n+     * {@link statusParse} processes the {@link TivoStatusData} status message returned from the TiVo.\n+     *\n+     * For channel status messages form 'CH_STATUS channel reason' or 'CH_STATUS channel sub-channel reason' calls\n+     * {@link getParsedChannel} and returns the channel number (if a match is found in a valid formatted message).\n+     *\n+     * @param rawStatus string representing the message text returned by the TiVo\n+     * @return TivoStatusData object conditionally populated based upon the raw status message\n+     */\n+    private TivoStatusData statusParse(String rawStatus) {\n+        logger.debug(\" statusParse '{}' - running on string '{}'\", tivoConfigData.getCfgIdentifier(), rawStatus);\n+\n+        if (rawStatus.contentEquals(\"COMMAND_TIMEOUT\")) {\n+            // Ignore COMMAND_TIMEOUT, they occur a few seconds after each successful command, just return existing\n+            // status again\n+            return this.tivoStatusData;\n+        } else {\n+            switch (rawStatus) {\n+                case \"\":\n+                    return new TivoStatusData(false, -1, -1, false, \"NO_STATUS_DATA_RETURNED\", false,\n+                            tivoStatusData.getConnectionStatus());\n+                case \"LIVETV_READY\":\n+                    return new TivoStatusData(true, -1, -1, false, \"LIVETV_READY\", true, ConnectionStatus.ONLINE);\n+                case \"CH_FAILED NO_LIVE\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED NO_LIVE\", true,\n+                            ConnectionStatus.STANDBY);\n+                case \"CH_FAILED RECORDING\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED RECORDING\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MISSING_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MISSING_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MALFORMED_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MALFORMED_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED INVALID_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED INVALID_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"INVALID_COMMAND\":\n+                    return new TivoStatusData(false, -1, -1, false, \"INVALID_COMMAND\", false, ConnectionStatus.ONLINE);\n+                case \"CONNECTION_RETRIES_EXHAUSTED\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CONNECTION_RETRIES_EXHAUSTED\", true,\n+                            ConnectionStatus.OFFLINE);\n+            }\n+        }\n+\n+        // Only other documented status is in the form 'CH_STATUS channel reason' or\n+        // 'CH_STATUS channel sub-channel reason'\n+        Pattern tivoStatusPattern = Pattern.compile(\"^CH_STATUS (\\\\d{4}) (?:(\\\\d{4}))?\");\n+        Matcher matcher = tivoStatusPattern.matcher(rawStatus);\n+        Integer chNum = -1; // -1 used globally to indicate channel number error\n+        Integer subChNum = -1;\n+        boolean isRecording = false;\n+\n+        if (matcher.find()) {\n+            logger.debug(\" statusParse '{}' - groups '{}' with group count of '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    matcher.group(), matcher.groupCount());\n+            if (matcher.groupCount() == 1 || matcher.groupCount() == 2) {\n+                chNum = Integer.parseInt(matcher.group(1).trim());\n+                logger.debug(\" statusParse '{}' - parsed channel '{}'\", tivoConfigData.getCfgIdentifier(), chNum);\n+            }\n+            if (matcher.groupCount() == 2) {\n+                subChNum = Integer.parseInt(matcher.group(2).trim());\n+                logger.debug(\" statusParse '{}' - parsed sub-channel '{}'\", tivoConfigData.getCfgIdentifier(),\n+                        subChNum);\n+            }\n+\n+            if (rawStatus.contains(\"RECORDING\")) {\n+                isRecording = true;\n+            }\n+\n+            rawStatus = rawStatus.replace(\" REMOTE\", \"\");\n+            rawStatus = rawStatus.replace(\" LOCAL\", \"\");\n+            return new TivoStatusData(true, chNum, subChNum, isRecording, rawStatus, true, ConnectionStatus.ONLINE);\n+        }\n+        logger.warn(\" TiVo '{}' - Unhandled/unexpected status message: '{}'\", tivoConfigData.getCfgIdentifier(),\n+                rawStatus);\n+        return new TivoStatusData(false, -1, -1, false, rawStatus, false, tivoStatusData.getConnectionStatus());\n+    }\n+\n+    /**\n+     * {@link connIsConnected} returns the connection state of the Socket, streamWriter and streamReader objects.\n+     *\n+     * @return true = connection exists and all objects look OK, false = connection does not exist or a problem has\n+     *         occurred\n+     *\n+     */\n+    private boolean connIsConnected() {\n+        Socket tivoSocket = this.tivoSocket;\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (tivoSocket == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (!tivoSocket.isConnected()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isConnected=false\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (tivoSocket.isClosed()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isClosed=true\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter.checkError()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand.checkError()=true\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamReader == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: streamReader=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * {@link connTivoConnect} manages the creation / retry process of the socket connection.\n+     *\n+     * @return true = connected, false = not connected\n+     */\n+    public boolean connTivoConnect() {\n+        for (int iL = 1; iL <= tivoConfigData.getNumRetry(); iL++) {\n+            logger.debug(\" connTivoConnect '{}' - starting connection process '{}' of '{}'.\",\n+                    tivoConfigData.getCfgIdentifier(), iL, tivoConfigData.getNumRetry());\n+\n+            // Sort out the socket connection\n+            if (connSocketConnect()) {\n+                logger.debug(\" connTivoConnect '{}' - Socket created / connection made.\",\n+                        tivoConfigData.getCfgIdentifier());\n+                StreamReader streamReader = this.streamReader;\n+                if (streamReader != null && streamReader.isAlive()) {\n+                    return true;\n+                }\n+            } else {\n+                logger.debug(\" connTivoConnect '{}' - Socket creation failed.\", tivoConfigData.getCfgIdentifier());\n+                TiVoHandler tivoHandler = this.tivoHandler;\n+                if (tivoHandler != null) {\n+                    tivoHandler.setStatusOffline();\n+                }\n+            }\n+            // Sleep and retry\n+            doNappTime();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@link connTivoDisconnect} conditionally closes the Socket connection. When 'keep connection open' or 'channel\n+     * scanning' is true, the disconnection process is ignored. Disconnect can be forced by setting forceDisconnect to\n+     * true.\n+     *\n+     * @param forceDisconnect true = forces a disconnection , false = disconnects in specific situations\n+     */\n+    public void connTivoDisconnect(boolean forceDisconnect) {\n+        if (forceDisconnect) {\n+            connSocketDisconnect();\n+        } else {\n+            if (!tivoConfigData.isKeepConnActive()) {\n+                doNappTime();\n+                connSocketDisconnect();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@link connTivoReconnect} disconnect and reconnect the socket connection to the TiVo.\n+     *\n+     * @return boolean true = connection succeeded, false = connection failed\n+     */\n+    public boolean connTivoReconnect() {\n+        connSocketDisconnect();\n+        doNappTime();\n+        return connTivoConnect();\n+    }\n+\n+    /**\n+     * {@link connSocketDisconnect} cleanly closes the socket connection and dependent objects\n+     *\n+     */\n+    private void connSocketDisconnect() {\n+        TiVoHandler tivoHandler = this.tivoHandler;\n+        StreamReader streamReader = this.streamReader;\n+        PrintStream streamWriter = this.streamWriter;\n+        Socket tivoSocket = this.tivoSocket;\n+\n+        logger.debug(\" connTivoSocket '{}' - requested to disconnect/cleanup connection objects\",\n+                tivoConfigData.getCfgIdentifier());\n+\n+        // if isCfgKeepConnOpen = false, don't set status to OFFLINE since the socket is closed after each command\n+        if (tivoHandler != null && tivoConfigData.isKeepConnActive()) {\n+            tivoHandler.setStatusOffline();\n+        }\n+\n+        try {\n+            if (streamReader != null) {\n+                streamReader.interrupt();\n+                try {\n+                    streamReader.join(READ_TIMEOUT);\n+                } catch (InterruptedException e) {\n+                    logger.warn(\"Error joining streamReader: {}\", e.getMessage());\n+                }\n+                this.streamReader = null;\n+            }\n+            if (streamWriter != null) {\n+                streamWriter.close();\n+                this.streamWriter = null;\n+            }\n+            if (tivoSocket != null) {\n+                tivoSocket.close();\n+                this.tivoSocket = null;\n+            }\n+\n+        } catch (IOException e) {\n+            logger.debug(\" TiVo '{}' - I/O exception while disconnecting: '{}'.  Connection closed.\",\n+                    tivoConfigData.getCfgIdentifier(), e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * {@link connSocketConnect} opens a Socket connection to the TiVo. Creates a {@link StreamReader} (Input)\n+     * thread to read the responses from the TiVo and a PrintStream (Output) {@link cmdTivoSend}\n+     * to send commands to the device.\n+     *\n+     * @param pConnect true = make a new connection , false = close existing connection\n+     * @return boolean true = connection succeeded, false = connection failed\n+     */\n+    private synchronized boolean connSocketConnect() {\n+        logger.debug(\" connSocketConnect '{}' - attempting connection to host '{}', port '{}'\",\n+                tivoConfigData.getCfgIdentifier(), tivoConfigData.getHost(), tivoConfigData.getTcpPort());\n+\n+        if (connIsConnected()) {\n+            logger.debug(\" connSocketConnect '{}' - already connected to host '{}', port '{}'\",\n+                    tivoConfigData.getCfgIdentifier(), tivoConfigData.getHost(), tivoConfigData.getTcpPort());\n+            return true;\n+        } else {\n+            // something is wrong, so force a disconnect/clean up so we can try again\n+            connTivoDisconnect(true);\n+        }\n+\n+        try {\n+            Socket tivoSocket = new Socket(tivoConfigData.getHost(), tivoConfigData.getTcpPort());\n+            tivoSocket.setKeepAlive(true);\n+            tivoSocket.setSoTimeout(CONFIG_SOCKET_TIMEOUT_MS);\n+            tivoSocket.setReuseAddress(true);\n+\n+            if (tivoSocket.isConnected() && !tivoSocket.isClosed()) {\n+                if (streamWriter == null) {\n+                    streamWriter = new PrintStream(tivoSocket.getOutputStream(), false);\n+                }\n+                if (this.streamReader == null) {\n+                    StreamReader streamReader = new StreamReader(tivoSocket.getInputStream());\n+                    streamReader.start();\n+                    this.streamReader = streamReader;\n+                }\n+                this.tivoSocket = tivoSocket;\n+            } else {\n+                logger.debug(\" connSocketConnect '{}' - socket creation failed to host '{}', port '{}'\",\n+                        tivoConfigData.getCfgIdentifier(), tivoConfigData.getHost(), tivoConfigData.getTcpPort());\n+                return false;\n+            }\n+\n+            return true;\n+\n+        } catch (UnknownHostException e) {\n+            logger.debug(\" TiVo '{}' - while connecting, unexpected host error: '{}'\",\n+                    tivoConfigData.getCfgIdentifier(), e.getMessage());\n+        } catch (IOException e) {\n+            if (tivoStatusData.getConnectionStatus() != ConnectionStatus.OFFLINE) {\n+                logger.debug(\" TiVo '{}' - I/O exception while connecting: '{}'\", tivoConfigData.getCfgIdentifier(),\n+                        e.getMessage());\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@link doNappTime} sleeps for the period specified by the getCmdWaitInterval parameter. Primarily used to allow\n+     * the TiVo time to process responses after a command is issued.\n+     */\n+    public void doNappTime() {\n+        try {\n+            logger.debug(\" doNappTime '{}' - I feel like napping for '{}' milliseconds\",\n+                    tivoConfigData.getCfgIdentifier(), tivoConfigData.getCmdWaitInterval());", "originalCommit": "25ff9846c37a0a0f97537c9787882f689895b0d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "22dd91d170af4976920f9a0a47831bcedb440ac1", "url": "https://github.com/openhab/openhab-addons/commit/22dd91d170af4976920f9a0a47831bcedb440ac1", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-12-16T22:57:55Z", "type": "commit"}, {"oid": "bbada65689ccf3f272e802c9ecda8739d7040dd4", "url": "https://github.com/openhab/openhab-addons/commit/bbada65689ccf3f272e802c9ecda8739d7040dd4", "message": "throw InterruptedException\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-12-17T23:49:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg1NDAwMg==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r545854002", "bodyText": "Primitive types (int) should be used where possible.\nIt's good practice to append the unit to the field name e.g. TIMEOUT_SEC.", "author": "fwolter", "createdAt": "2020-12-18T14:10:29Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/internal/service/TivoStatusProvider.java", "diffHunk": "@@ -44,6 +44,9 @@\n \n @NonNullByDefault\n public class TivoStatusProvider {\n+    private static final Pattern TIVO_STATUS_PATTERN = Pattern.compile(\"^CH_STATUS (\\\\d{4}) (?:(\\\\d{4}))?\");\n+    private static final Integer READ_TIMEOUT = 3000;", "originalCommit": "22dd91d170af4976920f9a0a47831bcedb440ac1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3NTYzOA==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r546175638", "bodyText": "Fixed both and two other Integers", "author": "mlobstein", "createdAt": "2020-12-19T02:08:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg1NDAwMg=="}], "type": "inlineReview"}, {"oid": "74830f91371b2211056f20c08d4af94a4572ba40", "url": "https://github.com/openhab/openhab-addons/commit/74830f91371b2211056f20c08d4af94a4572ba40", "message": "review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-12-19T02:01:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYxOTc5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r547619799", "bodyText": "Does this need to be immediate?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(immediate = true, configurationPid = \"discovery.tivo\")\n          \n          \n            \n            @Component(configurationPid = \"discovery.tivo\")", "author": "cpmeister", "createdAt": "2020-12-23T03:29:17Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/internal/discovery/TiVoDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.internal.discovery;\n+\n+import static org.openhab.binding.tivo.internal.TiVoBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Class TiVoDiscoveryParticipant.\n+ * *\n+ *\n+ * @author Jayson Kubilis (DigitalBytes) - Initial contribution\n+ * @author Andrew Black (AndyXMB) - minor updates.\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+@NonNullByDefault\n+@Component(immediate = true, configurationPid = \"discovery.tivo\")", "originalCommit": "74830f91371b2211056f20c08d4af94a4572ba40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5MjY3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r548792675", "bodyText": "changed", "author": "mlobstein", "createdAt": "2020-12-25T03:47:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYxOTc5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMTAyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r547621025", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        this.setName(\"OH-binding-\" + thingUid + \"-\" + tivoConfigData.getHost() + \".\" + tivoConfigData.getTcpPort());\n          \n          \n            \n                        this.setName(\"OH-binding-\" + thingUid + \"-\" + tivoConfigData.getHost() + \":\" + tivoConfigData.getTcpPort());", "author": "cpmeister", "createdAt": "2020-12-23T03:35:10Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/internal/service/TivoStatusProvider.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.internal.service;\n+\n+import static org.openhab.binding.tivo.internal.TiVoBindingConstants.CONFIG_SOCKET_TIMEOUT_MS;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.internal.handler.TiVoHandler;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * TivoStatusProvider class to maintain a connection out to the Tivo, monitor and process status messages returned..\n+ *\n+ * @author Jayson Kubilis - Initial contribution\n+ * @author Andrew Black - Updates / compilation corrections\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TivoStatusProvider {\n+    private static final Pattern TIVO_STATUS_PATTERN = Pattern.compile(\"^CH_STATUS (\\\\d{4}) (?:(\\\\d{4}))?\");\n+    private static final int TIMEOUT_SEC = 3000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(TivoStatusProvider.class);\n+    private @Nullable Socket tivoSocket = null;\n+    private @Nullable PrintStream streamWriter = null;\n+    private @Nullable StreamReader streamReader = null;\n+    private @Nullable TiVoHandler tivoHandler = null;\n+    private TivoStatusData tivoStatusData = new TivoStatusData();\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+    private final String thingUid;\n+\n+    /**\n+     * Instantiates a new TivoConfigStatusProvider.\n+     *\n+     * @param tivoConfigData {@link TivoConfigData} configuration data for the specific thing.\n+     * @param tivoStatusData {@link TivoStatusData} status data for the specific thing.\n+     * @param tivoHandler {@link TivoHandler} parent handler object for the TivoConfigStatusProvider.\n+     *\n+     */\n+\n+    public TivoStatusProvider(TivoConfigData tivoConfigData, TiVoHandler tivoHandler) {\n+        this.tivoStatusData = new TivoStatusData(false, -1, -1, false, \"INITIALISING\", false, ConnectionStatus.UNKNOWN);\n+        this.tivoConfigData = tivoConfigData;\n+        this.tivoHandler = tivoHandler;\n+        this.thingUid = tivoHandler.getThing().getUID().getAsString();\n+    }\n+\n+    /**\n+     * {@link statusRefresh} initiates a connection to the TiVo. When a new connection is made and the TiVo is online,\n+     * the current channel is always returned. The connection is then closed (allows the socket to be used by other\n+     * devices).\n+     *\n+     * @return {@link TivoStatusData} object\n+     * @throws InterruptedException\n+     */\n+    public void statusRefresh() throws InterruptedException {\n+        if (tivoStatusData.getConnectionStatus() != ConnectionStatus.INIT) {\n+            logger.debug(\" statusRefresh '{}' - EXISTING status data - '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    tivoStatusData.toString());\n+        }\n+        connTivoConnect();\n+        doNappTime();\n+        connTivoDisconnect(false);\n+    }\n+\n+    /**\n+     * {@link cmdTivoSend} sends a command to the Tivo.\n+     *\n+     * @param tivoCommand the complete command string (KEYWORD + PARAMETERS e.g. SETCH 102) to send.\n+     * @return {@link TivoStatusData} status data object, contains the result of the command.\n+     * @throws InterruptedException\n+     */\n+    public @Nullable TivoStatusData cmdTivoSend(String tivoCommand) throws InterruptedException {\n+        boolean connected = connTivoConnect();\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (!connected || streamWriter == null) {\n+            return new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false, ConnectionStatus.OFFLINE);\n+        }\n+        logger.debug(\"TiVo '{}' - sending command: '{}'\", tivoConfigData.getCfgIdentifier(), tivoCommand);\n+        int repeatCount = 1;\n+        // Handle special keyboard \"repeat\" commands\n+        if (tivoCommand.contains(\"*\")) {\n+            repeatCount = Integer.parseInt(tivoCommand.substring(tivoCommand.indexOf(\"*\") + 1));\n+            tivoCommand = tivoCommand.substring(0, tivoCommand.indexOf(\"*\"));\n+            logger.debug(\"TiVo '{}' - repeating command: '{}' for '{}' times\", tivoConfigData.getCfgIdentifier(),\n+                    tivoCommand, repeatCount);\n+        }\n+        for (int i = 1; i <= repeatCount; i++) {\n+            // Send the command\n+            streamWriter.println(tivoCommand.toString() + \"\\r\");\n+            if (streamWriter.checkError()) {\n+                logger.debug(\"TiVo '{}' - called cmdTivoSend and encountered an IO error\",\n+                        tivoConfigData.getCfgIdentifier());\n+                tivoStatusData = new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false,\n+                        ConnectionStatus.OFFLINE);\n+                connTivoReconnect();\n+            }\n+        }\n+        return tivoStatusData;\n+    }\n+\n+    /**\n+     * {@link statusParse} processes the {@link TivoStatusData} status message returned from the TiVo.\n+     *\n+     * For channel status messages form 'CH_STATUS channel reason' or 'CH_STATUS channel sub-channel reason' calls\n+     * {@link getParsedChannel} and returns the channel number (if a match is found in a valid formatted message).\n+     *\n+     * @param rawStatus string representing the message text returned by the TiVo\n+     * @return TivoStatusData object conditionally populated based upon the raw status message\n+     */\n+    private TivoStatusData statusParse(String rawStatus) {\n+        logger.debug(\" statusParse '{}' - running on string '{}'\", tivoConfigData.getCfgIdentifier(), rawStatus);\n+\n+        if (rawStatus.contentEquals(\"COMMAND_TIMEOUT\")) {\n+            // Ignore COMMAND_TIMEOUT, they occur a few seconds after each successful command, just return existing\n+            // status again\n+            return this.tivoStatusData;\n+        } else {\n+            switch (rawStatus) {\n+                case \"\":\n+                    return new TivoStatusData(false, -1, -1, false, \"NO_STATUS_DATA_RETURNED\", false,\n+                            tivoStatusData.getConnectionStatus());\n+                case \"LIVETV_READY\":\n+                    return new TivoStatusData(true, -1, -1, false, \"LIVETV_READY\", true, ConnectionStatus.ONLINE);\n+                case \"CH_FAILED NO_LIVE\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED NO_LIVE\", true,\n+                            ConnectionStatus.STANDBY);\n+                case \"CH_FAILED RECORDING\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED RECORDING\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MISSING_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MISSING_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MALFORMED_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MALFORMED_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED INVALID_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED INVALID_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"INVALID_COMMAND\":\n+                    return new TivoStatusData(false, -1, -1, false, \"INVALID_COMMAND\", false, ConnectionStatus.ONLINE);\n+                case \"CONNECTION_RETRIES_EXHAUSTED\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CONNECTION_RETRIES_EXHAUSTED\", true,\n+                            ConnectionStatus.OFFLINE);\n+            }\n+        }\n+\n+        // Only other documented status is in the form 'CH_STATUS channel reason' or\n+        // 'CH_STATUS channel sub-channel reason'\n+        Matcher matcher = TIVO_STATUS_PATTERN.matcher(rawStatus);\n+        int chNum = -1; // -1 used globally to indicate channel number error\n+        int subChNum = -1;\n+        boolean isRecording = false;\n+\n+        if (matcher.find()) {\n+            logger.debug(\" statusParse '{}' - groups '{}' with group count of '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    matcher.group(), matcher.groupCount());\n+            if (matcher.groupCount() == 1 || matcher.groupCount() == 2) {\n+                chNum = Integer.parseInt(matcher.group(1).trim());\n+                logger.debug(\" statusParse '{}' - parsed channel '{}'\", tivoConfigData.getCfgIdentifier(), chNum);\n+            }\n+            if (matcher.groupCount() == 2) {\n+                subChNum = Integer.parseInt(matcher.group(2).trim());\n+                logger.debug(\" statusParse '{}' - parsed sub-channel '{}'\", tivoConfigData.getCfgIdentifier(),\n+                        subChNum);\n+            }\n+\n+            if (rawStatus.contains(\"RECORDING\")) {\n+                isRecording = true;\n+            }\n+\n+            rawStatus = rawStatus.replace(\" REMOTE\", \"\");\n+            rawStatus = rawStatus.replace(\" LOCAL\", \"\");\n+            return new TivoStatusData(true, chNum, subChNum, isRecording, rawStatus, true, ConnectionStatus.ONLINE);\n+        }\n+        logger.warn(\" TiVo '{}' - Unhandled/unexpected status message: '{}'\", tivoConfigData.getCfgIdentifier(),\n+                rawStatus);\n+        return new TivoStatusData(false, -1, -1, false, rawStatus, false, tivoStatusData.getConnectionStatus());\n+    }\n+\n+    /**\n+     * {@link connIsConnected} returns the connection state of the Socket, streamWriter and streamReader objects.\n+     *\n+     * @return true = connection exists and all objects look OK, false = connection does not exist or a problem has\n+     *         occurred\n+     *\n+     */\n+    private boolean connIsConnected() {\n+        Socket tivoSocket = this.tivoSocket;\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (tivoSocket == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (!tivoSocket.isConnected()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isConnected=false\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (tivoSocket.isClosed()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isClosed=true\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter.checkError()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand.checkError()=true\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamReader == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: streamReader=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * {@link connTivoConnect} manages the creation / retry process of the socket connection.\n+     *\n+     * @return true = connected, false = not connected\n+     * @throws InterruptedException\n+     */\n+    public boolean connTivoConnect() throws InterruptedException {\n+        for (int iL = 1; iL <= tivoConfigData.getNumRetry(); iL++) {\n+            logger.debug(\" connTivoConnect '{}' - starting connection process '{}' of '{}'.\",\n+                    tivoConfigData.getCfgIdentifier(), iL, tivoConfigData.getNumRetry());\n+\n+            // Sort out the socket connection\n+            if (connSocketConnect()) {\n+                logger.debug(\" connTivoConnect '{}' - Socket created / connection made.\",\n+                        tivoConfigData.getCfgIdentifier());\n+                StreamReader streamReader = this.streamReader;\n+                if (streamReader != null && streamReader.isAlive()) {\n+                    return true;\n+                }\n+            } else {\n+                logger.debug(\" connTivoConnect '{}' - Socket creation failed.\", tivoConfigData.getCfgIdentifier());\n+                TiVoHandler tivoHandler = this.tivoHandler;\n+                if (tivoHandler != null) {\n+                    tivoHandler.setStatusOffline();\n+                }\n+            }\n+            // Sleep and retry\n+            doNappTime();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@link connTivoDisconnect} conditionally closes the Socket connection. When 'keep connection open' or 'channel\n+     * scanning' is true, the disconnection process is ignored. Disconnect can be forced by setting forceDisconnect to\n+     * true.\n+     *\n+     * @param forceDisconnect true = forces a disconnection , false = disconnects in specific situations\n+     * @throws InterruptedException\n+     */\n+    public void connTivoDisconnect(boolean forceDisconnect) throws InterruptedException {\n+        if (forceDisconnect) {\n+            connSocketDisconnect();\n+        } else {\n+            if (!tivoConfigData.isKeepConnActive()) {\n+                doNappTime();\n+                connSocketDisconnect();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@link connTivoReconnect} disconnect and reconnect the socket connection to the TiVo.\n+     *\n+     * @return boolean true = connection succeeded, false = connection failed\n+     * @throws InterruptedException\n+     */\n+    public boolean connTivoReconnect() throws InterruptedException {\n+        connSocketDisconnect();\n+        doNappTime();\n+        return connTivoConnect();\n+    }\n+\n+    /**\n+     * {@link connSocketDisconnect} cleanly closes the socket connection and dependent objects\n+     *\n+     */\n+    private void connSocketDisconnect() {\n+        TiVoHandler tivoHandler = this.tivoHandler;\n+        StreamReader streamReader = this.streamReader;\n+        PrintStream streamWriter = this.streamWriter;\n+        Socket tivoSocket = this.tivoSocket;\n+\n+        logger.debug(\" connTivoSocket '{}' - requested to disconnect/cleanup connection objects\",\n+                tivoConfigData.getCfgIdentifier());\n+\n+        // if isCfgKeepConnOpen = false, don't set status to OFFLINE since the socket is closed after each command\n+        if (tivoHandler != null && tivoConfigData.isKeepConnActive()) {\n+            tivoHandler.setStatusOffline();\n+        }\n+\n+        try {\n+            if (streamReader != null) {\n+                streamReader.interrupt();\n+                try {\n+                    streamReader.join(TIMEOUT_SEC);\n+                } catch (InterruptedException e) {\n+                    logger.debug(\"Error joining streamReader: {}\", e.getMessage());\n+                }\n+                this.streamReader = null;\n+            }\n+            if (streamWriter != null) {\n+                streamWriter.close();\n+                this.streamWriter = null;\n+            }\n+            if (tivoSocket != null) {\n+                tivoSocket.close();\n+                this.tivoSocket = null;\n+            }\n+\n+        } catch (IOException e) {\n+            logger.debug(\" TiVo '{}' - I/O exception while disconnecting: '{}'.  Connection closed.\",\n+                    tivoConfigData.getCfgIdentifier(), e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * {@link connSocketConnect} opens a Socket connection to the TiVo. Creates a {@link StreamReader} (Input)\n+     * thread to read the responses from the TiVo and a PrintStream (Output) {@link cmdTivoSend}\n+     * to send commands to the device.\n+     *\n+     * @param pConnect true = make a new connection , false = close existing connection\n+     * @return boolean true = connection succeeded, false = connection failed\n+     * @throws InterruptedException\n+     */\n+    private synchronized boolean connSocketConnect() throws InterruptedException {\n+        logger.debug(\" connSocketConnect '{}' - attempting connection to host '{}', port '{}'\",\n+                tivoConfigData.getCfgIdentifier(), tivoConfigData.getHost(), tivoConfigData.getTcpPort());\n+\n+        if (connIsConnected()) {\n+            logger.debug(\" connSocketConnect '{}' - already connected to host '{}', port '{}'\",\n+                    tivoConfigData.getCfgIdentifier(), tivoConfigData.getHost(), tivoConfigData.getTcpPort());\n+            return true;\n+        } else {\n+            // something is wrong, so force a disconnect/clean up so we can try again\n+            connTivoDisconnect(true);\n+        }\n+\n+        try {\n+            Socket tivoSocket = new Socket(tivoConfigData.getHost(), tivoConfigData.getTcpPort());\n+            tivoSocket.setKeepAlive(true);\n+            tivoSocket.setSoTimeout(CONFIG_SOCKET_TIMEOUT_MS);\n+            tivoSocket.setReuseAddress(true);\n+\n+            if (tivoSocket.isConnected() && !tivoSocket.isClosed()) {\n+                if (streamWriter == null) {\n+                    streamWriter = new PrintStream(tivoSocket.getOutputStream(), false);\n+                }\n+                if (this.streamReader == null) {\n+                    StreamReader streamReader = new StreamReader(tivoSocket.getInputStream());\n+                    streamReader.start();\n+                    this.streamReader = streamReader;\n+                }\n+                this.tivoSocket = tivoSocket;\n+            } else {\n+                logger.debug(\" connSocketConnect '{}' - socket creation failed to host '{}', port '{}'\",\n+                        tivoConfigData.getCfgIdentifier(), tivoConfigData.getHost(), tivoConfigData.getTcpPort());\n+                return false;\n+            }\n+\n+            return true;\n+\n+        } catch (UnknownHostException e) {\n+            logger.debug(\" TiVo '{}' - while connecting, unexpected host error: '{}'\",\n+                    tivoConfigData.getCfgIdentifier(), e.getMessage());\n+        } catch (IOException e) {\n+            if (tivoStatusData.getConnectionStatus() != ConnectionStatus.OFFLINE) {\n+                logger.debug(\" TiVo '{}' - I/O exception while connecting: '{}'\", tivoConfigData.getCfgIdentifier(),\n+                        e.getMessage());\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@link doNappTime} sleeps for the period specified by the getCmdWaitInterval parameter. Primarily used to allow\n+     * the TiVo time to process responses after a command is issued.\n+     * \n+     * @throws InterruptedException\n+     */\n+    public void doNappTime() throws InterruptedException {\n+        TimeUnit.MILLISECONDS.sleep(tivoConfigData.getCmdWaitInterval());\n+    }\n+\n+    public TivoStatusData getServiceStatus() {\n+        return tivoStatusData;\n+    }\n+\n+    public void setServiceStatus(TivoStatusData tivoStatusData) {\n+        this.tivoStatusData = tivoStatusData;\n+    }\n+\n+    /**\n+     * {@link StreamReader} data stream reader that reads the status data returned from the TiVo.\n+     *\n+     */\n+    public class StreamReader extends Thread {\n+        private @Nullable BufferedReader bufferedReader = null;\n+\n+        /**\n+         * {@link StreamReader} construct a data stream reader that reads the status data returned from the TiVo via a\n+         * BufferedReader.\n+         *\n+         * @param inputStream socket input stream.\n+         * @throws IOException\n+         */\n+        public StreamReader(InputStream inputStream) {\n+            this.setName(\"OH-binding-\" + thingUid + \"-\" + tivoConfigData.getHost() + \".\" + tivoConfigData.getTcpPort());", "originalCommit": "74830f91371b2211056f20c08d4af94a4572ba40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMTMyNw==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r547621327", "bodyText": "You risk going into a busy loop here if exceptions continue to be thrown.", "author": "cpmeister", "createdAt": "2020-12-23T03:36:28Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/internal/service/TivoStatusProvider.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.internal.service;\n+\n+import static org.openhab.binding.tivo.internal.TiVoBindingConstants.CONFIG_SOCKET_TIMEOUT_MS;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.internal.handler.TiVoHandler;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * TivoStatusProvider class to maintain a connection out to the Tivo, monitor and process status messages returned..\n+ *\n+ * @author Jayson Kubilis - Initial contribution\n+ * @author Andrew Black - Updates / compilation corrections\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TivoStatusProvider {\n+    private static final Pattern TIVO_STATUS_PATTERN = Pattern.compile(\"^CH_STATUS (\\\\d{4}) (?:(\\\\d{4}))?\");\n+    private static final int TIMEOUT_SEC = 3000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(TivoStatusProvider.class);\n+    private @Nullable Socket tivoSocket = null;\n+    private @Nullable PrintStream streamWriter = null;\n+    private @Nullable StreamReader streamReader = null;\n+    private @Nullable TiVoHandler tivoHandler = null;\n+    private TivoStatusData tivoStatusData = new TivoStatusData();\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+    private final String thingUid;\n+\n+    /**\n+     * Instantiates a new TivoConfigStatusProvider.\n+     *\n+     * @param tivoConfigData {@link TivoConfigData} configuration data for the specific thing.\n+     * @param tivoStatusData {@link TivoStatusData} status data for the specific thing.\n+     * @param tivoHandler {@link TivoHandler} parent handler object for the TivoConfigStatusProvider.\n+     *\n+     */\n+\n+    public TivoStatusProvider(TivoConfigData tivoConfigData, TiVoHandler tivoHandler) {\n+        this.tivoStatusData = new TivoStatusData(false, -1, -1, false, \"INITIALISING\", false, ConnectionStatus.UNKNOWN);\n+        this.tivoConfigData = tivoConfigData;\n+        this.tivoHandler = tivoHandler;\n+        this.thingUid = tivoHandler.getThing().getUID().getAsString();\n+    }\n+\n+    /**\n+     * {@link statusRefresh} initiates a connection to the TiVo. When a new connection is made and the TiVo is online,\n+     * the current channel is always returned. The connection is then closed (allows the socket to be used by other\n+     * devices).\n+     *\n+     * @return {@link TivoStatusData} object\n+     * @throws InterruptedException\n+     */\n+    public void statusRefresh() throws InterruptedException {\n+        if (tivoStatusData.getConnectionStatus() != ConnectionStatus.INIT) {\n+            logger.debug(\" statusRefresh '{}' - EXISTING status data - '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    tivoStatusData.toString());\n+        }\n+        connTivoConnect();\n+        doNappTime();\n+        connTivoDisconnect(false);\n+    }\n+\n+    /**\n+     * {@link cmdTivoSend} sends a command to the Tivo.\n+     *\n+     * @param tivoCommand the complete command string (KEYWORD + PARAMETERS e.g. SETCH 102) to send.\n+     * @return {@link TivoStatusData} status data object, contains the result of the command.\n+     * @throws InterruptedException\n+     */\n+    public @Nullable TivoStatusData cmdTivoSend(String tivoCommand) throws InterruptedException {\n+        boolean connected = connTivoConnect();\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (!connected || streamWriter == null) {\n+            return new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false, ConnectionStatus.OFFLINE);\n+        }\n+        logger.debug(\"TiVo '{}' - sending command: '{}'\", tivoConfigData.getCfgIdentifier(), tivoCommand);\n+        int repeatCount = 1;\n+        // Handle special keyboard \"repeat\" commands\n+        if (tivoCommand.contains(\"*\")) {\n+            repeatCount = Integer.parseInt(tivoCommand.substring(tivoCommand.indexOf(\"*\") + 1));\n+            tivoCommand = tivoCommand.substring(0, tivoCommand.indexOf(\"*\"));\n+            logger.debug(\"TiVo '{}' - repeating command: '{}' for '{}' times\", tivoConfigData.getCfgIdentifier(),\n+                    tivoCommand, repeatCount);\n+        }\n+        for (int i = 1; i <= repeatCount; i++) {\n+            // Send the command\n+            streamWriter.println(tivoCommand.toString() + \"\\r\");\n+            if (streamWriter.checkError()) {\n+                logger.debug(\"TiVo '{}' - called cmdTivoSend and encountered an IO error\",\n+                        tivoConfigData.getCfgIdentifier());\n+                tivoStatusData = new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false,\n+                        ConnectionStatus.OFFLINE);\n+                connTivoReconnect();\n+            }\n+        }\n+        return tivoStatusData;\n+    }\n+\n+    /**\n+     * {@link statusParse} processes the {@link TivoStatusData} status message returned from the TiVo.\n+     *\n+     * For channel status messages form 'CH_STATUS channel reason' or 'CH_STATUS channel sub-channel reason' calls\n+     * {@link getParsedChannel} and returns the channel number (if a match is found in a valid formatted message).\n+     *\n+     * @param rawStatus string representing the message text returned by the TiVo\n+     * @return TivoStatusData object conditionally populated based upon the raw status message\n+     */\n+    private TivoStatusData statusParse(String rawStatus) {\n+        logger.debug(\" statusParse '{}' - running on string '{}'\", tivoConfigData.getCfgIdentifier(), rawStatus);\n+\n+        if (rawStatus.contentEquals(\"COMMAND_TIMEOUT\")) {\n+            // Ignore COMMAND_TIMEOUT, they occur a few seconds after each successful command, just return existing\n+            // status again\n+            return this.tivoStatusData;\n+        } else {\n+            switch (rawStatus) {\n+                case \"\":\n+                    return new TivoStatusData(false, -1, -1, false, \"NO_STATUS_DATA_RETURNED\", false,\n+                            tivoStatusData.getConnectionStatus());\n+                case \"LIVETV_READY\":\n+                    return new TivoStatusData(true, -1, -1, false, \"LIVETV_READY\", true, ConnectionStatus.ONLINE);\n+                case \"CH_FAILED NO_LIVE\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED NO_LIVE\", true,\n+                            ConnectionStatus.STANDBY);\n+                case \"CH_FAILED RECORDING\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED RECORDING\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MISSING_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MISSING_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MALFORMED_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MALFORMED_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED INVALID_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED INVALID_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"INVALID_COMMAND\":\n+                    return new TivoStatusData(false, -1, -1, false, \"INVALID_COMMAND\", false, ConnectionStatus.ONLINE);\n+                case \"CONNECTION_RETRIES_EXHAUSTED\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CONNECTION_RETRIES_EXHAUSTED\", true,\n+                            ConnectionStatus.OFFLINE);\n+            }\n+        }\n+\n+        // Only other documented status is in the form 'CH_STATUS channel reason' or\n+        // 'CH_STATUS channel sub-channel reason'\n+        Matcher matcher = TIVO_STATUS_PATTERN.matcher(rawStatus);\n+        int chNum = -1; // -1 used globally to indicate channel number error\n+        int subChNum = -1;\n+        boolean isRecording = false;\n+\n+        if (matcher.find()) {\n+            logger.debug(\" statusParse '{}' - groups '{}' with group count of '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    matcher.group(), matcher.groupCount());\n+            if (matcher.groupCount() == 1 || matcher.groupCount() == 2) {\n+                chNum = Integer.parseInt(matcher.group(1).trim());\n+                logger.debug(\" statusParse '{}' - parsed channel '{}'\", tivoConfigData.getCfgIdentifier(), chNum);\n+            }\n+            if (matcher.groupCount() == 2) {\n+                subChNum = Integer.parseInt(matcher.group(2).trim());\n+                logger.debug(\" statusParse '{}' - parsed sub-channel '{}'\", tivoConfigData.getCfgIdentifier(),\n+                        subChNum);\n+            }\n+\n+            if (rawStatus.contains(\"RECORDING\")) {\n+                isRecording = true;\n+            }\n+\n+            rawStatus = rawStatus.replace(\" REMOTE\", \"\");\n+            rawStatus = rawStatus.replace(\" LOCAL\", \"\");\n+            return new TivoStatusData(true, chNum, subChNum, isRecording, rawStatus, true, ConnectionStatus.ONLINE);\n+        }\n+        logger.warn(\" TiVo '{}' - Unhandled/unexpected status message: '{}'\", tivoConfigData.getCfgIdentifier(),\n+                rawStatus);\n+        return new TivoStatusData(false, -1, -1, false, rawStatus, false, tivoStatusData.getConnectionStatus());\n+    }\n+\n+    /**\n+     * {@link connIsConnected} returns the connection state of the Socket, streamWriter and streamReader objects.\n+     *\n+     * @return true = connection exists and all objects look OK, false = connection does not exist or a problem has\n+     *         occurred\n+     *\n+     */\n+    private boolean connIsConnected() {\n+        Socket tivoSocket = this.tivoSocket;\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (tivoSocket == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (!tivoSocket.isConnected()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isConnected=false\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (tivoSocket.isClosed()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isClosed=true\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter.checkError()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand.checkError()=true\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamReader == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: streamReader=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * {@link connTivoConnect} manages the creation / retry process of the socket connection.\n+     *\n+     * @return true = connected, false = not connected\n+     * @throws InterruptedException\n+     */\n+    public boolean connTivoConnect() throws InterruptedException {\n+        for (int iL = 1; iL <= tivoConfigData.getNumRetry(); iL++) {\n+            logger.debug(\" connTivoConnect '{}' - starting connection process '{}' of '{}'.\",\n+                    tivoConfigData.getCfgIdentifier(), iL, tivoConfigData.getNumRetry());\n+\n+            // Sort out the socket connection\n+            if (connSocketConnect()) {\n+                logger.debug(\" connTivoConnect '{}' - Socket created / connection made.\",\n+                        tivoConfigData.getCfgIdentifier());\n+                StreamReader streamReader = this.streamReader;\n+                if (streamReader != null && streamReader.isAlive()) {\n+                    return true;\n+                }\n+            } else {\n+                logger.debug(\" connTivoConnect '{}' - Socket creation failed.\", tivoConfigData.getCfgIdentifier());\n+                TiVoHandler tivoHandler = this.tivoHandler;\n+                if (tivoHandler != null) {\n+                    tivoHandler.setStatusOffline();\n+                }\n+            }\n+            // Sleep and retry\n+            doNappTime();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@link connTivoDisconnect} conditionally closes the Socket connection. When 'keep connection open' or 'channel\n+     * scanning' is true, the disconnection process is ignored. Disconnect can be forced by setting forceDisconnect to\n+     * true.\n+     *\n+     * @param forceDisconnect true = forces a disconnection , false = disconnects in specific situations\n+     * @throws InterruptedException\n+     */\n+    public void connTivoDisconnect(boolean forceDisconnect) throws InterruptedException {\n+        if (forceDisconnect) {\n+            connSocketDisconnect();\n+        } else {\n+            if (!tivoConfigData.isKeepConnActive()) {\n+                doNappTime();\n+                connSocketDisconnect();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@link connTivoReconnect} disconnect and reconnect the socket connection to the TiVo.\n+     *\n+     * @return boolean true = connection succeeded, false = connection failed\n+     * @throws InterruptedException\n+     */\n+    public boolean connTivoReconnect() throws InterruptedException {\n+        connSocketDisconnect();\n+        doNappTime();\n+        return connTivoConnect();\n+    }\n+\n+    /**\n+     * {@link connSocketDisconnect} cleanly closes the socket connection and dependent objects\n+     *\n+     */\n+    private void connSocketDisconnect() {\n+        TiVoHandler tivoHandler = this.tivoHandler;\n+        StreamReader streamReader = this.streamReader;\n+        PrintStream streamWriter = this.streamWriter;\n+        Socket tivoSocket = this.tivoSocket;\n+\n+        logger.debug(\" connTivoSocket '{}' - requested to disconnect/cleanup connection objects\",\n+                tivoConfigData.getCfgIdentifier());\n+\n+        // if isCfgKeepConnOpen = false, don't set status to OFFLINE since the socket is closed after each command\n+        if (tivoHandler != null && tivoConfigData.isKeepConnActive()) {\n+            tivoHandler.setStatusOffline();\n+        }\n+\n+        try {\n+            if (streamReader != null) {\n+                streamReader.interrupt();\n+                try {\n+                    streamReader.join(TIMEOUT_SEC);\n+                } catch (InterruptedException e) {\n+                    logger.debug(\"Error joining streamReader: {}\", e.getMessage());\n+                }\n+                this.streamReader = null;\n+            }\n+            if (streamWriter != null) {\n+                streamWriter.close();\n+                this.streamWriter = null;\n+            }\n+            if (tivoSocket != null) {\n+                tivoSocket.close();\n+                this.tivoSocket = null;\n+            }\n+\n+        } catch (IOException e) {\n+            logger.debug(\" TiVo '{}' - I/O exception while disconnecting: '{}'.  Connection closed.\",\n+                    tivoConfigData.getCfgIdentifier(), e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * {@link connSocketConnect} opens a Socket connection to the TiVo. Creates a {@link StreamReader} (Input)\n+     * thread to read the responses from the TiVo and a PrintStream (Output) {@link cmdTivoSend}\n+     * to send commands to the device.\n+     *\n+     * @param pConnect true = make a new connection , false = close existing connection\n+     * @return boolean true = connection succeeded, false = connection failed\n+     * @throws InterruptedException\n+     */\n+    private synchronized boolean connSocketConnect() throws InterruptedException {\n+        logger.debug(\" connSocketConnect '{}' - attempting connection to host '{}', port '{}'\",\n+                tivoConfigData.getCfgIdentifier(), tivoConfigData.getHost(), tivoConfigData.getTcpPort());\n+\n+        if (connIsConnected()) {\n+            logger.debug(\" connSocketConnect '{}' - already connected to host '{}', port '{}'\",\n+                    tivoConfigData.getCfgIdentifier(), tivoConfigData.getHost(), tivoConfigData.getTcpPort());\n+            return true;\n+        } else {\n+            // something is wrong, so force a disconnect/clean up so we can try again\n+            connTivoDisconnect(true);\n+        }\n+\n+        try {\n+            Socket tivoSocket = new Socket(tivoConfigData.getHost(), tivoConfigData.getTcpPort());\n+            tivoSocket.setKeepAlive(true);\n+            tivoSocket.setSoTimeout(CONFIG_SOCKET_TIMEOUT_MS);\n+            tivoSocket.setReuseAddress(true);\n+\n+            if (tivoSocket.isConnected() && !tivoSocket.isClosed()) {\n+                if (streamWriter == null) {\n+                    streamWriter = new PrintStream(tivoSocket.getOutputStream(), false);\n+                }\n+                if (this.streamReader == null) {\n+                    StreamReader streamReader = new StreamReader(tivoSocket.getInputStream());\n+                    streamReader.start();\n+                    this.streamReader = streamReader;\n+                }\n+                this.tivoSocket = tivoSocket;\n+            } else {\n+                logger.debug(\" connSocketConnect '{}' - socket creation failed to host '{}', port '{}'\",\n+                        tivoConfigData.getCfgIdentifier(), tivoConfigData.getHost(), tivoConfigData.getTcpPort());\n+                return false;\n+            }\n+\n+            return true;\n+\n+        } catch (UnknownHostException e) {\n+            logger.debug(\" TiVo '{}' - while connecting, unexpected host error: '{}'\",\n+                    tivoConfigData.getCfgIdentifier(), e.getMessage());\n+        } catch (IOException e) {\n+            if (tivoStatusData.getConnectionStatus() != ConnectionStatus.OFFLINE) {\n+                logger.debug(\" TiVo '{}' - I/O exception while connecting: '{}'\", tivoConfigData.getCfgIdentifier(),\n+                        e.getMessage());\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@link doNappTime} sleeps for the period specified by the getCmdWaitInterval parameter. Primarily used to allow\n+     * the TiVo time to process responses after a command is issued.\n+     * \n+     * @throws InterruptedException\n+     */\n+    public void doNappTime() throws InterruptedException {\n+        TimeUnit.MILLISECONDS.sleep(tivoConfigData.getCmdWaitInterval());\n+    }\n+\n+    public TivoStatusData getServiceStatus() {\n+        return tivoStatusData;\n+    }\n+\n+    public void setServiceStatus(TivoStatusData tivoStatusData) {\n+        this.tivoStatusData = tivoStatusData;\n+    }\n+\n+    /**\n+     * {@link StreamReader} data stream reader that reads the status data returned from the TiVo.\n+     *\n+     */\n+    public class StreamReader extends Thread {\n+        private @Nullable BufferedReader bufferedReader = null;\n+\n+        /**\n+         * {@link StreamReader} construct a data stream reader that reads the status data returned from the TiVo via a\n+         * BufferedReader.\n+         *\n+         * @param inputStream socket input stream.\n+         * @throws IOException\n+         */\n+        public StreamReader(InputStream inputStream) {\n+            this.setName(\"OH-binding-\" + thingUid + \"-\" + tivoConfigData.getHost() + \".\" + tivoConfigData.getTcpPort());\n+            this.bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n+            this.setDaemon(true);\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                logger.debug(\"streamReader {} is running. \", tivoConfigData.getCfgIdentifier());\n+                while (!Thread.currentThread().isInterrupted()) {\n+                    String receivedData = null;\n+                    try {\n+                        BufferedReader reader = bufferedReader;\n+                        if (reader != null) {\n+                            receivedData = reader.readLine();\n+                        }\n+                    } catch (SocketTimeoutException | SocketException e) {\n+                        // Do nothing. Just allow the thread to check if it has to stop.\n+                    }", "originalCommit": "74830f91371b2211056f20c08d4af94a4572ba40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5MzUyNg==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r548793526", "bodyText": "fixed", "author": "mlobstein", "createdAt": "2020-12-25T03:54:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMTMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMTQ3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r547621477", "bodyText": "You will busy loop if reader is null. Please avoid busy loops at all costs.", "author": "cpmeister", "createdAt": "2020-12-23T03:37:02Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/internal/service/TivoStatusProvider.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.internal.service;\n+\n+import static org.openhab.binding.tivo.internal.TiVoBindingConstants.CONFIG_SOCKET_TIMEOUT_MS;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.internal.handler.TiVoHandler;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * TivoStatusProvider class to maintain a connection out to the Tivo, monitor and process status messages returned..\n+ *\n+ * @author Jayson Kubilis - Initial contribution\n+ * @author Andrew Black - Updates / compilation corrections\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TivoStatusProvider {\n+    private static final Pattern TIVO_STATUS_PATTERN = Pattern.compile(\"^CH_STATUS (\\\\d{4}) (?:(\\\\d{4}))?\");\n+    private static final int TIMEOUT_SEC = 3000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(TivoStatusProvider.class);\n+    private @Nullable Socket tivoSocket = null;\n+    private @Nullable PrintStream streamWriter = null;\n+    private @Nullable StreamReader streamReader = null;\n+    private @Nullable TiVoHandler tivoHandler = null;\n+    private TivoStatusData tivoStatusData = new TivoStatusData();\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+    private final String thingUid;\n+\n+    /**\n+     * Instantiates a new TivoConfigStatusProvider.\n+     *\n+     * @param tivoConfigData {@link TivoConfigData} configuration data for the specific thing.\n+     * @param tivoStatusData {@link TivoStatusData} status data for the specific thing.\n+     * @param tivoHandler {@link TivoHandler} parent handler object for the TivoConfigStatusProvider.\n+     *\n+     */\n+\n+    public TivoStatusProvider(TivoConfigData tivoConfigData, TiVoHandler tivoHandler) {\n+        this.tivoStatusData = new TivoStatusData(false, -1, -1, false, \"INITIALISING\", false, ConnectionStatus.UNKNOWN);\n+        this.tivoConfigData = tivoConfigData;\n+        this.tivoHandler = tivoHandler;\n+        this.thingUid = tivoHandler.getThing().getUID().getAsString();\n+    }\n+\n+    /**\n+     * {@link statusRefresh} initiates a connection to the TiVo. When a new connection is made and the TiVo is online,\n+     * the current channel is always returned. The connection is then closed (allows the socket to be used by other\n+     * devices).\n+     *\n+     * @return {@link TivoStatusData} object\n+     * @throws InterruptedException\n+     */\n+    public void statusRefresh() throws InterruptedException {\n+        if (tivoStatusData.getConnectionStatus() != ConnectionStatus.INIT) {\n+            logger.debug(\" statusRefresh '{}' - EXISTING status data - '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    tivoStatusData.toString());\n+        }\n+        connTivoConnect();\n+        doNappTime();\n+        connTivoDisconnect(false);\n+    }\n+\n+    /**\n+     * {@link cmdTivoSend} sends a command to the Tivo.\n+     *\n+     * @param tivoCommand the complete command string (KEYWORD + PARAMETERS e.g. SETCH 102) to send.\n+     * @return {@link TivoStatusData} status data object, contains the result of the command.\n+     * @throws InterruptedException\n+     */\n+    public @Nullable TivoStatusData cmdTivoSend(String tivoCommand) throws InterruptedException {\n+        boolean connected = connTivoConnect();\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (!connected || streamWriter == null) {\n+            return new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false, ConnectionStatus.OFFLINE);\n+        }\n+        logger.debug(\"TiVo '{}' - sending command: '{}'\", tivoConfigData.getCfgIdentifier(), tivoCommand);\n+        int repeatCount = 1;\n+        // Handle special keyboard \"repeat\" commands\n+        if (tivoCommand.contains(\"*\")) {\n+            repeatCount = Integer.parseInt(tivoCommand.substring(tivoCommand.indexOf(\"*\") + 1));\n+            tivoCommand = tivoCommand.substring(0, tivoCommand.indexOf(\"*\"));\n+            logger.debug(\"TiVo '{}' - repeating command: '{}' for '{}' times\", tivoConfigData.getCfgIdentifier(),\n+                    tivoCommand, repeatCount);\n+        }\n+        for (int i = 1; i <= repeatCount; i++) {\n+            // Send the command\n+            streamWriter.println(tivoCommand.toString() + \"\\r\");\n+            if (streamWriter.checkError()) {\n+                logger.debug(\"TiVo '{}' - called cmdTivoSend and encountered an IO error\",\n+                        tivoConfigData.getCfgIdentifier());\n+                tivoStatusData = new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false,\n+                        ConnectionStatus.OFFLINE);\n+                connTivoReconnect();\n+            }\n+        }\n+        return tivoStatusData;\n+    }\n+\n+    /**\n+     * {@link statusParse} processes the {@link TivoStatusData} status message returned from the TiVo.\n+     *\n+     * For channel status messages form 'CH_STATUS channel reason' or 'CH_STATUS channel sub-channel reason' calls\n+     * {@link getParsedChannel} and returns the channel number (if a match is found in a valid formatted message).\n+     *\n+     * @param rawStatus string representing the message text returned by the TiVo\n+     * @return TivoStatusData object conditionally populated based upon the raw status message\n+     */\n+    private TivoStatusData statusParse(String rawStatus) {\n+        logger.debug(\" statusParse '{}' - running on string '{}'\", tivoConfigData.getCfgIdentifier(), rawStatus);\n+\n+        if (rawStatus.contentEquals(\"COMMAND_TIMEOUT\")) {\n+            // Ignore COMMAND_TIMEOUT, they occur a few seconds after each successful command, just return existing\n+            // status again\n+            return this.tivoStatusData;\n+        } else {\n+            switch (rawStatus) {\n+                case \"\":\n+                    return new TivoStatusData(false, -1, -1, false, \"NO_STATUS_DATA_RETURNED\", false,\n+                            tivoStatusData.getConnectionStatus());\n+                case \"LIVETV_READY\":\n+                    return new TivoStatusData(true, -1, -1, false, \"LIVETV_READY\", true, ConnectionStatus.ONLINE);\n+                case \"CH_FAILED NO_LIVE\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED NO_LIVE\", true,\n+                            ConnectionStatus.STANDBY);\n+                case \"CH_FAILED RECORDING\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED RECORDING\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MISSING_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MISSING_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MALFORMED_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MALFORMED_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED INVALID_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED INVALID_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"INVALID_COMMAND\":\n+                    return new TivoStatusData(false, -1, -1, false, \"INVALID_COMMAND\", false, ConnectionStatus.ONLINE);\n+                case \"CONNECTION_RETRIES_EXHAUSTED\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CONNECTION_RETRIES_EXHAUSTED\", true,\n+                            ConnectionStatus.OFFLINE);\n+            }\n+        }\n+\n+        // Only other documented status is in the form 'CH_STATUS channel reason' or\n+        // 'CH_STATUS channel sub-channel reason'\n+        Matcher matcher = TIVO_STATUS_PATTERN.matcher(rawStatus);\n+        int chNum = -1; // -1 used globally to indicate channel number error\n+        int subChNum = -1;\n+        boolean isRecording = false;\n+\n+        if (matcher.find()) {\n+            logger.debug(\" statusParse '{}' - groups '{}' with group count of '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    matcher.group(), matcher.groupCount());\n+            if (matcher.groupCount() == 1 || matcher.groupCount() == 2) {\n+                chNum = Integer.parseInt(matcher.group(1).trim());\n+                logger.debug(\" statusParse '{}' - parsed channel '{}'\", tivoConfigData.getCfgIdentifier(), chNum);\n+            }\n+            if (matcher.groupCount() == 2) {\n+                subChNum = Integer.parseInt(matcher.group(2).trim());\n+                logger.debug(\" statusParse '{}' - parsed sub-channel '{}'\", tivoConfigData.getCfgIdentifier(),\n+                        subChNum);\n+            }\n+\n+            if (rawStatus.contains(\"RECORDING\")) {\n+                isRecording = true;\n+            }\n+\n+            rawStatus = rawStatus.replace(\" REMOTE\", \"\");\n+            rawStatus = rawStatus.replace(\" LOCAL\", \"\");\n+            return new TivoStatusData(true, chNum, subChNum, isRecording, rawStatus, true, ConnectionStatus.ONLINE);\n+        }\n+        logger.warn(\" TiVo '{}' - Unhandled/unexpected status message: '{}'\", tivoConfigData.getCfgIdentifier(),\n+                rawStatus);\n+        return new TivoStatusData(false, -1, -1, false, rawStatus, false, tivoStatusData.getConnectionStatus());\n+    }\n+\n+    /**\n+     * {@link connIsConnected} returns the connection state of the Socket, streamWriter and streamReader objects.\n+     *\n+     * @return true = connection exists and all objects look OK, false = connection does not exist or a problem has\n+     *         occurred\n+     *\n+     */\n+    private boolean connIsConnected() {\n+        Socket tivoSocket = this.tivoSocket;\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (tivoSocket == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (!tivoSocket.isConnected()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isConnected=false\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (tivoSocket.isClosed()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isClosed=true\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter.checkError()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand.checkError()=true\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamReader == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: streamReader=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * {@link connTivoConnect} manages the creation / retry process of the socket connection.\n+     *\n+     * @return true = connected, false = not connected\n+     * @throws InterruptedException\n+     */\n+    public boolean connTivoConnect() throws InterruptedException {\n+        for (int iL = 1; iL <= tivoConfigData.getNumRetry(); iL++) {\n+            logger.debug(\" connTivoConnect '{}' - starting connection process '{}' of '{}'.\",\n+                    tivoConfigData.getCfgIdentifier(), iL, tivoConfigData.getNumRetry());\n+\n+            // Sort out the socket connection\n+            if (connSocketConnect()) {\n+                logger.debug(\" connTivoConnect '{}' - Socket created / connection made.\",\n+                        tivoConfigData.getCfgIdentifier());\n+                StreamReader streamReader = this.streamReader;\n+                if (streamReader != null && streamReader.isAlive()) {\n+                    return true;\n+                }\n+            } else {\n+                logger.debug(\" connTivoConnect '{}' - Socket creation failed.\", tivoConfigData.getCfgIdentifier());\n+                TiVoHandler tivoHandler = this.tivoHandler;\n+                if (tivoHandler != null) {\n+                    tivoHandler.setStatusOffline();\n+                }\n+            }\n+            // Sleep and retry\n+            doNappTime();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@link connTivoDisconnect} conditionally closes the Socket connection. When 'keep connection open' or 'channel\n+     * scanning' is true, the disconnection process is ignored. Disconnect can be forced by setting forceDisconnect to\n+     * true.\n+     *\n+     * @param forceDisconnect true = forces a disconnection , false = disconnects in specific situations\n+     * @throws InterruptedException\n+     */\n+    public void connTivoDisconnect(boolean forceDisconnect) throws InterruptedException {\n+        if (forceDisconnect) {\n+            connSocketDisconnect();\n+        } else {\n+            if (!tivoConfigData.isKeepConnActive()) {\n+                doNappTime();\n+                connSocketDisconnect();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@link connTivoReconnect} disconnect and reconnect the socket connection to the TiVo.\n+     *\n+     * @return boolean true = connection succeeded, false = connection failed\n+     * @throws InterruptedException\n+     */\n+    public boolean connTivoReconnect() throws InterruptedException {\n+        connSocketDisconnect();\n+        doNappTime();\n+        return connTivoConnect();\n+    }\n+\n+    /**\n+     * {@link connSocketDisconnect} cleanly closes the socket connection and dependent objects\n+     *\n+     */\n+    private void connSocketDisconnect() {\n+        TiVoHandler tivoHandler = this.tivoHandler;\n+        StreamReader streamReader = this.streamReader;\n+        PrintStream streamWriter = this.streamWriter;\n+        Socket tivoSocket = this.tivoSocket;\n+\n+        logger.debug(\" connTivoSocket '{}' - requested to disconnect/cleanup connection objects\",\n+                tivoConfigData.getCfgIdentifier());\n+\n+        // if isCfgKeepConnOpen = false, don't set status to OFFLINE since the socket is closed after each command\n+        if (tivoHandler != null && tivoConfigData.isKeepConnActive()) {\n+            tivoHandler.setStatusOffline();\n+        }\n+\n+        try {\n+            if (streamReader != null) {\n+                streamReader.interrupt();\n+                try {\n+                    streamReader.join(TIMEOUT_SEC);\n+                } catch (InterruptedException e) {\n+                    logger.debug(\"Error joining streamReader: {}\", e.getMessage());\n+                }\n+                this.streamReader = null;\n+            }\n+            if (streamWriter != null) {\n+                streamWriter.close();\n+                this.streamWriter = null;\n+            }\n+            if (tivoSocket != null) {\n+                tivoSocket.close();\n+                this.tivoSocket = null;\n+            }\n+\n+        } catch (IOException e) {\n+            logger.debug(\" TiVo '{}' - I/O exception while disconnecting: '{}'.  Connection closed.\",\n+                    tivoConfigData.getCfgIdentifier(), e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * {@link connSocketConnect} opens a Socket connection to the TiVo. Creates a {@link StreamReader} (Input)\n+     * thread to read the responses from the TiVo and a PrintStream (Output) {@link cmdTivoSend}\n+     * to send commands to the device.\n+     *\n+     * @param pConnect true = make a new connection , false = close existing connection\n+     * @return boolean true = connection succeeded, false = connection failed\n+     * @throws InterruptedException\n+     */\n+    private synchronized boolean connSocketConnect() throws InterruptedException {\n+        logger.debug(\" connSocketConnect '{}' - attempting connection to host '{}', port '{}'\",\n+                tivoConfigData.getCfgIdentifier(), tivoConfigData.getHost(), tivoConfigData.getTcpPort());\n+\n+        if (connIsConnected()) {\n+            logger.debug(\" connSocketConnect '{}' - already connected to host '{}', port '{}'\",\n+                    tivoConfigData.getCfgIdentifier(), tivoConfigData.getHost(), tivoConfigData.getTcpPort());\n+            return true;\n+        } else {\n+            // something is wrong, so force a disconnect/clean up so we can try again\n+            connTivoDisconnect(true);\n+        }\n+\n+        try {\n+            Socket tivoSocket = new Socket(tivoConfigData.getHost(), tivoConfigData.getTcpPort());\n+            tivoSocket.setKeepAlive(true);\n+            tivoSocket.setSoTimeout(CONFIG_SOCKET_TIMEOUT_MS);\n+            tivoSocket.setReuseAddress(true);\n+\n+            if (tivoSocket.isConnected() && !tivoSocket.isClosed()) {\n+                if (streamWriter == null) {\n+                    streamWriter = new PrintStream(tivoSocket.getOutputStream(), false);\n+                }\n+                if (this.streamReader == null) {\n+                    StreamReader streamReader = new StreamReader(tivoSocket.getInputStream());\n+                    streamReader.start();\n+                    this.streamReader = streamReader;\n+                }\n+                this.tivoSocket = tivoSocket;\n+            } else {\n+                logger.debug(\" connSocketConnect '{}' - socket creation failed to host '{}', port '{}'\",\n+                        tivoConfigData.getCfgIdentifier(), tivoConfigData.getHost(), tivoConfigData.getTcpPort());\n+                return false;\n+            }\n+\n+            return true;\n+\n+        } catch (UnknownHostException e) {\n+            logger.debug(\" TiVo '{}' - while connecting, unexpected host error: '{}'\",\n+                    tivoConfigData.getCfgIdentifier(), e.getMessage());\n+        } catch (IOException e) {\n+            if (tivoStatusData.getConnectionStatus() != ConnectionStatus.OFFLINE) {\n+                logger.debug(\" TiVo '{}' - I/O exception while connecting: '{}'\", tivoConfigData.getCfgIdentifier(),\n+                        e.getMessage());\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@link doNappTime} sleeps for the period specified by the getCmdWaitInterval parameter. Primarily used to allow\n+     * the TiVo time to process responses after a command is issued.\n+     * \n+     * @throws InterruptedException\n+     */\n+    public void doNappTime() throws InterruptedException {\n+        TimeUnit.MILLISECONDS.sleep(tivoConfigData.getCmdWaitInterval());\n+    }\n+\n+    public TivoStatusData getServiceStatus() {\n+        return tivoStatusData;\n+    }\n+\n+    public void setServiceStatus(TivoStatusData tivoStatusData) {\n+        this.tivoStatusData = tivoStatusData;\n+    }\n+\n+    /**\n+     * {@link StreamReader} data stream reader that reads the status data returned from the TiVo.\n+     *\n+     */\n+    public class StreamReader extends Thread {\n+        private @Nullable BufferedReader bufferedReader = null;\n+\n+        /**\n+         * {@link StreamReader} construct a data stream reader that reads the status data returned from the TiVo via a\n+         * BufferedReader.\n+         *\n+         * @param inputStream socket input stream.\n+         * @throws IOException\n+         */\n+        public StreamReader(InputStream inputStream) {\n+            this.setName(\"OH-binding-\" + thingUid + \"-\" + tivoConfigData.getHost() + \".\" + tivoConfigData.getTcpPort());\n+            this.bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n+            this.setDaemon(true);\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                logger.debug(\"streamReader {} is running. \", tivoConfigData.getCfgIdentifier());\n+                while (!Thread.currentThread().isInterrupted()) {\n+                    String receivedData = null;\n+                    try {\n+                        BufferedReader reader = bufferedReader;\n+                        if (reader != null) {\n+                            receivedData = reader.readLine();\n+                        }", "originalCommit": "74830f91371b2211056f20c08d4af94a4572ba40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5MzQ2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r548793462", "bodyText": "Changed to throw exception if reader is null.", "author": "mlobstein", "createdAt": "2020-12-25T03:53:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMTQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjQzOA==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r547622438", "bodyText": "You are performing two different behaviors based on the input boolean parameter. It would be better if you split this into two different methods instead.", "author": "cpmeister", "createdAt": "2020-12-23T03:41:14Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/internal/service/TivoStatusProvider.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.internal.service;\n+\n+import static org.openhab.binding.tivo.internal.TiVoBindingConstants.CONFIG_SOCKET_TIMEOUT_MS;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.internal.handler.TiVoHandler;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * TivoStatusProvider class to maintain a connection out to the Tivo, monitor and process status messages returned..\n+ *\n+ * @author Jayson Kubilis - Initial contribution\n+ * @author Andrew Black - Updates / compilation corrections\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TivoStatusProvider {\n+    private static final Pattern TIVO_STATUS_PATTERN = Pattern.compile(\"^CH_STATUS (\\\\d{4}) (?:(\\\\d{4}))?\");\n+    private static final int TIMEOUT_SEC = 3000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(TivoStatusProvider.class);\n+    private @Nullable Socket tivoSocket = null;\n+    private @Nullable PrintStream streamWriter = null;\n+    private @Nullable StreamReader streamReader = null;\n+    private @Nullable TiVoHandler tivoHandler = null;\n+    private TivoStatusData tivoStatusData = new TivoStatusData();\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+    private final String thingUid;\n+\n+    /**\n+     * Instantiates a new TivoConfigStatusProvider.\n+     *\n+     * @param tivoConfigData {@link TivoConfigData} configuration data for the specific thing.\n+     * @param tivoStatusData {@link TivoStatusData} status data for the specific thing.\n+     * @param tivoHandler {@link TivoHandler} parent handler object for the TivoConfigStatusProvider.\n+     *\n+     */\n+\n+    public TivoStatusProvider(TivoConfigData tivoConfigData, TiVoHandler tivoHandler) {\n+        this.tivoStatusData = new TivoStatusData(false, -1, -1, false, \"INITIALISING\", false, ConnectionStatus.UNKNOWN);\n+        this.tivoConfigData = tivoConfigData;\n+        this.tivoHandler = tivoHandler;\n+        this.thingUid = tivoHandler.getThing().getUID().getAsString();\n+    }\n+\n+    /**\n+     * {@link statusRefresh} initiates a connection to the TiVo. When a new connection is made and the TiVo is online,\n+     * the current channel is always returned. The connection is then closed (allows the socket to be used by other\n+     * devices).\n+     *\n+     * @return {@link TivoStatusData} object\n+     * @throws InterruptedException\n+     */\n+    public void statusRefresh() throws InterruptedException {\n+        if (tivoStatusData.getConnectionStatus() != ConnectionStatus.INIT) {\n+            logger.debug(\" statusRefresh '{}' - EXISTING status data - '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    tivoStatusData.toString());\n+        }\n+        connTivoConnect();\n+        doNappTime();\n+        connTivoDisconnect(false);\n+    }\n+\n+    /**\n+     * {@link cmdTivoSend} sends a command to the Tivo.\n+     *\n+     * @param tivoCommand the complete command string (KEYWORD + PARAMETERS e.g. SETCH 102) to send.\n+     * @return {@link TivoStatusData} status data object, contains the result of the command.\n+     * @throws InterruptedException\n+     */\n+    public @Nullable TivoStatusData cmdTivoSend(String tivoCommand) throws InterruptedException {\n+        boolean connected = connTivoConnect();\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (!connected || streamWriter == null) {\n+            return new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false, ConnectionStatus.OFFLINE);\n+        }\n+        logger.debug(\"TiVo '{}' - sending command: '{}'\", tivoConfigData.getCfgIdentifier(), tivoCommand);\n+        int repeatCount = 1;\n+        // Handle special keyboard \"repeat\" commands\n+        if (tivoCommand.contains(\"*\")) {\n+            repeatCount = Integer.parseInt(tivoCommand.substring(tivoCommand.indexOf(\"*\") + 1));\n+            tivoCommand = tivoCommand.substring(0, tivoCommand.indexOf(\"*\"));\n+            logger.debug(\"TiVo '{}' - repeating command: '{}' for '{}' times\", tivoConfigData.getCfgIdentifier(),\n+                    tivoCommand, repeatCount);\n+        }\n+        for (int i = 1; i <= repeatCount; i++) {\n+            // Send the command\n+            streamWriter.println(tivoCommand.toString() + \"\\r\");\n+            if (streamWriter.checkError()) {\n+                logger.debug(\"TiVo '{}' - called cmdTivoSend and encountered an IO error\",\n+                        tivoConfigData.getCfgIdentifier());\n+                tivoStatusData = new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false,\n+                        ConnectionStatus.OFFLINE);\n+                connTivoReconnect();\n+            }\n+        }\n+        return tivoStatusData;\n+    }\n+\n+    /**\n+     * {@link statusParse} processes the {@link TivoStatusData} status message returned from the TiVo.\n+     *\n+     * For channel status messages form 'CH_STATUS channel reason' or 'CH_STATUS channel sub-channel reason' calls\n+     * {@link getParsedChannel} and returns the channel number (if a match is found in a valid formatted message).\n+     *\n+     * @param rawStatus string representing the message text returned by the TiVo\n+     * @return TivoStatusData object conditionally populated based upon the raw status message\n+     */\n+    private TivoStatusData statusParse(String rawStatus) {\n+        logger.debug(\" statusParse '{}' - running on string '{}'\", tivoConfigData.getCfgIdentifier(), rawStatus);\n+\n+        if (rawStatus.contentEquals(\"COMMAND_TIMEOUT\")) {\n+            // Ignore COMMAND_TIMEOUT, they occur a few seconds after each successful command, just return existing\n+            // status again\n+            return this.tivoStatusData;\n+        } else {\n+            switch (rawStatus) {\n+                case \"\":\n+                    return new TivoStatusData(false, -1, -1, false, \"NO_STATUS_DATA_RETURNED\", false,\n+                            tivoStatusData.getConnectionStatus());\n+                case \"LIVETV_READY\":\n+                    return new TivoStatusData(true, -1, -1, false, \"LIVETV_READY\", true, ConnectionStatus.ONLINE);\n+                case \"CH_FAILED NO_LIVE\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED NO_LIVE\", true,\n+                            ConnectionStatus.STANDBY);\n+                case \"CH_FAILED RECORDING\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED RECORDING\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MISSING_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MISSING_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MALFORMED_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MALFORMED_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED INVALID_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED INVALID_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"INVALID_COMMAND\":\n+                    return new TivoStatusData(false, -1, -1, false, \"INVALID_COMMAND\", false, ConnectionStatus.ONLINE);\n+                case \"CONNECTION_RETRIES_EXHAUSTED\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CONNECTION_RETRIES_EXHAUSTED\", true,\n+                            ConnectionStatus.OFFLINE);\n+            }\n+        }\n+\n+        // Only other documented status is in the form 'CH_STATUS channel reason' or\n+        // 'CH_STATUS channel sub-channel reason'\n+        Matcher matcher = TIVO_STATUS_PATTERN.matcher(rawStatus);\n+        int chNum = -1; // -1 used globally to indicate channel number error\n+        int subChNum = -1;\n+        boolean isRecording = false;\n+\n+        if (matcher.find()) {\n+            logger.debug(\" statusParse '{}' - groups '{}' with group count of '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    matcher.group(), matcher.groupCount());\n+            if (matcher.groupCount() == 1 || matcher.groupCount() == 2) {\n+                chNum = Integer.parseInt(matcher.group(1).trim());\n+                logger.debug(\" statusParse '{}' - parsed channel '{}'\", tivoConfigData.getCfgIdentifier(), chNum);\n+            }\n+            if (matcher.groupCount() == 2) {\n+                subChNum = Integer.parseInt(matcher.group(2).trim());\n+                logger.debug(\" statusParse '{}' - parsed sub-channel '{}'\", tivoConfigData.getCfgIdentifier(),\n+                        subChNum);\n+            }\n+\n+            if (rawStatus.contains(\"RECORDING\")) {\n+                isRecording = true;\n+            }\n+\n+            rawStatus = rawStatus.replace(\" REMOTE\", \"\");\n+            rawStatus = rawStatus.replace(\" LOCAL\", \"\");\n+            return new TivoStatusData(true, chNum, subChNum, isRecording, rawStatus, true, ConnectionStatus.ONLINE);\n+        }\n+        logger.warn(\" TiVo '{}' - Unhandled/unexpected status message: '{}'\", tivoConfigData.getCfgIdentifier(),\n+                rawStatus);\n+        return new TivoStatusData(false, -1, -1, false, rawStatus, false, tivoStatusData.getConnectionStatus());\n+    }\n+\n+    /**\n+     * {@link connIsConnected} returns the connection state of the Socket, streamWriter and streamReader objects.\n+     *\n+     * @return true = connection exists and all objects look OK, false = connection does not exist or a problem has\n+     *         occurred\n+     *\n+     */\n+    private boolean connIsConnected() {\n+        Socket tivoSocket = this.tivoSocket;\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (tivoSocket == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (!tivoSocket.isConnected()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isConnected=false\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (tivoSocket.isClosed()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isClosed=true\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter.checkError()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand.checkError()=true\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamReader == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: streamReader=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * {@link connTivoConnect} manages the creation / retry process of the socket connection.\n+     *\n+     * @return true = connected, false = not connected\n+     * @throws InterruptedException\n+     */\n+    public boolean connTivoConnect() throws InterruptedException {\n+        for (int iL = 1; iL <= tivoConfigData.getNumRetry(); iL++) {\n+            logger.debug(\" connTivoConnect '{}' - starting connection process '{}' of '{}'.\",\n+                    tivoConfigData.getCfgIdentifier(), iL, tivoConfigData.getNumRetry());\n+\n+            // Sort out the socket connection\n+            if (connSocketConnect()) {\n+                logger.debug(\" connTivoConnect '{}' - Socket created / connection made.\",\n+                        tivoConfigData.getCfgIdentifier());\n+                StreamReader streamReader = this.streamReader;\n+                if (streamReader != null && streamReader.isAlive()) {\n+                    return true;\n+                }\n+            } else {\n+                logger.debug(\" connTivoConnect '{}' - Socket creation failed.\", tivoConfigData.getCfgIdentifier());\n+                TiVoHandler tivoHandler = this.tivoHandler;\n+                if (tivoHandler != null) {\n+                    tivoHandler.setStatusOffline();\n+                }\n+            }\n+            // Sleep and retry\n+            doNappTime();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@link connTivoDisconnect} conditionally closes the Socket connection. When 'keep connection open' or 'channel\n+     * scanning' is true, the disconnection process is ignored. Disconnect can be forced by setting forceDisconnect to\n+     * true.\n+     *\n+     * @param forceDisconnect true = forces a disconnection , false = disconnects in specific situations\n+     * @throws InterruptedException\n+     */\n+    public void connTivoDisconnect(boolean forceDisconnect) throws InterruptedException {\n+        if (forceDisconnect) {\n+            connSocketDisconnect();\n+        } else {\n+            if (!tivoConfigData.isKeepConnActive()) {\n+                doNappTime();\n+                connSocketDisconnect();\n+            }\n+        }", "originalCommit": "74830f91371b2211056f20c08d4af94a4572ba40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5Mjg5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r548792897", "bodyText": "Agreed. I simplified the logic.", "author": "mlobstein", "createdAt": "2020-12-25T03:49:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjQzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjc1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r547622753", "bodyText": "If closing of the writer fails, you should still attempt to close the socket.", "author": "cpmeister", "createdAt": "2020-12-23T03:42:34Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/internal/service/TivoStatusProvider.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.internal.service;\n+\n+import static org.openhab.binding.tivo.internal.TiVoBindingConstants.CONFIG_SOCKET_TIMEOUT_MS;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.internal.handler.TiVoHandler;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * TivoStatusProvider class to maintain a connection out to the Tivo, monitor and process status messages returned..\n+ *\n+ * @author Jayson Kubilis - Initial contribution\n+ * @author Andrew Black - Updates / compilation corrections\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TivoStatusProvider {\n+    private static final Pattern TIVO_STATUS_PATTERN = Pattern.compile(\"^CH_STATUS (\\\\d{4}) (?:(\\\\d{4}))?\");\n+    private static final int TIMEOUT_SEC = 3000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(TivoStatusProvider.class);\n+    private @Nullable Socket tivoSocket = null;\n+    private @Nullable PrintStream streamWriter = null;\n+    private @Nullable StreamReader streamReader = null;\n+    private @Nullable TiVoHandler tivoHandler = null;\n+    private TivoStatusData tivoStatusData = new TivoStatusData();\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+    private final String thingUid;\n+\n+    /**\n+     * Instantiates a new TivoConfigStatusProvider.\n+     *\n+     * @param tivoConfigData {@link TivoConfigData} configuration data for the specific thing.\n+     * @param tivoStatusData {@link TivoStatusData} status data for the specific thing.\n+     * @param tivoHandler {@link TivoHandler} parent handler object for the TivoConfigStatusProvider.\n+     *\n+     */\n+\n+    public TivoStatusProvider(TivoConfigData tivoConfigData, TiVoHandler tivoHandler) {\n+        this.tivoStatusData = new TivoStatusData(false, -1, -1, false, \"INITIALISING\", false, ConnectionStatus.UNKNOWN);\n+        this.tivoConfigData = tivoConfigData;\n+        this.tivoHandler = tivoHandler;\n+        this.thingUid = tivoHandler.getThing().getUID().getAsString();\n+    }\n+\n+    /**\n+     * {@link statusRefresh} initiates a connection to the TiVo. When a new connection is made and the TiVo is online,\n+     * the current channel is always returned. The connection is then closed (allows the socket to be used by other\n+     * devices).\n+     *\n+     * @return {@link TivoStatusData} object\n+     * @throws InterruptedException\n+     */\n+    public void statusRefresh() throws InterruptedException {\n+        if (tivoStatusData.getConnectionStatus() != ConnectionStatus.INIT) {\n+            logger.debug(\" statusRefresh '{}' - EXISTING status data - '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    tivoStatusData.toString());\n+        }\n+        connTivoConnect();\n+        doNappTime();\n+        connTivoDisconnect(false);\n+    }\n+\n+    /**\n+     * {@link cmdTivoSend} sends a command to the Tivo.\n+     *\n+     * @param tivoCommand the complete command string (KEYWORD + PARAMETERS e.g. SETCH 102) to send.\n+     * @return {@link TivoStatusData} status data object, contains the result of the command.\n+     * @throws InterruptedException\n+     */\n+    public @Nullable TivoStatusData cmdTivoSend(String tivoCommand) throws InterruptedException {\n+        boolean connected = connTivoConnect();\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (!connected || streamWriter == null) {\n+            return new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false, ConnectionStatus.OFFLINE);\n+        }\n+        logger.debug(\"TiVo '{}' - sending command: '{}'\", tivoConfigData.getCfgIdentifier(), tivoCommand);\n+        int repeatCount = 1;\n+        // Handle special keyboard \"repeat\" commands\n+        if (tivoCommand.contains(\"*\")) {\n+            repeatCount = Integer.parseInt(tivoCommand.substring(tivoCommand.indexOf(\"*\") + 1));\n+            tivoCommand = tivoCommand.substring(0, tivoCommand.indexOf(\"*\"));\n+            logger.debug(\"TiVo '{}' - repeating command: '{}' for '{}' times\", tivoConfigData.getCfgIdentifier(),\n+                    tivoCommand, repeatCount);\n+        }\n+        for (int i = 1; i <= repeatCount; i++) {\n+            // Send the command\n+            streamWriter.println(tivoCommand.toString() + \"\\r\");\n+            if (streamWriter.checkError()) {\n+                logger.debug(\"TiVo '{}' - called cmdTivoSend and encountered an IO error\",\n+                        tivoConfigData.getCfgIdentifier());\n+                tivoStatusData = new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false,\n+                        ConnectionStatus.OFFLINE);\n+                connTivoReconnect();\n+            }\n+        }\n+        return tivoStatusData;\n+    }\n+\n+    /**\n+     * {@link statusParse} processes the {@link TivoStatusData} status message returned from the TiVo.\n+     *\n+     * For channel status messages form 'CH_STATUS channel reason' or 'CH_STATUS channel sub-channel reason' calls\n+     * {@link getParsedChannel} and returns the channel number (if a match is found in a valid formatted message).\n+     *\n+     * @param rawStatus string representing the message text returned by the TiVo\n+     * @return TivoStatusData object conditionally populated based upon the raw status message\n+     */\n+    private TivoStatusData statusParse(String rawStatus) {\n+        logger.debug(\" statusParse '{}' - running on string '{}'\", tivoConfigData.getCfgIdentifier(), rawStatus);\n+\n+        if (rawStatus.contentEquals(\"COMMAND_TIMEOUT\")) {\n+            // Ignore COMMAND_TIMEOUT, they occur a few seconds after each successful command, just return existing\n+            // status again\n+            return this.tivoStatusData;\n+        } else {\n+            switch (rawStatus) {\n+                case \"\":\n+                    return new TivoStatusData(false, -1, -1, false, \"NO_STATUS_DATA_RETURNED\", false,\n+                            tivoStatusData.getConnectionStatus());\n+                case \"LIVETV_READY\":\n+                    return new TivoStatusData(true, -1, -1, false, \"LIVETV_READY\", true, ConnectionStatus.ONLINE);\n+                case \"CH_FAILED NO_LIVE\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED NO_LIVE\", true,\n+                            ConnectionStatus.STANDBY);\n+                case \"CH_FAILED RECORDING\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED RECORDING\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MISSING_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MISSING_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MALFORMED_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MALFORMED_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED INVALID_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED INVALID_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"INVALID_COMMAND\":\n+                    return new TivoStatusData(false, -1, -1, false, \"INVALID_COMMAND\", false, ConnectionStatus.ONLINE);\n+                case \"CONNECTION_RETRIES_EXHAUSTED\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CONNECTION_RETRIES_EXHAUSTED\", true,\n+                            ConnectionStatus.OFFLINE);\n+            }\n+        }\n+\n+        // Only other documented status is in the form 'CH_STATUS channel reason' or\n+        // 'CH_STATUS channel sub-channel reason'\n+        Matcher matcher = TIVO_STATUS_PATTERN.matcher(rawStatus);\n+        int chNum = -1; // -1 used globally to indicate channel number error\n+        int subChNum = -1;\n+        boolean isRecording = false;\n+\n+        if (matcher.find()) {\n+            logger.debug(\" statusParse '{}' - groups '{}' with group count of '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    matcher.group(), matcher.groupCount());\n+            if (matcher.groupCount() == 1 || matcher.groupCount() == 2) {\n+                chNum = Integer.parseInt(matcher.group(1).trim());\n+                logger.debug(\" statusParse '{}' - parsed channel '{}'\", tivoConfigData.getCfgIdentifier(), chNum);\n+            }\n+            if (matcher.groupCount() == 2) {\n+                subChNum = Integer.parseInt(matcher.group(2).trim());\n+                logger.debug(\" statusParse '{}' - parsed sub-channel '{}'\", tivoConfigData.getCfgIdentifier(),\n+                        subChNum);\n+            }\n+\n+            if (rawStatus.contains(\"RECORDING\")) {\n+                isRecording = true;\n+            }\n+\n+            rawStatus = rawStatus.replace(\" REMOTE\", \"\");\n+            rawStatus = rawStatus.replace(\" LOCAL\", \"\");\n+            return new TivoStatusData(true, chNum, subChNum, isRecording, rawStatus, true, ConnectionStatus.ONLINE);\n+        }\n+        logger.warn(\" TiVo '{}' - Unhandled/unexpected status message: '{}'\", tivoConfigData.getCfgIdentifier(),\n+                rawStatus);\n+        return new TivoStatusData(false, -1, -1, false, rawStatus, false, tivoStatusData.getConnectionStatus());\n+    }\n+\n+    /**\n+     * {@link connIsConnected} returns the connection state of the Socket, streamWriter and streamReader objects.\n+     *\n+     * @return true = connection exists and all objects look OK, false = connection does not exist or a problem has\n+     *         occurred\n+     *\n+     */\n+    private boolean connIsConnected() {\n+        Socket tivoSocket = this.tivoSocket;\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (tivoSocket == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (!tivoSocket.isConnected()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isConnected=false\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (tivoSocket.isClosed()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isClosed=true\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter.checkError()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand.checkError()=true\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamReader == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: streamReader=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * {@link connTivoConnect} manages the creation / retry process of the socket connection.\n+     *\n+     * @return true = connected, false = not connected\n+     * @throws InterruptedException\n+     */\n+    public boolean connTivoConnect() throws InterruptedException {\n+        for (int iL = 1; iL <= tivoConfigData.getNumRetry(); iL++) {\n+            logger.debug(\" connTivoConnect '{}' - starting connection process '{}' of '{}'.\",\n+                    tivoConfigData.getCfgIdentifier(), iL, tivoConfigData.getNumRetry());\n+\n+            // Sort out the socket connection\n+            if (connSocketConnect()) {\n+                logger.debug(\" connTivoConnect '{}' - Socket created / connection made.\",\n+                        tivoConfigData.getCfgIdentifier());\n+                StreamReader streamReader = this.streamReader;\n+                if (streamReader != null && streamReader.isAlive()) {\n+                    return true;\n+                }\n+            } else {\n+                logger.debug(\" connTivoConnect '{}' - Socket creation failed.\", tivoConfigData.getCfgIdentifier());\n+                TiVoHandler tivoHandler = this.tivoHandler;\n+                if (tivoHandler != null) {\n+                    tivoHandler.setStatusOffline();\n+                }\n+            }\n+            // Sleep and retry\n+            doNappTime();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@link connTivoDisconnect} conditionally closes the Socket connection. When 'keep connection open' or 'channel\n+     * scanning' is true, the disconnection process is ignored. Disconnect can be forced by setting forceDisconnect to\n+     * true.\n+     *\n+     * @param forceDisconnect true = forces a disconnection , false = disconnects in specific situations\n+     * @throws InterruptedException\n+     */\n+    public void connTivoDisconnect(boolean forceDisconnect) throws InterruptedException {\n+        if (forceDisconnect) {\n+            connSocketDisconnect();\n+        } else {\n+            if (!tivoConfigData.isKeepConnActive()) {\n+                doNappTime();\n+                connSocketDisconnect();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@link connTivoReconnect} disconnect and reconnect the socket connection to the TiVo.\n+     *\n+     * @return boolean true = connection succeeded, false = connection failed\n+     * @throws InterruptedException\n+     */\n+    public boolean connTivoReconnect() throws InterruptedException {\n+        connSocketDisconnect();\n+        doNappTime();\n+        return connTivoConnect();\n+    }\n+\n+    /**\n+     * {@link connSocketDisconnect} cleanly closes the socket connection and dependent objects\n+     *\n+     */\n+    private void connSocketDisconnect() {\n+        TiVoHandler tivoHandler = this.tivoHandler;\n+        StreamReader streamReader = this.streamReader;\n+        PrintStream streamWriter = this.streamWriter;\n+        Socket tivoSocket = this.tivoSocket;\n+\n+        logger.debug(\" connTivoSocket '{}' - requested to disconnect/cleanup connection objects\",\n+                tivoConfigData.getCfgIdentifier());\n+\n+        // if isCfgKeepConnOpen = false, don't set status to OFFLINE since the socket is closed after each command\n+        if (tivoHandler != null && tivoConfigData.isKeepConnActive()) {\n+            tivoHandler.setStatusOffline();\n+        }\n+\n+        try {\n+            if (streamReader != null) {\n+                streamReader.interrupt();\n+                try {\n+                    streamReader.join(TIMEOUT_SEC);\n+                } catch (InterruptedException e) {\n+                    logger.debug(\"Error joining streamReader: {}\", e.getMessage());\n+                }\n+                this.streamReader = null;\n+            }\n+            if (streamWriter != null) {\n+                streamWriter.close();\n+                this.streamWriter = null;\n+            }\n+            if (tivoSocket != null) {\n+                tivoSocket.close();\n+                this.tivoSocket = null;\n+            }", "originalCommit": "74830f91371b2211056f20c08d4af94a4572ba40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5MzMyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r548793329", "bodyText": "I moved this outside of the try block. PrintStream.close() does not throw any exceptions.", "author": "mlobstein", "createdAt": "2020-12-25T03:52:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyNDE5OA==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r547624198", "bodyText": "An interrupt isn't an error, it is another process requesting this thread to stop. You shouldn't silently consume an InterruptException either, at the very least you should have some way to notify the caller that an interrupt occured. Usually the best way to to rethrow the exception. But in this case you should wait to rethrow it until you have attempted to close the other other stuff first. With that in mind the best option would probably be to perform your streamReader.join at the end and then just add the InterruptException to the method signature.", "author": "cpmeister", "createdAt": "2020-12-23T03:48:52Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/internal/service/TivoStatusProvider.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.internal.service;\n+\n+import static org.openhab.binding.tivo.internal.TiVoBindingConstants.CONFIG_SOCKET_TIMEOUT_MS;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.internal.handler.TiVoHandler;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * TivoStatusProvider class to maintain a connection out to the Tivo, monitor and process status messages returned..\n+ *\n+ * @author Jayson Kubilis - Initial contribution\n+ * @author Andrew Black - Updates / compilation corrections\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TivoStatusProvider {\n+    private static final Pattern TIVO_STATUS_PATTERN = Pattern.compile(\"^CH_STATUS (\\\\d{4}) (?:(\\\\d{4}))?\");\n+    private static final int TIMEOUT_SEC = 3000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(TivoStatusProvider.class);\n+    private @Nullable Socket tivoSocket = null;\n+    private @Nullable PrintStream streamWriter = null;\n+    private @Nullable StreamReader streamReader = null;\n+    private @Nullable TiVoHandler tivoHandler = null;\n+    private TivoStatusData tivoStatusData = new TivoStatusData();\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+    private final String thingUid;\n+\n+    /**\n+     * Instantiates a new TivoConfigStatusProvider.\n+     *\n+     * @param tivoConfigData {@link TivoConfigData} configuration data for the specific thing.\n+     * @param tivoStatusData {@link TivoStatusData} status data for the specific thing.\n+     * @param tivoHandler {@link TivoHandler} parent handler object for the TivoConfigStatusProvider.\n+     *\n+     */\n+\n+    public TivoStatusProvider(TivoConfigData tivoConfigData, TiVoHandler tivoHandler) {\n+        this.tivoStatusData = new TivoStatusData(false, -1, -1, false, \"INITIALISING\", false, ConnectionStatus.UNKNOWN);\n+        this.tivoConfigData = tivoConfigData;\n+        this.tivoHandler = tivoHandler;\n+        this.thingUid = tivoHandler.getThing().getUID().getAsString();\n+    }\n+\n+    /**\n+     * {@link statusRefresh} initiates a connection to the TiVo. When a new connection is made and the TiVo is online,\n+     * the current channel is always returned. The connection is then closed (allows the socket to be used by other\n+     * devices).\n+     *\n+     * @return {@link TivoStatusData} object\n+     * @throws InterruptedException\n+     */\n+    public void statusRefresh() throws InterruptedException {\n+        if (tivoStatusData.getConnectionStatus() != ConnectionStatus.INIT) {\n+            logger.debug(\" statusRefresh '{}' - EXISTING status data - '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    tivoStatusData.toString());\n+        }\n+        connTivoConnect();\n+        doNappTime();\n+        connTivoDisconnect(false);\n+    }\n+\n+    /**\n+     * {@link cmdTivoSend} sends a command to the Tivo.\n+     *\n+     * @param tivoCommand the complete command string (KEYWORD + PARAMETERS e.g. SETCH 102) to send.\n+     * @return {@link TivoStatusData} status data object, contains the result of the command.\n+     * @throws InterruptedException\n+     */\n+    public @Nullable TivoStatusData cmdTivoSend(String tivoCommand) throws InterruptedException {\n+        boolean connected = connTivoConnect();\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (!connected || streamWriter == null) {\n+            return new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false, ConnectionStatus.OFFLINE);\n+        }\n+        logger.debug(\"TiVo '{}' - sending command: '{}'\", tivoConfigData.getCfgIdentifier(), tivoCommand);\n+        int repeatCount = 1;\n+        // Handle special keyboard \"repeat\" commands\n+        if (tivoCommand.contains(\"*\")) {\n+            repeatCount = Integer.parseInt(tivoCommand.substring(tivoCommand.indexOf(\"*\") + 1));\n+            tivoCommand = tivoCommand.substring(0, tivoCommand.indexOf(\"*\"));\n+            logger.debug(\"TiVo '{}' - repeating command: '{}' for '{}' times\", tivoConfigData.getCfgIdentifier(),\n+                    tivoCommand, repeatCount);\n+        }\n+        for (int i = 1; i <= repeatCount; i++) {\n+            // Send the command\n+            streamWriter.println(tivoCommand.toString() + \"\\r\");\n+            if (streamWriter.checkError()) {\n+                logger.debug(\"TiVo '{}' - called cmdTivoSend and encountered an IO error\",\n+                        tivoConfigData.getCfgIdentifier());\n+                tivoStatusData = new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false,\n+                        ConnectionStatus.OFFLINE);\n+                connTivoReconnect();\n+            }\n+        }\n+        return tivoStatusData;\n+    }\n+\n+    /**\n+     * {@link statusParse} processes the {@link TivoStatusData} status message returned from the TiVo.\n+     *\n+     * For channel status messages form 'CH_STATUS channel reason' or 'CH_STATUS channel sub-channel reason' calls\n+     * {@link getParsedChannel} and returns the channel number (if a match is found in a valid formatted message).\n+     *\n+     * @param rawStatus string representing the message text returned by the TiVo\n+     * @return TivoStatusData object conditionally populated based upon the raw status message\n+     */\n+    private TivoStatusData statusParse(String rawStatus) {\n+        logger.debug(\" statusParse '{}' - running on string '{}'\", tivoConfigData.getCfgIdentifier(), rawStatus);\n+\n+        if (rawStatus.contentEquals(\"COMMAND_TIMEOUT\")) {\n+            // Ignore COMMAND_TIMEOUT, they occur a few seconds after each successful command, just return existing\n+            // status again\n+            return this.tivoStatusData;\n+        } else {\n+            switch (rawStatus) {\n+                case \"\":\n+                    return new TivoStatusData(false, -1, -1, false, \"NO_STATUS_DATA_RETURNED\", false,\n+                            tivoStatusData.getConnectionStatus());\n+                case \"LIVETV_READY\":\n+                    return new TivoStatusData(true, -1, -1, false, \"LIVETV_READY\", true, ConnectionStatus.ONLINE);\n+                case \"CH_FAILED NO_LIVE\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED NO_LIVE\", true,\n+                            ConnectionStatus.STANDBY);\n+                case \"CH_FAILED RECORDING\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED RECORDING\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MISSING_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MISSING_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MALFORMED_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MALFORMED_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED INVALID_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED INVALID_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"INVALID_COMMAND\":\n+                    return new TivoStatusData(false, -1, -1, false, \"INVALID_COMMAND\", false, ConnectionStatus.ONLINE);\n+                case \"CONNECTION_RETRIES_EXHAUSTED\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CONNECTION_RETRIES_EXHAUSTED\", true,\n+                            ConnectionStatus.OFFLINE);\n+            }\n+        }\n+\n+        // Only other documented status is in the form 'CH_STATUS channel reason' or\n+        // 'CH_STATUS channel sub-channel reason'\n+        Matcher matcher = TIVO_STATUS_PATTERN.matcher(rawStatus);\n+        int chNum = -1; // -1 used globally to indicate channel number error\n+        int subChNum = -1;\n+        boolean isRecording = false;\n+\n+        if (matcher.find()) {\n+            logger.debug(\" statusParse '{}' - groups '{}' with group count of '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    matcher.group(), matcher.groupCount());\n+            if (matcher.groupCount() == 1 || matcher.groupCount() == 2) {\n+                chNum = Integer.parseInt(matcher.group(1).trim());\n+                logger.debug(\" statusParse '{}' - parsed channel '{}'\", tivoConfigData.getCfgIdentifier(), chNum);\n+            }\n+            if (matcher.groupCount() == 2) {\n+                subChNum = Integer.parseInt(matcher.group(2).trim());\n+                logger.debug(\" statusParse '{}' - parsed sub-channel '{}'\", tivoConfigData.getCfgIdentifier(),\n+                        subChNum);\n+            }\n+\n+            if (rawStatus.contains(\"RECORDING\")) {\n+                isRecording = true;\n+            }\n+\n+            rawStatus = rawStatus.replace(\" REMOTE\", \"\");\n+            rawStatus = rawStatus.replace(\" LOCAL\", \"\");\n+            return new TivoStatusData(true, chNum, subChNum, isRecording, rawStatus, true, ConnectionStatus.ONLINE);\n+        }\n+        logger.warn(\" TiVo '{}' - Unhandled/unexpected status message: '{}'\", tivoConfigData.getCfgIdentifier(),\n+                rawStatus);\n+        return new TivoStatusData(false, -1, -1, false, rawStatus, false, tivoStatusData.getConnectionStatus());\n+    }\n+\n+    /**\n+     * {@link connIsConnected} returns the connection state of the Socket, streamWriter and streamReader objects.\n+     *\n+     * @return true = connection exists and all objects look OK, false = connection does not exist or a problem has\n+     *         occurred\n+     *\n+     */\n+    private boolean connIsConnected() {\n+        Socket tivoSocket = this.tivoSocket;\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (tivoSocket == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (!tivoSocket.isConnected()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isConnected=false\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (tivoSocket.isClosed()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isClosed=true\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter.checkError()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand.checkError()=true\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamReader == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: streamReader=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * {@link connTivoConnect} manages the creation / retry process of the socket connection.\n+     *\n+     * @return true = connected, false = not connected\n+     * @throws InterruptedException\n+     */\n+    public boolean connTivoConnect() throws InterruptedException {\n+        for (int iL = 1; iL <= tivoConfigData.getNumRetry(); iL++) {\n+            logger.debug(\" connTivoConnect '{}' - starting connection process '{}' of '{}'.\",\n+                    tivoConfigData.getCfgIdentifier(), iL, tivoConfigData.getNumRetry());\n+\n+            // Sort out the socket connection\n+            if (connSocketConnect()) {\n+                logger.debug(\" connTivoConnect '{}' - Socket created / connection made.\",\n+                        tivoConfigData.getCfgIdentifier());\n+                StreamReader streamReader = this.streamReader;\n+                if (streamReader != null && streamReader.isAlive()) {\n+                    return true;\n+                }\n+            } else {\n+                logger.debug(\" connTivoConnect '{}' - Socket creation failed.\", tivoConfigData.getCfgIdentifier());\n+                TiVoHandler tivoHandler = this.tivoHandler;\n+                if (tivoHandler != null) {\n+                    tivoHandler.setStatusOffline();\n+                }\n+            }\n+            // Sleep and retry\n+            doNappTime();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@link connTivoDisconnect} conditionally closes the Socket connection. When 'keep connection open' or 'channel\n+     * scanning' is true, the disconnection process is ignored. Disconnect can be forced by setting forceDisconnect to\n+     * true.\n+     *\n+     * @param forceDisconnect true = forces a disconnection , false = disconnects in specific situations\n+     * @throws InterruptedException\n+     */\n+    public void connTivoDisconnect(boolean forceDisconnect) throws InterruptedException {\n+        if (forceDisconnect) {\n+            connSocketDisconnect();\n+        } else {\n+            if (!tivoConfigData.isKeepConnActive()) {\n+                doNappTime();\n+                connSocketDisconnect();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@link connTivoReconnect} disconnect and reconnect the socket connection to the TiVo.\n+     *\n+     * @return boolean true = connection succeeded, false = connection failed\n+     * @throws InterruptedException\n+     */\n+    public boolean connTivoReconnect() throws InterruptedException {\n+        connSocketDisconnect();\n+        doNappTime();\n+        return connTivoConnect();\n+    }\n+\n+    /**\n+     * {@link connSocketDisconnect} cleanly closes the socket connection and dependent objects\n+     *\n+     */\n+    private void connSocketDisconnect() {\n+        TiVoHandler tivoHandler = this.tivoHandler;\n+        StreamReader streamReader = this.streamReader;\n+        PrintStream streamWriter = this.streamWriter;\n+        Socket tivoSocket = this.tivoSocket;\n+\n+        logger.debug(\" connTivoSocket '{}' - requested to disconnect/cleanup connection objects\",\n+                tivoConfigData.getCfgIdentifier());\n+\n+        // if isCfgKeepConnOpen = false, don't set status to OFFLINE since the socket is closed after each command\n+        if (tivoHandler != null && tivoConfigData.isKeepConnActive()) {\n+            tivoHandler.setStatusOffline();\n+        }\n+\n+        try {\n+            if (streamReader != null) {\n+                streamReader.interrupt();\n+                try {\n+                    streamReader.join(TIMEOUT_SEC);\n+                } catch (InterruptedException e) {\n+                    logger.debug(\"Error joining streamReader: {}\", e.getMessage());\n+                }", "originalCommit": "74830f91371b2211056f20c08d4af94a4572ba40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5MzM1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r548793356", "bodyText": "Done", "author": "mlobstein", "createdAt": "2020-12-25T03:53:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyNDE5OA=="}], "type": "inlineReview"}, {"oid": "b82530ec5ac5be44d396a7e5605720d669f20f89", "url": "https://github.com/openhab/openhab-addons/commit/b82530ec5ac5be44d396a7e5605720d669f20f89", "message": "review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-12-25T03:46:53Z", "type": "commit"}, {"oid": "1d799c57e1e8b70ebf4df5fffefc1f8407e150f4", "url": "https://github.com/openhab/openhab-addons/commit/1d799c57e1e8b70ebf4df5fffefc1f8407e150f4", "message": "Merge branch 'main' into Tivo_OH3", "committedDate": "2020-12-26T03:19:39Z", "type": "commit"}, {"oid": "a305e6080d24dbde81ad2279caa70f7103031f0e", "url": "https://github.com/openhab/openhab-addons/commit/a305e6080d24dbde81ad2279caa70f7103031f0e", "message": "update version and year\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-12-27T16:19:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk0MjA5MA==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r550942090", "bodyText": "You should take advantage of switch statement fall-throughs when possible.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                case \"CH_FAILED RECORDING\":\n          \n          \n            \n                                    return tmpStatus;\n          \n          \n            \n                                case \"CH_FAILED MISSING_CHANNEL\":\n          \n          \n            \n                                    return tmpStatus;\n          \n          \n            \n                                case \"CH_FAILED MALFORMED_CHANNEL\":\n          \n          \n            \n                                    return tmpStatus;\n          \n          \n            \n                                case \"CH_FAILED INVALID_CHANNEL\":\n          \n          \n            \n                                    return tmpStatus;\n          \n          \n            \n                                case \"CH_FAILED RECORDING\":\n          \n          \n            \n                                case \"CH_FAILED MISSING_CHANNEL\":\n          \n          \n            \n                                case \"CH_FAILED MALFORMED_CHANNEL\":\n          \n          \n            \n                                case \"CH_FAILED INVALID_CHANNEL\":\n          \n          \n            \n                                    return tmpStatus;", "author": "cpmeister", "createdAt": "2021-01-03T01:35:31Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/internal/handler/TiVoHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.internal.handler;\n+\n+import static org.openhab.binding.tivo.internal.TiVoBindingConstants.*;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.internal.service.TivoConfigData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.openhab.binding.tivo.internal.service.TivoStatusProvider;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TiVoHandler} is the BaseThingHandler responsible for handling commands that are\n+ * sent to one of the Tivo's channels.\n+ *\n+ * @author Jayson Kubilis (DigitalBytes) - Initial contribution\n+ * @author Andrew Black (AndyXMB) - Updates / compilation corrections. Addition of channel scanning functionality.\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TiVoHandler extends BaseThingHandler {\n+    private static final Pattern NUMERIC_PATTERN = Pattern.compile(\"(\\\\d+)\\\\.?(\\\\d+)?\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(TiVoHandler.class);\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+    private ConnectionStatus lastConnectionStatus = ConnectionStatus.UNKNOWN;\n+    private Optional<TivoStatusProvider> tivoConnection = Optional.empty();\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    /**\n+     * Instantiates a new TiVo handler.\n+     *\n+     * @param thing the thing\n+     */\n+    public TiVoHandler(Thing thing) {\n+        super(thing);\n+        logger.debug(\"TiVoHandler '{}' - creating\", getThing().getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Handles the commands from the various TiVo channel objects\n+        logger.debug(\"handleCommand '{}', parameter: {}\", channelUID, command);\n+\n+        if (!isInitialized() || !tivoConnection.isPresent()) {\n+            logger.debug(\"handleCommand '{}' device is not initialized yet, command '{}' will be ignored.\",\n+                    getThing().getUID(), channelUID + \" \" + command);\n+            return;\n+        }\n+\n+        TivoStatusData currentStatus = tivoConnection.get().getServiceStatus();\n+        String commandKeyword = \"\";\n+\n+        String commandParameter = command.toString().toUpperCase();\n+        if (command instanceof RefreshType) {\n+            // Future enhancement, if we can come up with a sensible set of actions when a REFRESH is issued\n+            logger.debug(\"TiVo '{}' skipping REFRESH command for channel: '{}'.\", getThing().getUID(),\n+                    channelUID.getId());\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TIVO_CHANNEL_FORCE:\n+                commandKeyword = \"FORCECH\";\n+                break;\n+            case CHANNEL_TIVO_CHANNEL_SET:\n+                commandKeyword = \"SETCH\";\n+                break;\n+            case CHANNEL_TIVO_TELEPORT:\n+                commandKeyword = \"TELEPORT\";\n+                break;\n+            case CHANNEL_TIVO_IRCMD:\n+                commandKeyword = \"IRCODE\";\n+                break;\n+            case CHANNEL_TIVO_KBDCMD:\n+                commandKeyword = \"KEYBOARD\";\n+                break;\n+        }\n+        try {\n+            sendCommand(commandKeyword, commandParameter, currentStatus);\n+        } catch (InterruptedException e) {\n+            // TiVo handler disposed or openHAB exiting, do nothing\n+        }\n+    }\n+\n+    public void setStatusOffline() {\n+        this.updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                \"Power on device or check network configuration/connection.\");\n+    }\n+\n+    private void sendCommand(String commandKeyword, String commandParameter, TivoStatusData currentStatus)\n+            throws InterruptedException {\n+        if (!tivoConnection.isPresent()) {\n+            return;\n+        }\n+\n+        TivoStatusData deviceStatus = tivoConnection.get().getServiceStatus();\n+        TivoStatusData commandResult = null;\n+        logger.debug(\"handleCommand '{}' - {} found!\", getThing().getUID(), commandKeyword);\n+        // Re-write command keyword if we are in STANDBY, as only IRCODE TIVO will wake the unit from\n+        // standby mode\n+        if (deviceStatus.getConnectionStatus() == ConnectionStatus.STANDBY && commandKeyword.contentEquals(\"TELEPORT\")\n+                && commandParameter.contentEquals(\"TIVO\")) {\n+            String command = \"IRCODE \" + commandParameter;\n+            logger.debug(\"TiVo '{}' TELEPORT re-mapped to IRCODE as we are in standby: '{}'\", getThing().getUID(),\n+                    command);\n+        }\n+        // Execute command\n+        if (commandKeyword.contentEquals(\"FORCECH\") || commandKeyword.contentEquals(\"SETCH\")) {\n+            commandResult = chChannelChange(commandKeyword, commandParameter);\n+        } else {\n+            commandResult = tivoConnection.get().cmdTivoSend(commandKeyword + \" \" + commandParameter);\n+        }\n+\n+        // Post processing\n+        if (commandResult != null && commandParameter.contentEquals(\"STANDBY\")) {\n+            // Force thing state into STANDBY as this command does not return a status when executed\n+            commandResult.setConnectionStatus(ConnectionStatus.STANDBY);\n+        }\n+\n+        // Push status updates\n+        if (commandResult != null && commandResult.isCmdOk()) {\n+            updateTivoStatus(currentStatus, commandResult);\n+        }\n+\n+        if (!tivoConfigData.isKeepConnActive()) {\n+            // disconnect once command is complete\n+            tivoConnection.get().connTivoDisconnect();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing a TiVo '{}' with config options\", getThing().getUID());\n+\n+        tivoConfigData = getConfigAs(TivoConfigData.class);\n+\n+        tivoConfigData.setCfgIdentifier(getThing().getUID().getAsString());\n+        tivoConnection = Optional.of(new TivoStatusProvider(tivoConfigData, this));\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        lastConnectionStatus = ConnectionStatus.UNKNOWN;\n+        logger.debug(\"Initializing a TiVo handler for thing '{}' - finished!\", getThing().getUID());\n+\n+        startPollStatus();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing of a TiVo handler for thing '{}'\", getThing().getUID());\n+\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null) {\n+            refreshJob.cancel(false);\n+            this.refreshJob = null;\n+        }\n+\n+        if (tivoConnection.isPresent()) {\n+            try {\n+                tivoConnection.get().connTivoDisconnect();\n+            } catch (InterruptedException e) {\n+                // TiVo handler disposed or openHAB exiting, do nothing\n+            }\n+            tivoConnection = Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * {@link startPollStatus} scheduled job to poll for changes in state.\n+     */\n+    private void startPollStatus() {\n+        Runnable runnable = () -> {\n+            logger.debug(\"startPollStatus '{}' @ rate of '{}' seconds\", getThing().getUID(),\n+                    tivoConfigData.getPollInterval());\n+            tivoConnection.ifPresent(connection -> {\n+                try {\n+                    connection.statusRefresh();\n+                } catch (InterruptedException e) {\n+                    // TiVo handler disposed or openHAB exiting, do nothing\n+                }\n+            });\n+        };\n+\n+        if (tivoConfigData.isKeepConnActive()) {\n+            // Run once\n+            refreshJob = scheduler.schedule(runnable, INIT_POLLING_DELAY_S, TimeUnit.SECONDS);\n+            logger.debug(\"Status collection '{}' will start in '{}' seconds.\", getThing().getUID(),\n+                    INIT_POLLING_DELAY_S);\n+        } else if (tivoConfigData.doPollChanges()) {\n+            // Run at intervals\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, INIT_POLLING_DELAY_S,\n+                    tivoConfigData.getPollInterval(), TimeUnit.SECONDS);\n+            logger.debug(\"Status polling '{}' will start in '{}' seconds.\", getThing().getUID(), INIT_POLLING_DELAY_S);\n+        } else {\n+            // Just update the status now\n+            tivoConnection.ifPresent(connection -> {\n+                try {\n+                    connection.statusRefresh();\n+                } catch (InterruptedException e) {\n+                    // TiVo handler disposed or openHAB exiting, do nothing\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * {@link chChannelChange} performs channel changing operations.\n+     *\n+     * @param commandKeyword the TiVo command object.\n+     * @param command the command parameter.\n+     * @return TivoStatusData status of the command.\n+     * @throws InterruptedException\n+     */\n+    private TivoStatusData chChannelChange(String commandKeyword, String command) throws InterruptedException {\n+        int channel = -1;\n+        int subChannel = -1;\n+\n+        TivoStatusData tmpStatus = tivoConnection.get().getServiceStatus();\n+        try {\n+            // Parse the channel number and if there is a decimal, the sub-channel number (OTA channels)\n+            Matcher matcher = NUMERIC_PATTERN.matcher(command);\n+            if (matcher.find()) {\n+                if (matcher.groupCount() >= 1) {\n+                    channel = Integer.parseInt(matcher.group(1).trim());\n+                }\n+                if (matcher.groupCount() >= 2 && matcher.group(2) != null) {\n+                    subChannel = Integer.parseInt(matcher.group(2).trim());\n+                }\n+            } else {\n+                // The command string was not a number, throw exception to catch & log below\n+                throw new NumberFormatException();\n+            }\n+\n+            String tmpCommand = commandKeyword + \" \" + channel + ((subChannel != -1) ? (\" \" + subChannel) : \"\");\n+            logger.debug(\"chChannelChange '{}' sending command to tivo: '{}'\", getThing().getUID(), tmpCommand);\n+\n+            // Attempt to execute the command on the tivo\n+            tivoConnection.get().cmdTivoSend(tmpCommand);\n+            TimeUnit.MILLISECONDS.sleep(tivoConfigData.getCmdWaitInterval() * 2);\n+\n+            tmpStatus = tivoConnection.get().getServiceStatus();\n+\n+            // Check to see if the command was successful\n+            if (tmpStatus.getConnectionStatus() != ConnectionStatus.INIT && tmpStatus.isCmdOk()) {\n+                if (tmpStatus.getMsg().contains(\"CH_STATUS\")) {\n+                    return tmpStatus;\n+                }\n+            } else if (tmpStatus.getConnectionStatus() != ConnectionStatus.INIT) {\n+                logger.warn(\"TiVo'{}' set channel command failed '{}' with msg '{}'\", getThing().getUID(), tmpCommand,\n+                        tmpStatus.getMsg());\n+                switch (tmpStatus.getMsg()) {\n+                    case \"CH_FAILED NO_LIVE\":\n+                        tmpStatus.setChannelNum(channel);\n+                        tmpStatus.setSubChannelNum(subChannel);\n+                        return tmpStatus;\n+                    case \"CH_FAILED RECORDING\":\n+                        return tmpStatus;\n+                    case \"CH_FAILED MISSING_CHANNEL\":\n+                        return tmpStatus;\n+                    case \"CH_FAILED MALFORMED_CHANNEL\":\n+                        return tmpStatus;\n+                    case \"CH_FAILED INVALID_CHANNEL\":\n+                        return tmpStatus;", "originalCommit": "a305e6080d24dbde81ad2279caa70f7103031f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk0MjI5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r550942297", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            case \"CH_FAILED RECORDING\":\n          \n          \n            \n                                return new TivoStatusData(false, -1, -1, false, \"CH_FAILED RECORDING\", true,\n          \n          \n            \n                                        ConnectionStatus.ONLINE);\n          \n          \n            \n                            case \"CH_FAILED MISSING_CHANNEL\":\n          \n          \n            \n                                return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MISSING_CHANNEL\", true,\n          \n          \n            \n                                        ConnectionStatus.ONLINE);\n          \n          \n            \n                            case \"CH_FAILED MALFORMED_CHANNEL\":\n          \n          \n            \n                                return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MALFORMED_CHANNEL\", true,\n          \n          \n            \n                                        ConnectionStatus.ONLINE);\n          \n          \n            \n                            case \"CH_FAILED INVALID_CHANNEL\":\n          \n          \n            \n                                return new TivoStatusData(false, -1, -1, false, \"CH_FAILED INVALID_CHANNEL\", true,\n          \n          \n            \n                                        ConnectionStatus.ONLINE);\n          \n          \n            \n                            case \"CH_FAILED RECORDING\":\n          \n          \n            \n                            case \"CH_FAILED MISSING_CHANNEL\":\n          \n          \n            \n                            case \"CH_FAILED MALFORMED_CHANNEL\":\n          \n          \n            \n                            case \"CH_FAILED INVALID_CHANNEL\":\n          \n          \n            \n                                return new TivoStatusData(false, -1, -1, false, rawStatus, true, ConnectionStatus.ONLINE);", "author": "cpmeister", "createdAt": "2021-01-03T01:38:03Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/internal/service/TivoStatusProvider.java", "diffHunk": "@@ -0,0 +1,459 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.internal.service;\n+\n+import static org.openhab.binding.tivo.internal.TiVoBindingConstants.CONFIG_SOCKET_TIMEOUT_MS;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.internal.handler.TiVoHandler;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * TivoStatusProvider class to maintain a connection out to the Tivo, monitor and process status messages returned..\n+ *\n+ * @author Jayson Kubilis - Initial contribution\n+ * @author Andrew Black - Updates / compilation corrections\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TivoStatusProvider {\n+    private static final Pattern TIVO_STATUS_PATTERN = Pattern.compile(\"^CH_STATUS (\\\\d{4}) (?:(\\\\d{4}))?\");\n+    private static final int TIMEOUT_SEC = 3000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(TivoStatusProvider.class);\n+    private @Nullable Socket tivoSocket = null;\n+    private @Nullable PrintStream streamWriter = null;\n+    private @Nullable StreamReader streamReader = null;\n+    private @Nullable TiVoHandler tivoHandler = null;\n+    private TivoStatusData tivoStatusData = new TivoStatusData();\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+    private final String thingUid;\n+\n+    /**\n+     * Instantiates a new TivoConfigStatusProvider.\n+     *\n+     * @param tivoConfigData {@link TivoConfigData} configuration data for the specific thing.\n+     * @param tivoStatusData {@link TivoStatusData} status data for the specific thing.\n+     * @param tivoHandler {@link TivoHandler} parent handler object for the TivoConfigStatusProvider.\n+     *\n+     */\n+\n+    public TivoStatusProvider(TivoConfigData tivoConfigData, TiVoHandler tivoHandler) {\n+        this.tivoStatusData = new TivoStatusData(false, -1, -1, false, \"INITIALISING\", false, ConnectionStatus.UNKNOWN);\n+        this.tivoConfigData = tivoConfigData;\n+        this.tivoHandler = tivoHandler;\n+        this.thingUid = tivoHandler.getThing().getUID().getAsString();\n+    }\n+\n+    /**\n+     * {@link statusRefresh} initiates a connection to the TiVo. When a new connection is made and the TiVo is online,\n+     * the current channel is always returned. The connection is then closed (allows the socket to be used by other\n+     * devices).\n+     *\n+     * @return {@link TivoStatusData} object\n+     * @throws InterruptedException\n+     */\n+    public void statusRefresh() throws InterruptedException {\n+        if (tivoStatusData.getConnectionStatus() != ConnectionStatus.INIT) {\n+            logger.debug(\" statusRefresh '{}' - EXISTING status data - '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    tivoStatusData.toString());\n+        }\n+        connTivoConnect();\n+        doNappTime();\n+        if (!tivoConfigData.isKeepConnActive()) {\n+            connTivoDisconnect();\n+        }\n+    }\n+\n+    /**\n+     * {@link cmdTivoSend} sends a command to the Tivo.\n+     *\n+     * @param tivoCommand the complete command string (KEYWORD + PARAMETERS e.g. SETCH 102) to send.\n+     * @return {@link TivoStatusData} status data object, contains the result of the command.\n+     * @throws InterruptedException\n+     */\n+    public @Nullable TivoStatusData cmdTivoSend(String tivoCommand) throws InterruptedException {\n+        boolean connected = connTivoConnect();\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (!connected || streamWriter == null) {\n+            return new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false, ConnectionStatus.OFFLINE);\n+        }\n+        logger.debug(\"TiVo '{}' - sending command: '{}'\", tivoConfigData.getCfgIdentifier(), tivoCommand);\n+        int repeatCount = 1;\n+        // Handle special keyboard \"repeat\" commands\n+        if (tivoCommand.contains(\"*\")) {\n+            repeatCount = Integer.parseInt(tivoCommand.substring(tivoCommand.indexOf(\"*\") + 1));\n+            tivoCommand = tivoCommand.substring(0, tivoCommand.indexOf(\"*\"));\n+            logger.debug(\"TiVo '{}' - repeating command: '{}' for '{}' times\", tivoConfigData.getCfgIdentifier(),\n+                    tivoCommand, repeatCount);\n+        }\n+        for (int i = 1; i <= repeatCount; i++) {\n+            // Send the command\n+            streamWriter.println(tivoCommand.toString() + \"\\r\");\n+            if (streamWriter.checkError()) {\n+                logger.debug(\"TiVo '{}' - called cmdTivoSend and encountered an IO error\",\n+                        tivoConfigData.getCfgIdentifier());\n+                tivoStatusData = new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false,\n+                        ConnectionStatus.OFFLINE);\n+                connTivoReconnect();\n+            }\n+        }\n+        return tivoStatusData;\n+    }\n+\n+    /**\n+     * {@link statusParse} processes the {@link TivoStatusData} status message returned from the TiVo.\n+     *\n+     * For channel status messages form 'CH_STATUS channel reason' or 'CH_STATUS channel sub-channel reason' calls\n+     * {@link getParsedChannel} and returns the channel number (if a match is found in a valid formatted message).\n+     *\n+     * @param rawStatus string representing the message text returned by the TiVo\n+     * @return TivoStatusData object conditionally populated based upon the raw status message\n+     */\n+    private TivoStatusData statusParse(String rawStatus) {\n+        logger.debug(\" statusParse '{}' - running on string '{}'\", tivoConfigData.getCfgIdentifier(), rawStatus);\n+\n+        if (rawStatus.contentEquals(\"COMMAND_TIMEOUT\")) {\n+            // Ignore COMMAND_TIMEOUT, they occur a few seconds after each successful command, just return existing\n+            // status again\n+            return this.tivoStatusData;\n+        } else {\n+            switch (rawStatus) {\n+                case \"\":\n+                    return new TivoStatusData(false, -1, -1, false, \"NO_STATUS_DATA_RETURNED\", false,\n+                            tivoStatusData.getConnectionStatus());\n+                case \"LIVETV_READY\":\n+                    return new TivoStatusData(true, -1, -1, false, \"LIVETV_READY\", true, ConnectionStatus.ONLINE);\n+                case \"CH_FAILED NO_LIVE\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED NO_LIVE\", true,\n+                            ConnectionStatus.STANDBY);\n+                case \"CH_FAILED RECORDING\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED RECORDING\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MISSING_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MISSING_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MALFORMED_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MALFORMED_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED INVALID_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED INVALID_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);", "originalCommit": "a305e6080d24dbde81ad2279caa70f7103031f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk0Mjc0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r550942749", "bodyText": "Is this thread supposed to be responsible for closing this reader?", "author": "cpmeister", "createdAt": "2021-01-03T01:44:47Z", "path": "bundles/org.openhab.binding.tivo/src/main/java/org/openhab/binding/tivo/internal/service/TivoStatusProvider.java", "diffHunk": "@@ -0,0 +1,459 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tivo.internal.service;\n+\n+import static org.openhab.binding.tivo.internal.TiVoBindingConstants.CONFIG_SOCKET_TIMEOUT_MS;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tivo.internal.handler.TiVoHandler;\n+import org.openhab.binding.tivo.internal.service.TivoStatusData.ConnectionStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * TivoStatusProvider class to maintain a connection out to the Tivo, monitor and process status messages returned..\n+ *\n+ * @author Jayson Kubilis - Initial contribution\n+ * @author Andrew Black - Updates / compilation corrections\n+ * @author Michael Lobstein - Updated for OH3\n+ */\n+\n+@NonNullByDefault\n+public class TivoStatusProvider {\n+    private static final Pattern TIVO_STATUS_PATTERN = Pattern.compile(\"^CH_STATUS (\\\\d{4}) (?:(\\\\d{4}))?\");\n+    private static final int TIMEOUT_SEC = 3000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(TivoStatusProvider.class);\n+    private @Nullable Socket tivoSocket = null;\n+    private @Nullable PrintStream streamWriter = null;\n+    private @Nullable StreamReader streamReader = null;\n+    private @Nullable TiVoHandler tivoHandler = null;\n+    private TivoStatusData tivoStatusData = new TivoStatusData();\n+    private TivoConfigData tivoConfigData = new TivoConfigData();\n+    private final String thingUid;\n+\n+    /**\n+     * Instantiates a new TivoConfigStatusProvider.\n+     *\n+     * @param tivoConfigData {@link TivoConfigData} configuration data for the specific thing.\n+     * @param tivoStatusData {@link TivoStatusData} status data for the specific thing.\n+     * @param tivoHandler {@link TivoHandler} parent handler object for the TivoConfigStatusProvider.\n+     *\n+     */\n+\n+    public TivoStatusProvider(TivoConfigData tivoConfigData, TiVoHandler tivoHandler) {\n+        this.tivoStatusData = new TivoStatusData(false, -1, -1, false, \"INITIALISING\", false, ConnectionStatus.UNKNOWN);\n+        this.tivoConfigData = tivoConfigData;\n+        this.tivoHandler = tivoHandler;\n+        this.thingUid = tivoHandler.getThing().getUID().getAsString();\n+    }\n+\n+    /**\n+     * {@link statusRefresh} initiates a connection to the TiVo. When a new connection is made and the TiVo is online,\n+     * the current channel is always returned. The connection is then closed (allows the socket to be used by other\n+     * devices).\n+     *\n+     * @return {@link TivoStatusData} object\n+     * @throws InterruptedException\n+     */\n+    public void statusRefresh() throws InterruptedException {\n+        if (tivoStatusData.getConnectionStatus() != ConnectionStatus.INIT) {\n+            logger.debug(\" statusRefresh '{}' - EXISTING status data - '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    tivoStatusData.toString());\n+        }\n+        connTivoConnect();\n+        doNappTime();\n+        if (!tivoConfigData.isKeepConnActive()) {\n+            connTivoDisconnect();\n+        }\n+    }\n+\n+    /**\n+     * {@link cmdTivoSend} sends a command to the Tivo.\n+     *\n+     * @param tivoCommand the complete command string (KEYWORD + PARAMETERS e.g. SETCH 102) to send.\n+     * @return {@link TivoStatusData} status data object, contains the result of the command.\n+     * @throws InterruptedException\n+     */\n+    public @Nullable TivoStatusData cmdTivoSend(String tivoCommand) throws InterruptedException {\n+        boolean connected = connTivoConnect();\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (!connected || streamWriter == null) {\n+            return new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false, ConnectionStatus.OFFLINE);\n+        }\n+        logger.debug(\"TiVo '{}' - sending command: '{}'\", tivoConfigData.getCfgIdentifier(), tivoCommand);\n+        int repeatCount = 1;\n+        // Handle special keyboard \"repeat\" commands\n+        if (tivoCommand.contains(\"*\")) {\n+            repeatCount = Integer.parseInt(tivoCommand.substring(tivoCommand.indexOf(\"*\") + 1));\n+            tivoCommand = tivoCommand.substring(0, tivoCommand.indexOf(\"*\"));\n+            logger.debug(\"TiVo '{}' - repeating command: '{}' for '{}' times\", tivoConfigData.getCfgIdentifier(),\n+                    tivoCommand, repeatCount);\n+        }\n+        for (int i = 1; i <= repeatCount; i++) {\n+            // Send the command\n+            streamWriter.println(tivoCommand.toString() + \"\\r\");\n+            if (streamWriter.checkError()) {\n+                logger.debug(\"TiVo '{}' - called cmdTivoSend and encountered an IO error\",\n+                        tivoConfigData.getCfgIdentifier());\n+                tivoStatusData = new TivoStatusData(false, -1, -1, false, \"CONNECTION FAILED\", false,\n+                        ConnectionStatus.OFFLINE);\n+                connTivoReconnect();\n+            }\n+        }\n+        return tivoStatusData;\n+    }\n+\n+    /**\n+     * {@link statusParse} processes the {@link TivoStatusData} status message returned from the TiVo.\n+     *\n+     * For channel status messages form 'CH_STATUS channel reason' or 'CH_STATUS channel sub-channel reason' calls\n+     * {@link getParsedChannel} and returns the channel number (if a match is found in a valid formatted message).\n+     *\n+     * @param rawStatus string representing the message text returned by the TiVo\n+     * @return TivoStatusData object conditionally populated based upon the raw status message\n+     */\n+    private TivoStatusData statusParse(String rawStatus) {\n+        logger.debug(\" statusParse '{}' - running on string '{}'\", tivoConfigData.getCfgIdentifier(), rawStatus);\n+\n+        if (rawStatus.contentEquals(\"COMMAND_TIMEOUT\")) {\n+            // Ignore COMMAND_TIMEOUT, they occur a few seconds after each successful command, just return existing\n+            // status again\n+            return this.tivoStatusData;\n+        } else {\n+            switch (rawStatus) {\n+                case \"\":\n+                    return new TivoStatusData(false, -1, -1, false, \"NO_STATUS_DATA_RETURNED\", false,\n+                            tivoStatusData.getConnectionStatus());\n+                case \"LIVETV_READY\":\n+                    return new TivoStatusData(true, -1, -1, false, \"LIVETV_READY\", true, ConnectionStatus.ONLINE);\n+                case \"CH_FAILED NO_LIVE\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED NO_LIVE\", true,\n+                            ConnectionStatus.STANDBY);\n+                case \"CH_FAILED RECORDING\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED RECORDING\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MISSING_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MISSING_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED MALFORMED_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED MALFORMED_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"CH_FAILED INVALID_CHANNEL\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CH_FAILED INVALID_CHANNEL\", true,\n+                            ConnectionStatus.ONLINE);\n+                case \"INVALID_COMMAND\":\n+                    return new TivoStatusData(false, -1, -1, false, \"INVALID_COMMAND\", false, ConnectionStatus.ONLINE);\n+                case \"CONNECTION_RETRIES_EXHAUSTED\":\n+                    return new TivoStatusData(false, -1, -1, false, \"CONNECTION_RETRIES_EXHAUSTED\", true,\n+                            ConnectionStatus.OFFLINE);\n+            }\n+        }\n+\n+        // Only other documented status is in the form 'CH_STATUS channel reason' or\n+        // 'CH_STATUS channel sub-channel reason'\n+        Matcher matcher = TIVO_STATUS_PATTERN.matcher(rawStatus);\n+        int chNum = -1; // -1 used globally to indicate channel number error\n+        int subChNum = -1;\n+        boolean isRecording = false;\n+\n+        if (matcher.find()) {\n+            logger.debug(\" statusParse '{}' - groups '{}' with group count of '{}'\", tivoConfigData.getCfgIdentifier(),\n+                    matcher.group(), matcher.groupCount());\n+            if (matcher.groupCount() == 1 || matcher.groupCount() == 2) {\n+                chNum = Integer.parseInt(matcher.group(1).trim());\n+                logger.debug(\" statusParse '{}' - parsed channel '{}'\", tivoConfigData.getCfgIdentifier(), chNum);\n+            }\n+            if (matcher.groupCount() == 2) {\n+                subChNum = Integer.parseInt(matcher.group(2).trim());\n+                logger.debug(\" statusParse '{}' - parsed sub-channel '{}'\", tivoConfigData.getCfgIdentifier(),\n+                        subChNum);\n+            }\n+\n+            if (rawStatus.contains(\"RECORDING\")) {\n+                isRecording = true;\n+            }\n+\n+            rawStatus = rawStatus.replace(\" REMOTE\", \"\");\n+            rawStatus = rawStatus.replace(\" LOCAL\", \"\");\n+            return new TivoStatusData(true, chNum, subChNum, isRecording, rawStatus, true, ConnectionStatus.ONLINE);\n+        }\n+        logger.warn(\" TiVo '{}' - Unhandled/unexpected status message: '{}'\", tivoConfigData.getCfgIdentifier(),\n+                rawStatus);\n+        return new TivoStatusData(false, -1, -1, false, rawStatus, false, tivoStatusData.getConnectionStatus());\n+    }\n+\n+    /**\n+     * {@link connIsConnected} returns the connection state of the Socket, streamWriter and streamReader objects.\n+     *\n+     * @return true = connection exists and all objects look OK, false = connection does not exist or a problem has\n+     *         occurred\n+     *\n+     */\n+    private boolean connIsConnected() {\n+        Socket tivoSocket = this.tivoSocket;\n+        PrintStream streamWriter = this.streamWriter;\n+\n+        if (tivoSocket == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (!tivoSocket.isConnected()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isConnected=false\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (tivoSocket.isClosed()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoSocket.isClosed=true\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamWriter.checkError()) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: tivoIOSendCommand.checkError()=true\",\n+                    tivoConfigData.getCfgIdentifier());\n+            return false;\n+        } else if (streamReader == null) {\n+            logger.debug(\" connIsConnected '{}' - FALSE: streamReader=null\", tivoConfigData.getCfgIdentifier());\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * {@link connTivoConnect} manages the creation / retry process of the socket connection.\n+     *\n+     * @return true = connected, false = not connected\n+     * @throws InterruptedException\n+     */\n+    public boolean connTivoConnect() throws InterruptedException {\n+        for (int iL = 1; iL <= tivoConfigData.getNumRetry(); iL++) {\n+            logger.debug(\" connTivoConnect '{}' - starting connection process '{}' of '{}'.\",\n+                    tivoConfigData.getCfgIdentifier(), iL, tivoConfigData.getNumRetry());\n+\n+            // Sort out the socket connection\n+            if (connSocketConnect()) {\n+                logger.debug(\" connTivoConnect '{}' - Socket created / connection made.\",\n+                        tivoConfigData.getCfgIdentifier());\n+                StreamReader streamReader = this.streamReader;\n+                if (streamReader != null && streamReader.isAlive()) {\n+                    return true;\n+                }\n+            } else {\n+                logger.debug(\" connTivoConnect '{}' - Socket creation failed.\", tivoConfigData.getCfgIdentifier());\n+                TiVoHandler tivoHandler = this.tivoHandler;\n+                if (tivoHandler != null) {\n+                    tivoHandler.setStatusOffline();\n+                }\n+            }\n+            // Sleep and retry\n+            doNappTime();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@link connTivoReconnect} disconnect and reconnect the socket connection to the TiVo.\n+     *\n+     * @return boolean true = connection succeeded, false = connection failed\n+     * @throws InterruptedException\n+     */\n+    public boolean connTivoReconnect() throws InterruptedException {\n+        connTivoDisconnect();\n+        doNappTime();\n+        return connTivoConnect();\n+    }\n+\n+    /**\n+     * {@link connTivoDisconnect} cleanly closes the socket connection and dependent objects\n+     *\n+     */\n+    public void connTivoDisconnect() throws InterruptedException {\n+        TiVoHandler tivoHandler = this.tivoHandler;\n+        StreamReader streamReader = this.streamReader;\n+        PrintStream streamWriter = this.streamWriter;\n+        Socket tivoSocket = this.tivoSocket;\n+\n+        logger.debug(\" connTivoSocket '{}' - requested to disconnect/cleanup connection objects\",\n+                tivoConfigData.getCfgIdentifier());\n+\n+        // if isCfgKeepConnOpen = false, don't set status to OFFLINE since the socket is closed after each command\n+        if (tivoHandler != null && tivoConfigData.isKeepConnActive()) {\n+            tivoHandler.setStatusOffline();\n+        }\n+\n+        if (streamWriter != null) {\n+            streamWriter.close();\n+            this.streamWriter = null;\n+        }\n+\n+        try {\n+            if (tivoSocket != null) {\n+                tivoSocket.close();\n+                this.tivoSocket = null;\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\" TiVo '{}' - I/O exception while disconnecting: '{}'.  Connection closed.\",\n+                    tivoConfigData.getCfgIdentifier(), e.getMessage());\n+        }\n+\n+        if (streamReader != null) {\n+            streamReader.interrupt();\n+            streamReader.join(TIMEOUT_SEC);\n+            this.streamReader = null;\n+        }\n+    }\n+\n+    /**\n+     * {@link connSocketConnect} opens a Socket connection to the TiVo. Creates a {@link StreamReader} (Input)\n+     * thread to read the responses from the TiVo and a PrintStream (Output) {@link cmdTivoSend}\n+     * to send commands to the device.\n+     *\n+     * @param pConnect true = make a new connection , false = close existing connection\n+     * @return boolean true = connection succeeded, false = connection failed\n+     * @throws InterruptedException\n+     */\n+    private synchronized boolean connSocketConnect() throws InterruptedException {\n+        logger.debug(\" connSocketConnect '{}' - attempting connection to host '{}', port '{}'\",\n+                tivoConfigData.getCfgIdentifier(), tivoConfigData.getHost(), tivoConfigData.getTcpPort());\n+\n+        if (connIsConnected()) {\n+            logger.debug(\" connSocketConnect '{}' - already connected to host '{}', port '{}'\",\n+                    tivoConfigData.getCfgIdentifier(), tivoConfigData.getHost(), tivoConfigData.getTcpPort());\n+            return true;\n+        } else {\n+            // something is wrong, so force a disconnect/clean up so we can try again\n+            connTivoDisconnect();\n+        }\n+\n+        try {\n+            Socket tivoSocket = new Socket(tivoConfigData.getHost(), tivoConfigData.getTcpPort());\n+            tivoSocket.setKeepAlive(true);\n+            tivoSocket.setSoTimeout(CONFIG_SOCKET_TIMEOUT_MS);\n+            tivoSocket.setReuseAddress(true);\n+\n+            if (tivoSocket.isConnected() && !tivoSocket.isClosed()) {\n+                if (streamWriter == null) {\n+                    streamWriter = new PrintStream(tivoSocket.getOutputStream(), false);\n+                }\n+                if (this.streamReader == null) {\n+                    StreamReader streamReader = new StreamReader(tivoSocket.getInputStream());\n+                    streamReader.start();\n+                    this.streamReader = streamReader;\n+                }\n+                this.tivoSocket = tivoSocket;\n+            } else {\n+                logger.debug(\" connSocketConnect '{}' - socket creation failed to host '{}', port '{}'\",\n+                        tivoConfigData.getCfgIdentifier(), tivoConfigData.getHost(), tivoConfigData.getTcpPort());\n+                return false;\n+            }\n+\n+            return true;\n+\n+        } catch (UnknownHostException e) {\n+            logger.debug(\" TiVo '{}' - while connecting, unexpected host error: '{}'\",\n+                    tivoConfigData.getCfgIdentifier(), e.getMessage());\n+        } catch (IOException e) {\n+            if (tivoStatusData.getConnectionStatus() != ConnectionStatus.OFFLINE) {\n+                logger.debug(\" TiVo '{}' - I/O exception while connecting: '{}'\", tivoConfigData.getCfgIdentifier(),\n+                        e.getMessage());\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@link doNappTime} sleeps for the period specified by the getCmdWaitInterval parameter. Primarily used to allow\n+     * the TiVo time to process responses after a command is issued.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public void doNappTime() throws InterruptedException {\n+        TimeUnit.MILLISECONDS.sleep(tivoConfigData.getCmdWaitInterval());\n+    }\n+\n+    public TivoStatusData getServiceStatus() {\n+        return tivoStatusData;\n+    }\n+\n+    public void setServiceStatus(TivoStatusData tivoStatusData) {\n+        this.tivoStatusData = tivoStatusData;\n+    }\n+\n+    /**\n+     * {@link StreamReader} data stream reader that reads the status data returned from the TiVo.\n+     *\n+     */\n+    public class StreamReader extends Thread {\n+        private @Nullable BufferedReader bufferedReader = null;", "originalCommit": "a305e6080d24dbde81ad2279caa70f7103031f0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk0ODU4MA==", "url": "https://github.com/openhab/openhab-addons/pull/9302#discussion_r550948580", "bodyText": "Yes it should. I added a method to close the reader.", "author": "mlobstein", "createdAt": "2021-01-03T03:05:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk0Mjc0OQ=="}], "type": "inlineReview"}, {"oid": "03b07109ab4fbce5722070512d7b59fd082b19cf", "url": "https://github.com/openhab/openhab-addons/commit/03b07109ab4fbce5722070512d7b59fd082b19cf", "message": "Merge branch 'main' into Tivo_OH3", "committedDate": "2021-01-03T01:55:40Z", "type": "commit"}, {"oid": "d74cab2f9b5e8a03fa4f752be9b46a2a6db790a3", "url": "https://github.com/openhab/openhab-addons/commit/d74cab2f9b5e8a03fa4f752be9b46a2a6db790a3", "message": "review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2021-01-03T03:00:41Z", "type": "commit"}]}