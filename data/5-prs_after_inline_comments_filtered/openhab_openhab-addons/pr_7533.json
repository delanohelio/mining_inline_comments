{"pr_number": 7533, "pr_title": "[bticinosmarther] Initial contribution", "pr_createdAt": "2020-05-02T19:18:54Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7533", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1MDM2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429450365", "bodyText": "Since we are going to remove the Apache Commons dependencies, could you replace the line with standard Java code? See #7722", "author": "fwolter", "createdAt": "2020-05-22T21:03:11Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAccountService.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Hashtable;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherAccountService} class to manage the servlets and bind authorization servlet to bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = SmartherAccountService.class, immediate = true, configurationPid = \"binding.smarther.accountService\")\n+@NonNullByDefault\n+public class SmartherAccountService {\n+\n+    private static final String TEMPLATE_PATH = \"templates/\";\n+    private static final String IMAGE_PATH = \"web\";\n+    private static final String TEMPLATE_APPLICATION = TEMPLATE_PATH + \"application.html\";\n+    private static final String TEMPLATE_INDEX = TEMPLATE_PATH + \"index.html\";\n+    private static final String ERROR_UKNOWN_BRIDGE = \"Returned 'state' by doesn't match any Bridges. Has the bridge been removed?\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final List<SmartherAccountHandler> handlers = new ArrayList<>();\n+\n+    private @NonNullByDefault({}) HttpService httpService;\n+    private @NonNullByDefault({}) BundleContext bundleContext;\n+\n+    @Activate\n+    protected void activate(ComponentContext componentContext, Map<String, Object> properties) {\n+        try {\n+            bundleContext = componentContext.getBundleContext();\n+\n+            // Register the authorization servlet\n+            httpService.registerServlet(AUTH_SERVLET_ALIAS, createAuthorizationServlet(), new Hashtable<>(),\n+                    httpService.createDefaultHttpContext());\n+            httpService.registerResources(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS, IMAGE_PATH, null);\n+\n+            // Register the notification servlet\n+            httpService.registerServlet(NOTIFY_SERVLET_ALIAS, createNotificationServlet(), new Hashtable<>(),\n+                    httpService.createDefaultHttpContext());\n+        } catch (NamespaceException | ServletException | IOException e) {\n+            logger.warn(\"Error during Smarther servlet startup\", e);\n+        }\n+    }\n+\n+    @Deactivate\n+    protected void deactivate(ComponentContext componentContext) {\n+        // Unregister the authorization servlet\n+        httpService.unregister(AUTH_SERVLET_ALIAS);\n+        httpService.unregister(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS);\n+\n+        // Unregister the notification servlet\n+        httpService.unregister(NOTIFY_SERVLET_ALIAS);\n+    }\n+\n+    /**\n+     * Creates a new {@link SmartherAuthorizationServlet}.\n+     *\n+     * @return the newly created servlet\n+     * @throws IOException thrown when an HTML template could not be read\n+     */\n+    private HttpServlet createAuthorizationServlet() throws IOException {\n+        return new SmartherAuthorizationServlet(this, readTemplate(TEMPLATE_INDEX), readTemplate(TEMPLATE_APPLICATION));\n+    }\n+\n+    /**\n+     * Creates a new {@link SmartherNotificationServlet}.\n+     *\n+     * @return the newly created servlet\n+     */\n+    private HttpServlet createNotificationServlet() {\n+        return new SmartherNotificationServlet(this);\n+    }\n+\n+    /**\n+     * Reads a template from file and returns the content as String.\n+     *\n+     * @param templateName name of the template file to read\n+     * @return The content of the template file\n+     * @throws IOException thrown when an HTML template could not be read\n+     */\n+    private String readTemplate(String templateName) throws IOException {\n+        final URL index = bundleContext.getBundle().getEntry(templateName);\n+\n+        if (index == null) {\n+            throw new FileNotFoundException(\n+                    String.format(\"Cannot find template '%s' - failed to initialize Smarther servlet\", templateName));\n+        } else {\n+            try (InputStream inputStream = index.openStream()) {\n+                return IOUtils.toString(inputStream);", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY0NDQ4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429644486", "bodyText": "Done.", "author": "MrRonfo", "createdAt": "2020-05-24T14:49:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1MDM2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1NDA1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429454058", "bodyText": "Apache Commons", "author": "fwolter", "createdAt": "2020-05-22T21:15:29Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAuthorizationServlet.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.model.Location;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherAuthorizationServlet} manages the authorization with the BTicino/Legrand API gateway. The servlet\n+ * implements the Authorization Code flow and saves the resulting refreshToken with the bridge.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherAuthorizationServlet extends HttpServlet {\n+\n+    private static final long serialVersionUID = 5199173744807168342L;\n+\n+    private static final String CONTENT_TYPE = \"text/html;charset=UTF-8\";\n+    private static final String X_FORWARDED_PROTO = \"X-Forwarded-Proto\";\n+\n+    // Simple HTML templates for inserting messages.\n+    private static final String HTML_EMPTY_APPLICATIONS = \"<p class='block'>Manually add a Smarther Bridge to authorize it here<p>\";\n+    private static final String HTML_BRIDGE_AUTHORIZED = \"<p class='block authorized'>Bridge authorized for Client Id %s</p>\";\n+    private static final String HTML_ERROR = \"<p class='block error'>Call to Smarther API gateway failed with error: %s</p>\";\n+\n+    private static final Pattern MESSAGE_KEY_PATTERN = Pattern.compile(\"\\\\$\\\\{([^\\\\}]+)\\\\}\");\n+\n+    // Keys present in the index.html\n+    private static final String KEY_PAGE_REFRESH = \"pageRefresh\";\n+    private static final String HTML_META_REFRESH_CONTENT = \"<meta http-equiv='refresh' content='10; url=%s'>\";\n+    private static final String KEY_AUTHORIZED_BRIDGE = \"authorizedBridge\";\n+    private static final String KEY_ERROR = \"error\";\n+    private static final String KEY_APPLICATIONS = \"applications\";\n+    private static final String KEY_REDIRECT_URI = \"redirectUri\";\n+    // Keys present in the application.html\n+    private static final String APPLICATION_ID = \"application.id\";\n+    private static final String APPLICATION_NAME = \"application.name\";\n+    private static final String APPLICATION_LOCATIONS = \"application.locations\";\n+    private static final String APPLICATION_AUTHORIZED_CLASS = \"application.authorized\";\n+    private static final String APPLICATION_AUTHORIZE = \"application.authorize\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final SmartherAccountService accountService;\n+    private final String indexTemplate;\n+    private final String applicationTemplate;\n+\n+    public SmartherAuthorizationServlet(SmartherAccountService accountService, String indexTemplate,\n+            String applicationTemplate) {\n+        this.accountService = accountService;\n+        this.indexTemplate = indexTemplate;\n+        this.applicationTemplate = applicationTemplate;\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req == null || resp == null) {\n+            throw new SmartherAuthorizationException(\"Authorization callback with null request/response\");\n+        }\n+\n+        final String servletBaseURL = extractServletBaseURL(req);\n+        final Map<String, String> replaceMap = new HashMap<>();\n+        logger.debug(\"Authorization callback servlet received GET request {}\", servletBaseURL);\n+\n+        // Handle the received data\n+        handleSmartherRedirect(replaceMap, servletBaseURL, req.getQueryString());\n+\n+        // Build response for the caller\n+        resp.setContentType(CONTENT_TYPE);\n+        replaceMap.put(KEY_REDIRECT_URI, servletBaseURL);\n+        replaceMap.put(KEY_APPLICATIONS, formatApplications(applicationTemplate, servletBaseURL));\n+        resp.getWriter().append(replaceKeysFromMap(indexTemplate, replaceMap));\n+        resp.getWriter().close();\n+    }\n+\n+    /**\n+     * Extracts the servlet base URL from received HTTP request, possibly handling reverse proxies.\n+     *\n+     * @param req The received HTTP request\n+     * @return A string containing the servlet base URL\n+     */\n+    private String extractServletBaseURL(HttpServletRequest req) {\n+        final StringBuffer requestURL = req.getRequestURL();\n+\n+        // Try to infer the real protocol from request headers\n+        final String realProtocol = StringUtils.defaultIfBlank(req.getHeader(X_FORWARDED_PROTO), req.getScheme());", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY0NTM2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429645364", "bodyText": "Done.", "author": "MrRonfo", "createdAt": "2020-05-24T14:59:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1NDA1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1NTExNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429455115", "bodyText": "Apache Commons", "author": "fwolter", "createdAt": "2020-05-22T21:19:10Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAuthorizationServlet.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.model.Location;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherAuthorizationServlet} manages the authorization with the BTicino/Legrand API gateway. The servlet\n+ * implements the Authorization Code flow and saves the resulting refreshToken with the bridge.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherAuthorizationServlet extends HttpServlet {\n+\n+    private static final long serialVersionUID = 5199173744807168342L;\n+\n+    private static final String CONTENT_TYPE = \"text/html;charset=UTF-8\";\n+    private static final String X_FORWARDED_PROTO = \"X-Forwarded-Proto\";\n+\n+    // Simple HTML templates for inserting messages.\n+    private static final String HTML_EMPTY_APPLICATIONS = \"<p class='block'>Manually add a Smarther Bridge to authorize it here<p>\";\n+    private static final String HTML_BRIDGE_AUTHORIZED = \"<p class='block authorized'>Bridge authorized for Client Id %s</p>\";\n+    private static final String HTML_ERROR = \"<p class='block error'>Call to Smarther API gateway failed with error: %s</p>\";\n+\n+    private static final Pattern MESSAGE_KEY_PATTERN = Pattern.compile(\"\\\\$\\\\{([^\\\\}]+)\\\\}\");\n+\n+    // Keys present in the index.html\n+    private static final String KEY_PAGE_REFRESH = \"pageRefresh\";\n+    private static final String HTML_META_REFRESH_CONTENT = \"<meta http-equiv='refresh' content='10; url=%s'>\";\n+    private static final String KEY_AUTHORIZED_BRIDGE = \"authorizedBridge\";\n+    private static final String KEY_ERROR = \"error\";\n+    private static final String KEY_APPLICATIONS = \"applications\";\n+    private static final String KEY_REDIRECT_URI = \"redirectUri\";\n+    // Keys present in the application.html\n+    private static final String APPLICATION_ID = \"application.id\";\n+    private static final String APPLICATION_NAME = \"application.name\";\n+    private static final String APPLICATION_LOCATIONS = \"application.locations\";\n+    private static final String APPLICATION_AUTHORIZED_CLASS = \"application.authorized\";\n+    private static final String APPLICATION_AUTHORIZE = \"application.authorize\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final SmartherAccountService accountService;\n+    private final String indexTemplate;\n+    private final String applicationTemplate;\n+\n+    public SmartherAuthorizationServlet(SmartherAccountService accountService, String indexTemplate,\n+            String applicationTemplate) {\n+        this.accountService = accountService;\n+        this.indexTemplate = indexTemplate;\n+        this.applicationTemplate = applicationTemplate;\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req == null || resp == null) {\n+            throw new SmartherAuthorizationException(\"Authorization callback with null request/response\");\n+        }\n+\n+        final String servletBaseURL = extractServletBaseURL(req);\n+        final Map<String, String> replaceMap = new HashMap<>();\n+        logger.debug(\"Authorization callback servlet received GET request {}\", servletBaseURL);\n+\n+        // Handle the received data\n+        handleSmartherRedirect(replaceMap, servletBaseURL, req.getQueryString());\n+\n+        // Build response for the caller\n+        resp.setContentType(CONTENT_TYPE);\n+        replaceMap.put(KEY_REDIRECT_URI, servletBaseURL);\n+        replaceMap.put(KEY_APPLICATIONS, formatApplications(applicationTemplate, servletBaseURL));\n+        resp.getWriter().append(replaceKeysFromMap(indexTemplate, replaceMap));\n+        resp.getWriter().close();\n+    }\n+\n+    /**\n+     * Extracts the servlet base URL from received HTTP request, possibly handling reverse proxies.\n+     *\n+     * @param req The received HTTP request\n+     * @return A string containing the servlet base URL\n+     */\n+    private String extractServletBaseURL(HttpServletRequest req) {\n+        final StringBuffer requestURL = req.getRequestURL();\n+\n+        // Try to infer the real protocol from request headers\n+        final String realProtocol = StringUtils.defaultIfBlank(req.getHeader(X_FORWARDED_PROTO), req.getScheme());\n+\n+        return requestURL.replace(0, requestURL.indexOf(\":\"), realProtocol).toString();\n+    }\n+\n+    /**\n+     * Handles a possible call from BTicino/Legrand API gateway to the redirect_uri. If that is the case,\n+     * BTicino/Legrand API gateway will pass the authorization codes via the url and these are processed. In case of an\n+     * error this is shown to the user. If the user was authorized this is passed on to the handler. Based on all these\n+     * different outcomes the HTML is generated to inform the user.\n+     *\n+     * @param replaceMap a map with key String values that will be mapped in the HTML templates\n+     * @param servletBaseURL the servlet base, which should be used as the BTicino/Legrand API gateway redirect_uri\n+     *            value\n+     * @param queryString the query part of the GET request this servlet is processing\n+     */\n+    private void handleSmartherRedirect(Map<String, String> replaceMap, String servletBaseURL,\n+            @Nullable String queryString) {\n+        replaceMap.put(KEY_AUTHORIZED_BRIDGE, \"\");\n+        replaceMap.put(KEY_ERROR, \"\");\n+        replaceMap.put(KEY_PAGE_REFRESH, \"\");\n+\n+        if (queryString != null) {\n+            final MultiMap<String> params = new MultiMap<>();\n+            UrlEncoded.decodeTo(queryString, params, StandardCharsets.UTF_8.name());\n+            final String reqCode = params.getString(\"code\");\n+            final String reqState = params.getString(\"state\");\n+            final String reqError = params.getString(\"error\");\n+\n+            replaceMap.put(KEY_PAGE_REFRESH,\n+                    params.isEmpty() ? \"\" : String.format(HTML_META_REFRESH_CONTENT, servletBaseURL));\n+            if (!StringUtil.isBlank(reqError)) {\n+                logger.debug(\"Authorization redirected with an error: {}\", reqError);\n+                replaceMap.put(KEY_ERROR, String.format(HTML_ERROR, reqError));\n+            } else if (!StringUtil.isBlank(reqState)) {", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY0NTM5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429645391", "bodyText": "Done.", "author": "MrRonfo", "createdAt": "2020-05-24T14:59:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1NTExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1NjE3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429456176", "bodyText": "What do you want to catch here? If you really have to catch an unchecked Exception, better specify the exact type.", "author": "fwolter", "createdAt": "2020-05-22T21:23:14Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAuthorizationServlet.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.model.Location;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherAuthorizationServlet} manages the authorization with the BTicino/Legrand API gateway. The servlet\n+ * implements the Authorization Code flow and saves the resulting refreshToken with the bridge.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherAuthorizationServlet extends HttpServlet {\n+\n+    private static final long serialVersionUID = 5199173744807168342L;\n+\n+    private static final String CONTENT_TYPE = \"text/html;charset=UTF-8\";\n+    private static final String X_FORWARDED_PROTO = \"X-Forwarded-Proto\";\n+\n+    // Simple HTML templates for inserting messages.\n+    private static final String HTML_EMPTY_APPLICATIONS = \"<p class='block'>Manually add a Smarther Bridge to authorize it here<p>\";\n+    private static final String HTML_BRIDGE_AUTHORIZED = \"<p class='block authorized'>Bridge authorized for Client Id %s</p>\";\n+    private static final String HTML_ERROR = \"<p class='block error'>Call to Smarther API gateway failed with error: %s</p>\";\n+\n+    private static final Pattern MESSAGE_KEY_PATTERN = Pattern.compile(\"\\\\$\\\\{([^\\\\}]+)\\\\}\");\n+\n+    // Keys present in the index.html\n+    private static final String KEY_PAGE_REFRESH = \"pageRefresh\";\n+    private static final String HTML_META_REFRESH_CONTENT = \"<meta http-equiv='refresh' content='10; url=%s'>\";\n+    private static final String KEY_AUTHORIZED_BRIDGE = \"authorizedBridge\";\n+    private static final String KEY_ERROR = \"error\";\n+    private static final String KEY_APPLICATIONS = \"applications\";\n+    private static final String KEY_REDIRECT_URI = \"redirectUri\";\n+    // Keys present in the application.html\n+    private static final String APPLICATION_ID = \"application.id\";\n+    private static final String APPLICATION_NAME = \"application.name\";\n+    private static final String APPLICATION_LOCATIONS = \"application.locations\";\n+    private static final String APPLICATION_AUTHORIZED_CLASS = \"application.authorized\";\n+    private static final String APPLICATION_AUTHORIZE = \"application.authorize\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final SmartherAccountService accountService;\n+    private final String indexTemplate;\n+    private final String applicationTemplate;\n+\n+    public SmartherAuthorizationServlet(SmartherAccountService accountService, String indexTemplate,\n+            String applicationTemplate) {\n+        this.accountService = accountService;\n+        this.indexTemplate = indexTemplate;\n+        this.applicationTemplate = applicationTemplate;\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req == null || resp == null) {\n+            throw new SmartherAuthorizationException(\"Authorization callback with null request/response\");\n+        }\n+\n+        final String servletBaseURL = extractServletBaseURL(req);\n+        final Map<String, String> replaceMap = new HashMap<>();\n+        logger.debug(\"Authorization callback servlet received GET request {}\", servletBaseURL);\n+\n+        // Handle the received data\n+        handleSmartherRedirect(replaceMap, servletBaseURL, req.getQueryString());\n+\n+        // Build response for the caller\n+        resp.setContentType(CONTENT_TYPE);\n+        replaceMap.put(KEY_REDIRECT_URI, servletBaseURL);\n+        replaceMap.put(KEY_APPLICATIONS, formatApplications(applicationTemplate, servletBaseURL));\n+        resp.getWriter().append(replaceKeysFromMap(indexTemplate, replaceMap));\n+        resp.getWriter().close();\n+    }\n+\n+    /**\n+     * Extracts the servlet base URL from received HTTP request, possibly handling reverse proxies.\n+     *\n+     * @param req The received HTTP request\n+     * @return A string containing the servlet base URL\n+     */\n+    private String extractServletBaseURL(HttpServletRequest req) {\n+        final StringBuffer requestURL = req.getRequestURL();\n+\n+        // Try to infer the real protocol from request headers\n+        final String realProtocol = StringUtils.defaultIfBlank(req.getHeader(X_FORWARDED_PROTO), req.getScheme());\n+\n+        return requestURL.replace(0, requestURL.indexOf(\":\"), realProtocol).toString();\n+    }\n+\n+    /**\n+     * Handles a possible call from BTicino/Legrand API gateway to the redirect_uri. If that is the case,\n+     * BTicino/Legrand API gateway will pass the authorization codes via the url and these are processed. In case of an\n+     * error this is shown to the user. If the user was authorized this is passed on to the handler. Based on all these\n+     * different outcomes the HTML is generated to inform the user.\n+     *\n+     * @param replaceMap a map with key String values that will be mapped in the HTML templates\n+     * @param servletBaseURL the servlet base, which should be used as the BTicino/Legrand API gateway redirect_uri\n+     *            value\n+     * @param queryString the query part of the GET request this servlet is processing\n+     */\n+    private void handleSmartherRedirect(Map<String, String> replaceMap, String servletBaseURL,\n+            @Nullable String queryString) {\n+        replaceMap.put(KEY_AUTHORIZED_BRIDGE, \"\");\n+        replaceMap.put(KEY_ERROR, \"\");\n+        replaceMap.put(KEY_PAGE_REFRESH, \"\");\n+\n+        if (queryString != null) {\n+            final MultiMap<String> params = new MultiMap<>();\n+            UrlEncoded.decodeTo(queryString, params, StandardCharsets.UTF_8.name());\n+            final String reqCode = params.getString(\"code\");\n+            final String reqState = params.getString(\"state\");\n+            final String reqError = params.getString(\"error\");\n+\n+            replaceMap.put(KEY_PAGE_REFRESH,\n+                    params.isEmpty() ? \"\" : String.format(HTML_META_REFRESH_CONTENT, servletBaseURL));\n+            if (!StringUtil.isBlank(reqError)) {\n+                logger.debug(\"Authorization redirected with an error: {}\", reqError);\n+                replaceMap.put(KEY_ERROR, String.format(HTML_ERROR, reqError));\n+            } else if (!StringUtil.isBlank(reqState)) {\n+                try {\n+                    logger.debug(\"Received from authorization - state:[{}] code:[{}]\", reqState, reqCode);\n+                    replaceMap.put(KEY_AUTHORIZED_BRIDGE, String.format(HTML_BRIDGE_AUTHORIZED,\n+                            accountService.authorize(servletBaseURL, reqState, reqCode)));\n+                } catch (RuntimeException e) {", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY0NTgwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429645803", "bodyText": "Specified: SmartherAuthorizationException | SmartherGatewayException", "author": "MrRonfo", "createdAt": "2020-05-24T15:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1NjE3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1Njg3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429456872", "bodyText": "Apache Commons", "author": "fwolter", "createdAt": "2020-05-22T21:26:01Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherNotificationServlet.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherNotificationException;\n+import org.openhab.binding.smarther.internal.api.model.ModelUtil;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+/**\n+ * The {@link SmartherNotificationServlet} manages the notifications from BTicino/Legrand C2C notification service.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherNotificationServlet extends HttpServlet {\n+\n+    private static final long serialVersionUID = -2474355132186048438L;\n+\n+    private static final String CONTENT_TYPE = \"application/json;charset=UTF-8\";\n+    private static final String OK_RESULT_MSG = \"{\\\"result\\\":0}\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final SmartherAccountService accountService;\n+\n+    public SmartherNotificationServlet(SmartherAccountService accountService) {\n+        this.accountService = accountService;\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req == null || resp == null) {\n+            throw new SmartherNotificationException(\"Notification callback with null request/response\");\n+        }\n+\n+        logger.debug(\"Notification callback servlet received POST request {}\", req.getRequestURI());\n+\n+        // Handle the received data\n+        final String requestBody = req.getReader().lines().collect(Collectors.joining(System.lineSeparator()));\n+        final String responseBody = handleSmartherNotifications(requestBody);\n+\n+        // Build response for the caller\n+        resp.setContentType(CONTENT_TYPE);\n+        resp.getWriter().append(responseBody);\n+        resp.setStatus(HttpStatus.OK_200);\n+        resp.getWriter().close();\n+    }\n+\n+    /**\n+     * Handles a notification payload received from BTicino/Legrand C2C notification service. If that is the case,\n+     * BTicino/Legrand C2C notification service will pass a list of notifications via the url and these are processed.\n+     * In case of an error, this is logged and the notifications are not passed on to the handler. Based on all these\n+     * different outcomes, the response is generated to inform the C2C service.\n+     *\n+     * @param payload the body part of the POST request this servlet is processing\n+     */\n+    private String handleSmartherNotifications(@Nullable String payload) {\n+        logger.trace(\"C2C listener received payload: {}\", payload);\n+        if (!StringUtils.isBlank(payload)) {", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY0NTkwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429645902", "bodyText": "Done.", "author": "MrRonfo", "createdAt": "2020-05-24T15:05:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1Njg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NDIyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429464228", "bodyText": "Can you use Java native date time classes here? That would prevent an additional dependency to Joda.", "author": "fwolter", "createdAt": "2020-05-22T21:44:25Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/model/Chronothermostat.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api.model;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.joda.time.DateTime;\n+import org.openhab.binding.smarther.internal.api.model.Enums.LoadState;\n+import org.openhab.binding.smarther.internal.api.model.Enums.MeasureUnit;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * Smarther API Chronothermostat DTO class.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+public class Chronothermostat {\n+\n+    private String function;\n+    private String mode;\n+    @SerializedName(\"setPoint\")\n+    private Measure setPointTemperature;\n+    private List<Program> programs;\n+    @SerializedName(\"temperatureFormat\")\n+    private String temperatureFormat;\n+    @SerializedName(\"loadState\")\n+    private String loadState;\n+    @SerializedName(\"activationTime\")\n+    private String activationTime;\n+    private String time;\n+    private Sensor thermometer;\n+    private Sensor hygrometer;\n+    private boolean online;\n+    private Sender sender;\n+\n+    public String getFunction() {\n+        return function;\n+    }\n+\n+    public String getMode() {\n+        return mode;\n+    }\n+\n+    public Measure getSetPointTemperature() {\n+        return setPointTemperature;\n+    }\n+\n+    public List<Program> getPrograms() {\n+        return (programs != null) ? programs : Collections.emptyList();\n+    }\n+\n+    public String getTemperatureFormat() {\n+        return temperatureFormat;\n+    }\n+\n+    public MeasureUnit getTemperatureFormatUnit() {\n+        return MeasureUnit.fromValue(temperatureFormat);\n+    }\n+\n+    public boolean isTemperatureFormatCelsius() {\n+        return MeasureUnit.CELSIUS.getValue().equals(temperatureFormat);\n+    }\n+\n+    public boolean isTemperatureFormatFahrenheit() {\n+        return MeasureUnit.FAHRENHEIT.getValue().equals(temperatureFormat);\n+    }\n+\n+    public String getLoadState() {\n+        return loadState;\n+    }\n+\n+    public boolean isActive() {\n+        return LoadState.fromValue(loadState).isActive();\n+    }\n+\n+    public String getActivationTime() {\n+        return activationTime;\n+    }\n+\n+    public String getActivationTimeLabel() {\n+        String timeLabel = \"Forever\";\n+        if (activationTime != null) {\n+            final DateTime dateActivationTime = new DateTime(activationTime);", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NTA2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429665064", "bodyText": "Converted to Java Date, I've build up a DateUtil class to manage all the date transformations.", "author": "MrRonfo", "createdAt": "2020-05-24T18:57:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NDIyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NDU4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429464585", "bodyText": "Apache Commons", "author": "fwolter", "createdAt": "2020-05-22T21:45:44Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/model/Location.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api.model;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Smarther API Location data class.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Location {\n+\n+    private String plantId;\n+    private String name;\n+    private @Nullable String subscriptionId;\n+    private @Nullable String endpointUrl;\n+\n+    private Location(Plant plant, @Nullable Subscription subscription) {\n+        super();\n+        this.plantId = plant.getId();\n+        this.name = plant.getName();\n+        if (subscription != null) {\n+            this.subscriptionId = subscription.getSubscriptionId();\n+            this.endpointUrl = subscription.getEndpointUrl();\n+        }\n+    }\n+\n+    public static Location fromPlant(Plant plant, @Nullable Subscription subscription) {\n+        return new Location(plant, subscription);\n+    }\n+\n+    public static Location fromPlant(Plant plant) {\n+        return new Location(plant, null);\n+    }\n+\n+    public static Location fromPlant(Plant plant, Optional<Subscription> subscription) {\n+        return (subscription.isPresent()) ? new Location(plant, subscription.get()) : new Location(plant, null);\n+    }\n+\n+    public String getPlantId() {\n+        return plantId;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public boolean hasSubscription() {\n+        return StringUtils.isNotBlank(subscriptionId);", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY0NjA1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429646059", "bodyText": "Done.", "author": "MrRonfo", "createdAt": "2020-05-24T15:07:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NDU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NDk4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429464987", "bodyText": "Apache Commons", "author": "fwolter", "createdAt": "2020-05-22T21:47:05Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/model/Measure.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api.model;\n+\n+import java.util.Optional;\n+\n+import javax.measure.quantity.Dimensionless;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.smarther.internal.api.model.Enums.MeasureUnit;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+import tec.uom.se.unit.Units;\n+\n+/**\n+ * Smarther API Measure DTO class.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+public class Measure {\n+\n+    @SerializedName(\"timeStamp\")\n+    private String timestamp;\n+    private String value;\n+    private String unit;\n+\n+    public String getTimestamp() {\n+        return timestamp;\n+    }\n+\n+    public String getValue() {\n+        return value;\n+    }\n+\n+    public String getUnit() {\n+        return unit;\n+    }\n+\n+    public MeasureUnit getMeasureUnit() {\n+        return MeasureUnit.fromValue(unit);\n+    }\n+\n+    public State toState() {\n+        State state = UnDefType.UNDEF;\n+        final Optional<Double> optValue = (StringUtils.isBlank(value)) ? Optional.empty()", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY0NjEzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429646137", "bodyText": "Done.", "author": "MrRonfo", "createdAt": "2020-05-24T15:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NDk4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NTQ4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429465484", "bodyText": "Can you use Java native date time classes here? That would prevent an additional dependency to Joda.", "author": "fwolter", "createdAt": "2020-05-22T21:49:06Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/model/ModuleSettings.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api.model;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.joda.time.DateTime;\n+import org.joda.time.format.DateTimeFormat;\n+import org.openhab.binding.smarther.internal.api.model.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.model.Enums.Function;\n+import org.openhab.binding.smarther.internal.api.model.Enums.Mode;\n+\n+/**\n+ * Smarther API ModuleSettings update data class.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ModuleSettings {\n+\n+    private transient String plantId;\n+    private transient String moduleId;\n+    private Function function;\n+    private Mode mode;\n+    private QuantityType<Temperature> setPointTemperature;\n+    private int program;\n+    private BoostTime boostTime;\n+    private @Nullable String endDate;\n+    private int endHour;\n+    private int endMinute;\n+\n+    public ModuleSettings(String plantId, String moduleId) {\n+        this.plantId = plantId;\n+        this.moduleId = moduleId;\n+        this.function = Function.HEATING;\n+        this.mode = Mode.AUTOMATIC;\n+        this.setPointTemperature = QuantityType.valueOf(7.0, SIUnits.CELSIUS);\n+        this.program = 0;\n+        this.boostTime = BoostTime.MINUTES_30;\n+        this.endDate = null;\n+        this.endHour = 0;\n+        this.endMinute = 0;\n+    }\n+\n+    public void updateFromChronothermostat(Chronothermostat chronothermostat) {\n+        this.function = Function.fromValue(chronothermostat.getFunction());\n+    }\n+\n+    public String getPlantId() {\n+        return plantId;\n+    }\n+\n+    public String getModuleId() {\n+        return moduleId;\n+    }\n+\n+    public Function getFunction() {\n+        return function;\n+    }\n+\n+    public Mode getMode() {\n+        return mode;\n+    }\n+\n+    public void setMode(Mode mode) {\n+        this.mode = mode;\n+    }\n+\n+    public QuantityType<Temperature> getSetPointTemperature() {\n+        return setPointTemperature;\n+    }\n+\n+    @Nullable\n+    public QuantityType<Temperature> getSetPointTemperature(Unit<?> targetUnit) {\n+        return setPointTemperature.toUnit(targetUnit);\n+    }\n+\n+    public void setSetPointTemperature(QuantityType<Temperature> setPointTemperature) {\n+        this.setPointTemperature = setPointTemperature;\n+    }\n+\n+    public int getProgram() {\n+        return program;\n+    }\n+\n+    public void setProgram(int program) {\n+        this.program = program;\n+    }\n+\n+    public BoostTime getBoostTime() {\n+        return boostTime;\n+    }\n+\n+    public void setBoostTime(BoostTime boostTime) {\n+        this.boostTime = boostTime;\n+    }\n+\n+    @Nullable\n+    public String getEndDate() {\n+        return endDate;\n+    }\n+\n+    public boolean isEndDateExpired() {\n+        if (endDate == null) {\n+            return false;\n+        }\n+\n+        final DateTime dtEndDate = DateTimeFormat.forPattern(DATE_FORMAT).parseDateTime(endDate).withTimeAtStartOfDay();\n+        final DateTime dtToday = DateTime.now().withTimeAtStartOfDay();", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3MTEyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429671127", "bodyText": "Changed to Java date time classes", "author": "MrRonfo", "createdAt": "2020-05-24T20:15:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NTQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NTUzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429465539", "bodyText": "Apache Commons", "author": "fwolter", "createdAt": "2020-05-22T21:49:16Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/model/ModuleSettings.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api.model;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.joda.time.DateTime;\n+import org.joda.time.format.DateTimeFormat;\n+import org.openhab.binding.smarther.internal.api.model.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.model.Enums.Function;\n+import org.openhab.binding.smarther.internal.api.model.Enums.Mode;\n+\n+/**\n+ * Smarther API ModuleSettings update data class.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ModuleSettings {\n+\n+    private transient String plantId;\n+    private transient String moduleId;\n+    private Function function;\n+    private Mode mode;\n+    private QuantityType<Temperature> setPointTemperature;\n+    private int program;\n+    private BoostTime boostTime;\n+    private @Nullable String endDate;\n+    private int endHour;\n+    private int endMinute;\n+\n+    public ModuleSettings(String plantId, String moduleId) {\n+        this.plantId = plantId;\n+        this.moduleId = moduleId;\n+        this.function = Function.HEATING;\n+        this.mode = Mode.AUTOMATIC;\n+        this.setPointTemperature = QuantityType.valueOf(7.0, SIUnits.CELSIUS);\n+        this.program = 0;\n+        this.boostTime = BoostTime.MINUTES_30;\n+        this.endDate = null;\n+        this.endHour = 0;\n+        this.endMinute = 0;\n+    }\n+\n+    public void updateFromChronothermostat(Chronothermostat chronothermostat) {\n+        this.function = Function.fromValue(chronothermostat.getFunction());\n+    }\n+\n+    public String getPlantId() {\n+        return plantId;\n+    }\n+\n+    public String getModuleId() {\n+        return moduleId;\n+    }\n+\n+    public Function getFunction() {\n+        return function;\n+    }\n+\n+    public Mode getMode() {\n+        return mode;\n+    }\n+\n+    public void setMode(Mode mode) {\n+        this.mode = mode;\n+    }\n+\n+    public QuantityType<Temperature> getSetPointTemperature() {\n+        return setPointTemperature;\n+    }\n+\n+    @Nullable\n+    public QuantityType<Temperature> getSetPointTemperature(Unit<?> targetUnit) {\n+        return setPointTemperature.toUnit(targetUnit);\n+    }\n+\n+    public void setSetPointTemperature(QuantityType<Temperature> setPointTemperature) {\n+        this.setPointTemperature = setPointTemperature;\n+    }\n+\n+    public int getProgram() {\n+        return program;\n+    }\n+\n+    public void setProgram(int program) {\n+        this.program = program;\n+    }\n+\n+    public BoostTime getBoostTime() {\n+        return boostTime;\n+    }\n+\n+    public void setBoostTime(BoostTime boostTime) {\n+        this.boostTime = boostTime;\n+    }\n+\n+    @Nullable\n+    public String getEndDate() {\n+        return endDate;\n+    }\n+\n+    public boolean isEndDateExpired() {\n+        if (endDate == null) {\n+            return false;\n+        }\n+\n+        final DateTime dtEndDate = DateTimeFormat.forPattern(DATE_FORMAT).parseDateTime(endDate).withTimeAtStartOfDay();\n+        final DateTime dtToday = DateTime.now().withTimeAtStartOfDay();\n+\n+        return (dtEndDate.isBefore(dtToday));\n+    }\n+\n+    public void setEndDate(String endDate) {\n+        this.endDate = StringUtils.stripToNull(endDate);", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY0Nzc5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429647796", "bodyText": "Done.", "author": "MrRonfo", "createdAt": "2020-05-24T15:26:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NTUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NTY4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429465686", "bodyText": "Can you use Java native date time classes here? That would prevent an additional dependency to Joda.", "author": "fwolter", "createdAt": "2020-05-22T21:49:56Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/model/ModuleSettings.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api.model;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.joda.time.DateTime;\n+import org.joda.time.format.DateTimeFormat;\n+import org.openhab.binding.smarther.internal.api.model.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.model.Enums.Function;\n+import org.openhab.binding.smarther.internal.api.model.Enums.Mode;\n+\n+/**\n+ * Smarther API ModuleSettings update data class.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ModuleSettings {\n+\n+    private transient String plantId;\n+    private transient String moduleId;\n+    private Function function;\n+    private Mode mode;\n+    private QuantityType<Temperature> setPointTemperature;\n+    private int program;\n+    private BoostTime boostTime;\n+    private @Nullable String endDate;\n+    private int endHour;\n+    private int endMinute;\n+\n+    public ModuleSettings(String plantId, String moduleId) {\n+        this.plantId = plantId;\n+        this.moduleId = moduleId;\n+        this.function = Function.HEATING;\n+        this.mode = Mode.AUTOMATIC;\n+        this.setPointTemperature = QuantityType.valueOf(7.0, SIUnits.CELSIUS);\n+        this.program = 0;\n+        this.boostTime = BoostTime.MINUTES_30;\n+        this.endDate = null;\n+        this.endHour = 0;\n+        this.endMinute = 0;\n+    }\n+\n+    public void updateFromChronothermostat(Chronothermostat chronothermostat) {\n+        this.function = Function.fromValue(chronothermostat.getFunction());\n+    }\n+\n+    public String getPlantId() {\n+        return plantId;\n+    }\n+\n+    public String getModuleId() {\n+        return moduleId;\n+    }\n+\n+    public Function getFunction() {\n+        return function;\n+    }\n+\n+    public Mode getMode() {\n+        return mode;\n+    }\n+\n+    public void setMode(Mode mode) {\n+        this.mode = mode;\n+    }\n+\n+    public QuantityType<Temperature> getSetPointTemperature() {\n+        return setPointTemperature;\n+    }\n+\n+    @Nullable\n+    public QuantityType<Temperature> getSetPointTemperature(Unit<?> targetUnit) {\n+        return setPointTemperature.toUnit(targetUnit);\n+    }\n+\n+    public void setSetPointTemperature(QuantityType<Temperature> setPointTemperature) {\n+        this.setPointTemperature = setPointTemperature;\n+    }\n+\n+    public int getProgram() {\n+        return program;\n+    }\n+\n+    public void setProgram(int program) {\n+        this.program = program;\n+    }\n+\n+    public BoostTime getBoostTime() {\n+        return boostTime;\n+    }\n+\n+    public void setBoostTime(BoostTime boostTime) {\n+        this.boostTime = boostTime;\n+    }\n+\n+    @Nullable\n+    public String getEndDate() {\n+        return endDate;\n+    }\n+\n+    public boolean isEndDateExpired() {\n+        if (endDate == null) {\n+            return false;\n+        }\n+\n+        final DateTime dtEndDate = DateTimeFormat.forPattern(DATE_FORMAT).parseDateTime(endDate).withTimeAtStartOfDay();\n+        final DateTime dtToday = DateTime.now().withTimeAtStartOfDay();\n+\n+        return (dtEndDate.isBefore(dtToday));\n+    }\n+\n+    public void setEndDate(String endDate) {\n+        this.endDate = StringUtils.stripToNull(endDate);\n+    }\n+\n+    public int getEndHour() {\n+        return endHour;\n+    }\n+\n+    public void setEndHour(int endHour) {\n+        this.endHour = endHour;\n+    }\n+\n+    public int getEndMinute() {\n+        return endMinute;\n+    }\n+\n+    public void setEndMinute(int endMinute) {\n+        this.endMinute = endMinute;\n+    }\n+\n+    public String getActivationTime() {\n+        if (mode.equals(Mode.MANUAL) && (endDate != null)) {\n+            DateTime d = DateTimeFormat.forPattern(DATE_FORMAT).parseDateTime(endDate);\n+            d = d.withTime(endHour, endMinute, 0, 0);\n+            return d.toString(DATETIME_FORMAT);\n+        } else if (mode.equals(Mode.BOOST)) {\n+            DateTime d1 = DateTime.now().withSecondOfMinute(0).withMillisOfSecond(0);\n+            DateTime d2 = d1.plusMinutes(boostTime.getValue());", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3MTE0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429671146", "bodyText": "Changed to Java date time classes", "author": "MrRonfo", "createdAt": "2020-05-24T20:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NTY4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyODc1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429528753", "bodyText": "What Exception do you want to catch here? Would a checked Exception be sufficient?", "author": "fwolter", "createdAt": "2020-05-23T08:56:09Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/discovery/SmartherModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.discovery;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.lang.WordUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.api.model.Location;\n+import org.openhab.binding.smarther.internal.api.model.Module;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherModuleDiscoveryService} queries the Smarther API gateway for available modules.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.smarther\")\n+@NonNullByDefault\n+public class SmartherModuleDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+\n+    // Only modules can be discovered. A bridge must be manually added.\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_MODULE);\n+    // The call to listModules is fast\n+    private static final int DISCOVERY_TIME_SECONDS = 10;\n+    // Handling of the background scan for new devices\n+    private static final boolean BACKGROUND_SCAN_ENABLED = false;\n+    private static final long BACKGROUND_SCAN_REFRESH_MINUTES = 1;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) SmartherAccountHandler bridgeHandler;\n+    private @NonNullByDefault({}) ThingUID bridgeUID;\n+\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public SmartherModuleDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_TIME_SECONDS);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public void activate() {\n+        Map<String, @Nullable Object> properties = new HashMap<>();\n+        properties.put(DiscoveryService.CONFIG_PROPERTY_BACKGROUND_DISCOVERY, Boolean.TRUE);\n+        super.activate(properties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof SmartherAccountHandler) {\n+            bridgeHandler = (SmartherAccountHandler) handler;\n+            bridgeUID = bridgeHandler.getUID();\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    protected synchronized void startBackgroundDiscovery() {\n+        stopBackgroundDiscovery();\n+        if (BACKGROUND_SCAN_ENABLED) {\n+            backgroundFuture = scheduler.scheduleWithFixedDelay(this::startScan, BACKGROUND_SCAN_REFRESH_MINUTES,\n+                    BACKGROUND_SCAN_REFRESH_MINUTES, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    protected synchronized void stopBackgroundDiscovery() {\n+        if (backgroundFuture != null) {\n+            backgroundFuture.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        // If the bridge is not online no other thing devices can be found, so no reason to scan at this moment.\n+        removeOlderResults(getTimestampOfLastScan());\n+        if (bridgeHandler != null && bridgeHandler.isOnline()) {\n+            logger.debug(\"Starting modules discovery for bridge {}\", bridgeUID);\n+            try {\n+                bridgeHandler.listLocations()\n+                        .forEach(l -> bridgeHandler.listModules(l).forEach(m -> thingDiscovered(l, m)));\n+            } catch (RuntimeException e) {", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY0OTEyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429649124", "bodyText": "Specified: SmartherAuthorizationException | SmartherGatewayException", "author": "MrRonfo", "createdAt": "2020-05-24T15:42:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyODc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyODg0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429528840", "bodyText": "Logging the stacktrace (last parameter) needs only be done if a bug in your code has been detected", "author": "fwolter", "createdAt": "2020-05-23T08:57:38Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/discovery/SmartherModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.discovery;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.lang.WordUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.api.model.Location;\n+import org.openhab.binding.smarther.internal.api.model.Module;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherModuleDiscoveryService} queries the Smarther API gateway for available modules.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.smarther\")\n+@NonNullByDefault\n+public class SmartherModuleDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+\n+    // Only modules can be discovered. A bridge must be manually added.\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_MODULE);\n+    // The call to listModules is fast\n+    private static final int DISCOVERY_TIME_SECONDS = 10;\n+    // Handling of the background scan for new devices\n+    private static final boolean BACKGROUND_SCAN_ENABLED = false;\n+    private static final long BACKGROUND_SCAN_REFRESH_MINUTES = 1;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) SmartherAccountHandler bridgeHandler;\n+    private @NonNullByDefault({}) ThingUID bridgeUID;\n+\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public SmartherModuleDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_TIME_SECONDS);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public void activate() {\n+        Map<String, @Nullable Object> properties = new HashMap<>();\n+        properties.put(DiscoveryService.CONFIG_PROPERTY_BACKGROUND_DISCOVERY, Boolean.TRUE);\n+        super.activate(properties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof SmartherAccountHandler) {\n+            bridgeHandler = (SmartherAccountHandler) handler;\n+            bridgeUID = bridgeHandler.getUID();\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    protected synchronized void startBackgroundDiscovery() {\n+        stopBackgroundDiscovery();\n+        if (BACKGROUND_SCAN_ENABLED) {\n+            backgroundFuture = scheduler.scheduleWithFixedDelay(this::startScan, BACKGROUND_SCAN_REFRESH_MINUTES,\n+                    BACKGROUND_SCAN_REFRESH_MINUTES, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    protected synchronized void stopBackgroundDiscovery() {\n+        if (backgroundFuture != null) {\n+            backgroundFuture.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        // If the bridge is not online no other thing devices can be found, so no reason to scan at this moment.\n+        removeOlderResults(getTimestampOfLastScan());\n+        if (bridgeHandler != null && bridgeHandler.isOnline()) {\n+            logger.debug(\"Starting modules discovery for bridge {}\", bridgeUID);\n+            try {\n+                bridgeHandler.listLocations()\n+                        .forEach(l -> bridgeHandler.listModules(l).forEach(m -> thingDiscovered(l, m)));\n+            } catch (RuntimeException e) {\n+                logger.warn(\"Finding modules failed with message: {}\", e.getMessage(), e);", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY0ODcyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429648726", "bodyText": "Of course. Removed.", "author": "MrRonfo", "createdAt": "2020-05-24T15:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyODg0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyOTU3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429529573", "bodyText": "You don't need to validate the config again, if you specify min/max etc. in the XML files.", "author": "fwolter", "createdAt": "2020-05-23T09:08:41Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherBridgeHandler.java", "diffHunk": "@@ -0,0 +1,629 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthFactory;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.account.SmartherNotificationHandler;\n+import org.openhab.binding.smarther.internal.api.SmartherApi;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.model.Location;\n+import org.openhab.binding.smarther.internal.api.model.Module;\n+import org.openhab.binding.smarther.internal.api.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.api.model.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.openhab.binding.smarther.internal.api.model.Plant;\n+import org.openhab.binding.smarther.internal.api.model.Program;\n+import org.openhab.binding.smarther.internal.api.model.Subscription;\n+import org.openhab.binding.smarther.internal.config.SmartherBridgeConfiguration;\n+import org.openhab.binding.smarther.internal.discovery.SmartherModuleDiscoveryService;\n+import org.openhab.binding.smarther.internal.model.BridgeStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherBridgeHandler} is responsible for accessing the BTicino/Legrand Smarther API gateway.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherBridgeHandler extends BaseBridgeHandler\n+        implements SmartherAccountHandler, SmartherNotificationHandler, AccessTokenRefreshListener {\n+\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HttpClient httpClient;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) OAuthClientService oAuthService;\n+    private @NonNullByDefault({}) SmartherApi smartherApi;\n+    private @NonNullByDefault({}) SmartherBridgeConfiguration config;\n+\n+    // Bridge local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Location>> locationCache;\n+    private @NonNullByDefault({}) BridgeStatus bridgeStatus;\n+\n+    public SmartherBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HttpClient httpClient) {\n+        super(bridge);\n+        this.oAuthFactory = oAuthFactory;\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(SmartherModuleDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_ACCESS_TOKEN:\n+                if (command instanceof RefreshType) {\n+                    onAccessTokenResponse(getAccessTokenResponse());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Bridge[{}] Manually triggered channel to refresh the Bridge config\",\n+                                thing.getUID());\n+                        schedulePoll();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Bridge[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Bridge[{}] Initialize handler\", thing.getUID());\n+\n+        config = getConfigAs(SmartherBridgeConfiguration.class);\n+        if (StringUtils.isBlank(config.getSubscriptionKey())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Subscription Key' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getClientId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getClientSecret())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Secret' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getStatusRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Bridge Status Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY0ODYyMA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429648620", "bodyText": "Yep, removed thanks.", "author": "MrRonfo", "createdAt": "2020-05-24T15:36:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyOTU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyOTk1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429529951", "bodyText": "It's bad practice to catch unchecked Exceptions. If you expect a particular error, catch it explicitly with a checked Exception.", "author": "fwolter", "createdAt": "2020-05-23T09:14:40Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherBridgeHandler.java", "diffHunk": "@@ -0,0 +1,629 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthFactory;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.account.SmartherNotificationHandler;\n+import org.openhab.binding.smarther.internal.api.SmartherApi;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.model.Location;\n+import org.openhab.binding.smarther.internal.api.model.Module;\n+import org.openhab.binding.smarther.internal.api.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.api.model.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.openhab.binding.smarther.internal.api.model.Plant;\n+import org.openhab.binding.smarther.internal.api.model.Program;\n+import org.openhab.binding.smarther.internal.api.model.Subscription;\n+import org.openhab.binding.smarther.internal.config.SmartherBridgeConfiguration;\n+import org.openhab.binding.smarther.internal.discovery.SmartherModuleDiscoveryService;\n+import org.openhab.binding.smarther.internal.model.BridgeStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherBridgeHandler} is responsible for accessing the BTicino/Legrand Smarther API gateway.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherBridgeHandler extends BaseBridgeHandler\n+        implements SmartherAccountHandler, SmartherNotificationHandler, AccessTokenRefreshListener {\n+\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HttpClient httpClient;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) OAuthClientService oAuthService;\n+    private @NonNullByDefault({}) SmartherApi smartherApi;\n+    private @NonNullByDefault({}) SmartherBridgeConfiguration config;\n+\n+    // Bridge local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Location>> locationCache;\n+    private @NonNullByDefault({}) BridgeStatus bridgeStatus;\n+\n+    public SmartherBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HttpClient httpClient) {\n+        super(bridge);\n+        this.oAuthFactory = oAuthFactory;\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(SmartherModuleDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_ACCESS_TOKEN:\n+                if (command instanceof RefreshType) {\n+                    onAccessTokenResponse(getAccessTokenResponse());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Bridge[{}] Manually triggered channel to refresh the Bridge config\",\n+                                thing.getUID());\n+                        schedulePoll();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Bridge[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Bridge[{}] Initialize handler\", thing.getUID());\n+\n+        config = getConfigAs(SmartherBridgeConfiguration.class);\n+        if (StringUtils.isBlank(config.getSubscriptionKey())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Subscription Key' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getClientId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getClientSecret())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Secret' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getStatusRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Bridge Status Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Initialize OAuth2 authentication support\n+        oAuthService = oAuthFactory.createOAuthClientService(thing.getUID().getAsString(), SMARTHER_API_TOKEN_URL,\n+                SMARTHER_AUTHORIZE_URL, config.getClientId(), config.getClientSecret(), SMARTHER_API_SCOPES, false);\n+        oAuthService.addAccessTokenRefreshListener(SmartherBridgeHandler.this);\n+        smartherApi = new SmartherApi(config.getSubscriptionKey(), oAuthService, scheduler, httpClient);\n+\n+        // Setup locations (plant Ids) local cache\n+        locationCache = new ExpiringCache<>(Duration.ofMinutes(config.getStatusRefreshPeriod()), this::getLocationList);\n+        bridgeStatus = new BridgeStatus();\n+\n+        schedulePoll();\n+\n+        logger.debug(\"Bridge[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    private void updateNotifications(List<Subscription> subscriptions) {\n+        // Get the notifications list from bridge config\n+        List<String> notifications = config.getNotifications();\n+\n+        for (Subscription s : subscriptions) {\n+            if (s.getEndpointUrl().equalsIgnoreCase(config.getNotificationUrl())\n+                    && !notifications.contains(s.getSubscriptionId())) {\n+                // Add the external subscription to notifications list\n+                notifications = config.addNotification(s.getSubscriptionId());\n+\n+                // Save the updated notifications list back to bridge config\n+                Configuration configuration = editConfiguration();\n+                configuration.put(PROPERTY_NOTIFICATIONS, notifications);\n+                updateConfiguration(configuration);\n+            }\n+        }\n+    }\n+\n+    private List<Location> getLocationList() {\n+        // Retrieve the plants list from the API Gateway\n+        final List<Plant> plants = listPlants();\n+\n+        List<Location> locations;\n+        if (config.isUseNotifications()) {\n+            // Retrieve the subscriptions list from the API Gateway\n+            final List<Subscription> subscriptions = getSubscriptionList();\n+\n+            // Enrich the notifications list with externally registered subscriptions\n+            updateNotifications(subscriptions);\n+\n+            // Get the notifications list from bridge config\n+            final List<String> notifications = config.getNotifications();\n+\n+            locations = plants.stream().map(p -> Location.fromPlant(p, subscriptions.stream()\n+                    .filter(s -> s.getPlantId().equals(p.getId()) && notifications.contains(s.getSubscriptionId()))\n+                    .findFirst())).collect(Collectors.toList());\n+        } else {\n+            locations = plants.stream().map(p -> Location.fromPlant(p)).collect(Collectors.toList());\n+        }\n+        logger.debug(\"Bridge[{}] Available locations: {}\", thing.getUID(), locations);\n+\n+        return locations;\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Bridge[{}] Dispose handler\", thing.getUID());\n+        if (oAuthService != null) {\n+            oAuthService.removeAccessTokenRefreshListener(this);\n+        }\n+        oAuthFactory.ungetOAuthService(thing.getUID().getAsString());\n+        stopPoll(true);\n+        logger.debug(\"Bridge[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    /**\n+     * This method initiates a new thread for polling the available Smarther plants and update the plants\n+     * information.\n+     */\n+    private void schedulePoll() {\n+        stopPoll(false);\n+        // Schedule poll to start after POLL_INITIAL_DELAY sec and run periodically based on status refresh period\n+        pollFuture = scheduler.scheduleWithFixedDelay(this::poll, POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod() * 60, TimeUnit.SECONDS);\n+        logger.debug(\"Bridge[{}] Scheduled poll for {} sec out, then every {} min\", thing.getUID(), POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod());\n+    }\n+\n+    /**\n+     * Cancels all running schedulers.\n+     *\n+     * @param mayInterruptIfRunning true if the thread executing this task should be interrupted; otherwise, in-progress\n+     *            tasks are allowed to complete.\n+     */\n+    private synchronized void stopPoll(boolean mayInterruptIfRunning) {\n+        if (pollFuture != null && !pollFuture.isCancelled()) {\n+            pollFuture.cancel(mayInterruptIfRunning);\n+            pollFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Calls the Smarther API and collects plant data. Returns true if method completed without errors.\n+     *\n+     * @return true if method completed without errors.\n+     */\n+    private synchronized boolean poll() {\n+        try {\n+            onAccessTokenResponse(getAccessTokenResponse());\n+\n+            expireCache();\n+            listLocations();\n+\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (SmartherAuthorizationException e) {\n+            logger.warn(\"Bridge[{}] Authorization error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Bridge[{}] API Gateway error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (RuntimeException e) {", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY0ODUwNg==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429648506", "bodyText": "Poll is the core function. Expected exceptions are catched above, I've added this last to be able to change the Thing status to Offline, to warn the user that something wrong happened so he can report the issue. Removing this catch, do I still get the Thing status to change to Offline and stacktrace to be printed somewhere ?", "author": "MrRonfo", "createdAt": "2020-05-24T15:34:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyOTk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzMTQyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429531424", "bodyText": "Unchecked exception", "author": "fwolter", "createdAt": "2020-05-23T09:38:17Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherBridgeHandler.java", "diffHunk": "@@ -0,0 +1,629 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthFactory;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.account.SmartherNotificationHandler;\n+import org.openhab.binding.smarther.internal.api.SmartherApi;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.model.Location;\n+import org.openhab.binding.smarther.internal.api.model.Module;\n+import org.openhab.binding.smarther.internal.api.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.api.model.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.openhab.binding.smarther.internal.api.model.Plant;\n+import org.openhab.binding.smarther.internal.api.model.Program;\n+import org.openhab.binding.smarther.internal.api.model.Subscription;\n+import org.openhab.binding.smarther.internal.config.SmartherBridgeConfiguration;\n+import org.openhab.binding.smarther.internal.discovery.SmartherModuleDiscoveryService;\n+import org.openhab.binding.smarther.internal.model.BridgeStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherBridgeHandler} is responsible for accessing the BTicino/Legrand Smarther API gateway.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherBridgeHandler extends BaseBridgeHandler\n+        implements SmartherAccountHandler, SmartherNotificationHandler, AccessTokenRefreshListener {\n+\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HttpClient httpClient;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) OAuthClientService oAuthService;\n+    private @NonNullByDefault({}) SmartherApi smartherApi;\n+    private @NonNullByDefault({}) SmartherBridgeConfiguration config;\n+\n+    // Bridge local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Location>> locationCache;\n+    private @NonNullByDefault({}) BridgeStatus bridgeStatus;\n+\n+    public SmartherBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HttpClient httpClient) {\n+        super(bridge);\n+        this.oAuthFactory = oAuthFactory;\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(SmartherModuleDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_ACCESS_TOKEN:\n+                if (command instanceof RefreshType) {\n+                    onAccessTokenResponse(getAccessTokenResponse());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Bridge[{}] Manually triggered channel to refresh the Bridge config\",\n+                                thing.getUID());\n+                        schedulePoll();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Bridge[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Bridge[{}] Initialize handler\", thing.getUID());\n+\n+        config = getConfigAs(SmartherBridgeConfiguration.class);\n+        if (StringUtils.isBlank(config.getSubscriptionKey())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Subscription Key' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getClientId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getClientSecret())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Secret' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getStatusRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Bridge Status Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Initialize OAuth2 authentication support\n+        oAuthService = oAuthFactory.createOAuthClientService(thing.getUID().getAsString(), SMARTHER_API_TOKEN_URL,\n+                SMARTHER_AUTHORIZE_URL, config.getClientId(), config.getClientSecret(), SMARTHER_API_SCOPES, false);\n+        oAuthService.addAccessTokenRefreshListener(SmartherBridgeHandler.this);\n+        smartherApi = new SmartherApi(config.getSubscriptionKey(), oAuthService, scheduler, httpClient);\n+\n+        // Setup locations (plant Ids) local cache\n+        locationCache = new ExpiringCache<>(Duration.ofMinutes(config.getStatusRefreshPeriod()), this::getLocationList);\n+        bridgeStatus = new BridgeStatus();\n+\n+        schedulePoll();\n+\n+        logger.debug(\"Bridge[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    private void updateNotifications(List<Subscription> subscriptions) {\n+        // Get the notifications list from bridge config\n+        List<String> notifications = config.getNotifications();\n+\n+        for (Subscription s : subscriptions) {\n+            if (s.getEndpointUrl().equalsIgnoreCase(config.getNotificationUrl())\n+                    && !notifications.contains(s.getSubscriptionId())) {\n+                // Add the external subscription to notifications list\n+                notifications = config.addNotification(s.getSubscriptionId());\n+\n+                // Save the updated notifications list back to bridge config\n+                Configuration configuration = editConfiguration();\n+                configuration.put(PROPERTY_NOTIFICATIONS, notifications);\n+                updateConfiguration(configuration);\n+            }\n+        }\n+    }\n+\n+    private List<Location> getLocationList() {\n+        // Retrieve the plants list from the API Gateway\n+        final List<Plant> plants = listPlants();\n+\n+        List<Location> locations;\n+        if (config.isUseNotifications()) {\n+            // Retrieve the subscriptions list from the API Gateway\n+            final List<Subscription> subscriptions = getSubscriptionList();\n+\n+            // Enrich the notifications list with externally registered subscriptions\n+            updateNotifications(subscriptions);\n+\n+            // Get the notifications list from bridge config\n+            final List<String> notifications = config.getNotifications();\n+\n+            locations = plants.stream().map(p -> Location.fromPlant(p, subscriptions.stream()\n+                    .filter(s -> s.getPlantId().equals(p.getId()) && notifications.contains(s.getSubscriptionId()))\n+                    .findFirst())).collect(Collectors.toList());\n+        } else {\n+            locations = plants.stream().map(p -> Location.fromPlant(p)).collect(Collectors.toList());\n+        }\n+        logger.debug(\"Bridge[{}] Available locations: {}\", thing.getUID(), locations);\n+\n+        return locations;\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Bridge[{}] Dispose handler\", thing.getUID());\n+        if (oAuthService != null) {\n+            oAuthService.removeAccessTokenRefreshListener(this);\n+        }\n+        oAuthFactory.ungetOAuthService(thing.getUID().getAsString());\n+        stopPoll(true);\n+        logger.debug(\"Bridge[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    /**\n+     * This method initiates a new thread for polling the available Smarther plants and update the plants\n+     * information.\n+     */\n+    private void schedulePoll() {\n+        stopPoll(false);\n+        // Schedule poll to start after POLL_INITIAL_DELAY sec and run periodically based on status refresh period\n+        pollFuture = scheduler.scheduleWithFixedDelay(this::poll, POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod() * 60, TimeUnit.SECONDS);\n+        logger.debug(\"Bridge[{}] Scheduled poll for {} sec out, then every {} min\", thing.getUID(), POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod());\n+    }\n+\n+    /**\n+     * Cancels all running schedulers.\n+     *\n+     * @param mayInterruptIfRunning true if the thread executing this task should be interrupted; otherwise, in-progress\n+     *            tasks are allowed to complete.\n+     */\n+    private synchronized void stopPoll(boolean mayInterruptIfRunning) {\n+        if (pollFuture != null && !pollFuture.isCancelled()) {\n+            pollFuture.cancel(mayInterruptIfRunning);\n+            pollFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Calls the Smarther API and collects plant data. Returns true if method completed without errors.\n+     *\n+     * @return true if method completed without errors.\n+     */\n+    private synchronized boolean poll() {\n+        try {\n+            onAccessTokenResponse(getAccessTokenResponse());\n+\n+            expireCache();\n+            listLocations();\n+\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (SmartherAuthorizationException e) {\n+            logger.warn(\"Bridge[{}] Authorization error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Bridge[{}] API Gateway error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (RuntimeException e) {\n+            // All other exceptions apart from Authorization and Gateway issues\n+            logger.warn(\"Bridge[{}] Unexpected error during polling, please report if this keeps occurring: \",\n+                    thing.getUID(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        }\n+    }\n+\n+    private void expireCache() {\n+        logger.debug(\"Bridge[{}] Invalidating location cache\", thing.getUID());\n+        locationCache.invalidateValue();\n+    }\n+\n+    public SmartherBridgeConfiguration getSmartherBridgeConfig() {\n+        return config;\n+    }\n+\n+    private @Nullable AccessTokenResponse getAccessTokenResponse() {\n+        try {\n+            return (oAuthService == null) ? null : oAuthService.getAccessTokenResponse();\n+        } catch (OAuthException | IOException | OAuthResponseException | RuntimeException e) {\n+            throw new SmartherAuthorizationException(e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void onAccessTokenResponse(@Nullable AccessTokenResponse tokenResponse) {\n+        updateChannelState(CHANNEL_ACCESS_TOKEN,\n+                new StringType((tokenResponse == null) ? null : tokenResponse.getAccessToken()));\n+    }\n+\n+    /**\n+     * Convenience method to update the channel state but only if the channel is linked.\n+     *\n+     * @param channelId id of the channel to update\n+     * @param state State to set on the channel\n+     */\n+    private void updateChannelState(String channelId, State state) {\n+        final Channel channel = thing.getChannel(channelId);\n+\n+        if (channel != null && isLinked(channel.getUID())) {\n+            updateState(channel.getUID(), state);\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to update the api calls counter of local bridge status.\n+     */\n+    private void updateApiCallsCounter() {\n+        updateChannelState(CHANNEL_API_CALLS_HANDLED, new DecimalType(bridgeStatus.incrementApiCallsHandled()));\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Implementation of SmartherAccountHandler interface\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public ThingUID getUID() {\n+        return thing.getUID();\n+    }\n+\n+    @Override\n+    public String getLabel() {\n+        return StringUtils.defaultString(thing.getLabel());\n+    }\n+\n+    @Override\n+    public List<Location> listLocations() {\n+        final List<Location> locations = locationCache.getValue();\n+        return (locations == null) ? Collections.emptyList() : locations;\n+    }\n+\n+    @Override\n+    public boolean hasLocation(String plantId) {\n+        final List<Location> locations = locationCache.getValue();\n+        return (locations == null) ? false : locations.stream().anyMatch(l -> l.getPlantId().equals(plantId));\n+    }\n+\n+    @Override\n+    public List<Plant> listPlants() {\n+        updateApiCallsCounter();\n+        return smartherApi.getPlantList();\n+    }\n+\n+    @Override\n+    public List<Subscription> getSubscriptionList() {\n+        updateApiCallsCounter();\n+        return smartherApi.getSubscriptionList();\n+    }\n+\n+    @Override\n+    public String addSubscription(String plantId, String notificationUrl) {\n+        updateApiCallsCounter();\n+        return smartherApi.subscribe(plantId, notificationUrl);\n+    }\n+\n+    @Override\n+    public void removeSubscription(String plantId, String subscriptionId) {\n+        updateApiCallsCounter();\n+        smartherApi.unsubscribe(plantId, subscriptionId);\n+    }\n+\n+    @Override\n+    public List<Module> listModules(Location location) {\n+        updateApiCallsCounter();\n+        return smartherApi.getTopology(location.getPlantId());\n+    }\n+\n+    @Override\n+    public ModuleStatus getModuleStatus(String plantId, String moduleId) {\n+        updateApiCallsCounter();\n+        return smartherApi.getModuleStatus(plantId, moduleId);\n+    }\n+\n+    @Override\n+    public boolean setModuleStatus(ModuleSettings moduleSettings) {\n+        updateApiCallsCounter();\n+        return smartherApi.setModuleStatus(moduleSettings);\n+    }\n+\n+    @Override\n+    public List<Program> getModuleProgramList(String plantId, String moduleId) {\n+        updateApiCallsCounter();\n+        return smartherApi.getProgramList(plantId, moduleId);\n+    }\n+\n+    @Override\n+    public boolean isAuthorized() {\n+        try {\n+            final AccessTokenResponse accessTokenResponse = getAccessTokenResponse();\n+\n+            return (accessTokenResponse != null && accessTokenResponse.getAccessToken() != null\n+                    && accessTokenResponse.getRefreshToken() != null);\n+        } catch (SmartherAuthorizationException e) {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOnline() {\n+        return (thing.getStatus() == ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public String authorize(String redirectUrl, String reqCode, String notificationUrl) {\n+        try {\n+            logger.debug(\"Bridge[{}] Call API gateway to get access token. RedirectUri: {}\", thing.getUID(),\n+                    redirectUrl);\n+\n+            // OAuth2 call to get access token from received authorization code\n+            oAuthService.getAccessTokenResponseByAuthorizationCode(reqCode, redirectUrl);\n+\n+            // Store the notification URL in bridge configuration\n+            Configuration configuration = editConfiguration();\n+            configuration.put(PROPERTY_NOTIFICATION_URL, notificationUrl);\n+            updateConfiguration(configuration);\n+            config.setNotificationUrl(notificationUrl);\n+            logger.debug(\"Bridge[{}] Store notification URL: {}\", thing.getUID(), notificationUrl);\n+\n+            // Reschedule the polling thread\n+            schedulePoll();\n+\n+            return config.getClientId();\n+        } catch (RuntimeException | OAuthException | IOException e) {", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY0ODEyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429648121", "bodyText": "Removed, thanks.", "author": "MrRonfo", "createdAt": "2020-05-24T15:30:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzMTQyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzMTQ2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429531465", "bodyText": "Logging stacktrace", "author": "fwolter", "createdAt": "2020-05-23T09:39:09Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherBridgeHandler.java", "diffHunk": "@@ -0,0 +1,629 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthFactory;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.account.SmartherNotificationHandler;\n+import org.openhab.binding.smarther.internal.api.SmartherApi;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.model.Location;\n+import org.openhab.binding.smarther.internal.api.model.Module;\n+import org.openhab.binding.smarther.internal.api.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.api.model.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.openhab.binding.smarther.internal.api.model.Plant;\n+import org.openhab.binding.smarther.internal.api.model.Program;\n+import org.openhab.binding.smarther.internal.api.model.Subscription;\n+import org.openhab.binding.smarther.internal.config.SmartherBridgeConfiguration;\n+import org.openhab.binding.smarther.internal.discovery.SmartherModuleDiscoveryService;\n+import org.openhab.binding.smarther.internal.model.BridgeStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherBridgeHandler} is responsible for accessing the BTicino/Legrand Smarther API gateway.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherBridgeHandler extends BaseBridgeHandler\n+        implements SmartherAccountHandler, SmartherNotificationHandler, AccessTokenRefreshListener {\n+\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HttpClient httpClient;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) OAuthClientService oAuthService;\n+    private @NonNullByDefault({}) SmartherApi smartherApi;\n+    private @NonNullByDefault({}) SmartherBridgeConfiguration config;\n+\n+    // Bridge local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Location>> locationCache;\n+    private @NonNullByDefault({}) BridgeStatus bridgeStatus;\n+\n+    public SmartherBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HttpClient httpClient) {\n+        super(bridge);\n+        this.oAuthFactory = oAuthFactory;\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(SmartherModuleDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_ACCESS_TOKEN:\n+                if (command instanceof RefreshType) {\n+                    onAccessTokenResponse(getAccessTokenResponse());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Bridge[{}] Manually triggered channel to refresh the Bridge config\",\n+                                thing.getUID());\n+                        schedulePoll();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Bridge[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Bridge[{}] Initialize handler\", thing.getUID());\n+\n+        config = getConfigAs(SmartherBridgeConfiguration.class);\n+        if (StringUtils.isBlank(config.getSubscriptionKey())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Subscription Key' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getClientId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getClientSecret())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Secret' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getStatusRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Bridge Status Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Initialize OAuth2 authentication support\n+        oAuthService = oAuthFactory.createOAuthClientService(thing.getUID().getAsString(), SMARTHER_API_TOKEN_URL,\n+                SMARTHER_AUTHORIZE_URL, config.getClientId(), config.getClientSecret(), SMARTHER_API_SCOPES, false);\n+        oAuthService.addAccessTokenRefreshListener(SmartherBridgeHandler.this);\n+        smartherApi = new SmartherApi(config.getSubscriptionKey(), oAuthService, scheduler, httpClient);\n+\n+        // Setup locations (plant Ids) local cache\n+        locationCache = new ExpiringCache<>(Duration.ofMinutes(config.getStatusRefreshPeriod()), this::getLocationList);\n+        bridgeStatus = new BridgeStatus();\n+\n+        schedulePoll();\n+\n+        logger.debug(\"Bridge[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    private void updateNotifications(List<Subscription> subscriptions) {\n+        // Get the notifications list from bridge config\n+        List<String> notifications = config.getNotifications();\n+\n+        for (Subscription s : subscriptions) {\n+            if (s.getEndpointUrl().equalsIgnoreCase(config.getNotificationUrl())\n+                    && !notifications.contains(s.getSubscriptionId())) {\n+                // Add the external subscription to notifications list\n+                notifications = config.addNotification(s.getSubscriptionId());\n+\n+                // Save the updated notifications list back to bridge config\n+                Configuration configuration = editConfiguration();\n+                configuration.put(PROPERTY_NOTIFICATIONS, notifications);\n+                updateConfiguration(configuration);\n+            }\n+        }\n+    }\n+\n+    private List<Location> getLocationList() {\n+        // Retrieve the plants list from the API Gateway\n+        final List<Plant> plants = listPlants();\n+\n+        List<Location> locations;\n+        if (config.isUseNotifications()) {\n+            // Retrieve the subscriptions list from the API Gateway\n+            final List<Subscription> subscriptions = getSubscriptionList();\n+\n+            // Enrich the notifications list with externally registered subscriptions\n+            updateNotifications(subscriptions);\n+\n+            // Get the notifications list from bridge config\n+            final List<String> notifications = config.getNotifications();\n+\n+            locations = plants.stream().map(p -> Location.fromPlant(p, subscriptions.stream()\n+                    .filter(s -> s.getPlantId().equals(p.getId()) && notifications.contains(s.getSubscriptionId()))\n+                    .findFirst())).collect(Collectors.toList());\n+        } else {\n+            locations = plants.stream().map(p -> Location.fromPlant(p)).collect(Collectors.toList());\n+        }\n+        logger.debug(\"Bridge[{}] Available locations: {}\", thing.getUID(), locations);\n+\n+        return locations;\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Bridge[{}] Dispose handler\", thing.getUID());\n+        if (oAuthService != null) {\n+            oAuthService.removeAccessTokenRefreshListener(this);\n+        }\n+        oAuthFactory.ungetOAuthService(thing.getUID().getAsString());\n+        stopPoll(true);\n+        logger.debug(\"Bridge[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    /**\n+     * This method initiates a new thread for polling the available Smarther plants and update the plants\n+     * information.\n+     */\n+    private void schedulePoll() {\n+        stopPoll(false);\n+        // Schedule poll to start after POLL_INITIAL_DELAY sec and run periodically based on status refresh period\n+        pollFuture = scheduler.scheduleWithFixedDelay(this::poll, POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod() * 60, TimeUnit.SECONDS);\n+        logger.debug(\"Bridge[{}] Scheduled poll for {} sec out, then every {} min\", thing.getUID(), POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod());\n+    }\n+\n+    /**\n+     * Cancels all running schedulers.\n+     *\n+     * @param mayInterruptIfRunning true if the thread executing this task should be interrupted; otherwise, in-progress\n+     *            tasks are allowed to complete.\n+     */\n+    private synchronized void stopPoll(boolean mayInterruptIfRunning) {\n+        if (pollFuture != null && !pollFuture.isCancelled()) {\n+            pollFuture.cancel(mayInterruptIfRunning);\n+            pollFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Calls the Smarther API and collects plant data. Returns true if method completed without errors.\n+     *\n+     * @return true if method completed without errors.\n+     */\n+    private synchronized boolean poll() {\n+        try {\n+            onAccessTokenResponse(getAccessTokenResponse());\n+\n+            expireCache();\n+            listLocations();\n+\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (SmartherAuthorizationException e) {\n+            logger.warn(\"Bridge[{}] Authorization error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Bridge[{}] API Gateway error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (RuntimeException e) {\n+            // All other exceptions apart from Authorization and Gateway issues\n+            logger.warn(\"Bridge[{}] Unexpected error during polling, please report if this keeps occurring: \",\n+                    thing.getUID(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        }\n+    }\n+\n+    private void expireCache() {\n+        logger.debug(\"Bridge[{}] Invalidating location cache\", thing.getUID());\n+        locationCache.invalidateValue();\n+    }\n+\n+    public SmartherBridgeConfiguration getSmartherBridgeConfig() {\n+        return config;\n+    }\n+\n+    private @Nullable AccessTokenResponse getAccessTokenResponse() {\n+        try {\n+            return (oAuthService == null) ? null : oAuthService.getAccessTokenResponse();\n+        } catch (OAuthException | IOException | OAuthResponseException | RuntimeException e) {\n+            throw new SmartherAuthorizationException(e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void onAccessTokenResponse(@Nullable AccessTokenResponse tokenResponse) {\n+        updateChannelState(CHANNEL_ACCESS_TOKEN,\n+                new StringType((tokenResponse == null) ? null : tokenResponse.getAccessToken()));\n+    }\n+\n+    /**\n+     * Convenience method to update the channel state but only if the channel is linked.\n+     *\n+     * @param channelId id of the channel to update\n+     * @param state State to set on the channel\n+     */\n+    private void updateChannelState(String channelId, State state) {\n+        final Channel channel = thing.getChannel(channelId);\n+\n+        if (channel != null && isLinked(channel.getUID())) {\n+            updateState(channel.getUID(), state);\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to update the api calls counter of local bridge status.\n+     */\n+    private void updateApiCallsCounter() {\n+        updateChannelState(CHANNEL_API_CALLS_HANDLED, new DecimalType(bridgeStatus.incrementApiCallsHandled()));\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Implementation of SmartherAccountHandler interface\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public ThingUID getUID() {\n+        return thing.getUID();\n+    }\n+\n+    @Override\n+    public String getLabel() {\n+        return StringUtils.defaultString(thing.getLabel());\n+    }\n+\n+    @Override\n+    public List<Location> listLocations() {\n+        final List<Location> locations = locationCache.getValue();\n+        return (locations == null) ? Collections.emptyList() : locations;\n+    }\n+\n+    @Override\n+    public boolean hasLocation(String plantId) {\n+        final List<Location> locations = locationCache.getValue();\n+        return (locations == null) ? false : locations.stream().anyMatch(l -> l.getPlantId().equals(plantId));\n+    }\n+\n+    @Override\n+    public List<Plant> listPlants() {\n+        updateApiCallsCounter();\n+        return smartherApi.getPlantList();\n+    }\n+\n+    @Override\n+    public List<Subscription> getSubscriptionList() {\n+        updateApiCallsCounter();\n+        return smartherApi.getSubscriptionList();\n+    }\n+\n+    @Override\n+    public String addSubscription(String plantId, String notificationUrl) {\n+        updateApiCallsCounter();\n+        return smartherApi.subscribe(plantId, notificationUrl);\n+    }\n+\n+    @Override\n+    public void removeSubscription(String plantId, String subscriptionId) {\n+        updateApiCallsCounter();\n+        smartherApi.unsubscribe(plantId, subscriptionId);\n+    }\n+\n+    @Override\n+    public List<Module> listModules(Location location) {\n+        updateApiCallsCounter();\n+        return smartherApi.getTopology(location.getPlantId());\n+    }\n+\n+    @Override\n+    public ModuleStatus getModuleStatus(String plantId, String moduleId) {\n+        updateApiCallsCounter();\n+        return smartherApi.getModuleStatus(plantId, moduleId);\n+    }\n+\n+    @Override\n+    public boolean setModuleStatus(ModuleSettings moduleSettings) {\n+        updateApiCallsCounter();\n+        return smartherApi.setModuleStatus(moduleSettings);\n+    }\n+\n+    @Override\n+    public List<Program> getModuleProgramList(String plantId, String moduleId) {\n+        updateApiCallsCounter();\n+        return smartherApi.getProgramList(plantId, moduleId);\n+    }\n+\n+    @Override\n+    public boolean isAuthorized() {\n+        try {\n+            final AccessTokenResponse accessTokenResponse = getAccessTokenResponse();\n+\n+            return (accessTokenResponse != null && accessTokenResponse.getAccessToken() != null\n+                    && accessTokenResponse.getRefreshToken() != null);\n+        } catch (SmartherAuthorizationException e) {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOnline() {\n+        return (thing.getStatus() == ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public String authorize(String redirectUrl, String reqCode, String notificationUrl) {\n+        try {\n+            logger.debug(\"Bridge[{}] Call API gateway to get access token. RedirectUri: {}\", thing.getUID(),\n+                    redirectUrl);\n+\n+            // OAuth2 call to get access token from received authorization code\n+            oAuthService.getAccessTokenResponseByAuthorizationCode(reqCode, redirectUrl);\n+\n+            // Store the notification URL in bridge configuration\n+            Configuration configuration = editConfiguration();\n+            configuration.put(PROPERTY_NOTIFICATION_URL, notificationUrl);\n+            updateConfiguration(configuration);\n+            config.setNotificationUrl(notificationUrl);\n+            logger.debug(\"Bridge[{}] Store notification URL: {}\", thing.getUID(), notificationUrl);\n+\n+            // Reschedule the polling thread\n+            schedulePoll();\n+\n+            return config.getClientId();\n+        } catch (RuntimeException | OAuthException | IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            throw new SmartherGatewayException(e.getMessage(), e);\n+        } catch (OAuthResponseException e) {\n+            throw new SmartherAuthorizationException(e.toString(), e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean equalsThingUID(String thingUID) {\n+        return thing.getUID().getAsString().equals(thingUID);\n+    }\n+\n+    @Override\n+    public String formatAuthorizationUrl(String redirectUri) {\n+        try {\n+            return oAuthService.getAuthorizationUrl(redirectUri, null, thing.getUID().getAsString());\n+        } catch (OAuthException e) {\n+            logger.warn(\"Bridge[{}] Error constructing AuthorizationUrl: \", thing.getUID(), e);", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY0ODAyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429648023", "bodyText": "D-oh! Removed, thanks,", "author": "MrRonfo", "createdAt": "2020-05-24T15:29:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzMTQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzMTczMg==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429531732", "bodyText": "Minor improvement:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (config.isUseNotifications() && maybeModuleHandler.isPresent()) {\n          \n          \n            \n                        maybeModuleHandler.get().handleNotification(notification);\n          \n          \n            \n                    if (config.isUseNotifications()) {\n          \n          \n            \n                        maybeModuleHandler.ifPresent(h -> h.handleNotification(notification));", "author": "fwolter", "createdAt": "2020-05-23T09:43:43Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherBridgeHandler.java", "diffHunk": "@@ -0,0 +1,629 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthFactory;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.account.SmartherNotificationHandler;\n+import org.openhab.binding.smarther.internal.api.SmartherApi;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.model.Location;\n+import org.openhab.binding.smarther.internal.api.model.Module;\n+import org.openhab.binding.smarther.internal.api.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.api.model.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.openhab.binding.smarther.internal.api.model.Plant;\n+import org.openhab.binding.smarther.internal.api.model.Program;\n+import org.openhab.binding.smarther.internal.api.model.Subscription;\n+import org.openhab.binding.smarther.internal.config.SmartherBridgeConfiguration;\n+import org.openhab.binding.smarther.internal.discovery.SmartherModuleDiscoveryService;\n+import org.openhab.binding.smarther.internal.model.BridgeStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherBridgeHandler} is responsible for accessing the BTicino/Legrand Smarther API gateway.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherBridgeHandler extends BaseBridgeHandler\n+        implements SmartherAccountHandler, SmartherNotificationHandler, AccessTokenRefreshListener {\n+\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HttpClient httpClient;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) OAuthClientService oAuthService;\n+    private @NonNullByDefault({}) SmartherApi smartherApi;\n+    private @NonNullByDefault({}) SmartherBridgeConfiguration config;\n+\n+    // Bridge local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Location>> locationCache;\n+    private @NonNullByDefault({}) BridgeStatus bridgeStatus;\n+\n+    public SmartherBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HttpClient httpClient) {\n+        super(bridge);\n+        this.oAuthFactory = oAuthFactory;\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(SmartherModuleDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_ACCESS_TOKEN:\n+                if (command instanceof RefreshType) {\n+                    onAccessTokenResponse(getAccessTokenResponse());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Bridge[{}] Manually triggered channel to refresh the Bridge config\",\n+                                thing.getUID());\n+                        schedulePoll();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Bridge[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Bridge[{}] Initialize handler\", thing.getUID());\n+\n+        config = getConfigAs(SmartherBridgeConfiguration.class);\n+        if (StringUtils.isBlank(config.getSubscriptionKey())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Subscription Key' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getClientId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getClientSecret())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Secret' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getStatusRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Bridge Status Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Initialize OAuth2 authentication support\n+        oAuthService = oAuthFactory.createOAuthClientService(thing.getUID().getAsString(), SMARTHER_API_TOKEN_URL,\n+                SMARTHER_AUTHORIZE_URL, config.getClientId(), config.getClientSecret(), SMARTHER_API_SCOPES, false);\n+        oAuthService.addAccessTokenRefreshListener(SmartherBridgeHandler.this);\n+        smartherApi = new SmartherApi(config.getSubscriptionKey(), oAuthService, scheduler, httpClient);\n+\n+        // Setup locations (plant Ids) local cache\n+        locationCache = new ExpiringCache<>(Duration.ofMinutes(config.getStatusRefreshPeriod()), this::getLocationList);\n+        bridgeStatus = new BridgeStatus();\n+\n+        schedulePoll();\n+\n+        logger.debug(\"Bridge[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    private void updateNotifications(List<Subscription> subscriptions) {\n+        // Get the notifications list from bridge config\n+        List<String> notifications = config.getNotifications();\n+\n+        for (Subscription s : subscriptions) {\n+            if (s.getEndpointUrl().equalsIgnoreCase(config.getNotificationUrl())\n+                    && !notifications.contains(s.getSubscriptionId())) {\n+                // Add the external subscription to notifications list\n+                notifications = config.addNotification(s.getSubscriptionId());\n+\n+                // Save the updated notifications list back to bridge config\n+                Configuration configuration = editConfiguration();\n+                configuration.put(PROPERTY_NOTIFICATIONS, notifications);\n+                updateConfiguration(configuration);\n+            }\n+        }\n+    }\n+\n+    private List<Location> getLocationList() {\n+        // Retrieve the plants list from the API Gateway\n+        final List<Plant> plants = listPlants();\n+\n+        List<Location> locations;\n+        if (config.isUseNotifications()) {\n+            // Retrieve the subscriptions list from the API Gateway\n+            final List<Subscription> subscriptions = getSubscriptionList();\n+\n+            // Enrich the notifications list with externally registered subscriptions\n+            updateNotifications(subscriptions);\n+\n+            // Get the notifications list from bridge config\n+            final List<String> notifications = config.getNotifications();\n+\n+            locations = plants.stream().map(p -> Location.fromPlant(p, subscriptions.stream()\n+                    .filter(s -> s.getPlantId().equals(p.getId()) && notifications.contains(s.getSubscriptionId()))\n+                    .findFirst())).collect(Collectors.toList());\n+        } else {\n+            locations = plants.stream().map(p -> Location.fromPlant(p)).collect(Collectors.toList());\n+        }\n+        logger.debug(\"Bridge[{}] Available locations: {}\", thing.getUID(), locations);\n+\n+        return locations;\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Bridge[{}] Dispose handler\", thing.getUID());\n+        if (oAuthService != null) {\n+            oAuthService.removeAccessTokenRefreshListener(this);\n+        }\n+        oAuthFactory.ungetOAuthService(thing.getUID().getAsString());\n+        stopPoll(true);\n+        logger.debug(\"Bridge[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    /**\n+     * This method initiates a new thread for polling the available Smarther plants and update the plants\n+     * information.\n+     */\n+    private void schedulePoll() {\n+        stopPoll(false);\n+        // Schedule poll to start after POLL_INITIAL_DELAY sec and run periodically based on status refresh period\n+        pollFuture = scheduler.scheduleWithFixedDelay(this::poll, POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod() * 60, TimeUnit.SECONDS);\n+        logger.debug(\"Bridge[{}] Scheduled poll for {} sec out, then every {} min\", thing.getUID(), POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod());\n+    }\n+\n+    /**\n+     * Cancels all running schedulers.\n+     *\n+     * @param mayInterruptIfRunning true if the thread executing this task should be interrupted; otherwise, in-progress\n+     *            tasks are allowed to complete.\n+     */\n+    private synchronized void stopPoll(boolean mayInterruptIfRunning) {\n+        if (pollFuture != null && !pollFuture.isCancelled()) {\n+            pollFuture.cancel(mayInterruptIfRunning);\n+            pollFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Calls the Smarther API and collects plant data. Returns true if method completed without errors.\n+     *\n+     * @return true if method completed without errors.\n+     */\n+    private synchronized boolean poll() {\n+        try {\n+            onAccessTokenResponse(getAccessTokenResponse());\n+\n+            expireCache();\n+            listLocations();\n+\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (SmartherAuthorizationException e) {\n+            logger.warn(\"Bridge[{}] Authorization error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Bridge[{}] API Gateway error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (RuntimeException e) {\n+            // All other exceptions apart from Authorization and Gateway issues\n+            logger.warn(\"Bridge[{}] Unexpected error during polling, please report if this keeps occurring: \",\n+                    thing.getUID(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        }\n+    }\n+\n+    private void expireCache() {\n+        logger.debug(\"Bridge[{}] Invalidating location cache\", thing.getUID());\n+        locationCache.invalidateValue();\n+    }\n+\n+    public SmartherBridgeConfiguration getSmartherBridgeConfig() {\n+        return config;\n+    }\n+\n+    private @Nullable AccessTokenResponse getAccessTokenResponse() {\n+        try {\n+            return (oAuthService == null) ? null : oAuthService.getAccessTokenResponse();\n+        } catch (OAuthException | IOException | OAuthResponseException | RuntimeException e) {\n+            throw new SmartherAuthorizationException(e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void onAccessTokenResponse(@Nullable AccessTokenResponse tokenResponse) {\n+        updateChannelState(CHANNEL_ACCESS_TOKEN,\n+                new StringType((tokenResponse == null) ? null : tokenResponse.getAccessToken()));\n+    }\n+\n+    /**\n+     * Convenience method to update the channel state but only if the channel is linked.\n+     *\n+     * @param channelId id of the channel to update\n+     * @param state State to set on the channel\n+     */\n+    private void updateChannelState(String channelId, State state) {\n+        final Channel channel = thing.getChannel(channelId);\n+\n+        if (channel != null && isLinked(channel.getUID())) {\n+            updateState(channel.getUID(), state);\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to update the api calls counter of local bridge status.\n+     */\n+    private void updateApiCallsCounter() {\n+        updateChannelState(CHANNEL_API_CALLS_HANDLED, new DecimalType(bridgeStatus.incrementApiCallsHandled()));\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Implementation of SmartherAccountHandler interface\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public ThingUID getUID() {\n+        return thing.getUID();\n+    }\n+\n+    @Override\n+    public String getLabel() {\n+        return StringUtils.defaultString(thing.getLabel());\n+    }\n+\n+    @Override\n+    public List<Location> listLocations() {\n+        final List<Location> locations = locationCache.getValue();\n+        return (locations == null) ? Collections.emptyList() : locations;\n+    }\n+\n+    @Override\n+    public boolean hasLocation(String plantId) {\n+        final List<Location> locations = locationCache.getValue();\n+        return (locations == null) ? false : locations.stream().anyMatch(l -> l.getPlantId().equals(plantId));\n+    }\n+\n+    @Override\n+    public List<Plant> listPlants() {\n+        updateApiCallsCounter();\n+        return smartherApi.getPlantList();\n+    }\n+\n+    @Override\n+    public List<Subscription> getSubscriptionList() {\n+        updateApiCallsCounter();\n+        return smartherApi.getSubscriptionList();\n+    }\n+\n+    @Override\n+    public String addSubscription(String plantId, String notificationUrl) {\n+        updateApiCallsCounter();\n+        return smartherApi.subscribe(plantId, notificationUrl);\n+    }\n+\n+    @Override\n+    public void removeSubscription(String plantId, String subscriptionId) {\n+        updateApiCallsCounter();\n+        smartherApi.unsubscribe(plantId, subscriptionId);\n+    }\n+\n+    @Override\n+    public List<Module> listModules(Location location) {\n+        updateApiCallsCounter();\n+        return smartherApi.getTopology(location.getPlantId());\n+    }\n+\n+    @Override\n+    public ModuleStatus getModuleStatus(String plantId, String moduleId) {\n+        updateApiCallsCounter();\n+        return smartherApi.getModuleStatus(plantId, moduleId);\n+    }\n+\n+    @Override\n+    public boolean setModuleStatus(ModuleSettings moduleSettings) {\n+        updateApiCallsCounter();\n+        return smartherApi.setModuleStatus(moduleSettings);\n+    }\n+\n+    @Override\n+    public List<Program> getModuleProgramList(String plantId, String moduleId) {\n+        updateApiCallsCounter();\n+        return smartherApi.getProgramList(plantId, moduleId);\n+    }\n+\n+    @Override\n+    public boolean isAuthorized() {\n+        try {\n+            final AccessTokenResponse accessTokenResponse = getAccessTokenResponse();\n+\n+            return (accessTokenResponse != null && accessTokenResponse.getAccessToken() != null\n+                    && accessTokenResponse.getRefreshToken() != null);\n+        } catch (SmartherAuthorizationException e) {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOnline() {\n+        return (thing.getStatus() == ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public String authorize(String redirectUrl, String reqCode, String notificationUrl) {\n+        try {\n+            logger.debug(\"Bridge[{}] Call API gateway to get access token. RedirectUri: {}\", thing.getUID(),\n+                    redirectUrl);\n+\n+            // OAuth2 call to get access token from received authorization code\n+            oAuthService.getAccessTokenResponseByAuthorizationCode(reqCode, redirectUrl);\n+\n+            // Store the notification URL in bridge configuration\n+            Configuration configuration = editConfiguration();\n+            configuration.put(PROPERTY_NOTIFICATION_URL, notificationUrl);\n+            updateConfiguration(configuration);\n+            config.setNotificationUrl(notificationUrl);\n+            logger.debug(\"Bridge[{}] Store notification URL: {}\", thing.getUID(), notificationUrl);\n+\n+            // Reschedule the polling thread\n+            schedulePoll();\n+\n+            return config.getClientId();\n+        } catch (RuntimeException | OAuthException | IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            throw new SmartherGatewayException(e.getMessage(), e);\n+        } catch (OAuthResponseException e) {\n+            throw new SmartherAuthorizationException(e.toString(), e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean equalsThingUID(String thingUID) {\n+        return thing.getUID().getAsString().equals(thingUID);\n+    }\n+\n+    @Override\n+    public String formatAuthorizationUrl(String redirectUri) {\n+        try {\n+            return oAuthService.getAuthorizationUrl(redirectUri, null, thing.getUID().getAsString());\n+        } catch (OAuthException e) {\n+            logger.warn(\"Bridge[{}] Error constructing AuthorizationUrl: \", thing.getUID(), e);\n+            return \"\";\n+        }\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Implementation of SmartherNotificationHandler interface\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public boolean useNotifications() {\n+        return config.isUseNotifications();\n+    }\n+\n+    @Override\n+    public synchronized void registerNotification(String plantId) {\n+        if (!config.isUseNotifications()) {\n+            return;\n+        }\n+\n+        List<Location> locations = locationCache.getValue();\n+        if (locations != null) {\n+            final Optional<Location> maybeLocation = locations.stream().filter(l -> l.getPlantId().equals(plantId))\n+                    .findFirst();\n+            if (maybeLocation.isPresent()) {\n+                Location location = maybeLocation.get();\n+                if (!location.hasSubscription()) {\n+                    // Validate notification Url (must be non-null and https)\n+                    final String notificationUrl = config.getNotificationUrl();\n+                    if (isValidNotificationUrl(notificationUrl)) {\n+                        // Call gateway to register plant subscription\n+                        String subscriptionId = addSubscription(plantId, config.getNotificationUrl());\n+                        logger.debug(\"Bridge[{}] Notification registered: [plantId={}, subscriptionId={}]\",\n+                                thing.getUID(), plantId, subscriptionId);\n+\n+                        // Add the new subscription to notifications list\n+                        List<String> notifications = config.addNotification(subscriptionId);\n+\n+                        // Save the updated notifications list back to bridge config\n+                        Configuration configuration = editConfiguration();\n+                        configuration.put(PROPERTY_NOTIFICATIONS, notifications);\n+                        updateConfiguration(configuration);\n+\n+                        // Update the local locationCache with the added data\n+                        locations.stream().forEach(l -> {\n+                            if (l.getPlantId().equals(plantId)) {\n+                                l.setSubscription(subscriptionId, config.getNotificationUrl());\n+                            }\n+                        });\n+                        locationCache.putValue(locations);\n+                    } else {\n+                        logger.warn(\"Bridge[{}] Invalid notification Url [{}]: must be non-null, public https address\",\n+                                thing.getUID(), notificationUrl);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleNotification(Notification notification) {\n+        logger.debug(\"Bridge[{}] Notification received: [id={}]\", thing.getUID(), notification.getId());\n+\n+        updateChannelState(CHANNEL_NOTIFS_RECEIVED, new DecimalType(bridgeStatus.incrementNotificationsReceived()));\n+\n+        final String plantId = notification.getData().toChronothermostat().getSender().getPlant().getId();\n+        final String moduleId = notification.getData().toChronothermostat().getSender().getPlant().getModule().getId();\n+\n+        Optional<SmartherModuleHandler> maybeModuleHandler = getThing().getThings().stream()\n+                .map(t -> (SmartherModuleHandler) t.getHandler()).filter(h -> h.isLinkedTo(plantId, moduleId))\n+                .findFirst();\n+\n+        if (config.isUseNotifications() && maybeModuleHandler.isPresent()) {\n+            maybeModuleHandler.get().handleNotification(notification);", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY0OTUyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429649524", "bodyText": "Hmmm. Good point, but what happens if \"is not present\" ? I suppose my \"else\" statement and related updateChannelState(CHANNEL_NOTIFS_REJECTED, ... ) don't get executed.\nIs that correct?", "author": "MrRonfo", "createdAt": "2020-05-24T15:46:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzMTczMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MzcxMA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429663710", "bodyText": "You're totally right. I overlooked the else branch.", "author": "fwolter", "createdAt": "2020-05-24T18:41:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzMTczMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzMTk4MA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429531980", "bodyText": "Joda", "author": "fwolter", "createdAt": "2020-05-23T09:48:00Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherDynamicStateDescriptionProvider.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.DATE_FORMAT;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseDynamicStateDescriptionProvider;\n+import org.eclipse.smarthome.core.thing.type.DynamicStateDescriptionProvider;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.joda.time.DateTime;\n+import org.openhab.binding.smarther.internal.api.model.Program;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * Dynamically create the users list of programs and setting dates.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = { DynamicStateDescriptionProvider.class, SmartherDynamicStateDescriptionProvider.class })\n+@NonNullByDefault\n+public class SmartherDynamicStateDescriptionProvider extends BaseDynamicStateDescriptionProvider {\n+\n+    private static final String LABEL_FOREVER = \"Forever\";\n+    private static final String LABEL_TODAY = \"Today\";\n+    private static final String LABEL_TOMORROW = \"Tomorrow\";\n+\n+    public void setEndDates(ChannelUID channelUID, int maxEndDays) {\n+        List<StateOption> endDates = new ArrayList<StateOption>();\n+\n+        endDates.add(new StateOption(\"\", LABEL_FOREVER));\n+\n+        final DateTime today = DateTime.now().withTimeAtStartOfDay();", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3MTUxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429671516", "bodyText": "Converted", "author": "MrRonfo", "createdAt": "2020-05-24T20:21:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzMTk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzMzY4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429533689", "bodyText": "Are you sure the unit will be Temperature under all circumstances? You can use toUnit() to convert the QuantityType to a well known unit. It will return null if it cannot be converted.\nThen, you can skip the fahrenheit check, too.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    @SuppressWarnings(\"unchecked\")\n          \n          \n            \n                    QuantityType<Temperature> newMeasure = (QuantityType<Temperature>) command;\n          \n          \n            \n                    QuantityType<?> quantity = (QuantityType<?>) command;\n          \n          \n            \n                    QuantityType<?> newMeasure = quantity.toUnit(SIUnits.CELSIUS);", "author": "fwolter", "createdAt": "2020-05-23T10:15:59Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherModuleHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.scheduler.CronScheduler;\n+import org.eclipse.smarthome.core.scheduler.ScheduledCompletableFuture;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.joda.time.DateTime;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherSubscriptionAlreadyExistsException;\n+import org.openhab.binding.smarther.internal.api.model.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.model.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.model.Enums.Mode;\n+import org.openhab.binding.smarther.internal.api.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.api.model.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.openhab.binding.smarther.internal.api.model.Program;\n+import org.openhab.binding.smarther.internal.config.SmartherModuleConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherModuleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherModuleHandler extends BaseThingHandler {\n+\n+    private static final String DAILY_MIDNIGHT = \"1 0 0 * * ? *\";\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final CronScheduler cronScheduler;\n+    private final SmartherDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ChannelUID programChannelUID;\n+    private final ChannelUID endDateChannelUID;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) ScheduledCompletableFuture<Void> jobFuture;\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) SmartherBridgeHandler bridgeHandler;\n+    private @NonNullByDefault({}) SmartherModuleConfiguration config;\n+\n+    // Chronothermostat local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Program>> programCache;\n+    private @NonNullByDefault({}) Chronothermostat chronothermostat;\n+    private @NonNullByDefault({}) ModuleSettings moduleSettings;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param thing Thing representing this module.\n+     */\n+    public SmartherModuleHandler(Thing thing, CronScheduler scheduler,\n+            SmartherDynamicStateDescriptionProvider provider) {\n+        super(thing);\n+        this.cronScheduler = scheduler;\n+        this.dynamicStateDescriptionProvider = provider;\n+        this.programChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_PROGRAM);\n+        this.endDateChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_ENDDATE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        try {\n+            handleCommandInternal(channelUID, command);\n+\n+            updateModuleStatus();\n+        } catch (SmartherGatewayException ex) {\n+            // catch exceptions and handle it in your binding\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, ex.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws SmartherGatewayException {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SETTINGS_MODE:\n+                if (command instanceof StringType) {\n+                    moduleSettings.setMode(Mode.fromValue(command.toString()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_TEMPERATURE:\n+                if (changeTemperature(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_PROGRAM:\n+                if (command instanceof DecimalType) {\n+                    moduleSettings.setProgram(((DecimalType) command).intValue());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_BOOSTTIME:\n+                if (command instanceof DecimalType) {\n+                    moduleSettings.setBoostTime(BoostTime.fromValue(((DecimalType) command).intValue()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDDATE:\n+                if (command instanceof StringType) {\n+                    moduleSettings.setEndDate(command.toString());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDHOUR:\n+                if (changeTimeHour(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDMINUTE:\n+                if (changeTimeMinute(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_POWER:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        // Send change to the remote module\n+                        applyModuleSettings();\n+                        updateChannelState(CHANNEL_SETTINGS_POWER, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Module[{}] Manually triggered channel to refresh the Module config\",\n+                                thing.getUID());\n+                        programCache.invalidateValue();\n+                        programCache.getValue();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Module[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    private void applyModuleSettings() {\n+        // Send change to the remote module\n+        if (bridgeHandler.setModuleStatus(moduleSettings)) {\n+            // Change applied, update module status\n+            logger.debug(\"Module[{}] New settings applied!\", thing.getUID());\n+        }\n+    }\n+\n+    private boolean changeTemperature(Command command) {\n+        if (!(command instanceof QuantityType)) {\n+            return false;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        QuantityType<Temperature> newMeasure = (QuantityType<Temperature>) command;", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNDAyMg==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429534022", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-23T10:21:36Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherModuleHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.scheduler.CronScheduler;\n+import org.eclipse.smarthome.core.scheduler.ScheduledCompletableFuture;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.joda.time.DateTime;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherSubscriptionAlreadyExistsException;\n+import org.openhab.binding.smarther.internal.api.model.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.model.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.model.Enums.Mode;\n+import org.openhab.binding.smarther.internal.api.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.api.model.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.openhab.binding.smarther.internal.api.model.Program;\n+import org.openhab.binding.smarther.internal.config.SmartherModuleConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherModuleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherModuleHandler extends BaseThingHandler {\n+\n+    private static final String DAILY_MIDNIGHT = \"1 0 0 * * ? *\";\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final CronScheduler cronScheduler;\n+    private final SmartherDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ChannelUID programChannelUID;\n+    private final ChannelUID endDateChannelUID;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) ScheduledCompletableFuture<Void> jobFuture;\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) SmartherBridgeHandler bridgeHandler;\n+    private @NonNullByDefault({}) SmartherModuleConfiguration config;\n+\n+    // Chronothermostat local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Program>> programCache;\n+    private @NonNullByDefault({}) Chronothermostat chronothermostat;\n+    private @NonNullByDefault({}) ModuleSettings moduleSettings;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param thing Thing representing this module.\n+     */\n+    public SmartherModuleHandler(Thing thing, CronScheduler scheduler,\n+            SmartherDynamicStateDescriptionProvider provider) {\n+        super(thing);\n+        this.cronScheduler = scheduler;\n+        this.dynamicStateDescriptionProvider = provider;\n+        this.programChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_PROGRAM);\n+        this.endDateChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_ENDDATE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        try {\n+            handleCommandInternal(channelUID, command);\n+\n+            updateModuleStatus();\n+        } catch (SmartherGatewayException ex) {\n+            // catch exceptions and handle it in your binding\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, ex.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws SmartherGatewayException {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SETTINGS_MODE:\n+                if (command instanceof StringType) {\n+                    moduleSettings.setMode(Mode.fromValue(command.toString()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_TEMPERATURE:\n+                if (changeTemperature(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_PROGRAM:\n+                if (command instanceof DecimalType) {\n+                    moduleSettings.setProgram(((DecimalType) command).intValue());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_BOOSTTIME:\n+                if (command instanceof DecimalType) {\n+                    moduleSettings.setBoostTime(BoostTime.fromValue(((DecimalType) command).intValue()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDDATE:\n+                if (command instanceof StringType) {\n+                    moduleSettings.setEndDate(command.toString());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDHOUR:\n+                if (changeTimeHour(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDMINUTE:\n+                if (changeTimeMinute(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_POWER:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        // Send change to the remote module\n+                        applyModuleSettings();\n+                        updateChannelState(CHANNEL_SETTINGS_POWER, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Module[{}] Manually triggered channel to refresh the Module config\",\n+                                thing.getUID());\n+                        programCache.invalidateValue();\n+                        programCache.getValue();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Module[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    private void applyModuleSettings() {\n+        // Send change to the remote module\n+        if (bridgeHandler.setModuleStatus(moduleSettings)) {\n+            // Change applied, update module status\n+            logger.debug(\"Module[{}] New settings applied!\", thing.getUID());\n+        }\n+    }\n+\n+    private boolean changeTemperature(Command command) {\n+        if (!(command instanceof QuantityType)) {\n+            return false;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        QuantityType<Temperature> newMeasure = (QuantityType<Temperature>) command;\n+\n+        // Check remote device temperature limits\n+        if (newMeasure.getUnit() == SIUnits.CELSIUS) {\n+            if (newMeasure.doubleValue() < 7.1 || newMeasure.doubleValue() > 40.0) {\n+                return false;\n+            }\n+        } else if (newMeasure.getUnit() == ImperialUnits.FAHRENHEIT) {\n+            if (newMeasure.doubleValue() < 44.7 || newMeasure.doubleValue() > 104) {\n+                return false;\n+            }\n+        }\n+\n+        // Only tenth degree increments are allowed\n+        double newTemperature = Math.round(newMeasure.doubleValue() * 10) / 10.0;\n+\n+        moduleSettings.setSetPointTemperature(QuantityType.valueOf(newTemperature, newMeasure.getUnit()));\n+        return true;\n+    }\n+\n+    private boolean changeTimeHour(Command command) {\n+        if (command instanceof DecimalType) {\n+            int endHour = ((DecimalType) command).intValue();\n+            if (endHour >= 0 && endHour <= 23) {\n+                moduleSettings.setEndHour(endHour);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean changeTimeMinute(Command command) {\n+        if (command instanceof DecimalType) {\n+            int endMinute = ((DecimalType) command).intValue();\n+            if (endMinute >= 0 && endMinute <= 59) {\n+                // Only 15 min increments are allowed\n+                endMinute = Math.round(endMinute / 15) * 15;\n+                moduleSettings.setEndMinute(endMinute);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public void handleNotification(Notification notification) {\n+        chronothermostat = notification.getData().toChronothermostat();\n+        if (config.isSettingsAutoupdate()) {\n+            moduleSettings.updateFromChronothermostat(chronothermostat);\n+        }\n+        logger.debug(\"Module[{}] Handle notification: [{}]\", thing.getUID(), chronothermostat);\n+\n+        updateModuleStatus();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Module[{}] Initialize handler\", thing.getUID());\n+\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        bridgeHandler = (SmartherBridgeHandler) bridge.getHandler();\n+        if (bridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, String.format(\n+                    \"Missing configuration from the Smarther Bridge (UID:%s). Fix configuration or report if this problem remains.\",\n+                    bridge.getBridgeUID()));\n+            return;\n+        }\n+\n+        config = getConfigAs(SmartherModuleConfiguration.class);\n+        if (StringUtils.isBlank(config.getPlantId())) {", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1MDAyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429650027", "bodyText": "Done.", "author": "MrRonfo", "createdAt": "2020-05-24T15:52:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNDAyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNDMwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429534305", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-23T10:26:16Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherModuleHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.scheduler.CronScheduler;\n+import org.eclipse.smarthome.core.scheduler.ScheduledCompletableFuture;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.joda.time.DateTime;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherSubscriptionAlreadyExistsException;\n+import org.openhab.binding.smarther.internal.api.model.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.model.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.model.Enums.Mode;\n+import org.openhab.binding.smarther.internal.api.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.api.model.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.openhab.binding.smarther.internal.api.model.Program;\n+import org.openhab.binding.smarther.internal.config.SmartherModuleConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherModuleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherModuleHandler extends BaseThingHandler {\n+\n+    private static final String DAILY_MIDNIGHT = \"1 0 0 * * ? *\";\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final CronScheduler cronScheduler;\n+    private final SmartherDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ChannelUID programChannelUID;\n+    private final ChannelUID endDateChannelUID;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) ScheduledCompletableFuture<Void> jobFuture;\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) SmartherBridgeHandler bridgeHandler;\n+    private @NonNullByDefault({}) SmartherModuleConfiguration config;\n+\n+    // Chronothermostat local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Program>> programCache;\n+    private @NonNullByDefault({}) Chronothermostat chronothermostat;\n+    private @NonNullByDefault({}) ModuleSettings moduleSettings;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param thing Thing representing this module.\n+     */\n+    public SmartherModuleHandler(Thing thing, CronScheduler scheduler,\n+            SmartherDynamicStateDescriptionProvider provider) {\n+        super(thing);\n+        this.cronScheduler = scheduler;\n+        this.dynamicStateDescriptionProvider = provider;\n+        this.programChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_PROGRAM);\n+        this.endDateChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_ENDDATE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        try {\n+            handleCommandInternal(channelUID, command);\n+\n+            updateModuleStatus();\n+        } catch (SmartherGatewayException ex) {\n+            // catch exceptions and handle it in your binding\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, ex.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws SmartherGatewayException {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SETTINGS_MODE:\n+                if (command instanceof StringType) {\n+                    moduleSettings.setMode(Mode.fromValue(command.toString()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_TEMPERATURE:\n+                if (changeTemperature(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_PROGRAM:\n+                if (command instanceof DecimalType) {\n+                    moduleSettings.setProgram(((DecimalType) command).intValue());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_BOOSTTIME:\n+                if (command instanceof DecimalType) {\n+                    moduleSettings.setBoostTime(BoostTime.fromValue(((DecimalType) command).intValue()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDDATE:\n+                if (command instanceof StringType) {\n+                    moduleSettings.setEndDate(command.toString());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDHOUR:\n+                if (changeTimeHour(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDMINUTE:\n+                if (changeTimeMinute(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_POWER:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        // Send change to the remote module\n+                        applyModuleSettings();\n+                        updateChannelState(CHANNEL_SETTINGS_POWER, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Module[{}] Manually triggered channel to refresh the Module config\",\n+                                thing.getUID());\n+                        programCache.invalidateValue();\n+                        programCache.getValue();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Module[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    private void applyModuleSettings() {\n+        // Send change to the remote module\n+        if (bridgeHandler.setModuleStatus(moduleSettings)) {\n+            // Change applied, update module status\n+            logger.debug(\"Module[{}] New settings applied!\", thing.getUID());\n+        }\n+    }\n+\n+    private boolean changeTemperature(Command command) {\n+        if (!(command instanceof QuantityType)) {\n+            return false;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        QuantityType<Temperature> newMeasure = (QuantityType<Temperature>) command;\n+\n+        // Check remote device temperature limits\n+        if (newMeasure.getUnit() == SIUnits.CELSIUS) {\n+            if (newMeasure.doubleValue() < 7.1 || newMeasure.doubleValue() > 40.0) {\n+                return false;\n+            }\n+        } else if (newMeasure.getUnit() == ImperialUnits.FAHRENHEIT) {\n+            if (newMeasure.doubleValue() < 44.7 || newMeasure.doubleValue() > 104) {\n+                return false;\n+            }\n+        }\n+\n+        // Only tenth degree increments are allowed\n+        double newTemperature = Math.round(newMeasure.doubleValue() * 10) / 10.0;\n+\n+        moduleSettings.setSetPointTemperature(QuantityType.valueOf(newTemperature, newMeasure.getUnit()));\n+        return true;\n+    }\n+\n+    private boolean changeTimeHour(Command command) {\n+        if (command instanceof DecimalType) {\n+            int endHour = ((DecimalType) command).intValue();\n+            if (endHour >= 0 && endHour <= 23) {\n+                moduleSettings.setEndHour(endHour);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean changeTimeMinute(Command command) {\n+        if (command instanceof DecimalType) {\n+            int endMinute = ((DecimalType) command).intValue();\n+            if (endMinute >= 0 && endMinute <= 59) {\n+                // Only 15 min increments are allowed\n+                endMinute = Math.round(endMinute / 15) * 15;\n+                moduleSettings.setEndMinute(endMinute);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public void handleNotification(Notification notification) {\n+        chronothermostat = notification.getData().toChronothermostat();\n+        if (config.isSettingsAutoupdate()) {\n+            moduleSettings.updateFromChronothermostat(chronothermostat);\n+        }\n+        logger.debug(\"Module[{}] Handle notification: [{}]\", thing.getUID(), chronothermostat);\n+\n+        updateModuleStatus();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Module[{}] Initialize handler\", thing.getUID());\n+\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        bridgeHandler = (SmartherBridgeHandler) bridge.getHandler();\n+        if (bridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, String.format(\n+                    \"Missing configuration from the Smarther Bridge (UID:%s). Fix configuration or report if this problem remains.\",\n+                    bridge.getBridgeUID()));\n+            return;\n+        }\n+\n+        config = getConfigAs(SmartherModuleConfiguration.class);\n+        if (StringUtils.isBlank(config.getPlantId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Plant Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getModuleId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getProgramsRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Programs Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getStatusRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Status Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        programCache = new ExpiringCache<>(Duration.ofHours(config.getProgramsRefreshPeriod()), this::getProgramList);\n+        moduleSettings = new ModuleSettings(config.getPlantId(), config.getModuleId());\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleJob();\n+        schedulePoll();\n+\n+        logger.debug(\"Module[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    private List<Program> getProgramList() {\n+        final List<Program> programs = bridgeHandler.getModuleProgramList(config.getPlantId(), config.getModuleId());\n+        logger.debug(\"Module[{}] Programs: {}\", thing.getUID(), programs);\n+        return programs;\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+        stopJob(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Module[{}] Dispose handler\", thing.getUID());\n+        stopPoll(true);\n+        stopJob(true);\n+        try {\n+            bridgeHandler.unregisterNotification(config.getPlantId());\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Module[{}] API Gateway error during disposing: {}\", thing.getUID(), e.getMessage());\n+        }\n+        logger.debug(\"Module[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    /**\n+     * This method initiates a new thread for executing internal recurring jobs.\n+     */\n+    private synchronized void scheduleJob() {\n+        stopJob(false);\n+        // Schedule daily job to start daily, at midnight\n+        jobFuture = cronScheduler.schedule(this::dailyJob, DAILY_MIDNIGHT);\n+        logger.debug(\"Module[{}] Scheduled recurring job {} to start at midnight\", thing.getUID(),\n+                Integer.toHexString(jobFuture.hashCode()));\n+        // Execute daily job immediately at startup\n+        this.dailyJob();\n+    }\n+\n+    /**\n+     * Cancels all running jobs.\n+     *\n+     * @param mayInterruptIfRunning true if the thread executing this task should be interrupted; otherwise, in-progress\n+     *            tasks are allowed to complete.\n+     */\n+    private synchronized void stopJob(boolean mayInterruptIfRunning) {\n+        if (jobFuture != null && !jobFuture.isCancelled()) {\n+            jobFuture.cancel(mayInterruptIfRunning);\n+            jobFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Action to be executed by the daily job: refresh the end dates list for \"manual\" mode.\n+     */\n+    private void dailyJob() {\n+        try {\n+            logger.debug(\"Module[{}] Daily job, refreshing the end dates list for \\\"manual\\\" mode\", thing.getUID());\n+            // Refresh the end dates list for \"manual\" mode\n+            dynamicStateDescriptionProvider.setEndDates(endDateChannelUID, config.getNumberOfEndDays());\n+            // If expired, update EndDate in module settings\n+            if (moduleSettings != null && moduleSettings.isEndDateExpired()) {\n+                final DateTime today = DateTime.now().withTimeAtStartOfDay();\n+                moduleSettings.setEndDate(today.toString(DATE_FORMAT));\n+                updateChannelState(CHANNEL_SETTINGS_ENDDATE, new StringType(moduleSettings.getEndDate()));\n+            }\n+        } catch (RuntimeException e) {", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3MTk2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429671966", "bodyText": "This is actually not needed. Removed, thanks.", "author": "MrRonfo", "createdAt": "2020-05-24T20:27:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNDMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNDcxNw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429534717", "bodyText": "From the concurrency perspective, getBridge() could return null here.", "author": "fwolter", "createdAt": "2020-05-23T10:34:29Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherModuleHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.scheduler.CronScheduler;\n+import org.eclipse.smarthome.core.scheduler.ScheduledCompletableFuture;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.joda.time.DateTime;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherSubscriptionAlreadyExistsException;\n+import org.openhab.binding.smarther.internal.api.model.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.model.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.model.Enums.Mode;\n+import org.openhab.binding.smarther.internal.api.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.api.model.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.openhab.binding.smarther.internal.api.model.Program;\n+import org.openhab.binding.smarther.internal.config.SmartherModuleConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherModuleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherModuleHandler extends BaseThingHandler {\n+\n+    private static final String DAILY_MIDNIGHT = \"1 0 0 * * ? *\";\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final CronScheduler cronScheduler;\n+    private final SmartherDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ChannelUID programChannelUID;\n+    private final ChannelUID endDateChannelUID;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) ScheduledCompletableFuture<Void> jobFuture;\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) SmartherBridgeHandler bridgeHandler;\n+    private @NonNullByDefault({}) SmartherModuleConfiguration config;\n+\n+    // Chronothermostat local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Program>> programCache;\n+    private @NonNullByDefault({}) Chronothermostat chronothermostat;\n+    private @NonNullByDefault({}) ModuleSettings moduleSettings;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param thing Thing representing this module.\n+     */\n+    public SmartherModuleHandler(Thing thing, CronScheduler scheduler,\n+            SmartherDynamicStateDescriptionProvider provider) {\n+        super(thing);\n+        this.cronScheduler = scheduler;\n+        this.dynamicStateDescriptionProvider = provider;\n+        this.programChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_PROGRAM);\n+        this.endDateChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_ENDDATE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        try {\n+            handleCommandInternal(channelUID, command);\n+\n+            updateModuleStatus();\n+        } catch (SmartherGatewayException ex) {\n+            // catch exceptions and handle it in your binding\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, ex.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws SmartherGatewayException {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SETTINGS_MODE:\n+                if (command instanceof StringType) {\n+                    moduleSettings.setMode(Mode.fromValue(command.toString()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_TEMPERATURE:\n+                if (changeTemperature(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_PROGRAM:\n+                if (command instanceof DecimalType) {\n+                    moduleSettings.setProgram(((DecimalType) command).intValue());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_BOOSTTIME:\n+                if (command instanceof DecimalType) {\n+                    moduleSettings.setBoostTime(BoostTime.fromValue(((DecimalType) command).intValue()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDDATE:\n+                if (command instanceof StringType) {\n+                    moduleSettings.setEndDate(command.toString());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDHOUR:\n+                if (changeTimeHour(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDMINUTE:\n+                if (changeTimeMinute(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_POWER:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        // Send change to the remote module\n+                        applyModuleSettings();\n+                        updateChannelState(CHANNEL_SETTINGS_POWER, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Module[{}] Manually triggered channel to refresh the Module config\",\n+                                thing.getUID());\n+                        programCache.invalidateValue();\n+                        programCache.getValue();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Module[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    private void applyModuleSettings() {\n+        // Send change to the remote module\n+        if (bridgeHandler.setModuleStatus(moduleSettings)) {\n+            // Change applied, update module status\n+            logger.debug(\"Module[{}] New settings applied!\", thing.getUID());\n+        }\n+    }\n+\n+    private boolean changeTemperature(Command command) {\n+        if (!(command instanceof QuantityType)) {\n+            return false;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        QuantityType<Temperature> newMeasure = (QuantityType<Temperature>) command;\n+\n+        // Check remote device temperature limits\n+        if (newMeasure.getUnit() == SIUnits.CELSIUS) {\n+            if (newMeasure.doubleValue() < 7.1 || newMeasure.doubleValue() > 40.0) {\n+                return false;\n+            }\n+        } else if (newMeasure.getUnit() == ImperialUnits.FAHRENHEIT) {\n+            if (newMeasure.doubleValue() < 44.7 || newMeasure.doubleValue() > 104) {\n+                return false;\n+            }\n+        }\n+\n+        // Only tenth degree increments are allowed\n+        double newTemperature = Math.round(newMeasure.doubleValue() * 10) / 10.0;\n+\n+        moduleSettings.setSetPointTemperature(QuantityType.valueOf(newTemperature, newMeasure.getUnit()));\n+        return true;\n+    }\n+\n+    private boolean changeTimeHour(Command command) {\n+        if (command instanceof DecimalType) {\n+            int endHour = ((DecimalType) command).intValue();\n+            if (endHour >= 0 && endHour <= 23) {\n+                moduleSettings.setEndHour(endHour);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean changeTimeMinute(Command command) {\n+        if (command instanceof DecimalType) {\n+            int endMinute = ((DecimalType) command).intValue();\n+            if (endMinute >= 0 && endMinute <= 59) {\n+                // Only 15 min increments are allowed\n+                endMinute = Math.round(endMinute / 15) * 15;\n+                moduleSettings.setEndMinute(endMinute);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public void handleNotification(Notification notification) {\n+        chronothermostat = notification.getData().toChronothermostat();\n+        if (config.isSettingsAutoupdate()) {\n+            moduleSettings.updateFromChronothermostat(chronothermostat);\n+        }\n+        logger.debug(\"Module[{}] Handle notification: [{}]\", thing.getUID(), chronothermostat);\n+\n+        updateModuleStatus();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Module[{}] Initialize handler\", thing.getUID());\n+\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        bridgeHandler = (SmartherBridgeHandler) bridge.getHandler();\n+        if (bridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, String.format(\n+                    \"Missing configuration from the Smarther Bridge (UID:%s). Fix configuration or report if this problem remains.\",\n+                    bridge.getBridgeUID()));\n+            return;\n+        }\n+\n+        config = getConfigAs(SmartherModuleConfiguration.class);\n+        if (StringUtils.isBlank(config.getPlantId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Plant Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getModuleId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getProgramsRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Programs Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getStatusRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Status Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        programCache = new ExpiringCache<>(Duration.ofHours(config.getProgramsRefreshPeriod()), this::getProgramList);\n+        moduleSettings = new ModuleSettings(config.getPlantId(), config.getModuleId());\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleJob();\n+        schedulePoll();\n+\n+        logger.debug(\"Module[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    private List<Program> getProgramList() {\n+        final List<Program> programs = bridgeHandler.getModuleProgramList(config.getPlantId(), config.getModuleId());\n+        logger.debug(\"Module[{}] Programs: {}\", thing.getUID(), programs);\n+        return programs;\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+        stopJob(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Module[{}] Dispose handler\", thing.getUID());\n+        stopPoll(true);\n+        stopJob(true);\n+        try {\n+            bridgeHandler.unregisterNotification(config.getPlantId());\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Module[{}] API Gateway error during disposing: {}\", thing.getUID(), e.getMessage());\n+        }\n+        logger.debug(\"Module[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    /**\n+     * This method initiates a new thread for executing internal recurring jobs.\n+     */\n+    private synchronized void scheduleJob() {\n+        stopJob(false);\n+        // Schedule daily job to start daily, at midnight\n+        jobFuture = cronScheduler.schedule(this::dailyJob, DAILY_MIDNIGHT);\n+        logger.debug(\"Module[{}] Scheduled recurring job {} to start at midnight\", thing.getUID(),\n+                Integer.toHexString(jobFuture.hashCode()));\n+        // Execute daily job immediately at startup\n+        this.dailyJob();\n+    }\n+\n+    /**\n+     * Cancels all running jobs.\n+     *\n+     * @param mayInterruptIfRunning true if the thread executing this task should be interrupted; otherwise, in-progress\n+     *            tasks are allowed to complete.\n+     */\n+    private synchronized void stopJob(boolean mayInterruptIfRunning) {\n+        if (jobFuture != null && !jobFuture.isCancelled()) {\n+            jobFuture.cancel(mayInterruptIfRunning);\n+            jobFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Action to be executed by the daily job: refresh the end dates list for \"manual\" mode.\n+     */\n+    private void dailyJob() {\n+        try {\n+            logger.debug(\"Module[{}] Daily job, refreshing the end dates list for \\\"manual\\\" mode\", thing.getUID());\n+            // Refresh the end dates list for \"manual\" mode\n+            dynamicStateDescriptionProvider.setEndDates(endDateChannelUID, config.getNumberOfEndDays());\n+            // If expired, update EndDate in module settings\n+            if (moduleSettings != null && moduleSettings.isEndDateExpired()) {\n+                final DateTime today = DateTime.now().withTimeAtStartOfDay();\n+                moduleSettings.setEndDate(today.toString(DATE_FORMAT));\n+                updateChannelState(CHANNEL_SETTINGS_ENDDATE, new StringType(moduleSettings.getEndDate()));\n+            }\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Module[{}] Unexpected error on daily job, please report if this keeps occurring: \",\n+                    thing.getUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * This method initiates a new thread for polling the Module status.\n+     */\n+    private void schedulePoll() {\n+        stopPoll(false);\n+        // Schedule poll to start after POLL_INITIAL_DELAY sec and run periodically based on status refresh period\n+        pollFuture = scheduler.scheduleWithFixedDelay(this::poll, POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod() * 60, TimeUnit.SECONDS);\n+        logger.debug(\"Module[{}] Scheduled poll for {} sec out, then every {} min\", thing.getUID(), POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod());\n+    }\n+\n+    /**\n+     * Cancels all running schedulers.\n+     *\n+     * @param mayInterruptIfRunning true if the thread executing this task should be interrupted; otherwise, in-progress\n+     *            tasks are allowed to complete.\n+     */\n+    private synchronized void stopPoll(boolean mayInterruptIfRunning) {\n+        if (pollFuture != null && !pollFuture.isCancelled()) {\n+            pollFuture.cancel(mayInterruptIfRunning);\n+            pollFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Calls the Smarther API and collects module data. Returns true if method completed without errors.\n+     *\n+     * @return true if method completed without errors.\n+     */\n+    private synchronized boolean poll() {\n+        try {\n+            @SuppressWarnings(\"null\")", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3MjU4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429672584", "bodyText": "Correct. Fixed.", "author": "MrRonfo", "createdAt": "2020-05-24T20:35:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNDcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNDgxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429534811", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-23T10:35:58Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherModuleHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.scheduler.CronScheduler;\n+import org.eclipse.smarthome.core.scheduler.ScheduledCompletableFuture;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.joda.time.DateTime;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherSubscriptionAlreadyExistsException;\n+import org.openhab.binding.smarther.internal.api.model.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.model.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.model.Enums.Mode;\n+import org.openhab.binding.smarther.internal.api.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.api.model.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.openhab.binding.smarther.internal.api.model.Program;\n+import org.openhab.binding.smarther.internal.config.SmartherModuleConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherModuleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherModuleHandler extends BaseThingHandler {\n+\n+    private static final String DAILY_MIDNIGHT = \"1 0 0 * * ? *\";\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final CronScheduler cronScheduler;\n+    private final SmartherDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ChannelUID programChannelUID;\n+    private final ChannelUID endDateChannelUID;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) ScheduledCompletableFuture<Void> jobFuture;\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) SmartherBridgeHandler bridgeHandler;\n+    private @NonNullByDefault({}) SmartherModuleConfiguration config;\n+\n+    // Chronothermostat local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Program>> programCache;\n+    private @NonNullByDefault({}) Chronothermostat chronothermostat;\n+    private @NonNullByDefault({}) ModuleSettings moduleSettings;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param thing Thing representing this module.\n+     */\n+    public SmartherModuleHandler(Thing thing, CronScheduler scheduler,\n+            SmartherDynamicStateDescriptionProvider provider) {\n+        super(thing);\n+        this.cronScheduler = scheduler;\n+        this.dynamicStateDescriptionProvider = provider;\n+        this.programChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_PROGRAM);\n+        this.endDateChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_ENDDATE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        try {\n+            handleCommandInternal(channelUID, command);\n+\n+            updateModuleStatus();\n+        } catch (SmartherGatewayException ex) {\n+            // catch exceptions and handle it in your binding\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, ex.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws SmartherGatewayException {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SETTINGS_MODE:\n+                if (command instanceof StringType) {\n+                    moduleSettings.setMode(Mode.fromValue(command.toString()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_TEMPERATURE:\n+                if (changeTemperature(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_PROGRAM:\n+                if (command instanceof DecimalType) {\n+                    moduleSettings.setProgram(((DecimalType) command).intValue());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_BOOSTTIME:\n+                if (command instanceof DecimalType) {\n+                    moduleSettings.setBoostTime(BoostTime.fromValue(((DecimalType) command).intValue()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDDATE:\n+                if (command instanceof StringType) {\n+                    moduleSettings.setEndDate(command.toString());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDHOUR:\n+                if (changeTimeHour(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDMINUTE:\n+                if (changeTimeMinute(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_POWER:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        // Send change to the remote module\n+                        applyModuleSettings();\n+                        updateChannelState(CHANNEL_SETTINGS_POWER, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Module[{}] Manually triggered channel to refresh the Module config\",\n+                                thing.getUID());\n+                        programCache.invalidateValue();\n+                        programCache.getValue();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Module[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    private void applyModuleSettings() {\n+        // Send change to the remote module\n+        if (bridgeHandler.setModuleStatus(moduleSettings)) {\n+            // Change applied, update module status\n+            logger.debug(\"Module[{}] New settings applied!\", thing.getUID());\n+        }\n+    }\n+\n+    private boolean changeTemperature(Command command) {\n+        if (!(command instanceof QuantityType)) {\n+            return false;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        QuantityType<Temperature> newMeasure = (QuantityType<Temperature>) command;\n+\n+        // Check remote device temperature limits\n+        if (newMeasure.getUnit() == SIUnits.CELSIUS) {\n+            if (newMeasure.doubleValue() < 7.1 || newMeasure.doubleValue() > 40.0) {\n+                return false;\n+            }\n+        } else if (newMeasure.getUnit() == ImperialUnits.FAHRENHEIT) {\n+            if (newMeasure.doubleValue() < 44.7 || newMeasure.doubleValue() > 104) {\n+                return false;\n+            }\n+        }\n+\n+        // Only tenth degree increments are allowed\n+        double newTemperature = Math.round(newMeasure.doubleValue() * 10) / 10.0;\n+\n+        moduleSettings.setSetPointTemperature(QuantityType.valueOf(newTemperature, newMeasure.getUnit()));\n+        return true;\n+    }\n+\n+    private boolean changeTimeHour(Command command) {\n+        if (command instanceof DecimalType) {\n+            int endHour = ((DecimalType) command).intValue();\n+            if (endHour >= 0 && endHour <= 23) {\n+                moduleSettings.setEndHour(endHour);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean changeTimeMinute(Command command) {\n+        if (command instanceof DecimalType) {\n+            int endMinute = ((DecimalType) command).intValue();\n+            if (endMinute >= 0 && endMinute <= 59) {\n+                // Only 15 min increments are allowed\n+                endMinute = Math.round(endMinute / 15) * 15;\n+                moduleSettings.setEndMinute(endMinute);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public void handleNotification(Notification notification) {\n+        chronothermostat = notification.getData().toChronothermostat();\n+        if (config.isSettingsAutoupdate()) {\n+            moduleSettings.updateFromChronothermostat(chronothermostat);\n+        }\n+        logger.debug(\"Module[{}] Handle notification: [{}]\", thing.getUID(), chronothermostat);\n+\n+        updateModuleStatus();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Module[{}] Initialize handler\", thing.getUID());\n+\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        bridgeHandler = (SmartherBridgeHandler) bridge.getHandler();\n+        if (bridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, String.format(\n+                    \"Missing configuration from the Smarther Bridge (UID:%s). Fix configuration or report if this problem remains.\",\n+                    bridge.getBridgeUID()));\n+            return;\n+        }\n+\n+        config = getConfigAs(SmartherModuleConfiguration.class);\n+        if (StringUtils.isBlank(config.getPlantId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Plant Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getModuleId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getProgramsRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Programs Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getStatusRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Status Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        programCache = new ExpiringCache<>(Duration.ofHours(config.getProgramsRefreshPeriod()), this::getProgramList);\n+        moduleSettings = new ModuleSettings(config.getPlantId(), config.getModuleId());\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleJob();\n+        schedulePoll();\n+\n+        logger.debug(\"Module[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    private List<Program> getProgramList() {\n+        final List<Program> programs = bridgeHandler.getModuleProgramList(config.getPlantId(), config.getModuleId());\n+        logger.debug(\"Module[{}] Programs: {}\", thing.getUID(), programs);\n+        return programs;\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+        stopJob(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Module[{}] Dispose handler\", thing.getUID());\n+        stopPoll(true);\n+        stopJob(true);\n+        try {\n+            bridgeHandler.unregisterNotification(config.getPlantId());\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Module[{}] API Gateway error during disposing: {}\", thing.getUID(), e.getMessage());\n+        }\n+        logger.debug(\"Module[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    /**\n+     * This method initiates a new thread for executing internal recurring jobs.\n+     */\n+    private synchronized void scheduleJob() {\n+        stopJob(false);\n+        // Schedule daily job to start daily, at midnight\n+        jobFuture = cronScheduler.schedule(this::dailyJob, DAILY_MIDNIGHT);\n+        logger.debug(\"Module[{}] Scheduled recurring job {} to start at midnight\", thing.getUID(),\n+                Integer.toHexString(jobFuture.hashCode()));\n+        // Execute daily job immediately at startup\n+        this.dailyJob();\n+    }\n+\n+    /**\n+     * Cancels all running jobs.\n+     *\n+     * @param mayInterruptIfRunning true if the thread executing this task should be interrupted; otherwise, in-progress\n+     *            tasks are allowed to complete.\n+     */\n+    private synchronized void stopJob(boolean mayInterruptIfRunning) {\n+        if (jobFuture != null && !jobFuture.isCancelled()) {\n+            jobFuture.cancel(mayInterruptIfRunning);\n+            jobFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Action to be executed by the daily job: refresh the end dates list for \"manual\" mode.\n+     */\n+    private void dailyJob() {\n+        try {\n+            logger.debug(\"Module[{}] Daily job, refreshing the end dates list for \\\"manual\\\" mode\", thing.getUID());\n+            // Refresh the end dates list for \"manual\" mode\n+            dynamicStateDescriptionProvider.setEndDates(endDateChannelUID, config.getNumberOfEndDays());\n+            // If expired, update EndDate in module settings\n+            if (moduleSettings != null && moduleSettings.isEndDateExpired()) {\n+                final DateTime today = DateTime.now().withTimeAtStartOfDay();\n+                moduleSettings.setEndDate(today.toString(DATE_FORMAT));\n+                updateChannelState(CHANNEL_SETTINGS_ENDDATE, new StringType(moduleSettings.getEndDate()));\n+            }\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Module[{}] Unexpected error on daily job, please report if this keeps occurring: \",\n+                    thing.getUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * This method initiates a new thread for polling the Module status.\n+     */\n+    private void schedulePoll() {\n+        stopPoll(false);\n+        // Schedule poll to start after POLL_INITIAL_DELAY sec and run periodically based on status refresh period\n+        pollFuture = scheduler.scheduleWithFixedDelay(this::poll, POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod() * 60, TimeUnit.SECONDS);\n+        logger.debug(\"Module[{}] Scheduled poll for {} sec out, then every {} min\", thing.getUID(), POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod());\n+    }\n+\n+    /**\n+     * Cancels all running schedulers.\n+     *\n+     * @param mayInterruptIfRunning true if the thread executing this task should be interrupted; otherwise, in-progress\n+     *            tasks are allowed to complete.\n+     */\n+    private synchronized void stopPoll(boolean mayInterruptIfRunning) {\n+        if (pollFuture != null && !pollFuture.isCancelled()) {\n+            pollFuture.cancel(mayInterruptIfRunning);\n+            pollFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Calls the Smarther API and collects module data. Returns true if method completed without errors.\n+     *\n+     * @return true if method completed without errors.\n+     */\n+    private synchronized boolean poll() {\n+        try {\n+            @SuppressWarnings(\"null\")\n+            final ThingStatusInfo bridgeStatusInfo = getBridge().getStatusInfo();\n+\n+            if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+                ModuleStatus moduleStatus = bridgeHandler.getModuleStatus(config.getPlantId(), config.getModuleId());\n+                if (!moduleStatus.hasChronothermostat()) {\n+                    throw new SmartherGatewayException(\"No chronothermostat data found\");\n+                }\n+\n+                boolean isFirstRemoteUpdate = (chronothermostat == null);\n+                chronothermostat = moduleStatus.toChronothermostat();\n+                if (isFirstRemoteUpdate || config.isSettingsAutoupdate()) {\n+                    moduleSettings.updateFromChronothermostat(chronothermostat);\n+                }\n+                logger.debug(\"Module[{}] Status: [{}]\", thing.getUID(), chronothermostat);\n+\n+                // Refresh the programs list for \"automatic\" mode\n+                dynamicStateDescriptionProvider.setPrograms(programChannelUID, programCache.getValue());\n+\n+                updateModuleStatus();\n+\n+                bridgeHandler.registerNotification(config.getPlantId());\n+\n+                // Everything is ok > set the Thing state to Online\n+                updateStatus(ThingStatus.ONLINE);\n+                return true;\n+            } else if (thing.getStatus() != ThingStatus.OFFLINE) {\n+                logger.debug(\"Module[{}] Switched {} as Bridge is not online\", thing.getUID(),\n+                        bridgeStatusInfo.getStatus());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, \"Smarther Bridge Offline\");\n+            }\n+            return false;\n+        } catch (SmartherSubscriptionAlreadyExistsException e) {\n+            logger.debug(\"Module[{}] Subscription error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Module[{}] API Gateway error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (RuntimeException e) {", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3MjE3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429672173", "bodyText": "Poll is the core function. See above for SmartherBridgeHandler...", "author": "MrRonfo", "createdAt": "2020-05-24T20:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNDgxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNjQ1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429536456", "bodyText": "Is there a reason for extending from an unchecked exception? Would extends Exception be sufficient?", "author": "fwolter", "createdAt": "2020-05-23T11:06:10Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/exception/SmartherAuthorizationException.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api.exception;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * BTicino/Legrand API gateway authorization problems exception class.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherAuthorizationException extends RuntimeException {", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1NjY2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429656669", "bodyText": "I've reused the base skeleton from Spotify binding, where these were all extension of RuntimeException. Extending from Exception is not sufficient in this case: also trying to refactor them, I come into lot of troubles when dealing with CompletableFuture and ExpiringCache declared in framework methods (like initialize, etc.) where signature cannot be changed.", "author": "MrRonfo", "createdAt": "2020-05-24T17:13:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNjQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2MTMxMg==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429661312", "bodyText": "I can't follow you. Can you point to a location that makes trouble?", "author": "fwolter", "createdAt": "2020-05-24T18:13:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNjQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3NTc1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429675752", "bodyText": "Just as an example: in the initialize function, I initialize the cache locationCache with action getLocationList:\n\nlocationCache = new ExpiringCache<>(Duration.ofMinutes(config.getStatusRefreshPeriod()), this::getLocationList);\n\nThat can throw runtime SmartherAuthenticationException:\n\nprivate List getLocationList() {\n\nSince this is an ExpiringCache, it is supposed to call getLocationList only when getting value from it, so in other functions where the exception are catched and handled (and I want to have exception thrown by getLocationList there, to be able to manage the related cases).\nHowever, if I extend SmartherAuthenticationException from Exception I'm obliged to catch the exception even in initialize method, where it shouldn't be needed...\nWith \"Spotify binding\" I just meant I've started from there to build up my binding (as it handles OAuth2 authentication, also used by Legrand API) and, since it was an already reviewed and authorized binding, I thought it was a good starting point. That's it :)", "author": "MrRonfo", "createdAt": "2020-05-24T21:10:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNjQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2MTEzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r430061138", "bodyText": "Understood, you used an unchecked exception, because you want to throw exceptions, but the external interface you used doesn't declare any throws. Well, the downside of this approach is that the compiler does not force you to catch the exception at the end.\nI took another look at your code and found a location straightaway where you miss to catch an unchecked exception: SmartherAuthorizationServlet.doGet() invokes formatApplications() which eventually accesses your cache. In this case you may be lucky if an exception is thrown, the servlet thread would catch it for you (but what happens with the request?). In a plain Java application the current thread would be terminated.\nI would catch the exception in getLocationList, log it and return an empty List or an empty Optional.\nI am wondering what @cpmeister would say.", "author": "fwolter", "createdAt": "2020-05-25T19:59:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNjQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNjQ2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429536463", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-23T11:06:22Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/exception/SmartherGatewayException.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api.exception;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Generic BTicino/Legrand API gateway exception class.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherGatewayException extends RuntimeException {", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3MjY1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429672658", "bodyText": "Same as above", "author": "MrRonfo", "createdAt": "2020-05-24T20:36:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNjQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNjQ2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429536468", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-23T11:06:32Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/exception/SmartherNotificationException.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api.exception;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * BTicino/Legrand C2C service notification problems exception class.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherNotificationException extends RuntimeException {", "originalCommit": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3MjY3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429672674", "bodyText": "Same as above", "author": "MrRonfo", "createdAt": "2020-05-24T20:36:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNjQ2OA=="}], "type": "inlineReview"}, {"oid": "ae26de1cd33f0ddef5e30296127aeb326c1163dd", "url": "https://github.com/openhab/openhab-addons/commit/ae26de1cd33f0ddef5e30296127aeb326c1163dd", "message": "FIxed reference to bridge authorization process.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-05-25T21:42:12Z", "type": "forcePushed"}, {"oid": "691a6fba423de88e4347016ce5b56655e0cd1b77", "url": "https://github.com/openhab/openhab-addons/commit/691a6fba423de88e4347016ce5b56655e0cd1b77", "message": "FIxed reference to bridge authorization process.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-05-26T18:37:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQzMDIzMg==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r431430232", "bodyText": "This will also be true if cause is one of your custom RuntimeExceptions. Is this intended?", "author": "fwolter", "createdAt": "2020-05-27T20:43:48Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/SmartherApiConnector.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api;\n+\n+import static org.eclipse.jetty.http.HttpStatus.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherSubscriptionAlreadyExistsException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherTokenExpiredException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * Class to perform the actual call to the BTicino/Legrand API gateway, interprets the returned Http status codes, and\n+ * handles the error codes returned by the API gateway.\n+ *\n+ * Response mappings:\n+ * <ul>\n+ * <li>Plants : 200, 204, 400, 401, 404, 408, 469, 470, 500</li>\n+ * <li>Topology : 200, 400, 401, 404, 408, 469, 470, 500</li>\n+ * <li>Measures : 200, 400, 401, 404, 408, 469, 470, 500</li>\n+ * <li>ProgramList : 200, 400, 401, 404, 408, 469, 470, 500</li>\n+ * <li>Get Status : 200, 400, 401, 404, 408, 469, 470, 500</li>\n+ * <li>Set Status : 200, 400, 401, 404, 408, 430, 469, 470, 486, 500</li>\n+ * <li>Get Subscriptions : 200, 204, 400, 401, 404, 500</li>\n+ * <li>Subscribe : 201, 400, 401, 404, 409, 500</li>\n+ * <li>Delete Subscription : 200, 400, 401, 404, 500</li>\n+ * </ul>\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherApiConnector {\n+\n+    private static final String RETRY_AFTER_HEADER = \"Retry-After\";\n+    private static final String AUTHORIZATION_HEADER = \"Authorization\";\n+    private static final String SUBSCRIPTION_HEADER = \"Ocp-Apim-Subscription-Key\";\n+\n+    private static final String ERROR_CODE = \"statusCode\";\n+    private static final String ERROR_MESSAGE = \"message\";\n+    private static final String TOKEN_EXPIRED = \"expired\";\n+    private static final String AUTHORIZATION_ERROR = \"error_description\";\n+\n+    private static final int HTTP_CLIENT_TIMEOUT_SECONDS = 10;\n+    private static final int HTTP_CLIENT_RETRY_COUNT = 5;\n+\n+    // Set Chronothermostat Status > Wrong input parameters\n+    private static final int WRONG_INPUT_PARAMS_430 = 430;\n+    // Official application password expired: password used in the Thermostat official app is expired.\n+    private static final int APP_PASSWORD_EXPIRED_469 = 469;\n+    // Official application terms and conditions expired: terms and conditions for Thermostat official app are expired.\n+    private static final int APP_TERMS_EXPIRED_470 = 470;\n+    // Set Chronothermostat Status > Busy visual user interface\n+    private static final int BUSY_VISUAL_UI_486 = 486;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final JsonParser parser = new JsonParser();\n+    private final HttpClient httpClient;\n+    private final ScheduledExecutorService scheduler;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param scheduler Scheduler to reschedule calls when rate limit exceeded or call not ready\n+     * @param httpClient http client to use to make http calls\n+     */\n+    public SmartherApiConnector(ScheduledExecutorService scheduler, HttpClient httpClient) {\n+        this.scheduler = scheduler;\n+        this.httpClient = httpClient;\n+    }\n+\n+    /**\n+     * Performs a call to the BTicino/Legrand API gateway and returns the raw response. In there are problems this\n+     * method can throw a SmartherGateway exception.\n+     *\n+     * @param requester The function to construct the request with http client that is passed as argument to the\n+     *            function\n+     * @param subscription The subscription string to use in the Subscription header\n+     * @param authorization The authorization string to use in the Authorization header\n+     * @return the raw reponse given\n+     */\n+    public ContentResponse request(Function<HttpClient, Request> requester, String subscription, String authorization) {\n+        final Caller caller = new Caller(requester, subscription, authorization);\n+\n+        try {\n+            return caller.call().get();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            throw new SmartherGatewayException(\"Thread interrupted\");\n+        } catch (ExecutionException e) {\n+            final Throwable cause = e.getCause();\n+\n+            if (cause instanceof RuntimeException) {", "originalCommit": "691a6fba423de88e4347016ce5b56655e0cd1b77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAzMzI5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r432033296", "bodyText": "Yes, this is intended, so that custom RuntimeExceptions gets propagated as is while others are reconducted to a SmartherGatewayException.", "author": "MrRonfo", "createdAt": "2020-05-28T18:21:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQzMDIzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQzMzgzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r431433837", "bodyText": "Can this be done by String.trim()? Then, length() == 0 can be replaced by isEmpty()", "author": "fwolter", "createdAt": "2020-05-27T20:50:24Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/util/StringUtil.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.util;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.StringWriter;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link StringUtil} class defines common String utility functions, which are used across the whole binding.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StringUtil {\n+\n+    private static final int EOF = -1;\n+    private static final int DEFAULT_BUFFER_SIZE = 1024 * 4;\n+\n+    /**\n+     * Checks if a String is whitespace, empty (\"\") or null.\n+     *\n+     * @param str the String to check, may be null\n+     * @return true if the String is null, empty or whitespace\n+     */\n+    public static boolean isBlank(@Nullable String str) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return true;\n+        }\n+        for (int i = 0; i < strLen; i++) {\n+            if (!Character.isWhitespace(str.charAt(i))) {\n+                return false;\n+            }\n+        }", "originalCommit": "7793a4f48ce3b905430b78b943996752b41d59d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0Njg2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r431446863", "bodyText": "Can this be done by String.trim()?", "author": "fwolter", "createdAt": "2020-05-27T21:15:52Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/util/StringUtil.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.util;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.StringWriter;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link StringUtil} class defines common String utility functions, which are used across the whole binding.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StringUtil {\n+\n+    private static final int EOF = -1;\n+    private static final int DEFAULT_BUFFER_SIZE = 1024 * 4;\n+\n+    /**\n+     * Checks if a String is whitespace, empty (\"\") or null.\n+     *\n+     * @param str the String to check, may be null\n+     * @return true if the String is null, empty or whitespace\n+     */\n+    public static boolean isBlank(@Nullable String str) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return true;\n+        }\n+        for (int i = 0; i < strLen; i++) {\n+            if (!Character.isWhitespace(str.charAt(i))) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns either the passed in String, or if the String is whitespace, empty (\"\") or null, the value of defaultStr.\n+     *\n+     * @param str the String to check, may be null\n+     * @param defaultStr the default String to return\n+     * @return the passed in String, or the default\n+     */\n+    public static String defaultIfBlank(String str, String defaultStr) {\n+        return StringUtil.isBlank(str) ? defaultStr : str;\n+    }\n+\n+    /**\n+     * Strips whitespace from the start and end of a String returning null if the String is empty (\"\") after the strip.\n+     *\n+     * @param str the String to be stripped, may be null\n+     * @return the stripped String, null if whitespace, empty or null String input\n+     */\n+    public static @Nullable String stripToNull(@Nullable String str) {\n+        if (str == null || str.length() == 0) {\n+            return null;\n+        }\n+\n+        int strLen = str.length();", "originalCommit": "7793a4f48ce3b905430b78b943996752b41d59d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0NzI5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r431447295", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (str == null || str.length() == 0) {\n          \n          \n            \n                    if (str == null || str.isEmpty()) {", "author": "fwolter", "createdAt": "2020-05-27T21:16:50Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/util/StringUtil.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.util;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.StringWriter;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link StringUtil} class defines common String utility functions, which are used across the whole binding.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StringUtil {\n+\n+    private static final int EOF = -1;\n+    private static final int DEFAULT_BUFFER_SIZE = 1024 * 4;\n+\n+    /**\n+     * Checks if a String is whitespace, empty (\"\") or null.\n+     *\n+     * @param str the String to check, may be null\n+     * @return true if the String is null, empty or whitespace\n+     */\n+    public static boolean isBlank(@Nullable String str) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return true;\n+        }\n+        for (int i = 0; i < strLen; i++) {\n+            if (!Character.isWhitespace(str.charAt(i))) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns either the passed in String, or if the String is whitespace, empty (\"\") or null, the value of defaultStr.\n+     *\n+     * @param str the String to check, may be null\n+     * @param defaultStr the default String to return\n+     * @return the passed in String, or the default\n+     */\n+    public static String defaultIfBlank(String str, String defaultStr) {\n+        return StringUtil.isBlank(str) ? defaultStr : str;\n+    }\n+\n+    /**\n+     * Strips whitespace from the start and end of a String returning null if the String is empty (\"\") after the strip.\n+     *\n+     * @param str the String to be stripped, may be null\n+     * @return the stripped String, null if whitespace, empty or null String input\n+     */\n+    public static @Nullable String stripToNull(@Nullable String str) {\n+        if (str == null || str.length() == 0) {", "originalCommit": "7793a4f48ce3b905430b78b943996752b41d59d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYyNTQ5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r431625493", "bodyText": "Need to return the trimmed string, so just left if (str == null) { return null; } and changed the rest to use trim() and isEmpty(). Thanks", "author": "MrRonfo", "createdAt": "2020-05-28T07:09:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0NzI5NQ=="}], "type": "inlineReview"}, {"oid": "5c671cc66c8d8a0c0c06e1973c7c34c370a8f774", "url": "https://github.com/openhab/openhab-addons/commit/5c671cc66c8d8a0c0c06e1973c7c34c370a8f774", "message": "Aligned pom.xml to OH 2.5.6 snapshot\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-05-29T19:16:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2NzkxMg==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r432967912", "bodyText": "Can you make these Nullable?", "author": "fwolter", "createdAt": "2020-05-31T17:36:57Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherModuleHandler.java", "diffHunk": "@@ -0,0 +1,661 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.scheduler.CronScheduler;\n+import org.eclipse.smarthome.core.scheduler.ScheduledCompletableFuture;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.api.dto.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.Mode;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherSubscriptionAlreadyExistsException;\n+import org.openhab.binding.smarther.internal.config.SmartherModuleConfiguration;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherModuleHandler} class is responsible of a single Smarther Chronothermostat, handling the commands\n+ * that are sent to one of its channels.\n+ * Each Smarther Chronothermostat communicates with the Smarther API via its assigned {@code SmartherBridgeHandler}.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherModuleHandler extends BaseThingHandler {\n+\n+    private static final String DAILY_MIDNIGHT = \"1 0 0 * * ? *\";\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final CronScheduler cronScheduler;\n+    private final SmartherDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ChannelUID programChannelUID;\n+    private final ChannelUID endDateChannelUID;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) ScheduledCompletableFuture<Void> jobFuture;\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) SmartherBridgeHandler bridgeHandler;\n+    private @NonNullByDefault({}) SmartherModuleConfiguration config;\n+\n+    // Chronothermostat local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Program>> programCache;\n+    private @NonNullByDefault({}) Chronothermostat chronothermostat;\n+    private @NonNullByDefault({}) ModuleSettings moduleSettings;", "originalCommit": "88eb92825089dd1210be50cbdee1c754431c8736", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0Nzk5OA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r433147998", "bodyText": "What is the intent and best practice around these?\nI can make the chronothermostat object Nullable. The others are actually created in the Initialize method (jobFuture, pollFuture, programCache, moduleSettings) and have no reason to be null, or are directly set by the OH platform (bridgeHandler, config).", "author": "MrRonfo", "createdAt": "2020-06-01T10:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2NzkxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ4NzAwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r433487002", "bodyText": "I have had seen invocations of handleCommand() before initialize() has been finished. I opened a thread, if this is intended behavior: https://community.openhab.org/t/invocation-of-handlecommand-before-initializing-has-finished/99956", "author": "fwolter", "createdAt": "2020-06-01T20:59:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2NzkxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5NDI0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r433494247", "bodyText": "Hmmm, it shouldn't be a correct behaviour in my opinion, I'd expect the thing to start accepting commands only after initialize() has finished. However, let's see what others will say in the thread \ud83d\ude09", "author": "MrRonfo", "createdAt": "2020-06-01T21:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2NzkxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxMzk0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r433513942", "bodyText": "Result of the thread is that handleCommand() can be invoked after the thing status has been updated to ONLINE, OFFLINE or UNKNOWN. So, you should move updateStatus(ThingStatus.UNKNOWN) behind scheduling of the timer tasks.", "author": "fwolter", "createdAt": "2020-06-01T22:01:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2NzkxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2OTg1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r433669853", "bodyText": "Noted. I've moved it forward accordingly on SmartherBridgeHandler:\n\nlocationCache = new ExpiringCache<>(Duration.ofMinutes(config.getStatusRefreshPeriod()), this::locationCacheAction);\nbridgeStatus = new BridgeStatus();\nupdateStatus(ThingStatus.UNKNOWN);\nschedulePoll();\n\nWhile on SmartherModuleHandler I believe the following to be correct:\n\nprogramCache = new ExpiringCache<>(Duration.ofHours(config.getProgramsRefreshPeriod()), this::programCacheAction);\nmoduleSettings = new ModuleSettings(config.getPlantId(), config.getModuleId());\nupdateStatus(ThingStatus.UNKNOWN);\nscheduleJob();\nschedulePoll();\n\nAs there should be no issue in eventually calling handleCommand() before timed tasks are started with scheduleJob() and schedulePoll(), not affected by a command.", "author": "MrRonfo", "createdAt": "2020-06-02T07:20:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2NzkxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAyMDMzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r434020336", "bodyText": "Yes, since you're doing a null check in dispose() it should be ok.", "author": "fwolter", "createdAt": "2020-06-02T16:40:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2NzkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2ODE1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r432968155", "bodyText": "You should validate the command content before passing it to any fromValue OR make SmartherIllegalPropertyValueException also a checked exception and catch it here.", "author": "fwolter", "createdAt": "2020-05-31T17:40:22Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherModuleHandler.java", "diffHunk": "@@ -0,0 +1,661 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.scheduler.CronScheduler;\n+import org.eclipse.smarthome.core.scheduler.ScheduledCompletableFuture;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.api.dto.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.Mode;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherSubscriptionAlreadyExistsException;\n+import org.openhab.binding.smarther.internal.config.SmartherModuleConfiguration;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherModuleHandler} class is responsible of a single Smarther Chronothermostat, handling the commands\n+ * that are sent to one of its channels.\n+ * Each Smarther Chronothermostat communicates with the Smarther API via its assigned {@code SmartherBridgeHandler}.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherModuleHandler extends BaseThingHandler {\n+\n+    private static final String DAILY_MIDNIGHT = \"1 0 0 * * ? *\";\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final CronScheduler cronScheduler;\n+    private final SmartherDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ChannelUID programChannelUID;\n+    private final ChannelUID endDateChannelUID;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) ScheduledCompletableFuture<Void> jobFuture;\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) SmartherBridgeHandler bridgeHandler;\n+    private @NonNullByDefault({}) SmartherModuleConfiguration config;\n+\n+    // Chronothermostat local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Program>> programCache;\n+    private @NonNullByDefault({}) Chronothermostat chronothermostat;\n+    private @NonNullByDefault({}) ModuleSettings moduleSettings;\n+\n+    /**\n+     * Constructs a {@code SmartherModuleHandler} for the given thing, scheduler and dynamic state description provider.\n+     *\n+     * @param thing\n+     *            the {@link Thing} thing to be used\n+     * @param scheduler\n+     *            the {@link CronScheduler} periodic job scheduler to be used\n+     * @param provider\n+     *            the {@link SmartherDynamicStateDescriptionProvider} dynamic state description provider to be used\n+     */\n+    public SmartherModuleHandler(Thing thing, CronScheduler scheduler,\n+            SmartherDynamicStateDescriptionProvider provider) {\n+        super(thing);\n+        this.cronScheduler = scheduler;\n+        this.dynamicStateDescriptionProvider = provider;\n+        this.programChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_PROGRAM);\n+        this.endDateChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_ENDDATE);\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Chronothermostat thing lifecycle management methods\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Module[{}] Initialize handler\", thing.getUID());\n+\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        bridgeHandler = (SmartherBridgeHandler) bridge.getHandler();\n+        if (bridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, String.format(\n+                    \"Missing configuration from the Smarther Bridge (UID:%s). Fix configuration or report if this problem remains.\",\n+                    bridge.getBridgeUID()));\n+            return;\n+        }\n+\n+        config = getConfigAs(SmartherModuleConfiguration.class);\n+        if (StringUtil.isBlank(config.getPlantId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Plant Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.getModuleId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getProgramsRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Programs Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getStatusRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Status Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        programCache = new ExpiringCache<>(Duration.ofHours(config.getProgramsRefreshPeriod()),\n+                this::programCacheAction);\n+        moduleSettings = new ModuleSettings(config.getPlantId(), config.getModuleId());\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleJob();\n+        schedulePoll();\n+\n+        logger.debug(\"Module[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        try {\n+            handleCommandInternal(channelUID, command);\n+\n+            updateModuleStatus();\n+        } catch (SmartherGatewayException ex) {\n+            // catch exceptions and handle it in your binding\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, ex.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Handles the command sent to a given Channel of this Chronothermostat.\n+     *\n+     * @param channelUID\n+     *            the identifier of the Channel\n+     * @param command\n+     *            the command sent to the given Channel\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API\n+     */\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws SmartherGatewayException {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SETTINGS_MODE:\n+                if (command instanceof StringType) {\n+                    moduleSettings.setMode(Mode.fromValue(command.toString()));", "originalCommit": "88eb92825089dd1210be50cbdee1c754431c8736", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIwOTM3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r433209371", "bodyText": "As the device should never send an illegal property, I made the SmartherIllegalPropertyValueException a checked exception and changed the code to take this error case into account, eventually logging a warning where needed.", "author": "MrRonfo", "createdAt": "2020-06-01T12:38:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2ODE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2ODYxMA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r432968610", "bodyText": "This exception is never catched. You could log it and simply return. Then, you could remove this (unchecked) exception completely. If you're fancy, you could respond with a 500 Internal Server Error additionally.", "author": "fwolter", "createdAt": "2020-05-31T17:45:55Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherNotificationServlet.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherNotificationException;\n+import org.openhab.binding.smarther.internal.util.ModelUtil;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+/**\n+ * The {@code SmartherNotificationServlet} class acts as the registered endpoint to receive module status notifications\n+ * from the Legrand/Bticino C2C Webhook notification service.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherNotificationServlet extends HttpServlet {\n+\n+    private static final long serialVersionUID = -2474355132186048438L;\n+\n+    private static final String CONTENT_TYPE = \"application/json;charset=UTF-8\";\n+    private static final String OK_RESULT_MSG = \"{\\\"result\\\":0}\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final SmartherAccountService accountService;\n+\n+    /**\n+     * Constructs a {@code SmartherNotificationServlet} associated to the given {@link SmartherAccountService} service.\n+     *\n+     * @param accountService\n+     *            the account service to associate to the servlet\n+     */\n+    public SmartherNotificationServlet(SmartherAccountService accountService) {\n+        this.accountService = accountService;\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req == null || resp == null) {\n+            throw new SmartherNotificationException(\"Notification callback with null request/response\");", "originalCommit": "88eb92825089dd1210be50cbdee1c754431c8736", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2NDIxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r433164219", "bodyText": "Indeed :) Changed to return a http 400 Bad Request in case of no request object, or throw a ServletException in case of no response object (as I cannot return any response in this case).\nSame for SmartherAuthorizationServlet.", "author": "MrRonfo", "createdAt": "2020-06-01T10:44:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2ODYxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2OTA2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r432969062", "bodyText": "It's implicitly derived from DiscoveryService via AbstractDiscoveryService.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class SmartherModuleDiscoveryService extends AbstractDiscoveryService\n          \n          \n            \n                    implements DiscoveryService, ThingHandlerService {\n          \n          \n            \n            public class SmartherModuleDiscoveryService extends AbstractDiscoveryService\n          \n          \n            \n                    implements ThingHandlerService {", "author": "fwolter", "createdAt": "2020-05-31T17:51:30Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/discovery/SmartherModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.discovery;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.api.dto.Location;\n+import org.openhab.binding.smarther.internal.api.dto.Module;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherModuleDiscoveryService} queries the Smarther API gateway to discover available Chronothermostat\n+ * modules inside existing plants registered under the configured Bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.smarther\")\n+@NonNullByDefault\n+public class SmartherModuleDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {", "originalCommit": "88eb92825089dd1210be50cbdee1c754431c8736", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY2NDg4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r437664881", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return (programs != null) ? programs : new ArrayList<>();\n          \n          \n            \n                    return (programs != null) ? programs : Collections.emptyList();", "author": "cpmeister", "createdAt": "2020-06-09T19:24:26Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/dto/Chronothermostat.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api.dto;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.LoadState;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.MeasureUnit;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherIllegalPropertyValueException;\n+import org.openhab.binding.smarther.internal.util.DateUtil;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * The {@code Chronothermostat} class defines the dto for Smarther API chronothermostat object.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+public class Chronothermostat {\n+\n+    private static final String TIME_FOREVER = \"Forever\";\n+\n+    private String function;\n+    private String mode;\n+    @SerializedName(\"setPoint\")\n+    private Measure setPointTemperature;\n+    private List<Program> programs;\n+    @SerializedName(\"temperatureFormat\")\n+    private String temperatureFormat;\n+    @SerializedName(\"loadState\")\n+    private String loadState;\n+    @SerializedName(\"activationTime\")\n+    private String activationTime;\n+    private String time;\n+    private Sensor thermometer;\n+    private Sensor hygrometer;\n+    private boolean online;\n+    private Sender sender;\n+\n+    /**\n+     * Returns the operational function of this chronothermostat module.\n+     *\n+     * @return a string containing the module operational function\n+     */\n+    public String getFunction() {\n+        return function;\n+    }\n+\n+    /**\n+     * Returns the operational mode of this chronothermostat module.\n+     *\n+     * @return a string containing the module operational mode\n+     */\n+    public String getMode() {\n+        return mode;\n+    }\n+\n+    /**\n+     * Returns the operational setpoint temperature of this chronothermostat module.\n+     *\n+     * @return a {@link Measure} object representing the module operational setpoint temperature\n+     */\n+    public Measure getSetPointTemperature() {\n+        return setPointTemperature;\n+    }\n+\n+    /**\n+     * Returns the list of programs registered on this chronothermostat module.\n+     *\n+     * @return the list of registered programs, or an empty list in case of no programs available\n+     */\n+    public List<Program> getPrograms() {\n+        return (programs != null) ? programs : new ArrayList<>();", "originalCommit": "ae593650e21d2592486a7e36653f6f7345c1fd40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3MDUxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r437670513", "bodyText": "ThingHandlerService instances should not be osgi components. Osgi components are singletons whereas a new ThingHandlerService instance is created for each handler that uses it as a services. So pick one or the other.", "author": "cpmeister", "createdAt": "2020-06-09T19:35:19Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/discovery/SmartherModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.discovery;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.api.dto.Location;\n+import org.openhab.binding.smarther.internal.api.dto.Module;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherModuleDiscoveryService} queries the Smarther API gateway to discover available Chronothermostat\n+ * modules inside existing plants registered under the configured Bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.smarther\")\n+@NonNullByDefault\n+public class SmartherModuleDiscoveryService extends AbstractDiscoveryService implements ThingHandlerService {", "originalCommit": "ae593650e21d2592486a7e36653f6f7345c1fd40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU3ODU4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r438578586", "bodyText": "Picked up the ThingHandlerService instance option, thanks", "author": "MrRonfo", "createdAt": "2020-06-11T06:54:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3MDUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3MjUwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r437672504", "bodyText": "Use of @NonNullByDefault({}) should be avoided wherever possible. I suggest populating these fields in through the SmartherHandlerFactory constructor and then making these fields final.", "author": "cpmeister", "createdAt": "2020-06-09T19:39:04Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/factory/SmartherHandlerFactory.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.factory;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthFactory;\n+import org.eclipse.smarthome.core.scheduler.CronScheduler;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.smarther.internal.SmartherBindingConstants;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountService;\n+import org.openhab.binding.smarther.internal.handler.SmartherBridgeHandler;\n+import org.openhab.binding.smarther.internal.handler.SmartherDynamicStateDescriptionProvider;\n+import org.openhab.binding.smarther.internal.handler.SmartherModuleHandler;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@code SmartherHandlerFactory} class is responsible for creating things and thing handlers.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = ThingHandlerFactory.class, configurationPid = \"binding.smarther\")\n+@NonNullByDefault\n+public class SmartherHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private @NonNullByDefault({}) OAuthFactory oAuthFactory;\n+    private @NonNullByDefault({}) SmartherAccountService authService;\n+    private @NonNullByDefault({}) HttpClient httpClient;\n+    private @NonNullByDefault({}) CronScheduler cronScheduler;\n+    private @NonNullByDefault({}) SmartherDynamicStateDescriptionProvider dynamicStateDescriptionProvider;", "originalCommit": "ae593650e21d2592486a7e36653f6f7345c1fd40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4MTA4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r437681088", "bodyText": "Please avoid using @NonNullByDefault({}). Use @Nullable instead. Most of the null checker warnings can be resolved by caching the fields to local variables and performing your logic on those local variables instead.", "author": "cpmeister", "createdAt": "2020-06-09T19:55:19Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherBridgeHandler.java", "diffHunk": "@@ -0,0 +1,699 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthFactory;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.account.SmartherNotificationHandler;\n+import org.openhab.binding.smarther.internal.api.SmartherApi;\n+import org.openhab.binding.smarther.internal.api.dto.Location;\n+import org.openhab.binding.smarther.internal.api.dto.Module;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Plant;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.dto.Subscription;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.config.SmartherBridgeConfiguration;\n+import org.openhab.binding.smarther.internal.discovery.SmartherModuleDiscoveryService;\n+import org.openhab.binding.smarther.internal.model.BridgeStatus;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherBridgeHandler} class is responsible of the handling of a Smarther Bridge thing.\n+ * The Smarther Bridge is used to manage a set of Smarther Chronothermostat Modules registered under the same\n+ * Legrand/Bticino account credentials.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherBridgeHandler extends BaseBridgeHandler\n+        implements SmartherAccountHandler, SmartherNotificationHandler, AccessTokenRefreshListener {\n+\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HttpClient httpClient;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) OAuthClientService oAuthService;\n+    private @NonNullByDefault({}) SmartherApi smartherApi;\n+    private @NonNullByDefault({}) SmartherBridgeConfiguration config;\n+\n+    // Bridge local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Location>> locationCache;\n+    private @NonNullByDefault({}) BridgeStatus bridgeStatus;", "originalCommit": "ae593650e21d2592486a7e36653f6f7345c1fd40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU3OTk3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r438579975", "bodyText": "Thanks, same suggested changes I've applied them to SmartherModuleHandler as well.", "author": "MrRonfo", "createdAt": "2020-06-11T06:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4MTA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1MTE3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439151172", "bodyText": "No need to parse a config you shouldn't use.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.config = getConfigAs(SmartherBridgeConfiguration.class);\n          \n          \n            \n                    this.config = new SmartherBridgeConfiguration();", "author": "cpmeister", "createdAt": "2020-06-12T00:52:44Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherBridgeHandler.java", "diffHunk": "@@ -0,0 +1,767 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthFactory;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.account.SmartherNotificationHandler;\n+import org.openhab.binding.smarther.internal.api.SmartherApi;\n+import org.openhab.binding.smarther.internal.api.dto.Location;\n+import org.openhab.binding.smarther.internal.api.dto.Module;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Plant;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.dto.Subscription;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.config.SmartherBridgeConfiguration;\n+import org.openhab.binding.smarther.internal.discovery.SmartherModuleDiscoveryService;\n+import org.openhab.binding.smarther.internal.model.BridgeStatus;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherBridgeHandler} class is responsible of the handling of a Smarther Bridge thing.\n+ * The Smarther Bridge is used to manage a set of Smarther Chronothermostat Modules registered under the same\n+ * Legrand/Bticino account credentials.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherBridgeHandler extends BaseBridgeHandler\n+        implements SmartherAccountHandler, SmartherNotificationHandler, AccessTokenRefreshListener {\n+\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HttpClient httpClient;\n+\n+    // Bridge configuration\n+    private SmartherBridgeConfiguration config;\n+\n+    // Field members assigned in initialize method\n+    private @Nullable Future<?> pollFuture;\n+    private @Nullable OAuthClientService oAuthService;\n+    private @Nullable SmartherApi smartherApi;\n+    private @Nullable ExpiringCache<List<Location>> locationCache;\n+    private @Nullable BridgeStatus bridgeStatus;\n+\n+    /**\n+     * Constructs a {@code SmartherBridgeHandler} for the given Bridge thing, authorization factory and http client.\n+     *\n+     * @param bridge\n+     *            the {@link Bridge} thing to be used\n+     * @param oAuthFactory\n+     *            the OAuth2 authorization factory to be used\n+     * @param httpClient\n+     *            the http client to be used\n+     */\n+    public SmartherBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HttpClient httpClient) {\n+        super(bridge);\n+        this.oAuthFactory = oAuthFactory;\n+        this.httpClient = httpClient;\n+        this.config = getConfigAs(SmartherBridgeConfiguration.class);", "originalCommit": "b76ea0c1193e57298bdea1f8bcae9b3f10b90950", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1MTc5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439151799", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return (locations != null) ? locations : new ArrayList<>();\n          \n          \n            \n                    return (locations != null) ? locations : Collections.emptyList();", "author": "cpmeister", "createdAt": "2020-06-12T00:55:22Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherBridgeHandler.java", "diffHunk": "@@ -0,0 +1,767 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthFactory;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.account.SmartherNotificationHandler;\n+import org.openhab.binding.smarther.internal.api.SmartherApi;\n+import org.openhab.binding.smarther.internal.api.dto.Location;\n+import org.openhab.binding.smarther.internal.api.dto.Module;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Plant;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.dto.Subscription;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.config.SmartherBridgeConfiguration;\n+import org.openhab.binding.smarther.internal.discovery.SmartherModuleDiscoveryService;\n+import org.openhab.binding.smarther.internal.model.BridgeStatus;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherBridgeHandler} class is responsible of the handling of a Smarther Bridge thing.\n+ * The Smarther Bridge is used to manage a set of Smarther Chronothermostat Modules registered under the same\n+ * Legrand/Bticino account credentials.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherBridgeHandler extends BaseBridgeHandler\n+        implements SmartherAccountHandler, SmartherNotificationHandler, AccessTokenRefreshListener {\n+\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HttpClient httpClient;\n+\n+    // Bridge configuration\n+    private SmartherBridgeConfiguration config;\n+\n+    // Field members assigned in initialize method\n+    private @Nullable Future<?> pollFuture;\n+    private @Nullable OAuthClientService oAuthService;\n+    private @Nullable SmartherApi smartherApi;\n+    private @Nullable ExpiringCache<List<Location>> locationCache;\n+    private @Nullable BridgeStatus bridgeStatus;\n+\n+    /**\n+     * Constructs a {@code SmartherBridgeHandler} for the given Bridge thing, authorization factory and http client.\n+     *\n+     * @param bridge\n+     *            the {@link Bridge} thing to be used\n+     * @param oAuthFactory\n+     *            the OAuth2 authorization factory to be used\n+     * @param httpClient\n+     *            the http client to be used\n+     */\n+    public SmartherBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HttpClient httpClient) {\n+        super(bridge);\n+        this.oAuthFactory = oAuthFactory;\n+        this.httpClient = httpClient;\n+        this.config = getConfigAs(SmartherBridgeConfiguration.class);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(SmartherModuleDiscoveryService.class);\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge thing lifecycle management methods\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Bridge[{}] Initialize handler\", thing.getUID());\n+\n+        this.config = getConfigAs(SmartherBridgeConfiguration.class);\n+        if (StringUtil.isBlank(config.getSubscriptionKey())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Subscription Key' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.getClientId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.getClientSecret())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Secret' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        // Initialize OAuth2 authentication support\n+        final OAuthClientService localOAuthService = oAuthFactory.createOAuthClientService(thing.getUID().getAsString(),\n+                SMARTHER_API_TOKEN_URL, SMARTHER_AUTHORIZE_URL, config.getClientId(), config.getClientSecret(),\n+                SMARTHER_API_SCOPES, false);\n+        localOAuthService.addAccessTokenRefreshListener(SmartherBridgeHandler.this);\n+        this.oAuthService = localOAuthService;\n+\n+        // Initialize Smarther Api\n+        final SmartherApi localSmartherApi = new SmartherApi(localOAuthService, config.getSubscriptionKey(), scheduler,\n+                httpClient);\n+        this.smartherApi = localSmartherApi;\n+\n+        // Initialize locations (plant Ids) local cache\n+        final ExpiringCache<List<Location>> localLocationCache = new ExpiringCache<>(\n+                Duration.ofMinutes(config.getStatusRefreshPeriod()), this::locationCacheAction);\n+        this.locationCache = localLocationCache;\n+\n+        // Initialize bridge local status\n+        final BridgeStatus localBridgeStatus = new BridgeStatus();\n+        this.bridgeStatus = localBridgeStatus;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        schedulePoll();\n+\n+        logger.debug(\"Bridge[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Bridge[{}] Manually triggered channel to refresh the Bridge config\",\n+                                thing.getUID());\n+                        schedulePoll();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Bridge[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Bridge[{}] Dispose handler\", thing.getUID());\n+        final OAuthClientService localOAuthService = this.oAuthService;\n+        if (localOAuthService != null) {\n+            localOAuthService.removeAccessTokenRefreshListener(this);\n+        }\n+        this.oAuthFactory.ungetOAuthService(thing.getUID().getAsString());\n+        stopPoll(true);\n+        logger.debug(\"Bridge[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge data cache management methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Returns the available locations to be cached for this Bridge.\n+     *\n+     * @return the available locations to be cached for this Bridge, or {@code null} if the list of available locations\n+     *         cannot be retrieved\n+     */\n+    private @Nullable List<Location> locationCacheAction() {\n+        try {\n+            // Retrieve the plants list from the API Gateway\n+            final List<Plant> plants = getPlants();\n+\n+            List<Location> locations;\n+            if (config.isUseNotifications()) {\n+                // Retrieve the subscriptions list from the API Gateway\n+                final List<Subscription> subscriptions = getSubscriptions();\n+\n+                // Enrich the notifications list with externally registered subscriptions\n+                updateNotifications(subscriptions);\n+\n+                // Get the notifications list from bridge config\n+                final List<String> notifications = config.getNotifications();\n+\n+                locations = plants.stream().map(p -> Location.fromPlant(p, subscriptions.stream()\n+                        .filter(s -> s.getPlantId().equals(p.getId()) && notifications.contains(s.getSubscriptionId()))\n+                        .findFirst())).collect(Collectors.toList());\n+            } else {\n+                locations = plants.stream().map(p -> Location.fromPlant(p)).collect(Collectors.toList());\n+            }\n+            logger.debug(\"Bridge[{}] Available locations: {}\", thing.getUID(), locations);\n+\n+            return locations;\n+\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Bridge[{}] Cannot retrieve available locations: {}\", thing.getUID(), e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Updates this Bridge local notifications list with externally registered subscriptions.\n+     *\n+     * @param subscriptions\n+     *            the externally registered subscriptions to be added to the local notifications list\n+     */\n+    private void updateNotifications(List<Subscription> subscriptions) {\n+        // Get the notifications list from bridge config\n+        List<String> notifications = config.getNotifications();\n+\n+        for (Subscription s : subscriptions) {\n+            if (s.getEndpointUrl().equalsIgnoreCase(config.getNotificationUrl())\n+                    && !notifications.contains(s.getSubscriptionId())) {\n+                // Add the external subscription to notifications list\n+                notifications = config.addNotification(s.getSubscriptionId());\n+\n+                // Save the updated notifications list back to bridge config\n+                Configuration configuration = editConfiguration();\n+                configuration.put(PROPERTY_NOTIFICATIONS, notifications);\n+                updateConfiguration(configuration);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets all the cache to \"expired\" for this Bridge.\n+     */\n+    private void expireCache() {\n+        logger.debug(\"Bridge[{}] Invalidating location cache\", thing.getUID());\n+        final ExpiringCache<List<Location>> localLocationCache = this.locationCache;\n+        if (localLocationCache != null) {\n+            localLocationCache.invalidateValue();\n+        }\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge status polling mechanism methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Starts a new scheduler to periodically poll and update this Bridge status.\n+     */\n+    private void schedulePoll() {\n+        stopPoll(false);\n+\n+        // Schedule poll to start after POLL_INITIAL_DELAY sec and run periodically based on status refresh period\n+        final Future<?> localPollFuture = scheduler.scheduleWithFixedDelay(this::poll, POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod() * 60, TimeUnit.SECONDS);\n+        this.pollFuture = localPollFuture;\n+\n+        logger.debug(\"Bridge[{}] Scheduled poll for {} sec out, then every {} min\", thing.getUID(), POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod());\n+    }\n+\n+    /**\n+     * Cancels all running poll schedulers.\n+     *\n+     * @param mayInterruptIfRunning\n+     *            {@code true} if the thread executing this task should be interrupted, {@code false} if the in-progress\n+     *            tasks are allowed to complete\n+     */\n+    private synchronized void stopPoll(boolean mayInterruptIfRunning) {\n+        final Future<?> localPollFuture = this.pollFuture;\n+        if (localPollFuture != null) {\n+            if (!localPollFuture.isCancelled()) {\n+                localPollFuture.cancel(mayInterruptIfRunning);\n+            }\n+            this.pollFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Polls to update this Bridge status, calling the Smarther API to refresh its plants list.\n+     *\n+     * @return {@code true} if the method completes without errors, {@code false} otherwise\n+     */\n+    private synchronized boolean poll() {\n+        try {\n+            onAccessTokenResponse(getAccessTokenResponse());\n+\n+            expireCache();\n+            locationCacheAction();\n+\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+\n+        } catch (SmartherAuthorizationException e) {\n+            logger.warn(\"Bridge[{}] Authorization error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (RuntimeException e) {\n+            // All other exceptions apart from Authorization and Gateway issues\n+            logger.warn(\"Bridge[{}] Unexpected error during polling, please report if this keeps occurring: \",\n+                    thing.getUID(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public void onAccessTokenResponse(@Nullable AccessTokenResponse tokenResponse) {\n+        updateChannelState(CHANNEL_ACCESS_TOKEN,\n+                new StringType((tokenResponse == null) ? null : tokenResponse.getAccessToken()));\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge convenience methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Convenience method to get this Bridge configuration.\n+     *\n+     * @return a {@link SmartherBridgeConfiguration} object containing the Bridge configuration\n+     */\n+    public SmartherBridgeConfiguration getSmartherBridgeConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Convenience method to get the access token from Smarther API authorization layer.\n+     *\n+     * @return the autorization access token, may be {@code null}\n+     *\n+     * @throws {@link SmartherAuthorizationException}\n+     *             in case of authorization issues with the Smarther API\n+     */\n+    private @Nullable AccessTokenResponse getAccessTokenResponse() throws SmartherAuthorizationException {\n+        try {\n+            final OAuthClientService localOAuthService = this.oAuthService;\n+            if (localOAuthService != null) {\n+                return localOAuthService.getAccessTokenResponse();\n+            }\n+            return null;\n+        } catch (OAuthException | IOException | OAuthResponseException | RuntimeException e) {\n+            throw new SmartherAuthorizationException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to update the given Channel state \"only\" if the Channel is linked.\n+     *\n+     * @param channelId\n+     *            the identifier of the Channel to be updated\n+     * @param state\n+     *            the new state to be applied to the given Channel\n+     */\n+    private void updateChannelState(String channelId, State state) {\n+        final Channel channel = thing.getChannel(channelId);\n+\n+        if (channel != null && isLinked(channel.getUID())) {\n+            updateState(channel.getUID(), state);\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to update the Smarther API calls counter for this Bridge.\n+     */\n+    private void updateApiCallsCounter() {\n+        final BridgeStatus localBridgeStatus = this.bridgeStatus;\n+        if (localBridgeStatus != null) {\n+            updateChannelState(CHANNEL_API_CALLS_HANDLED,\n+                    new DecimalType(localBridgeStatus.incrementApiCallsHandled()));\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to check and get the Smarther API instance for this Bridge.\n+     *\n+     * @return the Smarther API instance\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case the Smarther API instance is {@code null}\n+     */\n+    private SmartherApi getSmartherApi() throws SmartherGatewayException {\n+        final SmartherApi localSmartherApi = this.smartherApi;\n+        if (localSmartherApi == null) {\n+            throw new SmartherGatewayException(\"Smarther API instance is null\");\n+        }\n+        return localSmartherApi;\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Implementation of the SmartherAccountHandler interface\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public ThingUID getUID() {\n+        return thing.getUID();\n+    }\n+\n+    @Override\n+    public String getLabel() {\n+        return StringUtil.defaultString(thing.getLabel());\n+    }\n+\n+    @Override\n+    public List<Location> getLocations() {\n+        final ExpiringCache<List<Location>> localLocationCache = this.locationCache;\n+        final List<Location> locations = (localLocationCache != null) ? localLocationCache.getValue() : null;\n+        return (locations != null) ? locations : new ArrayList<>();", "originalCommit": "b76ea0c1193e57298bdea1f8bcae9b3f10b90950", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMzODkzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439338937", "bodyText": "Indeed, the result of getLocations() is only accessed and never gets manipulated. Thanks for having spotted this.", "author": "MrRonfo", "createdAt": "2020-06-12T10:30:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1MTc5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1MjAwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439152000", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return \"\";\n          \n          \n            \n                    } catch (OAuthException e) {\n          \n          \n            \n                        logger.warn(\"Bridge[{}] Error constructing AuthorizationUrl: \", thing.getUID());\n          \n          \n            \n                        return \"\";\n          \n          \n            \n                    }\n          \n          \n            \n                    } catch (OAuthException e) {\n          \n          \n            \n                        logger.warn(\"Bridge[{}] Error constructing AuthorizationUrl: \", thing.getUID());\n          \n          \n            \n                    }\n          \n          \n            \n                    return \"\";", "author": "cpmeister", "createdAt": "2020-06-12T00:56:06Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherBridgeHandler.java", "diffHunk": "@@ -0,0 +1,767 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthFactory;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.account.SmartherNotificationHandler;\n+import org.openhab.binding.smarther.internal.api.SmartherApi;\n+import org.openhab.binding.smarther.internal.api.dto.Location;\n+import org.openhab.binding.smarther.internal.api.dto.Module;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Plant;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.dto.Subscription;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.config.SmartherBridgeConfiguration;\n+import org.openhab.binding.smarther.internal.discovery.SmartherModuleDiscoveryService;\n+import org.openhab.binding.smarther.internal.model.BridgeStatus;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherBridgeHandler} class is responsible of the handling of a Smarther Bridge thing.\n+ * The Smarther Bridge is used to manage a set of Smarther Chronothermostat Modules registered under the same\n+ * Legrand/Bticino account credentials.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherBridgeHandler extends BaseBridgeHandler\n+        implements SmartherAccountHandler, SmartherNotificationHandler, AccessTokenRefreshListener {\n+\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HttpClient httpClient;\n+\n+    // Bridge configuration\n+    private SmartherBridgeConfiguration config;\n+\n+    // Field members assigned in initialize method\n+    private @Nullable Future<?> pollFuture;\n+    private @Nullable OAuthClientService oAuthService;\n+    private @Nullable SmartherApi smartherApi;\n+    private @Nullable ExpiringCache<List<Location>> locationCache;\n+    private @Nullable BridgeStatus bridgeStatus;\n+\n+    /**\n+     * Constructs a {@code SmartherBridgeHandler} for the given Bridge thing, authorization factory and http client.\n+     *\n+     * @param bridge\n+     *            the {@link Bridge} thing to be used\n+     * @param oAuthFactory\n+     *            the OAuth2 authorization factory to be used\n+     * @param httpClient\n+     *            the http client to be used\n+     */\n+    public SmartherBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HttpClient httpClient) {\n+        super(bridge);\n+        this.oAuthFactory = oAuthFactory;\n+        this.httpClient = httpClient;\n+        this.config = getConfigAs(SmartherBridgeConfiguration.class);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(SmartherModuleDiscoveryService.class);\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge thing lifecycle management methods\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Bridge[{}] Initialize handler\", thing.getUID());\n+\n+        this.config = getConfigAs(SmartherBridgeConfiguration.class);\n+        if (StringUtil.isBlank(config.getSubscriptionKey())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Subscription Key' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.getClientId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.getClientSecret())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Secret' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        // Initialize OAuth2 authentication support\n+        final OAuthClientService localOAuthService = oAuthFactory.createOAuthClientService(thing.getUID().getAsString(),\n+                SMARTHER_API_TOKEN_URL, SMARTHER_AUTHORIZE_URL, config.getClientId(), config.getClientSecret(),\n+                SMARTHER_API_SCOPES, false);\n+        localOAuthService.addAccessTokenRefreshListener(SmartherBridgeHandler.this);\n+        this.oAuthService = localOAuthService;\n+\n+        // Initialize Smarther Api\n+        final SmartherApi localSmartherApi = new SmartherApi(localOAuthService, config.getSubscriptionKey(), scheduler,\n+                httpClient);\n+        this.smartherApi = localSmartherApi;\n+\n+        // Initialize locations (plant Ids) local cache\n+        final ExpiringCache<List<Location>> localLocationCache = new ExpiringCache<>(\n+                Duration.ofMinutes(config.getStatusRefreshPeriod()), this::locationCacheAction);\n+        this.locationCache = localLocationCache;\n+\n+        // Initialize bridge local status\n+        final BridgeStatus localBridgeStatus = new BridgeStatus();\n+        this.bridgeStatus = localBridgeStatus;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        schedulePoll();\n+\n+        logger.debug(\"Bridge[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Bridge[{}] Manually triggered channel to refresh the Bridge config\",\n+                                thing.getUID());\n+                        schedulePoll();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Bridge[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Bridge[{}] Dispose handler\", thing.getUID());\n+        final OAuthClientService localOAuthService = this.oAuthService;\n+        if (localOAuthService != null) {\n+            localOAuthService.removeAccessTokenRefreshListener(this);\n+        }\n+        this.oAuthFactory.ungetOAuthService(thing.getUID().getAsString());\n+        stopPoll(true);\n+        logger.debug(\"Bridge[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge data cache management methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Returns the available locations to be cached for this Bridge.\n+     *\n+     * @return the available locations to be cached for this Bridge, or {@code null} if the list of available locations\n+     *         cannot be retrieved\n+     */\n+    private @Nullable List<Location> locationCacheAction() {\n+        try {\n+            // Retrieve the plants list from the API Gateway\n+            final List<Plant> plants = getPlants();\n+\n+            List<Location> locations;\n+            if (config.isUseNotifications()) {\n+                // Retrieve the subscriptions list from the API Gateway\n+                final List<Subscription> subscriptions = getSubscriptions();\n+\n+                // Enrich the notifications list with externally registered subscriptions\n+                updateNotifications(subscriptions);\n+\n+                // Get the notifications list from bridge config\n+                final List<String> notifications = config.getNotifications();\n+\n+                locations = plants.stream().map(p -> Location.fromPlant(p, subscriptions.stream()\n+                        .filter(s -> s.getPlantId().equals(p.getId()) && notifications.contains(s.getSubscriptionId()))\n+                        .findFirst())).collect(Collectors.toList());\n+            } else {\n+                locations = plants.stream().map(p -> Location.fromPlant(p)).collect(Collectors.toList());\n+            }\n+            logger.debug(\"Bridge[{}] Available locations: {}\", thing.getUID(), locations);\n+\n+            return locations;\n+\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Bridge[{}] Cannot retrieve available locations: {}\", thing.getUID(), e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Updates this Bridge local notifications list with externally registered subscriptions.\n+     *\n+     * @param subscriptions\n+     *            the externally registered subscriptions to be added to the local notifications list\n+     */\n+    private void updateNotifications(List<Subscription> subscriptions) {\n+        // Get the notifications list from bridge config\n+        List<String> notifications = config.getNotifications();\n+\n+        for (Subscription s : subscriptions) {\n+            if (s.getEndpointUrl().equalsIgnoreCase(config.getNotificationUrl())\n+                    && !notifications.contains(s.getSubscriptionId())) {\n+                // Add the external subscription to notifications list\n+                notifications = config.addNotification(s.getSubscriptionId());\n+\n+                // Save the updated notifications list back to bridge config\n+                Configuration configuration = editConfiguration();\n+                configuration.put(PROPERTY_NOTIFICATIONS, notifications);\n+                updateConfiguration(configuration);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets all the cache to \"expired\" for this Bridge.\n+     */\n+    private void expireCache() {\n+        logger.debug(\"Bridge[{}] Invalidating location cache\", thing.getUID());\n+        final ExpiringCache<List<Location>> localLocationCache = this.locationCache;\n+        if (localLocationCache != null) {\n+            localLocationCache.invalidateValue();\n+        }\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge status polling mechanism methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Starts a new scheduler to periodically poll and update this Bridge status.\n+     */\n+    private void schedulePoll() {\n+        stopPoll(false);\n+\n+        // Schedule poll to start after POLL_INITIAL_DELAY sec and run periodically based on status refresh period\n+        final Future<?> localPollFuture = scheduler.scheduleWithFixedDelay(this::poll, POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod() * 60, TimeUnit.SECONDS);\n+        this.pollFuture = localPollFuture;\n+\n+        logger.debug(\"Bridge[{}] Scheduled poll for {} sec out, then every {} min\", thing.getUID(), POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod());\n+    }\n+\n+    /**\n+     * Cancels all running poll schedulers.\n+     *\n+     * @param mayInterruptIfRunning\n+     *            {@code true} if the thread executing this task should be interrupted, {@code false} if the in-progress\n+     *            tasks are allowed to complete\n+     */\n+    private synchronized void stopPoll(boolean mayInterruptIfRunning) {\n+        final Future<?> localPollFuture = this.pollFuture;\n+        if (localPollFuture != null) {\n+            if (!localPollFuture.isCancelled()) {\n+                localPollFuture.cancel(mayInterruptIfRunning);\n+            }\n+            this.pollFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Polls to update this Bridge status, calling the Smarther API to refresh its plants list.\n+     *\n+     * @return {@code true} if the method completes without errors, {@code false} otherwise\n+     */\n+    private synchronized boolean poll() {\n+        try {\n+            onAccessTokenResponse(getAccessTokenResponse());\n+\n+            expireCache();\n+            locationCacheAction();\n+\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+\n+        } catch (SmartherAuthorizationException e) {\n+            logger.warn(\"Bridge[{}] Authorization error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (RuntimeException e) {\n+            // All other exceptions apart from Authorization and Gateway issues\n+            logger.warn(\"Bridge[{}] Unexpected error during polling, please report if this keeps occurring: \",\n+                    thing.getUID(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public void onAccessTokenResponse(@Nullable AccessTokenResponse tokenResponse) {\n+        updateChannelState(CHANNEL_ACCESS_TOKEN,\n+                new StringType((tokenResponse == null) ? null : tokenResponse.getAccessToken()));\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge convenience methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Convenience method to get this Bridge configuration.\n+     *\n+     * @return a {@link SmartherBridgeConfiguration} object containing the Bridge configuration\n+     */\n+    public SmartherBridgeConfiguration getSmartherBridgeConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Convenience method to get the access token from Smarther API authorization layer.\n+     *\n+     * @return the autorization access token, may be {@code null}\n+     *\n+     * @throws {@link SmartherAuthorizationException}\n+     *             in case of authorization issues with the Smarther API\n+     */\n+    private @Nullable AccessTokenResponse getAccessTokenResponse() throws SmartherAuthorizationException {\n+        try {\n+            final OAuthClientService localOAuthService = this.oAuthService;\n+            if (localOAuthService != null) {\n+                return localOAuthService.getAccessTokenResponse();\n+            }\n+            return null;\n+        } catch (OAuthException | IOException | OAuthResponseException | RuntimeException e) {\n+            throw new SmartherAuthorizationException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to update the given Channel state \"only\" if the Channel is linked.\n+     *\n+     * @param channelId\n+     *            the identifier of the Channel to be updated\n+     * @param state\n+     *            the new state to be applied to the given Channel\n+     */\n+    private void updateChannelState(String channelId, State state) {\n+        final Channel channel = thing.getChannel(channelId);\n+\n+        if (channel != null && isLinked(channel.getUID())) {\n+            updateState(channel.getUID(), state);\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to update the Smarther API calls counter for this Bridge.\n+     */\n+    private void updateApiCallsCounter() {\n+        final BridgeStatus localBridgeStatus = this.bridgeStatus;\n+        if (localBridgeStatus != null) {\n+            updateChannelState(CHANNEL_API_CALLS_HANDLED,\n+                    new DecimalType(localBridgeStatus.incrementApiCallsHandled()));\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to check and get the Smarther API instance for this Bridge.\n+     *\n+     * @return the Smarther API instance\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case the Smarther API instance is {@code null}\n+     */\n+    private SmartherApi getSmartherApi() throws SmartherGatewayException {\n+        final SmartherApi localSmartherApi = this.smartherApi;\n+        if (localSmartherApi == null) {\n+            throw new SmartherGatewayException(\"Smarther API instance is null\");\n+        }\n+        return localSmartherApi;\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Implementation of the SmartherAccountHandler interface\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public ThingUID getUID() {\n+        return thing.getUID();\n+    }\n+\n+    @Override\n+    public String getLabel() {\n+        return StringUtil.defaultString(thing.getLabel());\n+    }\n+\n+    @Override\n+    public List<Location> getLocations() {\n+        final ExpiringCache<List<Location>> localLocationCache = this.locationCache;\n+        final List<Location> locations = (localLocationCache != null) ? localLocationCache.getValue() : null;\n+        return (locations != null) ? locations : new ArrayList<>();\n+    }\n+\n+    @Override\n+    public boolean hasLocation(String plantId) {\n+        final ExpiringCache<List<Location>> localLocationCache = this.locationCache;\n+        final List<Location> locations = (localLocationCache != null) ? localLocationCache.getValue() : null;\n+        return (locations != null) ? locations.stream().anyMatch(l -> l.getPlantId().equals(plantId)) : false;\n+    }\n+\n+    @Override\n+    public List<Plant> getPlants() throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().getPlants();\n+    }\n+\n+    @Override\n+    public List<Subscription> getSubscriptions() throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().getSubscriptions();\n+    }\n+\n+    @Override\n+    public String subscribePlant(String plantId, String notificationUrl) throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().subscribePlant(plantId, notificationUrl);\n+    }\n+\n+    @Override\n+    public void unsubscribePlant(String plantId, String subscriptionId) throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        getSmartherApi().unsubscribePlant(plantId, subscriptionId);\n+    }\n+\n+    @Override\n+    public List<Module> getLocationModules(Location location) {\n+        try {\n+            updateApiCallsCounter();\n+            return getSmartherApi().getPlantModules(location.getPlantId());\n+        } catch (SmartherGatewayException e) {\n+            return new ArrayList<>();\n+        }\n+    }\n+\n+    @Override\n+    public ModuleStatus getModuleStatus(String plantId, String moduleId) throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().getModuleStatus(plantId, moduleId);\n+    }\n+\n+    @Override\n+    public boolean setModuleStatus(ModuleSettings moduleSettings) throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().setModuleStatus(moduleSettings);\n+    }\n+\n+    @Override\n+    public List<Program> getModulePrograms(String plantId, String moduleId) throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().getModulePrograms(plantId, moduleId);\n+    }\n+\n+    @Override\n+    public boolean isAuthorized() {\n+        try {\n+            final AccessTokenResponse tokenResponse = getAccessTokenResponse();\n+            onAccessTokenResponse(tokenResponse);\n+\n+            return (tokenResponse != null && tokenResponse.getAccessToken() != null\n+                    && tokenResponse.getRefreshToken() != null);\n+        } catch (SmartherAuthorizationException e) {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOnline() {\n+        return (thing.getStatus() == ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public String authorize(String redirectUrl, String reqCode, String notificationUrl)\n+            throws SmartherGatewayException {\n+        try {\n+            logger.debug(\"Bridge[{}] Call API gateway to get access token. RedirectUri: {}\", thing.getUID(),\n+                    redirectUrl);\n+\n+            final OAuthClientService localOAuthService = this.oAuthService;\n+            if (localOAuthService == null) {\n+                throw new SmartherAuthorizationException(\"Authorization service is null\");\n+            }\n+\n+            // OAuth2 call to get access token from received authorization code\n+            localOAuthService.getAccessTokenResponseByAuthorizationCode(reqCode, redirectUrl);\n+\n+            // Store the notification URL in bridge configuration\n+            Configuration configuration = editConfiguration();\n+            configuration.put(PROPERTY_NOTIFICATION_URL, notificationUrl);\n+            updateConfiguration(configuration);\n+            config.setNotificationUrl(notificationUrl);\n+            logger.debug(\"Bridge[{}] Store notification URL: {}\", thing.getUID(), notificationUrl);\n+\n+            // Reschedule the polling thread\n+            schedulePoll();\n+\n+            return config.getClientId();\n+        } catch (OAuthResponseException e) {\n+            throw new SmartherAuthorizationException(e.toString(), e);\n+        } catch (OAuthException | IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            throw new SmartherGatewayException(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean equalsThingUID(String thingUID) {\n+        return thing.getUID().getAsString().equals(thingUID);\n+    }\n+\n+    @Override\n+    public String formatAuthorizationUrl(String redirectUri) {\n+        try {\n+            final OAuthClientService localOAuthService = this.oAuthService;\n+            if (localOAuthService != null) {\n+                return localOAuthService.getAuthorizationUrl(redirectUri, null, thing.getUID().getAsString());\n+            }\n+            return \"\";\n+        } catch (OAuthException e) {\n+            logger.warn(\"Bridge[{}] Error constructing AuthorizationUrl: \", thing.getUID());\n+            return \"\";\n+        }", "originalCommit": "b76ea0c1193e57298bdea1f8bcae9b3f10b90950", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1MzMxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439153313", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.config = getConfigAs(SmartherModuleConfiguration.class);\n          \n          \n            \n                    this.config = new SmartherModuleConfiguration();", "author": "cpmeister", "createdAt": "2020-06-12T01:01:11Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherModuleHandler.java", "diffHunk": "@@ -0,0 +1,733 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.scheduler.CronScheduler;\n+import org.eclipse.smarthome.core.scheduler.ScheduledCompletableFuture;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.api.dto.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.Mode;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherIllegalPropertyValueException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherSubscriptionAlreadyExistsException;\n+import org.openhab.binding.smarther.internal.config.SmartherModuleConfiguration;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherModuleHandler} class is responsible of a single Smarther Chronothermostat, handling the commands\n+ * that are sent to one of its channels.\n+ * Each Smarther Chronothermostat communicates with the Smarther API via its assigned {@code SmartherBridgeHandler}.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherModuleHandler extends BaseThingHandler {\n+\n+    private static final String DAILY_MIDNIGHT = \"1 0 0 * * ? *\";\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final CronScheduler cronScheduler;\n+    private final SmartherDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ChannelUID programChannelUID;\n+    private final ChannelUID endDateChannelUID;\n+\n+    // Module configuration\n+    private SmartherModuleConfiguration config;\n+\n+    // Field members assigned in initialize method\n+    private @Nullable ScheduledCompletableFuture<Void> jobFuture;\n+    private @Nullable Future<?> pollFuture;\n+    private @Nullable SmartherBridgeHandler bridgeHandler;\n+    private @Nullable ExpiringCache<List<Program>> programCache;\n+    private @Nullable ModuleSettings moduleSettings;\n+\n+    // Chronothermostat local status\n+    private @Nullable Chronothermostat chronothermostat;\n+\n+    /**\n+     * Constructs a {@code SmartherModuleHandler} for the given thing, scheduler and dynamic state description provider.\n+     *\n+     * @param thing\n+     *            the {@link Thing} thing to be used\n+     * @param scheduler\n+     *            the {@link CronScheduler} periodic job scheduler to be used\n+     * @param provider\n+     *            the {@link SmartherDynamicStateDescriptionProvider} dynamic state description provider to be used\n+     */\n+    public SmartherModuleHandler(Thing thing, CronScheduler scheduler,\n+            SmartherDynamicStateDescriptionProvider provider) {\n+        super(thing);\n+        this.cronScheduler = scheduler;\n+        this.dynamicStateDescriptionProvider = provider;\n+        this.programChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_PROGRAM);\n+        this.endDateChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_ENDDATE);\n+        this.config = getConfigAs(SmartherModuleConfiguration.class);", "originalCommit": "b76ea0c1193e57298bdea1f8bcae9b3f10b90950", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1NDYzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439154633", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            updateChannelState(CHANNEL_STATUS_PROGRAM, new StringType(\"\" + localProgram.getNumber()));\n          \n          \n            \n                            updateChannelState(CHANNEL_STATUS_PROGRAM, new StringType(String.valueOf(localProgram.getNumber())));", "author": "cpmeister", "createdAt": "2020-06-12T01:06:41Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherModuleHandler.java", "diffHunk": "@@ -0,0 +1,733 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.scheduler.CronScheduler;\n+import org.eclipse.smarthome.core.scheduler.ScheduledCompletableFuture;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.api.dto.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.Mode;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherIllegalPropertyValueException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherSubscriptionAlreadyExistsException;\n+import org.openhab.binding.smarther.internal.config.SmartherModuleConfiguration;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherModuleHandler} class is responsible of a single Smarther Chronothermostat, handling the commands\n+ * that are sent to one of its channels.\n+ * Each Smarther Chronothermostat communicates with the Smarther API via its assigned {@code SmartherBridgeHandler}.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherModuleHandler extends BaseThingHandler {\n+\n+    private static final String DAILY_MIDNIGHT = \"1 0 0 * * ? *\";\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final CronScheduler cronScheduler;\n+    private final SmartherDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ChannelUID programChannelUID;\n+    private final ChannelUID endDateChannelUID;\n+\n+    // Module configuration\n+    private SmartherModuleConfiguration config;\n+\n+    // Field members assigned in initialize method\n+    private @Nullable ScheduledCompletableFuture<Void> jobFuture;\n+    private @Nullable Future<?> pollFuture;\n+    private @Nullable SmartherBridgeHandler bridgeHandler;\n+    private @Nullable ExpiringCache<List<Program>> programCache;\n+    private @Nullable ModuleSettings moduleSettings;\n+\n+    // Chronothermostat local status\n+    private @Nullable Chronothermostat chronothermostat;\n+\n+    /**\n+     * Constructs a {@code SmartherModuleHandler} for the given thing, scheduler and dynamic state description provider.\n+     *\n+     * @param thing\n+     *            the {@link Thing} thing to be used\n+     * @param scheduler\n+     *            the {@link CronScheduler} periodic job scheduler to be used\n+     * @param provider\n+     *            the {@link SmartherDynamicStateDescriptionProvider} dynamic state description provider to be used\n+     */\n+    public SmartherModuleHandler(Thing thing, CronScheduler scheduler,\n+            SmartherDynamicStateDescriptionProvider provider) {\n+        super(thing);\n+        this.cronScheduler = scheduler;\n+        this.dynamicStateDescriptionProvider = provider;\n+        this.programChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_PROGRAM);\n+        this.endDateChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_ENDDATE);\n+        this.config = getConfigAs(SmartherModuleConfiguration.class);\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Chronothermostat thing lifecycle management methods\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Module[{}] Initialize handler\", thing.getUID());\n+\n+        final Bridge localBridge = getBridge();\n+        if (localBridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final SmartherBridgeHandler localBridgeHandler = (SmartherBridgeHandler) localBridge.getHandler();\n+        this.bridgeHandler = localBridgeHandler;\n+        if (localBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, String.format(\n+                    \"Missing configuration from the Smarther Bridge (UID:%s). Fix configuration or report if this problem remains.\",\n+                    localBridge.getBridgeUID()));\n+            return;\n+        }\n+\n+        this.config = getConfigAs(SmartherModuleConfiguration.class);\n+        if (StringUtil.isBlank(config.getPlantId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Plant Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.getModuleId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getProgramsRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Programs Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getStatusRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Status Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        // Initialize automatic mode programs local cache\n+        final ExpiringCache<List<Program>> localProgramCache = new ExpiringCache<>(\n+                Duration.ofHours(config.getProgramsRefreshPeriod()), this::programCacheAction);\n+        this.programCache = localProgramCache;\n+\n+        // Initialize module local settings\n+        final ModuleSettings localModuleSettings = new ModuleSettings(config.getPlantId(), config.getModuleId());\n+        this.moduleSettings = localModuleSettings;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleJob();\n+        schedulePoll();\n+\n+        logger.debug(\"Module[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        try {\n+            handleCommandInternal(channelUID, command);\n+            updateModuleStatus();\n+        } catch (SmartherIllegalPropertyValueException e) {\n+            logger.warn(\"Module[{}] Received command {} with illegal value {} on channel {}\", thing.getUID(), command,\n+                    e.getMessage(), channelUID.getId());\n+        } catch (SmartherGatewayException e) {\n+            // catch exceptions and handle it in your binding\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Handles the command sent to a given Channel of this Chronothermostat.\n+     *\n+     * @param channelUID\n+     *            the identifier of the Channel\n+     * @param command\n+     *            the command sent to the given Channel\n+     *\n+     * @throws {@link SmartherIllegalPropertyValueException}\n+     *             if the command contains an illegal value that cannot be mapped to any valid enum value\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API\n+     */\n+    private void handleCommandInternal(ChannelUID channelUID, Command command)\n+            throws SmartherIllegalPropertyValueException, SmartherGatewayException {\n+        final ModuleSettings localModuleSettings = this.moduleSettings;\n+        if (localModuleSettings == null) {\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SETTINGS_MODE:\n+                if (command instanceof StringType) {\n+                    localModuleSettings.setMode(Mode.fromValue(command.toString()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_TEMPERATURE:\n+                if (changeTemperature(command, localModuleSettings)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_PROGRAM:\n+                if (command instanceof DecimalType) {\n+                    localModuleSettings.setProgram(((DecimalType) command).intValue());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_BOOSTTIME:\n+                if (command instanceof DecimalType) {\n+                    localModuleSettings.setBoostTime(BoostTime.fromValue(((DecimalType) command).intValue()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDDATE:\n+                if (command instanceof StringType) {\n+                    localModuleSettings.setEndDate(command.toString());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDHOUR:\n+                if (changeTimeHour(command, localModuleSettings)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDMINUTE:\n+                if (changeTimeMinute(command, localModuleSettings)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_POWER:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        // Apply module settings to the remote module\n+                        if (getBridgeHandler().setModuleStatus(localModuleSettings)) {\n+                            // Change applied, update module status\n+                            logger.debug(\"Module[{}] New settings applied!\", thing.getUID());\n+                        }\n+                        updateChannelState(CHANNEL_SETTINGS_POWER, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Module[{}] Manually triggered channel to refresh the Module config\",\n+                                thing.getUID());\n+                        expireCache();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Module[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    /**\n+     * Changes the \"temperature\" in module settings, based on the received Command.\n+     * The new value is checked against the temperature limits allowed by the device.\n+     *\n+     * @param command\n+     *            the command received on temperature Channel\n+     *\n+     * @return {@code true} if the change succeeded, {@code false} otherwise\n+     */\n+    private boolean changeTemperature(Command command, final ModuleSettings settings) {\n+        if (!(command instanceof QuantityType)) {\n+            return false;\n+        }\n+\n+        QuantityType<?> quantity = (QuantityType<?>) command;\n+        QuantityType<?> newMeasure = quantity.toUnit(SIUnits.CELSIUS);\n+\n+        // Check remote device temperature limits\n+        if (newMeasure != null && newMeasure.doubleValue() >= 7.1 && newMeasure.doubleValue() <= 40.0) {\n+            // Only tenth degree increments are allowed\n+            double newTemperature = Math.round(newMeasure.doubleValue() * 10) / 10.0;\n+\n+            settings.setSetPointTemperature(QuantityType.valueOf(newTemperature, SIUnits.CELSIUS));\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Changes the \"end hour\" for manual mode in module settings, based on the received Command.\n+     * The new value is checked against the 24-hours clock allowed range.\n+     *\n+     * @param command\n+     *            the command received on end hour Channel\n+     *\n+     * @return {@code true} if the change succeeded, {@code false} otherwise\n+     */\n+    private boolean changeTimeHour(Command command, final ModuleSettings settings) {\n+        if (command instanceof DecimalType) {\n+            int endHour = ((DecimalType) command).intValue();\n+            if (endHour >= 0 && endHour <= 23) {\n+                settings.setEndHour(endHour);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Changes the \"end minute\" for manual mode in module settings, based on the received Command.\n+     * The new value is modified to match a 15 min step increment.\n+     *\n+     * @param command\n+     *            the command received on end minute Channel\n+     *\n+     * @return {@code true} if the change succeeded, {@code false} otherwise\n+     */\n+    private boolean changeTimeMinute(Command command, final ModuleSettings settings) {\n+        if (command instanceof DecimalType) {\n+            int endMinute = ((DecimalType) command).intValue();\n+            if (endMinute >= 0 && endMinute <= 59) {\n+                // Only 15 min increments are allowed\n+                endMinute = Math.round(endMinute / 15) * 15;\n+                settings.setEndMinute(endMinute);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Handles the notification dispatched to this Chronothermostat from the reference Smarther Bridge.\n+     *\n+     * @param notification\n+     *            the notification to handle\n+     */\n+    public void handleNotification(Notification notification) {\n+        try {\n+            final Chronothermostat notificationChrono = notification.getChronothermostat();\n+            if (notificationChrono != null) {\n+                this.chronothermostat = notificationChrono;\n+                if (config.isSettingsAutoupdate()) {\n+                    final ModuleSettings localModuleSettings = this.moduleSettings;\n+                    if (localModuleSettings != null) {\n+                        localModuleSettings.updateFromChronothermostat(notificationChrono);\n+                    }\n+                }\n+                logger.debug(\"Module[{}] Handle notification: [{}]\", thing.getUID(), this.chronothermostat);\n+                updateModuleStatus();\n+            }\n+        } catch (SmartherIllegalPropertyValueException e) {\n+            logger.warn(\"Module[{}] Notification has illegal value: [{}]\", thing.getUID(), e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() != ThingStatus.ONLINE) {\n+            // Put module offline when the parent bridge goes offline\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, \"Smarther Bridge Offline\");\n+            logger.debug(\"Module[{}] Bridge switched {}\", thing.getUID(), bridgeStatusInfo.getStatus());\n+        } else {\n+            // Update the module status when the parent bridge return online\n+            logger.debug(\"Module[{}] Bridge is back ONLINE\", thing.getUID());\n+            // Restart polling to collect module data\n+            schedulePoll();\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+        stopJob(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Module[{}] Dispose handler\", thing.getUID());\n+        stopPoll(true);\n+        stopJob(true);\n+        try {\n+            getBridgeHandler().unregisterNotification(config.getPlantId());\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Module[{}] API Gateway error during disposing: {}\", thing.getUID(), e.getMessage());\n+        }\n+        logger.debug(\"Module[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Chronothermostat data cache management methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Returns the available automatic mode programs to be cached for this Chronothermostat.\n+     *\n+     * @return the available programs to be cached for this Chronothermostat, or {@code null} if the list of available\n+     *         programs cannot be retrieved\n+     */\n+    private @Nullable List<Program> programCacheAction() {\n+        try {\n+            final List<Program> programs = getBridgeHandler().getModulePrograms(config.getPlantId(),\n+                    config.getModuleId());\n+            logger.debug(\"Module[{}] Available programs: {}\", thing.getUID(), programs);\n+\n+            return programs;\n+\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Module[{}] Cannot retrieve available programs: {}\", thing.getUID(), e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Sets all the cache to \"expired\" for this Chronothermostat.\n+     */\n+    private void expireCache() {\n+        logger.debug(\"Module[{}] Invalidating program cache\", thing.getUID());\n+        final ExpiringCache<List<Program>> localProgramCache = this.programCache;\n+        if (localProgramCache != null) {\n+            localProgramCache.invalidateValue();\n+        }\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Chronothermostat job scheduler methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Starts a new cron scheduler to execute the internal recurring jobs.\n+     */\n+    private synchronized void scheduleJob() {\n+        stopJob(false);\n+\n+        // Schedule daily job to start daily, at midnight\n+        final ScheduledCompletableFuture<Void> localJobFuture = cronScheduler.schedule(this::dailyJob, DAILY_MIDNIGHT);\n+        this.jobFuture = localJobFuture;\n+\n+        logger.debug(\"Module[{}] Scheduled recurring job {} to start at midnight\", thing.getUID(),\n+                Integer.toHexString(localJobFuture.hashCode()));\n+\n+        // Execute daily job immediately at startup\n+        this.dailyJob();\n+    }\n+\n+    /**\n+     * Cancels all running jobs.\n+     *\n+     * @param mayInterruptIfRunning\n+     *            {@code true} if the thread executing this task should be interrupted, {@code false} if the in-progress\n+     *            tasks are allowed to complete\n+     */\n+    private synchronized void stopJob(boolean mayInterruptIfRunning) {\n+        final ScheduledCompletableFuture<Void> localJobFuture = this.jobFuture;\n+        if (localJobFuture != null) {\n+            if (!localJobFuture.isCancelled()) {\n+                localJobFuture.cancel(mayInterruptIfRunning);\n+            }\n+            this.jobFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Action to be executed by the daily job: refresh the end dates list for \"manual\" mode.\n+     */\n+    private void dailyJob() {\n+        logger.debug(\"Module[{}] Daily job, refreshing the end dates list for \\\"manual\\\" mode\", thing.getUID());\n+        // Refresh the end dates list for \"manual\" mode\n+        dynamicStateDescriptionProvider.setEndDates(endDateChannelUID, config.getNumberOfEndDays());\n+        // If expired, update EndDate in module settings\n+        final ModuleSettings localModuleSettings = this.moduleSettings;\n+        if (localModuleSettings != null && localModuleSettings.isEndDateExpired()) {\n+            localModuleSettings.refreshEndDate();\n+            updateChannelState(CHANNEL_SETTINGS_ENDDATE, new StringType(localModuleSettings.getEndDate()));\n+        }\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Chronothermostat status polling mechanism methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Starts a new scheduler to periodically poll and update this Chronothermostat status.\n+     */\n+    private void schedulePoll() {\n+        stopPoll(false);\n+\n+        // Schedule poll to start after POLL_INITIAL_DELAY sec and run periodically based on status refresh period\n+        final Future<?> localPollFuture = scheduler.scheduleWithFixedDelay(this::poll, POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod() * 60, TimeUnit.SECONDS);\n+        this.pollFuture = localPollFuture;\n+\n+        logger.debug(\"Module[{}] Scheduled poll for {} sec out, then every {} min\", thing.getUID(), POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod());\n+    }\n+\n+    /**\n+     * Cancels all running poll schedulers.\n+     *\n+     * @param mayInterruptIfRunning\n+     *            {@code true} if the thread executing this task should be interrupted, {@code false} if the in-progress\n+     *            tasks are allowed to complete\n+     */\n+    private synchronized void stopPoll(boolean mayInterruptIfRunning) {\n+        final Future<?> localPollFuture = this.pollFuture;\n+        if (localPollFuture != null) {\n+            if (!localPollFuture.isCancelled()) {\n+                localPollFuture.cancel(mayInterruptIfRunning);\n+            }\n+            this.pollFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Polls to update this Chronothermostat status.\n+     *\n+     * @return {@code true} if the method completes without errors, {@code false} otherwise\n+     */\n+    private synchronized boolean poll() {\n+        try {\n+            final Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                final ThingStatusInfo bridgeStatusInfo = bridge.getStatusInfo();\n+                if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+                    ModuleStatus moduleStatus = getBridgeHandler().getModuleStatus(config.getPlantId(),\n+                            config.getModuleId());\n+\n+                    final Chronothermostat statusChrono = moduleStatus.toChronothermostat();\n+                    if (statusChrono != null) {\n+                        if ((this.chronothermostat == null) || config.isSettingsAutoupdate()) {\n+                            final ModuleSettings localModuleSettings = this.moduleSettings;\n+                            if (localModuleSettings != null) {\n+                                localModuleSettings.updateFromChronothermostat(statusChrono);\n+                            }\n+                        }\n+                        this.chronothermostat = statusChrono;\n+                        logger.debug(\"Module[{}] Status: [{}]\", thing.getUID(), this.chronothermostat);\n+                    } else {\n+                        throw new SmartherGatewayException(\"No chronothermostat data found\");\n+                    }\n+\n+                    // Refresh the programs list for \"automatic\" mode\n+                    final ExpiringCache<List<Program>> localProgramCache = this.programCache;\n+                    if (localProgramCache != null) {\n+                        final List<Program> programs = localProgramCache.getValue();\n+                        if (programs != null) {\n+                            dynamicStateDescriptionProvider.setPrograms(programChannelUID, programs);\n+                        }\n+                    }\n+\n+                    updateModuleStatus();\n+\n+                    getBridgeHandler().registerNotification(config.getPlantId());\n+\n+                    // Everything is ok > set the Thing state to Online\n+                    updateStatus(ThingStatus.ONLINE);\n+                    return true;\n+                } else if (thing.getStatus() != ThingStatus.OFFLINE) {\n+                    logger.debug(\"Module[{}] Switched {} as Bridge is not online\", thing.getUID(),\n+                            bridgeStatusInfo.getStatus());\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, \"Smarther Bridge Offline\");\n+                }\n+            }\n+            return false;\n+        } catch (SmartherIllegalPropertyValueException e) {\n+            logger.debug(\"Module[{}] Illegal property value error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (SmartherSubscriptionAlreadyExistsException e) {\n+            logger.debug(\"Module[{}] Subscription error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Module[{}] API Gateway error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (RuntimeException e) {\n+            // All other exceptions apart from Subscription and Gateway issues\n+            logger.warn(\"Module[{}] Unexpected error during polling, please report if this keeps occurring: \",\n+                    thing.getUID(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        }\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Chronothermostat convenience methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Convenience method to check and get the Smarther Bridge handler instance for this Module.\n+     *\n+     * @return the Smarther Bridge handler instance\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case the Smarther Bridge handler instance is {@code null}\n+     */\n+    private SmartherBridgeHandler getBridgeHandler() throws SmartherGatewayException {\n+        final SmartherBridgeHandler localBridgeHandler = this.bridgeHandler;\n+        if (localBridgeHandler == null) {\n+            throw new SmartherGatewayException(\"Smarther Bridge handler instance is null\");\n+        }\n+        return localBridgeHandler;\n+    }\n+\n+    /**\n+     * Returns this Chronothermostat plant identifier\n+     *\n+     * @return a string containing the plant identifier\n+     */\n+    public String getPlantId() {\n+        return config.getPlantId();\n+    }\n+\n+    /**\n+     * Returns this Chronothermostat module identifier\n+     *\n+     * @return a string containing the module identifier\n+     */\n+    public String getModuleId() {\n+        return config.getModuleId();\n+    }\n+\n+    /**\n+     * Checks whether this Chronothermostat matches with the given plant and module identifiers.\n+     *\n+     * @param plantId\n+     *            the plant identifier to match to\n+     * @param moduleId\n+     *            the module identifier to match to\n+     *\n+     * @return {@code true} if the Chronothermostat matches the given plant and module identifiers, {@code false}\n+     *         otherwise\n+     */\n+    public boolean isLinkedTo(String plantId, String moduleId) {\n+        return (config.getPlantId().equals(plantId) && config.getModuleId().equals(moduleId));\n+    }\n+\n+    /**\n+     * Convenience method to update the given Channel state \"only\" if the Channel is linked.\n+     *\n+     * @param channelId\n+     *            the identifier of the Channel to be updated\n+     * @param state\n+     *            the new state to be applied to the given Channel\n+     */\n+    private void updateChannelState(String channelId, State state) {\n+        final Channel channel = thing.getChannel(channelId);\n+\n+        if (channel != null && isLinked(channel.getUID())) {\n+            updateState(channel.getUID(), state);\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to update the whole status of the Chronothermostat associated to this handler.\n+     * Channels are updated based on the local {@code chronothermostat} and {@code moduleSettings} objects.\n+     *\n+     * @throws {@link SmartherIllegalPropertyValueException}\n+     *             if at least one of the module properties cannot be mapped to any valid enum value\n+     */\n+    private void updateModuleStatus() throws SmartherIllegalPropertyValueException {\n+        final Chronothermostat localChrono = this.chronothermostat;\n+        if (localChrono != null) {\n+            // Update the Measures channels\n+            updateChannelState(CHANNEL_MEASURES_TEMPERATURE, localChrono.getThermometer().toState());\n+            updateChannelState(CHANNEL_MEASURES_HUMIDITY, localChrono.getHygrometer().toState());\n+            // Update the Status channels\n+            updateChannelState(CHANNEL_STATUS_STATE, (localChrono.isActive() ? OnOffType.ON : OnOffType.OFF));\n+            updateChannelState(CHANNEL_STATUS_FUNCTION,\n+                    new StringType(StringUtil.capitalize(localChrono.getFunction().toLowerCase())));\n+            updateChannelState(CHANNEL_STATUS_MODE,\n+                    new StringType(StringUtil.capitalize(localChrono.getMode().toLowerCase())));\n+            updateChannelState(CHANNEL_STATUS_TEMPERATURE, localChrono.getSetPointTemperature().toState());\n+            updateChannelState(CHANNEL_STATUS_ENDTIME, new StringType(localChrono.getActivationTimeLabel()));\n+            updateChannelState(CHANNEL_STATUS_TEMP_FORMAT, new StringType(localChrono.getTemperatureFormat()));\n+            final Program localProgram = localChrono.getProgram();\n+            if (localProgram != null) {\n+                updateChannelState(CHANNEL_STATUS_PROGRAM, new StringType(\"\" + localProgram.getNumber()));", "originalCommit": "b76ea0c1193e57298bdea1f8bcae9b3f10b90950", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1NDgxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439154819", "bodyText": "might as well put these two statements to after the catch blocks since all the catch blocks have these two statements.", "author": "cpmeister", "createdAt": "2020-06-12T01:07:32Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherModuleHandler.java", "diffHunk": "@@ -0,0 +1,733 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.scheduler.CronScheduler;\n+import org.eclipse.smarthome.core.scheduler.ScheduledCompletableFuture;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.api.dto.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.Mode;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherIllegalPropertyValueException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherSubscriptionAlreadyExistsException;\n+import org.openhab.binding.smarther.internal.config.SmartherModuleConfiguration;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherModuleHandler} class is responsible of a single Smarther Chronothermostat, handling the commands\n+ * that are sent to one of its channels.\n+ * Each Smarther Chronothermostat communicates with the Smarther API via its assigned {@code SmartherBridgeHandler}.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherModuleHandler extends BaseThingHandler {\n+\n+    private static final String DAILY_MIDNIGHT = \"1 0 0 * * ? *\";\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final CronScheduler cronScheduler;\n+    private final SmartherDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ChannelUID programChannelUID;\n+    private final ChannelUID endDateChannelUID;\n+\n+    // Module configuration\n+    private SmartherModuleConfiguration config;\n+\n+    // Field members assigned in initialize method\n+    private @Nullable ScheduledCompletableFuture<Void> jobFuture;\n+    private @Nullable Future<?> pollFuture;\n+    private @Nullable SmartherBridgeHandler bridgeHandler;\n+    private @Nullable ExpiringCache<List<Program>> programCache;\n+    private @Nullable ModuleSettings moduleSettings;\n+\n+    // Chronothermostat local status\n+    private @Nullable Chronothermostat chronothermostat;\n+\n+    /**\n+     * Constructs a {@code SmartherModuleHandler} for the given thing, scheduler and dynamic state description provider.\n+     *\n+     * @param thing\n+     *            the {@link Thing} thing to be used\n+     * @param scheduler\n+     *            the {@link CronScheduler} periodic job scheduler to be used\n+     * @param provider\n+     *            the {@link SmartherDynamicStateDescriptionProvider} dynamic state description provider to be used\n+     */\n+    public SmartherModuleHandler(Thing thing, CronScheduler scheduler,\n+            SmartherDynamicStateDescriptionProvider provider) {\n+        super(thing);\n+        this.cronScheduler = scheduler;\n+        this.dynamicStateDescriptionProvider = provider;\n+        this.programChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_PROGRAM);\n+        this.endDateChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_ENDDATE);\n+        this.config = getConfigAs(SmartherModuleConfiguration.class);\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Chronothermostat thing lifecycle management methods\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Module[{}] Initialize handler\", thing.getUID());\n+\n+        final Bridge localBridge = getBridge();\n+        if (localBridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final SmartherBridgeHandler localBridgeHandler = (SmartherBridgeHandler) localBridge.getHandler();\n+        this.bridgeHandler = localBridgeHandler;\n+        if (localBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, String.format(\n+                    \"Missing configuration from the Smarther Bridge (UID:%s). Fix configuration or report if this problem remains.\",\n+                    localBridge.getBridgeUID()));\n+            return;\n+        }\n+\n+        this.config = getConfigAs(SmartherModuleConfiguration.class);\n+        if (StringUtil.isBlank(config.getPlantId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Plant Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.getModuleId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getProgramsRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Programs Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getStatusRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Status Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        // Initialize automatic mode programs local cache\n+        final ExpiringCache<List<Program>> localProgramCache = new ExpiringCache<>(\n+                Duration.ofHours(config.getProgramsRefreshPeriod()), this::programCacheAction);\n+        this.programCache = localProgramCache;\n+\n+        // Initialize module local settings\n+        final ModuleSettings localModuleSettings = new ModuleSettings(config.getPlantId(), config.getModuleId());\n+        this.moduleSettings = localModuleSettings;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleJob();\n+        schedulePoll();\n+\n+        logger.debug(\"Module[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        try {\n+            handleCommandInternal(channelUID, command);\n+            updateModuleStatus();\n+        } catch (SmartherIllegalPropertyValueException e) {\n+            logger.warn(\"Module[{}] Received command {} with illegal value {} on channel {}\", thing.getUID(), command,\n+                    e.getMessage(), channelUID.getId());\n+        } catch (SmartherGatewayException e) {\n+            // catch exceptions and handle it in your binding\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Handles the command sent to a given Channel of this Chronothermostat.\n+     *\n+     * @param channelUID\n+     *            the identifier of the Channel\n+     * @param command\n+     *            the command sent to the given Channel\n+     *\n+     * @throws {@link SmartherIllegalPropertyValueException}\n+     *             if the command contains an illegal value that cannot be mapped to any valid enum value\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API\n+     */\n+    private void handleCommandInternal(ChannelUID channelUID, Command command)\n+            throws SmartherIllegalPropertyValueException, SmartherGatewayException {\n+        final ModuleSettings localModuleSettings = this.moduleSettings;\n+        if (localModuleSettings == null) {\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SETTINGS_MODE:\n+                if (command instanceof StringType) {\n+                    localModuleSettings.setMode(Mode.fromValue(command.toString()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_TEMPERATURE:\n+                if (changeTemperature(command, localModuleSettings)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_PROGRAM:\n+                if (command instanceof DecimalType) {\n+                    localModuleSettings.setProgram(((DecimalType) command).intValue());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_BOOSTTIME:\n+                if (command instanceof DecimalType) {\n+                    localModuleSettings.setBoostTime(BoostTime.fromValue(((DecimalType) command).intValue()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDDATE:\n+                if (command instanceof StringType) {\n+                    localModuleSettings.setEndDate(command.toString());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDHOUR:\n+                if (changeTimeHour(command, localModuleSettings)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDMINUTE:\n+                if (changeTimeMinute(command, localModuleSettings)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_POWER:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        // Apply module settings to the remote module\n+                        if (getBridgeHandler().setModuleStatus(localModuleSettings)) {\n+                            // Change applied, update module status\n+                            logger.debug(\"Module[{}] New settings applied!\", thing.getUID());\n+                        }\n+                        updateChannelState(CHANNEL_SETTINGS_POWER, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Module[{}] Manually triggered channel to refresh the Module config\",\n+                                thing.getUID());\n+                        expireCache();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Module[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    /**\n+     * Changes the \"temperature\" in module settings, based on the received Command.\n+     * The new value is checked against the temperature limits allowed by the device.\n+     *\n+     * @param command\n+     *            the command received on temperature Channel\n+     *\n+     * @return {@code true} if the change succeeded, {@code false} otherwise\n+     */\n+    private boolean changeTemperature(Command command, final ModuleSettings settings) {\n+        if (!(command instanceof QuantityType)) {\n+            return false;\n+        }\n+\n+        QuantityType<?> quantity = (QuantityType<?>) command;\n+        QuantityType<?> newMeasure = quantity.toUnit(SIUnits.CELSIUS);\n+\n+        // Check remote device temperature limits\n+        if (newMeasure != null && newMeasure.doubleValue() >= 7.1 && newMeasure.doubleValue() <= 40.0) {\n+            // Only tenth degree increments are allowed\n+            double newTemperature = Math.round(newMeasure.doubleValue() * 10) / 10.0;\n+\n+            settings.setSetPointTemperature(QuantityType.valueOf(newTemperature, SIUnits.CELSIUS));\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Changes the \"end hour\" for manual mode in module settings, based on the received Command.\n+     * The new value is checked against the 24-hours clock allowed range.\n+     *\n+     * @param command\n+     *            the command received on end hour Channel\n+     *\n+     * @return {@code true} if the change succeeded, {@code false} otherwise\n+     */\n+    private boolean changeTimeHour(Command command, final ModuleSettings settings) {\n+        if (command instanceof DecimalType) {\n+            int endHour = ((DecimalType) command).intValue();\n+            if (endHour >= 0 && endHour <= 23) {\n+                settings.setEndHour(endHour);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Changes the \"end minute\" for manual mode in module settings, based on the received Command.\n+     * The new value is modified to match a 15 min step increment.\n+     *\n+     * @param command\n+     *            the command received on end minute Channel\n+     *\n+     * @return {@code true} if the change succeeded, {@code false} otherwise\n+     */\n+    private boolean changeTimeMinute(Command command, final ModuleSettings settings) {\n+        if (command instanceof DecimalType) {\n+            int endMinute = ((DecimalType) command).intValue();\n+            if (endMinute >= 0 && endMinute <= 59) {\n+                // Only 15 min increments are allowed\n+                endMinute = Math.round(endMinute / 15) * 15;\n+                settings.setEndMinute(endMinute);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Handles the notification dispatched to this Chronothermostat from the reference Smarther Bridge.\n+     *\n+     * @param notification\n+     *            the notification to handle\n+     */\n+    public void handleNotification(Notification notification) {\n+        try {\n+            final Chronothermostat notificationChrono = notification.getChronothermostat();\n+            if (notificationChrono != null) {\n+                this.chronothermostat = notificationChrono;\n+                if (config.isSettingsAutoupdate()) {\n+                    final ModuleSettings localModuleSettings = this.moduleSettings;\n+                    if (localModuleSettings != null) {\n+                        localModuleSettings.updateFromChronothermostat(notificationChrono);\n+                    }\n+                }\n+                logger.debug(\"Module[{}] Handle notification: [{}]\", thing.getUID(), this.chronothermostat);\n+                updateModuleStatus();\n+            }\n+        } catch (SmartherIllegalPropertyValueException e) {\n+            logger.warn(\"Module[{}] Notification has illegal value: [{}]\", thing.getUID(), e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() != ThingStatus.ONLINE) {\n+            // Put module offline when the parent bridge goes offline\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, \"Smarther Bridge Offline\");\n+            logger.debug(\"Module[{}] Bridge switched {}\", thing.getUID(), bridgeStatusInfo.getStatus());\n+        } else {\n+            // Update the module status when the parent bridge return online\n+            logger.debug(\"Module[{}] Bridge is back ONLINE\", thing.getUID());\n+            // Restart polling to collect module data\n+            schedulePoll();\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+        stopJob(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Module[{}] Dispose handler\", thing.getUID());\n+        stopPoll(true);\n+        stopJob(true);\n+        try {\n+            getBridgeHandler().unregisterNotification(config.getPlantId());\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Module[{}] API Gateway error during disposing: {}\", thing.getUID(), e.getMessage());\n+        }\n+        logger.debug(\"Module[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Chronothermostat data cache management methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Returns the available automatic mode programs to be cached for this Chronothermostat.\n+     *\n+     * @return the available programs to be cached for this Chronothermostat, or {@code null} if the list of available\n+     *         programs cannot be retrieved\n+     */\n+    private @Nullable List<Program> programCacheAction() {\n+        try {\n+            final List<Program> programs = getBridgeHandler().getModulePrograms(config.getPlantId(),\n+                    config.getModuleId());\n+            logger.debug(\"Module[{}] Available programs: {}\", thing.getUID(), programs);\n+\n+            return programs;\n+\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Module[{}] Cannot retrieve available programs: {}\", thing.getUID(), e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Sets all the cache to \"expired\" for this Chronothermostat.\n+     */\n+    private void expireCache() {\n+        logger.debug(\"Module[{}] Invalidating program cache\", thing.getUID());\n+        final ExpiringCache<List<Program>> localProgramCache = this.programCache;\n+        if (localProgramCache != null) {\n+            localProgramCache.invalidateValue();\n+        }\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Chronothermostat job scheduler methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Starts a new cron scheduler to execute the internal recurring jobs.\n+     */\n+    private synchronized void scheduleJob() {\n+        stopJob(false);\n+\n+        // Schedule daily job to start daily, at midnight\n+        final ScheduledCompletableFuture<Void> localJobFuture = cronScheduler.schedule(this::dailyJob, DAILY_MIDNIGHT);\n+        this.jobFuture = localJobFuture;\n+\n+        logger.debug(\"Module[{}] Scheduled recurring job {} to start at midnight\", thing.getUID(),\n+                Integer.toHexString(localJobFuture.hashCode()));\n+\n+        // Execute daily job immediately at startup\n+        this.dailyJob();\n+    }\n+\n+    /**\n+     * Cancels all running jobs.\n+     *\n+     * @param mayInterruptIfRunning\n+     *            {@code true} if the thread executing this task should be interrupted, {@code false} if the in-progress\n+     *            tasks are allowed to complete\n+     */\n+    private synchronized void stopJob(boolean mayInterruptIfRunning) {\n+        final ScheduledCompletableFuture<Void> localJobFuture = this.jobFuture;\n+        if (localJobFuture != null) {\n+            if (!localJobFuture.isCancelled()) {\n+                localJobFuture.cancel(mayInterruptIfRunning);\n+            }\n+            this.jobFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Action to be executed by the daily job: refresh the end dates list for \"manual\" mode.\n+     */\n+    private void dailyJob() {\n+        logger.debug(\"Module[{}] Daily job, refreshing the end dates list for \\\"manual\\\" mode\", thing.getUID());\n+        // Refresh the end dates list for \"manual\" mode\n+        dynamicStateDescriptionProvider.setEndDates(endDateChannelUID, config.getNumberOfEndDays());\n+        // If expired, update EndDate in module settings\n+        final ModuleSettings localModuleSettings = this.moduleSettings;\n+        if (localModuleSettings != null && localModuleSettings.isEndDateExpired()) {\n+            localModuleSettings.refreshEndDate();\n+            updateChannelState(CHANNEL_SETTINGS_ENDDATE, new StringType(localModuleSettings.getEndDate()));\n+        }\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Chronothermostat status polling mechanism methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Starts a new scheduler to periodically poll and update this Chronothermostat status.\n+     */\n+    private void schedulePoll() {\n+        stopPoll(false);\n+\n+        // Schedule poll to start after POLL_INITIAL_DELAY sec and run periodically based on status refresh period\n+        final Future<?> localPollFuture = scheduler.scheduleWithFixedDelay(this::poll, POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod() * 60, TimeUnit.SECONDS);\n+        this.pollFuture = localPollFuture;\n+\n+        logger.debug(\"Module[{}] Scheduled poll for {} sec out, then every {} min\", thing.getUID(), POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod());\n+    }\n+\n+    /**\n+     * Cancels all running poll schedulers.\n+     *\n+     * @param mayInterruptIfRunning\n+     *            {@code true} if the thread executing this task should be interrupted, {@code false} if the in-progress\n+     *            tasks are allowed to complete\n+     */\n+    private synchronized void stopPoll(boolean mayInterruptIfRunning) {\n+        final Future<?> localPollFuture = this.pollFuture;\n+        if (localPollFuture != null) {\n+            if (!localPollFuture.isCancelled()) {\n+                localPollFuture.cancel(mayInterruptIfRunning);\n+            }\n+            this.pollFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Polls to update this Chronothermostat status.\n+     *\n+     * @return {@code true} if the method completes without errors, {@code false} otherwise\n+     */\n+    private synchronized boolean poll() {\n+        try {\n+            final Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                final ThingStatusInfo bridgeStatusInfo = bridge.getStatusInfo();\n+                if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+                    ModuleStatus moduleStatus = getBridgeHandler().getModuleStatus(config.getPlantId(),\n+                            config.getModuleId());\n+\n+                    final Chronothermostat statusChrono = moduleStatus.toChronothermostat();\n+                    if (statusChrono != null) {\n+                        if ((this.chronothermostat == null) || config.isSettingsAutoupdate()) {\n+                            final ModuleSettings localModuleSettings = this.moduleSettings;\n+                            if (localModuleSettings != null) {\n+                                localModuleSettings.updateFromChronothermostat(statusChrono);\n+                            }\n+                        }\n+                        this.chronothermostat = statusChrono;\n+                        logger.debug(\"Module[{}] Status: [{}]\", thing.getUID(), this.chronothermostat);\n+                    } else {\n+                        throw new SmartherGatewayException(\"No chronothermostat data found\");\n+                    }\n+\n+                    // Refresh the programs list for \"automatic\" mode\n+                    final ExpiringCache<List<Program>> localProgramCache = this.programCache;\n+                    if (localProgramCache != null) {\n+                        final List<Program> programs = localProgramCache.getValue();\n+                        if (programs != null) {\n+                            dynamicStateDescriptionProvider.setPrograms(programChannelUID, programs);\n+                        }\n+                    }\n+\n+                    updateModuleStatus();\n+\n+                    getBridgeHandler().registerNotification(config.getPlantId());\n+\n+                    // Everything is ok > set the Thing state to Online\n+                    updateStatus(ThingStatus.ONLINE);\n+                    return true;\n+                } else if (thing.getStatus() != ThingStatus.OFFLINE) {\n+                    logger.debug(\"Module[{}] Switched {} as Bridge is not online\", thing.getUID(),\n+                            bridgeStatusInfo.getStatus());\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, \"Smarther Bridge Offline\");\n+                }\n+            }\n+            return false;\n+        } catch (SmartherIllegalPropertyValueException e) {\n+            logger.debug(\"Module[{}] Illegal property value error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (SmartherSubscriptionAlreadyExistsException e) {\n+            logger.debug(\"Module[{}] Subscription error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Module[{}] API Gateway error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (RuntimeException e) {\n+            // All other exceptions apart from Subscription and Gateway issues\n+            logger.warn(\"Module[{}] Unexpected error during polling, please report if this keeps occurring: \",\n+                    thing.getUID(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;", "originalCommit": "b76ea0c1193e57298bdea1f8bcae9b3f10b90950", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0MzE2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439243161", "bodyText": "I agree it would be better", "author": "MrRonfo", "createdAt": "2020-06-12T07:02:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1NDgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1NTMzMg==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439155332", "bodyText": "missing implementations?", "author": "cpmeister", "createdAt": "2020-06-12T01:09:41Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/SmartherApi.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api;\n+\n+import static org.eclipse.jetty.http.HttpMethod.*;\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.function.Function;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.smarther.internal.api.dto.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.MeasureUnit;\n+import org.openhab.binding.smarther.internal.api.dto.Module;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Plant;\n+import org.openhab.binding.smarther.internal.api.dto.Plants;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.dto.Subscription;\n+import org.openhab.binding.smarther.internal.api.dto.Topology;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherTokenExpiredException;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.ModelUtil;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+/**\n+ * The {@code SmartherApi} class is used to communicate with the BTicino/Legrand API gateway.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherApi {\n+\n+    private static final String CONTENT_TYPE = \"application/json\";\n+    private static final String BEARER = \"Bearer \";\n+\n+    // API gateway request headers\n+    private static final String HEADER_ACCEPT = \"Accept\";\n+    // API gateway request attributes\n+    private static final String ATTR_FUNCTION = \"function\";\n+    private static final String ATTR_MODE = \"mode\";\n+    private static final String ATTR_PROGRAMS = \"programs\";\n+    private static final String ATTR_NUMBER = \"number\";\n+    private static final String ATTR_SETPOINT = \"setPoint\";\n+    private static final String ATTR_VALUE = \"value\";\n+    private static final String ATTR_UNIT = \"unit\";\n+    private static final String ATTR_ACTIVATION_TIME = \"activationTime\";\n+    private static final String ATTR_ENDPOINT_URL = \"EndPointUrl\";\n+    // API gateway operation paths\n+    private static final String PATH_PLANTS = \"/plants\";\n+    private static final String PATH_TOPOLOGY = PATH_PLANTS + \"/%s/topology\";\n+    private static final String PATH_MODULE = \"/chronothermostat/thermoregulation/addressLocation/plants/%s/modules/parameter/id/value/%s\";\n+    private static final String PATH_PROGRAMS = \"/programlist\";\n+    private static final String PATH_SUBSCRIPTIONS = \"/subscription\";\n+    private static final String PATH_SUBSCRIBE = PATH_PLANTS + \"/%s/subscription\";\n+    private static final String PATH_UNSUBSCRIBE = PATH_SUBSCRIBE + \"/%s\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final OAuthClientService oAuthClientService;\n+    private final String oAuthSubscriptionKey;\n+    private final SmartherApiConnector connector;\n+\n+    /**\n+     * Constructs a {@code SmartherApi} to the API gateway with the specified OAuth2 attributes (subscription key and\n+     * client service), scheduler service and http client.\n+     *\n+     * @param clientService\n+     *            the OAuth2 authorization client service to be used\n+     * @param subscriptionKey\n+     *            the OAuth2 subscription key to be used with the given client service\n+     * @param scheduler\n+     *            the scheduler to be used to reschedule calls when rate limit exceeded or call not succeeded\n+     * @param httpClient\n+     *            the http client to be used to make http calls to the API gateway\n+     */\n+    public SmartherApi(final OAuthClientService clientService, final String subscriptionKey,\n+            final ScheduledExecutorService scheduler, final HttpClient httpClient) {\n+        this.oAuthClientService = clientService;\n+        this.oAuthSubscriptionKey = subscriptionKey;\n+        this.connector = new SmartherApiConnector(scheduler, httpClient);\n+    }\n+\n+    /**\n+     * Returns the plants registered under the Smarther account the bridge has been configured with.\n+     *\n+     * @return the list of registered plants, or an empty {@link List} in case of no plants found\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public List<Plant> getPlants() throws SmartherGatewayException {\n+        final ContentResponse response = requestBasic(GET, PATH_PLANTS);\n+        if (response.getStatus() == HttpStatus.NO_CONTENT_204) {\n+            return new ArrayList<>();\n+        } else {\n+            return ModelUtil.gsonInstance().fromJson(response.getContentAsString(), Plants.class).getPlants();\n+        }\n+    }\n+\n+    /**\n+     * Returns the chronothermostat modules registered in the given plant.\n+     *\n+     * @param plantId\n+     *            the identifier of the plant\n+     *\n+     * @return the list of registered modules, or an empty {@link List} in case the plant contains no module\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public List<Module> getPlantModules(String plantId) throws SmartherGatewayException {\n+        final ContentResponse response = requestBasic(GET, String.format(PATH_TOPOLOGY, plantId));\n+        final Topology topology = ModelUtil.gsonInstance().fromJson(response.getContentAsString(), Topology.class);\n+        return topology.getModules();\n+    }\n+\n+    /**\n+     * Returns the current status of a given chronothermostat module.\n+     *\n+     * @param plantId\n+     *            the identifier of the plant\n+     * @param moduleId\n+     *            the identifier of the chronothermostat module inside the plant\n+     *\n+     * @return the current status of the chronothermostat module\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public ModuleStatus getModuleStatus(String plantId, String moduleId) throws SmartherGatewayException {\n+        final ContentResponse response = requestModule(GET, plantId, moduleId, null);\n+        return ModelUtil.gsonInstance().fromJson(response.getContentAsString(), ModuleStatus.class);\n+    }\n+\n+    /**\n+     * Sends new settings to be applied to a given chronothermostat module.\n+     *\n+     * @param settings\n+     *            the module settings to be applied\n+     *\n+     * @return {@code true} if the settings have been successfully applied, {@code false} otherwise\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public boolean setModuleStatus(ModuleSettings settings) throws SmartherGatewayException {\n+        // Prepare request payload\n+        Map<String, Object> rootMap = new IdentityHashMap<String, Object>();\n+        rootMap.put(ATTR_FUNCTION, settings.getFunction().getValue());\n+        rootMap.put(ATTR_MODE, settings.getMode().getValue());\n+        switch (settings.getMode()) {\n+            case AUTOMATIC:\n+                // {\"function\":\"heating\",\"mode\":\"automatic\",\"programs\":[{\"number\":0}]}\n+                Map<String, Integer> programMap = new IdentityHashMap<String, Integer>();\n+                programMap.put(ATTR_NUMBER, Integer.valueOf(settings.getProgram()));\n+                List<Map<String, Integer>> programsList = new ArrayList<>();\n+                programsList.add(programMap);\n+                rootMap.put(ATTR_PROGRAMS, programsList);\n+                break;\n+            case MANUAL:\n+                // {\"function\":\"heating\",\"mode\":\"manual\",\"setPoint\":{\"value\":0.0,\"unit\":\"C\"},\"activationTime\":\"X\"}\n+                QuantityType<Temperature> newTemperature = settings.getSetPointTemperature(SIUnits.CELSIUS);\n+                if (newTemperature == null) {\n+                    throw new SmartherGatewayException(\"Invalid temperature unit transformation\");\n+                }\n+                Map<String, Object> setPointMap = new IdentityHashMap<String, Object>();\n+                setPointMap.put(ATTR_VALUE, newTemperature.doubleValue());\n+                setPointMap.put(ATTR_UNIT, MeasureUnit.CELSIUS.getValue());\n+                rootMap.put(ATTR_SETPOINT, setPointMap);\n+                rootMap.put(ATTR_ACTIVATION_TIME, settings.getActivationTime());\n+                break;\n+            case BOOST:\n+                // {\"function\":\"heating\",\"mode\":\"boost\",\"activationTime\":\"X\"}\n+                rootMap.put(ATTR_ACTIVATION_TIME, settings.getActivationTime());\n+                break;\n+            case OFF:\n+                // {\"function\":\"heating\",\"mode\":\"off\"}\n+                break;\n+            case PROTECTION:\n+                // {\"function\":\"heating\",\"mode\":\"protection\"}\n+                break;", "originalCommit": "b76ea0c1193e57298bdea1f8bcae9b3f10b90950", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0NDcxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439244711", "bodyText": "Actually, no :)\nAs Off and Protection modes don't require additional attributes to be set, I've just kept them listed there to remind me and other potential developers that those cases exist and what is their current mapping required by API (in the comment).\nIt shouldn't be a problem to keep them, correct?", "author": "MrRonfo", "createdAt": "2020-06-12T07:06:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1NTMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1NTc5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439155799", "bodyText": "Whats with MethodHandles.lookup().lookupClass()?\nShouldn't this just be SmartherAccountService.class?", "author": "cpmeister", "createdAt": "2020-06-12T01:11:35Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAccountService.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Hashtable;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherAccountService} class manages the servlets and bind authorization servlet to Bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = SmartherAccountService.class, immediate = true, configurationPid = \"binding.smarther.accountService\")\n+@NonNullByDefault\n+public class SmartherAccountService {\n+\n+    private static final String TEMPLATE_PATH = \"templates/\";\n+    private static final String IMAGE_PATH = \"web\";\n+    private static final String TEMPLATE_APPLICATION = TEMPLATE_PATH + \"application.html\";\n+    private static final String TEMPLATE_INDEX = TEMPLATE_PATH + \"index.html\";\n+    private static final String ERROR_UKNOWN_BRIDGE = \"Returned 'state' doesn't match any Bridges. Has the bridge been removed?\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());", "originalCommit": "b76ea0c1193e57298bdea1f8bcae9b3f10b90950", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0NzI4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439247287", "bodyText": "Reflection I think I saw it in other bindings. I suppose they used it just to copy the logger row in new classes without bothering with the class name (so avoid potential bug in case they miss to).\nNo problem at all in changing it back to direct .class reference, though.", "author": "MrRonfo", "createdAt": "2020-06-12T07:12:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1NTc5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1NTg5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439155894", "bodyText": "here too", "author": "cpmeister", "createdAt": "2020-06-12T01:11:59Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAuthorizationServlet.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.smarther.internal.api.dto.Location;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherAuthorizationServlet} class acts as the registered endpoint for the user to automatically manage\n+ * the BTicino/Legrand API authorization process.\n+ * The servlet follows the OAuth2 Authorization Code flow, saving the resulting refreshToken within the Smarther Bridge.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherAuthorizationServlet extends HttpServlet {\n+\n+    private static final long serialVersionUID = 5199173744807168342L;\n+\n+    private static final String CONTENT_TYPE = \"text/html;charset=UTF-8\";\n+    private static final String X_FORWARDED_PROTO = \"X-Forwarded-Proto\";\n+\n+    // Http request parameters\n+    private static final String PARAM_CODE = \"code\";\n+    private static final String PARAM_STATE = \"state\";\n+    private static final String PARAM_ERROR = \"error\";\n+\n+    // Simple HTML templates for inserting messages.\n+    private static final String HTML_EMPTY_APPLICATIONS = \"<p class='block'>Manually add a Smarther Bridge to authorize it here<p>\";\n+    private static final String HTML_BRIDGE_AUTHORIZED = \"<p class='block authorized'>Bridge authorized for Client Id %s</p>\";\n+    private static final String HTML_ERROR = \"<p class='block error'>Call to Smarther API gateway failed with error: %s</p>\";\n+\n+    private static final Pattern MESSAGE_KEY_PATTERN = Pattern.compile(\"\\\\$\\\\{([^\\\\}]+)\\\\}\");\n+\n+    // Keys present in the index.html\n+    private static final String KEY_PAGE_REFRESH = \"pageRefresh\";\n+    private static final String HTML_META_REFRESH_CONTENT = \"<meta http-equiv='refresh' content='10; url=%s'>\";\n+    private static final String KEY_AUTHORIZED_BRIDGE = \"authorizedBridge\";\n+    private static final String KEY_ERROR = \"error\";\n+    private static final String KEY_APPLICATIONS = \"applications\";\n+    private static final String KEY_REDIRECT_URI = \"redirectUri\";\n+    // Keys present in the application.html\n+    private static final String APPLICATION_ID = \"application.id\";\n+    private static final String APPLICATION_NAME = \"application.name\";\n+    private static final String APPLICATION_LOCATIONS = \"application.locations\";\n+    private static final String APPLICATION_AUTHORIZED_CLASS = \"application.authorized\";\n+    private static final String APPLICATION_AUTHORIZE = \"application.authorize\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());", "originalCommit": "b76ea0c1193e57298bdea1f8bcae9b3f10b90950", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0NzU5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439247599", "bodyText": "I think I've used it everywhere I needed to have a logger instance :)\nReverted back all of them to direct .class usage.", "author": "MrRonfo", "createdAt": "2020-06-12T07:13:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1NTg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1ODgzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439158833", "bodyText": "If the contents of this is supposed to be unique, might as well make it a Set instead of a List.", "author": "cpmeister", "createdAt": "2020-06-12T01:24:22Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAccountService.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Hashtable;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherAccountService} class manages the servlets and bind authorization servlet to Bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = SmartherAccountService.class, immediate = true, configurationPid = \"binding.smarther.accountService\")\n+@NonNullByDefault\n+public class SmartherAccountService {\n+\n+    private static final String TEMPLATE_PATH = \"templates/\";\n+    private static final String IMAGE_PATH = \"web\";\n+    private static final String TEMPLATE_APPLICATION = TEMPLATE_PATH + \"application.html\";\n+    private static final String TEMPLATE_INDEX = TEMPLATE_PATH + \"index.html\";\n+    private static final String ERROR_UKNOWN_BRIDGE = \"Returned 'state' doesn't match any Bridges. Has the bridge been removed?\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final List<SmartherAccountHandler> handlers = new ArrayList<>();", "originalCommit": "b76ea0c1193e57298bdea1f8bcae9b3f10b90950", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMzNzExNg==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439337116", "bodyText": "Indeed, there's no need to have the handlers ordered. Thanks for having spotted this, changed to Set/HashSet implementation.", "author": "MrRonfo", "createdAt": "2020-06-12T10:25:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1ODgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNTE5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439715191", "bodyText": "handlers is a set so you don't need to bother checking if it already contains it or not.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!handlers.contains(handler)) {\n          \n          \n            \n                        handlers.add(handler);\n          \n          \n            \n                    }\n          \n          \n            \n                    handlers.add(handler);", "author": "cpmeister", "createdAt": "2020-06-13T06:45:21Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAccountService.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherAccountService} class manages the servlets and bind authorization servlet to Bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = SmartherAccountService.class, immediate = true, configurationPid = \"binding.smarther.accountService\")\n+@NonNullByDefault\n+public class SmartherAccountService {\n+\n+    private static final String TEMPLATE_PATH = \"templates/\";\n+    private static final String IMAGE_PATH = \"web\";\n+    private static final String TEMPLATE_APPLICATION = TEMPLATE_PATH + \"application.html\";\n+    private static final String TEMPLATE_INDEX = TEMPLATE_PATH + \"index.html\";\n+    private static final String ERROR_UKNOWN_BRIDGE = \"Returned 'state' doesn't match any Bridges. Has the bridge been removed?\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherAccountService.class);\n+\n+    private final Set<SmartherAccountHandler> handlers = new HashSet<>();\n+\n+    private @Nullable HttpService httpService;\n+    private @Nullable BundleContext bundleContext;\n+\n+    @Activate\n+    protected void activate(ComponentContext componentContext, Map<String, Object> properties) {\n+        try {\n+            this.bundleContext = componentContext.getBundleContext();\n+\n+            final HttpService localHttpService = this.httpService;\n+            if (localHttpService != null) {\n+                // Register the authorization servlet\n+                localHttpService.registerServlet(AUTH_SERVLET_ALIAS, createAuthorizationServlet(), new Hashtable<>(),\n+                        localHttpService.createDefaultHttpContext());\n+                localHttpService.registerResources(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS, IMAGE_PATH, null);\n+\n+                // Register the notification servlet\n+                localHttpService.registerServlet(NOTIFY_SERVLET_ALIAS, createNotificationServlet(), new Hashtable<>(),\n+                        localHttpService.createDefaultHttpContext());\n+            }\n+        } catch (NamespaceException | ServletException | IOException e) {\n+            logger.warn(\"Error during Smarther servlet startup\", e);\n+        }\n+    }\n+\n+    @Deactivate\n+    protected void deactivate(ComponentContext componentContext) {\n+        final HttpService localHttpService = this.httpService;\n+        if (localHttpService != null) {\n+            // Unregister the authorization servlet\n+            localHttpService.unregister(AUTH_SERVLET_ALIAS);\n+            localHttpService.unregister(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS);\n+\n+            // Unregister the notification servlet\n+            localHttpService.unregister(NOTIFY_SERVLET_ALIAS);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a {@code SmartherAuthorizationServlet}.\n+     *\n+     * @return the newly created servlet\n+     *\n+     * @throws {@link IOException}\n+     *             in case of issues reading one of the internal html templates\n+     */\n+    private HttpServlet createAuthorizationServlet() throws IOException {\n+        return new SmartherAuthorizationServlet(this, readTemplate(TEMPLATE_INDEX), readTemplate(TEMPLATE_APPLICATION));\n+    }\n+\n+    /**\n+     * Constructs a {@code SmartherNotificationServlet}.\n+     *\n+     * @return the newly created servlet\n+     */\n+    private HttpServlet createNotificationServlet() {\n+        return new SmartherNotificationServlet(this);\n+    }\n+\n+    /**\n+     * Reads a template from file and returns its content as string.\n+     *\n+     * @param templateName\n+     *            the name of the template file to read\n+     *\n+     * @return a string representing the content of the template file\n+     *\n+     * @throws {@link IOException}\n+     *             in case of issues reading the template from file\n+     */\n+    private String readTemplate(String templateName) throws IOException {\n+        final BundleContext localBundleContext = this.bundleContext;\n+        if (localBundleContext != null) {\n+            final URL index = localBundleContext.getBundle().getEntry(templateName);\n+\n+            if (index == null) {\n+                throw new FileNotFoundException(String\n+                        .format(\"Cannot find template '%s' - failed to initialize Smarther servlet\", templateName));\n+            } else {\n+                try (InputStream input = index.openStream()) {\n+                    return StringUtil.streamToString(input);\n+                }\n+            }\n+        } else {\n+            throw new IOException(\"Cannot get template, bundle context is null\");\n+        }\n+    }\n+\n+    /**\n+     * Dispatches the received Smarther API authorization response to the proper Smarther account handler.\n+     * Part of the Legrand/Bticino OAuth2 authorization process.\n+     *\n+     * @param servletBaseURL\n+     *            the authorization servlet url needed to derive the notification endpoint url\n+     * @param state\n+     *            the authorization state needed to match the correct Smarther account handler to authorize\n+     * @param code The BTicino/Legrand API returned code value\n+     *            the authorization code to authorize with the account handler\n+     *\n+     * @return a string containing the name of the authorized BTicino/Legrand portal user\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API or no account handler found\n+     */\n+    public String dispatchAuthorization(String servletBaseURL, String state, String code)\n+            throws SmartherGatewayException {\n+        // Searches the SmartherAccountHandler instance that matches the given state\n+        final SmartherAccountHandler listener = getAccountListenerByUID(state);\n+        if (listener == null) {\n+            logger.debug(\n+                    \"BTicino/Legrand API redirected with state '{}' but no matching bridge was found. Possible bridge has been removed.\",\n+                    state);\n+            throw new SmartherGatewayException(ERROR_UKNOWN_BRIDGE);\n+        }\n+\n+        // Generates the notification URL from servletBaseURL\n+        final String notificationUrl = servletBaseURL.replace(AUTH_SERVLET_ALIAS, NOTIFY_SERVLET_ALIAS);\n+\n+        logger.debug(\"Calling authorize on {}\", listener.getUID());\n+\n+        // Passes the authorization to the handler\n+        return listener.authorize(servletBaseURL, code, notificationUrl);\n+    }\n+\n+    /**\n+     * Dispatches the received C2C Webhook notification to the proper Smarther notification handler.\n+     *\n+     * @param notification\n+     *            the received notification to handle\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API or no notification handler found\n+     */\n+    public void dispatchNotification(Notification notification) throws SmartherGatewayException {\n+        // Searches the SmartherAccountHandler instance that matches the given location\n+        final Sender sender = notification.getSender();\n+        if (sender != null) {\n+            final SmartherAccountHandler listener = getAccountListenerByLocation(sender.getPlant().getId());\n+            if (listener == null) {\n+                logger.warn(\"C2C notification [{}]: no matching bridge was found. Possible bridge has been removed.\",\n+                        notification.getId());\n+                throw new SmartherGatewayException(ERROR_UKNOWN_BRIDGE);\n+            } else if (listener.isOnline()) {\n+                final SmartherNotificationHandler handler = (SmartherNotificationHandler) listener;\n+\n+                if (handler.useNotifications()) {\n+                    // Passes the notification to the handler\n+                    handler.handleNotification(notification);\n+                } else {\n+                    logger.debug(\n+                            \"C2C notification [{}]: notification discarded as bridge does not handle notifications.\",\n+                            notification.getId());\n+                }\n+            } else {\n+                logger.debug(\"C2C notification [{}]: notification discarded as bridge is offline.\",\n+                        notification.getId());\n+            }\n+        } else {\n+            logger.debug(\"C2C notification [{}]: notification discarded as payload is invalid.\", notification.getId());\n+        }\n+    }\n+\n+    /**\n+     * Adds a {@link SmartherAccountHandler} handler to the set of account service handlers.\n+     *\n+     * @param handler\n+     *            the handler to add to the handlers set\n+     */\n+    public void addSmartherAccountHandler(SmartherAccountHandler handler) {\n+        if (!handlers.contains(handler)) {\n+            handlers.add(handler);\n+        }", "originalCommit": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNTI3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439715273", "bodyText": "No idea if it needs to be thread-safe or not, but lets just make it thread-safe just to be safe.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Set<SmartherAccountHandler> handlers = new HashSet<>();\n          \n          \n            \n                private final Set<SmartherAccountHandler> handlers = new ConcurrentHashSet<>();", "author": "cpmeister", "createdAt": "2020-06-13T06:46:34Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAccountService.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherAccountService} class manages the servlets and bind authorization servlet to Bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = SmartherAccountService.class, immediate = true, configurationPid = \"binding.smarther.accountService\")\n+@NonNullByDefault\n+public class SmartherAccountService {\n+\n+    private static final String TEMPLATE_PATH = \"templates/\";\n+    private static final String IMAGE_PATH = \"web\";\n+    private static final String TEMPLATE_APPLICATION = TEMPLATE_PATH + \"application.html\";\n+    private static final String TEMPLATE_INDEX = TEMPLATE_PATH + \"index.html\";\n+    private static final String ERROR_UKNOWN_BRIDGE = \"Returned 'state' doesn't match any Bridges. Has the bridge been removed?\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherAccountService.class);\n+\n+    private final Set<SmartherAccountHandler> handlers = new HashSet<>();", "originalCommit": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNTQwNw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439715407", "bodyText": "This should work I think...\nBut the null checker and generic types might also collide in spectacular fashion so lets cross our finger.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Optional<SmartherAccountHandler> maybeListener = handlers.stream().filter(l -> l.equalsThingUID(thingUID))\n          \n          \n            \n                            .findFirst();\n          \n          \n            \n                    return (maybeListener.isPresent()) ? maybeListener.get() : null;\n          \n          \n            \n                    handlers.stream().filter(l -> l.equalsThingUID(thingUID)).findFirst().orElse(null);", "author": "cpmeister", "createdAt": "2020-06-13T06:48:47Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAccountService.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherAccountService} class manages the servlets and bind authorization servlet to Bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = SmartherAccountService.class, immediate = true, configurationPid = \"binding.smarther.accountService\")\n+@NonNullByDefault\n+public class SmartherAccountService {\n+\n+    private static final String TEMPLATE_PATH = \"templates/\";\n+    private static final String IMAGE_PATH = \"web\";\n+    private static final String TEMPLATE_APPLICATION = TEMPLATE_PATH + \"application.html\";\n+    private static final String TEMPLATE_INDEX = TEMPLATE_PATH + \"index.html\";\n+    private static final String ERROR_UKNOWN_BRIDGE = \"Returned 'state' doesn't match any Bridges. Has the bridge been removed?\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherAccountService.class);\n+\n+    private final Set<SmartherAccountHandler> handlers = new HashSet<>();\n+\n+    private @Nullable HttpService httpService;\n+    private @Nullable BundleContext bundleContext;\n+\n+    @Activate\n+    protected void activate(ComponentContext componentContext, Map<String, Object> properties) {\n+        try {\n+            this.bundleContext = componentContext.getBundleContext();\n+\n+            final HttpService localHttpService = this.httpService;\n+            if (localHttpService != null) {\n+                // Register the authorization servlet\n+                localHttpService.registerServlet(AUTH_SERVLET_ALIAS, createAuthorizationServlet(), new Hashtable<>(),\n+                        localHttpService.createDefaultHttpContext());\n+                localHttpService.registerResources(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS, IMAGE_PATH, null);\n+\n+                // Register the notification servlet\n+                localHttpService.registerServlet(NOTIFY_SERVLET_ALIAS, createNotificationServlet(), new Hashtable<>(),\n+                        localHttpService.createDefaultHttpContext());\n+            }\n+        } catch (NamespaceException | ServletException | IOException e) {\n+            logger.warn(\"Error during Smarther servlet startup\", e);\n+        }\n+    }\n+\n+    @Deactivate\n+    protected void deactivate(ComponentContext componentContext) {\n+        final HttpService localHttpService = this.httpService;\n+        if (localHttpService != null) {\n+            // Unregister the authorization servlet\n+            localHttpService.unregister(AUTH_SERVLET_ALIAS);\n+            localHttpService.unregister(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS);\n+\n+            // Unregister the notification servlet\n+            localHttpService.unregister(NOTIFY_SERVLET_ALIAS);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a {@code SmartherAuthorizationServlet}.\n+     *\n+     * @return the newly created servlet\n+     *\n+     * @throws {@link IOException}\n+     *             in case of issues reading one of the internal html templates\n+     */\n+    private HttpServlet createAuthorizationServlet() throws IOException {\n+        return new SmartherAuthorizationServlet(this, readTemplate(TEMPLATE_INDEX), readTemplate(TEMPLATE_APPLICATION));\n+    }\n+\n+    /**\n+     * Constructs a {@code SmartherNotificationServlet}.\n+     *\n+     * @return the newly created servlet\n+     */\n+    private HttpServlet createNotificationServlet() {\n+        return new SmartherNotificationServlet(this);\n+    }\n+\n+    /**\n+     * Reads a template from file and returns its content as string.\n+     *\n+     * @param templateName\n+     *            the name of the template file to read\n+     *\n+     * @return a string representing the content of the template file\n+     *\n+     * @throws {@link IOException}\n+     *             in case of issues reading the template from file\n+     */\n+    private String readTemplate(String templateName) throws IOException {\n+        final BundleContext localBundleContext = this.bundleContext;\n+        if (localBundleContext != null) {\n+            final URL index = localBundleContext.getBundle().getEntry(templateName);\n+\n+            if (index == null) {\n+                throw new FileNotFoundException(String\n+                        .format(\"Cannot find template '%s' - failed to initialize Smarther servlet\", templateName));\n+            } else {\n+                try (InputStream input = index.openStream()) {\n+                    return StringUtil.streamToString(input);\n+                }\n+            }\n+        } else {\n+            throw new IOException(\"Cannot get template, bundle context is null\");\n+        }\n+    }\n+\n+    /**\n+     * Dispatches the received Smarther API authorization response to the proper Smarther account handler.\n+     * Part of the Legrand/Bticino OAuth2 authorization process.\n+     *\n+     * @param servletBaseURL\n+     *            the authorization servlet url needed to derive the notification endpoint url\n+     * @param state\n+     *            the authorization state needed to match the correct Smarther account handler to authorize\n+     * @param code The BTicino/Legrand API returned code value\n+     *            the authorization code to authorize with the account handler\n+     *\n+     * @return a string containing the name of the authorized BTicino/Legrand portal user\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API or no account handler found\n+     */\n+    public String dispatchAuthorization(String servletBaseURL, String state, String code)\n+            throws SmartherGatewayException {\n+        // Searches the SmartherAccountHandler instance that matches the given state\n+        final SmartherAccountHandler listener = getAccountListenerByUID(state);\n+        if (listener == null) {\n+            logger.debug(\n+                    \"BTicino/Legrand API redirected with state '{}' but no matching bridge was found. Possible bridge has been removed.\",\n+                    state);\n+            throw new SmartherGatewayException(ERROR_UKNOWN_BRIDGE);\n+        }\n+\n+        // Generates the notification URL from servletBaseURL\n+        final String notificationUrl = servletBaseURL.replace(AUTH_SERVLET_ALIAS, NOTIFY_SERVLET_ALIAS);\n+\n+        logger.debug(\"Calling authorize on {}\", listener.getUID());\n+\n+        // Passes the authorization to the handler\n+        return listener.authorize(servletBaseURL, code, notificationUrl);\n+    }\n+\n+    /**\n+     * Dispatches the received C2C Webhook notification to the proper Smarther notification handler.\n+     *\n+     * @param notification\n+     *            the received notification to handle\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API or no notification handler found\n+     */\n+    public void dispatchNotification(Notification notification) throws SmartherGatewayException {\n+        // Searches the SmartherAccountHandler instance that matches the given location\n+        final Sender sender = notification.getSender();\n+        if (sender != null) {\n+            final SmartherAccountHandler listener = getAccountListenerByLocation(sender.getPlant().getId());\n+            if (listener == null) {\n+                logger.warn(\"C2C notification [{}]: no matching bridge was found. Possible bridge has been removed.\",\n+                        notification.getId());\n+                throw new SmartherGatewayException(ERROR_UKNOWN_BRIDGE);\n+            } else if (listener.isOnline()) {\n+                final SmartherNotificationHandler handler = (SmartherNotificationHandler) listener;\n+\n+                if (handler.useNotifications()) {\n+                    // Passes the notification to the handler\n+                    handler.handleNotification(notification);\n+                } else {\n+                    logger.debug(\n+                            \"C2C notification [{}]: notification discarded as bridge does not handle notifications.\",\n+                            notification.getId());\n+                }\n+            } else {\n+                logger.debug(\"C2C notification [{}]: notification discarded as bridge is offline.\",\n+                        notification.getId());\n+            }\n+        } else {\n+            logger.debug(\"C2C notification [{}]: notification discarded as payload is invalid.\", notification.getId());\n+        }\n+    }\n+\n+    /**\n+     * Adds a {@link SmartherAccountHandler} handler to the set of account service handlers.\n+     *\n+     * @param handler\n+     *            the handler to add to the handlers set\n+     */\n+    public void addSmartherAccountHandler(SmartherAccountHandler handler) {\n+        if (!handlers.contains(handler)) {\n+            handlers.add(handler);\n+        }\n+    }\n+\n+    /**\n+     * Removes a {@link SmartherAccountHandler} handler from the set of account service handlers.\n+     *\n+     * @param handler\n+     *            the handler to remove from the handlers set\n+     */\n+    public void removeSmartherAccountHandler(SmartherAccountHandler handler) {\n+        handlers.remove(handler);\n+    }\n+\n+    /**\n+     * Returns all the {@link SmartherAccountHandler} account service handlers.\n+     *\n+     * @return a set containing all the account service handlers\n+     */\n+    public Set<SmartherAccountHandler> getSmartherAccountHandlers() {\n+        return handlers;\n+    }\n+\n+    /**\n+     * Searches the {@link SmartherAccountHandler} handler that matches the given Thing UID.\n+     *\n+     * @param thingUID\n+     *            the UID of the Thing to match the handler with\n+     *\n+     * @return the handler matching the given Thing UID, or {@code null} if none matches\n+     */\n+    private @Nullable SmartherAccountHandler getAccountListenerByUID(String thingUID) {\n+        final Optional<SmartherAccountHandler> maybeListener = handlers.stream().filter(l -> l.equalsThingUID(thingUID))\n+                .findFirst();\n+        return (maybeListener.isPresent()) ? maybeListener.get() : null;", "originalCommit": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcyMDIwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439720204", "bodyText": "Seems not, I receive an error that orElse argument cannot be null.\nFound a strange javadoc, indeed:\n@NonNull SmartherAccountHandler java.util.Optional.orElse(@NonNull SmartherAccountHandler other)\n\nReturn the value if present, otherwise return other.\n\nParameters:\n    other - the value to be returned if there is no value present, maybe null", "author": "MrRonfo", "createdAt": "2020-06-13T08:12:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNTQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2MTM1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439761353", "bodyText": "well it was worth a shot, just leave as is then.", "author": "cpmeister", "createdAt": "2020-06-13T19:02:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNTQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNTQ4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439715486", "bodyText": "Should this method be renamed?", "author": "cpmeister", "createdAt": "2020-06-13T06:50:08Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAccountService.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherAccountService} class manages the servlets and bind authorization servlet to Bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = SmartherAccountService.class, immediate = true, configurationPid = \"binding.smarther.accountService\")\n+@NonNullByDefault\n+public class SmartherAccountService {\n+\n+    private static final String TEMPLATE_PATH = \"templates/\";\n+    private static final String IMAGE_PATH = \"web\";\n+    private static final String TEMPLATE_APPLICATION = TEMPLATE_PATH + \"application.html\";\n+    private static final String TEMPLATE_INDEX = TEMPLATE_PATH + \"index.html\";\n+    private static final String ERROR_UKNOWN_BRIDGE = \"Returned 'state' doesn't match any Bridges. Has the bridge been removed?\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherAccountService.class);\n+\n+    private final Set<SmartherAccountHandler> handlers = new HashSet<>();\n+\n+    private @Nullable HttpService httpService;\n+    private @Nullable BundleContext bundleContext;\n+\n+    @Activate\n+    protected void activate(ComponentContext componentContext, Map<String, Object> properties) {\n+        try {\n+            this.bundleContext = componentContext.getBundleContext();\n+\n+            final HttpService localHttpService = this.httpService;\n+            if (localHttpService != null) {\n+                // Register the authorization servlet\n+                localHttpService.registerServlet(AUTH_SERVLET_ALIAS, createAuthorizationServlet(), new Hashtable<>(),\n+                        localHttpService.createDefaultHttpContext());\n+                localHttpService.registerResources(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS, IMAGE_PATH, null);\n+\n+                // Register the notification servlet\n+                localHttpService.registerServlet(NOTIFY_SERVLET_ALIAS, createNotificationServlet(), new Hashtable<>(),\n+                        localHttpService.createDefaultHttpContext());\n+            }\n+        } catch (NamespaceException | ServletException | IOException e) {\n+            logger.warn(\"Error during Smarther servlet startup\", e);\n+        }\n+    }\n+\n+    @Deactivate\n+    protected void deactivate(ComponentContext componentContext) {\n+        final HttpService localHttpService = this.httpService;\n+        if (localHttpService != null) {\n+            // Unregister the authorization servlet\n+            localHttpService.unregister(AUTH_SERVLET_ALIAS);\n+            localHttpService.unregister(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS);\n+\n+            // Unregister the notification servlet\n+            localHttpService.unregister(NOTIFY_SERVLET_ALIAS);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a {@code SmartherAuthorizationServlet}.\n+     *\n+     * @return the newly created servlet\n+     *\n+     * @throws {@link IOException}\n+     *             in case of issues reading one of the internal html templates\n+     */\n+    private HttpServlet createAuthorizationServlet() throws IOException {\n+        return new SmartherAuthorizationServlet(this, readTemplate(TEMPLATE_INDEX), readTemplate(TEMPLATE_APPLICATION));\n+    }\n+\n+    /**\n+     * Constructs a {@code SmartherNotificationServlet}.\n+     *\n+     * @return the newly created servlet\n+     */\n+    private HttpServlet createNotificationServlet() {\n+        return new SmartherNotificationServlet(this);\n+    }\n+\n+    /**\n+     * Reads a template from file and returns its content as string.\n+     *\n+     * @param templateName\n+     *            the name of the template file to read\n+     *\n+     * @return a string representing the content of the template file\n+     *\n+     * @throws {@link IOException}\n+     *             in case of issues reading the template from file\n+     */\n+    private String readTemplate(String templateName) throws IOException {\n+        final BundleContext localBundleContext = this.bundleContext;\n+        if (localBundleContext != null) {\n+            final URL index = localBundleContext.getBundle().getEntry(templateName);\n+\n+            if (index == null) {\n+                throw new FileNotFoundException(String\n+                        .format(\"Cannot find template '%s' - failed to initialize Smarther servlet\", templateName));\n+            } else {\n+                try (InputStream input = index.openStream()) {\n+                    return StringUtil.streamToString(input);\n+                }\n+            }\n+        } else {\n+            throw new IOException(\"Cannot get template, bundle context is null\");\n+        }\n+    }\n+\n+    /**\n+     * Dispatches the received Smarther API authorization response to the proper Smarther account handler.\n+     * Part of the Legrand/Bticino OAuth2 authorization process.\n+     *\n+     * @param servletBaseURL\n+     *            the authorization servlet url needed to derive the notification endpoint url\n+     * @param state\n+     *            the authorization state needed to match the correct Smarther account handler to authorize\n+     * @param code The BTicino/Legrand API returned code value\n+     *            the authorization code to authorize with the account handler\n+     *\n+     * @return a string containing the name of the authorized BTicino/Legrand portal user\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API or no account handler found\n+     */\n+    public String dispatchAuthorization(String servletBaseURL, String state, String code)\n+            throws SmartherGatewayException {\n+        // Searches the SmartherAccountHandler instance that matches the given state\n+        final SmartherAccountHandler listener = getAccountListenerByUID(state);\n+        if (listener == null) {\n+            logger.debug(\n+                    \"BTicino/Legrand API redirected with state '{}' but no matching bridge was found. Possible bridge has been removed.\",\n+                    state);\n+            throw new SmartherGatewayException(ERROR_UKNOWN_BRIDGE);\n+        }\n+\n+        // Generates the notification URL from servletBaseURL\n+        final String notificationUrl = servletBaseURL.replace(AUTH_SERVLET_ALIAS, NOTIFY_SERVLET_ALIAS);\n+\n+        logger.debug(\"Calling authorize on {}\", listener.getUID());\n+\n+        // Passes the authorization to the handler\n+        return listener.authorize(servletBaseURL, code, notificationUrl);\n+    }\n+\n+    /**\n+     * Dispatches the received C2C Webhook notification to the proper Smarther notification handler.\n+     *\n+     * @param notification\n+     *            the received notification to handle\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API or no notification handler found\n+     */\n+    public void dispatchNotification(Notification notification) throws SmartherGatewayException {\n+        // Searches the SmartherAccountHandler instance that matches the given location\n+        final Sender sender = notification.getSender();\n+        if (sender != null) {\n+            final SmartherAccountHandler listener = getAccountListenerByLocation(sender.getPlant().getId());\n+            if (listener == null) {\n+                logger.warn(\"C2C notification [{}]: no matching bridge was found. Possible bridge has been removed.\",\n+                        notification.getId());\n+                throw new SmartherGatewayException(ERROR_UKNOWN_BRIDGE);\n+            } else if (listener.isOnline()) {\n+                final SmartherNotificationHandler handler = (SmartherNotificationHandler) listener;\n+\n+                if (handler.useNotifications()) {\n+                    // Passes the notification to the handler\n+                    handler.handleNotification(notification);\n+                } else {\n+                    logger.debug(\n+                            \"C2C notification [{}]: notification discarded as bridge does not handle notifications.\",\n+                            notification.getId());\n+                }\n+            } else {\n+                logger.debug(\"C2C notification [{}]: notification discarded as bridge is offline.\",\n+                        notification.getId());\n+            }\n+        } else {\n+            logger.debug(\"C2C notification [{}]: notification discarded as payload is invalid.\", notification.getId());\n+        }\n+    }\n+\n+    /**\n+     * Adds a {@link SmartherAccountHandler} handler to the set of account service handlers.\n+     *\n+     * @param handler\n+     *            the handler to add to the handlers set\n+     */\n+    public void addSmartherAccountHandler(SmartherAccountHandler handler) {\n+        if (!handlers.contains(handler)) {\n+            handlers.add(handler);\n+        }\n+    }\n+\n+    /**\n+     * Removes a {@link SmartherAccountHandler} handler from the set of account service handlers.\n+     *\n+     * @param handler\n+     *            the handler to remove from the handlers set\n+     */\n+    public void removeSmartherAccountHandler(SmartherAccountHandler handler) {\n+        handlers.remove(handler);\n+    }\n+\n+    /**\n+     * Returns all the {@link SmartherAccountHandler} account service handlers.\n+     *\n+     * @return a set containing all the account service handlers\n+     */\n+    public Set<SmartherAccountHandler> getSmartherAccountHandlers() {\n+        return handlers;\n+    }\n+\n+    /**\n+     * Searches the {@link SmartherAccountHandler} handler that matches the given Thing UID.\n+     *\n+     * @param thingUID\n+     *            the UID of the Thing to match the handler with\n+     *\n+     * @return the handler matching the given Thing UID, or {@code null} if none matches\n+     */\n+    private @Nullable SmartherAccountHandler getAccountListenerByUID(String thingUID) {", "originalCommit": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNTUwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439715500", "bodyText": "same question", "author": "cpmeister", "createdAt": "2020-06-13T06:50:21Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAccountService.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherAccountService} class manages the servlets and bind authorization servlet to Bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = SmartherAccountService.class, immediate = true, configurationPid = \"binding.smarther.accountService\")\n+@NonNullByDefault\n+public class SmartherAccountService {\n+\n+    private static final String TEMPLATE_PATH = \"templates/\";\n+    private static final String IMAGE_PATH = \"web\";\n+    private static final String TEMPLATE_APPLICATION = TEMPLATE_PATH + \"application.html\";\n+    private static final String TEMPLATE_INDEX = TEMPLATE_PATH + \"index.html\";\n+    private static final String ERROR_UKNOWN_BRIDGE = \"Returned 'state' doesn't match any Bridges. Has the bridge been removed?\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherAccountService.class);\n+\n+    private final Set<SmartherAccountHandler> handlers = new HashSet<>();\n+\n+    private @Nullable HttpService httpService;\n+    private @Nullable BundleContext bundleContext;\n+\n+    @Activate\n+    protected void activate(ComponentContext componentContext, Map<String, Object> properties) {\n+        try {\n+            this.bundleContext = componentContext.getBundleContext();\n+\n+            final HttpService localHttpService = this.httpService;\n+            if (localHttpService != null) {\n+                // Register the authorization servlet\n+                localHttpService.registerServlet(AUTH_SERVLET_ALIAS, createAuthorizationServlet(), new Hashtable<>(),\n+                        localHttpService.createDefaultHttpContext());\n+                localHttpService.registerResources(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS, IMAGE_PATH, null);\n+\n+                // Register the notification servlet\n+                localHttpService.registerServlet(NOTIFY_SERVLET_ALIAS, createNotificationServlet(), new Hashtable<>(),\n+                        localHttpService.createDefaultHttpContext());\n+            }\n+        } catch (NamespaceException | ServletException | IOException e) {\n+            logger.warn(\"Error during Smarther servlet startup\", e);\n+        }\n+    }\n+\n+    @Deactivate\n+    protected void deactivate(ComponentContext componentContext) {\n+        final HttpService localHttpService = this.httpService;\n+        if (localHttpService != null) {\n+            // Unregister the authorization servlet\n+            localHttpService.unregister(AUTH_SERVLET_ALIAS);\n+            localHttpService.unregister(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS);\n+\n+            // Unregister the notification servlet\n+            localHttpService.unregister(NOTIFY_SERVLET_ALIAS);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a {@code SmartherAuthorizationServlet}.\n+     *\n+     * @return the newly created servlet\n+     *\n+     * @throws {@link IOException}\n+     *             in case of issues reading one of the internal html templates\n+     */\n+    private HttpServlet createAuthorizationServlet() throws IOException {\n+        return new SmartherAuthorizationServlet(this, readTemplate(TEMPLATE_INDEX), readTemplate(TEMPLATE_APPLICATION));\n+    }\n+\n+    /**\n+     * Constructs a {@code SmartherNotificationServlet}.\n+     *\n+     * @return the newly created servlet\n+     */\n+    private HttpServlet createNotificationServlet() {\n+        return new SmartherNotificationServlet(this);\n+    }\n+\n+    /**\n+     * Reads a template from file and returns its content as string.\n+     *\n+     * @param templateName\n+     *            the name of the template file to read\n+     *\n+     * @return a string representing the content of the template file\n+     *\n+     * @throws {@link IOException}\n+     *             in case of issues reading the template from file\n+     */\n+    private String readTemplate(String templateName) throws IOException {\n+        final BundleContext localBundleContext = this.bundleContext;\n+        if (localBundleContext != null) {\n+            final URL index = localBundleContext.getBundle().getEntry(templateName);\n+\n+            if (index == null) {\n+                throw new FileNotFoundException(String\n+                        .format(\"Cannot find template '%s' - failed to initialize Smarther servlet\", templateName));\n+            } else {\n+                try (InputStream input = index.openStream()) {\n+                    return StringUtil.streamToString(input);\n+                }\n+            }\n+        } else {\n+            throw new IOException(\"Cannot get template, bundle context is null\");\n+        }\n+    }\n+\n+    /**\n+     * Dispatches the received Smarther API authorization response to the proper Smarther account handler.\n+     * Part of the Legrand/Bticino OAuth2 authorization process.\n+     *\n+     * @param servletBaseURL\n+     *            the authorization servlet url needed to derive the notification endpoint url\n+     * @param state\n+     *            the authorization state needed to match the correct Smarther account handler to authorize\n+     * @param code The BTicino/Legrand API returned code value\n+     *            the authorization code to authorize with the account handler\n+     *\n+     * @return a string containing the name of the authorized BTicino/Legrand portal user\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API or no account handler found\n+     */\n+    public String dispatchAuthorization(String servletBaseURL, String state, String code)\n+            throws SmartherGatewayException {\n+        // Searches the SmartherAccountHandler instance that matches the given state\n+        final SmartherAccountHandler listener = getAccountListenerByUID(state);\n+        if (listener == null) {\n+            logger.debug(\n+                    \"BTicino/Legrand API redirected with state '{}' but no matching bridge was found. Possible bridge has been removed.\",\n+                    state);\n+            throw new SmartherGatewayException(ERROR_UKNOWN_BRIDGE);\n+        }\n+\n+        // Generates the notification URL from servletBaseURL\n+        final String notificationUrl = servletBaseURL.replace(AUTH_SERVLET_ALIAS, NOTIFY_SERVLET_ALIAS);\n+\n+        logger.debug(\"Calling authorize on {}\", listener.getUID());\n+\n+        // Passes the authorization to the handler\n+        return listener.authorize(servletBaseURL, code, notificationUrl);\n+    }\n+\n+    /**\n+     * Dispatches the received C2C Webhook notification to the proper Smarther notification handler.\n+     *\n+     * @param notification\n+     *            the received notification to handle\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API or no notification handler found\n+     */\n+    public void dispatchNotification(Notification notification) throws SmartherGatewayException {\n+        // Searches the SmartherAccountHandler instance that matches the given location\n+        final Sender sender = notification.getSender();\n+        if (sender != null) {\n+            final SmartherAccountHandler listener = getAccountListenerByLocation(sender.getPlant().getId());\n+            if (listener == null) {\n+                logger.warn(\"C2C notification [{}]: no matching bridge was found. Possible bridge has been removed.\",\n+                        notification.getId());\n+                throw new SmartherGatewayException(ERROR_UKNOWN_BRIDGE);\n+            } else if (listener.isOnline()) {\n+                final SmartherNotificationHandler handler = (SmartherNotificationHandler) listener;\n+\n+                if (handler.useNotifications()) {\n+                    // Passes the notification to the handler\n+                    handler.handleNotification(notification);\n+                } else {\n+                    logger.debug(\n+                            \"C2C notification [{}]: notification discarded as bridge does not handle notifications.\",\n+                            notification.getId());\n+                }\n+            } else {\n+                logger.debug(\"C2C notification [{}]: notification discarded as bridge is offline.\",\n+                        notification.getId());\n+            }\n+        } else {\n+            logger.debug(\"C2C notification [{}]: notification discarded as payload is invalid.\", notification.getId());\n+        }\n+    }\n+\n+    /**\n+     * Adds a {@link SmartherAccountHandler} handler to the set of account service handlers.\n+     *\n+     * @param handler\n+     *            the handler to add to the handlers set\n+     */\n+    public void addSmartherAccountHandler(SmartherAccountHandler handler) {\n+        if (!handlers.contains(handler)) {\n+            handlers.add(handler);\n+        }\n+    }\n+\n+    /**\n+     * Removes a {@link SmartherAccountHandler} handler from the set of account service handlers.\n+     *\n+     * @param handler\n+     *            the handler to remove from the handlers set\n+     */\n+    public void removeSmartherAccountHandler(SmartherAccountHandler handler) {\n+        handlers.remove(handler);\n+    }\n+\n+    /**\n+     * Returns all the {@link SmartherAccountHandler} account service handlers.\n+     *\n+     * @return a set containing all the account service handlers\n+     */\n+    public Set<SmartherAccountHandler> getSmartherAccountHandlers() {\n+        return handlers;\n+    }\n+\n+    /**\n+     * Searches the {@link SmartherAccountHandler} handler that matches the given Thing UID.\n+     *\n+     * @param thingUID\n+     *            the UID of the Thing to match the handler with\n+     *\n+     * @return the handler matching the given Thing UID, or {@code null} if none matches\n+     */\n+    private @Nullable SmartherAccountHandler getAccountListenerByUID(String thingUID) {\n+        final Optional<SmartherAccountHandler> maybeListener = handlers.stream().filter(l -> l.equalsThingUID(thingUID))\n+                .findFirst();\n+        return (maybeListener.isPresent()) ? maybeListener.get() : null;\n+    }\n+\n+    /**\n+     * Searches the {@link SmartherAccountHandler} handler that matches the given location plant.\n+     *\n+     * @param plantId\n+     *            the identifier of the plant to match the handler with\n+     *\n+     * @return the handler matching the given location plant, or {@code null} if none matches\n+     */\n+    private @Nullable SmartherAccountHandler getAccountListenerByLocation(String plantId) {", "originalCommit": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNTUxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439715514", "bodyText": "same attempted optimization as earlier.", "author": "cpmeister", "createdAt": "2020-06-13T06:50:41Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAccountService.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherAccountService} class manages the servlets and bind authorization servlet to Bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = SmartherAccountService.class, immediate = true, configurationPid = \"binding.smarther.accountService\")\n+@NonNullByDefault\n+public class SmartherAccountService {\n+\n+    private static final String TEMPLATE_PATH = \"templates/\";\n+    private static final String IMAGE_PATH = \"web\";\n+    private static final String TEMPLATE_APPLICATION = TEMPLATE_PATH + \"application.html\";\n+    private static final String TEMPLATE_INDEX = TEMPLATE_PATH + \"index.html\";\n+    private static final String ERROR_UKNOWN_BRIDGE = \"Returned 'state' doesn't match any Bridges. Has the bridge been removed?\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherAccountService.class);\n+\n+    private final Set<SmartherAccountHandler> handlers = new HashSet<>();\n+\n+    private @Nullable HttpService httpService;\n+    private @Nullable BundleContext bundleContext;\n+\n+    @Activate\n+    protected void activate(ComponentContext componentContext, Map<String, Object> properties) {\n+        try {\n+            this.bundleContext = componentContext.getBundleContext();\n+\n+            final HttpService localHttpService = this.httpService;\n+            if (localHttpService != null) {\n+                // Register the authorization servlet\n+                localHttpService.registerServlet(AUTH_SERVLET_ALIAS, createAuthorizationServlet(), new Hashtable<>(),\n+                        localHttpService.createDefaultHttpContext());\n+                localHttpService.registerResources(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS, IMAGE_PATH, null);\n+\n+                // Register the notification servlet\n+                localHttpService.registerServlet(NOTIFY_SERVLET_ALIAS, createNotificationServlet(), new Hashtable<>(),\n+                        localHttpService.createDefaultHttpContext());\n+            }\n+        } catch (NamespaceException | ServletException | IOException e) {\n+            logger.warn(\"Error during Smarther servlet startup\", e);\n+        }\n+    }\n+\n+    @Deactivate\n+    protected void deactivate(ComponentContext componentContext) {\n+        final HttpService localHttpService = this.httpService;\n+        if (localHttpService != null) {\n+            // Unregister the authorization servlet\n+            localHttpService.unregister(AUTH_SERVLET_ALIAS);\n+            localHttpService.unregister(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS);\n+\n+            // Unregister the notification servlet\n+            localHttpService.unregister(NOTIFY_SERVLET_ALIAS);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a {@code SmartherAuthorizationServlet}.\n+     *\n+     * @return the newly created servlet\n+     *\n+     * @throws {@link IOException}\n+     *             in case of issues reading one of the internal html templates\n+     */\n+    private HttpServlet createAuthorizationServlet() throws IOException {\n+        return new SmartherAuthorizationServlet(this, readTemplate(TEMPLATE_INDEX), readTemplate(TEMPLATE_APPLICATION));\n+    }\n+\n+    /**\n+     * Constructs a {@code SmartherNotificationServlet}.\n+     *\n+     * @return the newly created servlet\n+     */\n+    private HttpServlet createNotificationServlet() {\n+        return new SmartherNotificationServlet(this);\n+    }\n+\n+    /**\n+     * Reads a template from file and returns its content as string.\n+     *\n+     * @param templateName\n+     *            the name of the template file to read\n+     *\n+     * @return a string representing the content of the template file\n+     *\n+     * @throws {@link IOException}\n+     *             in case of issues reading the template from file\n+     */\n+    private String readTemplate(String templateName) throws IOException {\n+        final BundleContext localBundleContext = this.bundleContext;\n+        if (localBundleContext != null) {\n+            final URL index = localBundleContext.getBundle().getEntry(templateName);\n+\n+            if (index == null) {\n+                throw new FileNotFoundException(String\n+                        .format(\"Cannot find template '%s' - failed to initialize Smarther servlet\", templateName));\n+            } else {\n+                try (InputStream input = index.openStream()) {\n+                    return StringUtil.streamToString(input);\n+                }\n+            }\n+        } else {\n+            throw new IOException(\"Cannot get template, bundle context is null\");\n+        }\n+    }\n+\n+    /**\n+     * Dispatches the received Smarther API authorization response to the proper Smarther account handler.\n+     * Part of the Legrand/Bticino OAuth2 authorization process.\n+     *\n+     * @param servletBaseURL\n+     *            the authorization servlet url needed to derive the notification endpoint url\n+     * @param state\n+     *            the authorization state needed to match the correct Smarther account handler to authorize\n+     * @param code The BTicino/Legrand API returned code value\n+     *            the authorization code to authorize with the account handler\n+     *\n+     * @return a string containing the name of the authorized BTicino/Legrand portal user\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API or no account handler found\n+     */\n+    public String dispatchAuthorization(String servletBaseURL, String state, String code)\n+            throws SmartherGatewayException {\n+        // Searches the SmartherAccountHandler instance that matches the given state\n+        final SmartherAccountHandler listener = getAccountListenerByUID(state);\n+        if (listener == null) {\n+            logger.debug(\n+                    \"BTicino/Legrand API redirected with state '{}' but no matching bridge was found. Possible bridge has been removed.\",\n+                    state);\n+            throw new SmartherGatewayException(ERROR_UKNOWN_BRIDGE);\n+        }\n+\n+        // Generates the notification URL from servletBaseURL\n+        final String notificationUrl = servletBaseURL.replace(AUTH_SERVLET_ALIAS, NOTIFY_SERVLET_ALIAS);\n+\n+        logger.debug(\"Calling authorize on {}\", listener.getUID());\n+\n+        // Passes the authorization to the handler\n+        return listener.authorize(servletBaseURL, code, notificationUrl);\n+    }\n+\n+    /**\n+     * Dispatches the received C2C Webhook notification to the proper Smarther notification handler.\n+     *\n+     * @param notification\n+     *            the received notification to handle\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API or no notification handler found\n+     */\n+    public void dispatchNotification(Notification notification) throws SmartherGatewayException {\n+        // Searches the SmartherAccountHandler instance that matches the given location\n+        final Sender sender = notification.getSender();\n+        if (sender != null) {\n+            final SmartherAccountHandler listener = getAccountListenerByLocation(sender.getPlant().getId());\n+            if (listener == null) {\n+                logger.warn(\"C2C notification [{}]: no matching bridge was found. Possible bridge has been removed.\",\n+                        notification.getId());\n+                throw new SmartherGatewayException(ERROR_UKNOWN_BRIDGE);\n+            } else if (listener.isOnline()) {\n+                final SmartherNotificationHandler handler = (SmartherNotificationHandler) listener;\n+\n+                if (handler.useNotifications()) {\n+                    // Passes the notification to the handler\n+                    handler.handleNotification(notification);\n+                } else {\n+                    logger.debug(\n+                            \"C2C notification [{}]: notification discarded as bridge does not handle notifications.\",\n+                            notification.getId());\n+                }\n+            } else {\n+                logger.debug(\"C2C notification [{}]: notification discarded as bridge is offline.\",\n+                        notification.getId());\n+            }\n+        } else {\n+            logger.debug(\"C2C notification [{}]: notification discarded as payload is invalid.\", notification.getId());\n+        }\n+    }\n+\n+    /**\n+     * Adds a {@link SmartherAccountHandler} handler to the set of account service handlers.\n+     *\n+     * @param handler\n+     *            the handler to add to the handlers set\n+     */\n+    public void addSmartherAccountHandler(SmartherAccountHandler handler) {\n+        if (!handlers.contains(handler)) {\n+            handlers.add(handler);\n+        }\n+    }\n+\n+    /**\n+     * Removes a {@link SmartherAccountHandler} handler from the set of account service handlers.\n+     *\n+     * @param handler\n+     *            the handler to remove from the handlers set\n+     */\n+    public void removeSmartherAccountHandler(SmartherAccountHandler handler) {\n+        handlers.remove(handler);\n+    }\n+\n+    /**\n+     * Returns all the {@link SmartherAccountHandler} account service handlers.\n+     *\n+     * @return a set containing all the account service handlers\n+     */\n+    public Set<SmartherAccountHandler> getSmartherAccountHandlers() {\n+        return handlers;\n+    }\n+\n+    /**\n+     * Searches the {@link SmartherAccountHandler} handler that matches the given Thing UID.\n+     *\n+     * @param thingUID\n+     *            the UID of the Thing to match the handler with\n+     *\n+     * @return the handler matching the given Thing UID, or {@code null} if none matches\n+     */\n+    private @Nullable SmartherAccountHandler getAccountListenerByUID(String thingUID) {\n+        final Optional<SmartherAccountHandler> maybeListener = handlers.stream().filter(l -> l.equalsThingUID(thingUID))\n+                .findFirst();\n+        return (maybeListener.isPresent()) ? maybeListener.get() : null;\n+    }\n+\n+    /**\n+     * Searches the {@link SmartherAccountHandler} handler that matches the given location plant.\n+     *\n+     * @param plantId\n+     *            the identifier of the plant to match the handler with\n+     *\n+     * @return the handler matching the given location plant, or {@code null} if none matches\n+     */\n+    private @Nullable SmartherAccountHandler getAccountListenerByLocation(String plantId) {\n+        final Optional<SmartherAccountHandler> maybeListener = handlers.stream().filter(l -> l.hasLocation(plantId))\n+                .findFirst();\n+        return (maybeListener.isPresent()) ? maybeListener.get() : null;", "originalCommit": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcyMDU5OA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439720598", "bodyText": "Same error that orElse argument cannot be null :/", "author": "MrRonfo", "createdAt": "2020-06-13T08:18:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNTUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNjU2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439716568", "bodyText": "Using BufferedReader.lines() does not result in the closing of the reader after the operation is complete, the Reader would still need to be closed manually.\nAlthough less concise than what you've written, I feel that the following code would be more correct and more performant.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        final String requestBody = request.getReader().lines().collect(Collectors.joining(System.lineSeparator()));\n          \n          \n            \n                        final String requestBody; \n          \n          \n            \n                        try(Reader reader = request.getReader()){\n          \n          \n            \n                            StringWriter writer = new StringWriter();\n          \n          \n            \n                            int c;\n          \n          \n            \n                            while((c = reader.read()) != -1){\n          \n          \n            \n                                writer.write(c);\n          \n          \n            \n                            }\n          \n          \n            \n                            requestBody = writer.toString();\n          \n          \n            \n                        }\n          \n      \n    \n    \n  \n\nWDYT?", "author": "cpmeister", "createdAt": "2020-06-13T07:07:56Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherNotificationServlet.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.util.ModelUtil;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+/**\n+ * The {@code SmartherNotificationServlet} class acts as the registered endpoint to receive module status notifications\n+ * from the Legrand/Bticino C2C Webhook notification service.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherNotificationServlet extends HttpServlet {\n+\n+    private static final long serialVersionUID = -2474355132186048438L;\n+\n+    private static final String CONTENT_TYPE = \"application/json;charset=UTF-8\";\n+    private static final String OK_RESULT_MSG = \"{\\\"result\\\":0}\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherNotificationServlet.class);\n+\n+    private final SmartherAccountService accountService;\n+\n+    /**\n+     * Constructs a {@code SmartherNotificationServlet} associated to the given {@link SmartherAccountService} service.\n+     *\n+     * @param accountService\n+     *            the account service to associate to the servlet\n+     */\n+    public SmartherNotificationServlet(SmartherAccountService accountService) {\n+        this.accountService = accountService;\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest request, @Nullable HttpServletResponse response)\n+            throws ServletException, IOException {\n+        if (request != null && response != null) {\n+            logger.debug(\"Notification callback servlet received POST request {}\", request.getRequestURI());\n+\n+            // Handle the received data\n+            final String requestBody = request.getReader().lines().collect(Collectors.joining(System.lineSeparator()));", "originalCommit": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcyOTIyMg==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439729222", "bodyText": "Hmmm... found something similar on StackOverflow: https://stackoverflow.com/questions/1808248/is-is-necessary-to-close-the-input-stream-returned-from-httpservletrequest\nJust reporting here the key paragraph, which I tend to agree to:\n\nThe thumb rule in I/O is, if you did not open/create the inputstream source yourself, then you do not necessarily need to close it as well. Here you are just wrapping the request's inputstream, so you don't necessarily need to close it.\n\nThe Servlet container should be in charge of closing the request stream.", "author": "MrRonfo", "createdAt": "2020-06-13T10:41:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNjU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2MTI4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439761289", "bodyText": "hmm, in that case you can just do it without the try-with-resources.", "author": "cpmeister", "createdAt": "2020-06-13T19:01:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNjU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3MDU5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439770592", "bodyText": "It seems to me your code reads int tokens from request body instead of Strings. Am I missing something ?\nI'd tend to accept your approach as more performant, however I'd slightly change it to something like:\nReader reader = request.getReader();\nfinal StringWriter writer = new StringWriter();\nchar[] buffer = new char[4096];\nint n = 0;\nwhile (-1 != (n = reader.read(buffer))) {\n    writer.write(buffer, 0, n);\n}\nfinal String requestBody = writer.toString();", "author": "MrRonfo", "createdAt": "2020-06-13T21:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNjU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3MzkyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439773928", "bodyText": "It seems to me your code reads int tokens from request body instead of Strings. Am I missing something ?\n\nEach int token is cast to a char as part of Writer.write(int).\n\nI'd tend to accept your approach as more performant, however I'd slightly change it to something like:\n\nIn general you would be correct, but the reason that I didn't use an intermediate buffer in my suggestion was because getReader returns a BufferedReader already, which means that data will be read by bulk for you behind the scenes. Because the reader is already doing buffering, there is no need for us to do buffering of our own as well.\nSo this would be more than sufficient:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        final String requestBody = request.getReader().lines().collect(Collectors.joining(System.lineSeparator()));\n          \n          \n            \n                        BufferedReader reader = request.getReader();\n          \n          \n            \n                        StringWriter writer = new StringWriter();\n          \n          \n            \n                        int c;\n          \n          \n            \n                        while((c = reader.read()) != -1){\n          \n          \n            \n                            writer.write(c);\n          \n          \n            \n                        }\n          \n          \n            \n                        final String requestBody = writer.toString();", "author": "cpmeister", "createdAt": "2020-06-13T22:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNjU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgwNzc2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439807764", "bodyText": "I agree. Changed.", "author": "MrRonfo", "createdAt": "2020-06-14T09:02:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNjU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNjgxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439716815", "bodyText": "You should probably catch the json parsing exception that is thrown here.", "author": "cpmeister", "createdAt": "2020-06-13T07:12:53Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherNotificationServlet.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.util.ModelUtil;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+/**\n+ * The {@code SmartherNotificationServlet} class acts as the registered endpoint to receive module status notifications\n+ * from the Legrand/Bticino C2C Webhook notification service.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherNotificationServlet extends HttpServlet {\n+\n+    private static final long serialVersionUID = -2474355132186048438L;\n+\n+    private static final String CONTENT_TYPE = \"application/json;charset=UTF-8\";\n+    private static final String OK_RESULT_MSG = \"{\\\"result\\\":0}\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherNotificationServlet.class);\n+\n+    private final SmartherAccountService accountService;\n+\n+    /**\n+     * Constructs a {@code SmartherNotificationServlet} associated to the given {@link SmartherAccountService} service.\n+     *\n+     * @param accountService\n+     *            the account service to associate to the servlet\n+     */\n+    public SmartherNotificationServlet(SmartherAccountService accountService) {\n+        this.accountService = accountService;\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest request, @Nullable HttpServletResponse response)\n+            throws ServletException, IOException {\n+        if (request != null && response != null) {\n+            logger.debug(\"Notification callback servlet received POST request {}\", request.getRequestURI());\n+\n+            // Handle the received data\n+            final String requestBody = request.getReader().lines().collect(Collectors.joining(System.lineSeparator()));\n+            final String responseBody = dispatchNotifications(requestBody);\n+\n+            // Build a http 200 (Success) response for the caller\n+            response.setContentType(CONTENT_TYPE);\n+            response.setStatus(HttpStatus.OK_200);\n+            response.getWriter().append(responseBody);\n+            response.getWriter().close();\n+        } else if (response != null) {\n+            // Build a http 400 (Bad Request) error response for the caller\n+            response.setContentType(CONTENT_TYPE);\n+            response.setStatus(HttpStatus.BAD_REQUEST_400);\n+            response.getWriter().close();\n+        } else {\n+            throw new ServletException(\"Notification callback with null request/response\");\n+        }\n+    }\n+\n+    /**\n+     * Dispatches all the notifications contained in the received payload to the proper notification handlers.\n+     * The response to the notification service is generated based on the different outcomes.\n+     *\n+     * @param payload\n+     *            the received servlet payload to process, may be {@code null}\n+     *\n+     * @return a string containing the response to the notification service\n+     */\n+    private String dispatchNotifications(@Nullable String payload) {\n+        logger.trace(\"C2C listener received payload: {}\", payload);\n+        if (!StringUtil.isBlank(payload)) {\n+            List<Notification> notifications = ModelUtil.gsonInstance().fromJson(payload,", "originalCommit": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNjg1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439716858", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Map<String, Object> rootMap = new IdentityHashMap<String, Object>();\n          \n          \n            \n                    Map<String, Object> rootMap = new IdentityHashMap<>();", "author": "cpmeister", "createdAt": "2020-06-13T07:13:36Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/SmartherApi.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api;\n+\n+import static org.eclipse.jetty.http.HttpMethod.*;\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.function.Function;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.smarther.internal.api.dto.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.MeasureUnit;\n+import org.openhab.binding.smarther.internal.api.dto.Module;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Plant;\n+import org.openhab.binding.smarther.internal.api.dto.Plants;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.dto.Subscription;\n+import org.openhab.binding.smarther.internal.api.dto.Topology;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherTokenExpiredException;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.ModelUtil;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+/**\n+ * The {@code SmartherApi} class is used to communicate with the BTicino/Legrand API gateway.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherApi {\n+\n+    private static final String CONTENT_TYPE = \"application/json\";\n+    private static final String BEARER = \"Bearer \";\n+\n+    // API gateway request headers\n+    private static final String HEADER_ACCEPT = \"Accept\";\n+    // API gateway request attributes\n+    private static final String ATTR_FUNCTION = \"function\";\n+    private static final String ATTR_MODE = \"mode\";\n+    private static final String ATTR_PROGRAMS = \"programs\";\n+    private static final String ATTR_NUMBER = \"number\";\n+    private static final String ATTR_SETPOINT = \"setPoint\";\n+    private static final String ATTR_VALUE = \"value\";\n+    private static final String ATTR_UNIT = \"unit\";\n+    private static final String ATTR_ACTIVATION_TIME = \"activationTime\";\n+    private static final String ATTR_ENDPOINT_URL = \"EndPointUrl\";\n+    // API gateway operation paths\n+    private static final String PATH_PLANTS = \"/plants\";\n+    private static final String PATH_TOPOLOGY = PATH_PLANTS + \"/%s/topology\";\n+    private static final String PATH_MODULE = \"/chronothermostat/thermoregulation/addressLocation/plants/%s/modules/parameter/id/value/%s\";\n+    private static final String PATH_PROGRAMS = \"/programlist\";\n+    private static final String PATH_SUBSCRIPTIONS = \"/subscription\";\n+    private static final String PATH_SUBSCRIBE = PATH_PLANTS + \"/%s/subscription\";\n+    private static final String PATH_UNSUBSCRIBE = PATH_SUBSCRIBE + \"/%s\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherApi.class);\n+\n+    private final OAuthClientService oAuthClientService;\n+    private final String oAuthSubscriptionKey;\n+    private final SmartherApiConnector connector;\n+\n+    /**\n+     * Constructs a {@code SmartherApi} to the API gateway with the specified OAuth2 attributes (subscription key and\n+     * client service), scheduler service and http client.\n+     *\n+     * @param clientService\n+     *            the OAuth2 authorization client service to be used\n+     * @param subscriptionKey\n+     *            the OAuth2 subscription key to be used with the given client service\n+     * @param scheduler\n+     *            the scheduler to be used to reschedule calls when rate limit exceeded or call not succeeded\n+     * @param httpClient\n+     *            the http client to be used to make http calls to the API gateway\n+     */\n+    public SmartherApi(final OAuthClientService clientService, final String subscriptionKey,\n+            final ScheduledExecutorService scheduler, final HttpClient httpClient) {\n+        this.oAuthClientService = clientService;\n+        this.oAuthSubscriptionKey = subscriptionKey;\n+        this.connector = new SmartherApiConnector(scheduler, httpClient);\n+    }\n+\n+    /**\n+     * Returns the plants registered under the Smarther account the bridge has been configured with.\n+     *\n+     * @return the list of registered plants, or an empty {@link List} in case of no plants found\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public List<Plant> getPlants() throws SmartherGatewayException {\n+        final ContentResponse response = requestBasic(GET, PATH_PLANTS);\n+        if (response.getStatus() == HttpStatus.NO_CONTENT_204) {\n+            return new ArrayList<>();\n+        } else {\n+            return ModelUtil.gsonInstance().fromJson(response.getContentAsString(), Plants.class).getPlants();\n+        }\n+    }\n+\n+    /**\n+     * Returns the chronothermostat modules registered in the given plant.\n+     *\n+     * @param plantId\n+     *            the identifier of the plant\n+     *\n+     * @return the list of registered modules, or an empty {@link List} in case the plant contains no module\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public List<Module> getPlantModules(String plantId) throws SmartherGatewayException {\n+        final ContentResponse response = requestBasic(GET, String.format(PATH_TOPOLOGY, plantId));\n+        final Topology topology = ModelUtil.gsonInstance().fromJson(response.getContentAsString(), Topology.class);\n+        return topology.getModules();\n+    }\n+\n+    /**\n+     * Returns the current status of a given chronothermostat module.\n+     *\n+     * @param plantId\n+     *            the identifier of the plant\n+     * @param moduleId\n+     *            the identifier of the chronothermostat module inside the plant\n+     *\n+     * @return the current status of the chronothermostat module\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public ModuleStatus getModuleStatus(String plantId, String moduleId) throws SmartherGatewayException {\n+        final ContentResponse response = requestModule(GET, plantId, moduleId, null);\n+        return ModelUtil.gsonInstance().fromJson(response.getContentAsString(), ModuleStatus.class);\n+    }\n+\n+    /**\n+     * Sends new settings to be applied to a given chronothermostat module.\n+     *\n+     * @param settings\n+     *            the module settings to be applied\n+     *\n+     * @return {@code true} if the settings have been successfully applied, {@code false} otherwise\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public boolean setModuleStatus(ModuleSettings settings) throws SmartherGatewayException {\n+        // Prepare request payload\n+        Map<String, Object> rootMap = new IdentityHashMap<String, Object>();", "originalCommit": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNjkyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439716924", "bodyText": "You should catch the json syntax exception anywhere you are using gson.", "author": "cpmeister", "createdAt": "2020-06-13T07:14:56Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/SmartherApi.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api;\n+\n+import static org.eclipse.jetty.http.HttpMethod.*;\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.function.Function;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.smarther.internal.api.dto.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.MeasureUnit;\n+import org.openhab.binding.smarther.internal.api.dto.Module;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Plant;\n+import org.openhab.binding.smarther.internal.api.dto.Plants;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.dto.Subscription;\n+import org.openhab.binding.smarther.internal.api.dto.Topology;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherTokenExpiredException;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.ModelUtil;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+/**\n+ * The {@code SmartherApi} class is used to communicate with the BTicino/Legrand API gateway.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherApi {\n+\n+    private static final String CONTENT_TYPE = \"application/json\";\n+    private static final String BEARER = \"Bearer \";\n+\n+    // API gateway request headers\n+    private static final String HEADER_ACCEPT = \"Accept\";\n+    // API gateway request attributes\n+    private static final String ATTR_FUNCTION = \"function\";\n+    private static final String ATTR_MODE = \"mode\";\n+    private static final String ATTR_PROGRAMS = \"programs\";\n+    private static final String ATTR_NUMBER = \"number\";\n+    private static final String ATTR_SETPOINT = \"setPoint\";\n+    private static final String ATTR_VALUE = \"value\";\n+    private static final String ATTR_UNIT = \"unit\";\n+    private static final String ATTR_ACTIVATION_TIME = \"activationTime\";\n+    private static final String ATTR_ENDPOINT_URL = \"EndPointUrl\";\n+    // API gateway operation paths\n+    private static final String PATH_PLANTS = \"/plants\";\n+    private static final String PATH_TOPOLOGY = PATH_PLANTS + \"/%s/topology\";\n+    private static final String PATH_MODULE = \"/chronothermostat/thermoregulation/addressLocation/plants/%s/modules/parameter/id/value/%s\";\n+    private static final String PATH_PROGRAMS = \"/programlist\";\n+    private static final String PATH_SUBSCRIPTIONS = \"/subscription\";\n+    private static final String PATH_SUBSCRIBE = PATH_PLANTS + \"/%s/subscription\";\n+    private static final String PATH_UNSUBSCRIBE = PATH_SUBSCRIBE + \"/%s\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherApi.class);\n+\n+    private final OAuthClientService oAuthClientService;\n+    private final String oAuthSubscriptionKey;\n+    private final SmartherApiConnector connector;\n+\n+    /**\n+     * Constructs a {@code SmartherApi} to the API gateway with the specified OAuth2 attributes (subscription key and\n+     * client service), scheduler service and http client.\n+     *\n+     * @param clientService\n+     *            the OAuth2 authorization client service to be used\n+     * @param subscriptionKey\n+     *            the OAuth2 subscription key to be used with the given client service\n+     * @param scheduler\n+     *            the scheduler to be used to reschedule calls when rate limit exceeded or call not succeeded\n+     * @param httpClient\n+     *            the http client to be used to make http calls to the API gateway\n+     */\n+    public SmartherApi(final OAuthClientService clientService, final String subscriptionKey,\n+            final ScheduledExecutorService scheduler, final HttpClient httpClient) {\n+        this.oAuthClientService = clientService;\n+        this.oAuthSubscriptionKey = subscriptionKey;\n+        this.connector = new SmartherApiConnector(scheduler, httpClient);\n+    }\n+\n+    /**\n+     * Returns the plants registered under the Smarther account the bridge has been configured with.\n+     *\n+     * @return the list of registered plants, or an empty {@link List} in case of no plants found\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public List<Plant> getPlants() throws SmartherGatewayException {\n+        final ContentResponse response = requestBasic(GET, PATH_PLANTS);\n+        if (response.getStatus() == HttpStatus.NO_CONTENT_204) {\n+            return new ArrayList<>();\n+        } else {\n+            return ModelUtil.gsonInstance().fromJson(response.getContentAsString(), Plants.class).getPlants();\n+        }\n+    }\n+\n+    /**\n+     * Returns the chronothermostat modules registered in the given plant.\n+     *\n+     * @param plantId\n+     *            the identifier of the plant\n+     *\n+     * @return the list of registered modules, or an empty {@link List} in case the plant contains no module\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public List<Module> getPlantModules(String plantId) throws SmartherGatewayException {\n+        final ContentResponse response = requestBasic(GET, String.format(PATH_TOPOLOGY, plantId));\n+        final Topology topology = ModelUtil.gsonInstance().fromJson(response.getContentAsString(), Topology.class);\n+        return topology.getModules();\n+    }\n+\n+    /**\n+     * Returns the current status of a given chronothermostat module.\n+     *\n+     * @param plantId\n+     *            the identifier of the plant\n+     * @param moduleId\n+     *            the identifier of the chronothermostat module inside the plant\n+     *\n+     * @return the current status of the chronothermostat module\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public ModuleStatus getModuleStatus(String plantId, String moduleId) throws SmartherGatewayException {\n+        final ContentResponse response = requestModule(GET, plantId, moduleId, null);\n+        return ModelUtil.gsonInstance().fromJson(response.getContentAsString(), ModuleStatus.class);\n+    }\n+\n+    /**\n+     * Sends new settings to be applied to a given chronothermostat module.\n+     *\n+     * @param settings\n+     *            the module settings to be applied\n+     *\n+     * @return {@code true} if the settings have been successfully applied, {@code false} otherwise\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public boolean setModuleStatus(ModuleSettings settings) throws SmartherGatewayException {\n+        // Prepare request payload\n+        Map<String, Object> rootMap = new IdentityHashMap<String, Object>();\n+        rootMap.put(ATTR_FUNCTION, settings.getFunction().getValue());\n+        rootMap.put(ATTR_MODE, settings.getMode().getValue());\n+        switch (settings.getMode()) {\n+            case AUTOMATIC:\n+                // {\"function\":\"heating\",\"mode\":\"automatic\",\"programs\":[{\"number\":0}]}\n+                Map<String, Integer> programMap = new IdentityHashMap<String, Integer>();\n+                programMap.put(ATTR_NUMBER, Integer.valueOf(settings.getProgram()));\n+                List<Map<String, Integer>> programsList = new ArrayList<>();\n+                programsList.add(programMap);\n+                rootMap.put(ATTR_PROGRAMS, programsList);\n+                break;\n+            case MANUAL:\n+                // {\"function\":\"heating\",\"mode\":\"manual\",\"setPoint\":{\"value\":0.0,\"unit\":\"C\"},\"activationTime\":\"X\"}\n+                QuantityType<Temperature> newTemperature = settings.getSetPointTemperature(SIUnits.CELSIUS);\n+                if (newTemperature == null) {\n+                    throw new SmartherGatewayException(\"Invalid temperature unit transformation\");\n+                }\n+                Map<String, Object> setPointMap = new IdentityHashMap<String, Object>();\n+                setPointMap.put(ATTR_VALUE, newTemperature.doubleValue());\n+                setPointMap.put(ATTR_UNIT, MeasureUnit.CELSIUS.getValue());\n+                rootMap.put(ATTR_SETPOINT, setPointMap);\n+                rootMap.put(ATTR_ACTIVATION_TIME, settings.getActivationTime());\n+                break;\n+            case BOOST:\n+                // {\"function\":\"heating\",\"mode\":\"boost\",\"activationTime\":\"X\"}\n+                rootMap.put(ATTR_ACTIVATION_TIME, settings.getActivationTime());\n+                break;\n+            case OFF:\n+                // {\"function\":\"heating\",\"mode\":\"off\"}\n+                break;\n+            case PROTECTION:\n+                // {\"function\":\"heating\",\"mode\":\"protection\"}\n+                break;\n+        }\n+        final String jsonPayload = ModelUtil.gsonInstance().toJson(rootMap);\n+\n+        // Send request to server\n+        final ContentResponse response = requestModule(POST, settings.getPlantId(), settings.getModuleId(),\n+                jsonPayload);\n+        return (response.getStatus() == HttpStatus.OK_200);\n+    }\n+\n+    /**\n+     * Returns the automatic mode programs registered for the given chronothermostat module.\n+     *\n+     * @param plantId\n+     *            the identifier of the plant\n+     * @param moduleId\n+     *            the identifier of the chronothermostat module inside the plant\n+     *\n+     * @return the list of registered programs, or an empty {@link List} in case of no programs found\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public List<Program> getModulePrograms(String plantId, String moduleId) throws SmartherGatewayException {\n+        final ContentResponse response = requestModule(GET, plantId, moduleId, PATH_PROGRAMS, null);\n+        final ModuleStatus moduleStatus = ModelUtil.gsonInstance().fromJson(response.getContentAsString(),\n+                ModuleStatus.class);\n+\n+        final Chronothermostat chronothermostat = moduleStatus.toChronothermostat();\n+        return (chronothermostat != null) ? chronothermostat.getPrograms() : Collections.emptyList();\n+    }\n+\n+    /**\n+     * Returns the subscriptions registered to the C2C Webhook, where modules status notifications are currently sent\n+     * for all the plants.\n+     *\n+     * @return the list of registered subscriptions, or an empty {@link List} in case of no subscriptions found\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public List<Subscription> getSubscriptions() throws SmartherGatewayException {\n+        final ContentResponse response = requestBasic(GET, PATH_SUBSCRIPTIONS);\n+        if (response.getStatus() == HttpStatus.NO_CONTENT_204) {\n+            return new ArrayList<>();\n+        } else {\n+            return ModelUtil.gsonInstance().fromJson(response.getContentAsString(),", "originalCommit": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNzE3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439717173", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Map<String, Object> properties = new HashMap<String, Object>();\n          \n          \n            \n                    Map<String, Object> properties = new HashMap<>();", "author": "cpmeister", "createdAt": "2020-06-13T07:19:55Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/discovery/SmartherModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.discovery;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.api.dto.Location;\n+import org.openhab.binding.smarther.internal.api.dto.Module;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherModuleDiscoveryService} queries the Smarther API gateway to discover available Chronothermostat\n+ * modules inside existing plants registered under the configured Bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherModuleDiscoveryService extends AbstractDiscoveryService implements ThingHandlerService {\n+\n+    // Only modules can be discovered. A bridge must be manually added.\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_MODULE);\n+    // The call to listModules is fast\n+    private static final int DISCOVERY_TIME_SECONDS = 10;\n+\n+    // Handling of the background scan for new devices\n+    private static final boolean BACKGROUND_SCAN_ENABLED = false;\n+    private static final long BACKGROUND_SCAN_REFRESH_MINUTES = 1;\n+\n+    private static final String ID_SEPARATOR = \"-\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherModuleDiscoveryService.class);\n+\n+    private @Nullable SmartherAccountHandler bridgeHandler;\n+    private @Nullable ThingUID bridgeUID;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    /**\n+     * Constructs a {@code SmartherModuleDiscoveryService}.\n+     */\n+    public SmartherModuleDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_TIME_SECONDS);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public void activate() {\n+        Map<String, @Nullable Object> properties = new HashMap<>();\n+        properties.put(DiscoveryService.CONFIG_PROPERTY_BACKGROUND_DISCOVERY, Boolean.TRUE);\n+        super.activate(properties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        removeOlderResults(new Date().getTime());\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof SmartherAccountHandler) {\n+            final SmartherAccountHandler localBridgeHandler = (SmartherAccountHandler) handler;\n+            this.bridgeHandler = localBridgeHandler;\n+            this.bridgeUID = localBridgeHandler.getUID();\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return this.bridgeHandler;\n+    }\n+\n+    @Override\n+    protected synchronized void startBackgroundDiscovery() {\n+        stopBackgroundDiscovery();\n+        if (BACKGROUND_SCAN_ENABLED) {\n+            this.backgroundFuture = scheduler.scheduleWithFixedDelay(this::startScan, BACKGROUND_SCAN_REFRESH_MINUTES,\n+                    BACKGROUND_SCAN_REFRESH_MINUTES, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    protected synchronized void stopBackgroundDiscovery() {\n+        final ScheduledFuture<?> localBackgroundFuture = this.backgroundFuture;\n+        if (localBackgroundFuture != null) {\n+            if (!localBackgroundFuture.isCancelled()) {\n+                localBackgroundFuture.cancel(true);\n+            }\n+            this.backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        final SmartherAccountHandler localBridgeHandler = this.bridgeHandler;\n+        if (localBridgeHandler != null) {\n+            // If the bridge is not online no other thing devices can be found, so no reason to scan at this moment\n+            if (localBridgeHandler.isOnline()) {\n+                logger.debug(\"Starting modules discovery for bridge {}\", this.bridgeUID);\n+                localBridgeHandler.getLocations()\n+                        .forEach(l -> localBridgeHandler.getLocationModules(l).forEach(m -> thingDiscovered(l, m)));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected synchronized void stopScan() {\n+        super.stopScan();\n+        removeOlderResults(getTimestampOfLastScan());\n+    }\n+\n+    /**\n+     * Creates a Chronothermostat module Thing based on the remotely discovered location and module.\n+     *\n+     * @param location\n+     *            the location containing the discovered module\n+     * @param module\n+     *            the discovered module\n+     */\n+    private void thingDiscovered(Location location, Module module) {\n+        Map<String, Object> properties = new HashMap<String, Object>();", "originalCommit": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNzM5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439717394", "bodyText": "Was the AuthorizationUrl supposed to be  included in this message?\nYou should also include the exception or at least the exception's message in the log as well.", "author": "cpmeister", "createdAt": "2020-06-13T07:23:15Z", "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherBridgeHandler.java", "diffHunk": "@@ -0,0 +1,762 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthFactory;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.account.SmartherNotificationHandler;\n+import org.openhab.binding.smarther.internal.api.SmartherApi;\n+import org.openhab.binding.smarther.internal.api.dto.Location;\n+import org.openhab.binding.smarther.internal.api.dto.Module;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Plant;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.dto.Subscription;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.config.SmartherBridgeConfiguration;\n+import org.openhab.binding.smarther.internal.discovery.SmartherModuleDiscoveryService;\n+import org.openhab.binding.smarther.internal.model.BridgeStatus;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherBridgeHandler} class is responsible of the handling of a Smarther Bridge thing.\n+ * The Smarther Bridge is used to manage a set of Smarther Chronothermostat Modules registered under the same\n+ * Legrand/Bticino account credentials.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherBridgeHandler extends BaseBridgeHandler\n+        implements SmartherAccountHandler, SmartherNotificationHandler, AccessTokenRefreshListener {\n+\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherBridgeHandler.class);\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HttpClient httpClient;\n+\n+    // Bridge configuration\n+    private SmartherBridgeConfiguration config;\n+\n+    // Field members assigned in initialize method\n+    private @Nullable Future<?> pollFuture;\n+    private @Nullable OAuthClientService oAuthService;\n+    private @Nullable SmartherApi smartherApi;\n+    private @Nullable ExpiringCache<List<Location>> locationCache;\n+    private @Nullable BridgeStatus bridgeStatus;\n+\n+    /**\n+     * Constructs a {@code SmartherBridgeHandler} for the given Bridge thing, authorization factory and http client.\n+     *\n+     * @param bridge\n+     *            the {@link Bridge} thing to be used\n+     * @param oAuthFactory\n+     *            the OAuth2 authorization factory to be used\n+     * @param httpClient\n+     *            the http client to be used\n+     */\n+    public SmartherBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HttpClient httpClient) {\n+        super(bridge);\n+        this.oAuthFactory = oAuthFactory;\n+        this.httpClient = httpClient;\n+        this.config = new SmartherBridgeConfiguration();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(SmartherModuleDiscoveryService.class);\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge thing lifecycle management methods\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Bridge[{}] Initialize handler\", thing.getUID());\n+\n+        this.config = getConfigAs(SmartherBridgeConfiguration.class);\n+        if (StringUtil.isBlank(config.getSubscriptionKey())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Subscription Key' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.getClientId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.getClientSecret())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Secret' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        // Initialize OAuth2 authentication support\n+        final OAuthClientService localOAuthService = oAuthFactory.createOAuthClientService(thing.getUID().getAsString(),\n+                SMARTHER_API_TOKEN_URL, SMARTHER_AUTHORIZE_URL, config.getClientId(), config.getClientSecret(),\n+                SMARTHER_API_SCOPES, false);\n+        localOAuthService.addAccessTokenRefreshListener(SmartherBridgeHandler.this);\n+        this.oAuthService = localOAuthService;\n+\n+        // Initialize Smarther Api\n+        final SmartherApi localSmartherApi = new SmartherApi(localOAuthService, config.getSubscriptionKey(), scheduler,\n+                httpClient);\n+        this.smartherApi = localSmartherApi;\n+\n+        // Initialize locations (plant Ids) local cache\n+        final ExpiringCache<List<Location>> localLocationCache = new ExpiringCache<>(\n+                Duration.ofMinutes(config.getStatusRefreshPeriod()), this::locationCacheAction);\n+        this.locationCache = localLocationCache;\n+\n+        // Initialize bridge local status\n+        final BridgeStatus localBridgeStatus = new BridgeStatus();\n+        this.bridgeStatus = localBridgeStatus;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        schedulePoll();\n+\n+        logger.debug(\"Bridge[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Bridge[{}] Manually triggered channel to refresh the Bridge config\",\n+                                thing.getUID());\n+                        schedulePoll();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Bridge[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Bridge[{}] Dispose handler\", thing.getUID());\n+        final OAuthClientService localOAuthService = this.oAuthService;\n+        if (localOAuthService != null) {\n+            localOAuthService.removeAccessTokenRefreshListener(this);\n+        }\n+        this.oAuthFactory.ungetOAuthService(thing.getUID().getAsString());\n+        stopPoll(true);\n+        logger.debug(\"Bridge[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge data cache management methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Returns the available locations to be cached for this Bridge.\n+     *\n+     * @return the available locations to be cached for this Bridge, or {@code null} if the list of available locations\n+     *         cannot be retrieved\n+     */\n+    private @Nullable List<Location> locationCacheAction() {\n+        try {\n+            // Retrieve the plants list from the API Gateway\n+            final List<Plant> plants = getPlants();\n+\n+            List<Location> locations;\n+            if (config.isUseNotifications()) {\n+                // Retrieve the subscriptions list from the API Gateway\n+                final List<Subscription> subscriptions = getSubscriptions();\n+\n+                // Enrich the notifications list with externally registered subscriptions\n+                updateNotifications(subscriptions);\n+\n+                // Get the notifications list from bridge config\n+                final List<String> notifications = config.getNotifications();\n+\n+                locations = plants.stream().map(p -> Location.fromPlant(p, subscriptions.stream()\n+                        .filter(s -> s.getPlantId().equals(p.getId()) && notifications.contains(s.getSubscriptionId()))\n+                        .findFirst())).collect(Collectors.toList());\n+            } else {\n+                locations = plants.stream().map(p -> Location.fromPlant(p)).collect(Collectors.toList());\n+            }\n+            logger.debug(\"Bridge[{}] Available locations: {}\", thing.getUID(), locations);\n+\n+            return locations;\n+\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Bridge[{}] Cannot retrieve available locations: {}\", thing.getUID(), e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Updates this Bridge local notifications list with externally registered subscriptions.\n+     *\n+     * @param subscriptions\n+     *            the externally registered subscriptions to be added to the local notifications list\n+     */\n+    private void updateNotifications(List<Subscription> subscriptions) {\n+        // Get the notifications list from bridge config\n+        List<String> notifications = config.getNotifications();\n+\n+        for (Subscription s : subscriptions) {\n+            if (s.getEndpointUrl().equalsIgnoreCase(config.getNotificationUrl())\n+                    && !notifications.contains(s.getSubscriptionId())) {\n+                // Add the external subscription to notifications list\n+                notifications = config.addNotification(s.getSubscriptionId());\n+\n+                // Save the updated notifications list back to bridge config\n+                Configuration configuration = editConfiguration();\n+                configuration.put(PROPERTY_NOTIFICATIONS, notifications);\n+                updateConfiguration(configuration);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets all the cache to \"expired\" for this Bridge.\n+     */\n+    private void expireCache() {\n+        logger.debug(\"Bridge[{}] Invalidating location cache\", thing.getUID());\n+        final ExpiringCache<List<Location>> localLocationCache = this.locationCache;\n+        if (localLocationCache != null) {\n+            localLocationCache.invalidateValue();\n+        }\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge status polling mechanism methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Starts a new scheduler to periodically poll and update this Bridge status.\n+     */\n+    private void schedulePoll() {\n+        stopPoll(false);\n+\n+        // Schedule poll to start after POLL_INITIAL_DELAY sec and run periodically based on status refresh period\n+        final Future<?> localPollFuture = scheduler.scheduleWithFixedDelay(this::poll, POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod() * 60, TimeUnit.SECONDS);\n+        this.pollFuture = localPollFuture;\n+\n+        logger.debug(\"Bridge[{}] Scheduled poll for {} sec out, then every {} min\", thing.getUID(), POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod());\n+    }\n+\n+    /**\n+     * Cancels all running poll schedulers.\n+     *\n+     * @param mayInterruptIfRunning\n+     *            {@code true} if the thread executing this task should be interrupted, {@code false} if the in-progress\n+     *            tasks are allowed to complete\n+     */\n+    private synchronized void stopPoll(boolean mayInterruptIfRunning) {\n+        final Future<?> localPollFuture = this.pollFuture;\n+        if (localPollFuture != null) {\n+            if (!localPollFuture.isCancelled()) {\n+                localPollFuture.cancel(mayInterruptIfRunning);\n+            }\n+            this.pollFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Polls to update this Bridge status, calling the Smarther API to refresh its plants list.\n+     *\n+     * @return {@code true} if the method completes without errors, {@code false} otherwise\n+     */\n+    private synchronized boolean poll() {\n+        try {\n+            onAccessTokenResponse(getAccessTokenResponse());\n+\n+            expireCache();\n+            locationCacheAction();\n+\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (SmartherAuthorizationException e) {\n+            logger.warn(\"Bridge[{}] Authorization error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+        } catch (RuntimeException e) {\n+            // All other exceptions apart from Authorization and Gateway issues\n+            logger.warn(\"Bridge[{}] Unexpected error during polling, please report if this keeps occurring: \",\n+                    thing.getUID(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+        }\n+        schedulePoll();\n+        return false;\n+    }\n+\n+    @Override\n+    public void onAccessTokenResponse(@Nullable AccessTokenResponse tokenResponse) {\n+        updateChannelState(CHANNEL_ACCESS_TOKEN,\n+                new StringType((tokenResponse == null) ? null : tokenResponse.getAccessToken()));\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge convenience methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Convenience method to get this Bridge configuration.\n+     *\n+     * @return a {@link SmartherBridgeConfiguration} object containing the Bridge configuration\n+     */\n+    public SmartherBridgeConfiguration getSmartherBridgeConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Convenience method to get the access token from Smarther API authorization layer.\n+     *\n+     * @return the autorization access token, may be {@code null}\n+     *\n+     * @throws {@link SmartherAuthorizationException}\n+     *             in case of authorization issues with the Smarther API\n+     */\n+    private @Nullable AccessTokenResponse getAccessTokenResponse() throws SmartherAuthorizationException {\n+        try {\n+            final OAuthClientService localOAuthService = this.oAuthService;\n+            if (localOAuthService != null) {\n+                return localOAuthService.getAccessTokenResponse();\n+            }\n+            return null;\n+        } catch (OAuthException | IOException | OAuthResponseException | RuntimeException e) {\n+            throw new SmartherAuthorizationException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to update the given Channel state \"only\" if the Channel is linked.\n+     *\n+     * @param channelId\n+     *            the identifier of the Channel to be updated\n+     * @param state\n+     *            the new state to be applied to the given Channel\n+     */\n+    private void updateChannelState(String channelId, State state) {\n+        final Channel channel = thing.getChannel(channelId);\n+\n+        if (channel != null && isLinked(channel.getUID())) {\n+            updateState(channel.getUID(), state);\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to update the Smarther API calls counter for this Bridge.\n+     */\n+    private void updateApiCallsCounter() {\n+        final BridgeStatus localBridgeStatus = this.bridgeStatus;\n+        if (localBridgeStatus != null) {\n+            updateChannelState(CHANNEL_API_CALLS_HANDLED,\n+                    new DecimalType(localBridgeStatus.incrementApiCallsHandled()));\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to check and get the Smarther API instance for this Bridge.\n+     *\n+     * @return the Smarther API instance\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case the Smarther API instance is {@code null}\n+     */\n+    private SmartherApi getSmartherApi() throws SmartherGatewayException {\n+        final SmartherApi localSmartherApi = this.smartherApi;\n+        if (localSmartherApi == null) {\n+            throw new SmartherGatewayException(\"Smarther API instance is null\");\n+        }\n+        return localSmartherApi;\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Implementation of the SmartherAccountHandler interface\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public ThingUID getUID() {\n+        return thing.getUID();\n+    }\n+\n+    @Override\n+    public String getLabel() {\n+        return StringUtil.defaultString(thing.getLabel());\n+    }\n+\n+    @Override\n+    public List<Location> getLocations() {\n+        final ExpiringCache<List<Location>> localLocationCache = this.locationCache;\n+        final List<Location> locations = (localLocationCache != null) ? localLocationCache.getValue() : null;\n+        return (locations != null) ? locations : Collections.emptyList();\n+    }\n+\n+    @Override\n+    public boolean hasLocation(String plantId) {\n+        final ExpiringCache<List<Location>> localLocationCache = this.locationCache;\n+        final List<Location> locations = (localLocationCache != null) ? localLocationCache.getValue() : null;\n+        return (locations != null) ? locations.stream().anyMatch(l -> l.getPlantId().equals(plantId)) : false;\n+    }\n+\n+    @Override\n+    public List<Plant> getPlants() throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().getPlants();\n+    }\n+\n+    @Override\n+    public List<Subscription> getSubscriptions() throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().getSubscriptions();\n+    }\n+\n+    @Override\n+    public String subscribePlant(String plantId, String notificationUrl) throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().subscribePlant(plantId, notificationUrl);\n+    }\n+\n+    @Override\n+    public void unsubscribePlant(String plantId, String subscriptionId) throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        getSmartherApi().unsubscribePlant(plantId, subscriptionId);\n+    }\n+\n+    @Override\n+    public List<Module> getLocationModules(Location location) {\n+        try {\n+            updateApiCallsCounter();\n+            return getSmartherApi().getPlantModules(location.getPlantId());\n+        } catch (SmartherGatewayException e) {\n+            return new ArrayList<>();\n+        }\n+    }\n+\n+    @Override\n+    public ModuleStatus getModuleStatus(String plantId, String moduleId) throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().getModuleStatus(plantId, moduleId);\n+    }\n+\n+    @Override\n+    public boolean setModuleStatus(ModuleSettings moduleSettings) throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().setModuleStatus(moduleSettings);\n+    }\n+\n+    @Override\n+    public List<Program> getModulePrograms(String plantId, String moduleId) throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().getModulePrograms(plantId, moduleId);\n+    }\n+\n+    @Override\n+    public boolean isAuthorized() {\n+        try {\n+            final AccessTokenResponse tokenResponse = getAccessTokenResponse();\n+            onAccessTokenResponse(tokenResponse);\n+\n+            return (tokenResponse != null && tokenResponse.getAccessToken() != null\n+                    && tokenResponse.getRefreshToken() != null);\n+        } catch (SmartherAuthorizationException e) {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOnline() {\n+        return (thing.getStatus() == ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public String authorize(String redirectUrl, String reqCode, String notificationUrl)\n+            throws SmartherGatewayException {\n+        try {\n+            logger.debug(\"Bridge[{}] Call API gateway to get access token. RedirectUri: {}\", thing.getUID(),\n+                    redirectUrl);\n+\n+            final OAuthClientService localOAuthService = this.oAuthService;\n+            if (localOAuthService == null) {\n+                throw new SmartherAuthorizationException(\"Authorization service is null\");\n+            }\n+\n+            // OAuth2 call to get access token from received authorization code\n+            localOAuthService.getAccessTokenResponseByAuthorizationCode(reqCode, redirectUrl);\n+\n+            // Store the notification URL in bridge configuration\n+            Configuration configuration = editConfiguration();\n+            configuration.put(PROPERTY_NOTIFICATION_URL, notificationUrl);\n+            updateConfiguration(configuration);\n+            config.setNotificationUrl(notificationUrl);\n+            logger.debug(\"Bridge[{}] Store notification URL: {}\", thing.getUID(), notificationUrl);\n+\n+            // Reschedule the polling thread\n+            schedulePoll();\n+\n+            return config.getClientId();\n+        } catch (OAuthResponseException e) {\n+            throw new SmartherAuthorizationException(e.toString(), e);\n+        } catch (OAuthException | IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            throw new SmartherGatewayException(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean equalsThingUID(String thingUID) {\n+        return thing.getUID().getAsString().equals(thingUID);\n+    }\n+\n+    @Override\n+    public String formatAuthorizationUrl(String redirectUri) {\n+        try {\n+            final OAuthClientService localOAuthService = this.oAuthService;\n+            if (localOAuthService != null) {\n+                return localOAuthService.getAuthorizationUrl(redirectUri, null, thing.getUID().getAsString());\n+            }\n+        } catch (OAuthException e) {\n+            logger.warn(\"Bridge[{}] Error constructing AuthorizationUrl: \", thing.getUID());", "originalCommit": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcyMDg1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439720858", "bodyText": "Yes, exception message need to be included. Thanks!", "author": "MrRonfo", "createdAt": "2020-06-13T08:22:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNzM5NA=="}], "type": "inlineReview"}, {"oid": "87295d9d1935ee21b16e175838a8b8e1ebe63dc4", "url": "https://github.com/openhab/openhab-addons/commit/87295d9d1935ee21b16e175838a8b8e1ebe63dc4", "message": "[smarther] Initial contribution\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-06-23T18:39:45Z", "type": "commit"}, {"oid": "a6af3df4ece4fffe5b97d040d4a9cd49ad88ef2a", "url": "https://github.com/openhab/openhab-addons/commit/a6af3df4ece4fffe5b97d040d4a9cd49ad88ef2a", "message": "Added link to companion HABPanel widget in README.md\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-06-23T18:39:47Z", "type": "commit"}, {"oid": "e9e7f137037113f705e17293d1d98eadf8d9e01b", "url": "https://github.com/openhab/openhab-addons/commit/e9e7f137037113f705e17293d1d98eadf8d9e01b", "message": "Fixed: Authorization Url calculation for local address, formal check of\nNotification Url. Improved: logging and application tutorial in\nREADME.md.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-06-23T18:39:50Z", "type": "commit"}, {"oid": "83835abadf1021ab62aedf7954d285e2a02e0667", "url": "https://github.com/openhab/openhab-addons/commit/83835abadf1021ab62aedf7954d285e2a02e0667", "message": "Fixed: rare use case of Legrand API temporary failure in name resolution\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-06-23T18:39:52Z", "type": "commit"}, {"oid": "7237714656aab68387c47a5e5eb37ffac83cc473", "url": "https://github.com/openhab/openhab-addons/commit/7237714656aab68387c47a5e5eb37ffac83cc473", "message": "Update bundles/org.openhab.binding.smarther/README.md\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-06-23T18:39:55Z", "type": "commit"}, {"oid": "5ddcc8a2eb2f400070d74295e8f93360116efa9d", "url": "https://github.com/openhab/openhab-addons/commit/5ddcc8a2eb2f400070d74295e8f93360116efa9d", "message": "Update bundles/org.openhab.binding.smarther/README.md\r\n\r\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-06-23T18:39:57Z", "type": "commit"}, {"oid": "0df609f27cc5df8ef3c0ac2a506b30c97ac5fb09", "url": "https://github.com/openhab/openhab-addons/commit/0df609f27cc5df8ef3c0ac2a506b30c97ac5fb09", "message": "Update bundles/org.openhab.binding.smarther/README.md\r\n\r\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-06-23T18:40:00Z", "type": "commit"}, {"oid": "99309f8f06f9d5aa9182078a3a9ef0749e46d744", "url": "https://github.com/openhab/openhab-addons/commit/99309f8f06f9d5aa9182078a3a9ef0749e46d744", "message": "Some fixes applied following PR Review from fwolter.\n\nConverted from Joda DateTime to equivalent standard Java DateUtil,\nconverted from Apache Commons to equivalent standard Java StringUtil,\nfixed Temperature conversion to SIUnit, removed unneeded items\n(suppressed annotations, RuntimeException catches, stacktrace print).\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-06-23T18:40:03Z", "type": "commit"}, {"oid": "e598b1483d8c61914caedf47021320e542b38796", "url": "https://github.com/openhab/openhab-addons/commit/e598b1483d8c61914caedf47021320e542b38796", "message": "FIxed reference to bridge authorization process.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-06-23T18:40:05Z", "type": "commit"}, {"oid": "b8d62de75887e7398e1328eb7e849cdc3dd2432f", "url": "https://github.com/openhab/openhab-addons/commit/b8d62de75887e7398e1328eb7e849cdc3dd2432f", "message": "Some fixes applied following PR Review from fwolter.\n\nMoved API model classes to dto package, upgraded from old Date classes\nto LocalDate and LocalDateTime, optimized StringUtil methods.\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-06-23T18:40:08Z", "type": "commit"}, {"oid": "bb844d820791caed15d34b311438eea3a83ae193", "url": "https://github.com/openhab/openhab-addons/commit/bb844d820791caed15d34b311438eea3a83ae193", "message": "Review of DateUtil parse usage and ZonedDateTime vs LocalDateTime.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-06-23T18:40:10Z", "type": "commit"}, {"oid": "3213258abbbc78ec1b50751dceb0e7865b0fa459", "url": "https://github.com/openhab/openhab-addons/commit/3213258abbbc78ec1b50751dceb0e7865b0fa459", "message": "Aligned pom.xml to OH 2.5.6 snapshot\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-06-23T18:40:13Z", "type": "commit"}, {"oid": "d22a03203636f6b97dc552710aae45f5d800b592", "url": "https://github.com/openhab/openhab-addons/commit/d22a03203636f6b97dc552710aae45f5d800b592", "message": "Review of unchecked exceptions and code comments\n\nMoved from unchecked to checked exceptions (reorganized the custom\nexceptions tree and reviewed all the exception handling flows in code),\nfixed remaining dependencies to Apache Commons, enhanced classes and\nmethod comments where available.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-06-23T18:40:16Z", "type": "commit"}, {"oid": "06643c37cb85d9148a765604dbcb04dd85a9da83", "url": "https://github.com/openhab/openhab-addons/commit/06643c37cb85d9148a765604dbcb04dd85a9da83", "message": "Review of exceptions, nullable items and servlet response\n\nMoved SmartherIllegalPropertyValueException to checked exception and\nhandled it where needed, converted chronothermostat variable to Nullable\nin module handler, fixed servlet response in error cases, completed\ncomments on all dto classes.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-06-23T18:40:19Z", "type": "commit"}, {"oid": "67300fbe8483c170a4f1e1cb89a17294b18849b2", "url": "https://github.com/openhab/openhab-addons/commit/67300fbe8483c170a4f1e1cb89a17294b18849b2", "message": "Fixed transition to Unknown status on Bridge thing\n\nFixed the Bridge thing transition to Unknown status in initialize\nmethod, moving it after variables initialization so that handleCommand()\nis eventually called only after.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-06-23T18:40:21Z", "type": "commit"}, {"oid": "d8631aebf8e0b632245f096d8d58b67b32d382cc", "url": "https://github.com/openhab/openhab-addons/commit/d8631aebf8e0b632245f096d8d58b67b32d382cc", "message": "Some fixes applied following PR Review from cpmeister.\n\nChanged wrong use of NonNullByDefault with Nullable wherever found,\nremoved OSGI component declaration in ThingHandlerService, fixed unit\nattribute in config.xml\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-06-23T18:40:23Z", "type": "commit"}, {"oid": "295553076105ce78c917b1b9a6fa8f129d239b76", "url": "https://github.com/openhab/openhab-addons/commit/295553076105ce78c917b1b9a6fa8f129d239b76", "message": "Some fixes applied following PR Review from cpmeister.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-06-23T18:40:26Z", "type": "commit"}, {"oid": "0d8ef84d04a0743256f0974e106fd719b73fbedf", "url": "https://github.com/openhab/openhab-addons/commit/0d8ef84d04a0743256f0974e106fd719b73fbedf", "message": "Some fixes applied following PR Review from cpmeister.\n\nAdded syntax exception handling to Json parsing calls, optimized reading\nnew notification from servlet request, fixed module discovery service.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-06-23T18:40:28Z", "type": "commit"}, {"oid": "1813b1e2848a074831e735e0a27d6c8f56e9a6e0", "url": "https://github.com/openhab/openhab-addons/commit/1813b1e2848a074831e735e0a27d6c8f56e9a6e0", "message": "Refactored binding naming from smarther to bticinosmarther\n\nJust refactored the binding naming to bticinosmarther (smarther alone\nwas too generic), as BTicino also provides other protocols that can be\nintegrated over time in OH by other developers\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-06-23T18:40:32Z", "type": "commit"}, {"oid": "1813b1e2848a074831e735e0a27d6c8f56e9a6e0", "url": "https://github.com/openhab/openhab-addons/commit/1813b1e2848a074831e735e0a27d6c8f56e9a6e0", "message": "Refactored binding naming from smarther to bticinosmarther\n\nJust refactored the binding naming to bticinosmarther (smarther alone\nwas too generic), as BTicino also provides other protocols that can be\nintegrated over time in OH by other developers\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-06-23T18:40:32Z", "type": "forcePushed"}, {"oid": "8bf252fdee587dc75178246537db8bfe456faba2", "url": "https://github.com/openhab/openhab-addons/commit/8bf252fdee587dc75178246537db8bfe456faba2", "message": "Aligned pom.xml to OH 2.5.7 snapshot\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-06-23T20:58:03Z", "type": "commit"}, {"oid": "c8440b6b00c1af6d83180be648749aec3d3e446d", "url": "https://github.com/openhab/openhab-addons/commit/c8440b6b00c1af6d83180be648749aec3d3e446d", "message": "Some fixes applied following PR Review from kaikreuzer.\n\nAligned README to OH template, fixed config locations fetch channel for\nBridge thing and config programs fetch channel for Module thing, moved\naccessToken info from channel to log at trace level.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>", "committedDate": "2020-06-27T16:22:21Z", "type": "commit"}]}