{"pr_number": 8523, "pr_title": "[tr064] Initial contribution", "pr_createdAt": "2020-09-21T17:00:28Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8523", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUwNDMyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r494504322", "bodyText": "Why is this synchronized?", "author": "cpmeister", "createdAt": "2020-09-24T17:53:22Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/SOAPConnector.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.util.Util.getSOAPElement;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import javax.xml.soap.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BytesContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescription;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SOAPConnector} provides communication with a remote SOAP device\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SOAPConnector {\n+    private static final int SOAP_TIMEOUT = 2000; // in ms\n+    private final Logger logger = LoggerFactory.getLogger(SOAPConnector.class);\n+    private final HttpClient httpClient;\n+    private final String endpointBaseURL;\n+    private final SOAPValueConverter soapValueConverter;\n+\n+    public SOAPConnector(HttpClient httpClient, String endpointBaseURL) {\n+        this.httpClient = httpClient;\n+        this.endpointBaseURL = endpointBaseURL;\n+        soapValueConverter = new SOAPValueConverter(httpClient);\n+    }\n+\n+    /**\n+     * prepare a SOAP request for an action request to a service\n+     *\n+     * @param service the service\n+     * @param soapAction the action to send\n+     * @param arguments arguments to send along with the request\n+     * @return a jetty Request containing the full SOAP message\n+     * @throws IOException if a problem while writing the SOAP message to the Request occurs\n+     * @throws SOAPException if a problem with creating the SOAP message occurs\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private Request prepareSOAPRequest(SCPDServiceType service, String soapAction, Map<String, String> arguments)\n+            throws IOException, SOAPException {\n+        MessageFactory messageFactory = MessageFactory.newInstance();\n+        SOAPMessage soapMessage = messageFactory.createMessage();\n+        SOAPPart soapPart = soapMessage.getSOAPPart();\n+        SOAPEnvelope envelope = soapPart.getEnvelope();\n+        envelope.setEncodingStyle(\"http://schemas.xmlsoap.org/soap/encoding/\");\n+\n+        // SOAP body\n+        SOAPBody soapBody = envelope.getBody();\n+        SOAPElement soapBodyElem = soapBody.addChildElement(soapAction, \"u\", service.getServiceType());\n+        arguments.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(argument -> {\n+            try {\n+                soapBodyElem.addChildElement(argument.getKey()).setTextContent(argument.getValue());\n+            } catch (SOAPException e) {\n+                logger.warn(\"Could not add {}:{} to SOAP Request: {}\", argument.getKey(), argument.getValue(),\n+                        e.getMessage());\n+            }\n+        });\n+\n+        // SOAP headers\n+        MimeHeaders headers = soapMessage.getMimeHeaders();\n+        headers.addHeader(\"SOAPAction\", service.getServiceType() + \"#\" + soapAction);\n+        soapMessage.saveChanges();\n+\n+        // create Request and add headers and content\n+        Request request = httpClient.newRequest(endpointBaseURL + service.getControlURL()).method(HttpMethod.POST);\n+        ((Iterator<MimeHeader>) soapMessage.getMimeHeaders().getAllHeaders())\n+                .forEachRemaining(header -> request.header(header.getName(), header.getValue()));\n+        try (final ByteArrayOutputStream os = new ByteArrayOutputStream()) {\n+            soapMessage.writeTo(os);\n+            byte[] content = os.toByteArray();\n+            request.content(new BytesContentProvider(content));\n+        }\n+\n+        return request;\n+    }\n+\n+    /**\n+     * execute a SOAP request\n+     *\n+     * @param service the service to send the action to\n+     * @param soapAction the action itself\n+     * @param arguments arguments to send along with the request\n+     * @return the SOAPMessage answer from the remote host\n+     * @throws Tr064CommunicationException if an error occurs during the request\n+     */\n+    public synchronized SOAPMessage doSOAPRequest(SCPDServiceType service, String soapAction,", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEyNjczMg==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499126732", "bodyText": "IIRC there was a problem when several requests are executed at the same time and return 401. It was not poissble to get the re-auth working in that case.", "author": "J-N-K", "createdAt": "2020-10-03T08:01:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUwNDMyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUwNzc3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r494507776", "bodyText": "Make sure to include cause exceptions in when rethrowing new exceptions.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new PostProcessingException(\"Failed to get call list from URL \" + state.toString());\n          \n          \n            \n                        throw new PostProcessingException(e, \"Failed to get call list from URL \" + state.toString());", "author": "cpmeister", "createdAt": "2020-09-24T17:59:16Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/SOAPValueConverter.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.util.Util.getSOAPElement;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.xml.soap.SOAPMessage;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SOAPValueConverter} converts SOAP values and openHAB states\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SOAPValueConverter {\n+    private final Logger logger = LoggerFactory.getLogger(SOAPValueConverter.class);\n+    private final HttpClient httpClient;\n+\n+    public SOAPValueConverter(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+    }\n+\n+    /**\n+     * convert an openHAB command to a SOAP value\n+     *\n+     * @param command the command to be converted\n+     * @param dataType the datatype to send\n+     * @param unit if available, the unit of the converted value\n+     * @return a string optional containing the converted value\n+     */\n+    public Optional<String> getSOAPValueFromCommand(Command command, String dataType, String unit) {\n+        if (dataType.isEmpty()) {\n+            // we don't have data to send\n+            return Optional.of(\"\");\n+        }\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> value = (unit.isEmpty()) ? ((QuantityType<?>) command)\n+                    : ((QuantityType<?>) command).toUnit(unit);\n+            if (value == null) {\n+                logger.info(\"Could not convert {} to unit {}\", command, unit);\n+                return Optional.empty();\n+            }\n+            switch (dataType) {\n+                case \"ui2\":\n+                    return Optional.of(String.valueOf(value.shortValue()));\n+                case \"ui4\":\n+                    return Optional.of(String.valueOf(value.intValue()));\n+                default:\n+            }\n+        } else if (command instanceof DecimalType) {\n+            BigDecimal value = ((DecimalType) command).toBigDecimal();\n+            switch (dataType) {\n+                case \"ui2\":\n+                    return Optional.of(String.valueOf(value.shortValue()));\n+                case \"ui4\":\n+                    return Optional.of(String.valueOf(value.intValue()));\n+                default:\n+            }\n+        } else if (command instanceof StringType) {\n+            if (dataType.equals(\"string\")) {\n+                return Optional.of(command.toString());\n+            }\n+        } else if (command instanceof OnOffType) {\n+            if (dataType.equals(\"boolean\")) {\n+                return Optional.of(OnOffType.ON.equals(command) ? \"1\" : \"0\");\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * convert the value from a SOAP message to an openHAB value\n+     *\n+     * @param soapMessage the inbound SOAP message\n+     * @param element the element that needs to be extracted\n+     * @param channelConfig the channel config containing additional information (if null a data-type \"string\" and\n+     *            missing unit is assumed)\n+     * @return an Optional of State containing the converted value\n+     */\n+    public Optional<State> getStateFromSOAPValue(SOAPMessage soapMessage, String element,\n+            @Nullable Tr064ChannelConfig channelConfig) {\n+        String dataType = channelConfig != null ? channelConfig.getDataType() : \"string\";\n+        String unit = channelConfig != null ? channelConfig.getChannelTypeDescription().getItem().getUnit() : \"\";\n+\n+        return getSOAPElement(soapMessage, element).map(rawValue -> {\n+            // map rawValue to State\n+            switch (dataType) {\n+                case \"boolean\":\n+                    return rawValue.equals(\"0\") ? OnOffType.OFF : OnOffType.ON;\n+                case \"string\":\n+                    return new StringType(rawValue);\n+                case \"ui2\":\n+                case \"ui4\":\n+                    if (!unit.isEmpty()) {\n+                        return new QuantityType<>(rawValue + \" \" + unit);\n+                    } else {\n+                        return new DecimalType(rawValue);\n+                    }\n+                default:\n+                    return null;\n+            }\n+        }).map(state -> {\n+            // check if we need post processing\n+            if (channelConfig == null\n+                    || channelConfig.getChannelTypeDescription().getGetAction().getPostProcessor() == null) {\n+                return state;\n+            }\n+            String postProcessor = channelConfig.getChannelTypeDescription().getGetAction().getPostProcessor();\n+            try {\n+                Method method = SOAPValueConverter.class.getDeclaredMethod(postProcessor, State.class,\n+                        Tr064ChannelConfig.class);\n+                Object o = method.invoke(this, state, channelConfig);\n+                if (o instanceof State) {\n+                    return (State) o;\n+                }\n+            } catch (NoSuchMethodException | IllegalAccessException e) {\n+                logger.warn(\"Postprocessor {} not found, this most likely is a programming error\", postProcessor, e);\n+            } catch (InvocationTargetException e) {\n+                logger.info(\"Postprocessor {} failed: {}\", postProcessor, e.getCause().getMessage());\n+            }\n+            return null;\n+        }).or(Optional::empty);\n+    }\n+\n+    /**\n+     * post processor for answering machine new messages channel\n+     *\n+     * @param state the message list URL\n+     * @param channelConfig channel config of the TAM new message channel\n+     * @return the number of new messages\n+     * @throws PostProcessingException if the message list could not be retrieved\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private State processTamListURL(State state, Tr064ChannelConfig channelConfig) throws PostProcessingException {\n+        try {\n+            ContentResponse response = httpClient.newRequest(state.toString()).timeout(1000, TimeUnit.MILLISECONDS)\n+                    .send();\n+            String responseContent = response.getContentAsString();\n+            int messageCount = responseContent.split(\"<New>1</New>\").length - 1;\n+\n+            return new DecimalType(messageCount);\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new PostProcessingException(\"Failed to get TAM list from URL \" + state.toString());\n+        }\n+    }\n+\n+    /**\n+     * post processor for missed calls\n+     *\n+     * @param state the call list URL\n+     * @param channelConfig channel config of the missed call channel (contains day number)\n+     * @return the number of missed calls\n+     * @throws PostProcessingException if call list could not be retrieved\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private State processMissedCalls(State state, Tr064ChannelConfig channelConfig) throws PostProcessingException {\n+        return processCallList(state, channelConfig.getParameter(), \"2\");\n+    }\n+\n+    /**\n+     * post processor for inbound calls\n+     *\n+     * @param state the call list URL\n+     * @param channelConfig channel config of the inbound call channel (contains day number)\n+     * @return the number of inbound calls\n+     * @throws PostProcessingException if call list could not be retrieved\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private State processInboundCalls(State state, Tr064ChannelConfig channelConfig) throws PostProcessingException {\n+        return processCallList(state, channelConfig.getParameter(), \"1\");\n+    }\n+\n+    /**\n+     * post processor for rejected calls\n+     *\n+     * @param state the call list URL\n+     * @param channelConfig channel config of the rejected call channel (contains day number)\n+     * @return the number of rejected calls\n+     * @throws PostProcessingException if call list could not be retrieved\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private State processRejectedCalls(State state, Tr064ChannelConfig channelConfig) throws PostProcessingException {\n+        return processCallList(state, channelConfig.getParameter(), \"3\");\n+    }\n+\n+    /**\n+     * post processor for outbound calls\n+     *\n+     * @param state the call list URL\n+     * @param channelConfig channel config of the outbound call channel (contains day number)\n+     * @return the number of outbound calls\n+     * @throws PostProcessingException if call list could not be retrieved\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private State processOutboundCalls(State state, Tr064ChannelConfig channelConfig) throws PostProcessingException {\n+        return processCallList(state, channelConfig.getParameter(), \"4\");\n+    }\n+\n+    /**\n+     * internal helper for call list post processors\n+     *\n+     * @param state the call list URL\n+     * @param days number of days to get\n+     * @param type type of call (1=missed 2=inbound 3=rejected 4=outbund)\n+     * @return the quantity of calls of the given type within the given number of days\n+     * @throws PostProcessingException if the call list could not be retrieved\n+     */\n+    private State processCallList(State state, @Nullable String days, String type) throws PostProcessingException {\n+        try {\n+            ContentResponse response = httpClient.newRequest(state.toString() + \"&days=\" + days)\n+                    .timeout(5000, TimeUnit.MILLISECONDS).send();\n+            String responseContent = response.getContentAsString();\n+            int callCount = responseContent.split(\"<Type>\" + type + \"</Type>\").length - 1;\n+\n+            return new DecimalType(callCount);\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.trace(\"Received {}:\", e.getClass(), e);\n+            throw new PostProcessingException(\"Failed to get call list from URL \" + state.toString());", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxMzkzMw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499013933", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.info(\"Could not convert {} to unit {}\", command, unit);\n          \n          \n            \n                            logger.debug(\"Could not convert {} to unit {}\", command, unit);", "author": "cpmeister", "createdAt": "2020-10-02T19:35:20Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/SOAPValueConverter.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.util.Util.getSOAPElement;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.xml.soap.SOAPMessage;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SOAPValueConverter} converts SOAP values and openHAB states\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SOAPValueConverter {\n+    private final Logger logger = LoggerFactory.getLogger(SOAPValueConverter.class);\n+    private final HttpClient httpClient;\n+\n+    public SOAPValueConverter(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+    }\n+\n+    /**\n+     * convert an openHAB command to a SOAP value\n+     *\n+     * @param command the command to be converted\n+     * @param dataType the datatype to send\n+     * @param unit if available, the unit of the converted value\n+     * @return a string optional containing the converted value\n+     */\n+    public Optional<String> getSOAPValueFromCommand(Command command, String dataType, String unit) {\n+        if (dataType.isEmpty()) {\n+            // we don't have data to send\n+            return Optional.of(\"\");\n+        }\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> value = (unit.isEmpty()) ? ((QuantityType<?>) command)\n+                    : ((QuantityType<?>) command).toUnit(unit);\n+            if (value == null) {\n+                logger.info(\"Could not convert {} to unit {}\", command, unit);", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEyNzAyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499127025", "bodyText": "This hides the message, I would like to keep it visible to the user. This is clearly a mis-function, we could discuss if that is warn.", "author": "J-N-K", "createdAt": "2020-10-03T08:05:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxMzkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxNDEyNg==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r515514126", "bodyText": "If it is something that we want to make the admin aware of, I'd usually indeed prefer a warn.", "author": "kaikreuzer", "createdAt": "2020-10-31T16:34:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxMzkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxNjAyNw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499016027", "bodyText": "This removes a bit of code duplication.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (channelConfig == null\n          \n          \n            \n                                || channelConfig.getChannelTypeDescription().getGetAction().getPostProcessor() == null) {\n          \n          \n            \n                            return state;\n          \n          \n            \n                        }\n          \n          \n            \n                        String postProcessor = channelConfig.getChannelTypeDescription().getGetAction().getPostProcessor();\n          \n          \n            \n                        String postProcessor = channelConfig != null ? channelConfig.getChannelTypeDescription().getGetAction().getPostProcessor() : null;\n          \n          \n            \n                        if(postProcessor == null){\n          \n          \n            \n                            return state;\n          \n          \n            \n                        }", "author": "cpmeister", "createdAt": "2020-10-02T19:40:21Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/SOAPValueConverter.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.util.Util.getSOAPElement;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.xml.soap.SOAPMessage;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SOAPValueConverter} converts SOAP values and openHAB states\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SOAPValueConverter {\n+    private final Logger logger = LoggerFactory.getLogger(SOAPValueConverter.class);\n+    private final HttpClient httpClient;\n+\n+    public SOAPValueConverter(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+    }\n+\n+    /**\n+     * convert an openHAB command to a SOAP value\n+     *\n+     * @param command the command to be converted\n+     * @param dataType the datatype to send\n+     * @param unit if available, the unit of the converted value\n+     * @return a string optional containing the converted value\n+     */\n+    public Optional<String> getSOAPValueFromCommand(Command command, String dataType, String unit) {\n+        if (dataType.isEmpty()) {\n+            // we don't have data to send\n+            return Optional.of(\"\");\n+        }\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> value = (unit.isEmpty()) ? ((QuantityType<?>) command)\n+                    : ((QuantityType<?>) command).toUnit(unit);\n+            if (value == null) {\n+                logger.info(\"Could not convert {} to unit {}\", command, unit);\n+                return Optional.empty();\n+            }\n+            switch (dataType) {\n+                case \"ui2\":\n+                    return Optional.of(String.valueOf(value.shortValue()));\n+                case \"ui4\":\n+                    return Optional.of(String.valueOf(value.intValue()));\n+                default:\n+            }\n+        } else if (command instanceof DecimalType) {\n+            BigDecimal value = ((DecimalType) command).toBigDecimal();\n+            switch (dataType) {\n+                case \"ui2\":\n+                    return Optional.of(String.valueOf(value.shortValue()));\n+                case \"ui4\":\n+                    return Optional.of(String.valueOf(value.intValue()));\n+                default:\n+            }\n+        } else if (command instanceof StringType) {\n+            if (dataType.equals(\"string\")) {\n+                return Optional.of(command.toString());\n+            }\n+        } else if (command instanceof OnOffType) {\n+            if (dataType.equals(\"boolean\")) {\n+                return Optional.of(OnOffType.ON.equals(command) ? \"1\" : \"0\");\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * convert the value from a SOAP message to an openHAB value\n+     *\n+     * @param soapMessage the inbound SOAP message\n+     * @param element the element that needs to be extracted\n+     * @param channelConfig the channel config containing additional information (if null a data-type \"string\" and\n+     *            missing unit is assumed)\n+     * @return an Optional of State containing the converted value\n+     */\n+    public Optional<State> getStateFromSOAPValue(SOAPMessage soapMessage, String element,\n+            @Nullable Tr064ChannelConfig channelConfig) {\n+        String dataType = channelConfig != null ? channelConfig.getDataType() : \"string\";\n+        String unit = channelConfig != null ? channelConfig.getChannelTypeDescription().getItem().getUnit() : \"\";\n+\n+        return getSOAPElement(soapMessage, element).map(rawValue -> {\n+            // map rawValue to State\n+            switch (dataType) {\n+                case \"boolean\":\n+                    return rawValue.equals(\"0\") ? OnOffType.OFF : OnOffType.ON;\n+                case \"string\":\n+                    return new StringType(rawValue);\n+                case \"ui2\":\n+                case \"ui4\":\n+                    if (!unit.isEmpty()) {\n+                        return new QuantityType<>(rawValue + \" \" + unit);\n+                    } else {\n+                        return new DecimalType(rawValue);\n+                    }\n+                default:\n+                    return null;\n+            }\n+        }).map(state -> {\n+            // check if we need post processing\n+            if (channelConfig == null\n+                    || channelConfig.getChannelTypeDescription().getGetAction().getPostProcessor() == null) {\n+                return state;\n+            }\n+            String postProcessor = channelConfig.getChannelTypeDescription().getGetAction().getPostProcessor();", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEyNzE0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499127146", "bodyText": "Agreed that this will reduce code, but IMO the \"original\" version is much easier to understand.", "author": "J-N-K", "createdAt": "2020-10-03T08:07:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxNjAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3MDg0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499170845", "bodyText": "Up to you then, I just hate duplicate code.", "author": "cpmeister", "createdAt": "2020-10-03T18:28:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxNjAyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxNzM4NA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499017384", "bodyText": "Please cache channelConfig.getChannelTypeDescription().getGetAction() in a local variable for reuse.", "author": "cpmeister", "createdAt": "2020-10-02T19:43:40Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/SOAPConnector.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.util.Util.getSOAPElement;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import javax.xml.soap.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BytesContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescription;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SOAPConnector} provides communication with a remote SOAP device\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SOAPConnector {\n+    private static final int SOAP_TIMEOUT = 2000; // in ms\n+    private final Logger logger = LoggerFactory.getLogger(SOAPConnector.class);\n+    private final HttpClient httpClient;\n+    private final String endpointBaseURL;\n+    private final SOAPValueConverter soapValueConverter;\n+\n+    public SOAPConnector(HttpClient httpClient, String endpointBaseURL) {\n+        this.httpClient = httpClient;\n+        this.endpointBaseURL = endpointBaseURL;\n+        soapValueConverter = new SOAPValueConverter(httpClient);\n+    }\n+\n+    /**\n+     * prepare a SOAP request for an action request to a service\n+     *\n+     * @param service the service\n+     * @param soapAction the action to send\n+     * @param arguments arguments to send along with the request\n+     * @return a jetty Request containing the full SOAP message\n+     * @throws IOException if a problem while writing the SOAP message to the Request occurs\n+     * @throws SOAPException if a problem with creating the SOAP message occurs\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private Request prepareSOAPRequest(SCPDServiceType service, String soapAction, Map<String, String> arguments)\n+            throws IOException, SOAPException {\n+        MessageFactory messageFactory = MessageFactory.newInstance();\n+        SOAPMessage soapMessage = messageFactory.createMessage();\n+        SOAPPart soapPart = soapMessage.getSOAPPart();\n+        SOAPEnvelope envelope = soapPart.getEnvelope();\n+        envelope.setEncodingStyle(\"http://schemas.xmlsoap.org/soap/encoding/\");\n+\n+        // SOAP body\n+        SOAPBody soapBody = envelope.getBody();\n+        SOAPElement soapBodyElem = soapBody.addChildElement(soapAction, \"u\", service.getServiceType());\n+        arguments.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(argument -> {\n+            try {\n+                soapBodyElem.addChildElement(argument.getKey()).setTextContent(argument.getValue());\n+            } catch (SOAPException e) {\n+                logger.warn(\"Could not add {}:{} to SOAP Request: {}\", argument.getKey(), argument.getValue(),\n+                        e.getMessage());\n+            }\n+        });\n+\n+        // SOAP headers\n+        MimeHeaders headers = soapMessage.getMimeHeaders();\n+        headers.addHeader(\"SOAPAction\", service.getServiceType() + \"#\" + soapAction);\n+        soapMessage.saveChanges();\n+\n+        // create Request and add headers and content\n+        Request request = httpClient.newRequest(endpointBaseURL + service.getControlURL()).method(HttpMethod.POST);\n+        ((Iterator<MimeHeader>) soapMessage.getMimeHeaders().getAllHeaders())\n+                .forEachRemaining(header -> request.header(header.getName(), header.getValue()));\n+        try (final ByteArrayOutputStream os = new ByteArrayOutputStream()) {\n+            soapMessage.writeTo(os);\n+            byte[] content = os.toByteArray();\n+            request.content(new BytesContentProvider(content));\n+        }\n+\n+        return request;\n+    }\n+\n+    /**\n+     * execute a SOAP request\n+     *\n+     * @param service the service to send the action to\n+     * @param soapAction the action itself\n+     * @param arguments arguments to send along with the request\n+     * @return the SOAPMessage answer from the remote host\n+     * @throws Tr064CommunicationException if an error occurs during the request\n+     */\n+    public synchronized SOAPMessage doSOAPRequest(SCPDServiceType service, String soapAction,\n+            Map<String, String> arguments) throws Tr064CommunicationException {\n+        try {\n+            Request request = prepareSOAPRequest(service, soapAction, arguments).timeout(SOAP_TIMEOUT,\n+                    TimeUnit.MILLISECONDS);\n+            request.getContent().forEach(buffer -> logger.trace(\"Request: {}\", new String(buffer.array())));\n+\n+            ContentResponse response = request.send();\n+            if (response.getStatus() == HttpStatus.UNAUTHORIZED_401) {\n+                // retry once if authentication expired\n+                logger.trace(\"Re-Auth needed.\");\n+                httpClient.getAuthenticationStore().clearAuthenticationResults();\n+                request = prepareSOAPRequest(service, soapAction, arguments).timeout(SOAP_TIMEOUT,\n+                        TimeUnit.MILLISECONDS);\n+                response = request.send();\n+            }\n+            try (final ByteArrayInputStream is = new ByteArrayInputStream(response.getContent())) {\n+                logger.trace(\"Received response: {}\", response.getContentAsString());\n+\n+                SOAPMessage soapMessage = MessageFactory.newInstance().createMessage(null, is);\n+                if (soapMessage.getSOAPBody().hasFault()) {\n+                    String soapError = getSOAPElement(soapMessage, \"errorCode\").orElse(\"unknown\");\n+                    String soapReason = getSOAPElement(soapMessage, \"errorDescription\").orElse(\"unknown\");\n+                    String error = String.format(\"HTTP-Response-Code %d (%s), SOAP-Fault: %s (%s)\",\n+                            response.getStatus(), response.getReason(), soapError, soapReason);\n+                    throw new Tr064CommunicationException(error);\n+                }\n+                return soapMessage;\n+            }\n+        } catch (IOException | SOAPException | InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new Tr064CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * send a command to the remote device\n+     *\n+     * @param channelConfig the channel config containing all information\n+     * @param command the command to send\n+     */\n+    public void sendChannelCommandToDevice(Tr064ChannelConfig channelConfig, Command command) {\n+        soapValueConverter.getSOAPValueFromCommand(command, channelConfig.getDataType(),\n+                channelConfig.getChannelTypeDescription().getItem().getUnit()).ifPresentOrElse(value -> {\n+                    final ChannelTypeDescription channelTypeDescription = channelConfig.getChannelTypeDescription();\n+                    final SCPDServiceType service = channelConfig.getService();\n+                    logger.debug(\"Sending {} as {} to {}/{}\", command, value, service.getServiceId(),\n+                            channelTypeDescription.getSetAction().getName());\n+                    try {\n+                        Map<String, String> arguments = new HashMap<>();\n+                        if (channelTypeDescription.getSetAction().getArgument() != null) {\n+                            arguments.put(channelTypeDescription.getSetAction().getArgument(), value);\n+                        }\n+                        String parameter = channelConfig.getParameter();\n+                        if (parameter != null) {\n+                            arguments.put(\n+                                    channelConfig.getChannelTypeDescription().getGetAction().getParameter().getName(),\n+                                    parameter);\n+                        }\n+                        doSOAPRequest(service, channelTypeDescription.getSetAction().getName(), arguments);\n+                    } catch (Tr064CommunicationException e) {\n+                        logger.warn(\"Could not send command {}: {}\", command, e.getMessage());\n+                    }\n+                }, () -> logger.info(\"Could not convert {} to SOAP value\", command));\n+    }\n+\n+    /**\n+     * get a value from the remote device - updates state cache for all possible channels\n+     *\n+     * @param channelConfig the channel config containing all information\n+     * @param channelConfigMap map of all channels in the device\n+     * @param stateCache the ExpiringCacheMap for states of the device\n+     * @return the value for the requested channel\n+     */\n+    public State getChannelStateFromDevice(final Tr064ChannelConfig channelConfig,\n+            Map<ChannelUID, Tr064ChannelConfig> channelConfigMap, ExpiringCacheMap<ChannelUID, State> stateCache) {\n+        try {\n+            final SCPDActionType getAction = channelConfig.getGetAction();\n+            if (getAction == null) {\n+                // channel has no get action, return a default\n+                switch (channelConfig.getDataType()) {\n+                    case \"boolean\":\n+                        return OnOffType.OFF;\n+                    case \"string\":\n+                        return StringType.EMPTY;\n+                    default:\n+                        return UnDefType.UNDEF;\n+                }\n+            }\n+\n+            // get value(s) from remote device\n+            Map<String, String> arguments = new HashMap<>();\n+            String parameter = channelConfig.getParameter();\n+            if (parameter != null\n+                    && !channelConfig.getChannelTypeDescription().getGetAction().getParameter().isInternalOnly()) {\n+                arguments.put(channelConfig.getChannelTypeDescription().getGetAction().getParameter().getName(),", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxOTI2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499019266", "bodyText": "Should this value be configurable? Maybe at the very least store it in a static constant.", "author": "cpmeister", "createdAt": "2020-10-02T19:48:13Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/SOAPValueConverter.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.util.Util.getSOAPElement;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.xml.soap.SOAPMessage;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SOAPValueConverter} converts SOAP values and openHAB states\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SOAPValueConverter {\n+    private final Logger logger = LoggerFactory.getLogger(SOAPValueConverter.class);\n+    private final HttpClient httpClient;\n+\n+    public SOAPValueConverter(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+    }\n+\n+    /**\n+     * convert an openHAB command to a SOAP value\n+     *\n+     * @param command the command to be converted\n+     * @param dataType the datatype to send\n+     * @param unit if available, the unit of the converted value\n+     * @return a string optional containing the converted value\n+     */\n+    public Optional<String> getSOAPValueFromCommand(Command command, String dataType, String unit) {\n+        if (dataType.isEmpty()) {\n+            // we don't have data to send\n+            return Optional.of(\"\");\n+        }\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> value = (unit.isEmpty()) ? ((QuantityType<?>) command)\n+                    : ((QuantityType<?>) command).toUnit(unit);\n+            if (value == null) {\n+                logger.info(\"Could not convert {} to unit {}\", command, unit);\n+                return Optional.empty();\n+            }\n+            switch (dataType) {\n+                case \"ui2\":\n+                    return Optional.of(String.valueOf(value.shortValue()));\n+                case \"ui4\":\n+                    return Optional.of(String.valueOf(value.intValue()));\n+                default:\n+            }\n+        } else if (command instanceof DecimalType) {\n+            BigDecimal value = ((DecimalType) command).toBigDecimal();\n+            switch (dataType) {\n+                case \"ui2\":\n+                    return Optional.of(String.valueOf(value.shortValue()));\n+                case \"ui4\":\n+                    return Optional.of(String.valueOf(value.intValue()));\n+                default:\n+            }\n+        } else if (command instanceof StringType) {\n+            if (dataType.equals(\"string\")) {\n+                return Optional.of(command.toString());\n+            }\n+        } else if (command instanceof OnOffType) {\n+            if (dataType.equals(\"boolean\")) {\n+                return Optional.of(OnOffType.ON.equals(command) ? \"1\" : \"0\");\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * convert the value from a SOAP message to an openHAB value\n+     *\n+     * @param soapMessage the inbound SOAP message\n+     * @param element the element that needs to be extracted\n+     * @param channelConfig the channel config containing additional information (if null a data-type \"string\" and\n+     *            missing unit is assumed)\n+     * @return an Optional of State containing the converted value\n+     */\n+    public Optional<State> getStateFromSOAPValue(SOAPMessage soapMessage, String element,\n+            @Nullable Tr064ChannelConfig channelConfig) {\n+        String dataType = channelConfig != null ? channelConfig.getDataType() : \"string\";\n+        String unit = channelConfig != null ? channelConfig.getChannelTypeDescription().getItem().getUnit() : \"\";\n+\n+        return getSOAPElement(soapMessage, element).map(rawValue -> {\n+            // map rawValue to State\n+            switch (dataType) {\n+                case \"boolean\":\n+                    return rawValue.equals(\"0\") ? OnOffType.OFF : OnOffType.ON;\n+                case \"string\":\n+                    return new StringType(rawValue);\n+                case \"ui2\":\n+                case \"ui4\":\n+                    if (!unit.isEmpty()) {\n+                        return new QuantityType<>(rawValue + \" \" + unit);\n+                    } else {\n+                        return new DecimalType(rawValue);\n+                    }\n+                default:\n+                    return null;\n+            }\n+        }).map(state -> {\n+            // check if we need post processing\n+            if (channelConfig == null\n+                    || channelConfig.getChannelTypeDescription().getGetAction().getPostProcessor() == null) {\n+                return state;\n+            }\n+            String postProcessor = channelConfig.getChannelTypeDescription().getGetAction().getPostProcessor();\n+            try {\n+                Method method = SOAPValueConverter.class.getDeclaredMethod(postProcessor, State.class,\n+                        Tr064ChannelConfig.class);\n+                Object o = method.invoke(this, state, channelConfig);\n+                if (o instanceof State) {\n+                    return (State) o;\n+                }\n+            } catch (NoSuchMethodException | IllegalAccessException e) {\n+                logger.warn(\"Postprocessor {} not found, this most likely is a programming error\", postProcessor, e);\n+            } catch (InvocationTargetException e) {\n+                logger.info(\"Postprocessor {} failed: {}\", postProcessor, e.getCause().getMessage());\n+            }\n+            return null;\n+        }).or(Optional::empty);\n+    }\n+\n+    /**\n+     * post processor for answering machine new messages channel\n+     *\n+     * @param state the message list URL\n+     * @param channelConfig channel config of the TAM new message channel\n+     * @return the number of new messages\n+     * @throws PostProcessingException if the message list could not be retrieved\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private State processTamListURL(State state, Tr064ChannelConfig channelConfig) throws PostProcessingException {\n+        try {\n+            ContentResponse response = httpClient.newRequest(state.toString()).timeout(1000, TimeUnit.MILLISECONDS)\n+                    .send();\n+            String responseContent = response.getContentAsString();\n+            int messageCount = responseContent.split(\"<New>1</New>\").length - 1;\n+\n+            return new DecimalType(messageCount);\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new PostProcessingException(\"Failed to get TAM list from URL \" + state.toString());\n+        }\n+    }\n+\n+    /**\n+     * post processor for missed calls\n+     *\n+     * @param state the call list URL\n+     * @param channelConfig channel config of the missed call channel (contains day number)\n+     * @return the number of missed calls\n+     * @throws PostProcessingException if call list could not be retrieved\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private State processMissedCalls(State state, Tr064ChannelConfig channelConfig) throws PostProcessingException {\n+        return processCallList(state, channelConfig.getParameter(), \"2\");\n+    }\n+\n+    /**\n+     * post processor for inbound calls\n+     *\n+     * @param state the call list URL\n+     * @param channelConfig channel config of the inbound call channel (contains day number)\n+     * @return the number of inbound calls\n+     * @throws PostProcessingException if call list could not be retrieved\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private State processInboundCalls(State state, Tr064ChannelConfig channelConfig) throws PostProcessingException {\n+        return processCallList(state, channelConfig.getParameter(), \"1\");\n+    }\n+\n+    /**\n+     * post processor for rejected calls\n+     *\n+     * @param state the call list URL\n+     * @param channelConfig channel config of the rejected call channel (contains day number)\n+     * @return the number of rejected calls\n+     * @throws PostProcessingException if call list could not be retrieved\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private State processRejectedCalls(State state, Tr064ChannelConfig channelConfig) throws PostProcessingException {\n+        return processCallList(state, channelConfig.getParameter(), \"3\");\n+    }\n+\n+    /**\n+     * post processor for outbound calls\n+     *\n+     * @param state the call list URL\n+     * @param channelConfig channel config of the outbound call channel (contains day number)\n+     * @return the number of outbound calls\n+     * @throws PostProcessingException if call list could not be retrieved\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private State processOutboundCalls(State state, Tr064ChannelConfig channelConfig) throws PostProcessingException {\n+        return processCallList(state, channelConfig.getParameter(), \"4\");\n+    }\n+\n+    /**\n+     * internal helper for call list post processors\n+     *\n+     * @param state the call list URL\n+     * @param days number of days to get\n+     * @param type type of call (1=missed 2=inbound 3=rejected 4=outbund)\n+     * @return the quantity of calls of the given type within the given number of days\n+     * @throws PostProcessingException if the call list could not be retrieved\n+     */\n+    private State processCallList(State state, @Nullable String days, String type) throws PostProcessingException {\n+        try {\n+            ContentResponse response = httpClient.newRequest(state.toString() + \"&days=\" + days)\n+                    .timeout(5000, TimeUnit.MILLISECONDS).send();", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEyOTk4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499129983", "bodyText": "Made it a constant. I don't think there is a usecase for having that configurable. If the calllist is not available after 5s, it'll probably never be.", "author": "J-N-K", "createdAt": "2020-10-03T08:53:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxOTI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAyMDY3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499020675", "bodyText": "What about the representation property?", "author": "cpmeister", "createdAt": "2020-10-02T19:51:40Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064DiscoveryService.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE;\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE_LAN;\n+\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.util.UIDUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064DiscoveryService} discovers sub devices of a root device.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Tr064DiscoveryService extends AbstractDiscoveryService implements ThingHandlerService {\n+    private static final int SEARCH_TIME = 5;\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections.singleton(THING_TYPE_SUBDEVICE);\n+\n+    private final Logger logger = LoggerFactory.getLogger(Tr064DiscoveryService.class);\n+    private @Nullable Tr064RootHandler bridgeHandler;\n+\n+    public Tr064DiscoveryService() {\n+        super(SEARCH_TIME);\n+    }\n+\n+    @Override\n+    public void setThingHandler(ThingHandler thingHandler) {\n+        if (thingHandler instanceof Tr064RootHandler) {\n+            this.bridgeHandler = (Tr064RootHandler) thingHandler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        removeOlderResults(new Date().getTime(), bridgeHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES;\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        Tr064RootHandler bridgeHandler = this.bridgeHandler;\n+        if (bridgeHandler == null) {\n+            logger.warn(\"Could not start discovery, bridge handler not set\");\n+            return;\n+        }\n+        List<SCPDDeviceType> devices = bridgeHandler.getAllSubDevices();\n+        ThingUID bridgeUID = bridgeHandler.getThing().getUID();\n+        devices.forEach(device -> {\n+            logger.trace(\"Trying to add {} to discovery results on {}\", device, bridgeUID);\n+            String udn = device.getUDN();\n+            if (udn != null) {\n+                ThingTypeUID thingTypeUID;\n+                if (\"urn:dslforum-org:device:LANDevice:1\".equals(device.getDeviceType())) {\n+                    thingTypeUID = THING_TYPE_SUBDEVICE_LAN;\n+                } else {\n+                    thingTypeUID = THING_TYPE_SUBDEVICE;\n+                }\n+                ThingUID thingUID = new ThingUID(thingTypeUID, bridgeUID, UIDUtils.encode(udn));\n+\n+                Map<String, Object> properties = new HashMap<>(2);\n+                properties.put(\"uuid\", udn);\n+                properties.put(\"deviceType\", device.getDeviceType());\n+\n+                DiscoveryResult result = DiscoveryResultBuilder.create(thingUID).withLabel(device.getFriendlyName())\n+                        .withBridge(bridgeHandler.getThing().getUID()).withProperties(properties).build();", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAyNDk0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499024948", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = { ChannelTypeProvider.class, Tr064ChannelTypeProvider.class }, immediate = true)\n          \n          \n            \n            @Component(service = { ChannelTypeProvider.class, Tr064ChannelTypeProvider.class })", "author": "cpmeister", "createdAt": "2020-10-02T20:02:01Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064ChannelTypeProvider.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.CHANNEL_TYPES;\n+\n+import java.util.Collection;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeProvider;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064ChannelTypeProvider} is used for providing dynamic channel types\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { ChannelTypeProvider.class, Tr064ChannelTypeProvider.class }, immediate = true)", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAyNTAzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499025031", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Tr064DynamicStateDescriptionProvider.class }, immediate = true)\n          \n          \n            \n                    Tr064DynamicStateDescriptionProvider.class })", "author": "cpmeister", "createdAt": "2020-10-02T20:02:15Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064DynamicStateDescriptionProvider.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.type.DynamicStateDescriptionProvider;\n+import org.openhab.core.types.StateDescription;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Dynamic channel state description provider.\n+ * Overrides the state description for the controls, which receive its configuration in the runtime.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { DynamicStateDescriptionProvider.class,\n+        Tr064DynamicStateDescriptionProvider.class }, immediate = true)", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAyNTE1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499025159", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(immediate = true, service = { ThingHandlerFactory.class }, configurationPid = \"binding.tr064\")\n          \n          \n            \n            @Component(service = { ThingHandlerFactory.class }, configurationPid = \"binding.tr064\")", "author": "cpmeister", "createdAt": "2020-10-02T20:02:33Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064HandlerFactory.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.tr064.internal.phonebook.PhonebookProfileFactory;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link Tr064HandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(immediate = true, service = { ThingHandlerFactory.class }, configurationPid = \"binding.tr064\")", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAyNTM4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499025385", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(immediate = true, service = { ProfileFactory.class, ProfileTypeProvider.class, PhonebookProfileFactory.class,\n          \n          \n            \n            @Component(service = { ProfileFactory.class, ProfileTypeProvider.class, PhonebookProfileFactory.class,", "author": "cpmeister", "createdAt": "2020-10-02T20:03:07Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/phonebook/PhonebookProfileFactory.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal.phonebook;\n+\n+import java.net.URI;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.core.ConfigOptionProvider;\n+import org.openhab.core.config.core.ParameterOption;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.profiles.Profile;\n+import org.openhab.core.thing.profiles.ProfileCallback;\n+import org.openhab.core.thing.profiles.ProfileContext;\n+import org.openhab.core.thing.profiles.ProfileFactory;\n+import org.openhab.core.thing.profiles.ProfileType;\n+import org.openhab.core.thing.profiles.ProfileTypeBuilder;\n+import org.openhab.core.thing.profiles.ProfileTypeProvider;\n+import org.openhab.core.thing.profiles.ProfileTypeUID;\n+import org.openhab.core.util.UIDUtils;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PhonebookProfileFactory} class is used to create phonebook profiles\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(immediate = true, service = { ProfileFactory.class, ProfileTypeProvider.class, PhonebookProfileFactory.class,", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAyNTYxOA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499025618", "bodyText": "Maybe this should be a constant instead?", "author": "cpmeister", "createdAt": "2020-10-02T20:03:42Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/phonebook/PhonebookProfileFactory.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal.phonebook;\n+\n+import java.net.URI;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.core.ConfigOptionProvider;\n+import org.openhab.core.config.core.ParameterOption;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.profiles.Profile;\n+import org.openhab.core.thing.profiles.ProfileCallback;\n+import org.openhab.core.thing.profiles.ProfileContext;\n+import org.openhab.core.thing.profiles.ProfileFactory;\n+import org.openhab.core.thing.profiles.ProfileType;\n+import org.openhab.core.thing.profiles.ProfileTypeBuilder;\n+import org.openhab.core.thing.profiles.ProfileTypeProvider;\n+import org.openhab.core.thing.profiles.ProfileTypeUID;\n+import org.openhab.core.util.UIDUtils;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PhonebookProfileFactory} class is used to create phonebook profiles\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(immediate = true, service = { ProfileFactory.class, ProfileTypeProvider.class, PhonebookProfileFactory.class,\n+        ConfigOptionProvider.class })\n+public class PhonebookProfileFactory implements ProfileFactory, ProfileTypeProvider, ConfigOptionProvider {\n+    private final Logger logger = LoggerFactory.getLogger(PhonebookProfileFactory.class);\n+    private final Map<ThingUID, PhonebookProvider> phonebookProviders = new ConcurrentHashMap<>();\n+\n+    @Override\n+    public @Nullable Profile createProfile(ProfileTypeUID profileTypeUID, ProfileCallback callback,\n+            ProfileContext profileContext) {\n+        return new PhonebookProfile(callback, profileContext, phonebookProviders);\n+    }\n+\n+    @Override\n+    public Collection<ProfileTypeUID> getSupportedProfileTypeUIDs() {\n+        return Collections.singleton(PhonebookProfile.PHONEBOOK_PROFILE_TYPE_UID);\n+    }\n+\n+    @Override\n+    public Collection<ProfileType> getProfileTypes(@Nullable Locale locale) {\n+        return Collections.singleton(\n+                ProfileTypeBuilder.newState(PhonebookProfile.PHONEBOOK_PROFILE_TYPE_UID, \"Phonebook\").build());", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0MzkxMw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499043913", "bodyText": "Could this be an enum instead?", "author": "cpmeister", "createdAt": "2020-10-02T20:49:19Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/dto/scpd/service/SCPDArgumentType.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.tr064.internal.dto.scpd.service;\n+\n+import java.io.Serializable;\n+\n+import javax.xml.bind.annotation.XmlAccessType;\n+import javax.xml.bind.annotation.XmlAccessorType;\n+import javax.xml.bind.annotation.XmlType;\n+\n+/**\n+ * <p>\n+ * Java class for argumentType complex type.\n+ * \n+ * <p>\n+ * The following schema fragment specifies the expected content contained within this class.\n+ * \n+ * <pre>\n+ * &lt;complexType name=\"argumentType\"&gt;\n+ *   &lt;complexContent&gt;\n+ *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\"&gt;\n+ *       &lt;sequence&gt;\n+ *         &lt;element name=\"name\" type=\"{http://www.w3.org/2001/XMLSchema}string\" minOccurs=\"0\"/&gt;\n+ *         &lt;element name=\"direction\" type=\"{http://www.w3.org/2001/XMLSchema}string\" minOccurs=\"0\"/&gt;\n+ *         &lt;element name=\"relatedStateVariable\" type=\"{http://www.w3.org/2001/XMLSchema}string\" minOccurs=\"0\"/&gt;\n+ *       &lt;/sequence&gt;\n+ *     &lt;/restriction&gt;\n+ *   &lt;/complexContent&gt;\n+ * &lt;/complexType&gt;\n+ * </pre>\n+ * \n+ * \n+ */\n+@XmlAccessorType(XmlAccessType.FIELD)\n+@XmlType(name = \"argumentType\", propOrder = { \"name\", \"direction\", \"relatedStateVariable\" })\n+public class SCPDArgumentType implements Serializable {\n+\n+    private final static long serialVersionUID = 1L;\n+    protected String name;\n+    protected String direction;", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0NjIyMA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499046220", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                parameters.removeIf(param -> !allowedValues.contains(param));\n          \n          \n            \n                                parameters.retainAll(allowedValues);", "author": "cpmeister", "createdAt": "2020-10-02T20:55:12Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/util/Util.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal.util;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.*;\n+\n+import java.io.InputStream;\n+import java.lang.reflect.Field;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.soap.SOAPException;\n+import javax.xml.soap.SOAPMessage;\n+import javax.xml.transform.stream.StreamSource;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.tr064.internal.ChannelConfigException;\n+import org.openhab.binding.tr064.internal.config.Tr064BaseThingConfiguration;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064RootConfiguration;\n+import org.openhab.binding.tr064.internal.config.Tr064SubConfiguration;\n+import org.openhab.binding.tr064.internal.dto.config.ActionType;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescription;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescriptions;\n+import org.openhab.binding.tr064.internal.dto.config.ParameterType;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDArgumentType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDScpdType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDStateVariableType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.util.UIDUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.w3c.dom.NodeList;\n+\n+/**\n+ * The {@link Util} is a set of helper functions\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Util {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(Util.class);\n+\n+    public static List<ChannelTypeDescription> readXMLChannelConfig() {\n+        try {\n+            InputStream resource = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"channels.xml\");\n+            JAXBContext context = JAXBContext.newInstance(ChannelTypeDescriptions.class);\n+            Unmarshaller um = context.createUnmarshaller();\n+            JAXBElement<ChannelTypeDescriptions> root = um.unmarshal(new StreamSource(resource),\n+                    ChannelTypeDescriptions.class);\n+            return root.getValue().getChannel();\n+        } catch (JAXBException e) {\n+            LOGGER.warn(\"Failed to read channel definitions\", e);\n+            return Collections.emptyList();\n+        }\n+    }\n+\n+    public static ThingBuilder checkAvailableChannels(Thing thing, ThingBuilder thingBuilder, SCPDUtil scpdUtil,\n+            String deviceId, String deviceType, Map<ChannelUID, Tr064ChannelConfig> channels) {\n+        Tr064BaseThingConfiguration thingConfig = thing.getThingTypeUID().equals(THING_TYPE_FRITZBOX)\n+                ? thing.getConfiguration().as(Tr064RootConfiguration.class)\n+                : thing.getConfiguration().as(Tr064SubConfiguration.class);\n+        CHANNEL_TYPES.stream().filter(channel -> deviceType.equals(channel.getService().getDeviceType()))\n+                .forEach(channelTypeDescription -> {\n+                    String channelId = channelTypeDescription.getName();\n+                    String serviceId = channelTypeDescription.getService().getServiceId();\n+                    Set<String> parameters = new HashSet<>();\n+                    try {\n+                        SCPDServiceType deviceService = scpdUtil.getDevice(deviceId)\n+                                .flatMap(device -> device.getServiceList().stream()\n+                                        .filter(service -> service.getServiceId().equals(serviceId)).findFirst())\n+                                .orElseThrow(() -> new ChannelConfigException(\"Service '\" + serviceId + \"' not found\"));\n+                        SCPDScpdType serviceRoot = scpdUtil.getService(deviceService.getServiceId())\n+                                .orElseThrow(() -> new ChannelConfigException(\n+                                        \"Service definition for '\" + serviceId + \"' not found\"));\n+                        Tr064ChannelConfig channelConfig = new Tr064ChannelConfig(channelTypeDescription,\n+                                deviceService);\n+\n+                        // get\n+                        ActionType getAction = channelTypeDescription.getGetAction();\n+                        if (getAction != null) {\n+                            String actionName = getAction.getName();\n+                            String argumentName = getAction.getArgument();\n+                            SCPDActionType scpdAction = serviceRoot.getActionList().stream()\n+                                    .filter(action -> actionName.equals(action.getName())).findFirst()\n+                                    .orElseThrow(() -> new ChannelConfigException(\n+                                            \"Get-Action '\" + actionName + \"' not found\"));\n+                            SCPDArgumentType scpdArgument = scpdAction.getArgumentList().stream()\n+                                    .filter(argument -> argument.getName().equals(argumentName)\n+                                            && argument.getDirection().equals(\"out\"))\n+                                    .findFirst().orElseThrow(() -> new ChannelConfigException(\n+                                            \"Get-Argument '\" + argumentName + \"' not found\"));\n+                            SCPDStateVariableType relatedStateVariable = serviceRoot.getServiceStateTable().stream()\n+                                    .filter(stateVariable -> stateVariable.getName()\n+                                            .equals(scpdArgument.getRelatedStateVariable()))\n+                                    .findFirst().orElseThrow(() -> new ChannelConfigException(\"StateVariable '\"\n+                                            + scpdArgument.getRelatedStateVariable() + \"' not found\"));\n+                            parameters.addAll(\n+                                    getAndCheckParameters(channelId, getAction, scpdAction, serviceRoot, thingConfig));\n+\n+                            channelConfig.setGetAction(scpdAction);\n+                            channelConfig.setDataType(relatedStateVariable.getDataType());\n+                        }\n+\n+                        // check set action\n+                        ActionType setAction = channelTypeDescription.getSetAction();\n+                        if (setAction != null) {\n+                            String actionName = setAction.getName();\n+                            String argumentName = setAction.getArgument();\n+\n+                            SCPDActionType scpdAction = serviceRoot.getActionList().stream()\n+                                    .filter(action -> action.getName().equals(actionName)).findFirst()\n+                                    .orElseThrow(() -> new ChannelConfigException(\n+                                            \"Set-Action '\" + actionName + \"' not found\"));\n+                            if (argumentName != null) {\n+                                SCPDArgumentType scpdArgument = scpdAction.getArgumentList().stream()\n+                                        .filter(argument -> argument.getName().equals(argumentName)\n+                                                && argument.getDirection().equals(\"in\"))\n+                                        .findFirst().orElseThrow(() -> new ChannelConfigException(\n+                                                \"Set-Argument '\" + argumentName + \"' not found\"));\n+                                SCPDStateVariableType relatedStateVariable = serviceRoot.getServiceStateTable().stream()\n+                                        .filter(stateVariable -> stateVariable.getName()\n+                                                .equals(scpdArgument.getRelatedStateVariable()))\n+                                        .findFirst().orElseThrow(() -> new ChannelConfigException(\"StateVariable '\"\n+                                                + scpdArgument.getRelatedStateVariable() + \"' not found\"));\n+                                if (channelConfig.getDataType().isEmpty()) {\n+                                    channelConfig.setDataType(relatedStateVariable.getDataType());\n+                                } else if (!channelConfig.getDataType().equals(relatedStateVariable.getDataType())) {\n+                                    throw new ChannelConfigException(\"dataType of set and get action are different\");\n+                                }\n+                            }\n+                        }\n+\n+                        // everything is available, create the channel\n+                        ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID,\n+                                channelTypeDescription.getName());\n+                        if (parameters.isEmpty()) {\n+                            // we have no parameters, so create a single channel\n+                            ChannelUID channelUID = new ChannelUID(thing.getUID(), channelId);\n+                            ChannelBuilder channelBuilder = ChannelBuilder\n+                                    .create(channelUID, channelTypeDescription.getItem().getType())\n+                                    .withType(channelTypeUID);\n+                            thingBuilder.withChannel(channelBuilder.build());\n+                            channels.put(channelUID, channelConfig);\n+                        } else {\n+                            // create a channel for each parameter\n+                            parameters.forEach(parameter -> {\n+                                String normalizedParameter = UIDUtils.encode(parameter);\n+                                ChannelUID channelUID = new ChannelUID(thing.getUID(),\n+                                        channelId + \"_\" + normalizedParameter);\n+                                ChannelBuilder channelBuilder = ChannelBuilder\n+                                        .create(channelUID, channelTypeDescription.getItem().getType())\n+                                        .withType(channelTypeUID)\n+                                        .withLabel(channelTypeDescription.getLabel() + \" \" + parameter);\n+                                thingBuilder.withChannel(channelBuilder.build());\n+                                Tr064ChannelConfig channelConfig1 = new Tr064ChannelConfig(channelConfig);\n+                                channelConfig1.setParameter(parameter);\n+                                channels.put(channelUID, channelConfig1);\n+                            });\n+                        }\n+                    } catch (ChannelConfigException e) {\n+                        LOGGER.debug(\"Channel {} not available: {}\", channelId, e.getMessage());\n+                    }\n+                });\n+        return thingBuilder;\n+    }\n+\n+    private static Set<String> getAndCheckParameters(String channelId, ActionType action, SCPDActionType scpdAction,\n+            SCPDScpdType serviceRoot, Tr064BaseThingConfiguration thingConfig) throws ChannelConfigException {\n+        ParameterType parameter = action.getParameter();\n+        if (parameter == null) {\n+            return Collections.emptySet();\n+        }\n+        try {\n+            Set<String> parameters = new HashSet<>();\n+\n+            // get parameters by reflection from thing config\n+            Field paramField = thingConfig.getClass().getField(parameter.getThingParameter());\n+            Object rawFieldValue = paramField.get(thingConfig);\n+            if ((rawFieldValue instanceof List<?>)) {\n+                ((List<?>) rawFieldValue).forEach(obj -> {\n+                    if (obj instanceof String) {\n+                        parameters.add((String) obj);\n+                    }\n+                });\n+            }\n+\n+            // validate parameter against pattern\n+            String parameterPattern = parameter.getPattern();\n+            if (parameterPattern != null) {\n+                parameters.removeIf(param -> !param.matches(parameterPattern));\n+            }\n+\n+            // validate parameter against SCPD (if not internal only)\n+            if (!parameter.isInternalOnly()) {\n+                SCPDArgumentType scpdArgument = scpdAction.getArgumentList().stream()\n+                        .filter(argument -> argument.getName().equals(parameter.getName())\n+                                && argument.getDirection().equals(\"in\"))\n+                        .findFirst().orElseThrow(() -> new ChannelConfigException(\n+                                \"Get-Parameter '\" + parameter.getName() + \"' not found\"));\n+                SCPDStateVariableType relatedStateVariable = serviceRoot.getServiceStateTable().stream()\n+                        .filter(stateVariable -> stateVariable.getName().equals(scpdArgument.getRelatedStateVariable()))\n+                        .findFirst().orElseThrow(() -> new ChannelConfigException(\n+                                \"StateVariable '\" + scpdArgument.getRelatedStateVariable() + \"' not found\"));\n+                if (relatedStateVariable.getAllowedValueRange() != null) {\n+                    int paramMin = relatedStateVariable.getAllowedValueRange().getMinimum();\n+                    int paramMax = relatedStateVariable.getAllowedValueRange().getMaximum();\n+                    int paramStep = relatedStateVariable.getAllowedValueRange().getStep();\n+                    Set<String> allowedValues = Stream.iterate(paramMin, i -> i <= paramMax, i -> i + paramStep)\n+                            .map(String::valueOf).collect(Collectors.toSet());\n+                    parameters.removeIf(param -> !allowedValues.contains(param));", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEzMDUwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499130507", "bodyText": "Nice, Thanks.", "author": "J-N-K", "createdAt": "2020-10-03T09:01:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0NjIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1MDQzMg==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499050432", "bodyText": "See if you can refactor this into another function since it looks like there is similar code is used in 2 other places.", "author": "cpmeister", "createdAt": "2020-10-02T21:06:12Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/util/Util.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal.util;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.*;\n+\n+import java.io.InputStream;\n+import java.lang.reflect.Field;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.soap.SOAPException;\n+import javax.xml.soap.SOAPMessage;\n+import javax.xml.transform.stream.StreamSource;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.tr064.internal.ChannelConfigException;\n+import org.openhab.binding.tr064.internal.config.Tr064BaseThingConfiguration;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064RootConfiguration;\n+import org.openhab.binding.tr064.internal.config.Tr064SubConfiguration;\n+import org.openhab.binding.tr064.internal.dto.config.ActionType;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescription;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescriptions;\n+import org.openhab.binding.tr064.internal.dto.config.ParameterType;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDArgumentType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDScpdType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDStateVariableType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.util.UIDUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.w3c.dom.NodeList;\n+\n+/**\n+ * The {@link Util} is a set of helper functions\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Util {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(Util.class);\n+\n+    public static List<ChannelTypeDescription> readXMLChannelConfig() {\n+        try {\n+            InputStream resource = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"channels.xml\");\n+            JAXBContext context = JAXBContext.newInstance(ChannelTypeDescriptions.class);\n+            Unmarshaller um = context.createUnmarshaller();\n+            JAXBElement<ChannelTypeDescriptions> root = um.unmarshal(new StreamSource(resource),\n+                    ChannelTypeDescriptions.class);\n+            return root.getValue().getChannel();\n+        } catch (JAXBException e) {\n+            LOGGER.warn(\"Failed to read channel definitions\", e);\n+            return Collections.emptyList();\n+        }\n+    }\n+\n+    public static ThingBuilder checkAvailableChannels(Thing thing, ThingBuilder thingBuilder, SCPDUtil scpdUtil,\n+            String deviceId, String deviceType, Map<ChannelUID, Tr064ChannelConfig> channels) {\n+        Tr064BaseThingConfiguration thingConfig = thing.getThingTypeUID().equals(THING_TYPE_FRITZBOX)\n+                ? thing.getConfiguration().as(Tr064RootConfiguration.class)\n+                : thing.getConfiguration().as(Tr064SubConfiguration.class);\n+        CHANNEL_TYPES.stream().filter(channel -> deviceType.equals(channel.getService().getDeviceType()))\n+                .forEach(channelTypeDescription -> {\n+                    String channelId = channelTypeDescription.getName();\n+                    String serviceId = channelTypeDescription.getService().getServiceId();\n+                    Set<String> parameters = new HashSet<>();\n+                    try {\n+                        SCPDServiceType deviceService = scpdUtil.getDevice(deviceId)\n+                                .flatMap(device -> device.getServiceList().stream()\n+                                        .filter(service -> service.getServiceId().equals(serviceId)).findFirst())\n+                                .orElseThrow(() -> new ChannelConfigException(\"Service '\" + serviceId + \"' not found\"));\n+                        SCPDScpdType serviceRoot = scpdUtil.getService(deviceService.getServiceId())\n+                                .orElseThrow(() -> new ChannelConfigException(\n+                                        \"Service definition for '\" + serviceId + \"' not found\"));\n+                        Tr064ChannelConfig channelConfig = new Tr064ChannelConfig(channelTypeDescription,\n+                                deviceService);\n+\n+                        // get\n+                        ActionType getAction = channelTypeDescription.getGetAction();\n+                        if (getAction != null) {\n+                            String actionName = getAction.getName();\n+                            String argumentName = getAction.getArgument();\n+                            SCPDActionType scpdAction = serviceRoot.getActionList().stream()\n+                                    .filter(action -> actionName.equals(action.getName())).findFirst()\n+                                    .orElseThrow(() -> new ChannelConfigException(\n+                                            \"Get-Action '\" + actionName + \"' not found\"));\n+                            SCPDArgumentType scpdArgument = scpdAction.getArgumentList().stream()\n+                                    .filter(argument -> argument.getName().equals(argumentName)\n+                                            && argument.getDirection().equals(\"out\"))\n+                                    .findFirst().orElseThrow(() -> new ChannelConfigException(\n+                                            \"Get-Argument '\" + argumentName + \"' not found\"));\n+                            SCPDStateVariableType relatedStateVariable = serviceRoot.getServiceStateTable().stream()\n+                                    .filter(stateVariable -> stateVariable.getName()\n+                                            .equals(scpdArgument.getRelatedStateVariable()))\n+                                    .findFirst().orElseThrow(() -> new ChannelConfigException(\"StateVariable '\"\n+                                            + scpdArgument.getRelatedStateVariable() + \"' not found\"));", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2MDQ0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499060447", "bodyText": "Minor adjustment to refactor the callback.sendUpdate.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        match.ifPresentOrElse(name -> callback.sendUpdate(new StringType(name)), () -> {\n          \n          \n            \n                            logger.debug(\"Number '{}' not found in phonebook '{}' from provider '{}'\", state, phonebookName,\n          \n          \n            \n                                    thingUID);\n          \n          \n            \n                            callback.sendUpdate(state);\n          \n          \n            \n                        });\n          \n          \n            \n                        State newState = match.map(name -> (State) new StringType(name)).orElse(state);\n          \n          \n            \n                        if(newState == state) {\n          \n          \n            \n                             logger.debug(\"Number '{}' not found in phonebook '{}' from provider '{}'\", state, phonebookName,\n          \n          \n            \n                                    thingUID);\n          \n          \n            \n                        }\n          \n          \n            \n                        callback.sendUpdate(newState);", "author": "cpmeister", "createdAt": "2020-10-02T21:35:26Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/phonebook/PhonebookProfile.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal.phonebook;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.profiles.ProfileCallback;\n+import org.openhab.core.thing.profiles.ProfileContext;\n+import org.openhab.core.thing.profiles.ProfileTypeUID;\n+import org.openhab.core.thing.profiles.StateProfile;\n+import org.openhab.core.transform.TransformationService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.util.UIDUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PhonebookProfile} class provides a profile for resolving phone number strings to names\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PhonebookProfile implements StateProfile {\n+    public static final ProfileTypeUID PHONEBOOK_PROFILE_TYPE_UID = new ProfileTypeUID(\n+            TransformationService.TRANSFORM_PROFILE_SCOPE, \"PHONEBOOK\");\n+\n+    public static final String PHONEBOOK_PARAM = \"phonebook\";\n+    private static final String MATCH_COUNT_PARAM = \"matchCount\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(PhonebookProfile.class);\n+\n+    private final ProfileCallback callback;\n+\n+    private final @Nullable String phonebookName;\n+    private final @Nullable ThingUID thingUID;\n+    private final Map<ThingUID, PhonebookProvider> phonebookProviders;\n+    private final int matchCount;\n+\n+    public PhonebookProfile(ProfileCallback callback, ProfileContext context,\n+            Map<ThingUID, PhonebookProvider> phonebookProviders) {\n+        this.callback = callback;\n+        this.phonebookProviders = phonebookProviders;\n+\n+        Configuration configuration = context.getConfiguration();\n+        Object phonebookParam = configuration.get(PHONEBOOK_PARAM);\n+        Object matchCountParam = configuration.get(MATCH_COUNT_PARAM);\n+\n+        logger.debug(\"Profile configured with '{}'='{}', '{}'='{}'\", PHONEBOOK_PARAM, phonebookParam, MATCH_COUNT_PARAM,\n+                matchCountParam);\n+\n+        ThingUID thingUID;\n+        String phonebookName = null;\n+        int matchCount = 0;\n+\n+        try {\n+            if (!(phonebookParam instanceof String)\n+                    || ((matchCountParam != null) && !(matchCountParam instanceof String))) {\n+                throw new IllegalArgumentException(\"Parameters need to be Strings\");\n+            }\n+            String[] phonebookParams = ((String) phonebookParam).split(\":\");\n+            if (phonebookParams.length > 2) {\n+                throw new IllegalArgumentException(\"Could not split 'phonebook' parameter\");\n+            }\n+            thingUID = new ThingUID(UIDUtils.decode(phonebookParams[0]));\n+            if (phonebookParams.length == 2) {\n+                phonebookName = UIDUtils.decode(phonebookParams[1]);\n+            }\n+            if (matchCountParam != null) {\n+                matchCount = Integer.parseInt((String) matchCountParam);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.warn(\"Could not initialize PHONEBOOK transformation profile: {}. Profile will be inactive.\",\n+                    e.getMessage());\n+            thingUID = null;\n+        }\n+\n+        this.thingUID = thingUID;\n+        this.phonebookName = phonebookName;\n+        this.matchCount = matchCount;\n+    }\n+\n+    @Override\n+    public void onCommandFromItem(Command command) {\n+    }\n+\n+    @Override\n+    public void onCommandFromHandler(Command command) {\n+    }\n+\n+    @Override\n+    public void onStateUpdateFromHandler(State state) {\n+        if (state instanceof StringType) {\n+            PhonebookProvider provider = phonebookProviders.get(thingUID);\n+            if (provider == null) {\n+                logger.warn(\"Could not get phonebook provider with thing UID '{}'.\", thingUID);\n+                return;\n+            }\n+            final String phonebookName = this.phonebookName;\n+            Optional<String> match;\n+            if (phonebookName != null) {\n+                match = provider.getPhonebookByName(phonebookName).or(() -> {\n+                    logger.warn(\"Could not get phonebook '{}' from provider '{}'\", phonebookName, thingUID);\n+                    return Optional.empty();\n+                }).flatMap(phonebook -> phonebook.lookupNumber(state.toString(), matchCount));\n+            } else {\n+                match = provider.getPhonebooks().stream().map(p -> p.lookupNumber(state.toString(), matchCount))\n+                        .filter(Optional::isPresent).map(Optional::get).findAny();\n+            }\n+            match.ifPresentOrElse(name -> callback.sendUpdate(new StringType(name)), () -> {\n+                logger.debug(\"Number '{}' not found in phonebook '{}' from provider '{}'\", state, phonebookName,\n+                        thingUID);\n+                callback.sendUpdate(state);\n+            });", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2MzYzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499063639", "bodyText": "Why do you need to keep track of the linked channels? Can't you use isLinked instead?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (linkedChannels.contains(channelUID)) {\n          \n          \n            \n                        if (isLinked(channelUID)) {", "author": "cpmeister", "createdAt": "2020-10-02T21:45:41Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064SubHandler.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE;\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE_LAN;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064SubConfiguration;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.binding.tr064.internal.util.SCPDUtil;\n+import org.openhab.binding.tr064.internal.util.Util;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064SubHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Tr064SubHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_SUBDEVICE,\n+            THING_TYPE_SUBDEVICE_LAN);\n+    private static final int RETRY_INTERVAL = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(Tr064SubHandler.class);\n+\n+    private Tr064SubConfiguration config = new Tr064SubConfiguration();\n+\n+    private String deviceType = \"\";\n+    private boolean isInitialized = false;\n+\n+    private final Map<ChannelUID, Tr064ChannelConfig> channels = new HashMap<>();\n+    // caching is used to prevent excessive calls to the same action\n+    private final ExpiringCacheMap<ChannelUID, State> stateCache = new ExpiringCacheMap<>(2000);\n+    private final Set<ChannelUID> linkedChannels = ConcurrentHashMap.newKeySet();\n+\n+    private @Nullable SOAPConnector soapConnector;\n+    private @Nullable ScheduledFuture<?> connectFuture;\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+\n+    Tr064SubHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"null\")\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        Tr064ChannelConfig channelConfig = channels.get(channelUID);\n+        if (channelConfig == null) {\n+            logger.trace(\"Channel {} not supported.\", channelUID);\n+            return;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            State state = stateCache.putIfAbsentAndGet(channelUID, () -> soapConnector == null ? UnDefType.UNDEF\n+                    : soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n+            return;\n+        }\n+\n+        if (channelConfig.getChannelTypeDescription().getSetAction() == null) {\n+            logger.debug(\"Discarding command {} to {}, read-only channel\", command, channelUID);\n+            return;\n+        }\n+        scheduler.execute(() -> {\n+            if (soapConnector == null) {\n+                logger.warn(\"Could not send command because connector not available\");\n+            } else {\n+                soapConnector.sendChannelCommandToDevice(channelConfig, command);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(Tr064SubConfiguration.class);\n+        if (!config.isValid()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"One or more mandatory configuration field is empty\");\n+            return;\n+        }\n+\n+        final Bridge bridge = getBridge();\n+        if (bridge != null && bridge.getStatus().equals(ThingStatus.ONLINE)) {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            connectFuture = scheduler.scheduleWithFixedDelay(this::internalInitialize, 0, 30, TimeUnit.SECONDS);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        }\n+    }\n+\n+    private void internalInitialize() {\n+        final Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            return;\n+        }\n+        final Tr064RootHandler bridgeHandler = (Tr064RootHandler) bridge.getHandler();\n+        if (bridgeHandler == null) {\n+            logger.warn(\"Bridge-handler is null in thing {}\", thing.getUID());\n+            return;\n+        }\n+        final SCPDUtil scpdUtil = bridgeHandler.getSCPDUtil();\n+        if (scpdUtil == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not get device definitions\");\n+            return;\n+        }\n+\n+        if (checkProperties(scpdUtil)) {\n+            // properties set, check channels\n+            ThingBuilder thingBuilder = editThing();\n+            thingBuilder.withoutChannels(thing.getChannels());\n+            Util.checkAvailableChannels(thing, thingBuilder, scpdUtil, config.uuid, deviceType, channels);\n+            updateThing(thingBuilder.build());\n+\n+            // remove connect scheduler\n+            final ScheduledFuture<?> connectFuture = this.connectFuture;\n+            if (connectFuture != null) {\n+                connectFuture.cancel(false);\n+                this.connectFuture = null;\n+            }\n+\n+            isInitialized = true;\n+            soapConnector = bridgeHandler.getSOAPConnector();\n+            installPolling();\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> connectFuture = this.connectFuture;\n+        if (connectFuture != null) {\n+            connectFuture.cancel(true);\n+            this.connectFuture = null;\n+        }\n+        uninstallPolling();\n+\n+        stateCache.clear();\n+        isInitialized = false;\n+\n+        super.dispose();\n+    }\n+\n+    /**\n+     * poll remote device for channel values\n+     */\n+    private void poll() {\n+        channels.forEach((channelUID, channelConfig) -> {\n+            if (linkedChannels.contains(channelUID)) {", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEzMTY5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499131695", "bodyText": "I guess a set-lookup is faster, but changed.", "author": "J-N-K", "createdAt": "2020-10-03T09:19:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2MzYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2Mzg2NA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499063864", "bodyText": "refactor this into its own method", "author": "cpmeister", "createdAt": "2020-10-02T21:46:28Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064SubHandler.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE;\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE_LAN;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064SubConfiguration;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.binding.tr064.internal.util.SCPDUtil;\n+import org.openhab.binding.tr064.internal.util.Util;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064SubHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Tr064SubHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_SUBDEVICE,\n+            THING_TYPE_SUBDEVICE_LAN);\n+    private static final int RETRY_INTERVAL = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(Tr064SubHandler.class);\n+\n+    private Tr064SubConfiguration config = new Tr064SubConfiguration();\n+\n+    private String deviceType = \"\";\n+    private boolean isInitialized = false;\n+\n+    private final Map<ChannelUID, Tr064ChannelConfig> channels = new HashMap<>();\n+    // caching is used to prevent excessive calls to the same action\n+    private final ExpiringCacheMap<ChannelUID, State> stateCache = new ExpiringCacheMap<>(2000);\n+    private final Set<ChannelUID> linkedChannels = ConcurrentHashMap.newKeySet();\n+\n+    private @Nullable SOAPConnector soapConnector;\n+    private @Nullable ScheduledFuture<?> connectFuture;\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+\n+    Tr064SubHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"null\")\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        Tr064ChannelConfig channelConfig = channels.get(channelUID);\n+        if (channelConfig == null) {\n+            logger.trace(\"Channel {} not supported.\", channelUID);\n+            return;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            State state = stateCache.putIfAbsentAndGet(channelUID, () -> soapConnector == null ? UnDefType.UNDEF\n+                    : soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n+            return;\n+        }\n+\n+        if (channelConfig.getChannelTypeDescription().getSetAction() == null) {\n+            logger.debug(\"Discarding command {} to {}, read-only channel\", command, channelUID);\n+            return;\n+        }\n+        scheduler.execute(() -> {\n+            if (soapConnector == null) {\n+                logger.warn(\"Could not send command because connector not available\");\n+            } else {\n+                soapConnector.sendChannelCommandToDevice(channelConfig, command);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(Tr064SubConfiguration.class);\n+        if (!config.isValid()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"One or more mandatory configuration field is empty\");\n+            return;\n+        }\n+\n+        final Bridge bridge = getBridge();\n+        if (bridge != null && bridge.getStatus().equals(ThingStatus.ONLINE)) {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            connectFuture = scheduler.scheduleWithFixedDelay(this::internalInitialize, 0, 30, TimeUnit.SECONDS);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        }\n+    }\n+\n+    private void internalInitialize() {\n+        final Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            return;\n+        }\n+        final Tr064RootHandler bridgeHandler = (Tr064RootHandler) bridge.getHandler();\n+        if (bridgeHandler == null) {\n+            logger.warn(\"Bridge-handler is null in thing {}\", thing.getUID());\n+            return;\n+        }\n+        final SCPDUtil scpdUtil = bridgeHandler.getSCPDUtil();\n+        if (scpdUtil == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not get device definitions\");\n+            return;\n+        }\n+\n+        if (checkProperties(scpdUtil)) {\n+            // properties set, check channels\n+            ThingBuilder thingBuilder = editThing();\n+            thingBuilder.withoutChannels(thing.getChannels());\n+            Util.checkAvailableChannels(thing, thingBuilder, scpdUtil, config.uuid, deviceType, channels);\n+            updateThing(thingBuilder.build());\n+\n+            // remove connect scheduler\n+            final ScheduledFuture<?> connectFuture = this.connectFuture;\n+            if (connectFuture != null) {\n+                connectFuture.cancel(false);\n+                this.connectFuture = null;\n+            }\n+\n+            isInitialized = true;\n+            soapConnector = bridgeHandler.getSOAPConnector();\n+            installPolling();\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> connectFuture = this.connectFuture;\n+        if (connectFuture != null) {\n+            connectFuture.cancel(true);\n+            this.connectFuture = null;\n+        }", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NDE0MA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499064140", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                \"One or more mandatory configuration field is empty\");\n          \n          \n            \n                                \"One or more mandatory configuration fields are empty\");\n          \n      \n    \n    \n  \n\nIt would also be more beneficial to the user if you could specify which required fields were blank.", "author": "cpmeister", "createdAt": "2020-10-02T21:47:25Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064SubHandler.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE;\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE_LAN;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064SubConfiguration;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.binding.tr064.internal.util.SCPDUtil;\n+import org.openhab.binding.tr064.internal.util.Util;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064SubHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Tr064SubHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_SUBDEVICE,\n+            THING_TYPE_SUBDEVICE_LAN);\n+    private static final int RETRY_INTERVAL = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(Tr064SubHandler.class);\n+\n+    private Tr064SubConfiguration config = new Tr064SubConfiguration();\n+\n+    private String deviceType = \"\";\n+    private boolean isInitialized = false;\n+\n+    private final Map<ChannelUID, Tr064ChannelConfig> channels = new HashMap<>();\n+    // caching is used to prevent excessive calls to the same action\n+    private final ExpiringCacheMap<ChannelUID, State> stateCache = new ExpiringCacheMap<>(2000);\n+    private final Set<ChannelUID> linkedChannels = ConcurrentHashMap.newKeySet();\n+\n+    private @Nullable SOAPConnector soapConnector;\n+    private @Nullable ScheduledFuture<?> connectFuture;\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+\n+    Tr064SubHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"null\")\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        Tr064ChannelConfig channelConfig = channels.get(channelUID);\n+        if (channelConfig == null) {\n+            logger.trace(\"Channel {} not supported.\", channelUID);\n+            return;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            State state = stateCache.putIfAbsentAndGet(channelUID, () -> soapConnector == null ? UnDefType.UNDEF\n+                    : soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n+            return;\n+        }\n+\n+        if (channelConfig.getChannelTypeDescription().getSetAction() == null) {\n+            logger.debug(\"Discarding command {} to {}, read-only channel\", command, channelUID);\n+            return;\n+        }\n+        scheduler.execute(() -> {\n+            if (soapConnector == null) {\n+                logger.warn(\"Could not send command because connector not available\");\n+            } else {\n+                soapConnector.sendChannelCommandToDevice(channelConfig, command);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(Tr064SubConfiguration.class);\n+        if (!config.isValid()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"One or more mandatory configuration field is empty\");", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEzMTk1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499131952", "bodyText": "This can only happen if the user decides to use textual configuration. So he/she'll probably be an advanced user and be able to figure it out. The UI doesn't allow to save an invalid config.  It would require removing the valid-check in the configuration classes and IMO the code is much clearer this way.", "author": "J-N-K", "createdAt": "2020-10-03T09:23:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NDE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NDcyMA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499064720", "bodyText": "Should this be logged as a warn? What could the user do about this if this happens? And how would they know to do it?", "author": "cpmeister", "createdAt": "2020-10-02T21:49:33Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064SubHandler.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE;\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE_LAN;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064SubConfiguration;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.binding.tr064.internal.util.SCPDUtil;\n+import org.openhab.binding.tr064.internal.util.Util;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064SubHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Tr064SubHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_SUBDEVICE,\n+            THING_TYPE_SUBDEVICE_LAN);\n+    private static final int RETRY_INTERVAL = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(Tr064SubHandler.class);\n+\n+    private Tr064SubConfiguration config = new Tr064SubConfiguration();\n+\n+    private String deviceType = \"\";\n+    private boolean isInitialized = false;\n+\n+    private final Map<ChannelUID, Tr064ChannelConfig> channels = new HashMap<>();\n+    // caching is used to prevent excessive calls to the same action\n+    private final ExpiringCacheMap<ChannelUID, State> stateCache = new ExpiringCacheMap<>(2000);\n+    private final Set<ChannelUID> linkedChannels = ConcurrentHashMap.newKeySet();\n+\n+    private @Nullable SOAPConnector soapConnector;\n+    private @Nullable ScheduledFuture<?> connectFuture;\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+\n+    Tr064SubHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"null\")\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        Tr064ChannelConfig channelConfig = channels.get(channelUID);\n+        if (channelConfig == null) {\n+            logger.trace(\"Channel {} not supported.\", channelUID);\n+            return;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            State state = stateCache.putIfAbsentAndGet(channelUID, () -> soapConnector == null ? UnDefType.UNDEF\n+                    : soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n+            return;\n+        }\n+\n+        if (channelConfig.getChannelTypeDescription().getSetAction() == null) {\n+            logger.debug(\"Discarding command {} to {}, read-only channel\", command, channelUID);\n+            return;\n+        }\n+        scheduler.execute(() -> {\n+            if (soapConnector == null) {\n+                logger.warn(\"Could not send command because connector not available\");", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2MjgyMw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499162823", "bodyText": "This happens if handleCommand is called before it is fully initialized. This should be prevented by the framework. However the null-check is necessary, because the field is @Nullable.", "author": "J-N-K", "createdAt": "2020-10-03T16:41:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NDcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA3Nzk0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499077943", "bodyText": "The previous logic really irked me because field assignment was getting performed inside of the streaming lambdas which I'd prefer to occur outside of your lambda logic. I went ahead and rearranged the logic but even now I'm not sure that it looks all that great. This logic should probably be refactored into several different methods.\nOh, I also noticed that you were not checking for null values in your final phonebook list so I fixed that.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    scpdUtil.getDevice(\"\").ifPresent(deviceType -> deviceType.getServiceList().stream()\n          \n          \n            \n                            .filter(service -> service.getServiceId().equals(serviceId)).findFirst().ifPresent(scpdService -> {\n          \n          \n            \n                                try {\n          \n          \n            \n                                    SOAPMessage soapMessagePhonebookList = soapConnector.doSOAPRequest(scpdService,\n          \n          \n            \n                                            \"GetPhonebookList\", Collections.emptyMap());\n          \n          \n            \n                                    SOAPValueConverter soapValueConverter = new SOAPValueConverter(httpClient);\n          \n          \n            \n                                    phonebooks = soapValueConverter\n          \n          \n            \n                                            .getStateFromSOAPValue(soapMessagePhonebookList, \"NewPhonebookList\", null)\n          \n          \n            \n                                            .map(phonebookList -> Arrays.stream(phonebookList.toString().split(\",\")).map(index -> {\n          \n          \n            \n                                                try {\n          \n          \n            \n                                                    SOAPMessage soapMessageURL = soapConnector.doSOAPRequest(scpdService,\n          \n          \n            \n                                                            \"GetPhonebook\", Map.of(\"NewPhonebookID\", index));\n          \n          \n            \n                                                    return soapValueConverter\n          \n          \n            \n                                                            .getStateFromSOAPValue(soapMessageURL, \"NewPhonebookURL\", null)\n          \n          \n            \n                                                            .map(url -> (Phonebook) new Tr064PhonebookImpl(httpClient,\n          \n          \n            \n                                                                    url.toString()))\n          \n          \n            \n                                                            .orElse(null);\n          \n          \n            \n                                                } catch (Tr064CommunicationException e) {\n          \n          \n            \n                                                    logger.warn(\"Failed to get phonebook with index {}:\", index, e);\n          \n          \n            \n                                                }\n          \n          \n            \n                                                return null;\n          \n          \n            \n                                            }).collect(Collectors.toList())).orElse(Collections.emptyList());\n          \n          \n            \n                                } catch (Tr064CommunicationException e) {\n          \n          \n            \n                                    phonebooks = Collections.emptyList();\n          \n          \n            \n                                }\n          \n          \n            \n                            }));\n          \n          \n            \n                    phonebooks = scpdUtil.getDevice(\"\")\n          \n          \n            \n                        .flatMap(deviceType -> deviceType.getServiceList().stream()\n          \n          \n            \n                            .filter(service -> service.getServiceId().equals(serviceId))\n          \n          \n            \n                            .findFirst())\n          \n          \n            \n                        .map(scpdService -> {\n          \n          \n            \n                            try {\n          \n          \n            \n                                return soapConnector.doSOAPRequest(scpdService,\n          \n          \n            \n                                         \"GetPhonebookList\", Collections.emptyMap());\n          \n          \n            \n                            } catch (Tr064CommunicationException e) {\n          \n          \n            \n                                return null;\n          \n          \n            \n                            }\n          \n          \n            \n                        }).map(soapMessagePhonebookList -> {\n          \n          \n            \n                                    SOAPValueConverter soapValueConverter = new SOAPValueConverter(httpClient);\n          \n          \n            \n                                    return soapValueConverter\n          \n          \n            \n                                            .getStateFromSOAPValue(soapMessagePhonebookList, \"NewPhonebookList\", null)\n          \n          \n            \n                                            .map(phonebookList -> Arrays.stream(phonebookList.toString().split(\",\")))\n          \n          \n            \n                                            .orElse(Streams.empty())\n          \n          \n            \n                                            .map(index -> {\n          \n          \n            \n                                                try {\n          \n          \n            \n                                                    SOAPMessage soapMessageURL = soapConnector.doSOAPRequest(scpdService,\n          \n          \n            \n                                                            \"GetPhonebook\", Map.of(\"NewPhonebookID\", index));\n          \n          \n            \n                                                    return soapValueConverter\n          \n          \n            \n                                                            .getStateFromSOAPValue(soapMessageURL, \"NewPhonebookURL\", null)\n          \n          \n            \n                                                            .map(url -> (Phonebook) new Tr064PhonebookImpl(httpClient,\n          \n          \n            \n                                                                    url.toString()))\n          \n          \n            \n                                                            .orElse(null);\n          \n          \n            \n                                                } catch (Tr064CommunicationException e) {\n          \n          \n            \n                                                    logger.warn(\"Failed to get phonebook with index {}:\", index, e);\n          \n          \n            \n                                                }\n          \n          \n            \n                                                return null;\n          \n          \n            \n                                            })\n          \n          \n            \n                                            .filter(Objects:nonNull)\n          \n          \n            \n                                            .collect(Collectors.toList());\n          \n          \n            \n                            }).orElse(Collections.emptyList());", "author": "cpmeister", "createdAt": "2020-10-02T22:40:38Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064RootHandler.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_FRITZBOX;\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_GENERIC;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.xml.soap.SOAPException;\n+import javax.xml.soap.SOAPMessage;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064RootConfiguration;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.binding.tr064.internal.phonebook.Phonebook;\n+import org.openhab.binding.tr064.internal.phonebook.PhonebookProvider;\n+import org.openhab.binding.tr064.internal.phonebook.Tr064PhonebookImpl;\n+import org.openhab.binding.tr064.internal.util.SCPDUtil;\n+import org.openhab.binding.tr064.internal.util.Util;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064RootHandler} is responsible for handling commands, which are\n+ * sent to one of the channels and update channel values\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Tr064RootHandler extends BaseBridgeHandler implements PhonebookProvider {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_GENERIC, THING_TYPE_FRITZBOX);\n+    private static final int RETRY_INTERVAL = 60;\n+    private static final Set<String> PROPERTY_ARGUMENTS = Set.of(\"NewSerialNumber\", \"NewSoftwareVersion\",\n+            \"NewModelName\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(Tr064RootHandler.class);\n+    private final HttpClient httpClient;\n+\n+    private Tr064RootConfiguration config = new Tr064RootConfiguration();\n+    private String deviceType = \"\";\n+\n+    private @Nullable SCPDUtil scpdUtil;\n+    private SOAPConnector soapConnector;\n+    private String endpointBaseURL = \"http://fritz.box:49000\";\n+\n+    private final Map<ChannelUID, Tr064ChannelConfig> channels = new HashMap<>();\n+    // caching is used to prevent excessive calls to the same action\n+    private final ExpiringCacheMap<ChannelUID, State> stateCache = new ExpiringCacheMap<>(2000);\n+    private final Set<ChannelUID> linkedChannels = ConcurrentHashMap.newKeySet();\n+    private Collection<Phonebook> phonebooks = Collections.emptyList();\n+\n+    private @Nullable ScheduledFuture<?> connectFuture;\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+    private @Nullable ScheduledFuture<?> phonebookFuture;\n+\n+    Tr064RootHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        soapConnector = new SOAPConnector(httpClient, endpointBaseURL);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"null\")\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        Tr064ChannelConfig channelConfig = channels.get(channelUID);\n+        if (channelConfig == null) {\n+            logger.trace(\"Channel {} not supported.\", channelUID);\n+            return;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            State state = stateCache.putIfAbsentAndGet(channelUID,\n+                    () -> soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n+            return;\n+        }\n+\n+        if (channelConfig.getChannelTypeDescription().getSetAction() == null) {\n+            logger.debug(\"Discarding command {} to {}, read-only channel\", command, channelUID);\n+            return;\n+        }\n+        scheduler.execute(() -> soapConnector.sendChannelCommandToDevice(channelConfig, command));\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(Tr064RootConfiguration.class);\n+        if (!config.isValid()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"At least one mandatory configuration field is empty\");\n+            return;\n+        }\n+\n+        endpointBaseURL = \"http://\" + config.host + \":49000\";\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        connectFuture = scheduler.scheduleWithFixedDelay(this::internalInitialize, 0, RETRY_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * internal thing initializer (sets SCPDUtil and connects to remote device)\n+     */\n+    private void internalInitialize() {\n+        try {\n+            scpdUtil = new SCPDUtil(httpClient, endpointBaseURL);\n+        } catch (SCPDException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"could not get device definitions from \" + config.host);\n+            return;\n+        }\n+\n+        if (establishSecureConnectionAndUpdateProperties()) {\n+            final ScheduledFuture<?> connectFuture = this.connectFuture;\n+            if (connectFuture != null) {\n+                connectFuture.cancel(false);\n+                this.connectFuture = null;\n+            }\n+\n+            // connection successful, check channels\n+            ThingBuilder thingBuilder = editThing();\n+            thingBuilder.withoutChannels(thing.getChannels());\n+            final SCPDUtil scpdUtil = this.scpdUtil;\n+            if (scpdUtil != null) {\n+                Util.checkAvailableChannels(thing, thingBuilder, scpdUtil, \"\", deviceType, channels);\n+                updateThing(thingBuilder.build());\n+            }\n+\n+            installPolling();\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> connectFuture = this.connectFuture;\n+        if (connectFuture != null) {\n+            connectFuture.cancel(true);\n+            this.connectFuture = null;\n+        }\n+        uninstallPolling();\n+\n+        stateCache.clear();\n+\n+        super.dispose();\n+    }\n+\n+    /**\n+     * poll remote device for channel values\n+     */\n+    private void poll() {\n+        channels.forEach((channelUID, channelConfig) -> {\n+            if (linkedChannels.contains(channelUID)) {\n+                State state = stateCache.putIfAbsentAndGet(channelUID,\n+                        () -> soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+                if (state != null) {\n+                    updateState(channelUID, state);\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * establish the connection - get secure port (if avallable), install authentication, get device properties\n+     *\n+     * @return true if successful\n+     */\n+    private boolean establishSecureConnectionAndUpdateProperties() {\n+        final SCPDUtil scpdUtil = this.scpdUtil;\n+        if (scpdUtil != null) {\n+            try {\n+                SCPDDeviceType device = scpdUtil.getDevice(\"\")\n+                        .orElseThrow(() -> new SCPDException(\"Root device not found\"));\n+                SCPDServiceType deviceService = device.getServiceList().stream()\n+                        .filter(service -> service.getServiceId().equals(\"urn:DeviceInfo-com:serviceId:DeviceInfo1\"))\n+                        .findFirst().orElseThrow(() -> new SCPDException(\n+                                \"service 'urn:DeviceInfo-com:serviceId:DeviceInfo1' not found\"));\n+\n+                this.deviceType = device.getDeviceType();\n+\n+                // try to get security (https) port\n+                SOAPMessage soapResponse = soapConnector.doSOAPRequest(deviceService, \"GetSecurityPort\",\n+                        Collections.emptyMap());\n+                if (!soapResponse.getSOAPBody().hasFault()) {\n+                    SOAPValueConverter soapValueConverter = new SOAPValueConverter(httpClient);\n+                    soapValueConverter.getStateFromSOAPValue(soapResponse, \"NewSecurityPort\", null)\n+                            .ifPresentOrElse(port -> {\n+                                endpointBaseURL = \"https://\" + config.host + \":\" + port.toString();\n+                                soapConnector = new SOAPConnector(httpClient, endpointBaseURL);\n+                                logger.debug(\"endpointBaseURL is now '{}'\", endpointBaseURL);\n+                            }, () -> logger.warn(\"Could not determine secure port, disabling https\"));\n+                } else {\n+                    logger.warn(\"Could not determine secure port, disabling https\");\n+                }\n+\n+                // clear auth cache and force re-auth\n+                httpClient.getAuthenticationStore().clearAuthenticationResults();\n+                AuthenticationStore auth = httpClient.getAuthenticationStore();\n+                auth.addAuthentication(new DigestAuthentication(new URI(endpointBaseURL), Authentication.ANY_REALM,\n+                        config.user, config.password));\n+\n+                // check & update properties\n+                SCPDActionType getInfoAction = scpdUtil.getService(deviceService.getServiceId())\n+                        .orElseThrow(() -> new SCPDException(\n+                                \"Could not get service definition for 'urn:DeviceInfo-com:serviceId:DeviceInfo1'\"))\n+                        .getActionList().stream().filter(action -> action.getName().equals(\"GetInfo\")).findFirst()\n+                        .orElseThrow(() -> new SCPDException(\"Action 'GetInfo' not found\"));\n+                SOAPMessage soapResponse1 = soapConnector.doSOAPRequest(deviceService, getInfoAction.getName(),\n+                        Collections.emptyMap());\n+                SOAPValueConverter soapValueConverter = new SOAPValueConverter(httpClient);\n+                Map<String, String> properties = editProperties();\n+                PROPERTY_ARGUMENTS.forEach(argumentName -> getInfoAction.getArgumentList().stream()\n+                        .filter(argument -> argument.getName().equals(argumentName)).findFirst()\n+                        .ifPresent(argument -> soapValueConverter\n+                                .getStateFromSOAPValue(soapResponse1, argumentName, null).ifPresent(value -> properties\n+                                        .put(argument.getRelatedStateVariable(), value.toString()))));\n+                properties.put(\"deviceType\", device.getDeviceType());\n+                updateProperties(properties);\n+\n+                return true;\n+            } catch (SCPDException | SOAPException | Tr064CommunicationException | URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                return false;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * get all sub devices of this root device (used for discovery)\n+     *\n+     * @return the list\n+     */\n+    public List<SCPDDeviceType> getAllSubDevices() {\n+        final SCPDUtil scpdUtil = this.scpdUtil;\n+        return (scpdUtil == null) ? Collections.emptyList() : scpdUtil.getAllSubDevices();\n+    }\n+\n+    /**\n+     * get the SOAP connector (used by sub devices for communication with the remote device)\n+     *\n+     * @return the SOAP connector\n+     */\n+    public SOAPConnector getSOAPConnector() {\n+        return soapConnector;\n+    }\n+\n+    /**\n+     * get the SCPD processing utility\n+     *\n+     * @return the SCPD utility (or null if not available)\n+     */\n+    public @Nullable SCPDUtil getSCPDUtil() {\n+        return scpdUtil;\n+    }\n+\n+    @Override\n+    public void channelLinked(ChannelUID channelUID) {\n+        linkedChannels.add(channelUID);\n+        super.channelLinked(channelUID);\n+        logger.debug(\"Channel {} linked\", channelUID);\n+    }\n+\n+    @Override\n+    public void channelUnlinked(ChannelUID channelUID) {\n+        super.channelUnlinked(channelUID);\n+        linkedChannels.remove(channelUID);\n+        logger.debug(\"Channel {} unlinked\", channelUID);\n+    }\n+\n+    /**\n+     * uninstall the polling\n+     */\n+    private void uninstallPolling() {\n+        final ScheduledFuture<?> pollFuture = this.pollFuture;\n+        if (pollFuture != null) {\n+            pollFuture.cancel(true);\n+            this.pollFuture = null;\n+        }\n+        final ScheduledFuture<?> phonebookFuture = this.phonebookFuture;\n+        if (phonebookFuture != null) {\n+            phonebookFuture.cancel(true);\n+            this.phonebookFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * install the polling\n+     */\n+    private void installPolling() {\n+        uninstallPolling();\n+        pollFuture = scheduler.scheduleWithFixedDelay(this::poll, 0, config.refresh, TimeUnit.SECONDS);\n+        if (config.phonebookInterval > 0) {\n+            phonebookFuture = scheduler.scheduleWithFixedDelay(this::retrievePhonebooks, 0, config.phonebookInterval,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void retrievePhonebooks() {\n+        String serviceId = \"urn:X_AVM-DE_OnTel-com:serviceId:X_AVM-DE_OnTel1\";\n+        scpdUtil.getDevice(\"\").ifPresent(deviceType -> deviceType.getServiceList().stream()\n+                .filter(service -> service.getServiceId().equals(serviceId)).findFirst().ifPresent(scpdService -> {\n+                    try {\n+                        SOAPMessage soapMessagePhonebookList = soapConnector.doSOAPRequest(scpdService,\n+                                \"GetPhonebookList\", Collections.emptyMap());\n+                        SOAPValueConverter soapValueConverter = new SOAPValueConverter(httpClient);\n+                        phonebooks = soapValueConverter\n+                                .getStateFromSOAPValue(soapMessagePhonebookList, \"NewPhonebookList\", null)\n+                                .map(phonebookList -> Arrays.stream(phonebookList.toString().split(\",\")).map(index -> {\n+                                    try {\n+                                        SOAPMessage soapMessageURL = soapConnector.doSOAPRequest(scpdService,\n+                                                \"GetPhonebook\", Map.of(\"NewPhonebookID\", index));\n+                                        return soapValueConverter\n+                                                .getStateFromSOAPValue(soapMessageURL, \"NewPhonebookURL\", null)\n+                                                .map(url -> (Phonebook) new Tr064PhonebookImpl(httpClient,\n+                                                        url.toString()))\n+                                                .orElse(null);\n+                                    } catch (Tr064CommunicationException e) {\n+                                        logger.warn(\"Failed to get phonebook with index {}:\", index, e);\n+                                    }\n+                                    return null;\n+                                }).collect(Collectors.toList())).orElse(Collections.emptyList());\n+                    } catch (Tr064CommunicationException e) {\n+                        phonebooks = Collections.emptyList();\n+                    }\n+                }));", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE0MDcxNg==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499140716", "bodyText": "I tried something similiar before. Unfortunately this will not work. scpdService is no longer available in l. 354 if you re-arrange the code like that.", "author": "J-N-K", "createdAt": "2020-10-03T11:39:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA3Nzk0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE0NzcwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499147704", "bodyText": "I refactored the code, WDYT?", "author": "J-N-K", "createdAt": "2020-10-03T13:24:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA3Nzk0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4NTUwMg==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499185502", "bodyText": "Looks better than before at least. \ud83d\ude04", "author": "cpmeister", "createdAt": "2020-10-03T22:04:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA3Nzk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA3ODU1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499078556", "bodyText": "same linked channels question as above", "author": "cpmeister", "createdAt": "2020-10-02T22:43:12Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064RootHandler.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_FRITZBOX;\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_GENERIC;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.xml.soap.SOAPException;\n+import javax.xml.soap.SOAPMessage;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064RootConfiguration;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.binding.tr064.internal.phonebook.Phonebook;\n+import org.openhab.binding.tr064.internal.phonebook.PhonebookProvider;\n+import org.openhab.binding.tr064.internal.phonebook.Tr064PhonebookImpl;\n+import org.openhab.binding.tr064.internal.util.SCPDUtil;\n+import org.openhab.binding.tr064.internal.util.Util;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064RootHandler} is responsible for handling commands, which are\n+ * sent to one of the channels and update channel values\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Tr064RootHandler extends BaseBridgeHandler implements PhonebookProvider {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_GENERIC, THING_TYPE_FRITZBOX);\n+    private static final int RETRY_INTERVAL = 60;\n+    private static final Set<String> PROPERTY_ARGUMENTS = Set.of(\"NewSerialNumber\", \"NewSoftwareVersion\",\n+            \"NewModelName\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(Tr064RootHandler.class);\n+    private final HttpClient httpClient;\n+\n+    private Tr064RootConfiguration config = new Tr064RootConfiguration();\n+    private String deviceType = \"\";\n+\n+    private @Nullable SCPDUtil scpdUtil;\n+    private SOAPConnector soapConnector;\n+    private String endpointBaseURL = \"http://fritz.box:49000\";\n+\n+    private final Map<ChannelUID, Tr064ChannelConfig> channels = new HashMap<>();\n+    // caching is used to prevent excessive calls to the same action\n+    private final ExpiringCacheMap<ChannelUID, State> stateCache = new ExpiringCacheMap<>(2000);\n+    private final Set<ChannelUID> linkedChannels = ConcurrentHashMap.newKeySet();\n+    private Collection<Phonebook> phonebooks = Collections.emptyList();\n+\n+    private @Nullable ScheduledFuture<?> connectFuture;\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+    private @Nullable ScheduledFuture<?> phonebookFuture;\n+\n+    Tr064RootHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        soapConnector = new SOAPConnector(httpClient, endpointBaseURL);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"null\")\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        Tr064ChannelConfig channelConfig = channels.get(channelUID);\n+        if (channelConfig == null) {\n+            logger.trace(\"Channel {} not supported.\", channelUID);\n+            return;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            State state = stateCache.putIfAbsentAndGet(channelUID,\n+                    () -> soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n+            return;\n+        }\n+\n+        if (channelConfig.getChannelTypeDescription().getSetAction() == null) {\n+            logger.debug(\"Discarding command {} to {}, read-only channel\", command, channelUID);\n+            return;\n+        }\n+        scheduler.execute(() -> soapConnector.sendChannelCommandToDevice(channelConfig, command));\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(Tr064RootConfiguration.class);\n+        if (!config.isValid()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"At least one mandatory configuration field is empty\");\n+            return;\n+        }\n+\n+        endpointBaseURL = \"http://\" + config.host + \":49000\";\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        connectFuture = scheduler.scheduleWithFixedDelay(this::internalInitialize, 0, RETRY_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * internal thing initializer (sets SCPDUtil and connects to remote device)\n+     */\n+    private void internalInitialize() {\n+        try {\n+            scpdUtil = new SCPDUtil(httpClient, endpointBaseURL);\n+        } catch (SCPDException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"could not get device definitions from \" + config.host);\n+            return;\n+        }\n+\n+        if (establishSecureConnectionAndUpdateProperties()) {\n+            final ScheduledFuture<?> connectFuture = this.connectFuture;\n+            if (connectFuture != null) {\n+                connectFuture.cancel(false);\n+                this.connectFuture = null;\n+            }\n+\n+            // connection successful, check channels\n+            ThingBuilder thingBuilder = editThing();\n+            thingBuilder.withoutChannels(thing.getChannels());\n+            final SCPDUtil scpdUtil = this.scpdUtil;\n+            if (scpdUtil != null) {\n+                Util.checkAvailableChannels(thing, thingBuilder, scpdUtil, \"\", deviceType, channels);\n+                updateThing(thingBuilder.build());\n+            }\n+\n+            installPolling();\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> connectFuture = this.connectFuture;\n+        if (connectFuture != null) {\n+            connectFuture.cancel(true);\n+            this.connectFuture = null;\n+        }\n+        uninstallPolling();\n+\n+        stateCache.clear();\n+\n+        super.dispose();\n+    }\n+\n+    /**\n+     * poll remote device for channel values\n+     */\n+    private void poll() {\n+        channels.forEach((channelUID, channelConfig) -> {\n+            if (linkedChannels.contains(channelUID)) {", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4MDgyMA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499080820", "bodyText": "Might be worth it add logic here so that the thing is only updated if the channels would change.", "author": "cpmeister", "createdAt": "2020-10-02T22:53:40Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064RootHandler.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_FRITZBOX;\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_GENERIC;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.xml.soap.SOAPException;\n+import javax.xml.soap.SOAPMessage;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064RootConfiguration;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.binding.tr064.internal.phonebook.Phonebook;\n+import org.openhab.binding.tr064.internal.phonebook.PhonebookProvider;\n+import org.openhab.binding.tr064.internal.phonebook.Tr064PhonebookImpl;\n+import org.openhab.binding.tr064.internal.util.SCPDUtil;\n+import org.openhab.binding.tr064.internal.util.Util;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064RootHandler} is responsible for handling commands, which are\n+ * sent to one of the channels and update channel values\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Tr064RootHandler extends BaseBridgeHandler implements PhonebookProvider {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_GENERIC, THING_TYPE_FRITZBOX);\n+    private static final int RETRY_INTERVAL = 60;\n+    private static final Set<String> PROPERTY_ARGUMENTS = Set.of(\"NewSerialNumber\", \"NewSoftwareVersion\",\n+            \"NewModelName\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(Tr064RootHandler.class);\n+    private final HttpClient httpClient;\n+\n+    private Tr064RootConfiguration config = new Tr064RootConfiguration();\n+    private String deviceType = \"\";\n+\n+    private @Nullable SCPDUtil scpdUtil;\n+    private SOAPConnector soapConnector;\n+    private String endpointBaseURL = \"http://fritz.box:49000\";\n+\n+    private final Map<ChannelUID, Tr064ChannelConfig> channels = new HashMap<>();\n+    // caching is used to prevent excessive calls to the same action\n+    private final ExpiringCacheMap<ChannelUID, State> stateCache = new ExpiringCacheMap<>(2000);\n+    private final Set<ChannelUID> linkedChannels = ConcurrentHashMap.newKeySet();\n+    private Collection<Phonebook> phonebooks = Collections.emptyList();\n+\n+    private @Nullable ScheduledFuture<?> connectFuture;\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+    private @Nullable ScheduledFuture<?> phonebookFuture;\n+\n+    Tr064RootHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        soapConnector = new SOAPConnector(httpClient, endpointBaseURL);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"null\")\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        Tr064ChannelConfig channelConfig = channels.get(channelUID);\n+        if (channelConfig == null) {\n+            logger.trace(\"Channel {} not supported.\", channelUID);\n+            return;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            State state = stateCache.putIfAbsentAndGet(channelUID,\n+                    () -> soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n+            return;\n+        }\n+\n+        if (channelConfig.getChannelTypeDescription().getSetAction() == null) {\n+            logger.debug(\"Discarding command {} to {}, read-only channel\", command, channelUID);\n+            return;\n+        }\n+        scheduler.execute(() -> soapConnector.sendChannelCommandToDevice(channelConfig, command));\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(Tr064RootConfiguration.class);\n+        if (!config.isValid()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"At least one mandatory configuration field is empty\");\n+            return;\n+        }\n+\n+        endpointBaseURL = \"http://\" + config.host + \":49000\";\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        connectFuture = scheduler.scheduleWithFixedDelay(this::internalInitialize, 0, RETRY_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * internal thing initializer (sets SCPDUtil and connects to remote device)\n+     */\n+    private void internalInitialize() {\n+        try {\n+            scpdUtil = new SCPDUtil(httpClient, endpointBaseURL);\n+        } catch (SCPDException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"could not get device definitions from \" + config.host);\n+            return;\n+        }\n+\n+        if (establishSecureConnectionAndUpdateProperties()) {\n+            final ScheduledFuture<?> connectFuture = this.connectFuture;\n+            if (connectFuture != null) {\n+                connectFuture.cancel(false);\n+                this.connectFuture = null;\n+            }\n+\n+            // connection successful, check channels\n+            ThingBuilder thingBuilder = editThing();\n+            thingBuilder.withoutChannels(thing.getChannels());\n+            final SCPDUtil scpdUtil = this.scpdUtil;\n+            if (scpdUtil != null) {\n+                Util.checkAvailableChannels(thing, thingBuilder, scpdUtil, \"\", deviceType, channels);\n+                updateThing(thingBuilder.build());", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEzNTczNA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499135734", "bodyText": "The problem is that Channel does not implement equals, so it's difficult to check if the channels are really the same. Checking the channelUID is not enough, since the configuration could be different.", "author": "J-N-K", "createdAt": "2020-10-03T10:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4MDgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4MTI1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499081251", "bodyText": "should this be logged as debug instead?", "author": "cpmeister", "createdAt": "2020-10-02T22:55:29Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/SOAPConnector.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.util.Util.getSOAPElement;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import javax.xml.soap.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BytesContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescription;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SOAPConnector} provides communication with a remote SOAP device\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SOAPConnector {\n+    private static final int SOAP_TIMEOUT = 2000; // in ms\n+    private final Logger logger = LoggerFactory.getLogger(SOAPConnector.class);\n+    private final HttpClient httpClient;\n+    private final String endpointBaseURL;\n+    private final SOAPValueConverter soapValueConverter;\n+\n+    public SOAPConnector(HttpClient httpClient, String endpointBaseURL) {\n+        this.httpClient = httpClient;\n+        this.endpointBaseURL = endpointBaseURL;\n+        soapValueConverter = new SOAPValueConverter(httpClient);\n+    }\n+\n+    /**\n+     * prepare a SOAP request for an action request to a service\n+     *\n+     * @param service the service\n+     * @param soapAction the action to send\n+     * @param arguments arguments to send along with the request\n+     * @return a jetty Request containing the full SOAP message\n+     * @throws IOException if a problem while writing the SOAP message to the Request occurs\n+     * @throws SOAPException if a problem with creating the SOAP message occurs\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private Request prepareSOAPRequest(SCPDServiceType service, String soapAction, Map<String, String> arguments)\n+            throws IOException, SOAPException {\n+        MessageFactory messageFactory = MessageFactory.newInstance();\n+        SOAPMessage soapMessage = messageFactory.createMessage();\n+        SOAPPart soapPart = soapMessage.getSOAPPart();\n+        SOAPEnvelope envelope = soapPart.getEnvelope();\n+        envelope.setEncodingStyle(\"http://schemas.xmlsoap.org/soap/encoding/\");\n+\n+        // SOAP body\n+        SOAPBody soapBody = envelope.getBody();\n+        SOAPElement soapBodyElem = soapBody.addChildElement(soapAction, \"u\", service.getServiceType());\n+        arguments.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(argument -> {\n+            try {\n+                soapBodyElem.addChildElement(argument.getKey()).setTextContent(argument.getValue());\n+            } catch (SOAPException e) {\n+                logger.warn(\"Could not add {}:{} to SOAP Request: {}\", argument.getKey(), argument.getValue(),\n+                        e.getMessage());\n+            }\n+        });\n+\n+        // SOAP headers\n+        MimeHeaders headers = soapMessage.getMimeHeaders();\n+        headers.addHeader(\"SOAPAction\", service.getServiceType() + \"#\" + soapAction);\n+        soapMessage.saveChanges();\n+\n+        // create Request and add headers and content\n+        Request request = httpClient.newRequest(endpointBaseURL + service.getControlURL()).method(HttpMethod.POST);\n+        ((Iterator<MimeHeader>) soapMessage.getMimeHeaders().getAllHeaders())\n+                .forEachRemaining(header -> request.header(header.getName(), header.getValue()));\n+        try (final ByteArrayOutputStream os = new ByteArrayOutputStream()) {\n+            soapMessage.writeTo(os);\n+            byte[] content = os.toByteArray();\n+            request.content(new BytesContentProvider(content));\n+        }\n+\n+        return request;\n+    }\n+\n+    /**\n+     * execute a SOAP request\n+     *\n+     * @param service the service to send the action to\n+     * @param soapAction the action itself\n+     * @param arguments arguments to send along with the request\n+     * @return the SOAPMessage answer from the remote host\n+     * @throws Tr064CommunicationException if an error occurs during the request\n+     */\n+    public synchronized SOAPMessage doSOAPRequest(SCPDServiceType service, String soapAction,\n+            Map<String, String> arguments) throws Tr064CommunicationException {\n+        try {\n+            Request request = prepareSOAPRequest(service, soapAction, arguments).timeout(SOAP_TIMEOUT,\n+                    TimeUnit.MILLISECONDS);\n+            request.getContent().forEach(buffer -> logger.trace(\"Request: {}\", new String(buffer.array())));\n+\n+            ContentResponse response = request.send();\n+            if (response.getStatus() == HttpStatus.UNAUTHORIZED_401) {\n+                // retry once if authentication expired\n+                logger.trace(\"Re-Auth needed.\");\n+                httpClient.getAuthenticationStore().clearAuthenticationResults();\n+                request = prepareSOAPRequest(service, soapAction, arguments).timeout(SOAP_TIMEOUT,\n+                        TimeUnit.MILLISECONDS);\n+                response = request.send();\n+            }\n+            try (final ByteArrayInputStream is = new ByteArrayInputStream(response.getContent())) {\n+                logger.trace(\"Received response: {}\", response.getContentAsString());\n+\n+                SOAPMessage soapMessage = MessageFactory.newInstance().createMessage(null, is);\n+                if (soapMessage.getSOAPBody().hasFault()) {\n+                    String soapError = getSOAPElement(soapMessage, \"errorCode\").orElse(\"unknown\");\n+                    String soapReason = getSOAPElement(soapMessage, \"errorDescription\").orElse(\"unknown\");\n+                    String error = String.format(\"HTTP-Response-Code %d (%s), SOAP-Fault: %s (%s)\",\n+                            response.getStatus(), response.getReason(), soapError, soapReason);\n+                    throw new Tr064CommunicationException(error);\n+                }\n+                return soapMessage;\n+            }\n+        } catch (IOException | SOAPException | InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new Tr064CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * send a command to the remote device\n+     *\n+     * @param channelConfig the channel config containing all information\n+     * @param command the command to send\n+     */\n+    public void sendChannelCommandToDevice(Tr064ChannelConfig channelConfig, Command command) {\n+        soapValueConverter.getSOAPValueFromCommand(command, channelConfig.getDataType(),\n+                channelConfig.getChannelTypeDescription().getItem().getUnit()).ifPresentOrElse(value -> {\n+                    final ChannelTypeDescription channelTypeDescription = channelConfig.getChannelTypeDescription();\n+                    final SCPDServiceType service = channelConfig.getService();\n+                    logger.debug(\"Sending {} as {} to {}/{}\", command, value, service.getServiceId(),\n+                            channelTypeDescription.getSetAction().getName());\n+                    try {\n+                        Map<String, String> arguments = new HashMap<>();\n+                        if (channelTypeDescription.getSetAction().getArgument() != null) {\n+                            arguments.put(channelTypeDescription.getSetAction().getArgument(), value);\n+                        }\n+                        String parameter = channelConfig.getParameter();\n+                        if (parameter != null) {\n+                            arguments.put(\n+                                    channelConfig.getChannelTypeDescription().getGetAction().getParameter().getName(),\n+                                    parameter);\n+                        }\n+                        doSOAPRequest(service, channelTypeDescription.getSetAction().getName(), arguments);\n+                    } catch (Tr064CommunicationException e) {\n+                        logger.warn(\"Could not send command {}: {}\", command, e.getMessage());\n+                    }\n+                }, () -> logger.info(\"Could not convert {} to SOAP value\", command));\n+    }\n+\n+    /**\n+     * get a value from the remote device - updates state cache for all possible channels\n+     *\n+     * @param channelConfig the channel config containing all information\n+     * @param channelConfigMap map of all channels in the device\n+     * @param stateCache the ExpiringCacheMap for states of the device\n+     * @return the value for the requested channel\n+     */\n+    public State getChannelStateFromDevice(final Tr064ChannelConfig channelConfig,\n+            Map<ChannelUID, Tr064ChannelConfig> channelConfigMap, ExpiringCacheMap<ChannelUID, State> stateCache) {\n+        try {\n+            final SCPDActionType getAction = channelConfig.getGetAction();\n+            if (getAction == null) {\n+                // channel has no get action, return a default\n+                switch (channelConfig.getDataType()) {\n+                    case \"boolean\":\n+                        return OnOffType.OFF;\n+                    case \"string\":\n+                        return StringType.EMPTY;\n+                    default:\n+                        return UnDefType.UNDEF;\n+                }\n+            }\n+\n+            // get value(s) from remote device\n+            Map<String, String> arguments = new HashMap<>();\n+            String parameter = channelConfig.getParameter();\n+            if (parameter != null\n+                    && !channelConfig.getChannelTypeDescription().getGetAction().getParameter().isInternalOnly()) {\n+                arguments.put(channelConfig.getChannelTypeDescription().getGetAction().getParameter().getName(),\n+                        parameter);\n+            }\n+            SOAPMessage soapResponse = doSOAPRequest(channelConfig.getService(), getAction.getName(), arguments);\n+\n+            String argumentName = channelConfig.getChannelTypeDescription().getGetAction().getArgument();\n+            // find all other channels with the same action that are already in cache, so we can update them\n+            Map<ChannelUID, Tr064ChannelConfig> channelsInRequest = channelConfigMap.entrySet().stream()\n+                    .filter(map -> getAction.equals(map.getValue().getGetAction())\n+                            && stateCache.containsKey(map.getKey())\n+                            && !argumentName\n+                                    .equals(map.getValue().getChannelTypeDescription().getGetAction().getArgument()))\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            channelsInRequest\n+                    .forEach(\n+                            (channelUID,\n+                                    channelConfig1) -> soapValueConverter\n+                                            .getStateFromSOAPValue(soapResponse,\n+                                                    channelConfig1.getChannelTypeDescription().getGetAction()\n+                                                            .getArgument(),\n+                                                    channelConfig1)\n+                                            .ifPresent(state -> stateCache.putValue(channelUID, state)));\n+\n+            return soapValueConverter.getStateFromSOAPValue(soapResponse, argumentName, channelConfig)\n+                    .orElseThrow(() -> new Tr064CommunicationException(\"failed to transform '\"\n+                            + channelConfig.getChannelTypeDescription().getGetAction().getArgument() + \"'\"));\n+        } catch (Tr064CommunicationException e) {\n+            logger.info(\"Failed to get {}: {}\", channelConfig, e.getMessage());", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4MTM3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499081375", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }, () -> logger.info(\"Could not convert {} to SOAP value\", command));\n          \n          \n            \n                            }, () -> logger.debug(\"Could not convert {} to SOAP value\", command));\n          \n      \n    \n    \n  \n\nShould this also put the thing offline?", "author": "cpmeister", "createdAt": "2020-10-02T22:56:00Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/SOAPConnector.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.util.Util.getSOAPElement;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import javax.xml.soap.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BytesContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescription;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SOAPConnector} provides communication with a remote SOAP device\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SOAPConnector {\n+    private static final int SOAP_TIMEOUT = 2000; // in ms\n+    private final Logger logger = LoggerFactory.getLogger(SOAPConnector.class);\n+    private final HttpClient httpClient;\n+    private final String endpointBaseURL;\n+    private final SOAPValueConverter soapValueConverter;\n+\n+    public SOAPConnector(HttpClient httpClient, String endpointBaseURL) {\n+        this.httpClient = httpClient;\n+        this.endpointBaseURL = endpointBaseURL;\n+        soapValueConverter = new SOAPValueConverter(httpClient);\n+    }\n+\n+    /**\n+     * prepare a SOAP request for an action request to a service\n+     *\n+     * @param service the service\n+     * @param soapAction the action to send\n+     * @param arguments arguments to send along with the request\n+     * @return a jetty Request containing the full SOAP message\n+     * @throws IOException if a problem while writing the SOAP message to the Request occurs\n+     * @throws SOAPException if a problem with creating the SOAP message occurs\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private Request prepareSOAPRequest(SCPDServiceType service, String soapAction, Map<String, String> arguments)\n+            throws IOException, SOAPException {\n+        MessageFactory messageFactory = MessageFactory.newInstance();\n+        SOAPMessage soapMessage = messageFactory.createMessage();\n+        SOAPPart soapPart = soapMessage.getSOAPPart();\n+        SOAPEnvelope envelope = soapPart.getEnvelope();\n+        envelope.setEncodingStyle(\"http://schemas.xmlsoap.org/soap/encoding/\");\n+\n+        // SOAP body\n+        SOAPBody soapBody = envelope.getBody();\n+        SOAPElement soapBodyElem = soapBody.addChildElement(soapAction, \"u\", service.getServiceType());\n+        arguments.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(argument -> {\n+            try {\n+                soapBodyElem.addChildElement(argument.getKey()).setTextContent(argument.getValue());\n+            } catch (SOAPException e) {\n+                logger.warn(\"Could not add {}:{} to SOAP Request: {}\", argument.getKey(), argument.getValue(),\n+                        e.getMessage());\n+            }\n+        });\n+\n+        // SOAP headers\n+        MimeHeaders headers = soapMessage.getMimeHeaders();\n+        headers.addHeader(\"SOAPAction\", service.getServiceType() + \"#\" + soapAction);\n+        soapMessage.saveChanges();\n+\n+        // create Request and add headers and content\n+        Request request = httpClient.newRequest(endpointBaseURL + service.getControlURL()).method(HttpMethod.POST);\n+        ((Iterator<MimeHeader>) soapMessage.getMimeHeaders().getAllHeaders())\n+                .forEachRemaining(header -> request.header(header.getName(), header.getValue()));\n+        try (final ByteArrayOutputStream os = new ByteArrayOutputStream()) {\n+            soapMessage.writeTo(os);\n+            byte[] content = os.toByteArray();\n+            request.content(new BytesContentProvider(content));\n+        }\n+\n+        return request;\n+    }\n+\n+    /**\n+     * execute a SOAP request\n+     *\n+     * @param service the service to send the action to\n+     * @param soapAction the action itself\n+     * @param arguments arguments to send along with the request\n+     * @return the SOAPMessage answer from the remote host\n+     * @throws Tr064CommunicationException if an error occurs during the request\n+     */\n+    public synchronized SOAPMessage doSOAPRequest(SCPDServiceType service, String soapAction,\n+            Map<String, String> arguments) throws Tr064CommunicationException {\n+        try {\n+            Request request = prepareSOAPRequest(service, soapAction, arguments).timeout(SOAP_TIMEOUT,\n+                    TimeUnit.MILLISECONDS);\n+            request.getContent().forEach(buffer -> logger.trace(\"Request: {}\", new String(buffer.array())));\n+\n+            ContentResponse response = request.send();\n+            if (response.getStatus() == HttpStatus.UNAUTHORIZED_401) {\n+                // retry once if authentication expired\n+                logger.trace(\"Re-Auth needed.\");\n+                httpClient.getAuthenticationStore().clearAuthenticationResults();\n+                request = prepareSOAPRequest(service, soapAction, arguments).timeout(SOAP_TIMEOUT,\n+                        TimeUnit.MILLISECONDS);\n+                response = request.send();\n+            }\n+            try (final ByteArrayInputStream is = new ByteArrayInputStream(response.getContent())) {\n+                logger.trace(\"Received response: {}\", response.getContentAsString());\n+\n+                SOAPMessage soapMessage = MessageFactory.newInstance().createMessage(null, is);\n+                if (soapMessage.getSOAPBody().hasFault()) {\n+                    String soapError = getSOAPElement(soapMessage, \"errorCode\").orElse(\"unknown\");\n+                    String soapReason = getSOAPElement(soapMessage, \"errorDescription\").orElse(\"unknown\");\n+                    String error = String.format(\"HTTP-Response-Code %d (%s), SOAP-Fault: %s (%s)\",\n+                            response.getStatus(), response.getReason(), soapError, soapReason);\n+                    throw new Tr064CommunicationException(error);\n+                }\n+                return soapMessage;\n+            }\n+        } catch (IOException | SOAPException | InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new Tr064CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * send a command to the remote device\n+     *\n+     * @param channelConfig the channel config containing all information\n+     * @param command the command to send\n+     */\n+    public void sendChannelCommandToDevice(Tr064ChannelConfig channelConfig, Command command) {\n+        soapValueConverter.getSOAPValueFromCommand(command, channelConfig.getDataType(),\n+                channelConfig.getChannelTypeDescription().getItem().getUnit()).ifPresentOrElse(value -> {\n+                    final ChannelTypeDescription channelTypeDescription = channelConfig.getChannelTypeDescription();\n+                    final SCPDServiceType service = channelConfig.getService();\n+                    logger.debug(\"Sending {} as {} to {}/{}\", command, value, service.getServiceId(),\n+                            channelTypeDescription.getSetAction().getName());\n+                    try {\n+                        Map<String, String> arguments = new HashMap<>();\n+                        if (channelTypeDescription.getSetAction().getArgument() != null) {\n+                            arguments.put(channelTypeDescription.getSetAction().getArgument(), value);\n+                        }\n+                        String parameter = channelConfig.getParameter();\n+                        if (parameter != null) {\n+                            arguments.put(\n+                                    channelConfig.getChannelTypeDescription().getGetAction().getParameter().getName(),\n+                                    parameter);\n+                        }\n+                        doSOAPRequest(service, channelTypeDescription.getSetAction().getName(), arguments);\n+                    } catch (Tr064CommunicationException e) {\n+                        logger.warn(\"Could not send command {}: {}\", command, e.getMessage());\n+                    }\n+                }, () -> logger.info(\"Could not convert {} to SOAP value\", command));", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEyNzM1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499127357", "bodyText": "See above: this should not happen during normal opertaion and indicates a fault. it is more likely warn than debug.", "author": "J-N-K", "createdAt": "2020-10-03T08:10:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4MTM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4MTUyMA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499081520", "bodyText": "Should this put the thing offline?", "author": "cpmeister", "createdAt": "2020-10-02T22:56:20Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/SOAPConnector.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.util.Util.getSOAPElement;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import javax.xml.soap.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BytesContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescription;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SOAPConnector} provides communication with a remote SOAP device\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SOAPConnector {\n+    private static final int SOAP_TIMEOUT = 2000; // in ms\n+    private final Logger logger = LoggerFactory.getLogger(SOAPConnector.class);\n+    private final HttpClient httpClient;\n+    private final String endpointBaseURL;\n+    private final SOAPValueConverter soapValueConverter;\n+\n+    public SOAPConnector(HttpClient httpClient, String endpointBaseURL) {\n+        this.httpClient = httpClient;\n+        this.endpointBaseURL = endpointBaseURL;\n+        soapValueConverter = new SOAPValueConverter(httpClient);\n+    }\n+\n+    /**\n+     * prepare a SOAP request for an action request to a service\n+     *\n+     * @param service the service\n+     * @param soapAction the action to send\n+     * @param arguments arguments to send along with the request\n+     * @return a jetty Request containing the full SOAP message\n+     * @throws IOException if a problem while writing the SOAP message to the Request occurs\n+     * @throws SOAPException if a problem with creating the SOAP message occurs\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private Request prepareSOAPRequest(SCPDServiceType service, String soapAction, Map<String, String> arguments)\n+            throws IOException, SOAPException {\n+        MessageFactory messageFactory = MessageFactory.newInstance();\n+        SOAPMessage soapMessage = messageFactory.createMessage();\n+        SOAPPart soapPart = soapMessage.getSOAPPart();\n+        SOAPEnvelope envelope = soapPart.getEnvelope();\n+        envelope.setEncodingStyle(\"http://schemas.xmlsoap.org/soap/encoding/\");\n+\n+        // SOAP body\n+        SOAPBody soapBody = envelope.getBody();\n+        SOAPElement soapBodyElem = soapBody.addChildElement(soapAction, \"u\", service.getServiceType());\n+        arguments.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(argument -> {\n+            try {\n+                soapBodyElem.addChildElement(argument.getKey()).setTextContent(argument.getValue());\n+            } catch (SOAPException e) {\n+                logger.warn(\"Could not add {}:{} to SOAP Request: {}\", argument.getKey(), argument.getValue(),\n+                        e.getMessage());\n+            }\n+        });\n+\n+        // SOAP headers\n+        MimeHeaders headers = soapMessage.getMimeHeaders();\n+        headers.addHeader(\"SOAPAction\", service.getServiceType() + \"#\" + soapAction);\n+        soapMessage.saveChanges();\n+\n+        // create Request and add headers and content\n+        Request request = httpClient.newRequest(endpointBaseURL + service.getControlURL()).method(HttpMethod.POST);\n+        ((Iterator<MimeHeader>) soapMessage.getMimeHeaders().getAllHeaders())\n+                .forEachRemaining(header -> request.header(header.getName(), header.getValue()));\n+        try (final ByteArrayOutputStream os = new ByteArrayOutputStream()) {\n+            soapMessage.writeTo(os);\n+            byte[] content = os.toByteArray();\n+            request.content(new BytesContentProvider(content));\n+        }\n+\n+        return request;\n+    }\n+\n+    /**\n+     * execute a SOAP request\n+     *\n+     * @param service the service to send the action to\n+     * @param soapAction the action itself\n+     * @param arguments arguments to send along with the request\n+     * @return the SOAPMessage answer from the remote host\n+     * @throws Tr064CommunicationException if an error occurs during the request\n+     */\n+    public synchronized SOAPMessage doSOAPRequest(SCPDServiceType service, String soapAction,\n+            Map<String, String> arguments) throws Tr064CommunicationException {\n+        try {\n+            Request request = prepareSOAPRequest(service, soapAction, arguments).timeout(SOAP_TIMEOUT,\n+                    TimeUnit.MILLISECONDS);\n+            request.getContent().forEach(buffer -> logger.trace(\"Request: {}\", new String(buffer.array())));\n+\n+            ContentResponse response = request.send();\n+            if (response.getStatus() == HttpStatus.UNAUTHORIZED_401) {\n+                // retry once if authentication expired\n+                logger.trace(\"Re-Auth needed.\");\n+                httpClient.getAuthenticationStore().clearAuthenticationResults();\n+                request = prepareSOAPRequest(service, soapAction, arguments).timeout(SOAP_TIMEOUT,\n+                        TimeUnit.MILLISECONDS);\n+                response = request.send();\n+            }\n+            try (final ByteArrayInputStream is = new ByteArrayInputStream(response.getContent())) {\n+                logger.trace(\"Received response: {}\", response.getContentAsString());\n+\n+                SOAPMessage soapMessage = MessageFactory.newInstance().createMessage(null, is);\n+                if (soapMessage.getSOAPBody().hasFault()) {\n+                    String soapError = getSOAPElement(soapMessage, \"errorCode\").orElse(\"unknown\");\n+                    String soapReason = getSOAPElement(soapMessage, \"errorDescription\").orElse(\"unknown\");\n+                    String error = String.format(\"HTTP-Response-Code %d (%s), SOAP-Fault: %s (%s)\",\n+                            response.getStatus(), response.getReason(), soapError, soapReason);\n+                    throw new Tr064CommunicationException(error);\n+                }\n+                return soapMessage;\n+            }\n+        } catch (IOException | SOAPException | InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new Tr064CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * send a command to the remote device\n+     *\n+     * @param channelConfig the channel config containing all information\n+     * @param command the command to send\n+     */\n+    public void sendChannelCommandToDevice(Tr064ChannelConfig channelConfig, Command command) {\n+        soapValueConverter.getSOAPValueFromCommand(command, channelConfig.getDataType(),\n+                channelConfig.getChannelTypeDescription().getItem().getUnit()).ifPresentOrElse(value -> {\n+                    final ChannelTypeDescription channelTypeDescription = channelConfig.getChannelTypeDescription();\n+                    final SCPDServiceType service = channelConfig.getService();\n+                    logger.debug(\"Sending {} as {} to {}/{}\", command, value, service.getServiceId(),\n+                            channelTypeDescription.getSetAction().getName());\n+                    try {\n+                        Map<String, String> arguments = new HashMap<>();\n+                        if (channelTypeDescription.getSetAction().getArgument() != null) {\n+                            arguments.put(channelTypeDescription.getSetAction().getArgument(), value);\n+                        }\n+                        String parameter = channelConfig.getParameter();\n+                        if (parameter != null) {\n+                            arguments.put(\n+                                    channelConfig.getChannelTypeDescription().getGetAction().getParameter().getName(),\n+                                    parameter);\n+                        }\n+                        doSOAPRequest(service, channelTypeDescription.getSetAction().getName(), arguments);\n+                    } catch (Tr064CommunicationException e) {\n+                        logger.warn(\"Could not send command {}: {}\", command, e.getMessage());", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4MTc1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499081753", "bodyText": "Just to be consistent.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    soapValueConverter = new SOAPValueConverter(httpClient);\n          \n          \n            \n                    this.soapValueConverter = new SOAPValueConverter(httpClient);", "author": "cpmeister", "createdAt": "2020-10-02T22:57:17Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/SOAPConnector.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.util.Util.getSOAPElement;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import javax.xml.soap.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BytesContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescription;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SOAPConnector} provides communication with a remote SOAP device\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SOAPConnector {\n+    private static final int SOAP_TIMEOUT = 2000; // in ms\n+    private final Logger logger = LoggerFactory.getLogger(SOAPConnector.class);\n+    private final HttpClient httpClient;\n+    private final String endpointBaseURL;\n+    private final SOAPValueConverter soapValueConverter;\n+\n+    public SOAPConnector(HttpClient httpClient, String endpointBaseURL) {\n+        this.httpClient = httpClient;\n+        this.endpointBaseURL = endpointBaseURL;\n+        soapValueConverter = new SOAPValueConverter(httpClient);", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4Njc4OA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499086788", "bodyText": "I wonder if it is worth it to make utility methods for these frequently used name lookups...\nprivate Function<SCPDActionType, Optional<SCPDArgumentType> getArgument(String argumentName, String direction){\n    return (action) -> action.getArgumentList().stream()\n                                        .filter(argument -> argument.getName().equals(argumentName)\n                                                && argument.getDirection().equals(direction))\n                                        .findFirst();\n}\n\nprivate Function<SCPDServiceType,  Optional<SCPDActionType>> getAction(String actionName){\n    return (service) -> service.getActionList().stream().filter(action -> action.getName().equals(actionName)).findFirst();\n}\n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            SCPDActionType getInfoAction = scpdUtil.getService(deviceService.getServiceId())\n          \n          \n            \n                                    .orElseThrow(() -> new SCPDException(\n          \n          \n            \n                                            \"Could not get service definition for 'urn:DeviceInfo-com:serviceId:DeviceInfo1'\"))\n          \n          \n            \n                                    .getActionList().stream().filter(action -> action.getName().equals(\"GetInfo\")).findFirst()\n          \n          \n            \n                                    .orElseThrow(() -> new SCPDException(\"Action 'GetInfo' not found\"));\n          \n          \n            \n                            SCPDActionType getInfoAction = scpdUtil.getService(deviceService.getServiceId())\n          \n          \n            \n                                    .orElseThrow(() -> new SCPDException(\n          \n          \n            \n                                            \"Could not get service definition for 'urn:DeviceInfo-com:serviceId:DeviceInfo1'\"))\n          \n          \n            \n                                    .flatMap(getAction(\"GetInfo\"))\n          \n          \n            \n                                    .orElseThrow(() -> new SCPDException(\"Action 'GetInfo' not found\"));", "author": "cpmeister", "createdAt": "2020-10-02T23:23:05Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064RootHandler.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_FRITZBOX;\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_GENERIC;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.xml.soap.SOAPException;\n+import javax.xml.soap.SOAPMessage;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064RootConfiguration;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.binding.tr064.internal.phonebook.Phonebook;\n+import org.openhab.binding.tr064.internal.phonebook.PhonebookProvider;\n+import org.openhab.binding.tr064.internal.phonebook.Tr064PhonebookImpl;\n+import org.openhab.binding.tr064.internal.util.SCPDUtil;\n+import org.openhab.binding.tr064.internal.util.Util;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064RootHandler} is responsible for handling commands, which are\n+ * sent to one of the channels and update channel values\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Tr064RootHandler extends BaseBridgeHandler implements PhonebookProvider {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_GENERIC, THING_TYPE_FRITZBOX);\n+    private static final int RETRY_INTERVAL = 60;\n+    private static final Set<String> PROPERTY_ARGUMENTS = Set.of(\"NewSerialNumber\", \"NewSoftwareVersion\",\n+            \"NewModelName\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(Tr064RootHandler.class);\n+    private final HttpClient httpClient;\n+\n+    private Tr064RootConfiguration config = new Tr064RootConfiguration();\n+    private String deviceType = \"\";\n+\n+    private @Nullable SCPDUtil scpdUtil;\n+    private SOAPConnector soapConnector;\n+    private String endpointBaseURL = \"http://fritz.box:49000\";\n+\n+    private final Map<ChannelUID, Tr064ChannelConfig> channels = new HashMap<>();\n+    // caching is used to prevent excessive calls to the same action\n+    private final ExpiringCacheMap<ChannelUID, State> stateCache = new ExpiringCacheMap<>(2000);\n+    private final Set<ChannelUID> linkedChannels = ConcurrentHashMap.newKeySet();\n+    private Collection<Phonebook> phonebooks = Collections.emptyList();\n+\n+    private @Nullable ScheduledFuture<?> connectFuture;\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+    private @Nullable ScheduledFuture<?> phonebookFuture;\n+\n+    Tr064RootHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        soapConnector = new SOAPConnector(httpClient, endpointBaseURL);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"null\")\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        Tr064ChannelConfig channelConfig = channels.get(channelUID);\n+        if (channelConfig == null) {\n+            logger.trace(\"Channel {} not supported.\", channelUID);\n+            return;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            State state = stateCache.putIfAbsentAndGet(channelUID,\n+                    () -> soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n+            return;\n+        }\n+\n+        if (channelConfig.getChannelTypeDescription().getSetAction() == null) {\n+            logger.debug(\"Discarding command {} to {}, read-only channel\", command, channelUID);\n+            return;\n+        }\n+        scheduler.execute(() -> soapConnector.sendChannelCommandToDevice(channelConfig, command));\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(Tr064RootConfiguration.class);\n+        if (!config.isValid()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"At least one mandatory configuration field is empty\");\n+            return;\n+        }\n+\n+        endpointBaseURL = \"http://\" + config.host + \":49000\";\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        connectFuture = scheduler.scheduleWithFixedDelay(this::internalInitialize, 0, RETRY_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * internal thing initializer (sets SCPDUtil and connects to remote device)\n+     */\n+    private void internalInitialize() {\n+        try {\n+            scpdUtil = new SCPDUtil(httpClient, endpointBaseURL);\n+        } catch (SCPDException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"could not get device definitions from \" + config.host);\n+            return;\n+        }\n+\n+        if (establishSecureConnectionAndUpdateProperties()) {\n+            final ScheduledFuture<?> connectFuture = this.connectFuture;\n+            if (connectFuture != null) {\n+                connectFuture.cancel(false);\n+                this.connectFuture = null;\n+            }\n+\n+            // connection successful, check channels\n+            ThingBuilder thingBuilder = editThing();\n+            thingBuilder.withoutChannels(thing.getChannels());\n+            final SCPDUtil scpdUtil = this.scpdUtil;\n+            if (scpdUtil != null) {\n+                Util.checkAvailableChannels(thing, thingBuilder, scpdUtil, \"\", deviceType, channels);\n+                updateThing(thingBuilder.build());\n+            }\n+\n+            installPolling();\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> connectFuture = this.connectFuture;\n+        if (connectFuture != null) {\n+            connectFuture.cancel(true);\n+            this.connectFuture = null;\n+        }\n+        uninstallPolling();\n+\n+        stateCache.clear();\n+\n+        super.dispose();\n+    }\n+\n+    /**\n+     * poll remote device for channel values\n+     */\n+    private void poll() {\n+        channels.forEach((channelUID, channelConfig) -> {\n+            if (linkedChannels.contains(channelUID)) {\n+                State state = stateCache.putIfAbsentAndGet(channelUID,\n+                        () -> soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+                if (state != null) {\n+                    updateState(channelUID, state);\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * establish the connection - get secure port (if avallable), install authentication, get device properties\n+     *\n+     * @return true if successful\n+     */\n+    private boolean establishSecureConnectionAndUpdateProperties() {\n+        final SCPDUtil scpdUtil = this.scpdUtil;\n+        if (scpdUtil != null) {\n+            try {\n+                SCPDDeviceType device = scpdUtil.getDevice(\"\")\n+                        .orElseThrow(() -> new SCPDException(\"Root device not found\"));\n+                SCPDServiceType deviceService = device.getServiceList().stream()\n+                        .filter(service -> service.getServiceId().equals(\"urn:DeviceInfo-com:serviceId:DeviceInfo1\"))\n+                        .findFirst().orElseThrow(() -> new SCPDException(\n+                                \"service 'urn:DeviceInfo-com:serviceId:DeviceInfo1' not found\"));\n+\n+                this.deviceType = device.getDeviceType();\n+\n+                // try to get security (https) port\n+                SOAPMessage soapResponse = soapConnector.doSOAPRequest(deviceService, \"GetSecurityPort\",\n+                        Collections.emptyMap());\n+                if (!soapResponse.getSOAPBody().hasFault()) {\n+                    SOAPValueConverter soapValueConverter = new SOAPValueConverter(httpClient);\n+                    soapValueConverter.getStateFromSOAPValue(soapResponse, \"NewSecurityPort\", null)\n+                            .ifPresentOrElse(port -> {\n+                                endpointBaseURL = \"https://\" + config.host + \":\" + port.toString();\n+                                soapConnector = new SOAPConnector(httpClient, endpointBaseURL);\n+                                logger.debug(\"endpointBaseURL is now '{}'\", endpointBaseURL);\n+                            }, () -> logger.warn(\"Could not determine secure port, disabling https\"));\n+                } else {\n+                    logger.warn(\"Could not determine secure port, disabling https\");\n+                }\n+\n+                // clear auth cache and force re-auth\n+                httpClient.getAuthenticationStore().clearAuthenticationResults();\n+                AuthenticationStore auth = httpClient.getAuthenticationStore();\n+                auth.addAuthentication(new DigestAuthentication(new URI(endpointBaseURL), Authentication.ANY_REALM,\n+                        config.user, config.password));\n+\n+                // check & update properties\n+                SCPDActionType getInfoAction = scpdUtil.getService(deviceService.getServiceId())\n+                        .orElseThrow(() -> new SCPDException(\n+                                \"Could not get service definition for 'urn:DeviceInfo-com:serviceId:DeviceInfo1'\"))\n+                        .getActionList().stream().filter(action -> action.getName().equals(\"GetInfo\")).findFirst()\n+                        .orElseThrow(() -> new SCPDException(\"Action 'GetInfo' not found\"));", "originalCommit": "49edb5c5d42bdd496e1d5952d63387e103402762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEyOTc0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499129749", "bodyText": "Where do you see a benefit here? It's only used in this place AFAIK.", "author": "J-N-K", "createdAt": "2020-10-03T08:49:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4Njc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2MTEwMA==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499161100", "bodyText": "It is used in several places in the Util class. But frankly I'm not sure my suggestion provides enough benefit to be worth the time to do it anyway.", "author": "cpmeister", "createdAt": "2020-10-03T16:19:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA4Njc4OA=="}], "type": "inlineReview"}, {"oid": "28368f9b4932845750ff83e34fcc3bdb38495521", "url": "https://github.com/openhab/openhab-addons/commit/28368f9b4932845750ff83e34fcc3bdb38495521", "message": "refactor phonebook retrieval\n\nSigned-off-by: Jan N. Klug <jan.n.klug@rub.de>", "committedDate": "2020-10-03T14:54:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2MDMzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499160339", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    .withRepresentationProperty(device.getUDN()).build();\n          \n          \n            \n                                    .withRepresentationProperty(\"uuid\").build();", "author": "cpmeister", "createdAt": "2020-10-03T16:09:59Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064DiscoveryService.java", "diffHunk": "@@ -96,7 +96,8 @@ public void startScan() {\n                 properties.put(\"deviceType\", device.getDeviceType());\n \n                 DiscoveryResult result = DiscoveryResultBuilder.create(thingUID).withLabel(device.getFriendlyName())\n-                        .withBridge(bridgeHandler.getThing().getUID()).withProperties(properties).build();\n+                        .withBridge(bridgeHandler.getThing().getUID()).withProperties(properties)\n+                        .withRepresentationProperty(device.getUDN()).build();", "originalCommit": "04fc473ab4bdc70c55e8c6ab5fa7df2d764fd4f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4Njc4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499186783", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        .concat(org.openhab.binding.tr064.internal.Tr064RootHandler.SUPPORTED_THING_TYPES.stream(),\n          \n          \n            \n                        .concat(Tr064RootHandler.SUPPORTED_THING_TYPES.stream(),", "author": "cpmeister", "createdAt": "2020-10-03T22:25:10Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064HandlerFactory.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.tr064.internal.phonebook.PhonebookProfileFactory;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link Tr064HandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { ThingHandlerFactory.class }, configurationPid = \"binding.tr064\")\n+public class Tr064HandlerFactory extends BaseThingHandlerFactory {\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Stream\n+            .concat(org.openhab.binding.tr064.internal.Tr064RootHandler.SUPPORTED_THING_TYPES.stream(),", "originalCommit": "21a2e416f1c764f6e493523622d354373d4ab1e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4Nzc3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499187773", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        final ScheduledFuture<?> connectFuture = this.connectFuture;\n          \n          \n            \n                        if (connectFuture != null) {\n          \n          \n            \n                            connectFuture.cancel(true);\n          \n          \n            \n                            this.connectFuture = null;\n          \n          \n            \n                        }\n          \n          \n            \n                        removeConnectScheduler();", "author": "cpmeister", "createdAt": "2020-10-03T22:43:32Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064SubHandler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE;\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_SUBDEVICE_LAN;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064SubConfiguration;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.binding.tr064.internal.util.SCPDUtil;\n+import org.openhab.binding.tr064.internal.util.Util;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064SubHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Tr064SubHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_SUBDEVICE,\n+            THING_TYPE_SUBDEVICE_LAN);\n+    private static final int RETRY_INTERVAL = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(Tr064SubHandler.class);\n+\n+    private Tr064SubConfiguration config = new Tr064SubConfiguration();\n+\n+    private String deviceType = \"\";\n+    private boolean isInitialized = false;\n+\n+    private final Map<ChannelUID, Tr064ChannelConfig> channels = new HashMap<>();\n+    // caching is used to prevent excessive calls to the same action\n+    private final ExpiringCacheMap<ChannelUID, State> stateCache = new ExpiringCacheMap<>(2000);\n+\n+    private @Nullable SOAPConnector soapConnector;\n+    private @Nullable ScheduledFuture<?> connectFuture;\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+\n+    Tr064SubHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"null\")\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        Tr064ChannelConfig channelConfig = channels.get(channelUID);\n+        if (channelConfig == null) {\n+            logger.trace(\"Channel {} not supported.\", channelUID);\n+            return;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            State state = stateCache.putIfAbsentAndGet(channelUID, () -> soapConnector == null ? UnDefType.UNDEF\n+                    : soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n+            return;\n+        }\n+\n+        if (channelConfig.getChannelTypeDescription().getSetAction() == null) {\n+            logger.debug(\"Discarding command {} to {}, read-only channel\", command, channelUID);\n+            return;\n+        }\n+        scheduler.execute(() -> {\n+            if (soapConnector == null) {\n+                logger.warn(\"Could not send command because connector not available\");\n+            } else {\n+                soapConnector.sendChannelCommandToDevice(channelConfig, command);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(Tr064SubConfiguration.class);\n+        if (!config.isValid()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"One or more mandatory configuration fields are empty\");\n+            return;\n+        }\n+\n+        final Bridge bridge = getBridge();\n+        if (bridge != null && bridge.getStatus().equals(ThingStatus.ONLINE)) {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            connectFuture = scheduler.scheduleWithFixedDelay(this::internalInitialize, 0, 30, TimeUnit.SECONDS);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        }\n+    }\n+\n+    private void internalInitialize() {\n+        final Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            return;\n+        }\n+        final Tr064RootHandler bridgeHandler = (Tr064RootHandler) bridge.getHandler();\n+        if (bridgeHandler == null) {\n+            logger.warn(\"Bridge-handler is null in thing {}\", thing.getUID());\n+            return;\n+        }\n+        final SCPDUtil scpdUtil = bridgeHandler.getSCPDUtil();\n+        if (scpdUtil == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not get device definitions\");\n+            return;\n+        }\n+\n+        if (checkProperties(scpdUtil)) {\n+            // properties set, check channels\n+            ThingBuilder thingBuilder = editThing();\n+            thingBuilder.withoutChannels(thing.getChannels());\n+            Util.checkAvailableChannels(thing, thingBuilder, scpdUtil, config.uuid, deviceType, channels);\n+            updateThing(thingBuilder.build());\n+\n+            // remove connect scheduler\n+            removeConnectScheduler();\n+            soapConnector = bridgeHandler.getSOAPConnector();\n+\n+            isInitialized = true;\n+            installPolling();\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+        }\n+    }\n+\n+    private void removeConnectScheduler() {\n+        final ScheduledFuture<?> connectFuture = this.connectFuture;\n+        if (connectFuture != null) {\n+            connectFuture.cancel(true);\n+            this.connectFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        removeConnectScheduler();\n+        uninstallPolling();\n+\n+        stateCache.clear();\n+        isInitialized = false;\n+\n+        super.dispose();\n+    }\n+\n+    /**\n+     * poll remote device for channel values\n+     */\n+    private void poll() {\n+        channels.forEach((channelUID, channelConfig) -> {\n+            if (isLinked(channelUID)) {\n+                State state = stateCache.putIfAbsentAndGet(channelUID, () -> soapConnector == null ? UnDefType.UNDEF\n+                        : soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+                if (state != null) {\n+                    updateState(channelUID, state);\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * get device properties from remote device\n+     *\n+     * @param scpdUtil the SCPD util of this device\n+     * @return true if successfull\n+     */\n+    private boolean checkProperties(SCPDUtil scpdUtil) {\n+        try {\n+            SCPDDeviceType device = scpdUtil.getDevice(config.uuid)\n+                    .orElseThrow(() -> new SCPDException(\"Could not find device \" + config.uuid));\n+            String deviceType = device.getDeviceType();\n+            if (deviceType == null) {\n+                throw new SCPDException(\"deviceType can't be null \");\n+            }\n+            this.deviceType = deviceType;\n+\n+            Map<String, String> properties = editProperties();\n+            properties.put(\"deviceType\", deviceType);\n+            updateProperties(properties);\n+\n+            return true;\n+        } catch (SCPDException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Failed to update device properties: \" + e.getMessage());\n+\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (!bridgeStatusInfo.getStatus().equals(ThingStatus.ONLINE)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            final ScheduledFuture<?> connectFuture = this.connectFuture;\n+            if (connectFuture != null) {\n+                connectFuture.cancel(true);\n+                this.connectFuture = null;\n+            }", "originalCommit": "21a2e416f1c764f6e493523622d354373d4ab1e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4NzkyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499187922", "bodyText": "refactor this into its own method. Same as what was done in Tr064SubHandler.", "author": "cpmeister", "createdAt": "2020-10-03T22:46:14Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064RootHandler.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_FRITZBOX;\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.THING_TYPE_GENERIC;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.*;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.xml.soap.SOAPException;\n+import javax.xml.soap.SOAPMessage;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064RootConfiguration;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.binding.tr064.internal.phonebook.Phonebook;\n+import org.openhab.binding.tr064.internal.phonebook.PhonebookProvider;\n+import org.openhab.binding.tr064.internal.phonebook.Tr064PhonebookImpl;\n+import org.openhab.binding.tr064.internal.util.SCPDUtil;\n+import org.openhab.binding.tr064.internal.util.Util;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Tr064RootHandler} is responsible for handling commands, which are\n+ * sent to one of the channels and update channel values\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Tr064RootHandler extends BaseBridgeHandler implements PhonebookProvider {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_GENERIC, THING_TYPE_FRITZBOX);\n+    private static final int RETRY_INTERVAL = 60;\n+    private static final Set<String> PROPERTY_ARGUMENTS = Set.of(\"NewSerialNumber\", \"NewSoftwareVersion\",\n+            \"NewModelName\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(Tr064RootHandler.class);\n+    private final HttpClient httpClient;\n+\n+    private Tr064RootConfiguration config = new Tr064RootConfiguration();\n+    private String deviceType = \"\";\n+\n+    private @Nullable SCPDUtil scpdUtil;\n+    private SOAPConnector soapConnector;\n+    private String endpointBaseURL = \"http://fritz.box:49000\";\n+\n+    private final Map<ChannelUID, Tr064ChannelConfig> channels = new HashMap<>();\n+    // caching is used to prevent excessive calls to the same action\n+    private final ExpiringCacheMap<ChannelUID, State> stateCache = new ExpiringCacheMap<>(2000);\n+    private Collection<Phonebook> phonebooks = Collections.emptyList();\n+\n+    private @Nullable ScheduledFuture<?> connectFuture;\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+    private @Nullable ScheduledFuture<?> phonebookFuture;\n+\n+    Tr064RootHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        soapConnector = new SOAPConnector(httpClient, endpointBaseURL);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"null\")\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        Tr064ChannelConfig channelConfig = channels.get(channelUID);\n+        if (channelConfig == null) {\n+            logger.trace(\"Channel {} not supported.\", channelUID);\n+            return;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            State state = stateCache.putIfAbsentAndGet(channelUID,\n+                    () -> soapConnector.getChannelStateFromDevice(channelConfig, channels, stateCache));\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n+            return;\n+        }\n+\n+        if (channelConfig.getChannelTypeDescription().getSetAction() == null) {\n+            logger.debug(\"Discarding command {} to {}, read-only channel\", command, channelUID);\n+            return;\n+        }\n+        scheduler.execute(() -> soapConnector.sendChannelCommandToDevice(channelConfig, command));\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(Tr064RootConfiguration.class);\n+        if (!config.isValid()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"At least one mandatory configuration field is empty\");\n+            return;\n+        }\n+\n+        endpointBaseURL = \"http://\" + config.host + \":49000\";\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        connectFuture = scheduler.scheduleWithFixedDelay(this::internalInitialize, 0, RETRY_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * internal thing initializer (sets SCPDUtil and connects to remote device)\n+     */\n+    private void internalInitialize() {\n+        try {\n+            scpdUtil = new SCPDUtil(httpClient, endpointBaseURL);\n+        } catch (SCPDException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"could not get device definitions from \" + config.host);\n+            return;\n+        }\n+\n+        if (establishSecureConnectionAndUpdateProperties()) {\n+            final ScheduledFuture<?> connectFuture = this.connectFuture;\n+            if (connectFuture != null) {\n+                connectFuture.cancel(false);\n+                this.connectFuture = null;\n+            }\n+\n+            // connection successful, check channels\n+            ThingBuilder thingBuilder = editThing();\n+            thingBuilder.withoutChannels(thing.getChannels());\n+            final SCPDUtil scpdUtil = this.scpdUtil;\n+            if (scpdUtil != null) {\n+                Util.checkAvailableChannels(thing, thingBuilder, scpdUtil, \"\", deviceType, channels);\n+                updateThing(thingBuilder.build());\n+            }\n+\n+            installPolling();\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> connectFuture = this.connectFuture;\n+        if (connectFuture != null) {\n+            connectFuture.cancel(true);\n+            this.connectFuture = null;\n+        }", "originalCommit": "21a2e416f1c764f6e493523622d354373d4ab1e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4ODQyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r499188421", "bodyText": "This forEach is only used for logging. Wrap all this with a isTraceEnabled check.", "author": "cpmeister", "createdAt": "2020-10-03T22:56:09Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/SOAPConnector.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import static org.openhab.binding.tr064.internal.util.Util.getSOAPElement;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import javax.xml.soap.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BytesContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.dto.config.ActionType;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescription;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDActionType;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SOAPConnector} provides communication with a remote SOAP device\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SOAPConnector {\n+    private static final int SOAP_TIMEOUT = 2000; // in ms\n+    private final Logger logger = LoggerFactory.getLogger(SOAPConnector.class);\n+    private final HttpClient httpClient;\n+    private final String endpointBaseURL;\n+    private final SOAPValueConverter soapValueConverter;\n+\n+    public SOAPConnector(HttpClient httpClient, String endpointBaseURL) {\n+        this.httpClient = httpClient;\n+        this.endpointBaseURL = endpointBaseURL;\n+        this.soapValueConverter = new SOAPValueConverter(httpClient);\n+    }\n+\n+    /**\n+     * prepare a SOAP request for an action request to a service\n+     *\n+     * @param service the service\n+     * @param soapAction the action to send\n+     * @param arguments arguments to send along with the request\n+     * @return a jetty Request containing the full SOAP message\n+     * @throws IOException if a problem while writing the SOAP message to the Request occurs\n+     * @throws SOAPException if a problem with creating the SOAP message occurs\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private Request prepareSOAPRequest(SCPDServiceType service, String soapAction, Map<String, String> arguments)\n+            throws IOException, SOAPException {\n+        MessageFactory messageFactory = MessageFactory.newInstance();\n+        SOAPMessage soapMessage = messageFactory.createMessage();\n+        SOAPPart soapPart = soapMessage.getSOAPPart();\n+        SOAPEnvelope envelope = soapPart.getEnvelope();\n+        envelope.setEncodingStyle(\"http://schemas.xmlsoap.org/soap/encoding/\");\n+\n+        // SOAP body\n+        SOAPBody soapBody = envelope.getBody();\n+        SOAPElement soapBodyElem = soapBody.addChildElement(soapAction, \"u\", service.getServiceType());\n+        arguments.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(argument -> {\n+            try {\n+                soapBodyElem.addChildElement(argument.getKey()).setTextContent(argument.getValue());\n+            } catch (SOAPException e) {\n+                logger.warn(\"Could not add {}:{} to SOAP Request: {}\", argument.getKey(), argument.getValue(),\n+                        e.getMessage());\n+            }\n+        });\n+\n+        // SOAP headers\n+        MimeHeaders headers = soapMessage.getMimeHeaders();\n+        headers.addHeader(\"SOAPAction\", service.getServiceType() + \"#\" + soapAction);\n+        soapMessage.saveChanges();\n+\n+        // create Request and add headers and content\n+        Request request = httpClient.newRequest(endpointBaseURL + service.getControlURL()).method(HttpMethod.POST);\n+        ((Iterator<MimeHeader>) soapMessage.getMimeHeaders().getAllHeaders())\n+                .forEachRemaining(header -> request.header(header.getName(), header.getValue()));\n+        try (final ByteArrayOutputStream os = new ByteArrayOutputStream()) {\n+            soapMessage.writeTo(os);\n+            byte[] content = os.toByteArray();\n+            request.content(new BytesContentProvider(content));\n+        }\n+\n+        return request;\n+    }\n+\n+    /**\n+     * execute a SOAP request\n+     *\n+     * @param service the service to send the action to\n+     * @param soapAction the action itself\n+     * @param arguments arguments to send along with the request\n+     * @return the SOAPMessage answer from the remote host\n+     * @throws Tr064CommunicationException if an error occurs during the request\n+     */\n+    public synchronized SOAPMessage doSOAPRequest(SCPDServiceType service, String soapAction,\n+            Map<String, String> arguments) throws Tr064CommunicationException {\n+        try {\n+            Request request = prepareSOAPRequest(service, soapAction, arguments).timeout(SOAP_TIMEOUT,\n+                    TimeUnit.MILLISECONDS);\n+            request.getContent().forEach(buffer -> logger.trace(\"Request: {}\", new String(buffer.array())));", "originalCommit": "21a2e416f1c764f6e493523622d354373d4ab1e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "89f8a646de034956ad72614516782381c6ebb8f6", "url": "https://github.com/openhab/openhab-addons/commit/89f8a646de034956ad72614516782381c6ebb8f6", "message": "improvments\n\nSigned-off-by: Jan N. Klug <jan.n.klug@rub.de>", "committedDate": "2020-10-06T14:39:21Z", "type": "forcePushed"}, {"oid": "554708dd9f8c481026bf55200f2bbf93e85bd778", "url": "https://github.com/openhab/openhab-addons/commit/554708dd9f8c481026bf55200f2bbf93e85bd778", "message": "fixes and code improvements\n\nSigned-off-by: Jan N. Klug <jan.n.klug@rub.de>", "committedDate": "2020-10-31T09:32:38Z", "type": "forcePushed"}, {"oid": "9720046fbaa95eb1f67d3bfc66ed9993a1d5cf18", "url": "https://github.com/openhab/openhab-addons/commit/9720046fbaa95eb1f67d3bfc66ed9993a1d5cf18", "message": "Initial contribution\n\nSigned-off-by: Jan N. Klug <jan.n.klug@rub.de>", "committedDate": "2020-10-31T16:46:23Z", "type": "commit"}, {"oid": "9720046fbaa95eb1f67d3bfc66ed9993a1d5cf18", "url": "https://github.com/openhab/openhab-addons/commit/9720046fbaa95eb1f67d3bfc66ed9993a1d5cf18", "message": "Initial contribution\n\nSigned-off-by: Jan N. Klug <jan.n.klug@rub.de>", "committedDate": "2020-10-31T16:46:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxOTI5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r515519291", "bodyText": "Didn't the phonebooks only exist on Fritzboxes, so you should register it only if it is a THING_TYPE_FRITZBOX?", "author": "kaikreuzer", "createdAt": "2020-10-31T17:26:42Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/Tr064HandlerFactory.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.tr064.internal.phonebook.PhonebookProfileFactory;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link Tr064HandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { ThingHandlerFactory.class }, configurationPid = \"binding.tr064\")\n+public class Tr064HandlerFactory extends BaseThingHandlerFactory {\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Stream\n+            .of(Tr064RootHandler.SUPPORTED_THING_TYPES, Tr064SubHandler.SUPPORTED_THING_TYPES).flatMap(Set::stream)\n+            .collect(Collectors.toSet());\n+\n+    private final HttpClient httpClient;\n+    private final PhonebookProfileFactory phonebookProfileFactory;\n+\n+    // the Tr064ChannelTypeProvider is needed for creating the channels and\n+    // referenced here to make sure it is available before things are\n+    // initialized\n+    @SuppressWarnings(\"unused\")\n+    private final Tr064ChannelTypeProvider channelTypeProvider;\n+\n+    @Activate\n+    public Tr064HandlerFactory(@Reference HttpClientFactory httpClientFactory,\n+            @Reference Tr064ChannelTypeProvider channelTypeProvider,\n+            @Reference PhonebookProfileFactory phonebookProfileFactory) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.phonebookProfileFactory = phonebookProfileFactory;\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (Tr064RootHandler.SUPPORTED_THING_TYPES.contains(thingTypeUID)) {\n+            Tr064RootHandler handler = new Tr064RootHandler((Bridge) thing, httpClient);\n+            phonebookProfileFactory.registerPhonebookProvider(handler);", "originalCommit": "9720046fbaa95eb1f67d3bfc66ed9993a1d5cf18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUzMzIzNg==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r515533236", "bodyText": "With your latest eea changes do you need to do this nullable thing here?", "author": "cpmeister", "createdAt": "2020-10-31T19:57:45Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/util/SCPDUtil.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal.util;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.transform.stream.StreamSource;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.binding.tr064.internal.SCPDException;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDDeviceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDRootType;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.SCPDScpdType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SCPDUtil} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SCPDUtil {\n+    private final Logger logger = LoggerFactory.getLogger(SCPDUtil.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private SCPDRootType scpdRoot;\n+    private final List<SCPDDeviceType> scpdDevicesList = new ArrayList<>();\n+    private final Map<String, @Nullable SCPDScpdType> serviceMap = new HashMap<>();", "originalCommit": "9720046fbaa95eb1f67d3bfc66ed9993a1d5cf18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUzMzM1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8523#discussion_r515533356", "bodyText": "Not worth logging? At least leave a comment here then.", "author": "cpmeister", "createdAt": "2020-10-31T19:59:15Z", "path": "bundles/org.openhab.binding.tr064/src/main/java/org/openhab/binding/tr064/internal/util/Util.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tr064.internal.util;\n+\n+import static org.openhab.binding.tr064.internal.Tr064BindingConstants.*;\n+\n+import java.io.InputStream;\n+import java.lang.reflect.Field;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.soap.SOAPException;\n+import javax.xml.soap.SOAPMessage;\n+import javax.xml.transform.stream.StreamSource;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.tr064.internal.ChannelConfigException;\n+import org.openhab.binding.tr064.internal.Tr064RootHandler;\n+import org.openhab.binding.tr064.internal.config.Tr064BaseThingConfiguration;\n+import org.openhab.binding.tr064.internal.config.Tr064ChannelConfig;\n+import org.openhab.binding.tr064.internal.config.Tr064RootConfiguration;\n+import org.openhab.binding.tr064.internal.config.Tr064SubConfiguration;\n+import org.openhab.binding.tr064.internal.dto.config.ActionType;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescription;\n+import org.openhab.binding.tr064.internal.dto.config.ChannelTypeDescriptions;\n+import org.openhab.binding.tr064.internal.dto.config.ParameterType;\n+import org.openhab.binding.tr064.internal.dto.scpd.root.SCPDServiceType;\n+import org.openhab.binding.tr064.internal.dto.scpd.service.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.util.UIDUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.w3c.dom.NodeList;\n+\n+/**\n+ * The {@link Util} is a set of helper functions\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Util {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(Util.class);\n+\n+    /**\n+     * read the channel config from the resource file (static initialization)\n+     * \n+     * @return a list of all available channel configurations\n+     */\n+    public static List<ChannelTypeDescription> readXMLChannelConfig() {\n+        try {\n+            InputStream resource = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"channels.xml\");\n+            JAXBContext context = JAXBContext.newInstance(ChannelTypeDescriptions.class);\n+            Unmarshaller um = context.createUnmarshaller();\n+            JAXBElement<ChannelTypeDescriptions> root = um.unmarshal(new StreamSource(resource),\n+                    ChannelTypeDescriptions.class);\n+            return root.getValue().getChannel();\n+        } catch (JAXBException e) {\n+            LOGGER.warn(\"Failed to read channel definitions\", e);\n+            return Collections.emptyList();\n+        }\n+    }\n+\n+    /**\n+     * Extract an argument from an SCPD action definition\n+     * \n+     * @param scpdAction the action object\n+     * @param argumentName the argument's name\n+     * @param direction the direction (in or out)\n+     * @return the requested argument object\n+     * @throws ChannelConfigException if not found\n+     */\n+    private static SCPDArgumentType getArgument(SCPDActionType scpdAction, String argumentName, SCPDDirection direction)\n+            throws ChannelConfigException {\n+        return scpdAction.getArgumentList().stream()\n+                .filter(argument -> argument.getName().equals(argumentName) && argument.getDirection() == direction)\n+                .findFirst()\n+                .orElseThrow(() -> new ChannelConfigException(\n+                        (direction == SCPDDirection.IN ? \"Set-Argument '\" : \"Get-Argument '\") + argumentName\n+                                + \"' not found\"));\n+    }\n+\n+    /**\n+     * Extract the related state variable from the service root for a given argument\n+     * \n+     * @param serviceRoot the service root object\n+     * @param scpdArgument the argument object\n+     * @return the related state variable object for this argument\n+     * @throws ChannelConfigException if not found\n+     */\n+    private static SCPDStateVariableType getStateVariable(SCPDScpdType serviceRoot, SCPDArgumentType scpdArgument)\n+            throws ChannelConfigException {\n+        return serviceRoot.getServiceStateTable().stream()\n+                .filter(stateVariable -> stateVariable.getName().equals(scpdArgument.getRelatedStateVariable()))\n+                .findFirst().orElseThrow(() -> new ChannelConfigException(\n+                        \"StateVariable '\" + scpdArgument.getRelatedStateVariable() + \"' not found\"));\n+    }\n+\n+    /**\n+     * Extract an action from the service root\n+     * \n+     * @param serviceRoot the service root object\n+     * @param actionName the action name\n+     * @param actionType \"Get-Action\" or \"Set-Action\" (for exception string only)\n+     * @return the requested action object\n+     * @throws ChannelConfigException if not found\n+     */\n+    private static SCPDActionType getAction(SCPDScpdType serviceRoot, String actionName, String actionType)\n+            throws ChannelConfigException {\n+        return serviceRoot.getActionList().stream().filter(action -> actionName.equals(action.getName())).findFirst()\n+                .orElseThrow(() -> new ChannelConfigException(actionType + \" '\" + actionName + \"' not found\"));\n+    }\n+\n+    /**\n+     * check and add available channels on a thing\n+     *\n+     * @param thing the Thing\n+     * @param thingBuilder the ThingBuilder (needs to be passed as editThing is only available in the handler)\n+     * @param scpdUtil the SCPDUtil instance for this thing\n+     * @param deviceId the device id for this thing\n+     * @param deviceType the (SCPD) device-type for this thing\n+     * @param channels a (mutable) channel list for storing all channels\n+     */\n+    public static void checkAvailableChannels(Thing thing, ThingBuilder thingBuilder, SCPDUtil scpdUtil,\n+            String deviceId, String deviceType, Map<ChannelUID, Tr064ChannelConfig> channels) {\n+        Tr064BaseThingConfiguration thingConfig = Tr064RootHandler.SUPPORTED_THING_TYPES\n+                .contains(thing.getThingTypeUID()) ? thing.getConfiguration().as(Tr064RootConfiguration.class)\n+                        : thing.getConfiguration().as(Tr064SubConfiguration.class);\n+        channels.clear();\n+        CHANNEL_TYPES.stream().filter(channel -> deviceType.equals(channel.getService().getDeviceType()))\n+                .forEach(channelTypeDescription -> {\n+                    String channelId = channelTypeDescription.getName();\n+                    String serviceId = channelTypeDescription.getService().getServiceId();\n+                    Set<String> parameters = new HashSet<>();\n+                    try {\n+                        SCPDServiceType deviceService = scpdUtil.getDevice(deviceId)\n+                                .flatMap(device -> device.getServiceList().stream()\n+                                        .filter(service -> service.getServiceId().equals(serviceId)).findFirst())\n+                                .orElseThrow(() -> new ChannelConfigException(\"Service '\" + serviceId + \"' not found\"));\n+                        SCPDScpdType serviceRoot = scpdUtil.getService(deviceService.getServiceId())\n+                                .orElseThrow(() -> new ChannelConfigException(\n+                                        \"Service definition for '\" + serviceId + \"' not found\"));\n+                        Tr064ChannelConfig channelConfig = new Tr064ChannelConfig(channelTypeDescription,\n+                                deviceService);\n+\n+                        // get\n+                        ActionType getAction = channelTypeDescription.getGetAction();\n+                        if (getAction != null) {\n+                            String actionName = getAction.getName();\n+                            String argumentName = getAction.getArgument();\n+                            SCPDActionType scpdAction = getAction(serviceRoot, actionName, \"Get-Action\");\n+                            SCPDArgumentType scpdArgument = getArgument(scpdAction, argumentName, SCPDDirection.OUT);\n+                            SCPDStateVariableType relatedStateVariable = getStateVariable(serviceRoot, scpdArgument);\n+                            parameters.addAll(\n+                                    getAndCheckParameters(channelId, getAction, scpdAction, serviceRoot, thingConfig));\n+\n+                            channelConfig.setGetAction(scpdAction);\n+                            channelConfig.setDataType(relatedStateVariable.getDataType());\n+                        }\n+\n+                        // check set action\n+                        ActionType setAction = channelTypeDescription.getSetAction();\n+                        if (setAction != null) {\n+                            String actionName = setAction.getName();\n+                            String argumentName = setAction.getArgument();\n+\n+                            SCPDActionType scpdAction = getAction(serviceRoot, actionName, \"Set-Action\");\n+                            if (argumentName != null) {\n+                                SCPDArgumentType scpdArgument = getArgument(scpdAction, argumentName, SCPDDirection.IN);\n+                                SCPDStateVariableType relatedStateVariable = getStateVariable(serviceRoot,\n+                                        scpdArgument);\n+                                if (channelConfig.getDataType().isEmpty()) {\n+                                    channelConfig.setDataType(relatedStateVariable.getDataType());\n+                                } else if (!channelConfig.getDataType().equals(relatedStateVariable.getDataType())) {\n+                                    throw new ChannelConfigException(\"dataType of set and get action are different\");\n+                                }\n+                            }\n+                        }\n+\n+                        // everything is available, create the channel\n+                        ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID,\n+                                channelTypeDescription.getName());\n+                        if (parameters.isEmpty()) {\n+                            // we have no parameters, so create a single channel\n+                            ChannelUID channelUID = new ChannelUID(thing.getUID(), channelId);\n+                            ChannelBuilder channelBuilder = ChannelBuilder\n+                                    .create(channelUID, channelTypeDescription.getItem().getType())\n+                                    .withType(channelTypeUID);\n+                            thingBuilder.withChannel(channelBuilder.build());\n+                            channels.put(channelUID, channelConfig);\n+                        } else {\n+                            // create a channel for each parameter\n+                            parameters.forEach(parameter -> {\n+                                String normalizedParameter = UIDUtils.encode(parameter);\n+                                ChannelUID channelUID = new ChannelUID(thing.getUID(),\n+                                        channelId + \"_\" + normalizedParameter);\n+                                ChannelBuilder channelBuilder = ChannelBuilder\n+                                        .create(channelUID, channelTypeDescription.getItem().getType())\n+                                        .withType(channelTypeUID)\n+                                        .withLabel(channelTypeDescription.getLabel() + \" \" + parameter);\n+                                thingBuilder.withChannel(channelBuilder.build());\n+                                Tr064ChannelConfig channelConfig1 = new Tr064ChannelConfig(channelConfig);\n+                                channelConfig1.setParameter(parameter);\n+                                channels.put(channelUID, channelConfig1);\n+                            });\n+                        }\n+                    } catch (ChannelConfigException e) {\n+                        LOGGER.debug(\"Channel {} not available: {}\", channelId, e.getMessage());\n+                    }\n+                });\n+    }\n+\n+    private static Set<String> getAndCheckParameters(String channelId, ActionType action, SCPDActionType scpdAction,\n+            SCPDScpdType serviceRoot, Tr064BaseThingConfiguration thingConfig) throws ChannelConfigException {\n+        ParameterType parameter = action.getParameter();\n+        if (parameter == null) {\n+            return Collections.emptySet();\n+        }\n+        try {\n+            Set<String> parameters = new HashSet<>();\n+\n+            // get parameters by reflection from thing config\n+            Field paramField = thingConfig.getClass().getField(parameter.getThingParameter());\n+            Object rawFieldValue = paramField.get(thingConfig);\n+            if ((rawFieldValue instanceof List<?>)) {\n+                ((List<?>) rawFieldValue).forEach(obj -> {\n+                    if (obj instanceof String) {\n+                        parameters.add((String) obj);\n+                    }\n+                });\n+            }\n+\n+            // validate parameter against pattern\n+            String parameterPattern = parameter.getPattern();\n+            if (parameterPattern != null) {\n+                parameters.removeIf(param -> !param.matches(parameterPattern));\n+            }\n+\n+            // validate parameter against SCPD (if not internal only)\n+            if (!parameter.isInternalOnly()) {\n+                SCPDArgumentType scpdArgument = getArgument(scpdAction, parameter.getName(), SCPDDirection.IN);\n+                SCPDStateVariableType relatedStateVariable = getStateVariable(serviceRoot, scpdArgument);\n+                if (relatedStateVariable.getAllowedValueRange() != null) {\n+                    int paramMin = relatedStateVariable.getAllowedValueRange().getMinimum();\n+                    int paramMax = relatedStateVariable.getAllowedValueRange().getMaximum();\n+                    int paramStep = relatedStateVariable.getAllowedValueRange().getStep();\n+                    Set<String> allowedValues = Stream.iterate(paramMin, i -> i <= paramMax, i -> i + paramStep)\n+                            .map(String::valueOf).collect(Collectors.toSet());\n+                    parameters.retainAll(allowedValues);\n+                }\n+            }\n+\n+            // check we have at least one valid parameter left\n+            if (parameters.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+            return parameters;\n+        } catch (NoSuchFieldException | IllegalAccessException | IllegalArgumentException e) {\n+            throw new ChannelConfigException(\"Could not get required parameter '\" + channelId\n+                    + \"' from thing config (missing, empty or invalid)\");\n+        }\n+    }\n+\n+    public static Optional<String> getSOAPElement(SOAPMessage soapMessage, String elementName) {\n+        try {\n+            NodeList nodeList = soapMessage.getSOAPBody().getElementsByTagName(elementName);\n+            if (nodeList != null && nodeList.getLength() > 0) {\n+                return Optional.of(nodeList.item(0).getTextContent());\n+            }\n+        } catch (SOAPException e) {\n+        }", "originalCommit": "9720046fbaa95eb1f67d3bfc66ed9993a1d5cf18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "67bcc2427ab047189969eb141d451517a64ffcc5", "url": "https://github.com/openhab/openhab-addons/commit/67bcc2427ab047189969eb141d451517a64ffcc5", "message": "address review comments\n\nSigned-off-by: Jan N. Klug <jan.n.klug@rub.de>", "committedDate": "2020-10-31T20:08:09Z", "type": "commit"}, {"oid": "f60b025025ccec34c568aa4def3c908d10c0c6eb", "url": "https://github.com/openhab/openhab-addons/commit/f60b025025ccec34c568aa4def3c908d10c0c6eb", "message": "address review comments\n\nSigned-off-by: Jan N. Klug <jan.n.klug@rub.de>", "committedDate": "2020-10-31T20:13:06Z", "type": "commit"}, {"oid": "5180bd3c48340eb056f4ad7718d6e31250f3e52c", "url": "https://github.com/openhab/openhab-addons/commit/5180bd3c48340eb056f4ad7718d6e31250f3e52c", "message": "address last review comments\n\nSigned-off-by: Jan N. Klug <jan.n.klug@rub.de>", "committedDate": "2020-11-01T08:08:04Z", "type": "commit"}]}