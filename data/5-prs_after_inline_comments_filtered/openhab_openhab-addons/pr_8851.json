{"pr_number": 8851, "pr_title": "[serial] Serial Binding", "pr_createdAt": "2020-10-24T00:12:10Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8851", "timeline": [{"oid": "504a559e8efb9ed9472a59a2af9fbffa87ffe1f2", "url": "https://github.com/openhab/openhab-addons/commit/504a559e8efb9ed9472a59a2af9fbffa87ffe1f2", "message": "WIP\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-10-22T19:31:52Z", "type": "commit"}, {"oid": "46a9b703107d4a90661b00cf85d4e88d2c74822c", "url": "https://github.com/openhab/openhab-addons/commit/46a9b703107d4a90661b00cf85d4e88d2c74822c", "message": "Basic working bridge and filter\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-10-23T23:55:34Z", "type": "commit"}, {"oid": "3c2ab3617cfeca2ae1b443224970b99656cd6fbf", "url": "https://github.com/openhab/openhab-addons/commit/3c2ab3617cfeca2ae1b443224970b99656cd6fbf", "message": "Add writing to serial port and support binary data at the bridge level\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-10-24T12:26:57Z", "type": "commit"}, {"oid": "9f10f5f4e25d0ff6f481bfe379d9c41deda95748", "url": "https://github.com/openhab/openhab-addons/commit/9f10f5f4e25d0ff6f481bfe379d9c41deda95748", "message": "Setup port from config\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-10-25T10:43:19Z", "type": "commit"}, {"oid": "68030166d33c4fbc9a6ce07763af50f15abe4054", "url": "https://github.com/openhab/openhab-addons/commit/68030166d33c4fbc9a6ce07763af50f15abe4054", "message": "Tidy up to remove warnings\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-10-25T12:36:22Z", "type": "commit"}, {"oid": "2450e83eb92d3f903fa113638139770d50859853", "url": "https://github.com/openhab/openhab-addons/commit/2450e83eb92d3f903fa113638139770d50859853", "message": "Further cleanup\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-10-25T17:10:41Z", "type": "commit"}, {"oid": "8456f68d486405aa3677c8a52a3143f33feeb76a", "url": "https://github.com/openhab/openhab-addons/commit/8456f68d486405aa3677c8a52a3143f33feeb76a", "message": "Run spotless on pom file\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-10-25T17:32:31Z", "type": "commit"}, {"oid": "84bec8458c04338ea3e5f7b968a6ec72a9866d01", "url": "https://github.com/openhab/openhab-addons/commit/84bec8458c04338ea3e5f7b968a6ec72a9866d01", "message": "Manually update POM file\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-10-25T17:46:24Z", "type": "commit"}, {"oid": "1a8484683364aaccb86d99e60584f37ce2c939fc", "url": "https://github.com/openhab/openhab-addons/commit/1a8484683364aaccb86d99e60584f37ce2c939fc", "message": "Add documentation and fix use of RawType\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-10-28T15:35:59Z", "type": "commit"}, {"oid": "4b09ef5b44574247f66a6473c84fb6009bd5b024", "url": "https://github.com/openhab/openhab-addons/commit/4b09ef5b44574247f66a6473c84fb6009bd5b024", "message": "Repackage files\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-10-28T15:52:00Z", "type": "commit"}, {"oid": "947ed25786fc869ba295780dbc1672b4bf91fd68", "url": "https://github.com/openhab/openhab-addons/commit/947ed25786fc869ba295780dbc1672b4bf91fd68", "message": "Minor changes\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-10-28T16:14:35Z", "type": "commit"}, {"oid": "80c55237deb66daea47b1e0d410f81967b61c486", "url": "https://github.com/openhab/openhab-addons/commit/80c55237deb66daea47b1e0d410f81967b61c486", "message": "Correct markdown\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-10-28T17:29:34Z", "type": "commit"}, {"oid": "6d0f136cc749b5bec0597b4efa611e4d0a1edcf0", "url": "https://github.com/openhab/openhab-addons/commit/6d0f136cc749b5bec0597b4efa611e4d0a1edcf0", "message": "Add support for writing to Serial Device channels and add support for incoming and outgoing transforms\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-10-30T16:30:58Z", "type": "commit"}, {"oid": "3db616b6bada1d99b396846bf130ed0d2251ab66", "url": "https://github.com/openhab/openhab-addons/commit/3db616b6bada1d99b396846bf130ed0d2251ab66", "message": "Document channel configuration and add some more examples.\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-10-31T12:21:30Z", "type": "commit"}, {"oid": "cbb46ea55d1240b0980f83f8d83a34017b17992f", "url": "https://github.com/openhab/openhab-addons/commit/cbb46ea55d1240b0980f83f8d83a34017b17992f", "message": "All channel now support a device transform\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-11-01T08:11:30Z", "type": "commit"}, {"oid": "fb95f3380eb99f21f8f7a0850ad9e310eef24118", "url": "https://github.com/openhab/openhab-addons/commit/fb95f3380eb99f21f8f7a0850ad9e310eef24118", "message": "Add NonNullByDefault to config classes\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-11-01T09:13:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwNTQzOA==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515605438", "bodyText": "Please use constructor injection (see e.g. https://github.com/openhab/openhab-addons/blob/main/bundles/org.openhab.binding.snmp/src/main/java/org/openhab/binding/snmp/internal/SnmpHandlerFactory.java how to do that).", "author": "J-N-K", "createdAt": "2020-11-01T10:43:18Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/SerialHandlerFactory.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal;\n+\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.THING_TYPE_BRIDGE;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.THING_TYPE_DEVICE;\n+\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.handler.SerialBridgeHandler;\n+import org.openhab.binding.serial.internal.handler.SerialDeviceHandler;\n+import org.openhab.core.io.transport.serial.SerialPortManager;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link SerialHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.serial\", service = ThingHandlerFactory.class)\n+public class SerialHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Set.of(THING_TYPE_BRIDGE, THING_TYPE_DEVICE);\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;", "originalCommit": "fb95f3380eb99f21f8f7a0850ad9e310eef24118", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwNzA4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515607086", "bodyText": "Same here.", "author": "J-N-K", "createdAt": "2020-11-01T11:00:43Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeConfiguration.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.io.transport.serial.SerialPort;\n+\n+/**\n+ * Class describing the serial bridge user configuration\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeConfiguration {\n+    /**\n+     * Serial port name\n+     */\n+    public @Nullable String serialPort;\n+\n+    /**\n+     * Serial port baud rate\n+     */\n+    public int baudRate = 9600;\n+\n+    /**\n+     * Serial port data bits\n+     */\n+    public int dataBits = 8;\n+\n+    /**\n+     * Serial port parity\n+     */\n+    public String parity = \"N\";\n+\n+    /**\n+     * Serial port stop bits\n+     */\n+    public String stopBits = \"1\";", "originalCommit": "fb95f3380eb99f21f8f7a0850ad9e310eef24118", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwNzI5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515607293", "bodyText": "You could use an enum for that (NONE, EVEN, ODD, MARK, SPACE).", "author": "J-N-K", "createdAt": "2020-11-01T11:03:05Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeConfiguration.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.io.transport.serial.SerialPort;\n+\n+/**\n+ * Class describing the serial bridge user configuration\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeConfiguration {\n+    /**\n+     * Serial port name\n+     */\n+    public @Nullable String serialPort;\n+\n+    /**\n+     * Serial port baud rate\n+     */\n+    public int baudRate = 9600;\n+\n+    /**\n+     * Serial port data bits\n+     */\n+    public int dataBits = 8;\n+\n+    /**\n+     * Serial port parity\n+     */\n+    public String parity = \"N\";", "originalCommit": "fb95f3380eb99f21f8f7a0850ad9e310eef24118", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY1MzE0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515653141", "bodyText": "Are you suggesting changing parity to be an enum rather than a string?\nHow would you handle a user setting an invalid value in the config? I've tried it and you get a an IllegalArgumentException thrown from ConfigMapper.", "author": "MikeJMajor", "createdAt": "2020-11-01T18:10:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwNzI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY3MDM0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r518670345", "bodyText": "But that's up to the user if he/she configures wrong values. Your code is much simpler and less error prone if you use the enum.", "author": "J-N-K", "createdAt": "2020-11-06T10:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwNzI5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwNzUyNg==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515607526", "bodyText": "Unfortunately this is not possible anymore. You could workaround that by assigning a new SerialBridgeConfiguration object.", "author": "J-N-K", "createdAt": "2020-11-01T11:05:13Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.BINARY_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.STRING_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.TRIGGER_CHANNEL;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.util.Base64;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.io.transport.serial.PortInUseException;\n+import org.openhab.core.io.transport.serial.SerialPort;\n+import org.openhab.core.io.transport.serial.SerialPortEvent;\n+import org.openhab.core.io.transport.serial.SerialPortEventListener;\n+import org.openhab.core.io.transport.serial.SerialPortIdentifier;\n+import org.openhab.core.io.transport.serial.SerialPortManager;\n+import org.openhab.core.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.CommonTriggerEvents;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SerialBridgeHandler} is responsible for handling commands, which\n+ * are sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends BaseBridgeHandler implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfiguration config;", "originalCommit": "fb95f3380eb99f21f8f7a0850ad9e310eef24118", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwNzU0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515607547", "bodyText": "Change to @Nullable", "author": "J-N-K", "createdAt": "2020-11-01T11:05:30Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.BINARY_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.STRING_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.TRIGGER_CHANNEL;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.util.Base64;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.io.transport.serial.PortInUseException;\n+import org.openhab.core.io.transport.serial.SerialPort;\n+import org.openhab.core.io.transport.serial.SerialPortEvent;\n+import org.openhab.core.io.transport.serial.SerialPortEventListener;\n+import org.openhab.core.io.transport.serial.SerialPortIdentifier;\n+import org.openhab.core.io.transport.serial.SerialPortManager;\n+import org.openhab.core.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.CommonTriggerEvents;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SerialBridgeHandler} is responsible for handling commands, which\n+ * are sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends BaseBridgeHandler implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfiguration config;\n+\n+    private final SerialPortManager serialPortManager;\n+    private @NonNullByDefault({}) SerialPort serialPort;", "originalCommit": "fb95f3380eb99f21f8f7a0850ad9e310eef24118", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwNzU4OA==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515607588", "bodyText": "Either assign a default charset or change to @Nullable.", "author": "J-N-K", "createdAt": "2020-11-01T11:05:57Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.BINARY_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.STRING_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.TRIGGER_CHANNEL;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.util.Base64;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.io.transport.serial.PortInUseException;\n+import org.openhab.core.io.transport.serial.SerialPort;\n+import org.openhab.core.io.transport.serial.SerialPortEvent;\n+import org.openhab.core.io.transport.serial.SerialPortEventListener;\n+import org.openhab.core.io.transport.serial.SerialPortIdentifier;\n+import org.openhab.core.io.transport.serial.SerialPortManager;\n+import org.openhab.core.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.CommonTriggerEvents;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SerialBridgeHandler} is responsible for handling commands, which\n+ * are sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends BaseBridgeHandler implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfiguration config;\n+\n+    private final SerialPortManager serialPortManager;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @NonNullByDefault({}) Charset charset;", "originalCommit": "fb95f3380eb99f21f8f7a0850ad9e310eef24118", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwODIyNg==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515608226", "bodyText": "You could refactor the receiving and processing to a new method (receiveAndProcess). Then schedule a call to that method here. Instead of a do-while, check if data is available, read that and then schedule a call to the same method after reading with a delay of 100ms. If no data is available, do the processing (l.212-224). Then Thread.sleep can be avoided.", "author": "J-N-K", "createdAt": "2020-11-01T11:13:16Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.BINARY_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.STRING_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.TRIGGER_CHANNEL;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.util.Base64;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.io.transport.serial.PortInUseException;\n+import org.openhab.core.io.transport.serial.SerialPort;\n+import org.openhab.core.io.transport.serial.SerialPortEvent;\n+import org.openhab.core.io.transport.serial.SerialPortEventListener;\n+import org.openhab.core.io.transport.serial.SerialPortIdentifier;\n+import org.openhab.core.io.transport.serial.SerialPortManager;\n+import org.openhab.core.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.CommonTriggerEvents;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SerialBridgeHandler} is responsible for handling commands, which\n+ * are sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends BaseBridgeHandler implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfiguration config;\n+\n+    private final SerialPortManager serialPortManager;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @NonNullByDefault({}) Charset charset;\n+\n+    private @Nullable String data;\n+\n+    public SerialBridgeHandler(final Bridge bridge, final SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            refresh(channelUID.getId());\n+        } else {\n+            switch (channelUID.getId()) {\n+                case STRING_CHANNEL:\n+                    writeString(command.toFullString(), false);\n+                    break;\n+                case BINARY_CHANNEL:\n+                    writeString(command.toFullString(), true);\n+                    break;\n+                default:\n+                    break;\n+            }\n+\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SerialBridgeConfiguration.class);\n+\n+        try {\n+            if (config.charset == null) {\n+                charset = Charset.defaultCharset();\n+            } else {\n+                charset = Charset.forName(config.charset);\n+            }\n+            logger.debug(\"Serial port '{}' charset '{}' set\", config.serialPort, charset);\n+        } catch (final IllegalCharsetNameException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Invalid charset\");\n+            return;\n+        }\n+\n+        final String port = config.serialPort;\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set\");\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        final SerialPortIdentifier portId = serialPortManager.getIdentifier(port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known\");\n+            return;\n+        }\n+\n+        // initialize serial port\n+        try {\n+            serialPort = portId.open(getThing().getUID().toString(), 2000);\n+\n+            serialPort.setSerialPortParams(config.baudRate, config.dataBits, config.getStopBitsAsInt(),\n+                    config.getParityAsInt());\n+\n+            serialPort.addEventListener(this);\n+\n+            // activate the DATA_AVAILABLE notifier\n+            serialPort.notifyOnDataAvailable(true);\n+            inputStream = serialPort.getInputStream();\n+            outputStream = serialPort.getOutputStream();\n+\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error\");\n+        } catch (final PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use\");\n+        } catch (final TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port\");\n+        } catch (final UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unsupported port parameters: \" + e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (serialPort != null) {\n+            serialPort.removeEventListener();\n+            serialPort.close();\n+            serialPort = null;\n+        }\n+\n+        final InputStream inputStream = this.inputStream;\n+        if (inputStream != null) {\n+            try {\n+                inputStream.close();\n+            } catch (final IOException e) {\n+                logger.debug(\"Error while closing the input stream: {}\", e.getMessage());\n+            }\n+            this.inputStream = null;\n+        }\n+\n+        final OutputStream outputStream = this.outputStream;\n+        if (outputStream != null) {\n+            try {\n+                outputStream.close();\n+            } catch (final IOException e) {\n+                logger.debug(\"Error while closing the output stream: {}\", e.getMessage());\n+            }\n+            this.outputStream = null;\n+        }\n+\n+        data = null;\n+    }\n+\n+    @Override\n+    public void serialEvent(final SerialPortEvent event) {\n+        final InputStream inputStream = this.inputStream;\n+\n+        if (inputStream == null) {\n+            return;\n+        }\n+\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                final StringBuilder sb = new StringBuilder();\n+                final byte[] readBuffer = new byte[20];\n+                try {\n+                    do {", "originalCommit": "fb95f3380eb99f21f8f7a0850ad9e310eef24118", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY1Mjg2NA==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515652864", "bodyText": "Is the sleep that much of an issue?\nI've refactored it and it appears to work, but now I'm concerned about 2 threads being involved and missing data. In my refactored code serialEvent checks if there's a ScheduledFuture active and does nothing. The assumption here is that receiveAndProcess will read in the data, but there's a risk that we are in the processing bit of receiveAndProcess and we won't do any more reads until we get another callback from serialEvent.", "author": "MikeJMajor", "createdAt": "2020-11-01T18:07:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwODIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY1MzM1MA==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515653350", "bodyText": "You could create a AtomicBoolean serialProcessing, set it when you first call the read-method and unset it after you stopped reading. That makes sure it's never called twice. The problem with Thread.sleep is when you have (e.g. five) com-ports reading, it'll sleep all threads in the thread-pool.", "author": "J-N-K", "createdAt": "2020-11-01T18:12:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwODIyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYxMDU1OA==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515610558", "bodyText": "Pass the bundleContext from the handler factory when instantiating the handler.", "author": "J-N-K", "createdAt": "2020-11-01T11:36:53Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private @NonNullByDefault({}) Pattern devicePattern;\n+\n+    private @Nullable String data;\n+\n+    private final Map<ChannelUID, DeviceChannel> channels = new HashMap<>();\n+\n+    public SerialDeviceHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            refresh(channelUID);\n+        } else {\n+            if (channels.containsKey(channelUID)) {\n+                final Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    final SerialBridgeHandler handler = (SerialBridgeHandler) bridge.getHandler();\n+                    if (handler != null) {\n+                        final String data = channels.get(channelUID).mapCommand(command);\n+                        if (data != null) {\n+                            handler.writeString(data);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final SerialDeviceConfiguration config = getConfigAs(SerialDeviceConfiguration.class);\n+\n+        try {\n+            devicePattern = Pattern.compile(config.patternMatch);\n+        } catch (final PatternSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid device pattern: \" + e.getMessage());\n+            return;\n+        }\n+\n+        final BundleContext bundleContext = FrameworkUtil.getBundle(SerialDeviceHandler.class).getBundleContext();", "originalCommit": "fb95f3380eb99f21f8f7a0850ad9e310eef24118", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYxMzAzMg==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515613032", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (channels.containsKey(channelUID)) {\n          \n          \n            \n                        final String state = channels.get(channelUID).transformData(data);\n          \n          \n            \n            \n          \n          \n            \n                        if (state != null) {\n          \n          \n            \n                            updateState(channelUID, new StringType(state));\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    Channel channel = channels.get(channelUID);\n          \n          \n            \n                    if (channel != null) {\n          \n          \n            \n                        final String state = channel.transformData(data);\n          \n          \n            \n            \n          \n          \n            \n                        if (state != null) {\n          \n          \n            \n                            updateState(channelUID, new StringType(state));\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n      \n    \n    \n  \n\nAvoid null warning.", "author": "J-N-K", "createdAt": "2020-11-01T11:59:54Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private @NonNullByDefault({}) Pattern devicePattern;\n+\n+    private @Nullable String data;\n+\n+    private final Map<ChannelUID, DeviceChannel> channels = new HashMap<>();\n+\n+    public SerialDeviceHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            refresh(channelUID);\n+        } else {\n+            if (channels.containsKey(channelUID)) {\n+                final Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    final SerialBridgeHandler handler = (SerialBridgeHandler) bridge.getHandler();\n+                    if (handler != null) {\n+                        final String data = channels.get(channelUID).mapCommand(command);\n+                        if (data != null) {\n+                            handler.writeString(data);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final SerialDeviceConfiguration config = getConfigAs(SerialDeviceConfiguration.class);\n+\n+        try {\n+            devicePattern = Pattern.compile(config.patternMatch);\n+        } catch (final PatternSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid device pattern: \" + e.getMessage());\n+            return;\n+        }\n+\n+        final BundleContext bundleContext = FrameworkUtil.getBundle(SerialDeviceHandler.class).getBundleContext();\n+        for (final Channel c : getThing().getChannels()) {\n+            final ChannelTypeUID type = c.getChannelTypeUID();\n+            if (type != null) {\n+                final ChannelConfig channelConfig = c.getConfiguration().as(ChannelConfig.class);\n+                try {\n+                    DeviceChannel deviceChannel = DeviceChannelFactory.createDeviceChannel(bundleContext, channelConfig,\n+                            type.getId());\n+                    if (deviceChannel != null) {\n+                        channels.put(c.getUID(), deviceChannel);\n+                    }\n+                } catch (final IllegalArgumentException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configuration error for channel \" + c.getUID().getId() + \": \" + e.getMessage());\n+                    return;\n+                }\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        bridgeStatusChanged(getBridgeStatus());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        channels.clear();\n+        data = null;\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Handle a line of data received from the bridge\n+     *\n+     * @param data the line of data\n+     */\n+    public void handleData(final String data) {\n+        if (devicePattern.matcher(data).matches()) {\n+            this.data = data;\n+            channels.keySet().forEach(this::refresh);\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(final ThingStatusInfo bridgeStatusInfo) {\n+        if (getThing().getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+            return;\n+        }\n+\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE && getThing().getStatus() == ThingStatus.UNKNOWN) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            return;\n+        }\n+\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+    }\n+\n+    /**\n+     * Return the bridge status.\n+     */\n+    private ThingStatusInfo getBridgeStatus() {\n+        final Bridge b = getBridge();\n+        if (b != null) {\n+            return b.getStatusInfo();\n+        } else {\n+            return new ThingStatusInfo(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, null);\n+        }\n+    }\n+\n+    /**\n+     * Refreshes the channel with the last received data\n+     *\n+     * @param channelId the channel to refresh\n+     */\n+    private void refresh(final ChannelUID channelUID) {\n+        final String data = this.data;\n+\n+        if (data == null || !isLinked(channelUID)) {\n+            return;\n+        }\n+\n+        if (channels.containsKey(channelUID)) {\n+            final String state = channels.get(channelUID).transformData(data);\n+\n+            if (state != null) {\n+                updateState(channelUID, new StringType(state));\n+            }\n+        }", "originalCommit": "fb95f3380eb99f21f8f7a0850ad9e310eef24118", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a9e05151604491ba0931ea08119f05f28a8e552e", "url": "https://github.com/openhab/openhab-addons/commit/a9e05151604491ba0931ea08119f05f28a8e552e", "message": "Simple code review changes\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-11-01T15:01:46Z", "type": "commit"}, {"oid": "c53d956a0acb2ff377c856b683af68fc144eeb41", "url": "https://github.com/openhab/openhab-addons/commit/c53d956a0acb2ff377c856b683af68fc144eeb41", "message": "Refactor receiving data\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-11-02T10:03:28Z", "type": "commit"}, {"oid": "e8c741cf1c521e8fef3d6b41cd2f76d71a11194d", "url": "https://github.com/openhab/openhab-addons/commit/e8c741cf1c521e8fef3d6b41cd2f76d71a11194d", "message": "Refactor to use enums for parity and stopBits\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-11-02T11:08:23Z", "type": "commit"}, {"oid": "a9bed971bf31da3f211b61c1f6c37b2de88ba3cf", "url": "https://github.com/openhab/openhab-addons/commit/a9bed971bf31da3f211b61c1f6c37b2de88ba3cf", "message": "Align config parameters with HTTP binding and make use of cascading transforms as used by MQTT and HTTP bindings\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-11-02T13:51:47Z", "type": "commit"}, {"oid": "522bd9c8b8db17cd7b3f73fdcaa23a994b5601d6", "url": "https://github.com/openhab/openhab-addons/commit/522bd9c8b8db17cd7b3f73fdcaa23a994b5601d6", "message": "Merge branch 'main' into serial", "committedDate": "2020-11-02T13:52:30Z", "type": "commit"}, {"oid": "a95590d1aba45dfaa507e5a4aed4e8e3d105662a", "url": "https://github.com/openhab/openhab-addons/commit/a95590d1aba45dfaa507e5a4aed4e8e3d105662a", "message": "Final tidy up\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-11-02T14:45:28Z", "type": "commit"}, {"oid": "e6cd0d31575632cd51fd1f22588bf047f296ab80", "url": "https://github.com/openhab/openhab-addons/commit/e6cd0d31575632cd51fd1f22588bf047f296ab80", "message": "Update README\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-11-02T17:06:03Z", "type": "commit"}, {"oid": "451bcd026efd63ab68f55c600a70acf970312e85", "url": "https://github.com/openhab/openhab-addons/commit/451bcd026efd63ab68f55c600a70acf970312e85", "message": "Make sure reader stops and can be restarted\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-11-03T09:04:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY3OTY1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r518679654", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public @Nullable String transformData(final @Nullable String data) {\n          \n          \n            \n                    return data != null ? transform.apply(data).orElse(null) : null;\n          \n          \n            \n                }\n          \n          \n            \n                public Optional<String> transformData(final String data) {\n          \n          \n            \n                    return transform.apply(data);\n          \n          \n            \n                }\n          \n      \n    \n    \n  \n\n(see below)", "author": "J-N-K", "createdAt": "2020-11-06T11:02:59Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/channel/DeviceChannel.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.channel;\n+\n+import java.util.IllegalFormatException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.transform.ValueTransformation;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DeviceChannel} is the abstract class for handling a channel. Provides\n+ * the ability to transform the device data into the channel state.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class DeviceChannel {\n+    protected final Logger logger = LoggerFactory.getLogger(DeviceChannel.class);\n+\n+    protected final ChannelConfig config;\n+\n+    private final ValueTransformation transform;\n+    private final ValueTransformation commandTransform;\n+\n+    protected DeviceChannel(final ValueTransformationProvider valueTransformationProvider, final ChannelConfig config) {\n+        this.config = config;\n+        transform = valueTransformationProvider.getValueTransformation(config.stateTransformation);\n+        commandTransform = valueTransformationProvider.getValueTransformation(config.commandTransformation);\n+    }\n+\n+    /**\n+     * Map the supplied command into the data to send to the device by\n+     * applying a format followed by a transform.\n+     * \n+     * @param command the command to map\n+     * @return the mapped data or the orginal data if no mapping found\n+     */\n+    public @Nullable String mapCommand(final Command command) {\n+        String data = formatCommand(command);\n+\n+        data = transformCommand(data);\n+\n+        logger.debug(\"Mapped command is '{}'\", data);\n+\n+        return data;\n+    }\n+\n+    /**\n+     * Transform the data using the configured transform\n+     * \n+     * @param data the data to transform\n+     * @return the transformed data is the transform produced a result otherwise null.\n+     */\n+    public @Nullable String transformData(final @Nullable String data) {\n+        return data != null ? transform.apply(data).orElse(null) : null;\n+    }", "originalCommit": "451bcd026efd63ab68f55c600a70acf970312e85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY4MTAxNA==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r518681014", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (channel != null) {\n          \n          \n            \n                        final String state = channel.transformData(data);\n          \n          \n            \n            \n          \n          \n            \n                        if (state != null) {\n          \n          \n            \n                            updateState(channelUID, new StringType(state));\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    if (channel != null) {\n          \n          \n            \n                        channel.transformData(data).ifPresent(value -> updateState(channelUID, new StringType(value));\n          \n          \n            \n                    }\n          \n      \n    \n    \n  \n\nYou have a null-check in l.169, so requiring non-null for the parameter should be ok. I think the same applies to mapCommand, please check that.", "author": "J-N-K", "createdAt": "2020-11-06T11:05:36Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private final ValueTransformationProvider valueTransformationProvider;\n+\n+    private @NonNullByDefault({}) Pattern devicePattern;\n+\n+    private @Nullable String data;\n+\n+    private final Map<ChannelUID, DeviceChannel> channels = new HashMap<>();\n+\n+    public SerialDeviceHandler(final Thing thing, final ValueTransformationProvider valueTransformationProvider) {\n+        super(thing);\n+        this.valueTransformationProvider = valueTransformationProvider;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            refresh(channelUID);\n+        } else {\n+            final DeviceChannel channel = channels.get(channelUID);\n+            if (channel != null) {\n+                final Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    final SerialBridgeHandler handler = (SerialBridgeHandler) bridge.getHandler();\n+                    if (handler != null) {\n+                        final String data = channel.mapCommand(command);\n+                        if (data != null) {\n+                            handler.writeString(data);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final SerialDeviceConfiguration config = getConfigAs(SerialDeviceConfiguration.class);\n+\n+        try {\n+            devicePattern = Pattern.compile(config.patternMatch);\n+        } catch (final PatternSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid device pattern: \" + e.getMessage());\n+            return;\n+        }\n+\n+        for (final Channel c : getThing().getChannels()) {\n+            final ChannelTypeUID type = c.getChannelTypeUID();\n+            if (type != null) {\n+                final ChannelConfig channelConfig = c.getConfiguration().as(ChannelConfig.class);\n+                try {\n+                    final DeviceChannel deviceChannel = DeviceChannelFactory\n+                            .createDeviceChannel(valueTransformationProvider, channelConfig, type.getId());\n+                    if (deviceChannel != null) {\n+                        channels.put(c.getUID(), deviceChannel);\n+                    }\n+                } catch (final IllegalArgumentException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configuration error for channel \" + c.getUID().getId() + \": \" + e.getMessage());\n+                    return;\n+                }\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        bridgeStatusChanged(getBridgeStatus());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        channels.clear();\n+        data = null;\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Handle a line of data received from the bridge\n+     *\n+     * @param data the line of data\n+     */\n+    public void handleData(final String data) {\n+        if (devicePattern.matcher(data).matches()) {\n+            this.data = data;\n+            channels.keySet().forEach(this::refresh);\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(final ThingStatusInfo bridgeStatusInfo) {\n+        if (getThing().getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+            return;\n+        }\n+\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE && getThing().getStatus() == ThingStatus.UNKNOWN) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            return;\n+        }\n+\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+    }\n+\n+    /**\n+     * Return the bridge status.\n+     */\n+    private ThingStatusInfo getBridgeStatus() {\n+        final Bridge b = getBridge();\n+        if (b != null) {\n+            return b.getStatusInfo();\n+        } else {\n+            return new ThingStatusInfo(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, null);\n+        }\n+    }\n+\n+    /**\n+     * Refreshes the channel with the last received data\n+     *\n+     * @param channelId the channel to refresh\n+     */\n+    private void refresh(final ChannelUID channelUID) {\n+        final String data = this.data;\n+\n+        if (data == null || !isLinked(channelUID)) {\n+            return;\n+        }\n+\n+        final DeviceChannel channel = channels.get(channelUID);\n+        if (channel != null) {\n+            final String state = channel.transformData(data);\n+\n+            if (state != null) {\n+                updateState(channelUID, new StringType(state));\n+            }\n+        }", "originalCommit": "451bcd026efd63ab68f55c600a70acf970312e85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b89e69f874e0282c544d6aba870f1f02623e9ab7", "url": "https://github.com/openhab/openhab-addons/commit/b89e69f874e0282c544d6aba870f1f02623e9ab7", "message": "Update transforms with review comments\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-11-08T09:34:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ0OTE1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519449155", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final ValueTransformation transform;\n          \n          \n            \n                private final ValueTransformation stateTransform;", "author": "J-N-K", "createdAt": "2020-11-08T16:46:12Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/channel/DeviceChannel.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.channel;\n+\n+import java.util.IllegalFormatException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.serial.internal.transform.ValueTransformation;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DeviceChannel} is the abstract class for handling a channel. Provides\n+ * the ability to transform the device data into the channel state.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class DeviceChannel {\n+    protected final Logger logger = LoggerFactory.getLogger(DeviceChannel.class);\n+\n+    protected final ChannelConfig config;\n+\n+    private final ValueTransformation transform;", "originalCommit": "b89e69f874e0282c544d6aba870f1f02623e9ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ0OTQwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519449407", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.debug(\"Mapped command is '{}'\", result.orElse(null));\n          \n          \n            \n                    logger.debug(\"Mapped command is '{}'\", result);\n          \n      \n    \n    \n  \n\nOptional.toString always contains the value", "author": "J-N-K", "createdAt": "2020-11-08T16:48:37Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/channel/DeviceChannel.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.channel;\n+\n+import java.util.IllegalFormatException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.serial.internal.transform.ValueTransformation;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DeviceChannel} is the abstract class for handling a channel. Provides\n+ * the ability to transform the device data into the channel state.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class DeviceChannel {\n+    protected final Logger logger = LoggerFactory.getLogger(DeviceChannel.class);\n+\n+    protected final ChannelConfig config;\n+\n+    private final ValueTransformation transform;\n+    private final ValueTransformation commandTransform;\n+\n+    protected DeviceChannel(final ValueTransformationProvider valueTransformationProvider, final ChannelConfig config) {\n+        this.config = config;\n+        transform = valueTransformationProvider.getValueTransformation(config.stateTransformation);\n+        commandTransform = valueTransformationProvider.getValueTransformation(config.commandTransformation);\n+    }\n+\n+    /**\n+     * Map the supplied command into the data to send to the device by\n+     * applying a format followed by a transform.\n+     * \n+     * @param command the command to map\n+     * @return the mapped data if the mapping produced a result.\n+     */\n+    public Optional<String> mapCommand(final Command command) {\n+        final Optional<String> result = transformCommand(formatCommand(command));\n+\n+        logger.debug(\"Mapped command is '{}'\", result.orElse(null));", "originalCommit": "b89e69f874e0282c544d6aba870f1f02623e9ab7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2NjkxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r520766919", "bodyText": "For cases when there is no value the result of just passing in the optional gives:\nMapped command is 'Optional.empty' which I don't think is as clear as  Mapped command is 'null'", "author": "MikeJMajor", "createdAt": "2020-11-10T18:08:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ0OTQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ0OTQ0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519449441", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Optional<String> transformData(final String data) {\n          \n          \n            \n                public Optional<String> transformState(final String data) {", "author": "J-N-K", "createdAt": "2020-11-08T16:49:01Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/channel/DeviceChannel.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.channel;\n+\n+import java.util.IllegalFormatException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.serial.internal.transform.ValueTransformation;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DeviceChannel} is the abstract class for handling a channel. Provides\n+ * the ability to transform the device data into the channel state.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class DeviceChannel {\n+    protected final Logger logger = LoggerFactory.getLogger(DeviceChannel.class);\n+\n+    protected final ChannelConfig config;\n+\n+    private final ValueTransformation transform;\n+    private final ValueTransformation commandTransform;\n+\n+    protected DeviceChannel(final ValueTransformationProvider valueTransformationProvider, final ChannelConfig config) {\n+        this.config = config;\n+        transform = valueTransformationProvider.getValueTransformation(config.stateTransformation);\n+        commandTransform = valueTransformationProvider.getValueTransformation(config.commandTransformation);\n+    }\n+\n+    /**\n+     * Map the supplied command into the data to send to the device by\n+     * applying a format followed by a transform.\n+     * \n+     * @param command the command to map\n+     * @return the mapped data if the mapping produced a result.\n+     */\n+    public Optional<String> mapCommand(final Command command) {\n+        final Optional<String> result = transformCommand(formatCommand(command));\n+\n+        logger.debug(\"Mapped command is '{}'\", result.orElse(null));\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Transform the data using the configured transform\n+     * \n+     * @param data the data to transform\n+     * @return the transformed data if the transform produced a result.\n+     */\n+    public Optional<String> transformData(final String data) {", "originalCommit": "b89e69f874e0282c544d6aba870f1f02623e9ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ0OTcxOA==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519449718", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.debug(\"Mapped command is '{}'\", result.orElse(null));\n          \n          \n            \n                    logger.debug(\"Mapped command is '{}'\", result);", "author": "J-N-K", "createdAt": "2020-11-08T16:50:59Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/channel/RollershutterChannel.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.channel;\n+\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StopMoveType;\n+import org.openhab.core.library.types.UpDownType;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link RollershutterChannel} channel provides mappings for the UP, DOWN and STOP commands\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RollershutterChannel extends DeviceChannel {\n+\n+    public RollershutterChannel(final ValueTransformationProvider valueTransformationProvider,\n+            final ChannelConfig config) {\n+        super(valueTransformationProvider, config);\n+    }\n+\n+    @Override\n+    public Optional<String> mapCommand(final Command command) {\n+        String data;\n+\n+        final String upValue = config.upValue;\n+        final String downValue = config.downValue;\n+        final String stopValue = config.stopValue;\n+\n+        if (command instanceof UpDownType) {\n+            if (upValue != null && UpDownType.UP.equals(command)) {\n+                data = upValue;\n+            } else if (downValue != null && UpDownType.DOWN.equals(command)) {\n+                data = downValue;\n+            } else {\n+                data = command.toFullString();\n+            }\n+        } else if (command instanceof StopMoveType) {\n+            if (stopValue != null && StopMoveType.STOP.equals(command)) {\n+                data = stopValue;\n+            } else {\n+                data = command.toFullString();\n+            }\n+        } else {\n+            data = formatCommand(command);\n+        }\n+\n+        final Optional<String> result = transformCommand(data);\n+\n+        logger.debug(\"Mapped command is '{}'\", result.orElse(null));", "originalCommit": "b89e69f874e0282c544d6aba870f1f02623e9ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ0OTc2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519449763", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.debug(\"Mapped command is '{}'\", result.orElse(null));\n          \n          \n            \n                    logger.debug(\"Mapped command is '{}'\", result.);", "author": "J-N-K", "createdAt": "2020-11-08T16:51:22Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/channel/SwitchChannel.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.channel;\n+\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link SwitchChannel} channel provides mappings for the ON and OFF commands\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SwitchChannel extends DeviceChannel {\n+\n+    public SwitchChannel(final ValueTransformationProvider valueTransformationProvider, final ChannelConfig config) {\n+        super(valueTransformationProvider, config);\n+    }\n+\n+    @Override\n+    public Optional<String> mapCommand(final Command command) {\n+        String data;\n+\n+        final String onValue = config.onValue;\n+        final String offValue = config.offValue;\n+\n+        if (onValue != null && OnOffType.ON.equals(command)) {\n+            data = onValue;\n+        } else if (offValue != null && OnOffType.OFF.equals(command)) {\n+            data = offValue;\n+        } else {\n+            data = command.toFullString();\n+        }\n+\n+        final Optional<String> result = transformCommand(data);\n+\n+        logger.debug(\"Mapped command is '{}'\", result.orElse(null));", "originalCommit": "b89e69f874e0282c544d6aba870f1f02623e9ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ0OTkxOA==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519449918", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"Mapped command is '{}'\", result.orElse(null));\n          \n          \n            \n                        logger.debug(\"Mapped command is '{}'\", result);", "author": "J-N-K", "createdAt": "2020-11-08T16:52:45Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/channel/DimmerChannel.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.channel;\n+\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link DimmerChannel} channel applies a format followed by a transform.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DimmerChannel extends SwitchChannel {\n+\n+    public DimmerChannel(final ValueTransformationProvider valueTransformationProvider, final ChannelConfig config) {\n+        super(valueTransformationProvider, config);\n+    }\n+\n+    @Override\n+    public Optional<String> mapCommand(final Command command) {\n+        Optional<String> result;\n+\n+        if (command instanceof OnOffType) {\n+            result = super.mapCommand(command);\n+        } else {\n+            String data;\n+\n+            final String increaseValue = config.increaseValue;\n+            final String decreaseValue = config.decreaseValue;\n+\n+            if (command instanceof IncreaseDecreaseType) {\n+                if (increaseValue != null && IncreaseDecreaseType.INCREASE.equals(command)) {\n+                    data = increaseValue;\n+                } else if (decreaseValue != null && IncreaseDecreaseType.DECREASE.equals(command)) {\n+                    data = decreaseValue;\n+                } else {\n+                    data = command.toFullString();\n+                }\n+            } else {\n+                data = formatCommand(command);\n+            }\n+\n+            result = transformCommand(data);\n+\n+            logger.debug(\"Mapped command is '{}'\", result.orElse(null));", "originalCommit": "b89e69f874e0282c544d6aba870f1f02623e9ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ1MDI2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519450267", "bodyText": "Wouldnt it be possible to remove the data field and pass result as a parameter to refresh? That's much more thread-safe.", "author": "J-N-K", "createdAt": "2020-11-08T16:55:42Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.BINARY_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.STRING_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.TRIGGER_CHANNEL;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.util.Base64;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.util.Parity;\n+import org.openhab.binding.serial.internal.util.StopBits;\n+import org.openhab.core.io.transport.serial.PortInUseException;\n+import org.openhab.core.io.transport.serial.SerialPort;\n+import org.openhab.core.io.transport.serial.SerialPortEvent;\n+import org.openhab.core.io.transport.serial.SerialPortEventListener;\n+import org.openhab.core.io.transport.serial.SerialPortIdentifier;\n+import org.openhab.core.io.transport.serial.SerialPortManager;\n+import org.openhab.core.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.CommonTriggerEvents;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SerialBridgeHandler} is responsible for handling commands, which\n+ * are sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends BaseBridgeHandler implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private SerialBridgeConfiguration config = new SerialBridgeConfiguration();\n+\n+    private final SerialPortManager serialPortManager;\n+    private @Nullable SerialPort serialPort;\n+\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private Charset charset = Charset.defaultCharset();\n+\n+    private @Nullable String data;\n+\n+    private final AtomicBoolean readerActive = new AtomicBoolean(false);\n+    private @Nullable ScheduledFuture<?> reader;\n+\n+    public SerialBridgeHandler(final Bridge bridge, final SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            refresh(channelUID.getId());\n+        } else {\n+            switch (channelUID.getId()) {\n+                case STRING_CHANNEL:\n+                    writeString(command.toFullString(), false);\n+                    break;\n+                case BINARY_CHANNEL:\n+                    writeString(command.toFullString(), true);\n+                    break;\n+                default:\n+                    break;\n+            }\n+\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SerialBridgeConfiguration.class);\n+\n+        try {\n+            if (config.charset != null) {\n+                charset = Charset.forName(config.charset);\n+            }\n+            logger.debug(\"Serial port '{}' charset '{}' set\", config.serialPort, charset);\n+        } catch (final IllegalCharsetNameException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Invalid charset\");\n+            return;\n+        }\n+\n+        final String port = config.serialPort;\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set\");\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        final SerialPortIdentifier portId = serialPortManager.getIdentifier(port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known\");\n+            return;\n+        }\n+\n+        // initialize serial port\n+        try {\n+            final SerialPort serialPort = portId.open(getThing().getUID().toString(), 2000);\n+            this.serialPort = serialPort;\n+\n+            serialPort.setSerialPortParams(config.baudRate, config.dataBits,\n+                    StopBits.fromConfig(config.stopBits).getSerialPortValue(),\n+                    Parity.fromConfig(config.parity).getSerialPortValue());\n+\n+            serialPort.addEventListener(this);\n+\n+            // activate the DATA_AVAILABLE notifier\n+            serialPort.notifyOnDataAvailable(true);\n+            inputStream = serialPort.getInputStream();\n+            outputStream = serialPort.getOutputStream();\n+\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error\");\n+        } catch (final PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use\");\n+        } catch (final TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port\");\n+        } catch (final UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unsupported port parameters: \" + e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final SerialPort serialPort = this.serialPort;\n+        if (serialPort != null) {\n+            serialPort.removeEventListener();\n+            serialPort.close();\n+            this.serialPort = null;\n+        }\n+\n+        final InputStream inputStream = this.inputStream;\n+        if (inputStream != null) {\n+            try {\n+                inputStream.close();\n+            } catch (final IOException e) {\n+                logger.debug(\"Error while closing the input stream: {}\", e.getMessage());\n+            }\n+            this.inputStream = null;\n+        }\n+\n+        final OutputStream outputStream = this.outputStream;\n+        if (outputStream != null) {\n+            try {\n+                outputStream.close();\n+            } catch (final IOException e) {\n+                logger.debug(\"Error while closing the output stream: {}\", e.getMessage());\n+            }\n+            this.outputStream = null;\n+        }\n+\n+        readerActive.set(false);\n+        final ScheduledFuture<?> reader = this.reader;\n+        if (reader != null) {\n+            reader.cancel(false);\n+            this.reader = null;\n+        }\n+\n+        data = null;\n+    }\n+\n+    @Override\n+    public void serialEvent(final SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                if (readerActive.compareAndSet(false, true)) {\n+                    reader = scheduler.schedule(() -> receiveAndProcess(new StringBuilder(), true), 0,\n+                            TimeUnit.MILLISECONDS);\n+                }\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Sends a string to the serial port.\n+     *\n+     * @param string the string to send\n+     */\n+    public void writeString(final String string) {\n+        writeString(string, false);\n+    }\n+\n+    /**\n+     * Refreshes the channel with the last received data\n+     *\n+     * @param channelId the channel to refresh\n+     */\n+    private void refresh(final String channelId) {\n+        final String data = this.data;\n+\n+        if (data == null || !isLinked(channelId)) {\n+            return;\n+        }\n+\n+        switch (channelId) {\n+            case STRING_CHANNEL:\n+                updateState(channelId, new StringType(data));\n+                break;\n+            case BINARY_CHANNEL:\n+                final StringBuilder sb = new StringBuilder(\"data:\");\n+                sb.append(RawType.DEFAULT_MIME_TYPE).append(\";base64,\")\n+                        .append(Base64.getEncoder().encodeToString(data.getBytes(charset)));\n+                updateState(channelId, new StringType(sb.toString()));\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Read from the serial port and process the data\n+     * \n+     * @param sb the string builder to receive the data\n+     * @param firstAttempt indicates if this is the first read attempt without waiting\n+     */\n+    private void receiveAndProcess(final StringBuilder sb, final boolean firstAttempt) {\n+        final InputStream inputStream = this.inputStream;\n+\n+        if (inputStream == null) {\n+            readerActive.set(false);\n+            return;\n+        }\n+\n+        try {\n+            if (firstAttempt || inputStream.available() > 0) {\n+                final byte[] readBuffer = new byte[20];\n+\n+                // read data from serial device\n+                while (inputStream.available() > 0) {\n+                    final int bytes = inputStream.read(readBuffer);\n+                    sb.append(new String(readBuffer, 0, bytes, charset));\n+                }\n+\n+                // Add wait states around reading the stream, so that interrupted transmissions\n+                // are merged\n+                if (readerActive.get()) {\n+                    reader = scheduler.schedule(() -> receiveAndProcess(sb, false), 100, TimeUnit.MILLISECONDS);\n+                }\n+\n+            } else {\n+                final String result = sb.toString();\n+                data = result;", "originalCommit": "b89e69f874e0282c544d6aba870f1f02623e9ab7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ1NjQwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519456404", "bodyText": "I'm using the data field to have access to the last received data to handle a refresh command. If I don't have the data field I can ignore the refresh command?", "author": "MikeJMajor", "createdAt": "2020-11-08T17:49:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ1MDI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ1ODYwNg==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519458606", "bodyText": "Good point. I would suggest to use the parameter nevertheless and store it in the field additionally. You can then use that to pass it when REFRESH is called.\nThis of course means that you must keep a refresh method in the ThingHandler below. I have edited my suggestions there. You could do something similar here.", "author": "J-N-K", "createdAt": "2020-11-08T18:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ1MDI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ1MDQ2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519450467", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNullByDefault({}) Pattern devicePattern;\n          \n          \n            \n                private @Nullable Pattern devicePattern;\n          \n      \n    \n    \n  \n\nunfortunately the decision was to use that only for injected OSGi-services.", "author": "J-N-K", "createdAt": "2020-11-08T16:57:18Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private final ValueTransformationProvider valueTransformationProvider;\n+\n+    private @NonNullByDefault({}) Pattern devicePattern;", "originalCommit": "b89e69f874e0282c544d6aba870f1f02623e9ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ1MDc1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519450752", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void handleData(final String data) {\n          \n          \n            \n                    if (devicePattern.matcher(data).matches()) {\n          \n          \n            \n                        this.data = data;\n          \n          \n            \n                        channels.keySet().forEach(this::refresh);\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                public void handleData(final String data) {\n          \n          \n            \n                    if (devicePattern.matcher(data).matches()) {\n          \n          \n            \n                        channels.forEach((channelUID, channel) -> refresh(channelUID, channel, value));\n          \n          \n            \n                        this.lastValue = value;\n          \n          \n            \n                    }\n          \n          \n            \n                }", "author": "J-N-K", "createdAt": "2020-11-08T16:59:48Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private final ValueTransformationProvider valueTransformationProvider;\n+\n+    private @NonNullByDefault({}) Pattern devicePattern;\n+\n+    private @Nullable String data;\n+\n+    private final Map<ChannelUID, DeviceChannel> channels = new HashMap<>();\n+\n+    public SerialDeviceHandler(final Thing thing, final ValueTransformationProvider valueTransformationProvider) {\n+        super(thing);\n+        this.valueTransformationProvider = valueTransformationProvider;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            refresh(channelUID);\n+        } else {\n+            final DeviceChannel channel = channels.get(channelUID);\n+            if (channel != null) {\n+                final Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    final SerialBridgeHandler handler = (SerialBridgeHandler) bridge.getHandler();\n+                    if (handler != null) {\n+                        channel.mapCommand(command).ifPresent(value -> handler.writeString(value));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final SerialDeviceConfiguration config = getConfigAs(SerialDeviceConfiguration.class);\n+\n+        try {\n+            devicePattern = Pattern.compile(config.patternMatch);\n+        } catch (final PatternSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid device pattern: \" + e.getMessage());\n+            return;\n+        }\n+\n+        for (final Channel c : getThing().getChannels()) {\n+            final ChannelTypeUID type = c.getChannelTypeUID();\n+            if (type != null) {\n+                final ChannelConfig channelConfig = c.getConfiguration().as(ChannelConfig.class);\n+                try {\n+                    final DeviceChannel deviceChannel = DeviceChannelFactory\n+                            .createDeviceChannel(valueTransformationProvider, channelConfig, type.getId());\n+                    if (deviceChannel != null) {\n+                        channels.put(c.getUID(), deviceChannel);\n+                    }\n+                } catch (final IllegalArgumentException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configuration error for channel \" + c.getUID().getId() + \": \" + e.getMessage());\n+                    return;\n+                }\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        bridgeStatusChanged(getBridgeStatus());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        channels.clear();\n+        data = null;\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Handle a line of data received from the bridge\n+     *\n+     * @param data the line of data\n+     */\n+    public void handleData(final String data) {\n+        if (devicePattern.matcher(data).matches()) {\n+            this.data = data;\n+            channels.keySet().forEach(this::refresh);\n+        }\n+    }", "originalCommit": "b89e69f874e0282c544d6aba870f1f02623e9ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ1ODY1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519458651", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable String data;\n          \n          \n            \n                private @Nullable String lastValue;", "author": "J-N-K", "createdAt": "2020-11-08T18:11:31Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private final ValueTransformationProvider valueTransformationProvider;\n+\n+    private @NonNullByDefault({}) Pattern devicePattern;\n+\n+    private @Nullable String data;", "originalCommit": "b89e69f874e0282c544d6aba870f1f02623e9ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ1ODc5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519458797", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (command instanceof RefreshType) {\n          \n          \n            \n                        refresh(channelUID);\n          \n          \n            \n                    } else {\n          \n          \n            \n                    if (command instanceof RefreshType) {\n          \n          \n            \n                        DeviceChannel channel = channels.get(channelUID);\n          \n          \n            \n                        String lastValue = this,lastValue;\n          \n          \n            \n                        if (channel != null) {\n          \n          \n            \n                            refresh(channelUID, channel, lastValue);\n          \n          \n            \n                        }\n          \n          \n            \n                    } else {", "author": "J-N-K", "createdAt": "2020-11-08T18:13:11Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private final ValueTransformationProvider valueTransformationProvider;\n+\n+    private @NonNullByDefault({}) Pattern devicePattern;\n+\n+    private @Nullable String data;\n+\n+    private final Map<ChannelUID, DeviceChannel> channels = new HashMap<>();\n+\n+    public SerialDeviceHandler(final Thing thing, final ValueTransformationProvider valueTransformationProvider) {\n+        super(thing);\n+        this.valueTransformationProvider = valueTransformationProvider;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            refresh(channelUID);\n+        } else {", "originalCommit": "b89e69f874e0282c544d6aba870f1f02623e9ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ1OTEwNg==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519459106", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void refresh(final ChannelUID channelUID) {\n          \n          \n            \n                    final String data = this.data;\n          \n          \n            \n            \n          \n          \n            \n                    if (data == null || !isLinked(channelUID)) {\n          \n          \n            \n                        return;\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    final DeviceChannel channel = channels.get(channelUID);\n          \n          \n            \n                    if (channel != null) {\n          \n          \n            \n                        channel.transformData(data).ifPresent(value -> updateState(channelUID, new StringType(value)));\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                private void refresh(ChannelUID channelUID, DeviceChannel channel, @Nullable String value) {\n          \n          \n            \n                    if (isLinked(channelUID) && value != null) {\n          \n          \n            \n                        channel.transformData(data).ifPresent(value -> updateState(channelUID, new StringType(value)));\n          \n          \n            \n                    }\n          \n          \n            \n                }", "author": "J-N-K", "createdAt": "2020-11-08T18:16:00Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private final ValueTransformationProvider valueTransformationProvider;\n+\n+    private @NonNullByDefault({}) Pattern devicePattern;\n+\n+    private @Nullable String data;\n+\n+    private final Map<ChannelUID, DeviceChannel> channels = new HashMap<>();\n+\n+    public SerialDeviceHandler(final Thing thing, final ValueTransformationProvider valueTransformationProvider) {\n+        super(thing);\n+        this.valueTransformationProvider = valueTransformationProvider;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            refresh(channelUID);\n+        } else {\n+            final DeviceChannel channel = channels.get(channelUID);\n+            if (channel != null) {\n+                final Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    final SerialBridgeHandler handler = (SerialBridgeHandler) bridge.getHandler();\n+                    if (handler != null) {\n+                        channel.mapCommand(command).ifPresent(value -> handler.writeString(value));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final SerialDeviceConfiguration config = getConfigAs(SerialDeviceConfiguration.class);\n+\n+        try {\n+            devicePattern = Pattern.compile(config.patternMatch);\n+        } catch (final PatternSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid device pattern: \" + e.getMessage());\n+            return;\n+        }\n+\n+        for (final Channel c : getThing().getChannels()) {\n+            final ChannelTypeUID type = c.getChannelTypeUID();\n+            if (type != null) {\n+                final ChannelConfig channelConfig = c.getConfiguration().as(ChannelConfig.class);\n+                try {\n+                    final DeviceChannel deviceChannel = DeviceChannelFactory\n+                            .createDeviceChannel(valueTransformationProvider, channelConfig, type.getId());\n+                    if (deviceChannel != null) {\n+                        channels.put(c.getUID(), deviceChannel);\n+                    }\n+                } catch (final IllegalArgumentException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configuration error for channel \" + c.getUID().getId() + \": \" + e.getMessage());\n+                    return;\n+                }\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        bridgeStatusChanged(getBridgeStatus());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        channels.clear();\n+        data = null;\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Handle a line of data received from the bridge\n+     *\n+     * @param data the line of data\n+     */\n+    public void handleData(final String data) {\n+        if (devicePattern.matcher(data).matches()) {\n+            this.data = data;\n+            channels.keySet().forEach(this::refresh);\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(final ThingStatusInfo bridgeStatusInfo) {\n+        if (getThing().getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+            return;\n+        }\n+\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE && getThing().getStatus() == ThingStatus.UNKNOWN) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            return;\n+        }\n+\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+    }\n+\n+    /**\n+     * Return the bridge status.\n+     */\n+    private ThingStatusInfo getBridgeStatus() {\n+        final Bridge b = getBridge();\n+        if (b != null) {\n+            return b.getStatusInfo();\n+        } else {\n+            return new ThingStatusInfo(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, null);\n+        }\n+    }\n+\n+    /**\n+     * Refreshes the channel with the last received data\n+     *\n+     * @param channelId the channel to refresh\n+     */\n+    private void refresh(final ChannelUID channelUID) {\n+        final String data = this.data;\n+\n+        if (data == null || !isLinked(channelUID)) {\n+            return;\n+        }\n+\n+        final DeviceChannel channel = channels.get(channelUID);\n+        if (channel != null) {\n+            channel.transformData(data).ifPresent(value -> updateState(channelUID, new StringType(value)));\n+        }\n+    }", "originalCommit": "b89e69f874e0282c544d6aba870f1f02623e9ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b", "url": "https://github.com/openhab/openhab-addons/commit/ced376cd67d3f5529e1317783162c5410ac0d47b", "message": "Minor changes following further review comments\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-11-10T18:18:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNjc5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r523806790", "bodyText": "To have the same behavior across all platforms and configurations, I'd use a static charset here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Charset charset = Charset.defaultCharset();\n          \n          \n            \n                private Charset charset = StandardCharsets.UTF_8;", "author": "fwolter", "createdAt": "2020-11-15T20:07:36Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,342 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.BINARY_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.STRING_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.TRIGGER_CHANNEL;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.util.Base64;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.util.Parity;\n+import org.openhab.binding.serial.internal.util.StopBits;\n+import org.openhab.core.io.transport.serial.PortInUseException;\n+import org.openhab.core.io.transport.serial.SerialPort;\n+import org.openhab.core.io.transport.serial.SerialPortEvent;\n+import org.openhab.core.io.transport.serial.SerialPortEventListener;\n+import org.openhab.core.io.transport.serial.SerialPortIdentifier;\n+import org.openhab.core.io.transport.serial.SerialPortManager;\n+import org.openhab.core.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.CommonTriggerEvents;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SerialBridgeHandler} is responsible for handling commands, which\n+ * are sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends BaseBridgeHandler implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private SerialBridgeConfiguration config = new SerialBridgeConfiguration();\n+\n+    private final SerialPortManager serialPortManager;\n+    private @Nullable SerialPort serialPort;\n+\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private Charset charset = Charset.defaultCharset();", "originalCommit": "ced376cd67d3f5529e1317783162c5410ac0d47b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNzYwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r523807609", "bodyText": "Why is the bridge status updated when the thing has been initialized?", "author": "fwolter", "createdAt": "2020-11-15T20:14:35Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private final ValueTransformationProvider valueTransformationProvider;\n+\n+    private @Nullable Pattern devicePattern;\n+\n+    private @Nullable String lastValue;\n+\n+    private final Map<ChannelUID, DeviceChannel> channels = new HashMap<>();\n+\n+    public SerialDeviceHandler(final Thing thing, final ValueTransformationProvider valueTransformationProvider) {\n+        super(thing);\n+        this.valueTransformationProvider = valueTransformationProvider;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            final String lastValue = this.lastValue;\n+\n+            if (lastValue != null) {\n+                final DeviceChannel channel = channels.get(channelUID);\n+                if (channel != null) {\n+                    refresh(channelUID, channel, lastValue);\n+                }\n+            }\n+        } else {\n+            final DeviceChannel channel = channels.get(channelUID);\n+            if (channel != null) {\n+                final Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    final SerialBridgeHandler handler = (SerialBridgeHandler) bridge.getHandler();\n+                    if (handler != null) {\n+                        channel.mapCommand(command).ifPresent(value -> handler.writeString(value));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final SerialDeviceConfiguration config = getConfigAs(SerialDeviceConfiguration.class);\n+\n+        try {\n+            devicePattern = Pattern.compile(config.patternMatch);\n+        } catch (final PatternSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid device pattern: \" + e.getMessage());\n+            return;\n+        }\n+\n+        for (final Channel c : getThing().getChannels()) {\n+            final ChannelTypeUID type = c.getChannelTypeUID();\n+            if (type != null) {\n+                final ChannelConfig channelConfig = c.getConfiguration().as(ChannelConfig.class);\n+                try {\n+                    final DeviceChannel deviceChannel = DeviceChannelFactory\n+                            .createDeviceChannel(valueTransformationProvider, channelConfig, type.getId());\n+                    if (deviceChannel != null) {\n+                        channels.put(c.getUID(), deviceChannel);\n+                    }\n+                } catch (final IllegalArgumentException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configuration error for channel \" + c.getUID().getId() + \": \" + e.getMessage());\n+                    return;\n+                }\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        bridgeStatusChanged(getBridgeStatus());", "originalCommit": "ced376cd67d3f5529e1317783162c5410ac0d47b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgxMTA3NA==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r523811074", "bodyText": "In fact this sets the thing status depending on the bridge status by calling bridgeStatusChanged with the current bridge status. The other option would be to duplicate the code from bridgeStatusChanged here.", "author": "J-N-K", "createdAt": "2020-11-15T20:44:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNzYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNzc3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r523807772", "bodyText": "The BaseThingHandler sets the Thing states accordingly when the bridge status changes. Is this method necessary?", "author": "fwolter", "createdAt": "2020-11-15T20:15:53Z", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private final ValueTransformationProvider valueTransformationProvider;\n+\n+    private @Nullable Pattern devicePattern;\n+\n+    private @Nullable String lastValue;\n+\n+    private final Map<ChannelUID, DeviceChannel> channels = new HashMap<>();\n+\n+    public SerialDeviceHandler(final Thing thing, final ValueTransformationProvider valueTransformationProvider) {\n+        super(thing);\n+        this.valueTransformationProvider = valueTransformationProvider;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            final String lastValue = this.lastValue;\n+\n+            if (lastValue != null) {\n+                final DeviceChannel channel = channels.get(channelUID);\n+                if (channel != null) {\n+                    refresh(channelUID, channel, lastValue);\n+                }\n+            }\n+        } else {\n+            final DeviceChannel channel = channels.get(channelUID);\n+            if (channel != null) {\n+                final Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    final SerialBridgeHandler handler = (SerialBridgeHandler) bridge.getHandler();\n+                    if (handler != null) {\n+                        channel.mapCommand(command).ifPresent(value -> handler.writeString(value));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final SerialDeviceConfiguration config = getConfigAs(SerialDeviceConfiguration.class);\n+\n+        try {\n+            devicePattern = Pattern.compile(config.patternMatch);\n+        } catch (final PatternSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid device pattern: \" + e.getMessage());\n+            return;\n+        }\n+\n+        for (final Channel c : getThing().getChannels()) {\n+            final ChannelTypeUID type = c.getChannelTypeUID();\n+            if (type != null) {\n+                final ChannelConfig channelConfig = c.getConfiguration().as(ChannelConfig.class);\n+                try {\n+                    final DeviceChannel deviceChannel = DeviceChannelFactory\n+                            .createDeviceChannel(valueTransformationProvider, channelConfig, type.getId());\n+                    if (deviceChannel != null) {\n+                        channels.put(c.getUID(), deviceChannel);\n+                    }\n+                } catch (final IllegalArgumentException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configuration error for channel \" + c.getUID().getId() + \": \" + e.getMessage());\n+                    return;\n+                }\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        bridgeStatusChanged(getBridgeStatus());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        channels.clear();\n+        lastValue = null;\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Handle a line of data received from the bridge\n+     *\n+     * @param data the line of data\n+     */\n+    public void handleData(final String data) {\n+        final Pattern devicePattern = this.devicePattern;\n+\n+        if (devicePattern != null && devicePattern.matcher(data).matches()) {\n+            channels.forEach((channelUID, channel) -> refresh(channelUID, channel, data));\n+            this.lastValue = data;\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(final ThingStatusInfo bridgeStatusInfo) {\n+        if (getThing().getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+            return;\n+        }\n+\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE && getThing().getStatus() == ThingStatus.UNKNOWN) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            return;\n+        }\n+\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+    }", "originalCommit": "ced376cd67d3f5529e1317783162c5410ac0d47b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzkzNDcxNA==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r523934714", "bodyText": "This is preventing the thing from going online if there is a thing level configuration error.", "author": "MikeJMajor", "createdAt": "2020-11-16T07:14:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNzc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk0Mzg4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r523943887", "bodyText": "I understood that the Thing should be online when there's no configuration error and the Bridge is online.\nThis behavior can be achieved by using the framework. You can set the Thing status to ONLINE when there is no configuration error. Then, the framework takes care, that the Thing is only online when the Bridge is.", "author": "fwolter", "createdAt": "2020-11-16T07:39:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNzc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAwMjEyNg==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r524002126", "bodyText": "It seems the framework only takes care of it if you explicitly check the bridge status and don't put the thing online if the bridge is offline. The framework allows you to set the thing online even though the bridge is offline. I'll make that change since its cleaner not overriding bridgeStatusChanged.", "author": "MikeJMajor", "createdAt": "2020-11-16T09:11:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNzc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0Mzk2NA==", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r524043964", "bodyText": "From my knowledge the Thing doesn't go online when the bridge is offline, although if the binding sets it explicitly to online. But I'm open for conviction.", "author": "fwolter", "createdAt": "2020-11-16T09:48:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNzc3Mg=="}], "type": "inlineReview"}, {"oid": "53da7c2ed1dbbcfcc4af57ce0af1529ada644002", "url": "https://github.com/openhab/openhab-addons/commit/53da7c2ed1dbbcfcc4af57ce0af1529ada644002", "message": "Further review changes\n\nSigned-off-by: Mike Major <mike_j_major@hotmail.com>", "committedDate": "2020-11-16T17:26:51Z", "type": "commit"}]}