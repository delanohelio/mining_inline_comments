{"pr_number": 7504, "pr_title": "[gree] Initial contribution", "pr_createdAt": "2020-04-29T19:24:24Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7504", "timeline": [{"oid": "15f2e7894ec1eb4b8751bb9f700e61b9ad064564", "url": "https://github.com/openhab/openhab-addons/commit/15f2e7894ec1eb4b8751bb9f700e61b9ad064564", "message": "ignore SocketTimeoutException on background status refresh\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-04-29T19:37:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk2NjgyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r417966829", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"Thing not properlyx initialized, abort command\");\n          \n          \n            \n                            logger.debug(\"Thing not properly initialized, abort command\");", "author": "alexander-po", "createdAt": "2020-04-30T12:18:37Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,327 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properlyx initialized, abort command\");", "originalCommit": "00967f38a5cd39ebe849516fbce526c40c51096f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE0NjI5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r418146296", "bodyText": "fixed", "author": "markus7017", "createdAt": "2020-04-30T16:44:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk2NjgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAxMzQ0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r418013441", "bodyText": "I think we should update channels when we don't have the previous value (set initial state of items).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return false;\n          \n          \n            \n                        return true;", "author": "alexander-po", "createdAt": "2020-04-30T13:34:55Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,687 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Air\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceDry(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Blo\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceHealth(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Health\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SvSt\", value);\r\n+        parameters.put(\"WdSpd\", new Integer(0));\r\n+        parameters.put(\"Quiet\", new Integer(0));\r\n+        parameters.put(\"Tur\", new Integer(0));\r\n+        parameters.put(\"SwhSlp\", new Integer(0));\r\n+        parameters.put(\"SlpMod\", new Integer(0));\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getIntStatusVal(String valueName) {\r\n+        /*\r\n+         * Note : Values can be:\r\n+         * \"Pow\": Power (0 or 1)\r\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\r\n+         * \"SetTem\": Requested Temperature\r\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\r\n+         * \"Air\": Air Mode Enabled\r\n+         * \"Blo\": Dry\r\n+         * \"Health\": Health\r\n+         * \"SwhSlp\": Sleep\r\n+         * \"SlpMod\": ???\r\n+         * \"Lig\": Light On\r\n+         * \"SwingLfRig\": Swing Left Right\r\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\r\n+         * \"Quiet\": Quiet mode\r\n+         * \"Tur\": Turbo\r\n+         * \"StHt\": 0,\r\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\r\n+         * \"HeatCoolType\"\r\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\r\n+         * temp\r\n+         * \"SvSt\": Power Saving\r\n+         */\r\n+        // Find the valueName in the Returned Status object\r\n+        String columns[] = statusResponseGson.packJson.cols;\r\n+        Integer values[] = statusResponseGson.packJson.dat;\r\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\r\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));\r\n+        int valueArrayposition = colList.indexOf(valueName);\r\n+        if (valueArrayposition == -1) {\r\n+            return -1;\r\n+        }\r\n+\r\n+        // Now get the Corresponding value\r\n+        Integer value = valList.get(valueArrayposition);\r\n+        return value;\r\n+    }\r\n+\r\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\r\n+        if (prevStatusResponsePackGson == null) {\r\n+            return false;\r", "originalCommit": "00967f38a5cd39ebe849516fbce526c40c51096f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE0NzM1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r418147351", "bodyText": "yep, makes sense", "author": "markus7017", "createdAt": "2020-04-30T16:45:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAxMzQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NDkwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432874902", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            + String.valueOf(refresh);\n          \n          \n            \n                            + refresh;", "author": "fwolter", "createdAt": "2020-05-30T18:06:04Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeConfiguration.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link GreeConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeConfiguration {\n+    public String ipAddress = \"\";\n+    public String broadcastAddress = \"\";\n+    public int refresh = 60;\n+\n+    @Override\n+    public String toString() {\n+        return \"Config: ipAddress=\" + ipAddress + \", broadcastAddress=\" + broadcastAddress + \", refresh=\"\n+                + String.valueOf(refresh);", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxNjcwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432916708", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-05-31T06:59:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NDkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NTUwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432875502", "bodyText": "This should be private static final and the name uppercase.", "author": "fwolter", "createdAt": "2020-05-30T18:14:32Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeCryptoUtil.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal;\r\n+\r\n+import java.security.Key;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+\r\n+/**\r\n+ * The CryptoUtil class provides functionality for encrypting and decrypting\r\n+ * messages sent to and from the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+@NonNullByDefault\r\n+public class GreeCryptoUtil {\r\n+    static String AES_General_Key = \"a3K8Bx%2r8Y7#xDh\";\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxNjg2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432916863", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-05-31T07:01:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NTUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NTU2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432875560", "bodyText": "Methods should start with a lowercase character.", "author": "fwolter", "createdAt": "2020-05-30T18:15:09Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeCryptoUtil.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal;\r\n+\r\n+import java.security.Key;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+\r\n+/**\r\n+ * The CryptoUtil class provides functionality for encrypting and decrypting\r\n+ * messages sent to and from the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+@NonNullByDefault\r\n+public class GreeCryptoUtil {\r\n+    static String AES_General_Key = \"a3K8Bx%2r8Y7#xDh\";\r\n+\r\n+    public static String GetAESGeneralKey() {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxNzAxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432917014", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-05-31T07:03:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NTU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NTU3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432875573", "bodyText": "See above.", "author": "fwolter", "createdAt": "2020-05-30T18:15:17Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeCryptoUtil.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal;\r\n+\r\n+import java.security.Key;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+\r\n+/**\r\n+ * The CryptoUtil class provides functionality for encrypting and decrypting\r\n+ * messages sent to and from the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+@NonNullByDefault\r\n+public class GreeCryptoUtil {\r\n+    static String AES_General_Key = \"a3K8Bx%2r8Y7#xDh\";\r\n+\r\n+    public static String GetAESGeneralKey() {\r\n+        return AES_General_Key;\r\n+    }\r\n+\r\n+    public static byte[] GetAESGeneralKeyByteArray() {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxNzAyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432917027", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-05-31T07:03:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NTU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NTY3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432875677", "bodyText": "Is the commented-out code necessary?", "author": "fwolter", "createdAt": "2020-05-30T18:16:52Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeCryptoUtil.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal;\r\n+\r\n+import java.security.Key;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+\r\n+/**\r\n+ * The CryptoUtil class provides functionality for encrypting and decrypting\r\n+ * messages sent to and from the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+@NonNullByDefault\r\n+public class GreeCryptoUtil {\r\n+    static String AES_General_Key = \"a3K8Bx%2r8Y7#xDh\";\r\n+\r\n+    public static String GetAESGeneralKey() {\r\n+        return AES_General_Key;\r\n+    }\r\n+\r\n+    public static byte[] GetAESGeneralKeyByteArray() {\r\n+        return AES_General_Key.getBytes();\r\n+    }\r\n+\r\n+    public static String decryptPack(byte[] keyarray, String message) throws GreeException {\r\n+        try {\r\n+            Key key = new SecretKeySpec(keyarray, \"AES\");\r\n+            // BASE64Decoder decoder = new BASE64Decoder();\r\n+            Base64.Decoder decoder = Base64.getDecoder();\r\n+            // Decoder decoder = new Decoder();\r\n+            byte[] imageByte = decoder.decode(message);\r\n+            // byte[] imageByte = decoder.decodeBuffer(message);\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxNzA2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432917062", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-05-31T07:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NTY3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NTk1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432875959", "bodyText": "You should specify the expected charset in the constructor, to not rely on the system charset.", "author": "fwolter", "createdAt": "2020-05-30T18:20:40Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeCryptoUtil.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal;\r\n+\r\n+import java.security.Key;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+\r\n+/**\r\n+ * The CryptoUtil class provides functionality for encrypting and decrypting\r\n+ * messages sent to and from the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+@NonNullByDefault\r\n+public class GreeCryptoUtil {\r\n+    static String AES_General_Key = \"a3K8Bx%2r8Y7#xDh\";\r\n+\r\n+    public static String GetAESGeneralKey() {\r\n+        return AES_General_Key;\r\n+    }\r\n+\r\n+    public static byte[] GetAESGeneralKeyByteArray() {\r\n+        return AES_General_Key.getBytes();\r\n+    }\r\n+\r\n+    public static String decryptPack(byte[] keyarray, String message) throws GreeException {\r\n+        try {\r\n+            Key key = new SecretKeySpec(keyarray, \"AES\");\r\n+            // BASE64Decoder decoder = new BASE64Decoder();\r\n+            Base64.Decoder decoder = Base64.getDecoder();\r\n+            // Decoder decoder = new Decoder();\r\n+            byte[] imageByte = decoder.decode(message);\r\n+            // byte[] imageByte = decoder.decodeBuffer(message);\r\n+\r\n+            Cipher aesCipher = Cipher.getInstance(\"AES\");\r\n+            aesCipher.init(Cipher.DECRYPT_MODE, key);\r\n+            byte[] bytePlainText = aesCipher.doFinal(imageByte);\r\n+\r\n+            return new String(bytePlainText);\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxNzI0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432917248", "bodyText": "\"UTF-8\" added", "author": "markus7017", "createdAt": "2020-05-31T07:06:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NTk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NjA0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432876043", "bodyText": "Better catch the exceptions you expect explicitly.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch (Exception ex) {\n          \n          \n            \n                    } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {", "author": "fwolter", "createdAt": "2020-05-30T18:22:01Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeCryptoUtil.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal;\r\n+\r\n+import java.security.Key;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+\r\n+/**\r\n+ * The CryptoUtil class provides functionality for encrypting and decrypting\r\n+ * messages sent to and from the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+@NonNullByDefault\r\n+public class GreeCryptoUtil {\r\n+    static String AES_General_Key = \"a3K8Bx%2r8Y7#xDh\";\r\n+\r\n+    public static String GetAESGeneralKey() {\r\n+        return AES_General_Key;\r\n+    }\r\n+\r\n+    public static byte[] GetAESGeneralKeyByteArray() {\r\n+        return AES_General_Key.getBytes();\r\n+    }\r\n+\r\n+    public static String decryptPack(byte[] keyarray, String message) throws GreeException {\r\n+        try {\r\n+            Key key = new SecretKeySpec(keyarray, \"AES\");\r\n+            // BASE64Decoder decoder = new BASE64Decoder();\r\n+            Base64.Decoder decoder = Base64.getDecoder();\r\n+            // Decoder decoder = new Decoder();\r\n+            byte[] imageByte = decoder.decode(message);\r\n+            // byte[] imageByte = decoder.decodeBuffer(message);\r\n+\r\n+            Cipher aesCipher = Cipher.getInstance(\"AES\");\r\n+            aesCipher.init(Cipher.DECRYPT_MODE, key);\r\n+            byte[] bytePlainText = aesCipher.doFinal(imageByte);\r\n+\r\n+            return new String(bytePlainText);\r\n+        } catch (Exception ex) {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxNzQwNw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432917407", "bodyText": "done", "author": "markus7017", "createdAt": "2020-05-31T07:09:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NjA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NjgzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432876838", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T18:32:43Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeCryptoUtil.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal;\r\n+\r\n+import java.security.Key;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+\r\n+/**\r\n+ * The CryptoUtil class provides functionality for encrypting and decrypting\r\n+ * messages sent to and from the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+@NonNullByDefault\r\n+public class GreeCryptoUtil {\r\n+    static String AES_General_Key = \"a3K8Bx%2r8Y7#xDh\";\r\n+\r\n+    public static String GetAESGeneralKey() {\r\n+        return AES_General_Key;\r\n+    }\r\n+\r\n+    public static byte[] GetAESGeneralKeyByteArray() {\r\n+        return AES_General_Key.getBytes();\r\n+    }\r\n+\r\n+    public static String decryptPack(byte[] keyarray, String message) throws GreeException {\r\n+        try {\r\n+            Key key = new SecretKeySpec(keyarray, \"AES\");\r\n+            // BASE64Decoder decoder = new BASE64Decoder();\r\n+            Base64.Decoder decoder = Base64.getDecoder();\r\n+            // Decoder decoder = new Decoder();\r\n+            byte[] imageByte = decoder.decode(message);\r\n+            // byte[] imageByte = decoder.decodeBuffer(message);\r\n+\r\n+            Cipher aesCipher = Cipher.getInstance(\"AES\");\r\n+            aesCipher.init(Cipher.DECRYPT_MODE, key);\r\n+            byte[] bytePlainText = aesCipher.doFinal(imageByte);\r\n+\r\n+            return new String(bytePlainText);\r\n+        } catch (Exception ex) {\r\n+            throw new GreeException(ex, \"Decryption of recieved data failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public static String encryptPack(byte[] keyarray, String message) throws GreeException {\r\n+        try {\r\n+            Key key = new SecretKeySpec(keyarray, \"AES\");\r\n+            Cipher aesCipher = Cipher.getInstance(\"AES\");\r\n+            aesCipher.init(Cipher.ENCRYPT_MODE, key);\r\n+            byte[] bytePlainText = aesCipher.doFinal(message.getBytes());\r\n+\r\n+            Base64.Encoder newencoder = Base64.getEncoder();\r\n+            String encrytpedMessage = new String(newencoder.encode(bytePlainText));\r\n+            return encrytpedMessage.substring(0, encrytpedMessage.length());\r\n+        } catch (Exception ex) {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxNzQzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432917431", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-05-31T07:09:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NjgzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NzM5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432877394", "bodyText": "This method is never called.", "author": "fwolter", "createdAt": "2020-05-30T18:39:26Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeHandlerFactory.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.util.Hashtable;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.binding.gree.internal.discovery.GreeDiscoveryService;\n+import org.openhab.binding.gree.internal.handler.GreeHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link GreeHandlerFactory} is responsible for creating things and thing handlers.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.\" + BINDING_ID, service = ThingHandlerFactory.class)\n+public class GreeHandlerFactory extends BaseThingHandlerFactory {\n+    private @Nullable ServiceRegistration<?> serviceRegistration;\n+    private final GreeTranslationProvider messages;\n+\n+    @Activate\n+    public GreeHandlerFactory(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider,\n+            ComponentContext componentContext, Map<String, Object> configProperties) {\n+        super.activate(componentContext);\n+\n+        messages = new GreeTranslationProvider(bundleContext.getBundle(), i18nProvider, localeProvider);\n+\n+        String broadcastAddress = networkAddressService.getConfiguredBroadcastAddress();\n+        String defBroadcastIp = broadcastAddress != null ? broadcastAddress : \"\";\n+        GreeDiscoveryService discoveryService = new GreeDiscoveryService(bundleContext.getBundle(), messages,\n+                defBroadcastIp);\n+        this.serviceRegistration = bundleContext.registerService(DiscoveryService.class.getName(), discoveryService,\n+                new Hashtable<String, Object>());\n+        discoveryService.activate();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        if (THING_TYPE_GREEAIRCON.equals(thing.getThingTypeUID())) {\n+            return new GreeHandler(thing, messages);\n+        }\n+        return null;\n+    }\n+\n+    private synchronized void unregisterDeviceDiscoveryService() {\n+        if (serviceRegistration != null) {\n+            serviceRegistration.unregister();\n+            GreeDiscoveryService discoveryService = (GreeDiscoveryService) bundleContext\n+                    .getService(serviceRegistration.getReference());\n+            if (discoveryService != null) {\n+                discoveryService.deactivate();\n+            }\n+        }\n+    }\n+\n+    public void dispose() {", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxNzU2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432917565", "bodyText": "revmoed, but is there an alternativ to call unregisterDeviceDiscoveryService() or even not required?", "author": "markus7017", "createdAt": "2020-05-31T07:11:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NzM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkzMDA4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432930084", "bodyText": "You can annotate a method with @Deactivate, which is called when the Component is deactivated.", "author": "fwolter", "createdAt": "2020-05-31T10:00:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NzM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkzODc5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432938791", "bodyText": "Actually you should override the deactivate() method of BaseThingHandlerFactory (don't forget to call super.deactivate() in your method at first). If you use the annotation, BaseThingHandlerFactory.deactivate() wouldn't be called anymore.", "author": "fwolter", "createdAt": "2020-05-31T11:48:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NzM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0ODY1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432948659", "bodyText": "I added this\n@OverRide\npublic void deactivate(ComponentContext componentContext) {\nsuper.deactivate(componentContext);\nunregisterDeviceDiscoveryService();\n}\nok?", "author": "markus7017", "createdAt": "2020-05-31T13:44:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NzM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1MDc3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r433150772", "bodyText": "When you make the DiscoveryService a Component, you don't need this at all.", "author": "fwolter", "createdAt": "2020-06-01T10:11:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NzM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM0Mjk1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436342958", "bodyText": "I turned it into a Component, the service gets started, but GREE is no longer selectable when running the discovery from the Inbox. It seems that some kind of registration is missing.", "author": "markus7017", "createdAt": "2020-06-07T09:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NzM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM0Mjk4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436342982", "bodyText": "I turned it into a Component, the service gets started, but GREE is no longer selectable when running the discovery from the Inbox. It seems that some kind of registration is missing.", "author": "markus7017", "createdAt": "2020-06-07T09:21:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NzM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NjU1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436396559", "bodyText": "The \"Gree\" must be removed from the class name in service: @Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.gree\")", "author": "fwolter", "createdAt": "2020-06-07T19:58:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NzM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNTg1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436405859", "bodyText": "yep, already found that, now it's working", "author": "markus7017", "createdAt": "2020-06-07T22:00:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NzM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3ODI5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432878290", "bodyText": "Is it commented out by intention?", "author": "fwolter", "createdAt": "2020-05-30T18:51:06Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxNzYxMg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432917612", "bodyText": "yes, adding the annotation produces some ugly warninngs, high effort to change", "author": "markus7017", "createdAt": "2020-05-31T07:12:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3ODI5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4OTEzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436289135", "bodyText": "I looked again into this, this results in 40-50 \"potential null pointer warnings\", stupid to change", "author": "markus7017", "createdAt": "2020-06-06T18:15:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3ODI5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY2OTIxOA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437669218", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-09T19:32:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3ODI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3ODUwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432878500", "bodyText": "Since we want to get rid of the Apache Commons dependency. Could you replace it by native Java code? See #7722", "author": "fwolter", "createdAt": "2020-05-30T18:53:58Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxNzY1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432917655", "bodyText": "uff... Please give an advise, Kai also mentioned this, but didn't advised", "author": "markus7017", "createdAt": "2020-05-31T07:12:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3ODUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkyOTY1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432929656", "bodyText": "You can take a look at the implementation of isTrue():\n    public static void isTrue(boolean expression) {\n        if (expression == false) {\n            throw new IllegalArgumentException(\"The validated expression is false\");\n        }\n    }\n\nBut I would rather throw a GreeException if socket is not present.", "author": "fwolter", "createdAt": "2020-05-31T09:54:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3ODUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTI3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432949274", "bodyText": "added this\nprivate void validateSocket(Optional socket) {\nif (!socket.isPresent()) {\nthrow new IllegalArgumentException(\"Socket not initialized!\");\n}\n}", "author": "markus7017", "createdAt": "2020-05-31T13:50:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3ODUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTIxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432879216", "bodyText": "Better specify the expected charset.", "author": "fwolter", "createdAt": "2020-05-30T19:04:50Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxNzY4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432917689", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-05-31T07:13:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTM0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432879347", "bodyText": "Can the return type be a primitive boolean?", "author": "fwolter", "createdAt": "2020-05-30T19:06:33Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTM0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432949341", "bodyText": "yes Sir :-)", "author": "markus7017", "createdAt": "2020-05-31T13:50:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTQ1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432879451", "bodyText": "This could be simplified regardless of using primitve or complex types. Java will auto box it.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\n          \n          \n            \n                    if (!getIsBound() || value < 0 || value > 1) {", "author": "fwolter", "createdAt": "2020-05-30T19:07:53Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTQxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432949415", "bodyText": "I replaced all of them with a simple if (!getIsBound()... using using int for value", "author": "markus7017", "createdAt": "2020-05-31T13:51:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTQ1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTU2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432879561", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T19:09:50Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTQ0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432949443", "bodyText": "fixed all of them", "author": "markus7017", "createdAt": "2020-05-31T13:51:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTY0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432879640", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T19:11:09Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxNzczMA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432917730", "bodyText": "removed, don't know why the author not just used !getIsBound()", "author": "markus7017", "createdAt": "2020-05-31T07:13:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTcyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432879723", "bodyText": "It's better to use primitive types than complex ones.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\n          \n          \n            \n                public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {", "author": "fwolter", "createdAt": "2020-05-30T19:12:26Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxNzkzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432917938", "bodyText": "changed all", "author": "markus7017", "createdAt": "2020-05-31T07:16:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTg0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432879847", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T19:14:13Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxNzk3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432917972", "bodyText": "dto", "author": "markus7017", "createdAt": "2020-05-31T07:17:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTg0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTg1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432879856", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T19:14:30Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxNzk1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432917954", "bodyText": "dto, you don't need 1 by 1 - just add the comment \"fix all of them\"", "author": "markus7017", "createdAt": "2020-05-31T07:16:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTg1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTg2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432879867", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T19:14:45Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxNzk5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432917991", "bodyText": "dto, jsu add \"fix all of them\"", "author": "markus7017", "createdAt": "2020-05-31T07:17:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTk4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432879983", "bodyText": "Auto-boxing\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    hmf.put(\"min\", new Integer(61)); // F\n          \n          \n            \n                    hmf.put(\"min\", 61); // F", "author": "fwolter", "createdAt": "2020-05-30T19:16:00Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxODE1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432918154", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-05-31T07:20:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDA3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880070", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\n          \n          \n            \n                private Integer[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {", "author": "fwolter", "createdAt": "2020-05-30T19:17:28Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxODI0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432918249", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-05-31T07:21:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDE0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880148", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T19:18:25Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxODI2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432918260", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-05-31T07:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDIyMg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880222", "bodyText": "This will check for object identity. Use validRangeCorF.equals(\"C\") to check for equality. Are you sure this code works under all conditions? This would be a good candidate for a unit test. See https://www.openhab.org/docs/developer/tests.html", "author": "fwolter", "createdAt": "2020-05-30T19:19:55Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxODM0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432918341", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-05-31T07:22:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDIyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDQ5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880499", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new Integer[] { newVal, CorF };\n          \n          \n            \n                    return new int[] { newVal, CorF };", "author": "fwolter", "createdAt": "2020-05-30T19:24:52Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTUzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432949535", "bodyText": "hmm, not sure. sometimes CorF is checked agains null\non the other side it's not @nullable Integer", "author": "markus7017", "createdAt": "2020-05-31T13:52:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4OTIwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436289201", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-06T18:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDQ5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDU3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880570", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (getIsBound() != Boolean.TRUE) {\n          \n          \n            \n                    if (!getIsBound()) {", "author": "fwolter", "createdAt": "2020-05-30T19:25:58Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTU2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432949560", "bodyText": "dto", "author": "markus7017", "createdAt": "2020-05-31T13:52:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDU4MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880580", "bodyText": "Primitive types", "author": "fwolter", "createdAt": "2020-05-30T19:26:15Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTYxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432949615", "bodyText": "I already replaced most of them, but not sure about the remaining ones\nmaybe check what I pushed", "author": "markus7017", "createdAt": "2020-05-31T13:53:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4OTIyMg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436289222", "bodyText": "I think we are good now", "author": "markus7017", "createdAt": "2020-06-06T18:16:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDU5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880595", "bodyText": "Primitive types", "author": "fwolter", "createdAt": "2020-05-30T19:26:44Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5Mjg0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436292849", "bodyText": "done", "author": "markus7017", "createdAt": "2020-06-06T19:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDU5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDcwNg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880706", "bodyText": "Primitive types", "author": "fwolter", "createdAt": "2020-05-30T19:28:20Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkzMDkwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432930903", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-05-31T10:10:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDczMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880731", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // subtract the float verison - the int version to get the fractional difference\n          \n          \n            \n                        // subtract the float version - the int version to get the fractional difference", "author": "fwolter", "createdAt": "2020-05-30T19:28:48Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkzMDk4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432930985", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-05-31T10:11:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880745", "bodyText": "Primitive types", "author": "fwolter", "createdAt": "2020-05-30T19:29:14Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTY3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432949679", "bodyText": "already changed", "author": "markus7017", "createdAt": "2020-05-31T13:54:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2NDY5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432964699", "bodyText": "same", "author": "markus7017", "createdAt": "2020-05-31T16:54:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880754", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T19:29:20Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTY5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432949696", "bodyText": "dto", "author": "markus7017", "createdAt": "2020-05-31T13:54:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2NDcxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432964716", "bodyText": "same", "author": "markus7017", "createdAt": "2020-05-31T16:55:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880764", "bodyText": "Primitive types", "author": "fwolter", "createdAt": "2020-05-30T19:29:31Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Air\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceDry(DatagramSocket clientSocket, Integer value) throws GreeException {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTcwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432949709", "bodyText": "dto", "author": "markus7017", "createdAt": "2020-05-31T13:54:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2NDczOA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432964738", "bodyText": "same", "author": "markus7017", "createdAt": "2020-05-31T16:55:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880776", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T19:29:37Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Air\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceDry(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTcxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432949719", "bodyText": "same", "author": "markus7017", "createdAt": "2020-05-31T13:54:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2NDc1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432964756", "bodyText": "same", "author": "markus7017", "createdAt": "2020-05-31T16:55:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880786", "bodyText": "Primitive types", "author": "fwolter", "createdAt": "2020-05-30T19:29:47Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Air\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceDry(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Blo\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceHealth(DatagramSocket clientSocket, Integer value) throws GreeException {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTc1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432949754", "bodyText": "same", "author": "markus7017", "createdAt": "2020-05-31T13:55:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2NDc3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432964770", "bodyText": "same", "author": "markus7017", "createdAt": "2020-05-31T16:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880791", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T19:29:52Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Air\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceDry(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Blo\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceHealth(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTcyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432949727", "bodyText": "same", "author": "markus7017", "createdAt": "2020-05-31T13:54:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2NDc4MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432964780", "bodyText": "same", "author": "markus7017", "createdAt": "2020-05-31T16:55:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDgxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880815", "bodyText": "Primitive types", "author": "fwolter", "createdAt": "2020-05-30T19:30:05Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Air\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceDry(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Blo\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceHealth(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Health\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, Integer value) throws GreeException {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTczNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432949735", "bodyText": "same", "author": "markus7017", "createdAt": "2020-05-31T13:54:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDgyMA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880820", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T19:30:11Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Air\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceDry(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Blo\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceHealth(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Health\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTc0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432949743", "bodyText": "same", "author": "markus7017", "createdAt": "2020-05-31T13:55:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDgzMg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880832", "bodyText": "Primitive types", "author": "fwolter", "createdAt": "2020-05-30T19:30:19Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Air\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceDry(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Blo\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceHealth(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Health\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SvSt\", value);\r\n+        parameters.put(\"WdSpd\", new Integer(0));\r\n+        parameters.put(\"Quiet\", new Integer(0));\r\n+        parameters.put(\"Tur\", new Integer(0));\r\n+        parameters.put(\"SwhSlp\", new Integer(0));\r\n+        parameters.put(\"SlpMod\", new Integer(0));\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTc3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432949771", "bodyText": "already changed", "author": "markus7017", "createdAt": "2020-05-31T13:55:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDgzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2NDgxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432964813", "bodyText": "same", "author": "markus7017", "createdAt": "2020-05-31T16:55:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDk5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880994", "bodyText": "Can these be deleted?", "author": "fwolter", "createdAt": "2020-05-30T19:33:06Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Air\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceDry(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Blo\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceHealth(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Health\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SvSt\", value);\r\n+        parameters.put(\"WdSpd\", new Integer(0));\r\n+        parameters.put(\"Quiet\", new Integer(0));\r\n+        parameters.put(\"Tur\", new Integer(0));\r\n+        parameters.put(\"SwhSlp\", new Integer(0));\r\n+        parameters.put(\"SlpMod\", new Integer(0));\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getIntStatusVal(String valueName) {\r\n+        /*\r\n+         * Note : Values can be:\r\n+         * \"Pow\": Power (0 or 1)\r\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\r\n+         * \"SetTem\": Requested Temperature\r\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\r\n+         * \"Air\": Air Mode Enabled\r\n+         * \"Blo\": Dry\r\n+         * \"Health\": Health\r\n+         * \"SwhSlp\": Sleep\r\n+         * \"SlpMod\": ???\r\n+         * \"Lig\": Light On\r\n+         * \"SwingLfRig\": Swing Left Right\r\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\r\n+         * \"Quiet\": Quiet mode\r\n+         * \"Tur\": Turbo\r\n+         * \"StHt\": 0,\r\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\r\n+         * \"HeatCoolType\"\r\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\r\n+         * temp\r\n+         * \"SvSt\": Power Saving\r\n+         */\r\n+        // Find the valueName in the Returned Status object\r\n+        String columns[] = statusResponseGson.packJson.cols;\r\n+        Integer values[] = statusResponseGson.packJson.dat;\r\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\r\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));\r\n+        int valueArrayposition = colList.indexOf(valueName);\r\n+        if (valueArrayposition == -1) {\r\n+            return -1;\r\n+        }\r\n+\r\n+        // Now get the Corresponding value\r\n+        Integer value = valList.get(valueArrayposition);\r\n+        return value;\r\n+    }\r\n+\r\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\r\n+        if (prevStatusResponsePackGson == null) {\r\n+            return true; // update value if there is no previous one\r\n+        }\r\n+        // Find the valueName in the Current Status object\r\n+        String currcolumns[] = statusResponseGson.packJson.cols;\r\n+        Integer currvalues[] = statusResponseGson.packJson.dat;\r\n+        List<String> currcolList = new ArrayList<>(Arrays.asList(currcolumns));\r\n+        List<Integer> currvalList = new ArrayList<>(Arrays.asList(currvalues));\r\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\r\n+        if (currvalueArrayposition == -1) {\r\n+            throw new GreeException(\"Unable to decode device status\");\r\n+        }\r\n+        // Now get the Corresponding value\r\n+        int currvalue = currvalList.get(currvalueArrayposition);\r\n+\r\n+        // Find the valueName in the Previous Status object\r\n+        String prevcolumns[] = prevStatusResponsePackGson.cols;\r\n+        Integer prevvalues[] = prevStatusResponsePackGson.dat;\r\n+        List<String> prevcolList = new ArrayList<>(Arrays.asList(prevcolumns));\r\n+        List<Integer> prevvalList = new ArrayList<>(Arrays.asList(prevvalues));\r\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\r\n+        if (prevvalueArrayposition == -1) {\r\n+            throw new GreeException(\"Unable to get status value\");\r\n+        }\r\n+        // Now get the Corresponding value\r\n+        int prevvalue = prevvalList.get(prevvalueArrayposition);\r\n+\r\n+        // Finally Compare the values\r\n+        return currvalue != prevvalue;\r\n+    }\r\n+\r\n+    protected void executeCommand(DatagramSocket clientSocket, HashMap<String, Integer> parameters)\r\n+            throws GreeException {\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[1024];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Convert the parameter map values to arrays\r\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\r\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\r\n+\r\n+            // Prep the Command Request pack\r\n+            GreeExecuteCommandPack4GsonDTO execCmdPackGson = new GreeExecuteCommandPack4GsonDTO();\r\n+            execCmdPackGson.opt = keyArray;\r\n+            execCmdPackGson.p = valueArray;\r\n+            execCmdPackGson.t = \"cmd\";\r\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), execCmdPackStr);\r\n+            // String unencryptedCommandReqPacket = CryptoUtil.decryptPack(device.getKey().getBytes(),\r\n+            // encryptedCommandReqPacket);\r\n+\r\n+            // Prep the Command Request\r\n+            GreeExecCommand4GsonDTO execCmdGson = new GreeExecCommand4GsonDTO();\r\n+            execCmdGson.cid = \"app\";\r\n+            execCmdGson.i = 0;\r\n+            execCmdGson.t = \"pack\";\r\n+            execCmdGson.uid = 0;\r\n+            execCmdGson.tcid = getId();\r\n+            execCmdGson.pack = new String(encryptedCommandReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String execCmdStr = gson.toJson(execCmdGson);\r\n+            sendData = execCmdStr.getBytes();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+            // System.out.println(\"FROM SERVER:\" + modifiedSentence);\r\n+            // byte[] modifiedSentenceArray = receivePacket.getData();\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTg1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432949851", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-05-31T13:56:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTAwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881002", "bodyText": "Encoding", "author": "fwolter", "createdAt": "2020-05-30T19:33:18Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Air\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceDry(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Blo\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceHealth(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Health\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SvSt\", value);\r\n+        parameters.put(\"WdSpd\", new Integer(0));\r\n+        parameters.put(\"Quiet\", new Integer(0));\r\n+        parameters.put(\"Tur\", new Integer(0));\r\n+        parameters.put(\"SwhSlp\", new Integer(0));\r\n+        parameters.put(\"SlpMod\", new Integer(0));\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getIntStatusVal(String valueName) {\r\n+        /*\r\n+         * Note : Values can be:\r\n+         * \"Pow\": Power (0 or 1)\r\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\r\n+         * \"SetTem\": Requested Temperature\r\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\r\n+         * \"Air\": Air Mode Enabled\r\n+         * \"Blo\": Dry\r\n+         * \"Health\": Health\r\n+         * \"SwhSlp\": Sleep\r\n+         * \"SlpMod\": ???\r\n+         * \"Lig\": Light On\r\n+         * \"SwingLfRig\": Swing Left Right\r\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\r\n+         * \"Quiet\": Quiet mode\r\n+         * \"Tur\": Turbo\r\n+         * \"StHt\": 0,\r\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\r\n+         * \"HeatCoolType\"\r\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\r\n+         * temp\r\n+         * \"SvSt\": Power Saving\r\n+         */\r\n+        // Find the valueName in the Returned Status object\r\n+        String columns[] = statusResponseGson.packJson.cols;\r\n+        Integer values[] = statusResponseGson.packJson.dat;\r\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\r\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));\r\n+        int valueArrayposition = colList.indexOf(valueName);\r\n+        if (valueArrayposition == -1) {\r\n+            return -1;\r\n+        }\r\n+\r\n+        // Now get the Corresponding value\r\n+        Integer value = valList.get(valueArrayposition);\r\n+        return value;\r\n+    }\r\n+\r\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\r\n+        if (prevStatusResponsePackGson == null) {\r\n+            return true; // update value if there is no previous one\r\n+        }\r\n+        // Find the valueName in the Current Status object\r\n+        String currcolumns[] = statusResponseGson.packJson.cols;\r\n+        Integer currvalues[] = statusResponseGson.packJson.dat;\r\n+        List<String> currcolList = new ArrayList<>(Arrays.asList(currcolumns));\r\n+        List<Integer> currvalList = new ArrayList<>(Arrays.asList(currvalues));\r\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\r\n+        if (currvalueArrayposition == -1) {\r\n+            throw new GreeException(\"Unable to decode device status\");\r\n+        }\r\n+        // Now get the Corresponding value\r\n+        int currvalue = currvalList.get(currvalueArrayposition);\r\n+\r\n+        // Find the valueName in the Previous Status object\r\n+        String prevcolumns[] = prevStatusResponsePackGson.cols;\r\n+        Integer prevvalues[] = prevStatusResponsePackGson.dat;\r\n+        List<String> prevcolList = new ArrayList<>(Arrays.asList(prevcolumns));\r\n+        List<Integer> prevvalList = new ArrayList<>(Arrays.asList(prevvalues));\r\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\r\n+        if (prevvalueArrayposition == -1) {\r\n+            throw new GreeException(\"Unable to get status value\");\r\n+        }\r\n+        // Now get the Corresponding value\r\n+        int prevvalue = prevvalList.get(prevvalueArrayposition);\r\n+\r\n+        // Finally Compare the values\r\n+        return currvalue != prevvalue;\r\n+    }\r\n+\r\n+    protected void executeCommand(DatagramSocket clientSocket, HashMap<String, Integer> parameters)\r\n+            throws GreeException {\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[1024];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Convert the parameter map values to arrays\r\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\r\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\r\n+\r\n+            // Prep the Command Request pack\r\n+            GreeExecuteCommandPack4GsonDTO execCmdPackGson = new GreeExecuteCommandPack4GsonDTO();\r\n+            execCmdPackGson.opt = keyArray;\r\n+            execCmdPackGson.p = valueArray;\r\n+            execCmdPackGson.t = \"cmd\";\r\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), execCmdPackStr);\r\n+            // String unencryptedCommandReqPacket = CryptoUtil.decryptPack(device.getKey().getBytes(),\r\n+            // encryptedCommandReqPacket);\r\n+\r\n+            // Prep the Command Request\r\n+            GreeExecCommand4GsonDTO execCmdGson = new GreeExecCommand4GsonDTO();\r\n+            execCmdGson.cid = \"app\";\r\n+            execCmdGson.i = 0;\r\n+            execCmdGson.t = \"pack\";\r\n+            execCmdGson.uid = 0;\r\n+            execCmdGson.tcid = getId();\r\n+            execCmdGson.pack = new String(encryptedCommandReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String execCmdStr = gson.toJson(execCmdGson);\r\n+            sendData = execCmdStr.getBytes();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTkxMg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432949912", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-05-31T13:57:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTA5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881093", "bodyText": "Encoding", "author": "fwolter", "createdAt": "2020-05-30T19:35:09Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Air\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceDry(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Blo\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceHealth(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Health\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SvSt\", value);\r\n+        parameters.put(\"WdSpd\", new Integer(0));\r\n+        parameters.put(\"Quiet\", new Integer(0));\r\n+        parameters.put(\"Tur\", new Integer(0));\r\n+        parameters.put(\"SwhSlp\", new Integer(0));\r\n+        parameters.put(\"SlpMod\", new Integer(0));\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getIntStatusVal(String valueName) {\r\n+        /*\r\n+         * Note : Values can be:\r\n+         * \"Pow\": Power (0 or 1)\r\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\r\n+         * \"SetTem\": Requested Temperature\r\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\r\n+         * \"Air\": Air Mode Enabled\r\n+         * \"Blo\": Dry\r\n+         * \"Health\": Health\r\n+         * \"SwhSlp\": Sleep\r\n+         * \"SlpMod\": ???\r\n+         * \"Lig\": Light On\r\n+         * \"SwingLfRig\": Swing Left Right\r\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\r\n+         * \"Quiet\": Quiet mode\r\n+         * \"Tur\": Turbo\r\n+         * \"StHt\": 0,\r\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\r\n+         * \"HeatCoolType\"\r\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\r\n+         * temp\r\n+         * \"SvSt\": Power Saving\r\n+         */\r\n+        // Find the valueName in the Returned Status object\r\n+        String columns[] = statusResponseGson.packJson.cols;\r\n+        Integer values[] = statusResponseGson.packJson.dat;\r\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\r\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));\r\n+        int valueArrayposition = colList.indexOf(valueName);\r\n+        if (valueArrayposition == -1) {\r\n+            return -1;\r\n+        }\r\n+\r\n+        // Now get the Corresponding value\r\n+        Integer value = valList.get(valueArrayposition);\r\n+        return value;\r\n+    }\r\n+\r\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\r\n+        if (prevStatusResponsePackGson == null) {\r\n+            return true; // update value if there is no previous one\r\n+        }\r\n+        // Find the valueName in the Current Status object\r\n+        String currcolumns[] = statusResponseGson.packJson.cols;\r\n+        Integer currvalues[] = statusResponseGson.packJson.dat;\r\n+        List<String> currcolList = new ArrayList<>(Arrays.asList(currcolumns));\r\n+        List<Integer> currvalList = new ArrayList<>(Arrays.asList(currvalues));\r\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\r\n+        if (currvalueArrayposition == -1) {\r\n+            throw new GreeException(\"Unable to decode device status\");\r\n+        }\r\n+        // Now get the Corresponding value\r\n+        int currvalue = currvalList.get(currvalueArrayposition);\r\n+\r\n+        // Find the valueName in the Previous Status object\r\n+        String prevcolumns[] = prevStatusResponsePackGson.cols;\r\n+        Integer prevvalues[] = prevStatusResponsePackGson.dat;\r\n+        List<String> prevcolList = new ArrayList<>(Arrays.asList(prevcolumns));\r\n+        List<Integer> prevvalList = new ArrayList<>(Arrays.asList(prevvalues));\r\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\r\n+        if (prevvalueArrayposition == -1) {\r\n+            throw new GreeException(\"Unable to get status value\");\r\n+        }\r\n+        // Now get the Corresponding value\r\n+        int prevvalue = prevvalList.get(prevvalueArrayposition);\r\n+\r\n+        // Finally Compare the values\r\n+        return currvalue != prevvalue;\r\n+    }\r\n+\r\n+    protected void executeCommand(DatagramSocket clientSocket, HashMap<String, Integer> parameters)\r\n+            throws GreeException {\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[1024];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Convert the parameter map values to arrays\r\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\r\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\r\n+\r\n+            // Prep the Command Request pack\r\n+            GreeExecuteCommandPack4GsonDTO execCmdPackGson = new GreeExecuteCommandPack4GsonDTO();\r\n+            execCmdPackGson.opt = keyArray;\r\n+            execCmdPackGson.p = valueArray;\r\n+            execCmdPackGson.t = \"cmd\";\r\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), execCmdPackStr);\r\n+            // String unencryptedCommandReqPacket = CryptoUtil.decryptPack(device.getKey().getBytes(),\r\n+            // encryptedCommandReqPacket);\r\n+\r\n+            // Prep the Command Request\r\n+            GreeExecCommand4GsonDTO execCmdGson = new GreeExecCommand4GsonDTO();\r\n+            execCmdGson.cid = \"app\";\r\n+            execCmdGson.i = 0;\r\n+            execCmdGson.t = \"pack\";\r\n+            execCmdGson.uid = 0;\r\n+            execCmdGson.tcid = getId();\r\n+            execCmdGson.pack = new String(encryptedCommandReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String execCmdStr = gson.toJson(execCmdGson);\r\n+            sendData = execCmdStr.getBytes();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+            // System.out.println(\"FROM SERVER:\" + modifiedSentence);\r\n+            // byte[] modifiedSentenceArray = receivePacket.getData();\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            GreeExecResponse4GsonDTO execResponseGson = gson.fromJson(new JsonReader(stringReader),\r\n+                    GreeExecResponse4GsonDTO.class);\r\n+            execResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(),\r\n+                    execResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(execResponseGson.decryptedPack);\r\n+            execResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeExecResponsePack4GsonDTO.class);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"Exception on command execution\");\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\r\n+        Gson gson = new Gson();\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[1024];\r\n+\r\n+        try {\r\n+            // Set the values in the HashMap\r\n+            ArrayList<String> columns = new ArrayList<>();\r\n+            columns.add(\"Pow\");\r\n+            columns.add(\"Mod\");\r\n+            columns.add(\"SetTem\");\r\n+            columns.add(\"WdSpd\");\r\n+            columns.add(\"Air\");\r\n+            columns.add(\"Blo\");\r\n+            columns.add(\"Health\");\r\n+            columns.add(\"SwhSlp\");\r\n+            columns.add(\"Lig\");\r\n+            columns.add(\"SwingLfRig\");\r\n+            columns.add(\"SwUpDn\");\r\n+            columns.add(\"Quiet\");\r\n+            columns.add(\"Tur\");\r\n+            columns.add(\"StHt\");\r\n+            columns.add(\"TemUn\");\r\n+            columns.add(\"HeatCoolType\");\r\n+            columns.add(\"TemRec\");\r\n+            columns.add(\"SvSt\");\r\n+            columns.add(\"NoiseSet\");\r\n+\r\n+            // Convert the parameter map values to arrays\r\n+            String[] colArray = columns.toArray(new String[0]);\r\n+\r\n+            // Prep the Command Request pack\r\n+            GreeReqStatusPack4GsonDTO reqStatusPackGson = new GreeReqStatusPack4GsonDTO();\r\n+            reqStatusPackGson.t = \"status\";\r\n+            reqStatusPackGson.cols = colArray;\r\n+            reqStatusPackGson.mac = getId();\r\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\r\n+\r\n+            // Prep the Status Request\r\n+            GreeReqStatus4GsonDTO reqStatusGson = new GreeReqStatus4GsonDTO();\r\n+            reqStatusGson.cid = \"app\";\r\n+            reqStatusGson.i = 0;\r\n+            reqStatusGson.t = \"pack\";\r\n+            reqStatusGson.uid = 0;\r\n+            reqStatusGson.tcid = getId();\r\n+            reqStatusGson.pack = new String(encryptedStatusReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String execCmdStr = gson.toJson(reqStatusGson);\r\n+            sendData = execCmdStr.getBytes();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTkyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432949921", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-05-31T13:57:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTE1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881158", "bodyText": "Apache Commons", "author": "fwolter", "createdAt": "2020-05-30T19:36:10Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.net.SocketTimeoutException;\r\n+import java.net.UnknownHostException;\r\n+import java.util.HashMap;\r\n+import java.util.Iterator;\r\n+import java.util.Optional;\r\n+import java.util.Set;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.GsonBuilder;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\r\n+ * of found devices.\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+@NonNullByDefault\r\n+public class GreeDeviceFinder {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\r\n+\r\n+    protected final InetAddress mIPAddress;\r\n+    protected HashMap<String, GreeAirDevice> mDevicesHashMap = new HashMap<>();\r\n+\r\n+    public GreeDeviceFinder() {\r\n+        mIPAddress = InetAddress.getLoopbackAddress(); // dummy\r\n+    }\r\n+\r\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\r\n+        mIPAddress = InetAddress.getByName(broadcastAddress);\r\n+    }\r\n+\r\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk1MDA0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432950048", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-05-31T13:58:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTIxMg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881212", "bodyText": "Encoding", "author": "fwolter", "createdAt": "2020-05-30T19:37:09Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.net.SocketTimeoutException;\r\n+import java.net.UnknownHostException;\r\n+import java.util.HashMap;\r\n+import java.util.Iterator;\r\n+import java.util.Optional;\r\n+import java.util.Set;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.GsonBuilder;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\r\n+ * of found devices.\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+@NonNullByDefault\r\n+public class GreeDeviceFinder {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\r\n+\r\n+    protected final InetAddress mIPAddress;\r\n+    protected HashMap<String, GreeAirDevice> mDevicesHashMap = new HashMap<>();\r\n+\r\n+    public GreeDeviceFinder() {\r\n+        mIPAddress = InetAddress.getLoopbackAddress(); // dummy\r\n+    }\r\n+\r\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\r\n+        mIPAddress = InetAddress.getByName(broadcastAddress);\r\n+    }\r\n+\r\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[1024];\r\n+\r\n+        // Send the Scan message\r\n+        GreeScanRequest4GsonDTO scanGson = new GreeScanRequest4GsonDTO();\r\n+        scanGson.t = \"scan\";\r\n+\r\n+        GsonBuilder gsonBuilder = new GsonBuilder();\r\n+        Gson gson = gsonBuilder.create();\r\n+        String scanReq = gson.toJson(scanGson);\r\n+        sendData = scanReq.getBytes();\r\n+\r\n+        logger.trace(\"Sending scan packet to {}\", mIPAddress.getHostAddress());\r\n+        try {\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, mIPAddress, DISCOVERY_TIMEOUT_MS);\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Loop for respnses from devices until we get a timeout.\r\n+            boolean scanning = true;\r\n+            int retries = MAX_SCAN_CYCLES;\r\n+            while (scanning && (retries > 0)) {\r\n+                // Receive a response\r\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+                try {\r\n+                    clientSocket.receive(receivePacket);\r\n+                    InetAddress remoteAddress = receivePacket.getAddress();\r\n+                    int remotePort = receivePacket.getPort();\r\n+\r\n+                    // Read the response\r\n+                    String modifiedSentence = new String(receivePacket.getData());\r", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4OTI2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436289265", "bodyText": "UTF-8 added", "author": "markus7017", "createdAt": "2020-06-06T18:17:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTIxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTQwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881401", "bodyText": "Is there a reason why you don't make this an OSGi Component?", "author": "fwolter", "createdAt": "2020-05-30T19:40:11Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.osgi.framework.Bundle;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class GreeDiscoveryService extends AbstractDiscoveryService {", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk1MDA5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432950095", "bodyText": "Is this possibel with an AbstractDiscoveryService?", "author": "markus7017", "createdAt": "2020-05-31T13:59:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTQwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1MjM3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r433152372", "bodyText": "Yes, you can annotate it with @Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.gree\") and inject the NetworkAddressService and the i18n provider into the discovery service, then.", "author": "fwolter", "createdAt": "2020-06-01T10:15:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTQwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM0MzA0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436343046", "bodyText": "I turned it into a Component, the service gets started, but GREE is no longer selectable when running the discovery from the Inbox. It seems that some kind of registration is missing.", "author": "markus7017", "createdAt": "2020-06-07T09:21:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTQwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNTg3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436405879", "bodyText": "fixed", "author": "markus7017", "createdAt": "2020-06-07T22:00:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTQyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881426", "bodyText": "Better specify the unit in the name.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final int TIMEOUT = 10;\n          \n          \n            \n                private static final int TIMEOUT_SEC = 10;", "author": "fwolter", "createdAt": "2020-05-30T19:40:33Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.osgi.framework.Bundle;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT = 10;", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3NTA0NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432975044", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-05-31T19:08:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTUwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881502", "bodyText": "Does this method has any purpose?", "author": "fwolter", "createdAt": "2020-05-30T19:42:04Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.osgi.framework.Bundle;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    public GreeDiscoveryService(Bundle bundle, GreeTranslationProvider messages, String broadcastAddress) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT);\n+        this.messages = messages;\n+        this.broadcastAddress = !broadcastAddress.isEmpty() ? broadcastAddress : \"192.168.255.255\";\n+        logger.debug(\"Auto-detected broadcast IP = {}\", this.broadcastAddress);\n+    }\n+\n+    public void activate() {\n+    }", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4MDQ4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432980484", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-05-31T20:19:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTU0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881549", "bodyText": "Can this message be replaced by using the debugger?", "author": "fwolter", "createdAt": "2020-05-30T19:42:38Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.osgi.framework.Bundle;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    public GreeDiscoveryService(Bundle bundle, GreeTranslationProvider messages, String broadcastAddress) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT);\n+        this.messages = messages;\n+        this.broadcastAddress = !broadcastAddress.isEmpty() ? broadcastAddress : \"192.168.255.255\";\n+        logger.debug(\"Auto-detected broadcast IP = {}\", this.broadcastAddress);\n+    }\n+\n+    public void activate() {\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background scan\");", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3NTA3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432975076", "bodyText": "what do you mean?", "author": "markus7017", "createdAt": "2020-05-31T19:09:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTU0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1NDI1MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r433154250", "bodyText": "See point 4 in https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-06-01T10:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTU0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM0MzA1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436343054", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-06-07T09:21:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTU0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTU2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881566", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T19:42:46Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.osgi.framework.Bundle;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    public GreeDiscoveryService(Bundle bundle, GreeTranslationProvider messages, String broadcastAddress) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT);\n+        this.messages = messages;\n+        this.broadcastAddress = !broadcastAddress.isEmpty() ? broadcastAddress : \"192.168.255.255\";\n+        logger.debug(\"Auto-detected broadcast IP = {}\", this.broadcastAddress);\n+    }\n+\n+    public void activate() {\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background scan\");\n+        startScan();\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background scan\");", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3NTA4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432975083", "bodyText": "what do you mean?", "author": "markus7017", "createdAt": "2020-05-31T19:09:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM0MzA2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436343062", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-06-07T09:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTczOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881739", "bodyText": "Should this be warn?", "author": "fwolter", "createdAt": "2020-05-30T19:45:10Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.osgi.framework.Bundle;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    public GreeDiscoveryService(Bundle bundle, GreeTranslationProvider messages, String broadcastAddress) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT);\n+        this.messages = messages;\n+        this.broadcastAddress = !broadcastAddress.isEmpty() ? broadcastAddress : \"192.168.255.255\";\n+        logger.debug(\"Auto-detected broadcast IP = {}\", this.broadcastAddress);\n+    }\n+\n+    public void activate() {\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background scan\");\n+        startScan();\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background scan\");\n+        stopScan();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        Optional<DatagramSocket> clientSocket = Optional.empty();\n+        try {\n+            clientSocket = Optional.of(new DatagramSocket());\n+            deviceFinder = new GreeDeviceFinder(broadcastAddress);\n+            deviceFinder.scan(clientSocket, true);\n+\n+            int count = deviceFinder.getScannedDeviceCount();\n+            logger.info(\"{}\", messages.get(\"discovery.result\", count));\n+            if (count > 0) {\n+                logger.debug(\"Adding uinits to Inbox\");\n+                createResult(deviceFinder.getDevices());\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"{}\",", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3NTI3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432975275", "bodyText": "changed to\n'''\n} catch (GreeException e) {\nlogger.warn(\"Discovery failed: {}\", e.toString());\n} catch (IOException | RuntimeException e) {\nlogger.debug(\"Diiscovery failed\", e);\n}\n'''", "author": "markus7017", "createdAt": "2020-05-31T19:12:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTczOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM0MzA4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436343089", "bodyText": "done", "author": "markus7017", "createdAt": "2020-06-07T09:22:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTc0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881743", "bodyText": "Should this be warn?", "author": "fwolter", "createdAt": "2020-05-30T19:45:15Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.osgi.framework.Bundle;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    public GreeDiscoveryService(Bundle bundle, GreeTranslationProvider messages, String broadcastAddress) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT);\n+        this.messages = messages;\n+        this.broadcastAddress = !broadcastAddress.isEmpty() ? broadcastAddress : \"192.168.255.255\";\n+        logger.debug(\"Auto-detected broadcast IP = {}\", this.broadcastAddress);\n+    }\n+\n+    public void activate() {\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background scan\");\n+        startScan();\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background scan\");\n+        stopScan();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        Optional<DatagramSocket> clientSocket = Optional.empty();\n+        try {\n+            clientSocket = Optional.of(new DatagramSocket());\n+            deviceFinder = new GreeDeviceFinder(broadcastAddress);\n+            deviceFinder.scan(clientSocket, true);\n+\n+            int count = deviceFinder.getScannedDeviceCount();\n+            logger.info(\"{}\", messages.get(\"discovery.result\", count));\n+            if (count > 0) {\n+                logger.debug(\"Adding uinits to Inbox\");\n+                createResult(deviceFinder.getDevices());\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"{}\",\n+                    new GreeException(e, \"I/O exception while scanning the network for GREE devices\").toString());\n+        } catch (GreeException e) {\n+            logger.debug(\"Discovery failed: {}\", e.toString());", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3NTM4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432975385", "bodyText": "there are different opinios, other reviewers want to see that as logger.debug()", "author": "markus7017", "createdAt": "2020-05-31T19:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTk0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881943", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-05-30T19:48:51Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3NTQxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432975415", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-05-31T19:13:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTk1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881953", "bodyText": "Should this be warn?", "author": "fwolter", "createdAt": "2020-05-30T19:49:16Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3NTQzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432975439", "bodyText": "makes sense, changed", "author": "markus7017", "createdAt": "2020-05-31T19:14:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTk3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881971", "bodyText": "Can this message be replaced by using the debugger?", "author": "fwolter", "createdAt": "2020-05-30T19:49:48Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM0MzEzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436343133", "bodyText": "I want to see it when users are providing logs", "author": "markus7017", "createdAt": "2020-06-07T09:22:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTk3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NzA0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436397040", "bodyText": "Would the framework's log message suffice?\n22:04:01.101 [ndlerExecutor-1] INFO  smarthome.event.ThingStatusInfoEvent:53 - 'gree:airconditioner:f9a55bda' updated: INITIALIZING", "author": "fwolter", "createdAt": "2020-06-07T20:05:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTk3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNTk0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436405941", "bodyText": "ok, removed", "author": "markus7017", "createdAt": "2020-06-07T22:01:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTk3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjA1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882059", "bodyText": "This code will never be reached.\nYou could work with a local variable to the new DatagramSocket to prevent using get() all the time.", "author": "fwolter", "createdAt": "2020-05-30T19:50:55Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3NTYzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432975631", "bodyText": "ok, you are right, if the creation fails an Exception is thrown\nremoved", "author": "markus7017", "createdAt": "2020-05-31T19:16:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjI5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882294", "bodyText": "updateStatus() already logs a message. This message is redundant.", "author": "fwolter", "createdAt": "2020-05-30T19:54:42Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3OTE3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432979175", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-05-31T20:02:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjI5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjM0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882348", "bodyText": "Should this be warn?", "author": "fwolter", "createdAt": "2020-05-30T19:55:34Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3OTIwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432979204", "bodyText": "makes sense", "author": "markus7017", "createdAt": "2020-05-31T20:02:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjM4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882381", "bodyText": "Should this be warn?\nIs it necessary to log the stack trace here or can you log the exception's message instead?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"Exception on inituialization\", e);\n          \n          \n            \n                        logger.debug(\"Exception on initialization\", e);", "author": "fwolter", "createdAt": "2020-05-30T19:55:57Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3OTIzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432979235", "bodyText": "fixed", "author": "markus7017", "createdAt": "2020-05-31T20:03:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjM4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjUxMg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882512", "bodyText": "Should this be warn?", "author": "fwolter", "createdAt": "2020-05-30T19:58:13Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3OTI2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432979265", "bodyText": "yes", "author": "markus7017", "createdAt": "2020-05-31T20:03:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjU2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882567", "bodyText": "You should check here for the type with if(command instanceof OnOffType), because the user could also specify e.g. Dimmer. Same for below.", "author": "fwolter", "createdAt": "2020-05-30T19:59:24Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3OTM4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432979381", "bodyText": "implemented for all of them", "author": "markus7017", "createdAt": "2020-05-31T20:05:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjYzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882634", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T20:00:12Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case SWINGV_CHANNEL:\n+                        device.setDeviceSwingVertical(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelUID.getId(),\n+                        e.toString());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelUID.getId(), e);\n+            }", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3OTUzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432979535", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-05-31T20:07:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjYzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjcxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882719", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T20:01:23Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case SWINGV_CHANNEL:\n+                        device.setDeviceSwingVertical(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelUID.getId(),\n+                        e.toString());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelUID.getId(), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = StringUtils.isNumeric(command.toString());\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    if (isNumber) {\n+                        // Support selecting the mode by number, maybe specific models support\n+                        // additional modes\n+                        mode = Integer.parseInt(modeStr);\n+                    } else {\n+                        logger.debug(\"Invalid mode requested: {}\", command);", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3OTU1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432979551", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-05-31T20:07:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjcyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882729", "bodyText": "Apache Commons", "author": "fwolter", "createdAt": "2020-05-30T20:01:33Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case SWINGV_CHANNEL:\n+                        device.setDeviceSwingVertical(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelUID.getId(),\n+                        e.toString());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelUID.getId(), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = StringUtils.isNumeric(command.toString());", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1NTMxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436355313", "bodyText": "replaced", "author": "markus7017", "createdAt": "2020-06-07T11:55:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4Mjg1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882851", "bodyText": "Can this be replaced by using the debugger?", "author": "fwolter", "createdAt": "2020-05-30T20:03:34Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case SWINGV_CHANNEL:\n+                        device.setDeviceSwingVertical(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelUID.getId(),\n+                        e.toString());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelUID.getId(), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = StringUtils.isNumeric(command.toString());\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    if (isNumber) {\n+                        // Support selecting the mode by number, maybe specific models support\n+                        // additional modes\n+                        mode = Integer.parseInt(modeStr);\n+                    } else {\n+                        logger.debug(\"Invalid mode requested: {}\", command);\n+                    }\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode != -1) {\n+            // Turn on the unit if currently off\n+            if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+                logger.debug(\"Send Auto-ON for mode {}\", mode);\n+                device.setDevicePower(socket, 1);\n+            }\n+\n+            // Select mode\n+            logger.debug(\"Select mode {}\", mode);\n+            device.SetDeviceMode(socket, mode);\n+\n+            // Check for secondary action\n+            switch (modeStr) {\n+                case MODE_ECO:\n+                    // Turn on power saving for eco mode\n+                    logger.debug(\"Turn on Power-Saving\");\n+                    device.setDevicePwrSaving(socket, 1);\n+                    break;\n+                case MODE_TURBO:\n+                    device.setDeviceTurbo(socket, 1);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = System.currentTimeMillis();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (timeSinceLastRefresh < MINIMUM_REFRESH_TIME_MS) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void startAutomaticRefresh() {\n+\n+        Runnable refresher = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                try {\n+                    logger.debug(\"Executing automatic update of values\");\n+                    // safeguard for multiple REFRESH commands\n+                    if (isMinimumRefreshTimeExceeded()) {\n+                        logger.debug(\"Fetching status values from device.\");", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3OTU5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432979595", "bodyText": "what do you mean?", "author": "markus7017", "createdAt": "2020-05-31T20:08:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4Mjg1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM0MzE5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436343193", "bodyText": "I want to see it when users are providing logs", "author": "markus7017", "createdAt": "2020-06-07T09:23:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4Mjg1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNTk2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436405962", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-06-07T22:01:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4Mjg1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4Mjg2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882868", "bodyText": "Should this be warn?\nWhat happens with the other exception causes?", "author": "fwolter", "createdAt": "2020-05-30T20:03:49Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case SWINGV_CHANNEL:\n+                        device.setDeviceSwingVertical(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelUID.getId(),\n+                        e.toString());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelUID.getId(), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = StringUtils.isNumeric(command.toString());\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    if (isNumber) {\n+                        // Support selecting the mode by number, maybe specific models support\n+                        // additional modes\n+                        mode = Integer.parseInt(modeStr);\n+                    } else {\n+                        logger.debug(\"Invalid mode requested: {}\", command);\n+                    }\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode != -1) {\n+            // Turn on the unit if currently off\n+            if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+                logger.debug(\"Send Auto-ON for mode {}\", mode);\n+                device.setDevicePower(socket, 1);\n+            }\n+\n+            // Select mode\n+            logger.debug(\"Select mode {}\", mode);\n+            device.SetDeviceMode(socket, mode);\n+\n+            // Check for secondary action\n+            switch (modeStr) {\n+                case MODE_ECO:\n+                    // Turn on power saving for eco mode\n+                    logger.debug(\"Turn on Power-Saving\");\n+                    device.setDevicePwrSaving(socket, 1);\n+                    break;\n+                case MODE_TURBO:\n+                    device.setDeviceTurbo(socket, 1);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = System.currentTimeMillis();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (timeSinceLastRefresh < MINIMUM_REFRESH_TIME_MS) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void startAutomaticRefresh() {\n+\n+        Runnable refresher = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                try {\n+                    logger.debug(\"Executing automatic update of values\");\n+                    // safeguard for multiple REFRESH commands\n+                    if (isMinimumRefreshTimeExceeded()) {\n+                        logger.debug(\"Fetching status values from device.\");\n+                        // Get the current status from the Airconditioner\n+                        device.getDeviceStatus(clientSocket.get());\n+                    } else {\n+                        logger.trace(\n+                                \"Skipped fetching status values from device because minimum refresh time not reached\");\n+                    }\n+\n+                    // Update All Channels\n+                    List<Channel> channels = getThing().getChannels();\n+                    for (Channel channel : channels) {\n+                        publishChannel(channel.getUID());\n+                    }\n+                } catch (GreeException e) {\n+                    if (!e.isTimeout()) {\n+                        logger.debug(\"Unable to perform auto-update: {}\", e.toString());", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3OTc3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432979772", "bodyText": "catch RunTimeException added", "author": "markus7017", "createdAt": "2020-05-31T20:10:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4Mjg2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1NzI0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r433157241", "bodyText": "Sorry, that was a bit misleading. I meant how the timeout is handled if e.isTimeout() is true. You might want to update the thing status to offline, then. Could you remove catching the RuntimeException again, since this is bad practice.", "author": "fwolter", "createdAt": "2020-06-01T10:27:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4Mjg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjkwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882900", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T20:04:36Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case SWINGV_CHANNEL:\n+                        device.setDeviceSwingVertical(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelUID.getId(),\n+                        e.toString());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelUID.getId(), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = StringUtils.isNumeric(command.toString());\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    if (isNumber) {\n+                        // Support selecting the mode by number, maybe specific models support\n+                        // additional modes\n+                        mode = Integer.parseInt(modeStr);\n+                    } else {\n+                        logger.debug(\"Invalid mode requested: {}\", command);\n+                    }\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode != -1) {\n+            // Turn on the unit if currently off\n+            if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+                logger.debug(\"Send Auto-ON for mode {}\", mode);\n+                device.setDevicePower(socket, 1);\n+            }\n+\n+            // Select mode\n+            logger.debug(\"Select mode {}\", mode);\n+            device.SetDeviceMode(socket, mode);\n+\n+            // Check for secondary action\n+            switch (modeStr) {\n+                case MODE_ECO:\n+                    // Turn on power saving for eco mode\n+                    logger.debug(\"Turn on Power-Saving\");\n+                    device.setDevicePwrSaving(socket, 1);\n+                    break;\n+                case MODE_TURBO:\n+                    device.setDeviceTurbo(socket, 1);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = System.currentTimeMillis();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (timeSinceLastRefresh < MINIMUM_REFRESH_TIME_MS) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void startAutomaticRefresh() {\n+\n+        Runnable refresher = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                try {\n+                    logger.debug(\"Executing automatic update of values\");\n+                    // safeguard for multiple REFRESH commands\n+                    if (isMinimumRefreshTimeExceeded()) {\n+                        logger.debug(\"Fetching status values from device.\");\n+                        // Get the current status from the Airconditioner\n+                        device.getDeviceStatus(clientSocket.get());\n+                    } else {\n+                        logger.trace(\n+                                \"Skipped fetching status values from device because minimum refresh time not reached\");\n+                    }\n+\n+                    // Update All Channels\n+                    List<Channel> channels = getThing().getChannels();\n+                    for (Channel channel : channels) {\n+                        publishChannel(channel.getUID());\n+                    }\n+                } catch (GreeException e) {\n+                    if (!e.isTimeout()) {\n+                        logger.debug(\"Unable to perform auto-update: {}\", e.toString());\n+                    }\n+                } catch (RuntimeException e) {\n+                    logger.debug(\"Unable to perform auto-update\", e);", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3OTg1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432979851", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-05-31T20:11:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMDg5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436400895", "bodyText": "Hm, I still see debug", "author": "fwolter", "createdAt": "2020-06-07T20:54:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4Mjk5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882996", "bodyText": "Should this be warn?", "author": "fwolter", "createdAt": "2020-05-30T20:05:29Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case SWINGV_CHANNEL:\n+                        device.setDeviceSwingVertical(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelUID.getId(),\n+                        e.toString());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelUID.getId(), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = StringUtils.isNumeric(command.toString());\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    if (isNumber) {\n+                        // Support selecting the mode by number, maybe specific models support\n+                        // additional modes\n+                        mode = Integer.parseInt(modeStr);\n+                    } else {\n+                        logger.debug(\"Invalid mode requested: {}\", command);\n+                    }\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode != -1) {\n+            // Turn on the unit if currently off\n+            if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+                logger.debug(\"Send Auto-ON for mode {}\", mode);\n+                device.setDevicePower(socket, 1);\n+            }\n+\n+            // Select mode\n+            logger.debug(\"Select mode {}\", mode);\n+            device.SetDeviceMode(socket, mode);\n+\n+            // Check for secondary action\n+            switch (modeStr) {\n+                case MODE_ECO:\n+                    // Turn on power saving for eco mode\n+                    logger.debug(\"Turn on Power-Saving\");\n+                    device.setDevicePwrSaving(socket, 1);\n+                    break;\n+                case MODE_TURBO:\n+                    device.setDeviceTurbo(socket, 1);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = System.currentTimeMillis();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (timeSinceLastRefresh < MINIMUM_REFRESH_TIME_MS) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void startAutomaticRefresh() {\n+\n+        Runnable refresher = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                try {\n+                    logger.debug(\"Executing automatic update of values\");\n+                    // safeguard for multiple REFRESH commands\n+                    if (isMinimumRefreshTimeExceeded()) {\n+                        logger.debug(\"Fetching status values from device.\");\n+                        // Get the current status from the Airconditioner\n+                        device.getDeviceStatus(clientSocket.get());\n+                    } else {\n+                        logger.trace(\n+                                \"Skipped fetching status values from device because minimum refresh time not reached\");\n+                    }\n+\n+                    // Update All Channels\n+                    List<Channel> channels = getThing().getChannels();\n+                    for (Channel channel : channels) {\n+                        publishChannel(channel.getUID());\n+                    }\n+                } catch (GreeException e) {\n+                    if (!e.isTimeout()) {\n+                        logger.debug(\"Unable to perform auto-update: {}\", e.toString());\n+                    }\n+                } catch (RuntimeException e) {\n+                    logger.debug(\"Unable to perform auto-update\", e);\n+                }\n+            }\n+        };\n+\n+        refreshTask = scheduler.scheduleWithFixedDelay(refresher, 0, config.refresh, TimeUnit.SECONDS);\n+        logger.debug(\"Automatic refresh started ({} second interval)\", config.refresh);\n+    }\n+\n+    private void publishChannel(ChannelUID channelUID) throws GreeException {\n+        try {\n+            String channelID = channelUID.getId();\n+            Optional<State> state = Optional.empty();\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case POWER_CHANNEL:\n+                    state = updateOnOff(\"Pow\");\n+                    break;\n+                case MODE_CHANNEL:\n+                    state = updateMode();\n+                    break;\n+                case TURBO_CHANNEL:\n+                    state = updateOnOff(\"Tur\");\n+                    break;\n+                case LIGHT_CHANNEL:\n+                    state = updateOnOff(\"Lig\");\n+                    break;\n+                case TEMP_CHANNEL:\n+                    state = updateTemp(\"SetTem\");\n+                    break;\n+                case SWINGV_CHANNEL:\n+                    state = updateNumber(\"SwUpDn\");\n+                    break;\n+                case WINDSPEED_CHANNEL:\n+                    state = updateNumber(\"WdSpd\");\n+                    break;\n+                case AIR_CHANNEL:\n+                    state = updateOnOff(\"Air\");\n+                    break;\n+                case DRY_CHANNEL:\n+                    state = updateOnOff(\"Blo\");\n+                    break;\n+                case HEALTH_CHANNEL:\n+                    state = updateOnOff(\"Health\");\n+                    break;\n+                case PWRSAV_CHANNEL:\n+                    state = updateOnOff(\"SvSt\");\n+                    break;\n+            }\n+            if (state.isPresent()) {\n+                logger.trace(\"Updating channel {} : {}\", channelID, state.get());\n+                updateState(channelID, state.get());\n+            }\n+        } catch (GreeException | IllegalArgumentException e) {\n+            logger.debug(\"Exception on channel update\", e);", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3OTg0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432979843", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-05-31T20:11:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4Mjk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5ODg1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436398852", "bodyText": "Did you forget to push it?", "author": "fwolter", "createdAt": "2020-06-07T20:27:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4Mjk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MzA2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432883064", "bodyText": "What throws a GreeException here?", "author": "fwolter", "createdAt": "2020-05-30T20:06:11Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case SWINGV_CHANNEL:\n+                        device.setDeviceSwingVertical(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelUID.getId(),\n+                        e.toString());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelUID.getId(), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = StringUtils.isNumeric(command.toString());\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    if (isNumber) {\n+                        // Support selecting the mode by number, maybe specific models support\n+                        // additional modes\n+                        mode = Integer.parseInt(modeStr);\n+                    } else {\n+                        logger.debug(\"Invalid mode requested: {}\", command);\n+                    }\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode != -1) {\n+            // Turn on the unit if currently off\n+            if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+                logger.debug(\"Send Auto-ON for mode {}\", mode);\n+                device.setDevicePower(socket, 1);\n+            }\n+\n+            // Select mode\n+            logger.debug(\"Select mode {}\", mode);\n+            device.SetDeviceMode(socket, mode);\n+\n+            // Check for secondary action\n+            switch (modeStr) {\n+                case MODE_ECO:\n+                    // Turn on power saving for eco mode\n+                    logger.debug(\"Turn on Power-Saving\");\n+                    device.setDevicePwrSaving(socket, 1);\n+                    break;\n+                case MODE_TURBO:\n+                    device.setDeviceTurbo(socket, 1);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = System.currentTimeMillis();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (timeSinceLastRefresh < MINIMUM_REFRESH_TIME_MS) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void startAutomaticRefresh() {\n+\n+        Runnable refresher = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                try {\n+                    logger.debug(\"Executing automatic update of values\");\n+                    // safeguard for multiple REFRESH commands\n+                    if (isMinimumRefreshTimeExceeded()) {\n+                        logger.debug(\"Fetching status values from device.\");\n+                        // Get the current status from the Airconditioner\n+                        device.getDeviceStatus(clientSocket.get());\n+                    } else {\n+                        logger.trace(\n+                                \"Skipped fetching status values from device because minimum refresh time not reached\");\n+                    }\n+\n+                    // Update All Channels\n+                    List<Channel> channels = getThing().getChannels();\n+                    for (Channel channel : channels) {\n+                        publishChannel(channel.getUID());\n+                    }\n+                } catch (GreeException e) {\n+                    if (!e.isTimeout()) {\n+                        logger.debug(\"Unable to perform auto-update: {}\", e.toString());\n+                    }\n+                } catch (RuntimeException e) {\n+                    logger.debug(\"Unable to perform auto-update\", e);\n+                }\n+            }\n+        };\n+\n+        refreshTask = scheduler.scheduleWithFixedDelay(refresher, 0, config.refresh, TimeUnit.SECONDS);\n+        logger.debug(\"Automatic refresh started ({} second interval)\", config.refresh);\n+    }\n+\n+    private void publishChannel(ChannelUID channelUID) throws GreeException {", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3OTk3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432979979", "bodyText": "updateNumber() or updateOnOff()", "author": "markus7017", "createdAt": "2020-05-31T20:12:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MzA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5ODU5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436398591", "bodyText": "GreeException is never thrown, because it is catched in this method. So, the throws declaration can be removed.", "author": "fwolter", "createdAt": "2020-06-07T20:23:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MzA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxNDAxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439014019", "bodyText": "I agree with @fwolter here, the GreeException should be removed from the throws clause since you are already caching it in the body.", "author": "cpmeister", "createdAt": "2020-06-11T19:17:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MzA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5MTk4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441191985", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-06-16T23:11:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MzA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MzEwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432883108", "bodyText": "What throws an IllegalArgumentException here?", "author": "fwolter", "createdAt": "2020-05-30T20:07:04Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case SWINGV_CHANNEL:\n+                        device.setDeviceSwingVertical(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelUID.getId(),\n+                        e.toString());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelUID.getId(), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = StringUtils.isNumeric(command.toString());\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    if (isNumber) {\n+                        // Support selecting the mode by number, maybe specific models support\n+                        // additional modes\n+                        mode = Integer.parseInt(modeStr);\n+                    } else {\n+                        logger.debug(\"Invalid mode requested: {}\", command);\n+                    }\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode != -1) {\n+            // Turn on the unit if currently off\n+            if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+                logger.debug(\"Send Auto-ON for mode {}\", mode);\n+                device.setDevicePower(socket, 1);\n+            }\n+\n+            // Select mode\n+            logger.debug(\"Select mode {}\", mode);\n+            device.SetDeviceMode(socket, mode);\n+\n+            // Check for secondary action\n+            switch (modeStr) {\n+                case MODE_ECO:\n+                    // Turn on power saving for eco mode\n+                    logger.debug(\"Turn on Power-Saving\");\n+                    device.setDevicePwrSaving(socket, 1);\n+                    break;\n+                case MODE_TURBO:\n+                    device.setDeviceTurbo(socket, 1);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = System.currentTimeMillis();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (timeSinceLastRefresh < MINIMUM_REFRESH_TIME_MS) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void startAutomaticRefresh() {\n+\n+        Runnable refresher = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                try {\n+                    logger.debug(\"Executing automatic update of values\");\n+                    // safeguard for multiple REFRESH commands\n+                    if (isMinimumRefreshTimeExceeded()) {\n+                        logger.debug(\"Fetching status values from device.\");\n+                        // Get the current status from the Airconditioner\n+                        device.getDeviceStatus(clientSocket.get());\n+                    } else {\n+                        logger.trace(\n+                                \"Skipped fetching status values from device because minimum refresh time not reached\");\n+                    }\n+\n+                    // Update All Channels\n+                    List<Channel> channels = getThing().getChannels();\n+                    for (Channel channel : channels) {\n+                        publishChannel(channel.getUID());\n+                    }\n+                } catch (GreeException e) {\n+                    if (!e.isTimeout()) {\n+                        logger.debug(\"Unable to perform auto-update: {}\", e.toString());\n+                    }\n+                } catch (RuntimeException e) {\n+                    logger.debug(\"Unable to perform auto-update\", e);\n+                }\n+            }\n+        };\n+\n+        refreshTask = scheduler.scheduleWithFixedDelay(refresher, 0, config.refresh, TimeUnit.SECONDS);\n+        logger.debug(\"Automatic refresh started ({} second interval)\", config.refresh);\n+    }\n+\n+    private void publishChannel(ChannelUID channelUID) throws GreeException {\n+        try {\n+            String channelID = channelUID.getId();\n+            Optional<State> state = Optional.empty();\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case POWER_CHANNEL:\n+                    state = updateOnOff(\"Pow\");\n+                    break;\n+                case MODE_CHANNEL:\n+                    state = updateMode();\n+                    break;\n+                case TURBO_CHANNEL:\n+                    state = updateOnOff(\"Tur\");\n+                    break;\n+                case LIGHT_CHANNEL:\n+                    state = updateOnOff(\"Lig\");\n+                    break;\n+                case TEMP_CHANNEL:\n+                    state = updateTemp(\"SetTem\");\n+                    break;\n+                case SWINGV_CHANNEL:\n+                    state = updateNumber(\"SwUpDn\");\n+                    break;\n+                case WINDSPEED_CHANNEL:\n+                    state = updateNumber(\"WdSpd\");\n+                    break;\n+                case AIR_CHANNEL:\n+                    state = updateOnOff(\"Air\");\n+                    break;\n+                case DRY_CHANNEL:\n+                    state = updateOnOff(\"Blo\");\n+                    break;\n+                case HEALTH_CHANNEL:\n+                    state = updateOnOff(\"Health\");\n+                    break;\n+                case PWRSAV_CHANNEL:\n+                    state = updateOnOff(\"SvSt\");\n+                    break;\n+            }\n+            if (state.isPresent()) {\n+                logger.trace(\"Updating channel {} : {}\", channelID, state.get());\n+                updateState(channelID, state.get());\n+            }\n+        } catch (GreeException | IllegalArgumentException e) {", "originalCommit": "4a0b49447344a772203fb7a3179f632c0360a0b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4MDAyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432980024", "bodyText": "removed IllegalArgumentException", "author": "markus7017", "createdAt": "2020-05-31T20:13:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MzEwOA=="}], "type": "inlineReview"}, {"oid": "6a486a9e70febf8869cc822d0821b2e98f651593", "url": "https://github.com/openhab/openhab-addons/commit/6a486a9e70febf8869cc822d0821b2e98f651593", "message": "various options descriptors added\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-03T17:55:47Z", "type": "forcePushed"}, {"oid": "ac59558a4da7a1aea9a453f4b4f19aa32b17082d", "url": "https://github.com/openhab/openhab-addons/commit/ac59558a4da7a1aea9a453f4b4f19aa32b17082d", "message": "rebased\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T17:46:09Z", "type": "commit"}, {"oid": "868041f5bce712be2f9226f7bfac337bcc1828e1", "url": "https://github.com/openhab/openhab-addons/commit/868041f5bce712be2f9226f7bfac337bcc1828e1", "message": "re-factoring WIP\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T17:46:09Z", "type": "commit"}, {"oid": "ac3275408bb290d8a2d1a865e5ba3b4c2cc14af5", "url": "https://github.com/openhab/openhab-addons/commit/ac3275408bb290d8a2d1a865e5ba3b4c2cc14af5", "message": "re-factoring WIP\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T17:46:09Z", "type": "commit"}, {"oid": "d087ba648e4fec06e9b1a126469d31c90712641f", "url": "https://github.com/openhab/openhab-addons/commit/d087ba648e4fec06e9b1a126469d31c90712641f", "message": "re-factoring WIP\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T17:46:09Z", "type": "commit"}, {"oid": "319b36723d354928fa58ec7b587d038489510819", "url": "https://github.com/openhab/openhab-addons/commit/319b36723d354928fa58ec7b587d038489510819", "message": "re-factoring WIP\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T17:46:09Z", "type": "commit"}, {"oid": "01bfa0b43edb2261deff1a9e4a100913767c6837", "url": "https://github.com/openhab/openhab-addons/commit/01bfa0b43edb2261deff1a9e4a100913767c6837", "message": "German translation added, refactoring completed\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T17:46:09Z", "type": "commit"}, {"oid": "912bf12a49c63c49622427bf1a64d08f7a9315cb", "url": "https://github.com/openhab/openhab-addons/commit/912bf12a49c63c49622427bf1a64d08f7a9315cb", "message": "ignore SocketTimeoutException on background status refresh\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T17:46:09Z", "type": "commit"}, {"oid": "de7d6e6d79c901f632fdfce09299c7627eb50890", "url": "https://github.com/openhab/openhab-addons/commit/de7d6e6d79c901f632fdfce09299c7627eb50890", "message": "module re-added to pom.xml\ntimeout adjusted, translation corrected\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T17:46:10Z", "type": "commit"}, {"oid": "d1677a939c7500b07b48eac6136d156931aa8d34", "url": "https://github.com/openhab/openhab-addons/commit/d1677a939c7500b07b48eac6136d156931aa8d34", "message": "review changes\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T17:46:10Z", "type": "commit"}, {"oid": "2f27216f0da11adb54fd84482aef9c133dab4653", "url": "https://github.com/openhab/openhab-addons/commit/2f27216f0da11adb54fd84482aef9c133dab4653", "message": "Added translations for mode and windspeed values\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T17:46:10Z", "type": "commit"}, {"oid": "10d3419989fbfdd001b09b1f62c5a61352ca2f01", "url": "https://github.com/openhab/openhab-addons/commit/10d3419989fbfdd001b09b1f62c5a61352ca2f01", "message": "Support got Aircon model (thanks @piotras) Support Google GD commands on\nthe mode channel\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T17:46:10Z", "type": "commit"}, {"oid": "2a753b3e0b928e6080ea963a90169586e6c88a4f", "url": "https://github.com/openhab/openhab-addons/commit/2a753b3e0b928e6080ea963a90169586e6c88a4f", "message": "Hungarian translation removed for now, seems to have some characterset\nissues\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T17:46:10Z", "type": "commit"}, {"oid": "ba6ad55c45f9d505893483913e71cfe4eb12dee7", "url": "https://github.com/openhab/openhab-addons/commit/ba6ad55c45f9d505893483913e71cfe4eb12dee7", "message": "mode channel is now String (supports Number as backward compatibility)\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T17:46:10Z", "type": "commit"}, {"oid": "1b928a843a5c83f3dfb09066439e40d7425021d0", "url": "https://github.com/openhab/openhab-addons/commit/1b928a843a5c83f3dfb09066439e40d7425021d0", "message": "naming of binding id and channel names adjusted\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T17:46:10Z", "type": "commit"}, {"oid": "9b1d436adda5d9c17440db094f82f92ff017ddd8", "url": "https://github.com/openhab/openhab-addons/commit/9b1d436adda5d9c17440db094f82f92ff017ddd8", "message": "New channels swingLeftRight, quiet; channel swingvertical renamed to\nswingUpDown; README updated; changes driven by PR review\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T17:46:10Z", "type": "commit"}, {"oid": "536dff441a4231662e76b8361a7c5f9215fbdc61", "url": "https://github.com/openhab/openhab-addons/commit/536dff441a4231662e76b8361a7c5f9215fbdc61", "message": "review changes\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T17:46:10Z", "type": "commit"}, {"oid": "a3832334e0b5bddc53a3121463df0dc329c035ef", "url": "https://github.com/openhab/openhab-addons/commit/a3832334e0b5bddc53a3121463df0dc329c035ef", "message": "more review changes\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T17:46:10Z", "type": "commit"}, {"oid": "533e2362069146e21466d1e5161a1331514a4407", "url": "https://github.com/openhab/openhab-addons/commit/533e2362069146e21466d1e5161a1331514a4407", "message": "getOnOffType() fixed\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T17:46:10Z", "type": "commit"}, {"oid": "0035358ca2c55385e43c8978905a423012fd5ba3", "url": "https://github.com/openhab/openhab-addons/commit/0035358ca2c55385e43c8978905a423012fd5ba3", "message": "updated channel handling (support for UBM)\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T17:46:10Z", "type": "commit"}, {"oid": "94fd14d821a6179d5278fb04c68fc4b438fbe62c", "url": "https://github.com/openhab/openhab-addons/commit/94fd14d821a6179d5278fb04c68fc4b438fbe62c", "message": "various options descriptors added\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T17:46:10Z", "type": "commit"}, {"oid": "94fd14d821a6179d5278fb04c68fc4b438fbe62c", "url": "https://github.com/openhab/openhab-addons/commit/94fd14d821a6179d5278fb04c68fc4b438fbe62c", "message": "various options descriptors added\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T17:46:10Z", "type": "forcePushed"}, {"oid": "b3df5cca635445fac9caa82d48591b8d52cd5907", "url": "https://github.com/openhab/openhab-addons/commit/b3df5cca635445fac9caa82d48591b8d52cd5907", "message": "rebased to 2.5.6\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T17:47:51Z", "type": "commit"}, {"oid": "1846cc40776cb0d4ab98b6db903dbffb769ebd62", "url": "https://github.com/openhab/openhab-addons/commit/1846cc40776cb0d4ab98b6db903dbffb769ebd62", "message": "review changes\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-06T18:02:03Z", "type": "commit"}, {"oid": "cd3073b907b96309c9ba0246aa74db523dedcddd", "url": "https://github.com/openhab/openhab-addons/commit/cd3073b907b96309c9ba0246aa74db523dedcddd", "message": "review changes; GreeDiscovery class turned into a Component, but this\nnot working yet\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-07T09:19:34Z", "type": "commit"}, {"oid": "5f205c44fbeeb23b0bfbd3ed08d5e550355330ab", "url": "https://github.com/openhab/openhab-addons/commit/5f205c44fbeeb23b0bfbd3ed08d5e550355330ab", "message": "various typos in language properties fixed; thing-type.xml uses @text/\nto reference language properties; quiet channel changed to\noff/auto/quiet rather than 0-2; README updated\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-07T11:48:49Z", "type": "commit"}, {"oid": "f39b4d2c64b1be550e3809943e3d6837fccda066", "url": "https://github.com/openhab/openhab-addons/commit/f39b4d2c64b1be550e3809943e3d6837fccda066", "message": "replace StringUtils.isNumber() by native code\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-07T11:55:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NzI1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436397258", "bodyText": "mark", "author": "fwolter", "createdAt": "2020-06-07T20:07:32Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeHandlerFactory.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.binding.gree.internal.handler.GreeHandler;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link GreeHandlerFactory} is responsible for creating things and thing handlers.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.\" + BINDING_ID, service = ThingHandlerFactory.class)\n+public class GreeHandlerFactory extends BaseThingHandlerFactory {\n+    private final GreeTranslationProvider messages;\n+    // private @Nullable ServiceRegistration<?> serviceRegistration;\n+\n+    @Activate\n+    public GreeHandlerFactory(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider,\n+            ComponentContext componentContext, Map<String, Object> configProperties) {\n+        super.activate(componentContext);\n+        messages = new GreeTranslationProvider(bundleContext.getBundle(), i18nProvider, localeProvider);\n+        /*\n+         * GreeDiscoveryService discoveryService = new GreeDiscoveryService(bundleContext.getBundle(), messages,\n+         * defBroadcastIp);\n+         * this.serviceRegistration = bundleContext.registerService(DiscoveryService.class.getName(), discoveryService,\n+         * new Hashtable<String, Object>());\n+         */", "originalCommit": "f39b4d2c64b1be550e3809943e3d6837fccda066", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNTI0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436405245", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-06-07T21:52:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NzI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5OTQxMg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436399412", "bodyText": "I see declaring this as NonNullByDefault has bigger impact. Nevertheless, I'd like to encourage you to use this opportunity to make your code even more robust.", "author": "fwolter", "createdAt": "2020-06-07T20:34:49Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,714 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.handler;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Optional;\r\n+\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r", "originalCommit": "f39b4d2c64b1be550e3809943e3d6837fccda066", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk2Mzg0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436963840", "bodyText": "ok, I worked on that, please check the result", "author": "markus7017", "createdAt": "2020-06-08T19:55:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5OTQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5OTk2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436399960", "bodyText": "Must be compared with equals().", "author": "fwolter", "createdAt": "2020-06-07T20:42:05Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,714 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.handler;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Optional;\r\n+\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        validateSocket(socket);\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    private void validateSocket(Optional<DatagramSocket> socket) {\r\n+        if (!socket.isPresent()) {\r\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if (!getIsBound() || (value < 0 || value > 1)) {\r\n+            throw new GreeException(\"Device not bound or value out of range!\");\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if (!getIsBound() || (value < 0 || value > 4)) {\r\n+            throw new GreeException(\"Device not bound or value out of range!\");\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\r\n+            throw new GreeException(\"Device not bound or value out of range!\");\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6 allowed\r\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\r\n+            throw new GreeException(\"Device not bound or value out of range!\");\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwingLfRig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\r\n+        if (!getIsBound() || (value < 0 || value > 5)) {\r\n+            throw new GreeException(\"Device not bound or value out of range!\");\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if (!getIsBound() || (value < 0 || value > 1)) {\r\n+            throw new GreeException(\"Device not bound or value out of range!\");\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if (!getIsBound() || (value < 0 || value > 2)) {\r\n+            throw new GreeException(\"Device not bound or value out of range!\");\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Quiet\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if (!getIsBound() || (value < 0 || value > 1)) {\r\n+            throw new GreeException(\"Device not bound or value out of range!\");\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", 61); // F\r\n+        hmf.put(\"max\", 86);\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", 16); // C\r\n+        hmc.put(\"max\", 30);\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", 0);\r\n+        nullCorFLUT.put(\"F\", 1);\r\n+        nullCorFLUT.put(\"INVALID\", 0);\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r", "originalCommit": "f39b4d2c64b1be550e3809943e3d6837fccda066", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNTM3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436405379", "bodyText": "fixed", "author": "markus7017", "createdAt": "2020-06-07T21:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5OTk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMDIyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436400227", "bodyText": "Do you log a stack trace by intention, when an IOException raises? RuntimeExceptions should be logged to warn or error. Logging IOException to debug is fine.", "author": "fwolter", "createdAt": "2020-06-07T20:46:10Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = GreeDiscoveryService.class, immediate = true, configurationPid = \"discovery.gree\")\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT_SEC = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    @Activate\n+    public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n+        Bundle bundle = FrameworkUtil.getBundle(this.getClass());\n+        messages = new GreeTranslationProvider(bundle.getBundleContext().getBundle(), i18nProvider, localeProvider);\n+        String ip = networkAddressService.getConfiguredBroadcastAddress();\n+        broadcastAddress = ip != null ? ip : \"\";\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        startScan();\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        stopScan();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        Optional<DatagramSocket> clientSocket = Optional.empty();\n+        try {\n+            clientSocket = Optional.of(new DatagramSocket());\n+            deviceFinder = new GreeDeviceFinder(broadcastAddress);\n+            deviceFinder.scan(clientSocket, true);\n+\n+            int count = deviceFinder.getScannedDeviceCount();\n+            logger.info(\"{}\", messages.get(\"discovery.result\", count));\n+            if (count > 0) {\n+                logger.debug(\"Adding uinits to Inbox\");\n+                createResult(deviceFinder.getDevices());\n+            }\n+        } catch (GreeException e) {\n+            logger.warn(\"Discovery failed: {}\", e.toString());\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Discovery failed\", e);", "originalCommit": "f39b4d2c64b1be550e3809943e3d6837fccda066", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNTU4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436405583", "bodyText": "changed to\n       } catch (GreeException e) {\n            logger.warn(\"Discovery failed: {}\", e.toString());\n        } catch (IOException e) {\n            logger.debug(\"Discovery failed\", e.toString());\n        } catch (RuntimeException e) {\n            logger.warn(\"Discovery failed\", e);\n        } finally {", "author": "markus7017", "createdAt": "2020-06-07T21:57:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMDIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMDQ1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436400457", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-06-07T20:49:29Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import tec.uom.se.unit.Units;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.warn(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on initialization\", e);", "originalCommit": "f39b4d2c64b1be550e3809943e3d6837fccda066", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNTY2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436405660", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-07T21:58:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMDQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMDUzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436400534", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-06-07T20:50:12Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import tec.uom.se.unit.Units;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.warn(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on initialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.warn(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"Handle command {} for channel {}, command class {}\", command, channelId, command.getClass());\n+            try {\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, (int) getTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(command, socket);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelId, e.toString());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"Invalid command value {}\u00a0for channel {}\", command, channelUID.getId());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelId, e);", "originalCommit": "f39b4d2c64b1be550e3809943e3d6837fccda066", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNTcyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436405727", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-07T21:58:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMDUzNA=="}], "type": "inlineReview"}, {"oid": "7e85fe1969c9ac94e13940ce8c6911a22ec4d558", "url": "https://github.com/openhab/openhab-addons/commit/7e85fe1969c9ac94e13940ce8c6911a22ec4d558", "message": "discovery fixed, review changes, README updated\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-07T22:03:11Z", "type": "commit"}, {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "url": "https://github.com/openhab/openhab-addons/commit/f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "message": "spotless formatting applied\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-07T22:06:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MTQ0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436471440", "bodyText": "The default charset varies from system to system so it is better to specify it yourself instead of using the default.\nYou can specify the charset as an additional parameter in the String constructor.", "author": "cpmeister", "createdAt": "2020-06-08T05:59:05Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeCryptoUtil.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Base64;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The CryptoUtil class provides functionality for encrypting and decrypting\n+ * messages sent to and from the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeCryptoUtil {\n+    private static final String AES_KEY = \"a3K8Bx%2r8Y7#xDh\";\n+\n+    public static String GetAESGeneralKey() {\n+        return AES_KEY;\n+    }\n+\n+    public static byte[] getAESGeneralKeyByteArray() {\n+        return AES_KEY.getBytes();\n+    }\n+\n+    public static String decryptPack(byte[] keyarray, String message) throws GreeException {\n+        try {\n+            Key key = new SecretKeySpec(keyarray, \"AES\");\n+            Base64.Decoder decoder = Base64.getDecoder();\n+            byte[] imageByte = decoder.decode(message);\n+\n+            Cipher aesCipher = Cipher.getInstance(\"AES\");\n+            aesCipher.init(Cipher.DECRYPT_MODE, key);\n+            byte[] bytePlainText = aesCipher.doFinal(imageByte);\n+\n+            return new String(bytePlainText, \"UTF-8\");\n+        } catch (NoSuchAlgorithmException | UnsupportedEncodingException | NoSuchPaddingException | BadPaddingException\n+                | InvalidKeyException | IllegalBlockSizeException ex) {\n+            throw new GreeException(ex, \"Decryption of recieved data failed\");\n+        }\n+    }\n+\n+    public static String encryptPack(byte[] keyarray, String message) throws GreeException {\n+        try {\n+            Key key = new SecretKeySpec(keyarray, \"AES\");\n+            Cipher aesCipher = Cipher.getInstance(\"AES\");\n+            aesCipher.init(Cipher.ENCRYPT_MODE, key);\n+            byte[] bytePlainText = aesCipher.doFinal(message.getBytes());\n+\n+            Base64.Encoder newencoder = Base64.getEncoder();\n+            String encrytpedMessage = new String(newencoder.encode(bytePlainText));", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzMzYwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437033600", "bodyText": "done", "author": "markus7017", "createdAt": "2020-06-08T22:21:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MTQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MTgwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436471800", "bodyText": "Minor knit-pick I know, but I would prefer if you swapped the order of these parameters to be consistent with other exception constructors.", "author": "cpmeister", "createdAt": "2020-06-08T06:00:30Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeException.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal;\n+\n+import java.net.MalformedURLException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * {@link GreeException} implements a binding specific exception class. This allows to unity exception handling on the\n+ * higher levels, but still carrying the exception, which caused the problem.\n+ *\n+ * @author Markus Michels - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class GreeException extends Exception {\n+    private static final long serialVersionUID = -2337258558995287405L;\n+    private static String EX_NONE = \"none\";\n+\n+    public GreeException(Exception exception) {\n+        super(exception);\n+    }\n+\n+    public GreeException(String message) {\n+        super(message);\n+    }\n+\n+    public GreeException(Exception exception, String message) {", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzNDUwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437034504", "bodyText": "changed...", "author": "markus7017", "createdAt": "2020-06-08T22:24:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MTgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MjE1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436472158", "bodyText": "any reason this was overriden?", "author": "cpmeister", "createdAt": "2020-06-08T06:01:57Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeHandlerFactory.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.binding.gree.internal.handler.GreeHandler;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link GreeHandlerFactory} is responsible for creating things and thing handlers.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.\" + BINDING_ID, service = ThingHandlerFactory.class)\n+public class GreeHandlerFactory extends BaseThingHandlerFactory {\n+    private final GreeTranslationProvider messages;\n+\n+    @Activate\n+    public GreeHandlerFactory(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider,\n+            ComponentContext componentContext, Map<String, Object> configProperties) {\n+        super.activate(componentContext);\n+        messages = new GreeTranslationProvider(bundleContext.getBundle(), i18nProvider, localeProvider);\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        if (THING_TYPE_GREEAIRCON.equals(thing.getThingTypeUID())) {\n+            return new GreeHandler(thing, messages);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public void deactivate(ComponentContext componentContext) {", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzNDY2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437034668", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-06-08T22:24:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MjE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MjQ0NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436472444", "bodyText": "please change this to debug", "author": "cpmeister", "createdAt": "2020-06-08T06:03:00Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.gree\")\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT_SEC = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    @Activate\n+    public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n+        Bundle bundle = FrameworkUtil.getBundle(this.getClass());\n+        messages = new GreeTranslationProvider(bundle.getBundleContext().getBundle(), i18nProvider, localeProvider);\n+        String ip = networkAddressService.getConfiguredBroadcastAddress();\n+        broadcastAddress = ip != null ? ip : \"\";\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    @Modified\n+    protected void modified(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.modified(configProperties);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        // It's very unusual that a new unit gets installed frequently so we run the discovery once when the binding is\n+        // started, but not frequently\n+        scheduler.execute(() -> {\n+            startScan();\n+        });\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        stopScan();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        Optional<DatagramSocket> clientSocket = Optional.empty();\n+        try {\n+            clientSocket = Optional.of(new DatagramSocket());\n+            deviceFinder = new GreeDeviceFinder(broadcastAddress);\n+            deviceFinder.scan(clientSocket, true);\n+\n+            int count = deviceFinder.getScannedDeviceCount();\n+            logger.info(\"{}\", messages.get(\"discovery.result\", count));", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzNDg0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437034840", "bodyText": "done", "author": "markus7017", "createdAt": "2020-06-08T22:25:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MjQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MjU3OA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436472578", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                .withRepresentationProperty(device.getId()).withLabel(device.getName()).build();\n          \n          \n            \n                                .withRepresentationProperty(Thing.PROPERTY_MAC_ADDRESS)).withLabel(device.getName()).build();", "author": "cpmeister", "createdAt": "2020-06-08T06:03:30Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.gree\")\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT_SEC = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    @Activate\n+    public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n+        Bundle bundle = FrameworkUtil.getBundle(this.getClass());\n+        messages = new GreeTranslationProvider(bundle.getBundleContext().getBundle(), i18nProvider, localeProvider);\n+        String ip = networkAddressService.getConfiguredBroadcastAddress();\n+        broadcastAddress = ip != null ? ip : \"\";\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    @Modified\n+    protected void modified(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.modified(configProperties);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        // It's very unusual that a new unit gets installed frequently so we run the discovery once when the binding is\n+        // started, but not frequently\n+        scheduler.execute(() -> {\n+            startScan();\n+        });\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        stopScan();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        Optional<DatagramSocket> clientSocket = Optional.empty();\n+        try {\n+            clientSocket = Optional.of(new DatagramSocket());\n+            deviceFinder = new GreeDeviceFinder(broadcastAddress);\n+            deviceFinder.scan(clientSocket, true);\n+\n+            int count = deviceFinder.getScannedDeviceCount();\n+            logger.info(\"{}\", messages.get(\"discovery.result\", count));\n+            if (count > 0) {\n+                logger.debug(\"Adding uinits to Inbox\");\n+                createResult(deviceFinder.getDevices());\n+            }\n+        } catch (GreeException e) {\n+            logger.warn(\"Discovery failed: {}\", e.toString());\n+        } catch (IOException e) {\n+            logger.debug(\"Discovery failed: {}\", e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Discovery failed\", e);\n+        } finally {\n+            if (clientSocket.isPresent()) {\n+                clientSocket.get().close();\n+            }\n+        }\n+    }\n+\n+    public void createResult(HashMap<String, GreeAirDevice> deviceList) {\n+        for (Map.Entry<String, GreeAirDevice> d : deviceList.entrySet()) {\n+            GreeAirDevice device = d.getValue();\n+            String ipAddress = device.getAddress().getHostAddress();\n+            logger.debug(\"{}\", messages.get(\"discovery.newunit\", device.getName(), ipAddress, device.getId()));\n+            Map<String, Object> properties = new TreeMap<String, Object>();\n+            properties.put(Thing.PROPERTY_VENDOR, device.getVendor());\n+            properties.put(Thing.PROPERTY_MODEL_ID, device.getModel());\n+            properties.put(Thing.PROPERTY_MAC_ADDRESS, device.getId());\n+            properties.put(PROPERTY_IP, ipAddress);\n+            properties.put(PROPERTY_BROADCAST, broadcastAddress);\n+            ThingUID thingUID = new ThingUID(THING_TYPE_GREEAIRCON, device.getId());\n+            DiscoveryResult result = DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n+                    .withRepresentationProperty(device.getId()).withLabel(device.getName()).build();", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzNTA4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437035083", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-08T22:25:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MjU3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MzE3OA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436473178", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected HashMap<String, GreeAirDevice> mDevicesHashMap = new HashMap<>();\n          \n          \n            \n                protected Map<String, GreeAirDevice> devicesHashMap = new HashMap<>();", "author": "cpmeister", "createdAt": "2020-06-08T06:05:43Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress mIPAddress;\n+    protected HashMap<String, GreeAirDevice> mDevicesHashMap = new HashMap<>();", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzNTM2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437035360", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-08T22:26:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MzE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MzQxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436473419", "bodyText": "Please use camelcase naming convention.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected final InetAddress mIPAddress;\n          \n          \n            \n                protected final InetAddress ipAddress;", "author": "cpmeister", "createdAt": "2020-06-08T06:06:29Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress mIPAddress;", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzNTU0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437035547", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-08T22:27:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MzQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3Mzg5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436473891", "bodyText": "I don't see why you need to use an Optional here. Making socket nullable would more than sufficient.", "author": "cpmeister", "createdAt": "2020-06-08T06:08:11Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress mIPAddress;\n+    protected HashMap<String, GreeAirDevice> mDevicesHashMap = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        mIPAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        mIPAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3MTEyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437671121", "bodyText": "I want to get rid of that @nullable crap as much as possible because it always leads into \"potential null access\" etc. I will keep it", "author": "markus7017", "createdAt": "2020-06-09T19:36:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3Mzg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4ODIzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437688231", "bodyText": "The nullable crap only becomes an annoyance when it comes to fields, which is due to it trying to be thread-safe. The null checker works perfectly fine on local variable / parameters where only the running thread has access to it.", "author": "cpmeister", "createdAt": "2020-06-09T20:08:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3Mzg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5NzU4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r438997584", "bodyText": "I tried it once more and I like the Optional version way more, otherwise\n\ninstance variable clientSocket must be Nullable\nall parameters in the GreeHandler functions need to be changed to nullable\nall parameters in GreeAirDrvice too\nthen we run in \"potential null pointer access\", which adds a bunch of \"if (clientSocket == null\")...\nall that, because in theory the variable can be null, which is never the case when initialization was successful\n\nFor this I want to stay with the Optional approach.", "author": "markus7017", "createdAt": "2020-06-11T18:45:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3Mzg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NzQ2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439857466", "bodyText": "@cpmeister Do you agree after looking to the latest code?", "author": "markus7017", "createdAt": "2020-06-14T18:49:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3Mzg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NDkxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436474916", "bodyText": "I don't think you need the scanning variable at all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                scanning = scanNetwork;\n          \n          \n            \n                                if(!scanNetwork){\n          \n          \n            \n                                    break;\n          \n          \n            \n                                }", "author": "cpmeister", "createdAt": "2020-06-08T06:11:46Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress mIPAddress;\n+    protected HashMap<String, GreeAirDevice> mDevicesHashMap = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        mIPAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        mIPAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        // Send the Scan message\n+        GreeScanRequest4GsonDTO scanGson = new GreeScanRequest4GsonDTO();\n+        scanGson.t = \"scan\";\n+\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        Gson gson = gsonBuilder.create();\n+        String scanReq = gson.toJson(scanGson);\n+        sendData = scanReq.getBytes();\n+\n+        logger.trace(\"Sending scan packet to {}\", mIPAddress.getHostAddress());\n+        try {\n+            DatagramSocket clientSocket = socket.get();\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, mIPAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            boolean scanning = true;\n+            int retries = MAX_SCAN_CYCLES;\n+            while (scanning && (retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponse4GsonDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanResponse4GsonDTO.class);\n+\n+                    // If there was no pack, ignore the response\n+                    if (scanResponseGson.pack == null) {\n+                        logger.debug(\"Invalid packet format, ignore\");\n+                        continue;\n+                    }\n+\n+                    // Decrypt message - a a GreeException is thrown when something went wrong\n+                    scanResponseGson.decryptedPack = GreeCryptoUtil\n+                            .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n+                    String decryptedMsg = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                            scanResponseGson.pack);\n+\n+                    logger.debug(\"Response received from address {}: {}\", remoteAddress.getHostAddress(), decryptedMsg);\n+\n+                    // Create the JSON to hold the response values\n+                    stringReader = new StringReader(decryptedMsg);\n+                    scanResponseGson.packJson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanReponsePack4GsonDTO.class);\n+\n+                    // Now make sure the device is reported as a Gree device\n+                    if (scanResponseGson.packJson.brand.equalsIgnoreCase(\"gree\")) {\n+                        // Create a new GreeDevice\n+                        logger.debug(\"Discovered device at {}:{}\", remoteAddress.getHostAddress(), remotePort);\n+                        GreeAirDevice newDevice = new GreeAirDevice();\n+                        newDevice.setAddress(remoteAddress);\n+                        newDevice.setPort(remotePort);\n+                        newDevice.setScanResponseGson(scanResponseGson);\n+                        addDevice(newDevice);\n+                    } else {\n+                        logger.debug(\"Unit discovered, but brand is not GREE\");\n+                    }\n+\n+                    scanning = scanNetwork;", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3NTgyMg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437675822", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-06-09T19:45:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NDkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NTA3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436475075", "bodyText": "what is the point of setting this to false if you are breaking out of the loop in the next statement?", "author": "cpmeister", "createdAt": "2020-06-08T06:12:14Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress mIPAddress;\n+    protected HashMap<String, GreeAirDevice> mDevicesHashMap = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        mIPAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        mIPAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        // Send the Scan message\n+        GreeScanRequest4GsonDTO scanGson = new GreeScanRequest4GsonDTO();\n+        scanGson.t = \"scan\";\n+\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        Gson gson = gsonBuilder.create();\n+        String scanReq = gson.toJson(scanGson);\n+        sendData = scanReq.getBytes();\n+\n+        logger.trace(\"Sending scan packet to {}\", mIPAddress.getHostAddress());\n+        try {\n+            DatagramSocket clientSocket = socket.get();\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, mIPAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            boolean scanning = true;\n+            int retries = MAX_SCAN_CYCLES;\n+            while (scanning && (retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponse4GsonDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanResponse4GsonDTO.class);\n+\n+                    // If there was no pack, ignore the response\n+                    if (scanResponseGson.pack == null) {\n+                        logger.debug(\"Invalid packet format, ignore\");\n+                        continue;\n+                    }\n+\n+                    // Decrypt message - a a GreeException is thrown when something went wrong\n+                    scanResponseGson.decryptedPack = GreeCryptoUtil\n+                            .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n+                    String decryptedMsg = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                            scanResponseGson.pack);\n+\n+                    logger.debug(\"Response received from address {}: {}\", remoteAddress.getHostAddress(), decryptedMsg);\n+\n+                    // Create the JSON to hold the response values\n+                    stringReader = new StringReader(decryptedMsg);\n+                    scanResponseGson.packJson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanReponsePack4GsonDTO.class);\n+\n+                    // Now make sure the device is reported as a Gree device\n+                    if (scanResponseGson.packJson.brand.equalsIgnoreCase(\"gree\")) {\n+                        // Create a new GreeDevice\n+                        logger.debug(\"Discovered device at {}:{}\", remoteAddress.getHostAddress(), remotePort);\n+                        GreeAirDevice newDevice = new GreeAirDevice();\n+                        newDevice.setAddress(remoteAddress);\n+                        newDevice.setPort(remotePort);\n+                        newDevice.setScanResponseGson(scanResponseGson);\n+                        addDevice(newDevice);\n+                    } else {\n+                        logger.debug(\"Unit discovered, but brand is not GREE\");\n+                    }\n+\n+                    scanning = scanNetwork;\n+                } catch (SocketTimeoutException e) {\n+                    // We've received a timeout so lets quit searching for devices\n+                    scanning = false;", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3NjE0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437676141", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-06-09T19:45:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NTA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NTg4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436475882", "bodyText": "Although less concise, I find this to be a bit more readable.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (--retries == 0) {\n          \n          \n            \n                                retries--;\n          \n          \n            \n                                if (retries == 0) {", "author": "cpmeister", "createdAt": "2020-06-08T06:15:01Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress mIPAddress;\n+    protected HashMap<String, GreeAirDevice> mDevicesHashMap = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        mIPAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        mIPAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        // Send the Scan message\n+        GreeScanRequest4GsonDTO scanGson = new GreeScanRequest4GsonDTO();\n+        scanGson.t = \"scan\";\n+\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        Gson gson = gsonBuilder.create();\n+        String scanReq = gson.toJson(scanGson);\n+        sendData = scanReq.getBytes();\n+\n+        logger.trace(\"Sending scan packet to {}\", mIPAddress.getHostAddress());\n+        try {\n+            DatagramSocket clientSocket = socket.get();\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, mIPAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            boolean scanning = true;\n+            int retries = MAX_SCAN_CYCLES;\n+            while (scanning && (retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponse4GsonDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanResponse4GsonDTO.class);\n+\n+                    // If there was no pack, ignore the response\n+                    if (scanResponseGson.pack == null) {\n+                        logger.debug(\"Invalid packet format, ignore\");\n+                        continue;\n+                    }\n+\n+                    // Decrypt message - a a GreeException is thrown when something went wrong\n+                    scanResponseGson.decryptedPack = GreeCryptoUtil\n+                            .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n+                    String decryptedMsg = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                            scanResponseGson.pack);\n+\n+                    logger.debug(\"Response received from address {}: {}\", remoteAddress.getHostAddress(), decryptedMsg);\n+\n+                    // Create the JSON to hold the response values\n+                    stringReader = new StringReader(decryptedMsg);\n+                    scanResponseGson.packJson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanReponsePack4GsonDTO.class);\n+\n+                    // Now make sure the device is reported as a Gree device\n+                    if (scanResponseGson.packJson.brand.equalsIgnoreCase(\"gree\")) {\n+                        // Create a new GreeDevice\n+                        logger.debug(\"Discovered device at {}:{}\", remoteAddress.getHostAddress(), remotePort);\n+                        GreeAirDevice newDevice = new GreeAirDevice();\n+                        newDevice.setAddress(remoteAddress);\n+                        newDevice.setPort(remotePort);\n+                        newDevice.setScanResponseGson(scanResponseGson);\n+                        addDevice(newDevice);\n+                    } else {\n+                        logger.debug(\"Unit discovered, but brand is not GREE\");\n+                    }\n+\n+                    scanning = scanNetwork;\n+                } catch (SocketTimeoutException e) {\n+                    // We've received a timeout so lets quit searching for devices\n+                    scanning = false;\n+                    break;\n+                } catch (IOException e) {\n+                    if (--retries == 0) {", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzNTk0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437035941", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-08T22:28:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NTg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NjQwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436476401", "bodyText": "Please use collection interfaces rather than concrete types if possible.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public HashMap<String, GreeAirDevice> getDevices() {\n          \n          \n            \n                public Map<String, GreeAirDevice> getDevices() {", "author": "cpmeister", "createdAt": "2020-06-08T06:16:52Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress mIPAddress;\n+    protected HashMap<String, GreeAirDevice> mDevicesHashMap = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        mIPAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        mIPAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        // Send the Scan message\n+        GreeScanRequest4GsonDTO scanGson = new GreeScanRequest4GsonDTO();\n+        scanGson.t = \"scan\";\n+\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        Gson gson = gsonBuilder.create();\n+        String scanReq = gson.toJson(scanGson);\n+        sendData = scanReq.getBytes();\n+\n+        logger.trace(\"Sending scan packet to {}\", mIPAddress.getHostAddress());\n+        try {\n+            DatagramSocket clientSocket = socket.get();\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, mIPAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            boolean scanning = true;\n+            int retries = MAX_SCAN_CYCLES;\n+            while (scanning && (retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponse4GsonDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanResponse4GsonDTO.class);\n+\n+                    // If there was no pack, ignore the response\n+                    if (scanResponseGson.pack == null) {\n+                        logger.debug(\"Invalid packet format, ignore\");\n+                        continue;\n+                    }\n+\n+                    // Decrypt message - a a GreeException is thrown when something went wrong\n+                    scanResponseGson.decryptedPack = GreeCryptoUtil\n+                            .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n+                    String decryptedMsg = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                            scanResponseGson.pack);\n+\n+                    logger.debug(\"Response received from address {}: {}\", remoteAddress.getHostAddress(), decryptedMsg);\n+\n+                    // Create the JSON to hold the response values\n+                    stringReader = new StringReader(decryptedMsg);\n+                    scanResponseGson.packJson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanReponsePack4GsonDTO.class);\n+\n+                    // Now make sure the device is reported as a Gree device\n+                    if (scanResponseGson.packJson.brand.equalsIgnoreCase(\"gree\")) {\n+                        // Create a new GreeDevice\n+                        logger.debug(\"Discovered device at {}:{}\", remoteAddress.getHostAddress(), remotePort);\n+                        GreeAirDevice newDevice = new GreeAirDevice();\n+                        newDevice.setAddress(remoteAddress);\n+                        newDevice.setPort(remotePort);\n+                        newDevice.setScanResponseGson(scanResponseGson);\n+                        addDevice(newDevice);\n+                    } else {\n+                        logger.debug(\"Unit discovered, but brand is not GREE\");\n+                    }\n+\n+                    scanning = scanNetwork;\n+                } catch (SocketTimeoutException e) {\n+                    // We've received a timeout so lets quit searching for devices\n+                    scanning = false;\n+                    break;\n+                } catch (IOException e) {\n+                    if (--retries == 0) {\n+                        throw new GreeException(e, \"Exception on device scan\");\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"I/O exception during device scan\");\n+        }\n+    }\n+\n+    public void addDevice(GreeAirDevice newDevice) {\n+        mDevicesHashMap.put(newDevice.getId(), newDevice);\n+    }\n+\n+    public GreeAirDevice getDevice(String id) {\n+        return mDevicesHashMap.get(id);\n+    }\n+\n+    public HashMap<String, GreeAirDevice> getDevices() {", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzNjIxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437036211", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-08T22:28:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NjQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NjY4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436476682", "bodyText": "Java will automatically handle conversion of primitive->object (aka boxing) for you.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new Integer(mDevicesHashMap.size());\n          \n          \n            \n                    return mDevicesHashMap.size();", "author": "cpmeister", "createdAt": "2020-06-08T06:17:49Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress mIPAddress;\n+    protected HashMap<String, GreeAirDevice> mDevicesHashMap = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        mIPAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        mIPAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        // Send the Scan message\n+        GreeScanRequest4GsonDTO scanGson = new GreeScanRequest4GsonDTO();\n+        scanGson.t = \"scan\";\n+\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        Gson gson = gsonBuilder.create();\n+        String scanReq = gson.toJson(scanGson);\n+        sendData = scanReq.getBytes();\n+\n+        logger.trace(\"Sending scan packet to {}\", mIPAddress.getHostAddress());\n+        try {\n+            DatagramSocket clientSocket = socket.get();\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, mIPAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            boolean scanning = true;\n+            int retries = MAX_SCAN_CYCLES;\n+            while (scanning && (retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponse4GsonDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanResponse4GsonDTO.class);\n+\n+                    // If there was no pack, ignore the response\n+                    if (scanResponseGson.pack == null) {\n+                        logger.debug(\"Invalid packet format, ignore\");\n+                        continue;\n+                    }\n+\n+                    // Decrypt message - a a GreeException is thrown when something went wrong\n+                    scanResponseGson.decryptedPack = GreeCryptoUtil\n+                            .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n+                    String decryptedMsg = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                            scanResponseGson.pack);\n+\n+                    logger.debug(\"Response received from address {}: {}\", remoteAddress.getHostAddress(), decryptedMsg);\n+\n+                    // Create the JSON to hold the response values\n+                    stringReader = new StringReader(decryptedMsg);\n+                    scanResponseGson.packJson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanReponsePack4GsonDTO.class);\n+\n+                    // Now make sure the device is reported as a Gree device\n+                    if (scanResponseGson.packJson.brand.equalsIgnoreCase(\"gree\")) {\n+                        // Create a new GreeDevice\n+                        logger.debug(\"Discovered device at {}:{}\", remoteAddress.getHostAddress(), remotePort);\n+                        GreeAirDevice newDevice = new GreeAirDevice();\n+                        newDevice.setAddress(remoteAddress);\n+                        newDevice.setPort(remotePort);\n+                        newDevice.setScanResponseGson(scanResponseGson);\n+                        addDevice(newDevice);\n+                    } else {\n+                        logger.debug(\"Unit discovered, but brand is not GREE\");\n+                    }\n+\n+                    scanning = scanNetwork;\n+                } catch (SocketTimeoutException e) {\n+                    // We've received a timeout so lets quit searching for devices\n+                    scanning = false;\n+                    break;\n+                } catch (IOException e) {\n+                    if (--retries == 0) {\n+                        throw new GreeException(e, \"Exception on device scan\");\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"I/O exception during device scan\");\n+        }\n+    }\n+\n+    public void addDevice(GreeAirDevice newDevice) {\n+        mDevicesHashMap.put(newDevice.getId(), newDevice);\n+    }\n+\n+    public GreeAirDevice getDevice(String id) {\n+        return mDevicesHashMap.get(id);\n+    }\n+\n+    public HashMap<String, GreeAirDevice> getDevices() {\n+        return mDevicesHashMap;\n+    }\n+\n+    public @Nullable GreeAirDevice getDeviceByIPAddress(String ipAddress) {\n+        GreeAirDevice returnDevice = null;\n+\n+        Set<String> keySet = mDevicesHashMap.keySet();\n+        Iterator<String> iter = keySet.iterator();\n+        while (returnDevice == null && iter.hasNext()) {\n+            Object thiskey = iter.next();\n+            if (mDevicesHashMap.containsKey(thiskey)) {\n+                GreeAirDevice currDevice = mDevicesHashMap.get(thiskey);\n+                if (currDevice.getAddress().getHostAddress().equals(ipAddress)) {\n+                    returnDevice = currDevice;\n+                }\n+            }\n+        }\n+\n+        return returnDevice;\n+    }\n+\n+    public Integer getScannedDeviceCount() {\n+        return new Integer(mDevicesHashMap.size());", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzNjQ1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437036459", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-08T22:29:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NjY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NzA5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436477099", "bodyText": "You should make sure to call the super's destructor last.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    super.deactivate();\n          \n          \n            \n                    removeOlderResults(getTimestampOfLastScan());\n          \n          \n            \n                    removeOlderResults(getTimestampOfLastScan());\n          \n          \n            \n                    super.deactivate();", "author": "cpmeister", "createdAt": "2020-06-08T06:19:23Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.gree\")\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT_SEC = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    @Activate\n+    public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n+        Bundle bundle = FrameworkUtil.getBundle(this.getClass());\n+        messages = new GreeTranslationProvider(bundle.getBundleContext().getBundle(), i18nProvider, localeProvider);\n+        String ip = networkAddressService.getConfiguredBroadcastAddress();\n+        broadcastAddress = ip != null ? ip : \"\";\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    @Modified\n+    protected void modified(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.modified(configProperties);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        // It's very unusual that a new unit gets installed frequently so we run the discovery once when the binding is\n+        // started, but not frequently\n+        scheduler.execute(() -> {\n+            startScan();\n+        });\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        stopScan();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        Optional<DatagramSocket> clientSocket = Optional.empty();\n+        try {\n+            clientSocket = Optional.of(new DatagramSocket());\n+            deviceFinder = new GreeDeviceFinder(broadcastAddress);\n+            deviceFinder.scan(clientSocket, true);\n+\n+            int count = deviceFinder.getScannedDeviceCount();\n+            logger.info(\"{}\", messages.get(\"discovery.result\", count));\n+            if (count > 0) {\n+                logger.debug(\"Adding uinits to Inbox\");\n+                createResult(deviceFinder.getDevices());\n+            }\n+        } catch (GreeException e) {\n+            logger.warn(\"Discovery failed: {}\", e.toString());\n+        } catch (IOException e) {\n+            logger.debug(\"Discovery failed: {}\", e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Discovery failed\", e);\n+        } finally {\n+            if (clientSocket.isPresent()) {\n+                clientSocket.get().close();\n+            }\n+        }\n+    }\n+\n+    public void createResult(HashMap<String, GreeAirDevice> deviceList) {\n+        for (Map.Entry<String, GreeAirDevice> d : deviceList.entrySet()) {\n+            GreeAirDevice device = d.getValue();\n+            String ipAddress = device.getAddress().getHostAddress();\n+            logger.debug(\"{}\", messages.get(\"discovery.newunit\", device.getName(), ipAddress, device.getId()));\n+            Map<String, Object> properties = new TreeMap<String, Object>();\n+            properties.put(Thing.PROPERTY_VENDOR, device.getVendor());\n+            properties.put(Thing.PROPERTY_MODEL_ID, device.getModel());\n+            properties.put(Thing.PROPERTY_MAC_ADDRESS, device.getId());\n+            properties.put(PROPERTY_IP, ipAddress);\n+            properties.put(PROPERTY_BROADCAST, broadcastAddress);\n+            ThingUID thingUID = new ThingUID(THING_TYPE_GREEAIRCON, device.getId());\n+            DiscoveryResult result = DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n+                    .withRepresentationProperty(device.getId()).withLabel(device.getName()).build();\n+            thingDiscovered(result);\n+        }\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        removeOlderResults(getTimestampOfLastScan());", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzNjc2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437036765", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-08T22:30:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NzA5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NzQ4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436477486", "bodyText": "I don't see why clientSocket is Optional here. Please just use a regular local variable instead.", "author": "cpmeister", "createdAt": "2020-06-08T06:20:44Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.gree\")\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT_SEC = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    @Activate\n+    public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n+        Bundle bundle = FrameworkUtil.getBundle(this.getClass());\n+        messages = new GreeTranslationProvider(bundle.getBundleContext().getBundle(), i18nProvider, localeProvider);\n+        String ip = networkAddressService.getConfiguredBroadcastAddress();\n+        broadcastAddress = ip != null ? ip : \"\";\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    @Modified\n+    protected void modified(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.modified(configProperties);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        // It's very unusual that a new unit gets installed frequently so we run the discovery once when the binding is\n+        // started, but not frequently\n+        scheduler.execute(() -> {\n+            startScan();\n+        });\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        stopScan();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        Optional<DatagramSocket> clientSocket = Optional.empty();", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5ODExMw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r438998113", "bodyText": "solved this with a try-with-resources", "author": "markus7017", "createdAt": "2020-06-11T18:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NzQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3Nzg0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436477845", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (Map.Entry<String, GreeAirDevice> d : deviceList.entrySet()) {\n          \n          \n            \n                        GreeAirDevice device = d.getValue();\n          \n          \n            \n                    for (GreeAirDevice device : deviceList.values()) {", "author": "cpmeister", "createdAt": "2020-06-08T06:21:57Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.gree\")\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT_SEC = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    @Activate\n+    public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n+        Bundle bundle = FrameworkUtil.getBundle(this.getClass());\n+        messages = new GreeTranslationProvider(bundle.getBundleContext().getBundle(), i18nProvider, localeProvider);\n+        String ip = networkAddressService.getConfiguredBroadcastAddress();\n+        broadcastAddress = ip != null ? ip : \"\";\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    @Modified\n+    protected void modified(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.modified(configProperties);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        // It's very unusual that a new unit gets installed frequently so we run the discovery once when the binding is\n+        // started, but not frequently\n+        scheduler.execute(() -> {\n+            startScan();\n+        });\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        stopScan();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        Optional<DatagramSocket> clientSocket = Optional.empty();\n+        try {\n+            clientSocket = Optional.of(new DatagramSocket());\n+            deviceFinder = new GreeDeviceFinder(broadcastAddress);\n+            deviceFinder.scan(clientSocket, true);\n+\n+            int count = deviceFinder.getScannedDeviceCount();\n+            logger.info(\"{}\", messages.get(\"discovery.result\", count));\n+            if (count > 0) {\n+                logger.debug(\"Adding uinits to Inbox\");\n+                createResult(deviceFinder.getDevices());\n+            }\n+        } catch (GreeException e) {\n+            logger.warn(\"Discovery failed: {}\", e.toString());\n+        } catch (IOException e) {\n+            logger.debug(\"Discovery failed: {}\", e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Discovery failed\", e);\n+        } finally {\n+            if (clientSocket.isPresent()) {\n+                clientSocket.get().close();\n+            }\n+        }\n+    }\n+\n+    public void createResult(HashMap<String, GreeAirDevice> deviceList) {\n+        for (Map.Entry<String, GreeAirDevice> d : deviceList.entrySet()) {\n+            GreeAirDevice device = d.getValue();", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzNjk5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437036991", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-08T22:31:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3Nzg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NzkyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436477921", "bodyText": "I don't know why you are using a TreeMap here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Map<String, Object> properties = new TreeMap<String, Object>();\n          \n          \n            \n                        Map<String, Object> properties = new HashMap<>();", "author": "cpmeister", "createdAt": "2020-06-08T06:22:08Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.gree\")\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT_SEC = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    @Activate\n+    public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n+        Bundle bundle = FrameworkUtil.getBundle(this.getClass());\n+        messages = new GreeTranslationProvider(bundle.getBundleContext().getBundle(), i18nProvider, localeProvider);\n+        String ip = networkAddressService.getConfiguredBroadcastAddress();\n+        broadcastAddress = ip != null ? ip : \"\";\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    @Modified\n+    protected void modified(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.modified(configProperties);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        // It's very unusual that a new unit gets installed frequently so we run the discovery once when the binding is\n+        // started, but not frequently\n+        scheduler.execute(() -> {\n+            startScan();\n+        });\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        stopScan();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        Optional<DatagramSocket> clientSocket = Optional.empty();\n+        try {\n+            clientSocket = Optional.of(new DatagramSocket());\n+            deviceFinder = new GreeDeviceFinder(broadcastAddress);\n+            deviceFinder.scan(clientSocket, true);\n+\n+            int count = deviceFinder.getScannedDeviceCount();\n+            logger.info(\"{}\", messages.get(\"discovery.result\", count));\n+            if (count > 0) {\n+                logger.debug(\"Adding uinits to Inbox\");\n+                createResult(deviceFinder.getDevices());\n+            }\n+        } catch (GreeException e) {\n+            logger.warn(\"Discovery failed: {}\", e.toString());\n+        } catch (IOException e) {\n+            logger.debug(\"Discovery failed: {}\", e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Discovery failed\", e);\n+        } finally {\n+            if (clientSocket.isPresent()) {\n+                clientSocket.get().close();\n+            }\n+        }\n+    }\n+\n+    public void createResult(HashMap<String, GreeAirDevice> deviceList) {\n+        for (Map.Entry<String, GreeAirDevice> d : deviceList.entrySet()) {\n+            GreeAirDevice device = d.getValue();\n+            String ipAddress = device.getAddress().getHostAddress();\n+            logger.debug(\"{}\", messages.get(\"discovery.newunit\", device.getName(), ipAddress, device.getId()));\n+            Map<String, Object> properties = new TreeMap<String, Object>();", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzNzIxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437037214", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-08T22:31:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NzkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3OTE0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436479143", "bodyText": "It seems redundant to always use 4GsonDTO as your suffix, just using a DTO suffix would be sufficient without being verbose. I'd prefer if you updated the other DTO classes as well.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class GreeBindRequest4GsonDTO {\n          \n          \n            \n            public class GreeBindRequestDTO {", "author": "cpmeister", "createdAt": "2020-06-08T06:25:58Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/gson/GreeBindRequest4GsonDTO.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.gson;\n+\n+/**\n+ *\n+ * The GreeBindRequest4Gson class is used by Gson to hold values to be send to\n+ * the Air Conditioner during Binding\n+ *\n+ * @author John Cunha - Initial contribution\n+ */\n+public class GreeBindRequest4GsonDTO {", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzODIzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437038239", "bodyText": "done", "author": "markus7017", "createdAt": "2020-06-08T22:34:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3OTE0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4MDIzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436480234", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Runnable refresher = new Runnable() {\n          \n          \n            \n                        @Override\n          \n          \n            \n                        public void run() {\n          \n          \n            \n                    Runnable refresher = () -> {", "author": "cpmeister", "createdAt": "2020-06-08T06:29:17Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import tec.uom.se.unit.Units;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.warn(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException e) {\n+            logger.debug(\"Exception on initialization: {}\", e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Initialization failed\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.warn(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"Handle command {} for channel {}, command class {}\", command, channelId, command.getClass());\n+            try {\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, (int) getTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(command, socket);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelId, e.toString());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"Invalid command value {}\u00a0for channel {}\", command, channelUID.getId());\n+            } catch (RuntimeException e) {\n+                logger.warn(\"Unable to execute command {}\u00a0for channel {}\", command, channelId, e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+            logger.debug(\"Send Auto-ON for mode {}\", mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"Select mode {}\", mode);\n+        device.SetDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"Turn on Power-Saving\");\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+            case MODE_TURBO:\n+                device.setDeviceTurbo(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        }\n+        throw new IllegalArgumentException(\"Invalid QuietType\");\n+    }\n+\n+    private int getOnOff(Command command) {\n+        if (command instanceof OnOffType) {\n+            return ((OnOffType) command) == OnOffType.ON ? 1 : 0;\n+        }\n+        if ((command instanceof DecimalType) && (((DecimalType) command).intValue() <= 2)) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalid OnOffType\");\n+    }\n+\n+    private int getNumber(Command command) {\n+        if (command instanceof DecimalType) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalud Number type\");\n+    }\n+\n+    private double getTemp(Command command) {\n+        if (command instanceof DecimalType) {\n+            // assume Celsius\n+            return ((DecimalType) command).doubleValue();\n+        }\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> q = (QuantityType<?>) command;\n+            if (q.getUnit() == Units.CELSIUS) {\n+                return q.intValue();\n+            }\n+            if (q.getUnit() == ImperialUnits.FAHRENHEIT) {\n+                return ImperialUnits.FAHRENHEIT.getConverterTo(Units.CELSIUS).convert(q.doubleValue());\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Invalud Temp type\");\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = System.currentTimeMillis();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (timeSinceLastRefresh < MINIMUM_REFRESH_TIME_MS) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void startAutomaticRefresh() {\n+\n+        Runnable refresher = new Runnable() {\n+            @Override\n+            public void run() {", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzODY1MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437038650", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-08T22:35:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4MDIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4MTE1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436481157", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (q.getUnit() == Units.CELSIUS) {\n          \n          \n            \n                            return q.intValue();\n          \n          \n            \n                        }\n          \n          \n            \n                        if (q.getUnit() == ImperialUnits.FAHRENHEIT) {\n          \n          \n            \n                            return ImperialUnits.FAHRENHEIT.getConverterTo(Units.CELSIUS).convert(q.doubleValue());\n          \n          \n            \n                        }\n          \n          \n            \n                        return q.toUnit(SIUnits.CELSIUS).doubleValue();", "author": "cpmeister", "createdAt": "2020-06-08T06:32:01Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import tec.uom.se.unit.Units;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.warn(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException e) {\n+            logger.debug(\"Exception on initialization: {}\", e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Initialization failed\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.warn(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"Handle command {} for channel {}, command class {}\", command, channelId, command.getClass());\n+            try {\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, (int) getTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(command, socket);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelId, e.toString());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"Invalid command value {}\u00a0for channel {}\", command, channelUID.getId());\n+            } catch (RuntimeException e) {\n+                logger.warn(\"Unable to execute command {}\u00a0for channel {}\", command, channelId, e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+            logger.debug(\"Send Auto-ON for mode {}\", mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"Select mode {}\", mode);\n+        device.SetDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"Turn on Power-Saving\");\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+            case MODE_TURBO:\n+                device.setDeviceTurbo(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        }\n+        throw new IllegalArgumentException(\"Invalid QuietType\");\n+    }\n+\n+    private int getOnOff(Command command) {\n+        if (command instanceof OnOffType) {\n+            return ((OnOffType) command) == OnOffType.ON ? 1 : 0;\n+        }\n+        if ((command instanceof DecimalType) && (((DecimalType) command).intValue() <= 2)) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalid OnOffType\");\n+    }\n+\n+    private int getNumber(Command command) {\n+        if (command instanceof DecimalType) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalud Number type\");\n+    }\n+\n+    private double getTemp(Command command) {\n+        if (command instanceof DecimalType) {\n+            // assume Celsius\n+            return ((DecimalType) command).doubleValue();\n+        }\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> q = (QuantityType<?>) command;\n+            if (q.getUnit() == Units.CELSIUS) {\n+                return q.intValue();\n+            }\n+            if (q.getUnit() == ImperialUnits.FAHRENHEIT) {\n+                return ImperialUnits.FAHRENHEIT.getConverterTo(Units.CELSIUS).convert(q.doubleValue());\n+            }", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzOTYxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437039619", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-08T22:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4MTE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4MTczNA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436481734", "bodyText": "Your use of Optional here could easily be substituted for a regular variable.\nPlease change all of your \"update*\" methods accordingly.", "author": "cpmeister", "createdAt": "2020-06-08T06:33:46Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import tec.uom.se.unit.Units;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.warn(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException e) {\n+            logger.debug(\"Exception on initialization: {}\", e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Initialization failed\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.warn(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"Handle command {} for channel {}, command class {}\", command, channelId, command.getClass());\n+            try {\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, (int) getTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(command, socket);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelId, e.toString());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"Invalid command value {}\u00a0for channel {}\", command, channelUID.getId());\n+            } catch (RuntimeException e) {\n+                logger.warn(\"Unable to execute command {}\u00a0for channel {}\", command, channelId, e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+            logger.debug(\"Send Auto-ON for mode {}\", mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"Select mode {}\", mode);\n+        device.SetDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"Turn on Power-Saving\");\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+            case MODE_TURBO:\n+                device.setDeviceTurbo(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        }\n+        throw new IllegalArgumentException(\"Invalid QuietType\");\n+    }\n+\n+    private int getOnOff(Command command) {\n+        if (command instanceof OnOffType) {\n+            return ((OnOffType) command) == OnOffType.ON ? 1 : 0;\n+        }\n+        if ((command instanceof DecimalType) && (((DecimalType) command).intValue() <= 2)) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalid OnOffType\");\n+    }\n+\n+    private int getNumber(Command command) {\n+        if (command instanceof DecimalType) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalud Number type\");\n+    }\n+\n+    private double getTemp(Command command) {\n+        if (command instanceof DecimalType) {\n+            // assume Celsius\n+            return ((DecimalType) command).doubleValue();\n+        }\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> q = (QuantityType<?>) command;\n+            if (q.getUnit() == Units.CELSIUS) {\n+                return q.intValue();\n+            }\n+            if (q.getUnit() == ImperialUnits.FAHRENHEIT) {\n+                return ImperialUnits.FAHRENHEIT.getConverterTo(Units.CELSIUS).convert(q.doubleValue());\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Invalud Temp type\");\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = System.currentTimeMillis();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (timeSinceLastRefresh < MINIMUM_REFRESH_TIME_MS) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void startAutomaticRefresh() {\n+\n+        Runnable refresher = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                try {\n+                    logger.debug(\"Executing automatic update of values\");\n+                    // safeguard for multiple REFRESH commands\n+                    if (isMinimumRefreshTimeExceeded()) {\n+                        // Get the current status from the Airconditioner\n+                        device.getDeviceStatus(clientSocket.get());\n+                    } else {\n+                        logger.trace(\n+                                \"Skipped fetching status values from device because minimum refresh time not reached\");\n+                    }\n+\n+                    // Update All Channels\n+                    List<Channel> channels = getThing().getChannels();\n+                    for (Channel channel : channels) {\n+                        publishChannel(channel.getUID());\n+                    }\n+                } catch (GreeException e) {\n+                    if (!e.isTimeout()) {\n+                        logger.warn(\"Unable to perform auto-update: {}\", e.toString());\n+                    }\n+                } catch (RuntimeException e) {\n+                    logger.warn(\"Unable to perform auto-update\", e);\n+                }\n+            }\n+        };\n+\n+        refreshTask = scheduler.scheduleWithFixedDelay(refresher, 0, config.refresh, TimeUnit.SECONDS);\n+        logger.debug(\"Automatic refresh started ({} second interval)\", config.refresh);\n+    }\n+\n+    private void publishChannel(ChannelUID channelUID) throws GreeException {\n+        try {\n+            String channelID = channelUID.getId();\n+            Optional<State> state = Optional.empty();", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAwMTIxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439001213", "bodyText": "that's right, Optional is really overdriven\nchanged", "author": "markus7017", "createdAt": "2020-06-11T18:52:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4MTczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4MjUyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436482526", "bodyText": "This exception will always be thrown", "author": "cpmeister", "createdAt": "2020-06-08T06:36:14Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import tec.uom.se.unit.Units;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.warn(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException e) {\n+            logger.debug(\"Exception on initialization: {}\", e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Initialization failed\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.warn(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"Handle command {} for channel {}, command class {}\", command, channelId, command.getClass());\n+            try {\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, (int) getTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(command, socket);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelId, e.toString());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"Invalid command value {}\u00a0for channel {}\", command, channelUID.getId());\n+            } catch (RuntimeException e) {\n+                logger.warn(\"Unable to execute command {}\u00a0for channel {}\", command, channelId, e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+            logger.debug(\"Send Auto-ON for mode {}\", mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"Select mode {}\", mode);\n+        device.SetDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"Turn on Power-Saving\");\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+            case MODE_TURBO:\n+                device.setDeviceTurbo(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        }\n+        throw new IllegalArgumentException(\"Invalid QuietType\");", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzOTgyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437039824", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-08T22:38:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4MjUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4Mjk1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436482954", "bodyText": "This error doesn't make any sense if the user passes a DecimalType with a value > 2.\nAlso shouldn't you also throw an error if the user passes in a negative DecimalType?", "author": "cpmeister", "createdAt": "2020-06-08T06:37:28Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import tec.uom.se.unit.Units;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.warn(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException e) {\n+            logger.debug(\"Exception on initialization: {}\", e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Initialization failed\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.warn(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"Handle command {} for channel {}, command class {}\", command, channelId, command.getClass());\n+            try {\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, (int) getTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(command, socket);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelId, e.toString());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"Invalid command value {}\u00a0for channel {}\", command, channelUID.getId());\n+            } catch (RuntimeException e) {\n+                logger.warn(\"Unable to execute command {}\u00a0for channel {}\", command, channelId, e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+            logger.debug(\"Send Auto-ON for mode {}\", mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"Select mode {}\", mode);\n+        device.SetDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"Turn on Power-Saving\");\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+            case MODE_TURBO:\n+                device.setDeviceTurbo(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        }\n+        throw new IllegalArgumentException(\"Invalid QuietType\");\n+    }\n+\n+    private int getOnOff(Command command) {\n+        if (command instanceof OnOffType) {\n+            return ((OnOffType) command) == OnOffType.ON ? 1 : 0;\n+        }\n+        if ((command instanceof DecimalType) && (((DecimalType) command).intValue() <= 2)) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalid OnOffType\");", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAwMjgwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439002809", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-11T18:55:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4Mjk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NDIxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436484216", "bodyText": "To safe the caller from casting the result, perhaps you should just change the return type?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private double getTemp(Command command) {\n          \n          \n            \n                private int getTemp(Command command) {", "author": "cpmeister", "createdAt": "2020-06-08T06:40:48Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import tec.uom.se.unit.Units;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.warn(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException e) {\n+            logger.debug(\"Exception on initialization: {}\", e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Initialization failed\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.warn(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"Handle command {} for channel {}, command class {}\", command, channelId, command.getClass());\n+            try {\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, (int) getTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(command, socket);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelId, e.toString());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"Invalid command value {}\u00a0for channel {}\", command, channelUID.getId());\n+            } catch (RuntimeException e) {\n+                logger.warn(\"Unable to execute command {}\u00a0for channel {}\", command, channelId, e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+            logger.debug(\"Send Auto-ON for mode {}\", mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"Select mode {}\", mode);\n+        device.SetDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"Turn on Power-Saving\");\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+            case MODE_TURBO:\n+                device.setDeviceTurbo(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        }\n+        throw new IllegalArgumentException(\"Invalid QuietType\");\n+    }\n+\n+    private int getOnOff(Command command) {\n+        if (command instanceof OnOffType) {\n+            return ((OnOffType) command) == OnOffType.ON ? 1 : 0;\n+        }\n+        if ((command instanceof DecimalType) && (((DecimalType) command).intValue() <= 2)) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalid OnOffType\");\n+    }\n+\n+    private int getNumber(Command command) {\n+        if (command instanceof DecimalType) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalud Number type\");\n+    }\n+\n+    private double getTemp(Command command) {", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0MDI0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437040243", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-08T22:40:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NDIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NTM5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436485393", "bodyText": "Maybe it would be better to just have your value stay as a QuantityType so that it can handle unit conversion for you.", "author": "cpmeister", "createdAt": "2020-06-08T06:44:14Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = bindResponseGson.packJson.key;\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"failed\");\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (!getIsBound() || (value < 0 || value > 5)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"WdSpd\", value);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"NoiseSet\", 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Tur\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 2)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Quiet\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(\"Tur\");\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Lig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Create Hash Look Up for C and F\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\n+     */\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\n+        HashMap<String, Integer> hmf = new HashMap<>();\n+        HashMap<String, Integer> hmc = new HashMap<>();\n+\n+        hmf.put(\"min\", 61); // F\n+        hmf.put(\"max\", 86);\n+        tempRanges.put(\"F\", hmf);\n+\n+        hmc.put(\"min\", 16); // C\n+        hmc.put(\"max\", 30);\n+        tempRanges.put(\"C\", hmc);\n+\n+        return tempRanges;\n+    }\n+\n+    /**\n+     * Checks input ranges for validity and TempUn for validity\n+     * Uses newVal as priority and tries to validate and determine intent\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\n+     */\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\n+                                                    // string for hashmap\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\n+        nullCorFLUT.put(\"C\", 0);\n+        nullCorFLUT.put(\"F\", 1);\n+        nullCorFLUT.put(\"INVALID\", 0);\n+\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\n+\n+        // force to global min/max\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\n+\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\n+            validRangeCorF = \"C\";\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\n+            validRangeCorF = \"F\";\n+        } else {\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\n+            validRangeCorF = \"INVALID\";\n+        }\n+\n+        // if CorF wasnt initialized or is null set it from lookup\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\n+\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\n+            CorF = 0; // input temp takes priority\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\n+            CorF = 1; // input temp takes priority\n+        } else if (validRangeCorF.equals(\"INVALID\")) {\n+            // force min or max temp based on CorF scale to be used\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\n+        }\n+\n+        return new int[] { newVal, CorF };\n+    }\n+\n+    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAwNDQ4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439004485", "bodyText": "getTemp() converts Fahrenheit to Celsius, the underlying code only supports Celsius", "author": "markus7017", "createdAt": "2020-06-11T18:58:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NTM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NjM0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436486345", "bodyText": "Please use the camelcase naming convention.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private GreeScanResponse4GsonDTO mScanResponseGson;\n          \n          \n            \n                private GreeScanResponse4GsonDTO scanResponseGson;", "author": "cpmeister", "createdAt": "2020-06-08T06:46:46Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYzMjkxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437632916", "bodyText": "done", "author": "markus7017", "createdAt": "2020-06-09T18:26:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NjM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NjQ3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436486472", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n          \n          \n            \n                private final static Charset UTF8_CHARSET = StandardCharsets.UTF_8;", "author": "cpmeister", "createdAt": "2020-06-08T06:47:08Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5OTQzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437699435", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-09T20:30:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NjQ3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NjY2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436486669", "bodyText": "Please make this a private static field so you can reuse it.", "author": "cpmeister", "createdAt": "2020-06-08T06:47:40Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYzMzYxMA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437633610", "bodyText": "done", "author": "markus7017", "createdAt": "2020-06-09T18:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NjY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NzY0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436487648", "bodyText": "This code seems repeated a lot, can you refactor it?", "author": "cpmeister", "createdAt": "2020-06-08T06:50:06Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = bindResponseGson.packJson.key;\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"failed\");\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (!getIsBound() || (value < 0 || value > 5)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"WdSpd\", value);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"NoiseSet\", 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Tur\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 2)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Quiet\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(\"Tur\");\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Lig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Create Hash Look Up for C and F\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\n+     */\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\n+        HashMap<String, Integer> hmf = new HashMap<>();\n+        HashMap<String, Integer> hmc = new HashMap<>();\n+\n+        hmf.put(\"min\", 61); // F\n+        hmf.put(\"max\", 86);\n+        tempRanges.put(\"F\", hmf);\n+\n+        hmc.put(\"min\", 16); // C\n+        hmc.put(\"max\", 30);\n+        tempRanges.put(\"C\", hmc);\n+\n+        return tempRanges;\n+    }\n+\n+    /**\n+     * Checks input ranges for validity and TempUn for validity\n+     * Uses newVal as priority and tries to validate and determine intent\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\n+     */\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\n+                                                    // string for hashmap\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\n+        nullCorFLUT.put(\"C\", 0);\n+        nullCorFLUT.put(\"F\", 1);\n+        nullCorFLUT.put(\"INVALID\", 0);\n+\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\n+\n+        // force to global min/max\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\n+\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\n+            validRangeCorF = \"C\";\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\n+            validRangeCorF = \"F\";\n+        } else {\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\n+            validRangeCorF = \"INVALID\";\n+        }\n+\n+        // if CorF wasnt initialized or is null set it from lookup\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\n+\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\n+            CorF = 0; // input temp takes priority\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\n+            CorF = 1; // input temp takes priority\n+        } else if (validRangeCorF.equals(\"INVALID\")) {\n+            // force min or max temp based on CorF scale to be used\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\n+        }\n+\n+        return new int[] { newVal, CorF };\n+    }\n+\n+    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n+        // **value** : set temperature in degrees celsius or Fahrenheit\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+        int newVal = value;\n+        int outVal = value;\n+        // Get Celsius or Fahrenheit from status message\n+        Integer CorF = getIntStatusVal(\"TemUn\");\n+        // TODO put a param in openhab to allow setting this from the config\n+\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        int halfStep = 0; // default to C\n+\n+        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n+        newVal = retList[0];\n+        CorF = retList[1];\n+\n+        if (CorF == 1) { // If Fahrenheit,\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+            outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\n+            // 84. , 85. , 86. ]\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+            // 28.8, 29.4, 30.0]\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // subtract the float version - the int version to get the fractional difference\n+            // if the difference is positive set halfStep to 1, negative to 0\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"TemUn\", CorF);\n+        parameters.put(\"SetTem\", outVal);\n+        parameters.put(\"TemRec\", halfStep);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Air\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Blo\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Health\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SvSt\", value);\n+        parameters.put(\"WdSpd\", 0);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"SwhSlp\", 0);\n+        parameters.put(\"SlpMod\", 0);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        String columns[] = statusResponseGson.packJson.cols;\n+        Integer values[] = statusResponseGson.packJson.dat;\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));\n+        int valueArrayposition = colList.indexOf(valueName);\n+        if (valueArrayposition == -1) {\n+            return -1;\n+        }\n+\n+        // Now get the Corresponding value\n+        Integer value = valList.get(valueArrayposition);\n+        return value;\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (prevStatusResponsePackGson == null) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        String currcolumns[] = statusResponseGson.packJson.cols;\n+        Integer currvalues[] = statusResponseGson.packJson.dat;\n+        List<String> currcolList = new ArrayList<>(Arrays.asList(currcolumns));\n+        List<Integer> currvalList = new ArrayList<>(Arrays.asList(currvalues));\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\n+        if (currvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to decode device status\");\n+        }\n+        // Now get the Corresponding value\n+        int currvalue = currvalList.get(currvalueArrayposition);\n+\n+        // Find the valueName in the Previous Status object\n+        String prevcolumns[] = prevStatusResponsePackGson.cols;\n+        Integer prevvalues[] = prevStatusResponsePackGson.dat;\n+        List<String> prevcolList = new ArrayList<>(Arrays.asList(prevcolumns));\n+        List<Integer> prevvalList = new ArrayList<>(Arrays.asList(prevvalues));\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\n+        if (prevvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to get status value\");\n+        }\n+        // Now get the Corresponding value\n+        int prevvalue = prevvalList.get(prevvalueArrayposition);\n+\n+        // Finally Compare the values\n+        return currvalue != prevvalue;\n+    }\n+\n+    protected void executeCommand(DatagramSocket clientSocket, HashMap<String, Integer> parameters)\n+            throws GreeException {\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Convert the parameter map values to arrays\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\n+\n+            // Prep the Command Request pack\n+            GreeExecuteCommandPack4GsonDTO execCmdPackGson = new GreeExecuteCommandPack4GsonDTO();\n+            execCmdPackGson.opt = keyArray;\n+            execCmdPackGson.p = valueArray;\n+            execCmdPackGson.t = \"cmd\";\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), execCmdPackStr);\n+            // String unencryptedCommandReqPacket = CryptoUtil.decryptPack(device.getKey().getBytes(),\n+            // encryptedCommandReqPacket);\n+\n+            // Prep the Command Request\n+            GreeExecCommand4GsonDTO execCmdGson = new GreeExecCommand4GsonDTO();\n+            execCmdGson.cid = \"app\";\n+            execCmdGson.i = 0;\n+            execCmdGson.t = \"pack\";\n+            execCmdGson.uid = 0;\n+            execCmdGson.tcid = getId();\n+            execCmdGson.pack = new String(encryptedCommandReqPacket.getBytes(), UTF8_CHARSET);\n+            String execCmdStr = gson.toJson(execCmdGson);\n+            sendData = execCmdStr.getBytes();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            GreeExecResponse4GsonDTO execResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                    GreeExecResponse4GsonDTO.class);\n+            execResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(),\n+                    execResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(execResponseGson.decryptedPack);\n+            execResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeExecResponsePack4GsonDTO.class);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"Exception on command execution\");\n+        }\n+    }\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        Gson gson = new Gson();\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(\"Pow\");\n+            columns.add(\"Mod\");\n+            columns.add(\"SetTem\");\n+            columns.add(\"WdSpd\");\n+            columns.add(\"Air\");\n+            columns.add(\"Blo\");\n+            columns.add(\"Health\");\n+            columns.add(\"SwhSlp\");\n+            columns.add(\"Lig\");\n+            columns.add(\"SwingLfRig\");\n+            columns.add(\"SwUpDn\");\n+            columns.add(\"Quiet\");\n+            columns.add(\"Tur\");\n+            columns.add(\"StHt\");\n+            columns.add(\"TemUn\");\n+            columns.add(\"HeatCoolType\");\n+            columns.add(\"TemRec\");\n+            columns.add(\"SvSt\");\n+            columns.add(\"NoiseSet\");\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPack4GsonDTO reqStatusPackGson = new GreeReqStatusPack4GsonDTO();\n+            reqStatusPackGson.t = \"status\";\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+\n+            // Prep the Status Request\n+            GreeReqStatus4GsonDTO reqStatusGson = new GreeReqStatus4GsonDTO();\n+            reqStatusGson.cid = \"app\";\n+            reqStatusGson.i = 0;\n+            reqStatusGson.t = \"pack\";\n+            reqStatusGson.uid = 0;\n+            reqStatusGson.tcid = getId();\n+            reqStatusGson.pack = new String(encryptedStatusReqPacket.getBytes(), UTF8_CHARSET);", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYzNDU0NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437634544", "bodyText": "3 times, all of them with different Gson structures, how to optimize this?", "author": "markus7017", "createdAt": "2020-06-09T18:29:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NzY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5NDM4MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437694380", "bodyText": "It looks like those 3 gson structures are all identical. Why not just use the same class for all 3 operations?", "author": "cpmeister", "createdAt": "2020-06-09T20:20:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NzY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIyNzMyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439227323", "bodyText": "yep, consolidated with next checkin", "author": "markus7017", "createdAt": "2020-06-12T06:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NzY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4Nzg2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436487868", "bodyText": "I'd prefer if you used the units framework to do your conversions.", "author": "cpmeister", "createdAt": "2020-06-08T06:50:41Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = bindResponseGson.packJson.key;\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"failed\");\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (!getIsBound() || (value < 0 || value > 5)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"WdSpd\", value);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"NoiseSet\", 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Tur\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 2)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Quiet\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(\"Tur\");\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Lig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Create Hash Look Up for C and F\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\n+     */\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\n+        HashMap<String, Integer> hmf = new HashMap<>();\n+        HashMap<String, Integer> hmc = new HashMap<>();\n+\n+        hmf.put(\"min\", 61); // F\n+        hmf.put(\"max\", 86);\n+        tempRanges.put(\"F\", hmf);\n+\n+        hmc.put(\"min\", 16); // C\n+        hmc.put(\"max\", 30);\n+        tempRanges.put(\"C\", hmc);\n+\n+        return tempRanges;\n+    }\n+\n+    /**\n+     * Checks input ranges for validity and TempUn for validity\n+     * Uses newVal as priority and tries to validate and determine intent\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\n+     */\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\n+                                                    // string for hashmap\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\n+        nullCorFLUT.put(\"C\", 0);\n+        nullCorFLUT.put(\"F\", 1);\n+        nullCorFLUT.put(\"INVALID\", 0);\n+\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\n+\n+        // force to global min/max\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\n+\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\n+            validRangeCorF = \"C\";\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\n+            validRangeCorF = \"F\";\n+        } else {\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\n+            validRangeCorF = \"INVALID\";\n+        }\n+\n+        // if CorF wasnt initialized or is null set it from lookup\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\n+\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\n+            CorF = 0; // input temp takes priority\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\n+            CorF = 1; // input temp takes priority\n+        } else if (validRangeCorF.equals(\"INVALID\")) {\n+            // force min or max temp based on CorF scale to be used\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\n+        }\n+\n+        return new int[] { newVal, CorF };\n+    }\n+\n+    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n+        // **value** : set temperature in degrees celsius or Fahrenheit\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+        int newVal = value;\n+        int outVal = value;\n+        // Get Celsius or Fahrenheit from status message\n+        Integer CorF = getIntStatusVal(\"TemUn\");\n+        // TODO put a param in openhab to allow setting this from the config\n+\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        int halfStep = 0; // default to C\n+\n+        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n+        newVal = retList[0];\n+        CorF = retList[1];\n+\n+        if (CorF == 1) { // If Fahrenheit,\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+            outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\n+            // 84. , 85. , 86. ]\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+            // 28.8, 29.4, 30.0]\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // subtract the float version - the int version to get the fractional difference\n+            // if the difference is positive set halfStep to 1, negative to 0\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"TemUn\", CorF);\n+        parameters.put(\"SetTem\", outVal);\n+        parameters.put(\"TemRec\", halfStep);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Air\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Blo\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Health\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SvSt\", value);\n+        parameters.put(\"WdSpd\", 0);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"SwhSlp\", 0);\n+        parameters.put(\"SlpMod\", 0);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        String columns[] = statusResponseGson.packJson.cols;\n+        Integer values[] = statusResponseGson.packJson.dat;\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));\n+        int valueArrayposition = colList.indexOf(valueName);\n+        if (valueArrayposition == -1) {\n+            return -1;\n+        }\n+\n+        // Now get the Corresponding value\n+        Integer value = valList.get(valueArrayposition);\n+        return value;\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (prevStatusResponsePackGson == null) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        String currcolumns[] = statusResponseGson.packJson.cols;\n+        Integer currvalues[] = statusResponseGson.packJson.dat;\n+        List<String> currcolList = new ArrayList<>(Arrays.asList(currcolumns));\n+        List<Integer> currvalList = new ArrayList<>(Arrays.asList(currvalues));\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\n+        if (currvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to decode device status\");\n+        }\n+        // Now get the Corresponding value\n+        int currvalue = currvalList.get(currvalueArrayposition);\n+\n+        // Find the valueName in the Previous Status object\n+        String prevcolumns[] = prevStatusResponsePackGson.cols;\n+        Integer prevvalues[] = prevStatusResponsePackGson.dat;\n+        List<String> prevcolList = new ArrayList<>(Arrays.asList(prevcolumns));\n+        List<Integer> prevvalList = new ArrayList<>(Arrays.asList(prevvalues));\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\n+        if (prevvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to get status value\");\n+        }\n+        // Now get the Corresponding value\n+        int prevvalue = prevvalList.get(prevvalueArrayposition);\n+\n+        // Finally Compare the values\n+        return currvalue != prevvalue;\n+    }\n+\n+    protected void executeCommand(DatagramSocket clientSocket, HashMap<String, Integer> parameters)\n+            throws GreeException {\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Convert the parameter map values to arrays\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\n+\n+            // Prep the Command Request pack\n+            GreeExecuteCommandPack4GsonDTO execCmdPackGson = new GreeExecuteCommandPack4GsonDTO();\n+            execCmdPackGson.opt = keyArray;\n+            execCmdPackGson.p = valueArray;\n+            execCmdPackGson.t = \"cmd\";\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), execCmdPackStr);\n+            // String unencryptedCommandReqPacket = CryptoUtil.decryptPack(device.getKey().getBytes(),\n+            // encryptedCommandReqPacket);\n+\n+            // Prep the Command Request\n+            GreeExecCommand4GsonDTO execCmdGson = new GreeExecCommand4GsonDTO();\n+            execCmdGson.cid = \"app\";\n+            execCmdGson.i = 0;\n+            execCmdGson.t = \"pack\";\n+            execCmdGson.uid = 0;\n+            execCmdGson.tcid = getId();\n+            execCmdGson.pack = new String(encryptedCommandReqPacket.getBytes(), UTF8_CHARSET);\n+            String execCmdStr = gson.toJson(execCmdGson);\n+            sendData = execCmdStr.getBytes();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            GreeExecResponse4GsonDTO execResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                    GreeExecResponse4GsonDTO.class);\n+            execResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(),\n+                    execResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(execResponseGson.decryptedPack);\n+            execResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeExecResponsePack4GsonDTO.class);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"Exception on command execution\");\n+        }\n+    }\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        Gson gson = new Gson();\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(\"Pow\");\n+            columns.add(\"Mod\");\n+            columns.add(\"SetTem\");\n+            columns.add(\"WdSpd\");\n+            columns.add(\"Air\");\n+            columns.add(\"Blo\");\n+            columns.add(\"Health\");\n+            columns.add(\"SwhSlp\");\n+            columns.add(\"Lig\");\n+            columns.add(\"SwingLfRig\");\n+            columns.add(\"SwUpDn\");\n+            columns.add(\"Quiet\");\n+            columns.add(\"Tur\");\n+            columns.add(\"StHt\");\n+            columns.add(\"TemUn\");\n+            columns.add(\"HeatCoolType\");\n+            columns.add(\"TemRec\");\n+            columns.add(\"SvSt\");\n+            columns.add(\"NoiseSet\");\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPack4GsonDTO reqStatusPackGson = new GreeReqStatusPack4GsonDTO();\n+            reqStatusPackGson.t = \"status\";\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+\n+            // Prep the Status Request\n+            GreeReqStatus4GsonDTO reqStatusGson = new GreeReqStatus4GsonDTO();\n+            reqStatusGson.cid = \"app\";\n+            reqStatusGson.i = 0;\n+            reqStatusGson.t = \"pack\";\n+            reqStatusGson.uid = 0;\n+            reqStatusGson.tcid = getId();\n+            reqStatusGson.pack = new String(encryptedStatusReqPacket.getBytes(), UTF8_CHARSET);\n+            String execCmdStr = gson.toJson(reqStatusGson);\n+            sendData = execCmdStr.getBytes();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson != null && statusResponseGson.packJson != null) {\n+                prevStatusResponsePackGson = new GreeStatusResponsePack4GsonDTO(statusResponseGson.packJson);\n+            }\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            statusResponseGson = gson.fromJson(new JsonReader(stringReader), GreeStatusResponse4GsonDTO.class);\n+            statusResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(),\n+                    statusResponseGson.pack);\n+\n+            logger.trace(\"Response from device: {}\", statusResponseGson.decryptedPack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(statusResponseGson.decryptedPack);\n+\n+            statusResponseGson.packJson = gson.fromJson(new JsonReader(stringReader),\n+                    GreeStatusResponsePack4GsonDTO.class);\n+            updateTempFtoC();\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"I/O exception while receiving data\");\n+        }\n+    }\n+\n+    private void updateTempFtoC() {\n+        // Status message back from A/C always reports degrees C\n+        // If using Fahrenheit, us SetTem, TemUn and TemRec to reconstruct the Fahrenheit temperature\n+        // Get Celsius or Fahrenheit from status message\n+        int CorF = getIntStatusVal(\"TemUn\");\n+        int newVal = getIntStatusVal(\"SetTem\");\n+        int halfStep = getIntStatusVal(\"TemRec\");\n+\n+        if ((CorF == -1) || (newVal == -1) || (halfStep == -1)) {\n+            throw new IllegalArgumentException(\"SetTem,TemUn or TemRec is invalid, not performing conversion\");\n+        } else if (CorF == 1) { // convert SetTem to Fahrenheit\n+            // Find the valueName in the Returned Status object\n+            String columns[] = statusResponseGson.packJson.cols;\n+            Integer values[] = statusResponseGson.packJson.dat;\n+            List<String> colList = new ArrayList<>(Arrays.asList(columns));\n+            int valueArrayposition = colList.indexOf(\"SetTem\");\n+            if (valueArrayposition != -1) {\n+                // convert Celsius to Fahrenheit,\n+                // SetTem status returns degrees C regardless of TempUn setting\n+\n+                // Perform the float Celsius to Fahrenheit conversion add or subtract 0.5 based on the value of TemRec\n+                // (0 = -0.5, 1 = +0.5). Pass into a rounding function, this yeild the correct Fahrenheit Temperature to\n+                // match A/C display\n+                newVal = (int) (Math.round(((newVal * 9.0 / 5.0) + 32.0) + halfStep - 0.5));", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYzNDkxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437634913", "bodyText": "that's really overdriven, it's simple math with primitives", "author": "markus7017", "createdAt": "2020-06-09T18:30:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4Nzg2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5MTg2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437691868", "bodyText": "Simple math, yes, but using the units framework makes it much more obvious what your intent is without risk of a computation mistake, thus making the code more readable and eliminates the risks of a simple typo (like using int instead of doubles) from breaking things.", "author": "cpmeister", "createdAt": "2020-06-09T20:15:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4Nzg2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg4MTE0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r440881142", "bodyText": "ok, I refactored temp handling completely. Now conversion is based on UBM and the binding maps the requested unit to the AC command", "author": "markus7017", "createdAt": "2020-06-16T14:10:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4Nzg2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg4MTIyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r440881221", "bodyText": "done", "author": "markus7017", "createdAt": "2020-06-16T14:10:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4Nzg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4ODc4MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436488780", "bodyText": "Any reason this wouldn't work?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    HashMap<String, Integer> parameters = new HashMap<>();\n          \n          \n            \n                    parameters.put(\"SwingLfRig\", value);\n          \n          \n            \n                    executeCommand(clientSocket, parameters);\n          \n          \n            \n                    executeCommand(clientSocket, Collections.singletonMap(\"SwingLfRig\", value));\n          \n      \n    \n    \n  \n\nI'd like other parts of the code to simplified similarly.", "author": "cpmeister", "createdAt": "2020-06-08T06:52:57Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = bindResponseGson.packJson.key;\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"failed\");\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1NDA1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437654052", "bodyText": "reworked all of them", "author": "markus7017", "createdAt": "2020-06-09T19:04:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4ODc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4OTkwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436489900", "bodyText": "I think it would simplify code if you split this into two separate maps, one for celsius and another for fahrenheit.", "author": "cpmeister", "createdAt": "2020-06-08T06:55:49Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIyNzYwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439227602", "bodyText": "I don't want to touch this, I didn't wrote it, don't know how it works in detail/should work and it's a critical component", "author": "markus7017", "createdAt": "2020-06-12T06:18:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4OTkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NzA0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439857042", "bodyText": "@cpmeister acceptable?", "author": "markus7017", "createdAt": "2020-06-14T18:42:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4OTkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1Nzk1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439857956", "bodyText": "Not really. You should probably create a new data type that has has two fields: min and max. Then have two instances of that datatype, one for fahrenheit and another for celsius. The only real logic that you would need to work out is how to replace line 493 which from what I can tell could be replaced with two if/else statements.", "author": "cpmeister", "createdAt": "2020-06-14T18:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4OTkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA4NDAzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r440084039", "bodyText": "okj, I digged into the code. you are fully right, nonsense, way to complicated. I'll refactor this", "author": "markus7017", "createdAt": "2020-06-15T10:35:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4OTkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg4MTUxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r440881514", "bodyText": "completely refactored, HashMaps removed, code clean-up", "author": "markus7017", "createdAt": "2020-06-16T14:10:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4OTkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ5MDMwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436490308", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String columns[] = statusResponseGson.packJson.cols;\n          \n          \n            \n                    Integer values[] = statusResponseGson.packJson.dat;\n          \n          \n            \n                    String[] columns = statusResponseGson.packJson.cols;\n          \n          \n            \n                    Integer[] values = statusResponseGson.packJson.dat;", "author": "cpmeister", "createdAt": "2020-06-08T06:56:51Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = bindResponseGson.packJson.key;\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"failed\");\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (!getIsBound() || (value < 0 || value > 5)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"WdSpd\", value);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"NoiseSet\", 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Tur\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 2)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Quiet\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(\"Tur\");\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Lig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Create Hash Look Up for C and F\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\n+     */\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\n+        HashMap<String, Integer> hmf = new HashMap<>();\n+        HashMap<String, Integer> hmc = new HashMap<>();\n+\n+        hmf.put(\"min\", 61); // F\n+        hmf.put(\"max\", 86);\n+        tempRanges.put(\"F\", hmf);\n+\n+        hmc.put(\"min\", 16); // C\n+        hmc.put(\"max\", 30);\n+        tempRanges.put(\"C\", hmc);\n+\n+        return tempRanges;\n+    }\n+\n+    /**\n+     * Checks input ranges for validity and TempUn for validity\n+     * Uses newVal as priority and tries to validate and determine intent\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\n+     */\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\n+                                                    // string for hashmap\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\n+        nullCorFLUT.put(\"C\", 0);\n+        nullCorFLUT.put(\"F\", 1);\n+        nullCorFLUT.put(\"INVALID\", 0);\n+\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\n+\n+        // force to global min/max\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\n+\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\n+            validRangeCorF = \"C\";\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\n+            validRangeCorF = \"F\";\n+        } else {\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\n+            validRangeCorF = \"INVALID\";\n+        }\n+\n+        // if CorF wasnt initialized or is null set it from lookup\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\n+\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\n+            CorF = 0; // input temp takes priority\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\n+            CorF = 1; // input temp takes priority\n+        } else if (validRangeCorF.equals(\"INVALID\")) {\n+            // force min or max temp based on CorF scale to be used\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\n+        }\n+\n+        return new int[] { newVal, CorF };\n+    }\n+\n+    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n+        // **value** : set temperature in degrees celsius or Fahrenheit\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+        int newVal = value;\n+        int outVal = value;\n+        // Get Celsius or Fahrenheit from status message\n+        Integer CorF = getIntStatusVal(\"TemUn\");\n+        // TODO put a param in openhab to allow setting this from the config\n+\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        int halfStep = 0; // default to C\n+\n+        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n+        newVal = retList[0];\n+        CorF = retList[1];\n+\n+        if (CorF == 1) { // If Fahrenheit,\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+            outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\n+            // 84. , 85. , 86. ]\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+            // 28.8, 29.4, 30.0]\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // subtract the float version - the int version to get the fractional difference\n+            // if the difference is positive set halfStep to 1, negative to 0\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"TemUn\", CorF);\n+        parameters.put(\"SetTem\", outVal);\n+        parameters.put(\"TemRec\", halfStep);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Air\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Blo\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Health\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SvSt\", value);\n+        parameters.put(\"WdSpd\", 0);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"SwhSlp\", 0);\n+        parameters.put(\"SlpMod\", 0);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        String columns[] = statusResponseGson.packJson.cols;\n+        Integer values[] = statusResponseGson.packJson.dat;", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1NDQxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437654413", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-09T19:04:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ5MDMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ5MDU1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436490556", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<String> colList = new ArrayList<>(Arrays.asList(columns));\n          \n          \n            \n                    List<Integer> valList = new ArrayList<>(Arrays.asList(values));\n          \n          \n            \n                    List<String> colList = Arrays.asList(columns);\n          \n          \n            \n                    List<Integer> valList = Arrays.asList(values);", "author": "cpmeister", "createdAt": "2020-06-08T06:57:29Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = bindResponseGson.packJson.key;\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"failed\");\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (!getIsBound() || (value < 0 || value > 5)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"WdSpd\", value);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"NoiseSet\", 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Tur\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 2)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Quiet\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(\"Tur\");\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Lig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Create Hash Look Up for C and F\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\n+     */\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\n+        HashMap<String, Integer> hmf = new HashMap<>();\n+        HashMap<String, Integer> hmc = new HashMap<>();\n+\n+        hmf.put(\"min\", 61); // F\n+        hmf.put(\"max\", 86);\n+        tempRanges.put(\"F\", hmf);\n+\n+        hmc.put(\"min\", 16); // C\n+        hmc.put(\"max\", 30);\n+        tempRanges.put(\"C\", hmc);\n+\n+        return tempRanges;\n+    }\n+\n+    /**\n+     * Checks input ranges for validity and TempUn for validity\n+     * Uses newVal as priority and tries to validate and determine intent\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\n+     */\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\n+                                                    // string for hashmap\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\n+        nullCorFLUT.put(\"C\", 0);\n+        nullCorFLUT.put(\"F\", 1);\n+        nullCorFLUT.put(\"INVALID\", 0);\n+\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\n+\n+        // force to global min/max\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\n+\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\n+            validRangeCorF = \"C\";\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\n+            validRangeCorF = \"F\";\n+        } else {\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\n+            validRangeCorF = \"INVALID\";\n+        }\n+\n+        // if CorF wasnt initialized or is null set it from lookup\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\n+\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\n+            CorF = 0; // input temp takes priority\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\n+            CorF = 1; // input temp takes priority\n+        } else if (validRangeCorF.equals(\"INVALID\")) {\n+            // force min or max temp based on CorF scale to be used\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\n+        }\n+\n+        return new int[] { newVal, CorF };\n+    }\n+\n+    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n+        // **value** : set temperature in degrees celsius or Fahrenheit\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+        int newVal = value;\n+        int outVal = value;\n+        // Get Celsius or Fahrenheit from status message\n+        Integer CorF = getIntStatusVal(\"TemUn\");\n+        // TODO put a param in openhab to allow setting this from the config\n+\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        int halfStep = 0; // default to C\n+\n+        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n+        newVal = retList[0];\n+        CorF = retList[1];\n+\n+        if (CorF == 1) { // If Fahrenheit,\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+            outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\n+            // 84. , 85. , 86. ]\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+            // 28.8, 29.4, 30.0]\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // subtract the float version - the int version to get the fractional difference\n+            // if the difference is positive set halfStep to 1, negative to 0\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"TemUn\", CorF);\n+        parameters.put(\"SetTem\", outVal);\n+        parameters.put(\"TemRec\", halfStep);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Air\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Blo\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Health\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SvSt\", value);\n+        parameters.put(\"WdSpd\", 0);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"SwhSlp\", 0);\n+        parameters.put(\"SlpMod\", 0);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        String columns[] = statusResponseGson.packJson.cols;\n+        Integer values[] = statusResponseGson.packJson.dat;\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1NTM2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437655367", "bodyText": "changed all", "author": "markus7017", "createdAt": "2020-06-09T19:06:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ5MDU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ5MTEyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436491128", "bodyText": "You should make these strings constants since they are used in multiple places in the code.", "author": "cpmeister", "createdAt": "2020-06-08T06:58:45Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = bindResponseGson.packJson.key;\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"failed\");\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (!getIsBound() || (value < 0 || value > 5)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"WdSpd\", value);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"NoiseSet\", 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Tur\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 2)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Quiet\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(\"Tur\");\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Lig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Create Hash Look Up for C and F\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\n+     */\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\n+        HashMap<String, Integer> hmf = new HashMap<>();\n+        HashMap<String, Integer> hmc = new HashMap<>();\n+\n+        hmf.put(\"min\", 61); // F\n+        hmf.put(\"max\", 86);\n+        tempRanges.put(\"F\", hmf);\n+\n+        hmc.put(\"min\", 16); // C\n+        hmc.put(\"max\", 30);\n+        tempRanges.put(\"C\", hmc);\n+\n+        return tempRanges;\n+    }\n+\n+    /**\n+     * Checks input ranges for validity and TempUn for validity\n+     * Uses newVal as priority and tries to validate and determine intent\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\n+     */\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\n+                                                    // string for hashmap\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\n+        nullCorFLUT.put(\"C\", 0);\n+        nullCorFLUT.put(\"F\", 1);\n+        nullCorFLUT.put(\"INVALID\", 0);\n+\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\n+\n+        // force to global min/max\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\n+\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\n+            validRangeCorF = \"C\";\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\n+            validRangeCorF = \"F\";\n+        } else {\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\n+            validRangeCorF = \"INVALID\";\n+        }\n+\n+        // if CorF wasnt initialized or is null set it from lookup\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\n+\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\n+            CorF = 0; // input temp takes priority\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\n+            CorF = 1; // input temp takes priority\n+        } else if (validRangeCorF.equals(\"INVALID\")) {\n+            // force min or max temp based on CorF scale to be used\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\n+        }\n+\n+        return new int[] { newVal, CorF };\n+    }\n+\n+    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n+        // **value** : set temperature in degrees celsius or Fahrenheit\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+        int newVal = value;\n+        int outVal = value;\n+        // Get Celsius or Fahrenheit from status message\n+        Integer CorF = getIntStatusVal(\"TemUn\");\n+        // TODO put a param in openhab to allow setting this from the config\n+\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        int halfStep = 0; // default to C\n+\n+        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n+        newVal = retList[0];\n+        CorF = retList[1];\n+\n+        if (CorF == 1) { // If Fahrenheit,\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+            outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\n+            // 84. , 85. , 86. ]\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+            // 28.8, 29.4, 30.0]\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // subtract the float version - the int version to get the fractional difference\n+            // if the difference is positive set halfStep to 1, negative to 0\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"TemUn\", CorF);\n+        parameters.put(\"SetTem\", outVal);\n+        parameters.put(\"TemRec\", halfStep);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Air\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Blo\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Health\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SvSt\", value);\n+        parameters.put(\"WdSpd\", 0);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"SwhSlp\", 0);\n+        parameters.put(\"SlpMod\", 0);", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4MjY0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r438982645", "bodyText": "done", "author": "markus7017", "createdAt": "2020-06-11T18:17:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ5MTEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ5MTIzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436491237", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n          \n          \n            \n                        String modifiedSentence = new String(receivePacket.getData(), UTF8_CHARSET);", "author": "cpmeister", "createdAt": "2020-06-08T06:59:02Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = bindResponseGson.packJson.key;\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"failed\");\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (!getIsBound() || (value < 0 || value > 5)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"WdSpd\", value);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"NoiseSet\", 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Tur\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 2)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Quiet\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(\"Tur\");\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Lig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Create Hash Look Up for C and F\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\n+     */\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\n+        HashMap<String, Integer> hmf = new HashMap<>();\n+        HashMap<String, Integer> hmc = new HashMap<>();\n+\n+        hmf.put(\"min\", 61); // F\n+        hmf.put(\"max\", 86);\n+        tempRanges.put(\"F\", hmf);\n+\n+        hmc.put(\"min\", 16); // C\n+        hmc.put(\"max\", 30);\n+        tempRanges.put(\"C\", hmc);\n+\n+        return tempRanges;\n+    }\n+\n+    /**\n+     * Checks input ranges for validity and TempUn for validity\n+     * Uses newVal as priority and tries to validate and determine intent\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\n+     */\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\n+                                                    // string for hashmap\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\n+        nullCorFLUT.put(\"C\", 0);\n+        nullCorFLUT.put(\"F\", 1);\n+        nullCorFLUT.put(\"INVALID\", 0);\n+\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\n+\n+        // force to global min/max\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\n+\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\n+            validRangeCorF = \"C\";\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\n+            validRangeCorF = \"F\";\n+        } else {\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\n+            validRangeCorF = \"INVALID\";\n+        }\n+\n+        // if CorF wasnt initialized or is null set it from lookup\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\n+\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\n+            CorF = 0; // input temp takes priority\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\n+            CorF = 1; // input temp takes priority\n+        } else if (validRangeCorF.equals(\"INVALID\")) {\n+            // force min or max temp based on CorF scale to be used\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\n+        }\n+\n+        return new int[] { newVal, CorF };\n+    }\n+\n+    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n+        // **value** : set temperature in degrees celsius or Fahrenheit\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+        int newVal = value;\n+        int outVal = value;\n+        // Get Celsius or Fahrenheit from status message\n+        Integer CorF = getIntStatusVal(\"TemUn\");\n+        // TODO put a param in openhab to allow setting this from the config\n+\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        int halfStep = 0; // default to C\n+\n+        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n+        newVal = retList[0];\n+        CorF = retList[1];\n+\n+        if (CorF == 1) { // If Fahrenheit,\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+            outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\n+            // 84. , 85. , 86. ]\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+            // 28.8, 29.4, 30.0]\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // subtract the float version - the int version to get the fractional difference\n+            // if the difference is positive set halfStep to 1, negative to 0\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"TemUn\", CorF);\n+        parameters.put(\"SetTem\", outVal);\n+        parameters.put(\"TemRec\", halfStep);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Air\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Blo\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Health\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SvSt\", value);\n+        parameters.put(\"WdSpd\", 0);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"SwhSlp\", 0);\n+        parameters.put(\"SlpMod\", 0);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        String columns[] = statusResponseGson.packJson.cols;\n+        Integer values[] = statusResponseGson.packJson.dat;\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));\n+        int valueArrayposition = colList.indexOf(valueName);\n+        if (valueArrayposition == -1) {\n+            return -1;\n+        }\n+\n+        // Now get the Corresponding value\n+        Integer value = valList.get(valueArrayposition);\n+        return value;\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (prevStatusResponsePackGson == null) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        String currcolumns[] = statusResponseGson.packJson.cols;\n+        Integer currvalues[] = statusResponseGson.packJson.dat;\n+        List<String> currcolList = new ArrayList<>(Arrays.asList(currcolumns));\n+        List<Integer> currvalList = new ArrayList<>(Arrays.asList(currvalues));\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\n+        if (currvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to decode device status\");\n+        }\n+        // Now get the Corresponding value\n+        int currvalue = currvalList.get(currvalueArrayposition);\n+\n+        // Find the valueName in the Previous Status object\n+        String prevcolumns[] = prevStatusResponsePackGson.cols;\n+        Integer prevvalues[] = prevStatusResponsePackGson.dat;\n+        List<String> prevcolList = new ArrayList<>(Arrays.asList(prevcolumns));\n+        List<Integer> prevvalList = new ArrayList<>(Arrays.asList(prevvalues));\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\n+        if (prevvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to get status value\");\n+        }\n+        // Now get the Corresponding value\n+        int prevvalue = prevvalList.get(prevvalueArrayposition);\n+\n+        // Finally Compare the values\n+        return currvalue != prevvalue;\n+    }\n+\n+    protected void executeCommand(DatagramSocket clientSocket, HashMap<String, Integer> parameters)\n+            throws GreeException {\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Convert the parameter map values to arrays\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\n+\n+            // Prep the Command Request pack\n+            GreeExecuteCommandPack4GsonDTO execCmdPackGson = new GreeExecuteCommandPack4GsonDTO();\n+            execCmdPackGson.opt = keyArray;\n+            execCmdPackGson.p = valueArray;\n+            execCmdPackGson.t = \"cmd\";\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), execCmdPackStr);\n+            // String unencryptedCommandReqPacket = CryptoUtil.decryptPack(device.getKey().getBytes(),\n+            // encryptedCommandReqPacket);\n+\n+            // Prep the Command Request\n+            GreeExecCommand4GsonDTO execCmdGson = new GreeExecCommand4GsonDTO();\n+            execCmdGson.cid = \"app\";\n+            execCmdGson.i = 0;\n+            execCmdGson.t = \"pack\";\n+            execCmdGson.uid = 0;\n+            execCmdGson.tcid = getId();\n+            execCmdGson.pack = new String(encryptedCommandReqPacket.getBytes(), UTF8_CHARSET);\n+            String execCmdStr = gson.toJson(execCmdGson);\n+            sendData = execCmdStr.getBytes();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0MDYwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437040602", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-08T22:41:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ5MTIzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ5MTMxOA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436491318", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n          \n          \n            \n                        String modifiedSentence = new String(receivePacket.getData(), UTF8_CHARSET);", "author": "cpmeister", "createdAt": "2020-06-08T06:59:15Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = bindResponseGson.packJson.key;\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"failed\");\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (!getIsBound() || (value < 0 || value > 5)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"WdSpd\", value);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"NoiseSet\", 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Tur\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 2)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Quiet\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(\"Tur\");\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Lig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Create Hash Look Up for C and F\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\n+     */\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\n+        HashMap<String, Integer> hmf = new HashMap<>();\n+        HashMap<String, Integer> hmc = new HashMap<>();\n+\n+        hmf.put(\"min\", 61); // F\n+        hmf.put(\"max\", 86);\n+        tempRanges.put(\"F\", hmf);\n+\n+        hmc.put(\"min\", 16); // C\n+        hmc.put(\"max\", 30);\n+        tempRanges.put(\"C\", hmc);\n+\n+        return tempRanges;\n+    }\n+\n+    /**\n+     * Checks input ranges for validity and TempUn for validity\n+     * Uses newVal as priority and tries to validate and determine intent\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\n+     */\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\n+                                                    // string for hashmap\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\n+        nullCorFLUT.put(\"C\", 0);\n+        nullCorFLUT.put(\"F\", 1);\n+        nullCorFLUT.put(\"INVALID\", 0);\n+\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\n+\n+        // force to global min/max\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\n+\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\n+            validRangeCorF = \"C\";\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\n+            validRangeCorF = \"F\";\n+        } else {\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\n+            validRangeCorF = \"INVALID\";\n+        }\n+\n+        // if CorF wasnt initialized or is null set it from lookup\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\n+\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\n+            CorF = 0; // input temp takes priority\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\n+            CorF = 1; // input temp takes priority\n+        } else if (validRangeCorF.equals(\"INVALID\")) {\n+            // force min or max temp based on CorF scale to be used\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\n+        }\n+\n+        return new int[] { newVal, CorF };\n+    }\n+\n+    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n+        // **value** : set temperature in degrees celsius or Fahrenheit\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+        int newVal = value;\n+        int outVal = value;\n+        // Get Celsius or Fahrenheit from status message\n+        Integer CorF = getIntStatusVal(\"TemUn\");\n+        // TODO put a param in openhab to allow setting this from the config\n+\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        int halfStep = 0; // default to C\n+\n+        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n+        newVal = retList[0];\n+        CorF = retList[1];\n+\n+        if (CorF == 1) { // If Fahrenheit,\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+            outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\n+            // 84. , 85. , 86. ]\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+            // 28.8, 29.4, 30.0]\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // subtract the float version - the int version to get the fractional difference\n+            // if the difference is positive set halfStep to 1, negative to 0\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"TemUn\", CorF);\n+        parameters.put(\"SetTem\", outVal);\n+        parameters.put(\"TemRec\", halfStep);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Air\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Blo\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Health\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SvSt\", value);\n+        parameters.put(\"WdSpd\", 0);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"SwhSlp\", 0);\n+        parameters.put(\"SlpMod\", 0);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        String columns[] = statusResponseGson.packJson.cols;\n+        Integer values[] = statusResponseGson.packJson.dat;\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));\n+        int valueArrayposition = colList.indexOf(valueName);\n+        if (valueArrayposition == -1) {\n+            return -1;\n+        }\n+\n+        // Now get the Corresponding value\n+        Integer value = valList.get(valueArrayposition);\n+        return value;\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (prevStatusResponsePackGson == null) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        String currcolumns[] = statusResponseGson.packJson.cols;\n+        Integer currvalues[] = statusResponseGson.packJson.dat;\n+        List<String> currcolList = new ArrayList<>(Arrays.asList(currcolumns));\n+        List<Integer> currvalList = new ArrayList<>(Arrays.asList(currvalues));\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\n+        if (currvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to decode device status\");\n+        }\n+        // Now get the Corresponding value\n+        int currvalue = currvalList.get(currvalueArrayposition);\n+\n+        // Find the valueName in the Previous Status object\n+        String prevcolumns[] = prevStatusResponsePackGson.cols;\n+        Integer prevvalues[] = prevStatusResponsePackGson.dat;\n+        List<String> prevcolList = new ArrayList<>(Arrays.asList(prevcolumns));\n+        List<Integer> prevvalList = new ArrayList<>(Arrays.asList(prevvalues));\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\n+        if (prevvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to get status value\");\n+        }\n+        // Now get the Corresponding value\n+        int prevvalue = prevvalList.get(prevvalueArrayposition);\n+\n+        // Finally Compare the values\n+        return currvalue != prevvalue;\n+    }\n+\n+    protected void executeCommand(DatagramSocket clientSocket, HashMap<String, Integer> parameters)\n+            throws GreeException {\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Convert the parameter map values to arrays\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\n+\n+            // Prep the Command Request pack\n+            GreeExecuteCommandPack4GsonDTO execCmdPackGson = new GreeExecuteCommandPack4GsonDTO();\n+            execCmdPackGson.opt = keyArray;\n+            execCmdPackGson.p = valueArray;\n+            execCmdPackGson.t = \"cmd\";\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), execCmdPackStr);\n+            // String unencryptedCommandReqPacket = CryptoUtil.decryptPack(device.getKey().getBytes(),\n+            // encryptedCommandReqPacket);\n+\n+            // Prep the Command Request\n+            GreeExecCommand4GsonDTO execCmdGson = new GreeExecCommand4GsonDTO();\n+            execCmdGson.cid = \"app\";\n+            execCmdGson.i = 0;\n+            execCmdGson.t = \"pack\";\n+            execCmdGson.uid = 0;\n+            execCmdGson.tcid = getId();\n+            execCmdGson.pack = new String(encryptedCommandReqPacket.getBytes(), UTF8_CHARSET);\n+            String execCmdStr = gson.toJson(execCmdGson);\n+            sendData = execCmdStr.getBytes();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            GreeExecResponse4GsonDTO execResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                    GreeExecResponse4GsonDTO.class);\n+            execResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(),\n+                    execResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(execResponseGson.decryptedPack);\n+            execResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeExecResponsePack4GsonDTO.class);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"Exception on command execution\");\n+        }\n+    }\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        Gson gson = new Gson();\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(\"Pow\");\n+            columns.add(\"Mod\");\n+            columns.add(\"SetTem\");\n+            columns.add(\"WdSpd\");\n+            columns.add(\"Air\");\n+            columns.add(\"Blo\");\n+            columns.add(\"Health\");\n+            columns.add(\"SwhSlp\");\n+            columns.add(\"Lig\");\n+            columns.add(\"SwingLfRig\");\n+            columns.add(\"SwUpDn\");\n+            columns.add(\"Quiet\");\n+            columns.add(\"Tur\");\n+            columns.add(\"StHt\");\n+            columns.add(\"TemUn\");\n+            columns.add(\"HeatCoolType\");\n+            columns.add(\"TemRec\");\n+            columns.add(\"SvSt\");\n+            columns.add(\"NoiseSet\");\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPack4GsonDTO reqStatusPackGson = new GreeReqStatusPack4GsonDTO();\n+            reqStatusPackGson.t = \"status\";\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+\n+            // Prep the Status Request\n+            GreeReqStatus4GsonDTO reqStatusGson = new GreeReqStatus4GsonDTO();\n+            reqStatusGson.cid = \"app\";\n+            reqStatusGson.i = 0;\n+            reqStatusGson.t = \"pack\";\n+            reqStatusGson.uid = 0;\n+            reqStatusGson.tcid = getId();\n+            reqStatusGson.pack = new String(encryptedStatusReqPacket.getBytes(), UTF8_CHARSET);\n+            String execCmdStr = gson.toJson(reqStatusGson);\n+            sendData = execCmdStr.getBytes();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0MDY2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437040664", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-08T22:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ5MTMxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ5MTc0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436491746", "bodyText": "so same changes here as other comment", "author": "cpmeister", "createdAt": "2020-06-08T07:00:22Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = bindResponseGson.packJson.key;\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"failed\");\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (!getIsBound() || (value < 0 || value > 5)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"WdSpd\", value);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"NoiseSet\", 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Tur\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 2)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Quiet\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(\"Tur\");\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Lig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Create Hash Look Up for C and F\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\n+     */\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\n+        HashMap<String, Integer> hmf = new HashMap<>();\n+        HashMap<String, Integer> hmc = new HashMap<>();\n+\n+        hmf.put(\"min\", 61); // F\n+        hmf.put(\"max\", 86);\n+        tempRanges.put(\"F\", hmf);\n+\n+        hmc.put(\"min\", 16); // C\n+        hmc.put(\"max\", 30);\n+        tempRanges.put(\"C\", hmc);\n+\n+        return tempRanges;\n+    }\n+\n+    /**\n+     * Checks input ranges for validity and TempUn for validity\n+     * Uses newVal as priority and tries to validate and determine intent\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\n+     */\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\n+                                                    // string for hashmap\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\n+        nullCorFLUT.put(\"C\", 0);\n+        nullCorFLUT.put(\"F\", 1);\n+        nullCorFLUT.put(\"INVALID\", 0);\n+\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\n+\n+        // force to global min/max\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\n+\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\n+            validRangeCorF = \"C\";\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\n+            validRangeCorF = \"F\";\n+        } else {\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\n+            validRangeCorF = \"INVALID\";\n+        }\n+\n+        // if CorF wasnt initialized or is null set it from lookup\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\n+\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\n+            CorF = 0; // input temp takes priority\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\n+            CorF = 1; // input temp takes priority\n+        } else if (validRangeCorF.equals(\"INVALID\")) {\n+            // force min or max temp based on CorF scale to be used\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\n+        }\n+\n+        return new int[] { newVal, CorF };\n+    }\n+\n+    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n+        // **value** : set temperature in degrees celsius or Fahrenheit\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+        int newVal = value;\n+        int outVal = value;\n+        // Get Celsius or Fahrenheit from status message\n+        Integer CorF = getIntStatusVal(\"TemUn\");\n+        // TODO put a param in openhab to allow setting this from the config\n+\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        int halfStep = 0; // default to C\n+\n+        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n+        newVal = retList[0];\n+        CorF = retList[1];\n+\n+        if (CorF == 1) { // If Fahrenheit,\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+            outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\n+            // 84. , 85. , 86. ]\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+            // 28.8, 29.4, 30.0]\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // subtract the float version - the int version to get the fractional difference\n+            // if the difference is positive set halfStep to 1, negative to 0\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"TemUn\", CorF);\n+        parameters.put(\"SetTem\", outVal);\n+        parameters.put(\"TemRec\", halfStep);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Air\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Blo\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Health\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SvSt\", value);\n+        parameters.put(\"WdSpd\", 0);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"SwhSlp\", 0);\n+        parameters.put(\"SlpMod\", 0);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        String columns[] = statusResponseGson.packJson.cols;\n+        Integer values[] = statusResponseGson.packJson.dat;\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));\n+        int valueArrayposition = colList.indexOf(valueName);\n+        if (valueArrayposition == -1) {\n+            return -1;\n+        }\n+\n+        // Now get the Corresponding value\n+        Integer value = valList.get(valueArrayposition);\n+        return value;\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (prevStatusResponsePackGson == null) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        String currcolumns[] = statusResponseGson.packJson.cols;\n+        Integer currvalues[] = statusResponseGson.packJson.dat;\n+        List<String> currcolList = new ArrayList<>(Arrays.asList(currcolumns));\n+        List<Integer> currvalList = new ArrayList<>(Arrays.asList(currvalues));", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1NTQ4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437655484", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-09T19:06:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ5MTc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ5MTgyMA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436491820", "bodyText": "do same changes here as other comment", "author": "cpmeister", "createdAt": "2020-06-08T07:00:34Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = bindResponseGson.packJson.key;\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"failed\");\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (!getIsBound() || (value < 0 || value > 5)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"WdSpd\", value);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"NoiseSet\", 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Tur\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 2)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Quiet\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(\"Tur\");\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Lig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Create Hash Look Up for C and F\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\n+     */\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\n+        HashMap<String, Integer> hmf = new HashMap<>();\n+        HashMap<String, Integer> hmc = new HashMap<>();\n+\n+        hmf.put(\"min\", 61); // F\n+        hmf.put(\"max\", 86);\n+        tempRanges.put(\"F\", hmf);\n+\n+        hmc.put(\"min\", 16); // C\n+        hmc.put(\"max\", 30);\n+        tempRanges.put(\"C\", hmc);\n+\n+        return tempRanges;\n+    }\n+\n+    /**\n+     * Checks input ranges for validity and TempUn for validity\n+     * Uses newVal as priority and tries to validate and determine intent\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\n+     */\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\n+                                                    // string for hashmap\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\n+        nullCorFLUT.put(\"C\", 0);\n+        nullCorFLUT.put(\"F\", 1);\n+        nullCorFLUT.put(\"INVALID\", 0);\n+\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\n+\n+        // force to global min/max\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\n+\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\n+            validRangeCorF = \"C\";\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\n+            validRangeCorF = \"F\";\n+        } else {\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\n+            validRangeCorF = \"INVALID\";\n+        }\n+\n+        // if CorF wasnt initialized or is null set it from lookup\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\n+\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\n+            CorF = 0; // input temp takes priority\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\n+            CorF = 1; // input temp takes priority\n+        } else if (validRangeCorF.equals(\"INVALID\")) {\n+            // force min or max temp based on CorF scale to be used\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\n+        }\n+\n+        return new int[] { newVal, CorF };\n+    }\n+\n+    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n+        // **value** : set temperature in degrees celsius or Fahrenheit\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+        int newVal = value;\n+        int outVal = value;\n+        // Get Celsius or Fahrenheit from status message\n+        Integer CorF = getIntStatusVal(\"TemUn\");\n+        // TODO put a param in openhab to allow setting this from the config\n+\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        int halfStep = 0; // default to C\n+\n+        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n+        newVal = retList[0];\n+        CorF = retList[1];\n+\n+        if (CorF == 1) { // If Fahrenheit,\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+            outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\n+            // 84. , 85. , 86. ]\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+            // 28.8, 29.4, 30.0]\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // subtract the float version - the int version to get the fractional difference\n+            // if the difference is positive set halfStep to 1, negative to 0\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"TemUn\", CorF);\n+        parameters.put(\"SetTem\", outVal);\n+        parameters.put(\"TemRec\", halfStep);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Air\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Blo\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Health\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SvSt\", value);\n+        parameters.put(\"WdSpd\", 0);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"SwhSlp\", 0);\n+        parameters.put(\"SlpMod\", 0);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        String columns[] = statusResponseGson.packJson.cols;\n+        Integer values[] = statusResponseGson.packJson.dat;\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));\n+        int valueArrayposition = colList.indexOf(valueName);\n+        if (valueArrayposition == -1) {\n+            return -1;\n+        }\n+\n+        // Now get the Corresponding value\n+        Integer value = valList.get(valueArrayposition);\n+        return value;\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (prevStatusResponsePackGson == null) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        String currcolumns[] = statusResponseGson.packJson.cols;\n+        Integer currvalues[] = statusResponseGson.packJson.dat;\n+        List<String> currcolList = new ArrayList<>(Arrays.asList(currcolumns));\n+        List<Integer> currvalList = new ArrayList<>(Arrays.asList(currvalues));\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\n+        if (currvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to decode device status\");\n+        }\n+        // Now get the Corresponding value\n+        int currvalue = currvalList.get(currvalueArrayposition);\n+\n+        // Find the valueName in the Previous Status object\n+        String prevcolumns[] = prevStatusResponsePackGson.cols;\n+        Integer prevvalues[] = prevStatusResponsePackGson.dat;\n+        List<String> prevcolList = new ArrayList<>(Arrays.asList(prevcolumns));\n+        List<Integer> prevvalList = new ArrayList<>(Arrays.asList(prevvalues));", "originalCommit": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1NTY2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437655662", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-09T19:07:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ5MTgyMA=="}], "type": "inlineReview"}, {"oid": "1c64aff6717981ccb3ec90324cb90ca704e68c88", "url": "https://github.com/openhab/openhab-addons/commit/1c64aff6717981ccb3ec90324cb90ca704e68c88", "message": "Turned GreeAirDevice into @NonNullByDefault, test pending\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-08T19:54:52Z", "type": "commit"}, {"oid": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d", "url": "https://github.com/openhab/openhab-addons/commit/5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d", "message": "review changes\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-08T22:43:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNDIxNw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437104217", "bodyText": "You should specify the charset here", "author": "cpmeister", "createdAt": "2020-06-09T02:33:51Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress ipAddress;\n+    protected HashMap<String, GreeAirDevice> deviceTable = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        ipAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        ipAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        // Send the Scan message\n+        GreeScanRequestDTO scanGson = new GreeScanRequestDTO();\n+        scanGson.t = \"scan\";\n+\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        Gson gson = gsonBuilder.create();\n+        String scanReq = gson.toJson(scanGson);\n+        sendData = scanReq.getBytes();", "originalCommit": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4NjIyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r438986229", "bodyText": "you mean like this?\nString scanReq = new String (gson.toJson(scanGson), \"UTF-8\")", "author": "markus7017", "createdAt": "2020-06-11T18:23:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNDIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxNDY5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439014695", "bodyText": "I mean like this:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    sendData = scanReq.getBytes();\n          \n          \n            \n                    sendData = scanReq.getBytes(StandardCharsets.UTF_8);", "author": "cpmeister", "createdAt": "2020-06-11T19:19:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNDIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgwNzMyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439807323", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-14T08:57:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNDIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNTAyMA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437105020", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    GreeAirDevice returnDevice = null;\n          \n          \n            \n            \n          \n          \n            \n                    Set<String> keySet = deviceTable.keySet();\n          \n          \n            \n                    Iterator<String> iter = keySet.iterator();\n          \n          \n            \n                    while (returnDevice == null && iter.hasNext()) {\n          \n          \n            \n                        Object thiskey = iter.next();\n          \n          \n            \n                        if (deviceTable.containsKey(thiskey)) {\n          \n          \n            \n                            GreeAirDevice currDevice = deviceTable.get(thiskey);\n          \n          \n            \n                            if (currDevice.getAddress().getHostAddress().equals(ipAddress)) {\n          \n          \n            \n                                returnDevice = currDevice;\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    return returnDevice;\n          \n          \n            \n                    for(GreeAirDevice currDevice : deviceTable.values()){\n          \n          \n            \n                        if (currDevice.getAddress().getHostAddress().equals(ipAddress)) {\n          \n          \n            \n                            return currDevice;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    return null;", "author": "cpmeister", "createdAt": "2020-06-09T02:36:57Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress ipAddress;\n+    protected HashMap<String, GreeAirDevice> deviceTable = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        ipAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        ipAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        // Send the Scan message\n+        GreeScanRequestDTO scanGson = new GreeScanRequestDTO();\n+        scanGson.t = \"scan\";\n+\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        Gson gson = gsonBuilder.create();\n+        String scanReq = gson.toJson(scanGson);\n+        sendData = scanReq.getBytes();\n+\n+        logger.trace(\"Sending scan packet to {}\", ipAddress.getHostAddress());\n+        try {\n+            DatagramSocket clientSocket = socket.get();\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, ipAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            boolean scanning = true;\n+            int retries = MAX_SCAN_CYCLES;\n+            while (scanning && (retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponseDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanResponseDTO.class);\n+\n+                    // If there was no pack, ignore the response\n+                    if (scanResponseGson.pack == null) {\n+                        logger.debug(\"Invalid packet format, ignore\");\n+                        continue;\n+                    }\n+\n+                    // Decrypt message - a a GreeException is thrown when something went wrong\n+                    scanResponseGson.decryptedPack = GreeCryptoUtil\n+                            .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n+                    String decryptedMsg = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                            scanResponseGson.pack);\n+\n+                    logger.debug(\"Response received from address {}: {}\", remoteAddress.getHostAddress(), decryptedMsg);\n+\n+                    // Create the JSON to hold the response values\n+                    stringReader = new StringReader(decryptedMsg);\n+                    scanResponseGson.packJson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanReponsePackDTO.class);\n+\n+                    // Now make sure the device is reported as a Gree device\n+                    if (scanResponseGson.packJson.brand.equalsIgnoreCase(\"gree\")) {\n+                        // Create a new GreeDevice\n+                        logger.debug(\"Discovered device at {}:{}\", remoteAddress.getHostAddress(), remotePort);\n+                        GreeAirDevice newDevice = new GreeAirDevice();\n+                        newDevice.setAddress(remoteAddress);\n+                        newDevice.setPort(remotePort);\n+                        newDevice.setScanResponseGson(scanResponseGson);\n+                        addDevice(newDevice);\n+                    } else {\n+                        logger.debug(\"Unit discovered, but brand is not GREE\");\n+                    }\n+\n+                    scanning = scanNetwork;\n+                } catch (SocketTimeoutException e) {\n+                    // We've received a timeout so lets quit searching for devices\n+                    scanning = false;\n+                    break;\n+                } catch (IOException e) {\n+                    retries--;\n+                    if (retries == 0) {\n+                        throw new GreeException(\"Exception on device scan\", e);\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new GreeException(\"I/O exception during device scan\", e);\n+        }\n+    }\n+\n+    public void addDevice(GreeAirDevice newDevice) {\n+        deviceTable.put(newDevice.getId(), newDevice);\n+    }\n+\n+    public GreeAirDevice getDevice(String id) {\n+        return deviceTable.get(id);\n+    }\n+\n+    public Map<String, GreeAirDevice> getDevices() {\n+        return deviceTable;\n+    }\n+\n+    public @Nullable GreeAirDevice getDeviceByIPAddress(String ipAddress) {\n+        GreeAirDevice returnDevice = null;\n+\n+        Set<String> keySet = deviceTable.keySet();\n+        Iterator<String> iter = keySet.iterator();\n+        while (returnDevice == null && iter.hasNext()) {\n+            Object thiskey = iter.next();\n+            if (deviceTable.containsKey(thiskey)) {\n+                GreeAirDevice currDevice = deviceTable.get(thiskey);\n+                if (currDevice.getAddress().getHostAddress().equals(ipAddress)) {\n+                    returnDevice = currDevice;\n+                }\n+            }\n+        }\n+\n+        return returnDevice;", "originalCommit": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1NjczMg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437656732", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-09T19:08:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNTAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNTQyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437105425", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                scanResponseGson.decryptedPack = GreeCryptoUtil\n          \n          \n            \n                                        .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n          \n          \n            \n                                String decryptedMsg = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n          \n          \n            \n                                        scanResponseGson.pack);\n          \n          \n            \n                                String decryptedMsg = scanResponseGson.decryptedPack = GreeCryptoUtil\n          \n          \n            \n                                        .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);", "author": "cpmeister", "createdAt": "2020-06-09T02:38:43Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress ipAddress;\n+    protected HashMap<String, GreeAirDevice> deviceTable = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        ipAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        ipAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        // Send the Scan message\n+        GreeScanRequestDTO scanGson = new GreeScanRequestDTO();\n+        scanGson.t = \"scan\";\n+\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        Gson gson = gsonBuilder.create();\n+        String scanReq = gson.toJson(scanGson);\n+        sendData = scanReq.getBytes();\n+\n+        logger.trace(\"Sending scan packet to {}\", ipAddress.getHostAddress());\n+        try {\n+            DatagramSocket clientSocket = socket.get();\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, ipAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            boolean scanning = true;\n+            int retries = MAX_SCAN_CYCLES;\n+            while (scanning && (retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponseDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanResponseDTO.class);\n+\n+                    // If there was no pack, ignore the response\n+                    if (scanResponseGson.pack == null) {\n+                        logger.debug(\"Invalid packet format, ignore\");\n+                        continue;\n+                    }\n+\n+                    // Decrypt message - a a GreeException is thrown when something went wrong\n+                    scanResponseGson.decryptedPack = GreeCryptoUtil\n+                            .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n+                    String decryptedMsg = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                            scanResponseGson.pack);", "originalCommit": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NzMwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439857303", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-14T18:46:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNTQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNTg4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437105886", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n          \n          \n            \n                                StringReader stringReader = new StringReader(modifiedSentence);\n          \n          \n            \n                                GreeScanResponseDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),\n          \n          \n            \n                                String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n          \n          \n            \n                                GreeScanResponseDTO scanResponseGson = gson.fromJson(modifiedSentence,", "author": "cpmeister", "createdAt": "2020-06-09T02:40:45Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress ipAddress;\n+    protected HashMap<String, GreeAirDevice> deviceTable = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        ipAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        ipAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        // Send the Scan message\n+        GreeScanRequestDTO scanGson = new GreeScanRequestDTO();\n+        scanGson.t = \"scan\";\n+\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        Gson gson = gsonBuilder.create();\n+        String scanReq = gson.toJson(scanGson);\n+        sendData = scanReq.getBytes();\n+\n+        logger.trace(\"Sending scan packet to {}\", ipAddress.getHostAddress());\n+        try {\n+            DatagramSocket clientSocket = socket.get();\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, ipAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            boolean scanning = true;\n+            int retries = MAX_SCAN_CYCLES;\n+            while (scanning && (retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponseDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),", "originalCommit": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY2NDIwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437664200", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-09T19:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNTg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNjU2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437106566", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return mScanResponseGson.isPresent()\n          \n          \n            \n                            ? mScanResponseGson.get().packJson.series + \" \" + mScanResponseGson.get().packJson.model\n          \n          \n            \n                            : \"\";\n          \n          \n            \n                    return mScanResponseGson.map(response -> response.packJson.series + \" \" + response.packJson.model).orElse(\"\");", "author": "cpmeister", "createdAt": "2020-06-09T02:43:34Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommandDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> mScanResponseGson = Optional.empty();\n+    private Optional<GreeBindResponseDTO> bindResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.isPresent() ? mScanResponseGson.get().packJson.mac : \"\";\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.isPresent() ? mScanResponseGson.get().packJson.name : \"\";\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.isPresent()\n+                ? mScanResponseGson.get().packJson.brand + \" \" + mScanResponseGson.get().packJson.vender\n+                : \"\";\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.isPresent()\n+                ? mScanResponseGson.get().packJson.series + \" \" + mScanResponseGson.get().packJson.model\n+                : \"\";", "originalCommit": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4NDA3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r438984076", "bodyText": "for me my version is straight forward, like to stay with this", "author": "markus7017", "createdAt": "2020-06-11T18:19:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNjU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NzI3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439857270", "bodyText": "keep as is then", "author": "cpmeister", "createdAt": "2020-06-14T18:46:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNjU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg3MjYzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439872631", "bodyText": "ok", "author": "markus7017", "createdAt": "2020-06-14T22:13:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNjU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY0ODgzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437648838", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String encrytpedMessage = new String(newencoder.encode(bytePlainText), \"UTF-8\");\n          \n          \n            \n                        return encrytpedMessage.substring(0, encrytpedMessage.length());\n          \n          \n            \n                        return new String(newencoder.encode(bytePlainText), \"UTF-8\");", "author": "cpmeister", "createdAt": "2020-06-09T18:54:59Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeCryptoUtil.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Base64;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The CryptoUtil class provides functionality for encrypting and decrypting\n+ * messages sent to and from the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeCryptoUtil {\n+    private static final String AES_KEY = \"a3K8Bx%2r8Y7#xDh\";\n+\n+    public static String GetAESGeneralKey() {\n+        return AES_KEY;\n+    }\n+\n+    public static byte[] getAESGeneralKeyByteArray() {\n+        return AES_KEY.getBytes();\n+    }\n+\n+    public static String decryptPack(byte[] keyarray, String message) throws GreeException {\n+        try {\n+            Key key = new SecretKeySpec(keyarray, \"AES\");\n+            Base64.Decoder decoder = Base64.getDecoder();\n+            byte[] imageByte = decoder.decode(message);\n+\n+            Cipher aesCipher = Cipher.getInstance(\"AES\");\n+            aesCipher.init(Cipher.DECRYPT_MODE, key);\n+            byte[] bytePlainText = aesCipher.doFinal(imageByte);\n+\n+            return new String(bytePlainText, \"UTF-8\");\n+        } catch (NoSuchAlgorithmException | UnsupportedEncodingException | NoSuchPaddingException | BadPaddingException\n+                | InvalidKeyException | IllegalBlockSizeException ex) {\n+            throw new GreeException(\"Decryption of recieved data failed\", ex);\n+        }\n+    }\n+\n+    public static String encryptPack(byte[] keyarray, String message) throws GreeException {\n+        try {\n+            Key key = new SecretKeySpec(keyarray, \"AES\");\n+            Cipher aesCipher = Cipher.getInstance(\"AES\");\n+            aesCipher.init(Cipher.ENCRYPT_MODE, key);\n+            byte[] bytePlainText = aesCipher.doFinal(message.getBytes());\n+\n+            Base64.Encoder newencoder = Base64.getEncoder();\n+            String encrytpedMessage = new String(newencoder.encode(bytePlainText), \"UTF-8\");\n+            return encrytpedMessage.substring(0, encrytpedMessage.length());", "originalCommit": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY2NTg4MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437665880", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-09T19:26:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY0ODgzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY0OTk3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437649977", "bodyText": "It is preferred to reuse Gson instances. Can you make a static final instance and use that instead?", "author": "cpmeister", "createdAt": "2020-06-09T18:56:43Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress ipAddress;\n+    protected HashMap<String, GreeAirDevice> deviceTable = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        ipAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        ipAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        // Send the Scan message\n+        GreeScanRequestDTO scanGson = new GreeScanRequestDTO();\n+        scanGson.t = \"scan\";\n+\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        Gson gson = gsonBuilder.create();", "originalCommit": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY2NzcwNw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437667707", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-09T19:29:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY0OTk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MTMwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437651309", "bodyText": "Why not make this an osgi component so that the DiscoveryService and HandlerFactory can just get a reference to it in their constructors?", "author": "cpmeister", "createdAt": "2020-06-09T18:59:05Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeTranslationProvider.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal;\n+\n+import java.util.Locale;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.osgi.framework.Bundle;\n+\n+/**\n+ * {@link GreeTranslationProvider} provides i18n message lookup\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class GreeTranslationProvider {", "originalCommit": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5MTUyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r438991526", "bodyText": "done", "author": "markus7017", "createdAt": "2020-06-11T18:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MTMwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MTQzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437651437", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected HashMap<String, GreeAirDevice> deviceTable = new HashMap<>();\n          \n          \n            \n                protected Map<String, GreeAirDevice> deviceTable = new HashMap<>();", "author": "cpmeister", "createdAt": "2020-06-09T18:59:21Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress ipAddress;\n+    protected HashMap<String, GreeAirDevice> deviceTable = new HashMap<>();", "originalCommit": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY2ODA4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437668088", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-09T19:30:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MTQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MjM2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437652360", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    scheduler.execute(() -> {\n          \n          \n            \n                        startScan();\n          \n          \n            \n                    });\n          \n          \n            \n                    scheduler.execute(this::startScan);", "author": "cpmeister", "createdAt": "2020-06-09T19:00:54Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.gree\")\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT_SEC = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    @Activate\n+    public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n+        Bundle bundle = FrameworkUtil.getBundle(this.getClass());\n+        messages = new GreeTranslationProvider(bundle.getBundleContext().getBundle(), i18nProvider, localeProvider);\n+        String ip = networkAddressService.getConfiguredBroadcastAddress();\n+        broadcastAddress = ip != null ? ip : \"\";\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    @Modified\n+    protected void modified(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.modified(configProperties);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        // It's very unusual that a new unit gets installed frequently so we run the discovery once when the binding is\n+        // started, but not frequently\n+        scheduler.execute(() -> {\n+            startScan();\n+        });", "originalCommit": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY2ODMzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437668337", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-09T19:31:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MjM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MzAxNw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437653017", "bodyText": "Please use camelcase for names.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Optional<GreeScanResponseDTO> mScanResponseGson = Optional.empty();\n          \n          \n            \n                private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();", "author": "cpmeister", "createdAt": "2020-06-09T19:02:10Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommandDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> mScanResponseGson = Optional.empty();", "originalCommit": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY2ODYzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437668633", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-09T19:31:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MzAxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1NDEyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437654121", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String columns[] = statusResponseGson.get().packJson.cols;\n          \n          \n            \n                        Integer values[] = statusResponseGson.get().packJson.dat;\n          \n          \n            \n                        String[] columns = statusResponseGson.get().packJson.cols;\n          \n          \n            \n                        Integer[] values = statusResponseGson.get().packJson.dat;", "author": "cpmeister", "createdAt": "2020-06-09T19:04:15Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommandDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> mScanResponseGson = Optional.empty();\n+    private Optional<GreeBindResponseDTO> bindResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.isPresent() ? mScanResponseGson.get().packJson.mac : \"\";\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.isPresent() ? mScanResponseGson.get().packJson.name : \"\";\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.isPresent()\n+                ? mScanResponseGson.get().packJson.brand + \" \" + mScanResponseGson.get().packJson.vender\n+                : \"\";\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.isPresent()\n+                ? mScanResponseGson.get().packJson.series + \" \" + mScanResponseGson.get().packJson.model\n+                : \"\";\n+    }\n+\n+    public GreeScanResponseDTO getScanResponseGson() {\n+        return mScanResponseGson.get();\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponseDTO gson) {\n+        mScanResponseGson = Optional.of(gson);\n+    }\n+\n+    public GreeBindResponseDTO getBindResponseGson() {\n+        return bindResponseGson.get();\n+    }\n+\n+    public GreeStatusResponseDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson.get();\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPackDTO bindReqPackGson = new GreeBindRequestPackDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequestDTO bindReqGson = new GreeBindRequestDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), UTF8_CHARSET);\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            GreeBindResponseDTO resp = gson.fromJson(new JsonReader(stringReader), GreeBindResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), resp.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(resp.decryptedPack);\n+            resp.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePackDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = resp.packJson.key;\n+\n+            // save the outcome\n+            bindResponseGson = Optional.of(resp);\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(\"Unable to bind to device\", e);\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (!getIsBound() || (value < 0 || value > 5)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"WdSpd\", value);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"NoiseSet\", 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Tur\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 2)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Quiet\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(\"Tur\");\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Lig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Create Hash Look Up for C and F\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\n+     */\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\n+        HashMap<String, Integer> hmf = new HashMap<>();\n+        HashMap<String, Integer> hmc = new HashMap<>();\n+\n+        hmf.put(\"min\", 61); // F\n+        hmf.put(\"max\", 86);\n+        tempRanges.put(\"F\", hmf);\n+\n+        hmc.put(\"min\", 16); // C\n+        hmc.put(\"max\", 30);\n+        tempRanges.put(\"C\", hmc);\n+\n+        return tempRanges;\n+    }\n+\n+    /**\n+     * Checks input ranges for validity and TempUn for validity\n+     * Uses newVal as priority and tries to validate and determine intent\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\n+     */\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\n+                                                    // string for hashmap\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\n+        nullCorFLUT.put(\"C\", 0);\n+        nullCorFLUT.put(\"F\", 1);\n+        nullCorFLUT.put(\"INVALID\", 0);\n+\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\n+\n+        // force to global min/max\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\n+\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\n+            validRangeCorF = \"C\";\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\n+            validRangeCorF = \"F\";\n+        } else {\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\n+            validRangeCorF = \"INVALID\";\n+        }\n+\n+        // if CorF wasnt initialized or is null set it from lookup\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\n+\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\n+            CorF = 0; // input temp takes priority\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\n+            CorF = 1; // input temp takes priority\n+        } else if (validRangeCorF.equals(\"INVALID\")) {\n+            // force min or max temp based on CorF scale to be used\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\n+        }\n+\n+        return new int[] { newVal, CorF };\n+    }\n+\n+    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n+        // **value** : set temperature in degrees celsius or Fahrenheit\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+        int newVal = value;\n+        int outVal = value;\n+        // Get Celsius or Fahrenheit from status message\n+        Integer CorF = getIntStatusVal(\"TemUn\");\n+        // TODO put a param in openhab to allow setting this from the config\n+\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        int halfStep = 0; // default to C\n+\n+        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n+        newVal = retList[0];\n+        CorF = retList[1];\n+\n+        if (CorF == 1) { // If Fahrenheit,\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+            outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\n+            // 84. , 85. , 86. ]\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+            // 28.8, 29.4, 30.0]\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // subtract the float version - the int version to get the fractional difference\n+            // if the difference is positive set halfStep to 1, negative to 0\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"TemUn\", CorF);\n+        parameters.put(\"SetTem\", outVal);\n+        parameters.put(\"TemRec\", halfStep);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Air\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Blo\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Health\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SvSt\", value);\n+        parameters.put(\"WdSpd\", 0);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"SwhSlp\", 0);\n+        parameters.put(\"SlpMod\", 0);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        String columns[] = statusResponseGson.get().packJson.cols;\n+        Integer values[] = statusResponseGson.get().packJson.dat;\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));\n+        int valueArrayposition = colList.indexOf(valueName);\n+        if (valueArrayposition == -1) {\n+            return -1;\n+        }\n+\n+        // Now get the Corresponding value\n+        Integer value = valList.get(valueArrayposition);\n+        return value;\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (!prevStatusResponsePackGson.isPresent()) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        String currcolumns[] = statusResponseGson.get().packJson.cols;\n+        Integer currvalues[] = statusResponseGson.get().packJson.dat;\n+        List<String> currcolList = new ArrayList<>(Arrays.asList(currcolumns));\n+        List<Integer> currvalList = new ArrayList<>(Arrays.asList(currvalues));\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\n+        if (currvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to decode device status\");\n+        }\n+        // Now get the Corresponding value\n+        int currvalue = currvalList.get(currvalueArrayposition);\n+\n+        // Find the valueName in the Previous Status object\n+        String prevcolumns[] = prevStatusResponsePackGson.get().cols;\n+        Integer prevvalues[] = prevStatusResponsePackGson.get().dat;\n+        List<String> prevcolList = new ArrayList<>(Arrays.asList(prevcolumns));\n+        List<Integer> prevvalList = new ArrayList<>(Arrays.asList(prevvalues));\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\n+        if (prevvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to get status value\");\n+        }\n+        // Now get the Corresponding value\n+        int prevvalue = prevvalList.get(prevvalueArrayposition);\n+\n+        // Finally Compare the values\n+        return currvalue != prevvalue;\n+    }\n+\n+    protected void executeCommand(DatagramSocket clientSocket, HashMap<String, Integer> parameters)\n+            throws GreeException {\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Convert the parameter map values to arrays\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\n+\n+            // Prep the Command Request pack\n+            GreeExecuteCommandPackDTO execCmdPackGson = new GreeExecuteCommandPackDTO();\n+            execCmdPackGson.opt = keyArray;\n+            execCmdPackGson.p = valueArray;\n+            execCmdPackGson.t = \"cmd\";\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), execCmdPackStr);\n+            // String unencryptedCommandReqPacket = CryptoUtil.decryptPack(device.getKey().getBytes(),\n+            // encryptedCommandReqPacket);\n+\n+            // Prep the Command Request\n+            GreeExecCommandDTO execCmdGson = new GreeExecCommandDTO();\n+            execCmdGson.cid = \"app\";\n+            execCmdGson.i = 0;\n+            execCmdGson.t = \"pack\";\n+            execCmdGson.uid = 0;\n+            execCmdGson.tcid = getId();\n+            execCmdGson.pack = new String(encryptedCommandReqPacket.getBytes(), UTF8_CHARSET);\n+            String execCmdStr = gson.toJson(execCmdGson);\n+            sendData = execCmdStr.getBytes();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), UTF8_CHARSET);\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            GreeExecResponseDTO execResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                    GreeExecResponseDTO.class);\n+            execResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(),\n+                    execResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(execResponseGson.decryptedPack);\n+            execResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeExecResponsePackDTO.class);\n+        } catch (IOException e) {\n+            throw new GreeException(\"Exception on command execution\", e);\n+        }\n+    }\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        Gson gson = new Gson();\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(\"Pow\");\n+            columns.add(\"Mod\");\n+            columns.add(\"SetTem\");\n+            columns.add(\"WdSpd\");\n+            columns.add(\"Air\");\n+            columns.add(\"Blo\");\n+            columns.add(\"Health\");\n+            columns.add(\"SwhSlp\");\n+            columns.add(\"Lig\");\n+            columns.add(\"SwingLfRig\");\n+            columns.add(\"SwUpDn\");\n+            columns.add(\"Quiet\");\n+            columns.add(\"Tur\");\n+            columns.add(\"StHt\");\n+            columns.add(\"TemUn\");\n+            columns.add(\"HeatCoolType\");\n+            columns.add(\"TemRec\");\n+            columns.add(\"SvSt\");\n+            columns.add(\"NoiseSet\");\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = \"status\";\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+\n+            // Prep the Status Request\n+            GreeReqStatusDTO reqStatusGson = new GreeReqStatusDTO();\n+            reqStatusGson.cid = \"app\";\n+            reqStatusGson.i = 0;\n+            reqStatusGson.t = \"pack\";\n+            reqStatusGson.uid = 0;\n+            reqStatusGson.tcid = getId();\n+            reqStatusGson.pack = new String(encryptedStatusReqPacket.getBytes(), UTF8_CHARSET);\n+            String execCmdStr = gson.toJson(reqStatusGson);\n+            sendData = execCmdStr.getBytes();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), UTF8_CHARSET);\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson.isPresent() && statusResponseGson.get().packJson != null) {\n+                prevStatusResponsePackGson = Optional\n+                        .of(new GreeStatusResponsePackDTO(statusResponseGson.get().packJson));\n+            }\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            GreeStatusResponseDTO resp = gson.fromJson(new JsonReader(stringReader), GreeStatusResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(), resp.pack);\n+            logger.trace(\"Response from device: {}\", resp.decryptedPack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(resp.decryptedPack);\n+\n+            resp.packJson = gson.fromJson(new JsonReader(stringReader), GreeStatusResponsePackDTO.class);\n+\n+            // save the results\n+            statusResponseGson = Optional.of(resp);\n+            updateTempFtoC();\n+        } catch (IOException e) {\n+            throw new GreeException(\"I/O exception while receiving data\", e);\n+        }\n+    }\n+\n+    private void updateTempFtoC() {\n+        // Status message back from A/C always reports degrees C\n+        // If using Fahrenheit, us SetTem, TemUn and TemRec to reconstruct the Fahrenheit temperature\n+        // Get Celsius or Fahrenheit from status message\n+        int CorF = getIntStatusVal(\"TemUn\");\n+        int newVal = getIntStatusVal(\"SetTem\");\n+        int halfStep = getIntStatusVal(\"TemRec\");\n+\n+        if ((CorF == -1) || (newVal == -1) || (halfStep == -1)) {\n+            throw new IllegalArgumentException(\"SetTem,TemUn or TemRec is invalid, not performing conversion\");\n+        } else if (CorF == 1) { // convert SetTem to Fahrenheit\n+            // Find the valueName in the Returned Status object\n+            String columns[] = statusResponseGson.get().packJson.cols;\n+            Integer values[] = statusResponseGson.get().packJson.dat;", "originalCommit": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY2ODk0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437668941", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-09T19:32:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1NDEyMQ=="}], "type": "inlineReview"}, {"oid": "e2fad291715bed6653cd3b0294109aeb3bddf3a4", "url": "https://github.com/openhab/openhab-addons/commit/e2fad291715bed6653cd3b0294109aeb3bddf3a4", "message": "more changes from review\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-09T20:31:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxNjIwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439016205", "bodyText": "This will make sure that background scanning properly starts since the @Activate annotation is no longer on the activate method.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n          \n          \n            \n                        @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider) {\n          \n          \n            \n                    super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n          \n          \n            \n                    Bundle bundle = FrameworkUtil.getBundle(this.getClass());\n          \n          \n            \n                    messages = new GreeTranslationProvider(bundle.getBundleContext().getBundle(), i18nProvider, localeProvider);\n          \n          \n            \n                    String ip = networkAddressService.getConfiguredBroadcastAddress();\n          \n          \n            \n                    broadcastAddress = ip != null ? ip : \"\";\n          \n          \n            \n                }\n          \n          \n            \n                public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n          \n          \n            \n                        @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider,\n          \n          \n            \n                        @Nullable Map<String, @Nullable Object> configProperties) {\n          \n          \n            \n                    super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n          \n          \n            \n                    Bundle bundle = FrameworkUtil.getBundle(this.getClass());\n          \n          \n            \n                    messages = new GreeTranslationProvider(bundle.getBundleContext().getBundle(), i18nProvider, localeProvider);\n          \n          \n            \n                    String ip = networkAddressService.getConfiguredBroadcastAddress();\n          \n          \n            \n                    broadcastAddress = ip != null ? ip : \"\";\n          \n          \n            \n                    activate(configProperties);\n          \n          \n            \n                }", "author": "cpmeister", "createdAt": "2020-06-11T19:22:07Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.gree\")\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT_SEC = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    @Activate\n+    public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n+        Bundle bundle = FrameworkUtil.getBundle(this.getClass());\n+        messages = new GreeTranslationProvider(bundle.getBundleContext().getBundle(), i18nProvider, localeProvider);\n+        String ip = networkAddressService.getConfiguredBroadcastAddress();\n+        broadcastAddress = ip != null ? ip : \"\";\n+    }", "originalCommit": "e2fad291715bed6653cd3b0294109aeb3bddf3a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1Njk1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439856952", "bodyText": "I changed to\n   @Activate\n    public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n            @Reference GreeTranslationProvider translationProvider, @Nullable Map<String, @Nullable Object> configProperties) {\n        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n        messages = translationProvider;\n        String ip = networkAddressService.getConfiguredBroadcastAddress();\n        broadcastAddress = ip != null ? ip : \"\";\n        activate(configProperties);\n    }\n\n    @Override\n    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n        super.activate(configProperties);\n    }\n\nIs this ok? still having the activate() method?", "author": "markus7017", "createdAt": "2020-06-14T18:41:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxNjIwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NzI4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439857283", "bodyText": "That is fine", "author": "cpmeister", "createdAt": "2020-06-14T18:46:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxNjIwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2MTg0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439861848", "bodyText": "Why do you want to keep the overriden activate(), only invoking the base class method?", "author": "fwolter", "createdAt": "2020-06-14T19:48:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxNjIwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg3MjYxOA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439872618", "bodyText": "that was my question, so I could safely remove it?", "author": "markus7017", "createdAt": "2020-06-14T22:13:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxNjIwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg4MTEyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439881128", "bodyText": "yes, you can safely remove it", "author": "cpmeister", "createdAt": "2020-06-14T23:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxNjIwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg3OTgwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r440879801", "bodyText": "done", "author": "markus7017", "createdAt": "2020-06-16T14:08:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxNjIwNQ=="}], "type": "inlineReview"}, {"oid": "3f990a5c390c2404ac5af0c9ef50a599b02903d7", "url": "https://github.com/openhab/openhab-addons/commit/3f990a5c390c2404ac5af0c9ef50a599b02903d7", "message": "more review changes (contants for cmd and property values, turn\ntranslation service into component, replaced some Optional stuff in\nhandler by @Nullable)\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-11T19:47:05Z", "type": "commit"}, {"oid": "e7b4c666c490b45266dfe59133c435ada802d53f", "url": "https://github.com/openhab/openhab-addons/commit/e7b4c666c490b45266dfe59133c435ada802d53f", "message": "review changes; fixed mode on/off\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-14T18:19:12Z", "type": "commit"}, {"oid": "3f8726ecabb25e20818bfae17f95d0c463a50b26", "url": "https://github.com/openhab/openhab-addons/commit/3f8726ecabb25e20818bfae17f95d0c463a50b26", "message": "review changes\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-14T18:48:10Z", "type": "commit"}, {"oid": "f7f599916ee2d6f1894d76b90166300892db7a10", "url": "https://github.com/openhab/openhab-addons/commit/f7f599916ee2d6f1894d76b90166300892db7a10", "message": "review changes, support Celsius and Fahrenheit based on QuantityType\n(WIP)\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-16T12:00:47Z", "type": "commit"}, {"oid": "6ec9f36e5df386e820534e4dba208893ecb95027", "url": "https://github.com/openhab/openhab-addons/commit/6ec9f36e5df386e820534e4dba208893ecb95027", "message": "removed C/F conversion (handled by the framework)\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-16T14:06:55Z", "type": "commit"}, {"oid": "f84b33b5c999635fd61d2476baa3f069ff644618", "url": "https://github.com/openhab/openhab-addons/commit/f84b33b5c999635fd61d2476baa3f069ff644618", "message": "activate() method removed\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-16T14:11:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE2NjIyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441166227", "bodyText": "statusResponseGson can be empty at this point. That would result in a NoSuchElementException.", "author": "fwolter", "createdAt": "2020-06-16T21:59:11Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -136,11 +131,12 @@ public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n             updateTempFtoC();\n         } catch (IOException e) {\n             throw new GreeException(\"I/O exception while receiving data\", e);\n+        } catch (RuntimeException e) {\n+            throw new GreeException(\"Exception while receiving data, JSON=\" + statusResponseGson.get().packJson, e);", "originalCommit": "f7f599916ee2d6f1894d76b90166300892db7a10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5MTM0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441191347", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-16T23:09:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE2NjIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE2NzEzMg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441167132", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Default for Celsiues\n          \n          \n            \n                    // Default for Celsius", "author": "fwolter", "createdAt": "2020-06-16T22:01:27Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -248,37 +233,40 @@ public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeEx\n     /**\n      * @param value set temperature in degrees Celsius or Fahrenheit\n      */\n-    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n-        int newVal = value;\n-        int outVal = value;\n-        // Get Celsius or Fahrenheit from status message\n-        Integer CorF = getIntStatusVal(GREE_PROP_TEMPUNIT);\n-        // TODO put a param in openhab to allow setting this from the config\n-\n+    public void setDeviceTempSet(DatagramSocket clientSocket, QuantityType<?> temp) throws GreeException {\n         // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n         // temperature to use as celsius alone is ambigious\n-        int halfStep = 0; // default to C\n-\n-        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n-        newVal = retList[0];\n-        CorF = retList[1];\n+        Double newVal = temp.doubleValue();\n+        int CorF = temp.getUnit() == SIUnits.CELSIUS ? TEMP_UNIT_CELSIUS : TEMP_UNIT_FAHRENHEIT; // 0=Celsius,\n+                                                                                                 // 1=Fahrenheit\n+        if (((CorF == TEMP_UNIT_CELSIUS) && (newVal < TEMP_MIN_C || newVal > TEMP_MAX_C))\n+                || ((CorF == TEMP_UNIT_FAHRENHEIT) && (newVal < TEMP_MIN_F || newVal > TEMP_MAX_F))) {\n+            throw new IllegalArgumentException(\"Temp Value out of Range\");\n+        }\n \n-        if (CorF == 1) { // If Fahrenheit,\n-            // value argument is degrees F, convert Fahrenheit to Celsius,\n-            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+        // Default for Celsiues", "originalCommit": "f7f599916ee2d6f1894d76b90166300892db7a10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5MDM4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441190385", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-16T23:06:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE2NzEzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE2ODIyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441168225", "bodyText": "You could convert the QuantityType with toUnit() to Celsius or Fahrenheit. Then, you need to check the range only once.", "author": "fwolter", "createdAt": "2020-06-16T22:04:19Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -248,37 +233,40 @@ public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeEx\n     /**\n      * @param value set temperature in degrees Celsius or Fahrenheit\n      */\n-    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n-        int newVal = value;\n-        int outVal = value;\n-        // Get Celsius or Fahrenheit from status message\n-        Integer CorF = getIntStatusVal(GREE_PROP_TEMPUNIT);\n-        // TODO put a param in openhab to allow setting this from the config\n-\n+    public void setDeviceTempSet(DatagramSocket clientSocket, QuantityType<?> temp) throws GreeException {\n         // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n         // temperature to use as celsius alone is ambigious\n-        int halfStep = 0; // default to C\n-\n-        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n-        newVal = retList[0];\n-        CorF = retList[1];\n+        Double newVal = temp.doubleValue();\n+        int CorF = temp.getUnit() == SIUnits.CELSIUS ? TEMP_UNIT_CELSIUS : TEMP_UNIT_FAHRENHEIT; // 0=Celsius,\n+                                                                                                 // 1=Fahrenheit\n+        if (((CorF == TEMP_UNIT_CELSIUS) && (newVal < TEMP_MIN_C || newVal > TEMP_MAX_C))\n+                || ((CorF == TEMP_UNIT_FAHRENHEIT) && (newVal < TEMP_MIN_F || newVal > TEMP_MAX_F))) {\n+            throw new IllegalArgumentException(\"Temp Value out of Range\");", "originalCommit": "f7f599916ee2d6f1894d76b90166300892db7a10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5MDc3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441190772", "bodyText": "this is more code, more overhead and feels for me a little bit strange. I send an out-of-range value through the converter and then check that it's out of range?", "author": "markus7017", "createdAt": "2020-06-16T23:07:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE2ODIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA2NjQ5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r442066491", "bodyText": "@fwolter how do we proceed on this?", "author": "markus7017", "createdAt": "2020-06-18T08:43:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE2ODIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4Njg5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r442486890", "bodyText": "It's a matter of taste. Your argument is valid. IMHO it's ok.", "author": "fwolter", "createdAt": "2020-06-18T20:34:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE2ODIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2Njg0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443066849", "bodyText": "ok", "author": "markus7017", "createdAt": "2020-06-19T22:34:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE2ODIyNQ=="}], "type": "inlineReview"}, {"oid": "5a2754c8e8096d6f2bc0111d90fbaf896bb331d0", "url": "https://github.com/openhab/openhab-addons/commit/5a2754c8e8096d6f2bc0111d90fbaf896bb331d0", "message": "review changes\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-16T23:09:55Z", "type": "commit"}, {"oid": "446e73815427bc66cd4e7734e552d9aa80c52b3c", "url": "https://github.com/openhab/openhab-addons/commit/446e73815427bc66cd4e7734e552d9aa80c52b3c", "message": "fixed typo in properties id (..), thingId added to debug outputs\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-17T14:34:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3NjYyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441676625", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String json = statusResponseGson.isPresent() ? statusResponseGson.get().packJson.toString() : \"n/a\";\n          \n          \n            \n                        String json = statusResponseGson.map(r -> r.packJson.toString()).orElse(\"n/a\");", "author": "fwolter", "createdAt": "2020-06-17T16:33:33Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Gson gson = new Gson();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(GREE_PROP_POWER);\n+            columns.add(GREE_PROP_MODE);\n+            columns.add(GREE_PROP_SETTEMP);\n+            columns.add(GREE_PROP_WINDSPEED);\n+            columns.add(GREE_PROP_AIR);\n+            columns.add(GREE_PROP_DRY);\n+            columns.add(GREE_PROP_HEALTH);\n+            columns.add(GREE_PROP_SLEEP);\n+            columns.add(GREE_PROP_LIGHT);\n+            columns.add(GREE_PROP_SWINGLEFTRIGHT);\n+            columns.add(GREE_PROP_SWINGUPDOWN);\n+            columns.add(GREE_PROP_QUIET);\n+            columns.add(GREE_PROP_TURBO);\n+            columns.add(GREE_PROP_TEMPUNIT);\n+            columns.add(GREE_PROP_HEAT);\n+            columns.add(GREE_PROP_HEATCOOL);\n+            columns.add(GREE_PROP_TEMPREC);\n+            columns.add(GREE_PROP_PWR_SAVING);\n+            columns.add(GREE_PROP_NOISESET);\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = GREE_CMDT_STATUS;\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Encrypt and send the Status Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            JsonReader receivedData = receiveResponse(clientSocket);\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson.isPresent() && statusResponseGson.get().packJson != null) {\n+                prevStatusResponsePackGson = Optional\n+                        .of(new GreeStatusResponsePackDTO(statusResponseGson.get().packJson));\n+            }\n+\n+            // Read the response, create the JSON to hold the response values\n+            GreeStatusResponseDTO resp = gson.fromJson(receivedData, GreeStatusResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(), resp.pack);\n+            logger.debug(\"Response from device: {}\", resp.decryptedPack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeStatusResponsePackDTO.class);\n+\n+            // save the results\n+            statusResponseGson = Optional.of(resp);\n+            updateTempFtoC();\n+        } catch (IOException e) {\n+            throw new GreeException(\"I/O exception while receiving data\", e);\n+        } catch (RuntimeException e) {\n+            String json = statusResponseGson.isPresent() ? statusResponseGson.get().packJson.toString() : \"n/a\";", "originalCommit": "446e73815427bc66cd4e7734e552d9aa80c52b3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgwOTcxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441809715", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-17T20:20:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3NjYyNQ=="}], "type": "inlineReview"}, {"oid": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1", "url": "https://github.com/openhab/openhab-addons/commit/ddbba49f802627554c380ef9a5b829ac7b1f8cb1", "message": "Update status 3sec after a command was sent; avoid NPE when no response\nis available; review change\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-17T20:27:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5NzA2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441897063", "bodyText": "You should catch the json syntax exception this throws.", "author": "cpmeister", "createdAt": "2020-06-18T00:02:15Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+    private static final Gson gson = (new GsonBuilder()).create();\n+\n+    protected final InetAddress ipAddress;\n+    protected Map<String, GreeAirDevice> deviceTable = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        ipAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws GreeException {\n+        try {\n+            ipAddress = InetAddress.getByName(broadcastAddress);\n+        } catch (UnknownHostException e) {\n+            throw new GreeException(\"Unknown host or invalid IP address\", e);\n+        }\n+    }\n+\n+    public void scan(DatagramSocket clientSocket, boolean scanNetwork) throws GreeException {\n+        try {\n+            byte[] sendData = new byte[1024];\n+            byte[] receiveData = new byte[1024];\n+\n+            // Send the Scan message\n+            GreeScanRequestDTO scanGson = new GreeScanRequestDTO();\n+            scanGson.t = GREE_CMDT_SCAN;\n+            String scanReq = gson.toJson(scanGson);\n+            sendData = scanReq.getBytes(StandardCharsets.UTF_8);\n+            logger.trace(\"Sending scan packet to {}\", ipAddress.getHostAddress());\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, ipAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            int retries = MAX_SCAN_CYCLES;\n+            while ((retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    // String modifiedSentence = new String(receivePacket.getData(), StandardCharsets.UTF_8);\n+                    // GreeScanResponseDTO scanResponseGson = gson.fromJson(modifiedSentence,\n+                    // GreeScanResponseDTO.class);\n+                    String modifiedSentence = new String(receivePacket.getData(), StandardCharsets.UTF_8);\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponseDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanResponseDTO.class);\n+\n+                    // If there was no pack, ignore the response\n+                    if (scanResponseGson.pack == null) {\n+                        logger.debug(\"Invalid packet format, ignore\");\n+                        continue;\n+                    }\n+\n+                    // Decrypt message - a a GreeException is thrown when something went wrong\n+                    /*\n+                     * scanResponseGson.decryptedPack = GreeCryptoUtil\n+                     * .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n+                     * String decryptedMsg = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                     * scanResponseGson.pack);\n+                     */\n+                    String decryptedMsg = scanResponseGson.decryptedPack = GreeCryptoUtil\n+                            .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n+                    logger.debug(\"Response received from address {}: {}\", remoteAddress.getHostAddress(), decryptedMsg);\n+\n+                    // Create the JSON to hold the response values\n+                    scanResponseGson.packJson = gson.fromJson(decryptedMsg, GreeScanReponsePackDTO.class);", "originalCommit": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk2NjEwNw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r442966107", "bodyText": "done", "author": "markus7017", "createdAt": "2020-06-19T17:35:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5NzA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5NzEwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441897105", "bodyText": "here too", "author": "cpmeister", "createdAt": "2020-06-18T00:02:25Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+    private static final Gson gson = (new GsonBuilder()).create();\n+\n+    protected final InetAddress ipAddress;\n+    protected Map<String, GreeAirDevice> deviceTable = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        ipAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws GreeException {\n+        try {\n+            ipAddress = InetAddress.getByName(broadcastAddress);\n+        } catch (UnknownHostException e) {\n+            throw new GreeException(\"Unknown host or invalid IP address\", e);\n+        }\n+    }\n+\n+    public void scan(DatagramSocket clientSocket, boolean scanNetwork) throws GreeException {\n+        try {\n+            byte[] sendData = new byte[1024];\n+            byte[] receiveData = new byte[1024];\n+\n+            // Send the Scan message\n+            GreeScanRequestDTO scanGson = new GreeScanRequestDTO();\n+            scanGson.t = GREE_CMDT_SCAN;\n+            String scanReq = gson.toJson(scanGson);\n+            sendData = scanReq.getBytes(StandardCharsets.UTF_8);\n+            logger.trace(\"Sending scan packet to {}\", ipAddress.getHostAddress());\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, ipAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            int retries = MAX_SCAN_CYCLES;\n+            while ((retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    // String modifiedSentence = new String(receivePacket.getData(), StandardCharsets.UTF_8);\n+                    // GreeScanResponseDTO scanResponseGson = gson.fromJson(modifiedSentence,\n+                    // GreeScanResponseDTO.class);\n+                    String modifiedSentence = new String(receivePacket.getData(), StandardCharsets.UTF_8);\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponseDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),", "originalCommit": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk2NjE2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r442966166", "bodyText": "done", "author": "markus7017", "createdAt": "2020-06-19T17:35:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5NzEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5NzE5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441897199", "bodyText": "remove these comments", "author": "cpmeister", "createdAt": "2020-06-18T00:02:47Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+    private static final Gson gson = (new GsonBuilder()).create();\n+\n+    protected final InetAddress ipAddress;\n+    protected Map<String, GreeAirDevice> deviceTable = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        ipAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws GreeException {\n+        try {\n+            ipAddress = InetAddress.getByName(broadcastAddress);\n+        } catch (UnknownHostException e) {\n+            throw new GreeException(\"Unknown host or invalid IP address\", e);\n+        }\n+    }\n+\n+    public void scan(DatagramSocket clientSocket, boolean scanNetwork) throws GreeException {\n+        try {\n+            byte[] sendData = new byte[1024];\n+            byte[] receiveData = new byte[1024];\n+\n+            // Send the Scan message\n+            GreeScanRequestDTO scanGson = new GreeScanRequestDTO();\n+            scanGson.t = GREE_CMDT_SCAN;\n+            String scanReq = gson.toJson(scanGson);\n+            sendData = scanReq.getBytes(StandardCharsets.UTF_8);\n+            logger.trace(\"Sending scan packet to {}\", ipAddress.getHostAddress());\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, ipAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            int retries = MAX_SCAN_CYCLES;\n+            while ((retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    // String modifiedSentence = new String(receivePacket.getData(), StandardCharsets.UTF_8);\n+                    // GreeScanResponseDTO scanResponseGson = gson.fromJson(modifiedSentence,\n+                    // GreeScanResponseDTO.class);", "originalCommit": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk2NjQ4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r442966485", "bodyText": "done", "author": "markus7017", "createdAt": "2020-06-19T17:36:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5NzE5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5NzYzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441897633", "bodyText": "Gson already has the method that allows parsing from a string.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                String modifiedSentence = new String(receivePacket.getData(), StandardCharsets.UTF_8);\n          \n          \n            \n                                StringReader stringReader = new StringReader(modifiedSentence);\n          \n          \n            \n                                GreeScanResponseDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),\n          \n          \n            \n                                String modifiedSentence = new String(receivePacket.getData(), StandardCharsets.UTF_8);\n          \n          \n            \n                                GreeScanResponseDTO scanResponseGson = gson.fromJson(modifiedSentence,", "author": "cpmeister", "createdAt": "2020-06-18T00:04:21Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+    private static final Gson gson = (new GsonBuilder()).create();\n+\n+    protected final InetAddress ipAddress;\n+    protected Map<String, GreeAirDevice> deviceTable = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        ipAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws GreeException {\n+        try {\n+            ipAddress = InetAddress.getByName(broadcastAddress);\n+        } catch (UnknownHostException e) {\n+            throw new GreeException(\"Unknown host or invalid IP address\", e);\n+        }\n+    }\n+\n+    public void scan(DatagramSocket clientSocket, boolean scanNetwork) throws GreeException {\n+        try {\n+            byte[] sendData = new byte[1024];\n+            byte[] receiveData = new byte[1024];\n+\n+            // Send the Scan message\n+            GreeScanRequestDTO scanGson = new GreeScanRequestDTO();\n+            scanGson.t = GREE_CMDT_SCAN;\n+            String scanReq = gson.toJson(scanGson);\n+            sendData = scanReq.getBytes(StandardCharsets.UTF_8);\n+            logger.trace(\"Sending scan packet to {}\", ipAddress.getHostAddress());\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, ipAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            int retries = MAX_SCAN_CYCLES;\n+            while ((retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    // String modifiedSentence = new String(receivePacket.getData(), StandardCharsets.UTF_8);\n+                    // GreeScanResponseDTO scanResponseGson = gson.fromJson(modifiedSentence,\n+                    // GreeScanResponseDTO.class);\n+                    String modifiedSentence = new String(receivePacket.getData(), StandardCharsets.UTF_8);\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponseDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),", "originalCommit": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzExNjk5OA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443116998", "bodyText": "refactored", "author": "markus7017", "createdAt": "2020-06-20T09:34:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5NzYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5ODQ4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441898481", "bodyText": "Returning from a method explicitly should be preferred over returning implicitly.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    break;\n          \n          \n            \n                                }\n          \n          \n            \n                            } catch (SocketTimeoutException e) {\n          \n          \n            \n                                break;\n          \n          \n            \n                                    return;\n          \n          \n            \n                                }\n          \n          \n            \n                            } catch (SocketTimeoutException e) {\n          \n          \n            \n                                return;", "author": "cpmeister", "createdAt": "2020-06-18T00:07:39Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+    private static final Gson gson = (new GsonBuilder()).create();\n+\n+    protected final InetAddress ipAddress;\n+    protected Map<String, GreeAirDevice> deviceTable = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        ipAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws GreeException {\n+        try {\n+            ipAddress = InetAddress.getByName(broadcastAddress);\n+        } catch (UnknownHostException e) {\n+            throw new GreeException(\"Unknown host or invalid IP address\", e);\n+        }\n+    }\n+\n+    public void scan(DatagramSocket clientSocket, boolean scanNetwork) throws GreeException {\n+        try {\n+            byte[] sendData = new byte[1024];\n+            byte[] receiveData = new byte[1024];\n+\n+            // Send the Scan message\n+            GreeScanRequestDTO scanGson = new GreeScanRequestDTO();\n+            scanGson.t = GREE_CMDT_SCAN;\n+            String scanReq = gson.toJson(scanGson);\n+            sendData = scanReq.getBytes(StandardCharsets.UTF_8);\n+            logger.trace(\"Sending scan packet to {}\", ipAddress.getHostAddress());\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, ipAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            int retries = MAX_SCAN_CYCLES;\n+            while ((retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    // String modifiedSentence = new String(receivePacket.getData(), StandardCharsets.UTF_8);\n+                    // GreeScanResponseDTO scanResponseGson = gson.fromJson(modifiedSentence,\n+                    // GreeScanResponseDTO.class);\n+                    String modifiedSentence = new String(receivePacket.getData(), StandardCharsets.UTF_8);\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponseDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanResponseDTO.class);\n+\n+                    // If there was no pack, ignore the response\n+                    if (scanResponseGson.pack == null) {\n+                        logger.debug(\"Invalid packet format, ignore\");\n+                        continue;\n+                    }\n+\n+                    // Decrypt message - a a GreeException is thrown when something went wrong\n+                    /*\n+                     * scanResponseGson.decryptedPack = GreeCryptoUtil\n+                     * .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n+                     * String decryptedMsg = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                     * scanResponseGson.pack);\n+                     */\n+                    String decryptedMsg = scanResponseGson.decryptedPack = GreeCryptoUtil\n+                            .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n+                    logger.debug(\"Response received from address {}: {}\", remoteAddress.getHostAddress(), decryptedMsg);\n+\n+                    // Create the JSON to hold the response values\n+                    scanResponseGson.packJson = gson.fromJson(decryptedMsg, GreeScanReponsePackDTO.class);\n+\n+                    // Now make sure the device is reported as a Gree device\n+                    if (scanResponseGson.packJson.brand.equalsIgnoreCase(\"gree\")) {\n+                        // Create a new GreeDevice\n+                        logger.debug(\"Discovered device at {}:{}\", remoteAddress.getHostAddress(), remotePort);\n+                        GreeAirDevice newDevice = new GreeAirDevice();\n+                        newDevice.setAddress(remoteAddress);\n+                        newDevice.setPort(remotePort);\n+                        newDevice.setScanResponseGson(scanResponseGson);\n+                        addDevice(newDevice);\n+                    } else {\n+                        logger.debug(\"Unit discovered, but brand is not GREE\");\n+                    }\n+\n+                    if (!scanNetwork) {\n+                        break;\n+                    }\n+                } catch (SocketTimeoutException e) {\n+                    break;", "originalCommit": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk2NzI5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r442967294", "bodyText": "done", "author": "markus7017", "createdAt": "2020-06-19T17:38:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5ODQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5ODY1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441898654", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return ((OnOffType) command) == OnOffType.ON ? 1 : 0;\n          \n          \n            \n                        return command == OnOffType.ON ? 1 : 0;", "author": "cpmeister", "createdAt": "2020-06-18T00:08:22Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+    private final String thingId;\n+    private boolean forceRefresh = false;\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+        String label = getThing().getLabel();\n+        this.thingId = label != null ? label : getThing().getUID().getId();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"{}: Config for {} is {}\", thing.getUID(), thingId, config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"{}: Config of {} is invalid. Check configuration\", thingId, thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(this::initializeThing);\n+    }\n+\n+    private void initializeThing() {\n+        try {\n+            if (!clientSocket.isPresent()) {\n+                clientSocket = Optional.of(new DatagramSocket());\n+                clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+            }\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket.get(), false);\n+            logger.debug(\"{}: {} units found matching IP address\", thingId, deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket.get());\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"{}: GREE unit is not responding\", thingId);\n+        } catch (GreeException e) {\n+            logger.warn(\"{}: Initialization failed: {}\", thingId, messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException e) {\n+            logger.debug(\"{}: Exception on initialization: {}\", thingId, e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Initialization failed\", thingId, e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Thing initialization failed!\");\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            logger.debug(\"{}: Issue command {}\u00a0to channe {}\", thingId, command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"{}: Handle command {} for channel {}, command class {}\", thingId, command, channelId,\n+                    command.getClass());\n+            try {\n+                DatagramSocket socket = clientSocket.get();\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(socket, command);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        // Set value, read back effective one and update channel\n+                        // e.g. 22.5C will result in 22.0, because the AC doesn't support half-steps for C\n+                        device.setDeviceTempSet(socket, convertTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(socket, command);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+\n+                // force refresh on next status refresh cycle\n+                forceRefresh = true;\n+            } catch (GreeException e) {\n+                logger.debug(\"{}: Unable to execute command {}\u00a0for channel {}: {}\", thingId, command, channelId,\n+                        e.toString());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"{}: Invalid command value {}\u00a0for channel {}\", thingId, command, channelUID.getId());\n+            } catch (RuntimeException e) {\n+                logger.warn(\"{}: Unable to execute command {}\u00a0for channel {}\", thingId, command, channelId, e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"{}: Send Power-{}\", thingId, command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    logger.debug(\"{}: Turn unit {}\", thingId, modeStr);\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    return;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"{}: Mode {} mapped to {}\", thingId, modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(GREE_PROP_POWER) == 0)) {\n+            logger.debug(\"{}: Send Auto-ON for mode {}\", thingId, mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"{}: Select mode {}\", thingId, mode);\n+        device.SetDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"{}: Turn on Power-Saving\", thingId);\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid QuietType\");\n+        }\n+    }\n+\n+    private int getOnOff(Command command) {\n+        if (command instanceof OnOffType) {\n+            return ((OnOffType) command) == OnOffType.ON ? 1 : 0;", "originalCommit": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk2ODUxNw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r442968517", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-19T17:41:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5ODY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5ODc3OA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441898778", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            return ((DecimalType) command).intValue();\n          \n          \n            \n                            return value;", "author": "cpmeister", "createdAt": "2020-06-18T00:08:52Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+    private final String thingId;\n+    private boolean forceRefresh = false;\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+        String label = getThing().getLabel();\n+        this.thingId = label != null ? label : getThing().getUID().getId();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"{}: Config for {} is {}\", thing.getUID(), thingId, config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"{}: Config of {} is invalid. Check configuration\", thingId, thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(this::initializeThing);\n+    }\n+\n+    private void initializeThing() {\n+        try {\n+            if (!clientSocket.isPresent()) {\n+                clientSocket = Optional.of(new DatagramSocket());\n+                clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+            }\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket.get(), false);\n+            logger.debug(\"{}: {} units found matching IP address\", thingId, deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket.get());\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"{}: GREE unit is not responding\", thingId);\n+        } catch (GreeException e) {\n+            logger.warn(\"{}: Initialization failed: {}\", thingId, messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException e) {\n+            logger.debug(\"{}: Exception on initialization: {}\", thingId, e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Initialization failed\", thingId, e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Thing initialization failed!\");\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            logger.debug(\"{}: Issue command {}\u00a0to channe {}\", thingId, command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"{}: Handle command {} for channel {}, command class {}\", thingId, command, channelId,\n+                    command.getClass());\n+            try {\n+                DatagramSocket socket = clientSocket.get();\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(socket, command);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        // Set value, read back effective one and update channel\n+                        // e.g. 22.5C will result in 22.0, because the AC doesn't support half-steps for C\n+                        device.setDeviceTempSet(socket, convertTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(socket, command);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+\n+                // force refresh on next status refresh cycle\n+                forceRefresh = true;\n+            } catch (GreeException e) {\n+                logger.debug(\"{}: Unable to execute command {}\u00a0for channel {}: {}\", thingId, command, channelId,\n+                        e.toString());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"{}: Invalid command value {}\u00a0for channel {}\", thingId, command, channelUID.getId());\n+            } catch (RuntimeException e) {\n+                logger.warn(\"{}: Unable to execute command {}\u00a0for channel {}\", thingId, command, channelId, e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"{}: Send Power-{}\", thingId, command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    logger.debug(\"{}: Turn unit {}\", thingId, modeStr);\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    return;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"{}: Mode {} mapped to {}\", thingId, modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(GREE_PROP_POWER) == 0)) {\n+            logger.debug(\"{}: Send Auto-ON for mode {}\", thingId, mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"{}: Select mode {}\", thingId, mode);\n+        device.SetDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"{}: Turn on Power-Saving\", thingId);\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid QuietType\");\n+        }\n+    }\n+\n+    private int getOnOff(Command command) {\n+        if (command instanceof OnOffType) {\n+            return ((OnOffType) command) == OnOffType.ON ? 1 : 0;\n+        }\n+        if (command instanceof DecimalType) {\n+            int value = ((DecimalType) command).intValue();\n+            if ((value == 0) || (value == 1)) {\n+                return ((DecimalType) command).intValue();", "originalCommit": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2ODIwNg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443068206", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-19T22:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5ODc3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5OTU5OA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441899598", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    throw new IllegalArgumentException(\"Invalud Number type\");\n          \n          \n            \n                    throw new IllegalArgumentException(\"Invalid Number type\");", "author": "cpmeister", "createdAt": "2020-06-18T00:12:13Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+    private final String thingId;\n+    private boolean forceRefresh = false;\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+        String label = getThing().getLabel();\n+        this.thingId = label != null ? label : getThing().getUID().getId();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"{}: Config for {} is {}\", thing.getUID(), thingId, config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"{}: Config of {} is invalid. Check configuration\", thingId, thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(this::initializeThing);\n+    }\n+\n+    private void initializeThing() {\n+        try {\n+            if (!clientSocket.isPresent()) {\n+                clientSocket = Optional.of(new DatagramSocket());\n+                clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+            }\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket.get(), false);\n+            logger.debug(\"{}: {} units found matching IP address\", thingId, deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket.get());\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"{}: GREE unit is not responding\", thingId);\n+        } catch (GreeException e) {\n+            logger.warn(\"{}: Initialization failed: {}\", thingId, messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException e) {\n+            logger.debug(\"{}: Exception on initialization: {}\", thingId, e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Initialization failed\", thingId, e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Thing initialization failed!\");\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            logger.debug(\"{}: Issue command {}\u00a0to channe {}\", thingId, command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"{}: Handle command {} for channel {}, command class {}\", thingId, command, channelId,\n+                    command.getClass());\n+            try {\n+                DatagramSocket socket = clientSocket.get();\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(socket, command);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        // Set value, read back effective one and update channel\n+                        // e.g. 22.5C will result in 22.0, because the AC doesn't support half-steps for C\n+                        device.setDeviceTempSet(socket, convertTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(socket, command);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+\n+                // force refresh on next status refresh cycle\n+                forceRefresh = true;\n+            } catch (GreeException e) {\n+                logger.debug(\"{}: Unable to execute command {}\u00a0for channel {}: {}\", thingId, command, channelId,\n+                        e.toString());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"{}: Invalid command value {}\u00a0for channel {}\", thingId, command, channelUID.getId());\n+            } catch (RuntimeException e) {\n+                logger.warn(\"{}: Unable to execute command {}\u00a0for channel {}\", thingId, command, channelId, e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"{}: Send Power-{}\", thingId, command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    logger.debug(\"{}: Turn unit {}\", thingId, modeStr);\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    return;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"{}: Mode {} mapped to {}\", thingId, modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(GREE_PROP_POWER) == 0)) {\n+            logger.debug(\"{}: Send Auto-ON for mode {}\", thingId, mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"{}: Select mode {}\", thingId, mode);\n+        device.SetDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"{}: Turn on Power-Saving\", thingId);\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid QuietType\");\n+        }\n+    }\n+\n+    private int getOnOff(Command command) {\n+        if (command instanceof OnOffType) {\n+            return ((OnOffType) command) == OnOffType.ON ? 1 : 0;\n+        }\n+        if (command instanceof DecimalType) {\n+            int value = ((DecimalType) command).intValue();\n+            if ((value == 0) || (value == 1)) {\n+                return ((DecimalType) command).intValue();\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Invalid OnOffType\");\n+    }\n+\n+    private int getNumber(Command command) {\n+        if (command instanceof DecimalType) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalud Number type\");", "originalCommit": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk2ODY4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r442968684", "bodyText": "fixed", "author": "markus7017", "createdAt": "2020-06-19T17:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5OTU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwMDI0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441900240", "bodyText": "These can be merged together.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static State toQuantityType(int value, int digits, Unit<?> unit) {\n          \n          \n            \n                    BigDecimal bd = new BigDecimal(value);\n          \n          \n            \n                    return new QuantityType<>(bd.setScale(digits, BigDecimal.ROUND_HALF_EVEN), unit);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public static QuantityType<?> toQuantityType(DecimalType value, int digits, Unit<?> unit) {\n          \n          \n            \n                    BigDecimal bd = new BigDecimal(value.doubleValue());\n          \n          \n            \n                    return new QuantityType<>(bd.setScale(digits, BigDecimal.ROUND_HALF_EVEN), unit);\n          \n          \n            \n                }\n          \n          \n            \n                public static QuantityType<?> toQuantityType(Number value, int digits, Unit<?> unit) {\n          \n          \n            \n                    BigDecimal bd = new BigDecimal(value.doubleValue());\n          \n          \n            \n                    return new QuantityType<>(bd.setScale(digits, BigDecimal.ROUND_HALF_EVEN), unit);\n          \n          \n            \n                }", "author": "cpmeister", "createdAt": "2020-06-18T00:14:44Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+    private final String thingId;\n+    private boolean forceRefresh = false;\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+        String label = getThing().getLabel();\n+        this.thingId = label != null ? label : getThing().getUID().getId();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"{}: Config for {} is {}\", thing.getUID(), thingId, config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"{}: Config of {} is invalid. Check configuration\", thingId, thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(this::initializeThing);\n+    }\n+\n+    private void initializeThing() {\n+        try {\n+            if (!clientSocket.isPresent()) {\n+                clientSocket = Optional.of(new DatagramSocket());\n+                clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+            }\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket.get(), false);\n+            logger.debug(\"{}: {} units found matching IP address\", thingId, deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket.get());\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"{}: GREE unit is not responding\", thingId);\n+        } catch (GreeException e) {\n+            logger.warn(\"{}: Initialization failed: {}\", thingId, messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException e) {\n+            logger.debug(\"{}: Exception on initialization: {}\", thingId, e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Initialization failed\", thingId, e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Thing initialization failed!\");\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            logger.debug(\"{}: Issue command {}\u00a0to channe {}\", thingId, command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"{}: Handle command {} for channel {}, command class {}\", thingId, command, channelId,\n+                    command.getClass());\n+            try {\n+                DatagramSocket socket = clientSocket.get();\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(socket, command);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        // Set value, read back effective one and update channel\n+                        // e.g. 22.5C will result in 22.0, because the AC doesn't support half-steps for C\n+                        device.setDeviceTempSet(socket, convertTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(socket, command);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+\n+                // force refresh on next status refresh cycle\n+                forceRefresh = true;\n+            } catch (GreeException e) {\n+                logger.debug(\"{}: Unable to execute command {}\u00a0for channel {}: {}\", thingId, command, channelId,\n+                        e.toString());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"{}: Invalid command value {}\u00a0for channel {}\", thingId, command, channelUID.getId());\n+            } catch (RuntimeException e) {\n+                logger.warn(\"{}: Unable to execute command {}\u00a0for channel {}\", thingId, command, channelId, e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"{}: Send Power-{}\", thingId, command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    logger.debug(\"{}: Turn unit {}\", thingId, modeStr);\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    return;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"{}: Mode {} mapped to {}\", thingId, modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(GREE_PROP_POWER) == 0)) {\n+            logger.debug(\"{}: Send Auto-ON for mode {}\", thingId, mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"{}: Select mode {}\", thingId, mode);\n+        device.SetDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"{}: Turn on Power-Saving\", thingId);\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid QuietType\");\n+        }\n+    }\n+\n+    private int getOnOff(Command command) {\n+        if (command instanceof OnOffType) {\n+            return ((OnOffType) command) == OnOffType.ON ? 1 : 0;\n+        }\n+        if (command instanceof DecimalType) {\n+            int value = ((DecimalType) command).intValue();\n+            if ((value == 0) || (value == 1)) {\n+                return ((DecimalType) command).intValue();\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Invalid OnOffType\");\n+    }\n+\n+    private int getNumber(Command command) {\n+        if (command instanceof DecimalType) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalud Number type\");\n+    }\n+\n+    private QuantityType<?> convertTemp(Command command) {\n+        if (command instanceof DecimalType) {\n+            // The Number alone doesn't specify the temp unit\n+            // for this get current setting from the A/C unit\n+            int unit = device.getIntStatusVal(GREE_PROP_TEMPUNIT);\n+            return toQuantityType((DecimalType) command, DIGITS_TEMP,\n+                    unit == TEMP_UNIT_CELSIUS ? SIUnits.CELSIUS : ImperialUnits.FAHRENHEIT);\n+        }\n+        if (command instanceof QuantityType) {\n+            return (QuantityType<?>) command;\n+        }\n+        throw new IllegalArgumentException(\"Invalud Temp type\");\n+    }\n+\n+    private void startAutomaticRefresh() {\n+        Runnable refresher = () -> {\n+            try {\n+                // safeguard for multiple REFRESH commands\n+                if (isMinimumRefreshTimeExceeded()) {\n+                    // Get the current status from the Airconditioner\n+                    device.getDeviceStatus(clientSocket.get());\n+                    logger.debug(\"{}: Executing automatic update of values\", thingId);\n+\n+                    // Update All Channels\n+                    List<Channel> channels = getThing().getChannels();\n+                    for (Channel channel : channels) {\n+                        publishChannel(channel.getUID());\n+                    }\n+                }\n+            } catch (GreeException e) {\n+                if (!e.isTimeout()) {\n+                    logger.warn(\"{}: Unable to perform auto-update: {} ({})\", thingId, e.toString(),\n+                            e.getCause().getMessage());\n+                }\n+            } catch (RuntimeException e) {\n+                logger.warn(\"{}: Unable to perform auto-update\", thingId, e);\n+            }\n+        };\n+\n+        forceRefresh = false;\n+        if ((refreshTask != null) && !refreshTask.isCancelled()) {\n+            refreshTask.cancel(true);\n+        }\n+        refreshTask = scheduler.scheduleWithFixedDelay(refresher, 0, REFRESH_INTERVAL_SEC, TimeUnit.SECONDS);\n+        logger.debug(\"{}: Automatic refresh started ({} second interval)\", thingId, config.refresh);\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = Instant.now().toEpochMilli();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        lastRefreshTime = currentTime;\n+        if (!forceRefresh && ((lastRefreshTime == 0) || (timeSinceLastRefresh < config.refresh * 1000))) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private void publishChannel(ChannelUID channelUID) {\n+        try {\n+            String channelID = channelUID.getId();\n+            State state = null;\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case POWER_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_POWER);\n+                    break;\n+                case MODE_CHANNEL:\n+                    state = updateMode();\n+                    break;\n+                case TURBO_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_TURBO);\n+                    break;\n+                case LIGHT_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_LIGHT);\n+                    break;\n+                case TEMP_CHANNEL:\n+                    state = updateTemp();\n+                    break;\n+                case SWINGUD_CHANNEL:\n+                    state = updateNumber(GREE_PROP_SWINGUPDOWN);\n+                    break;\n+                case SWINGLR_CHANNEL:\n+                    state = updateNumber(GREE_PROP_SWINGLEFTRIGHT);\n+                    break;\n+                case WINDSPEED_CHANNEL:\n+                    state = updateNumber(GREE_PROP_WINDSPEED);\n+                    break;\n+                case QUIET_CHANNEL:\n+                    state = updateQuiet();\n+                    break;\n+                case AIR_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_AIR);\n+                    break;\n+                case DRY_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_DRY);\n+                    break;\n+                case HEALTH_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_HEALTH);\n+                    break;\n+                case PWRSAV_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_PWR_SAVING);\n+                    break;\n+            }\n+            if (state != null) {\n+                logger.debug(\"{}: Updating channel {} : {}\", thingId, channelID, state);\n+                updateState(channelID, state);\n+            }\n+        } catch (GreeException e) {\n+            logger.warn(\"{}: Exception on channel update: {}\", thingId, e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Exception on channel update\", thingId, e);\n+        }\n+    }\n+\n+    private @Nullable State updateOnOff(final String valueName) throws GreeException {\n+        if (device.hasStatusValChanged(valueName)) {\n+            return device.getIntStatusVal(valueName) == 1 ? OnOffType.ON : OnOffType.OFF;\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateNumber(final String valueName) throws GreeException {\n+        if (device.hasStatusValChanged(valueName)) {\n+            return new DecimalType(device.getIntStatusVal(valueName));\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateMode() throws GreeException {\n+        if (device.hasStatusValChanged(GREE_PROP_MODE)) {\n+            int mode = device.getIntStatusVal(GREE_PROP_MODE);\n+            String modeStr = \"\";\n+            switch (mode) {\n+                case GREE_MODE_AUTO:\n+                    modeStr = MODE_AUTO;\n+                    break;\n+                case GREE_MODE_COOL:\n+                    boolean powerSave = device.getIntStatusVal(GREE_PROP_PWR_SAVING) == 1;\n+                    modeStr = !powerSave ? MODE_COOL : MODE_ECO;\n+                    break;\n+                case GREE_MODE_DRY:\n+                    modeStr = MODE_DRY;\n+                    break;\n+                case GREE_MODE_FAN:\n+                    modeStr = MODE_FAN;\n+                    break;\n+                case GREE_MODE_HEAT:\n+                    modeStr = MODE_HEAT;\n+                    break;\n+                default:\n+                    modeStr = String.valueOf(mode);\n+\n+            }\n+            if (!modeStr.isEmpty()) {\n+                logger.debug(\"{}: Updading mode channel with {}/{}\", thingId, mode, modeStr);\n+                return new StringType(modeStr);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateQuiet() throws GreeException {\n+        if (device.hasStatusValChanged(GREE_PROP_QUIET)) {\n+            switch (device.getIntStatusVal(GREE_PROP_QUIET)) {\n+                case GREE_QUIET_OFF:\n+                    return new StringType(QUIET_OFF);\n+                case GREE_QUIET_AUTO:\n+                    return new StringType(QUIET_AUTO);\n+                case GREE_QUIET_QUIET:\n+                    return new StringType(QUIET_QUIET);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateTemp() throws GreeException {\n+        if (device.hasStatusValChanged(GREE_PROP_SETTEMP) || device.hasStatusValChanged(GREE_PROP_TEMPUNIT)) {\n+            int unit = device.getIntStatusVal(GREE_PROP_TEMPUNIT);\n+            return toQuantityType(device.getIntStatusVal(GREE_PROP_SETTEMP), DIGITS_TEMP,\n+                    unit == TEMP_UNIT_CELSIUS ? SIUnits.CELSIUS : ImperialUnits.FAHRENHEIT);\n+        }\n+        return null;\n+    }\n+\n+    public static State toQuantityType(int value, int digits, Unit<?> unit) {\n+        BigDecimal bd = new BigDecimal(value);\n+        return new QuantityType<>(bd.setScale(digits, BigDecimal.ROUND_HALF_EVEN), unit);\n+    }\n+\n+    public static QuantityType<?> toQuantityType(DecimalType value, int digits, Unit<?> unit) {\n+        BigDecimal bd = new BigDecimal(value.doubleValue());\n+        return new QuantityType<>(bd.setScale(digits, BigDecimal.ROUND_HALF_EVEN), unit);\n+    }", "originalCommit": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2ODQzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443068430", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-19T22:41:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwMDI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwMjExNw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441902117", "bodyText": "please specify the charset", "author": "cpmeister", "createdAt": "2020-06-18T00:22:22Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeCryptoUtil.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Base64;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The CryptoUtil class provides functionality for encrypting and decrypting\n+ * messages sent to and from the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeCryptoUtil {\n+    private static final String AES_KEY = \"a3K8Bx%2r8Y7#xDh\";\n+\n+    public static String GetAESGeneralKey() {\n+        return AES_KEY;\n+    }\n+\n+    public static byte[] getAESGeneralKeyByteArray() {\n+        return AES_KEY.getBytes();", "originalCommit": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2OTczMA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443069730", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-19T22:47:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwMjExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwMjg3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441902874", "bodyText": "You should catch the json syntax exception", "author": "cpmeister", "createdAt": "2020-06-18T00:25:25Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,530 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Gson gson = new Gson();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(GREE_PROP_POWER);\n+            columns.add(GREE_PROP_MODE);\n+            columns.add(GREE_PROP_SETTEMP);\n+            columns.add(GREE_PROP_WINDSPEED);\n+            columns.add(GREE_PROP_AIR);\n+            columns.add(GREE_PROP_DRY);\n+            columns.add(GREE_PROP_HEALTH);\n+            columns.add(GREE_PROP_SLEEP);\n+            columns.add(GREE_PROP_LIGHT);\n+            columns.add(GREE_PROP_SWINGLEFTRIGHT);\n+            columns.add(GREE_PROP_SWINGUPDOWN);\n+            columns.add(GREE_PROP_QUIET);\n+            columns.add(GREE_PROP_TURBO);\n+            columns.add(GREE_PROP_TEMPUNIT);\n+            columns.add(GREE_PROP_HEAT);\n+            columns.add(GREE_PROP_HEATCOOL);\n+            columns.add(GREE_PROP_TEMPREC);\n+            columns.add(GREE_PROP_PWR_SAVING);\n+            columns.add(GREE_PROP_NOISESET);\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = GREE_CMDT_STATUS;\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Encrypt and send the Status Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            JsonReader receivedData = receiveResponse(clientSocket);\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson.isPresent() && statusResponseGson.get().packJson != null) {\n+                prevStatusResponsePackGson = Optional\n+                        .of(new GreeStatusResponsePackDTO(statusResponseGson.get().packJson));\n+            }\n+\n+            // Read the response, create the JSON to hold the response values\n+            GreeStatusResponseDTO resp = gson.fromJson(receivedData, GreeStatusResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(), resp.pack);\n+            logger.debug(\"Response from device: {}\", resp.decryptedPack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeStatusResponsePackDTO.class);\n+\n+            // save the results\n+            statusResponseGson = Optional.of(resp);\n+            updateTempFtoC();\n+        } catch (IOException e) {\n+            throw new GreeException(\"I/O exception while receiving data\", e);\n+        } catch (RuntimeException e) {\n+            String json = statusResponseGson.map(r -> r.packJson.toString()).orElse(\"n/a\");\n+            throw new GreeException(\"Exception while receiving data, JSON=\" + json, e);\n+        }\n+    }\n+\n+    public void bindWithDevice(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPackDTO bindReqPackGson = new GreeBindRequestPackDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = GREE_CMDT_BIND;\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Encrypt and send the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+            DatagramPacket sendPacket = createPackRequest(1,\n+                    new String(encryptedBindReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response, create the JSON to hold the response values\n+            GreeBindResponseDTO resp = gson.fromJson(receiveResponse(clientSocket), GreeBindResponseDTO.class);", "originalCommit": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk2ODkwNw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r442968907", "bodyText": "done", "author": "markus7017", "createdAt": "2020-06-19T17:42:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwMjg3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwMzIxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441903213", "bodyText": "Use primitives if possible.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Double newVal = temp.doubleValue();\n          \n          \n            \n                    double newVal = temp.doubleValue();", "author": "cpmeister", "createdAt": "2020-06-18T00:26:49Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,530 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Gson gson = new Gson();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(GREE_PROP_POWER);\n+            columns.add(GREE_PROP_MODE);\n+            columns.add(GREE_PROP_SETTEMP);\n+            columns.add(GREE_PROP_WINDSPEED);\n+            columns.add(GREE_PROP_AIR);\n+            columns.add(GREE_PROP_DRY);\n+            columns.add(GREE_PROP_HEALTH);\n+            columns.add(GREE_PROP_SLEEP);\n+            columns.add(GREE_PROP_LIGHT);\n+            columns.add(GREE_PROP_SWINGLEFTRIGHT);\n+            columns.add(GREE_PROP_SWINGUPDOWN);\n+            columns.add(GREE_PROP_QUIET);\n+            columns.add(GREE_PROP_TURBO);\n+            columns.add(GREE_PROP_TEMPUNIT);\n+            columns.add(GREE_PROP_HEAT);\n+            columns.add(GREE_PROP_HEATCOOL);\n+            columns.add(GREE_PROP_TEMPREC);\n+            columns.add(GREE_PROP_PWR_SAVING);\n+            columns.add(GREE_PROP_NOISESET);\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = GREE_CMDT_STATUS;\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Encrypt and send the Status Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            JsonReader receivedData = receiveResponse(clientSocket);\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson.isPresent() && statusResponseGson.get().packJson != null) {\n+                prevStatusResponsePackGson = Optional\n+                        .of(new GreeStatusResponsePackDTO(statusResponseGson.get().packJson));\n+            }\n+\n+            // Read the response, create the JSON to hold the response values\n+            GreeStatusResponseDTO resp = gson.fromJson(receivedData, GreeStatusResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(), resp.pack);\n+            logger.debug(\"Response from device: {}\", resp.decryptedPack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeStatusResponsePackDTO.class);\n+\n+            // save the results\n+            statusResponseGson = Optional.of(resp);\n+            updateTempFtoC();\n+        } catch (IOException e) {\n+            throw new GreeException(\"I/O exception while receiving data\", e);\n+        } catch (RuntimeException e) {\n+            String json = statusResponseGson.map(r -> r.packJson.toString()).orElse(\"n/a\");\n+            throw new GreeException(\"Exception while receiving data, JSON=\" + json, e);\n+        }\n+    }\n+\n+    public void bindWithDevice(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPackDTO bindReqPackGson = new GreeBindRequestPackDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = GREE_CMDT_BIND;\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Encrypt and send the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+            DatagramPacket sendPacket = createPackRequest(1,\n+                    new String(encryptedBindReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response, create the JSON to hold the response values\n+            GreeBindResponseDTO resp = gson.fromJson(receiveResponse(clientSocket), GreeBindResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), resp.pack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeBindResponsePackDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = resp.packJson.key;\n+\n+            // save the outcome\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(\"Unable to bind to device\", e);\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_POWER, value);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        if ((value < 0 || value > 4)) {\n+            throw new GreeException(\"Device mode out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_MODE, value);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if ((value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"SwingUpDown value out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_SWINGUPDOWN, value);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_SWINGLEFTRIGHT, value, 0, 6);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (value < 0 || value > 5) {\n+            throw new GreeException(\"Value out of range!\");\n+        }\n+\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_WINDSPEED, value);\n+        parameters.put(GREE_PROP_QUIET, 0);\n+        parameters.put(GREE_PROP_TURBO, 0);\n+        parameters.put(GREE_PROP_NOISE, 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_TURBO, value, 0, 1);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_QUIET, value, 0, 2);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(GREE_PROP_TURBO);\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_LIGHT, value);\n+    }\n+\n+    /**\n+     * @param value set temperature in degrees Celsius or Fahrenheit\n+     */\n+    public void setDeviceTempSet(DatagramSocket clientSocket, QuantityType<?> temp) throws GreeException {\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        Double newVal = temp.doubleValue();", "originalCommit": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk2OTQ3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r442969474", "bodyText": "done", "author": "markus7017", "createdAt": "2020-06-19T17:43:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwMzIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwNDQ0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441904440", "bodyText": "if statusResponseGson isn't present then this will throw an exception.", "author": "cpmeister", "createdAt": "2020-06-18T00:31:51Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,530 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Gson gson = new Gson();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(GREE_PROP_POWER);\n+            columns.add(GREE_PROP_MODE);\n+            columns.add(GREE_PROP_SETTEMP);\n+            columns.add(GREE_PROP_WINDSPEED);\n+            columns.add(GREE_PROP_AIR);\n+            columns.add(GREE_PROP_DRY);\n+            columns.add(GREE_PROP_HEALTH);\n+            columns.add(GREE_PROP_SLEEP);\n+            columns.add(GREE_PROP_LIGHT);\n+            columns.add(GREE_PROP_SWINGLEFTRIGHT);\n+            columns.add(GREE_PROP_SWINGUPDOWN);\n+            columns.add(GREE_PROP_QUIET);\n+            columns.add(GREE_PROP_TURBO);\n+            columns.add(GREE_PROP_TEMPUNIT);\n+            columns.add(GREE_PROP_HEAT);\n+            columns.add(GREE_PROP_HEATCOOL);\n+            columns.add(GREE_PROP_TEMPREC);\n+            columns.add(GREE_PROP_PWR_SAVING);\n+            columns.add(GREE_PROP_NOISESET);\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = GREE_CMDT_STATUS;\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Encrypt and send the Status Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            JsonReader receivedData = receiveResponse(clientSocket);\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson.isPresent() && statusResponseGson.get().packJson != null) {\n+                prevStatusResponsePackGson = Optional\n+                        .of(new GreeStatusResponsePackDTO(statusResponseGson.get().packJson));\n+            }\n+\n+            // Read the response, create the JSON to hold the response values\n+            GreeStatusResponseDTO resp = gson.fromJson(receivedData, GreeStatusResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(), resp.pack);\n+            logger.debug(\"Response from device: {}\", resp.decryptedPack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeStatusResponsePackDTO.class);\n+\n+            // save the results\n+            statusResponseGson = Optional.of(resp);\n+            updateTempFtoC();\n+        } catch (IOException e) {\n+            throw new GreeException(\"I/O exception while receiving data\", e);\n+        } catch (RuntimeException e) {\n+            String json = statusResponseGson.map(r -> r.packJson.toString()).orElse(\"n/a\");\n+            throw new GreeException(\"Exception while receiving data, JSON=\" + json, e);\n+        }\n+    }\n+\n+    public void bindWithDevice(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPackDTO bindReqPackGson = new GreeBindRequestPackDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = GREE_CMDT_BIND;\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Encrypt and send the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+            DatagramPacket sendPacket = createPackRequest(1,\n+                    new String(encryptedBindReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response, create the JSON to hold the response values\n+            GreeBindResponseDTO resp = gson.fromJson(receiveResponse(clientSocket), GreeBindResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), resp.pack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeBindResponsePackDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = resp.packJson.key;\n+\n+            // save the outcome\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(\"Unable to bind to device\", e);\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_POWER, value);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        if ((value < 0 || value > 4)) {\n+            throw new GreeException(\"Device mode out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_MODE, value);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if ((value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"SwingUpDown value out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_SWINGUPDOWN, value);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_SWINGLEFTRIGHT, value, 0, 6);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (value < 0 || value > 5) {\n+            throw new GreeException(\"Value out of range!\");\n+        }\n+\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_WINDSPEED, value);\n+        parameters.put(GREE_PROP_QUIET, 0);\n+        parameters.put(GREE_PROP_TURBO, 0);\n+        parameters.put(GREE_PROP_NOISE, 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_TURBO, value, 0, 1);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_QUIET, value, 0, 2);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(GREE_PROP_TURBO);\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_LIGHT, value);\n+    }\n+\n+    /**\n+     * @param value set temperature in degrees Celsius or Fahrenheit\n+     */\n+    public void setDeviceTempSet(DatagramSocket clientSocket, QuantityType<?> temp) throws GreeException {\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        Double newVal = temp.doubleValue();\n+        int CorF = temp.getUnit() == SIUnits.CELSIUS ? TEMP_UNIT_CELSIUS : TEMP_UNIT_FAHRENHEIT; // 0=Celsius,\n+                                                                                                 // 1=Fahrenheit\n+        if (((CorF == TEMP_UNIT_CELSIUS) && (newVal < TEMP_MIN_C || newVal > TEMP_MAX_C))\n+                || ((CorF == TEMP_UNIT_FAHRENHEIT) && (newVal < TEMP_MIN_F || newVal > TEMP_MAX_F))) {\n+            throw new IllegalArgumentException(\"Temp Value out of Range\");\n+        }\n+\n+        // Default for Celsius\n+        int outVal = newVal.intValue();\n+        int halfStep = TEMP_HALFSTEP_NO; // for whatever reason halfStep is not supported for Celsius\n+\n+        // If value argument is degrees F, convert Fahrenheit to Celsius,\n+        // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+        // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+        // F = [68...86]\n+        // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+        // 28.8, 29.4, 30.0]\n+        //\n+        // TemSet = [20..30] or [68..86]\n+        // TemRec = value - (value) > 0 ? 1 : 1 -> when xx.5 is request xx will become TemSet and halfStep the indicator\n+        // for \"half on top of TemSet\"\n+        // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+        // subtract the float version - the int version to get the fractional difference\n+        // if the difference is positive set halfStep to 1, negative to 0\n+        if (CorF == TEMP_UNIT_FAHRENHEIT) { // If Fahrenheit,\n+            /*\n+             * outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+             * halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+             */\n+            halfStep = newVal - outVal > 0 ? TEMP_HALFSTEP_YES : TEMP_HALFSTEP_NO;\n+        }\n+        logger.debug(\"Converted temp from {}{} to temp={}, halfStep={}, unit={})\", newVal, temp.getUnit(), outVal,\n+                halfStep, CorF == TEMP_UNIT_CELSIUS ? \"C\" : \"F\");\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_TEMPUNIT, CorF);\n+        parameters.put(GREE_PROP_SETTEMP, outVal);\n+        parameters.put(GREE_PROP_TEMPREC, halfStep);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_AIR, value);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_DRY, value);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_HEALTH, value);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_PWR_SAVING, value);\n+        parameters.put(GREE_PROP_WINDSPEED, 0);\n+        parameters.put(GREE_PROP_QUIET, 0);\n+        parameters.put(GREE_PROP_TURBO, 0);\n+        parameters.put(GREE_PROP_SLEEP, 0);\n+        parameters.put(GREE_PROP_SLEEPMODE, 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        if (isStatusAvailable()) {\n+            List<String> colList = Arrays.asList(statusResponseGson.get().packJson.cols);\n+            List<Integer> valList = Arrays.asList(statusResponseGson.get().packJson.dat);\n+            int valueArrayposition = colList.indexOf(valueName);\n+            if (valueArrayposition != -1) {\n+                // get the Corresponding value\n+                Integer value = valList.get(valueArrayposition);\n+                return value;\n+            }\n+        }\n+\n+        return -1;\n+    }\n+\n+    public boolean isStatusAvailable() {\n+        return statusResponseGson.isPresent();\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (!prevStatusResponsePackGson.isPresent()) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        List<String> currcolList = Arrays.asList(statusResponseGson.get().packJson.cols);", "originalCommit": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0MTQ4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443041482", "bodyText": "I suppose as it is designed that wouldn't happen so feel free to ignore this change.", "author": "cpmeister", "createdAt": "2020-06-19T20:59:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwNDQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwNDgyMg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441904822", "bodyText": "There are a lot more places that you are using the JsonReader instead of the string directly, so I suspect you are doing it intentionally. If you aren't then change them all to use the string directly as per my earlier comment.", "author": "cpmeister", "createdAt": "2020-06-18T00:33:18Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,530 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Gson gson = new Gson();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(GREE_PROP_POWER);\n+            columns.add(GREE_PROP_MODE);\n+            columns.add(GREE_PROP_SETTEMP);\n+            columns.add(GREE_PROP_WINDSPEED);\n+            columns.add(GREE_PROP_AIR);\n+            columns.add(GREE_PROP_DRY);\n+            columns.add(GREE_PROP_HEALTH);\n+            columns.add(GREE_PROP_SLEEP);\n+            columns.add(GREE_PROP_LIGHT);\n+            columns.add(GREE_PROP_SWINGLEFTRIGHT);\n+            columns.add(GREE_PROP_SWINGUPDOWN);\n+            columns.add(GREE_PROP_QUIET);\n+            columns.add(GREE_PROP_TURBO);\n+            columns.add(GREE_PROP_TEMPUNIT);\n+            columns.add(GREE_PROP_HEAT);\n+            columns.add(GREE_PROP_HEATCOOL);\n+            columns.add(GREE_PROP_TEMPREC);\n+            columns.add(GREE_PROP_PWR_SAVING);\n+            columns.add(GREE_PROP_NOISESET);\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = GREE_CMDT_STATUS;\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Encrypt and send the Status Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            JsonReader receivedData = receiveResponse(clientSocket);\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson.isPresent() && statusResponseGson.get().packJson != null) {\n+                prevStatusResponsePackGson = Optional\n+                        .of(new GreeStatusResponsePackDTO(statusResponseGson.get().packJson));\n+            }\n+\n+            // Read the response, create the JSON to hold the response values\n+            GreeStatusResponseDTO resp = gson.fromJson(receivedData, GreeStatusResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(), resp.pack);\n+            logger.debug(\"Response from device: {}\", resp.decryptedPack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeStatusResponsePackDTO.class);\n+\n+            // save the results\n+            statusResponseGson = Optional.of(resp);\n+            updateTempFtoC();\n+        } catch (IOException e) {\n+            throw new GreeException(\"I/O exception while receiving data\", e);\n+        } catch (RuntimeException e) {\n+            String json = statusResponseGson.map(r -> r.packJson.toString()).orElse(\"n/a\");\n+            throw new GreeException(\"Exception while receiving data, JSON=\" + json, e);\n+        }\n+    }\n+\n+    public void bindWithDevice(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPackDTO bindReqPackGson = new GreeBindRequestPackDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = GREE_CMDT_BIND;\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Encrypt and send the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+            DatagramPacket sendPacket = createPackRequest(1,\n+                    new String(encryptedBindReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response, create the JSON to hold the response values\n+            GreeBindResponseDTO resp = gson.fromJson(receiveResponse(clientSocket), GreeBindResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), resp.pack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeBindResponsePackDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = resp.packJson.key;\n+\n+            // save the outcome\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(\"Unable to bind to device\", e);\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_POWER, value);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        if ((value < 0 || value > 4)) {\n+            throw new GreeException(\"Device mode out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_MODE, value);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if ((value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"SwingUpDown value out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_SWINGUPDOWN, value);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_SWINGLEFTRIGHT, value, 0, 6);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (value < 0 || value > 5) {\n+            throw new GreeException(\"Value out of range!\");\n+        }\n+\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_WINDSPEED, value);\n+        parameters.put(GREE_PROP_QUIET, 0);\n+        parameters.put(GREE_PROP_TURBO, 0);\n+        parameters.put(GREE_PROP_NOISE, 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_TURBO, value, 0, 1);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_QUIET, value, 0, 2);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(GREE_PROP_TURBO);\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_LIGHT, value);\n+    }\n+\n+    /**\n+     * @param value set temperature in degrees Celsius or Fahrenheit\n+     */\n+    public void setDeviceTempSet(DatagramSocket clientSocket, QuantityType<?> temp) throws GreeException {\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        Double newVal = temp.doubleValue();\n+        int CorF = temp.getUnit() == SIUnits.CELSIUS ? TEMP_UNIT_CELSIUS : TEMP_UNIT_FAHRENHEIT; // 0=Celsius,\n+                                                                                                 // 1=Fahrenheit\n+        if (((CorF == TEMP_UNIT_CELSIUS) && (newVal < TEMP_MIN_C || newVal > TEMP_MAX_C))\n+                || ((CorF == TEMP_UNIT_FAHRENHEIT) && (newVal < TEMP_MIN_F || newVal > TEMP_MAX_F))) {\n+            throw new IllegalArgumentException(\"Temp Value out of Range\");\n+        }\n+\n+        // Default for Celsius\n+        int outVal = newVal.intValue();\n+        int halfStep = TEMP_HALFSTEP_NO; // for whatever reason halfStep is not supported for Celsius\n+\n+        // If value argument is degrees F, convert Fahrenheit to Celsius,\n+        // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+        // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+        // F = [68...86]\n+        // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+        // 28.8, 29.4, 30.0]\n+        //\n+        // TemSet = [20..30] or [68..86]\n+        // TemRec = value - (value) > 0 ? 1 : 1 -> when xx.5 is request xx will become TemSet and halfStep the indicator\n+        // for \"half on top of TemSet\"\n+        // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+        // subtract the float version - the int version to get the fractional difference\n+        // if the difference is positive set halfStep to 1, negative to 0\n+        if (CorF == TEMP_UNIT_FAHRENHEIT) { // If Fahrenheit,\n+            /*\n+             * outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+             * halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+             */\n+            halfStep = newVal - outVal > 0 ? TEMP_HALFSTEP_YES : TEMP_HALFSTEP_NO;\n+        }\n+        logger.debug(\"Converted temp from {}{} to temp={}, halfStep={}, unit={})\", newVal, temp.getUnit(), outVal,\n+                halfStep, CorF == TEMP_UNIT_CELSIUS ? \"C\" : \"F\");\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_TEMPUNIT, CorF);\n+        parameters.put(GREE_PROP_SETTEMP, outVal);\n+        parameters.put(GREE_PROP_TEMPREC, halfStep);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_AIR, value);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_DRY, value);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_HEALTH, value);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_PWR_SAVING, value);\n+        parameters.put(GREE_PROP_WINDSPEED, 0);\n+        parameters.put(GREE_PROP_QUIET, 0);\n+        parameters.put(GREE_PROP_TURBO, 0);\n+        parameters.put(GREE_PROP_SLEEP, 0);\n+        parameters.put(GREE_PROP_SLEEPMODE, 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        if (isStatusAvailable()) {\n+            List<String> colList = Arrays.asList(statusResponseGson.get().packJson.cols);\n+            List<Integer> valList = Arrays.asList(statusResponseGson.get().packJson.dat);\n+            int valueArrayposition = colList.indexOf(valueName);\n+            if (valueArrayposition != -1) {\n+                // get the Corresponding value\n+                Integer value = valList.get(valueArrayposition);\n+                return value;\n+            }\n+        }\n+\n+        return -1;\n+    }\n+\n+    public boolean isStatusAvailable() {\n+        return statusResponseGson.isPresent();\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (!prevStatusResponsePackGson.isPresent()) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        List<String> currcolList = Arrays.asList(statusResponseGson.get().packJson.cols);\n+        List<Integer> currvalList = Arrays.asList(statusResponseGson.get().packJson.dat);\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\n+        if (currvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to decode device status\");\n+        }\n+\n+        // Find the valueName in the Previous Status object\n+        List<String> prevcolList = Arrays.asList(prevStatusResponsePackGson.get().cols);\n+        List<Integer> prevvalList = Arrays.asList(prevStatusResponsePackGson.get().dat);\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\n+        if (prevvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to get status value\");\n+        }\n+\n+        // Finally Compare the values\n+        return currvalList.get(currvalueArrayposition) != prevvalList.get(prevvalueArrayposition);\n+    }\n+\n+    protected void executeCommand(DatagramSocket clientSocket, Map<String, Integer> parameters) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        try {\n+            // Convert the parameter map values to arrays\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\n+\n+            // Prep the Command Request pack\n+            GreeExecuteCommandPackDTO execCmdPackGson = new GreeExecuteCommandPackDTO();\n+            execCmdPackGson.opt = keyArray;\n+            execCmdPackGson.p = valueArray;\n+            execCmdPackGson.t = GREE_CMDT_CMD;\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\n+\n+            // Now encrypt and send the Command Request pack\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), execCmdPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedCommandReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            GreeExecResponseDTO execResponseGson = gson.fromJson(receiveResponse(clientSocket),\n+                    GreeExecResponseDTO.class);\n+            execResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(),\n+                    execResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            execResponseGson.packJson = gson.fromJson(new JsonReader(new StringReader(execResponseGson.decryptedPack)),", "originalCommit": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk2NzkyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r442967929", "bodyText": "this is from the old code; I did already changed it, but then users reported exceptions. I don't understand why, but after reverting the change, exception was gone", "author": "markus7017", "createdAt": "2020-06-19T17:39:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwNDgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0MTg2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443041866", "bodyText": "Do you know what the exception was?", "author": "cpmeister", "createdAt": "2020-06-19T21:00:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwNDgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzExNzA1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443117051", "bodyText": "I was able to debug it, the packet is padded with 0x00 bytes, refactored the response handling to trim the string, then it works", "author": "markus7017", "createdAt": "2020-06-20T09:35:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwNDgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwNTYxMA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441905610", "bodyText": "Why are you converting a string -> byte[] -> string?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        DatagramPacket sendPacket = createPackRequest(0,\n          \n          \n            \n                                new String(encryptedCommandReqPacket.getBytes(), StandardCharsets.UTF_8));\n          \n          \n            \n                        DatagramPacket sendPacket = createPackRequest(0, encryptedCommandReqPacket);", "author": "cpmeister", "createdAt": "2020-06-18T00:36:12Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,530 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Gson gson = new Gson();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(GREE_PROP_POWER);\n+            columns.add(GREE_PROP_MODE);\n+            columns.add(GREE_PROP_SETTEMP);\n+            columns.add(GREE_PROP_WINDSPEED);\n+            columns.add(GREE_PROP_AIR);\n+            columns.add(GREE_PROP_DRY);\n+            columns.add(GREE_PROP_HEALTH);\n+            columns.add(GREE_PROP_SLEEP);\n+            columns.add(GREE_PROP_LIGHT);\n+            columns.add(GREE_PROP_SWINGLEFTRIGHT);\n+            columns.add(GREE_PROP_SWINGUPDOWN);\n+            columns.add(GREE_PROP_QUIET);\n+            columns.add(GREE_PROP_TURBO);\n+            columns.add(GREE_PROP_TEMPUNIT);\n+            columns.add(GREE_PROP_HEAT);\n+            columns.add(GREE_PROP_HEATCOOL);\n+            columns.add(GREE_PROP_TEMPREC);\n+            columns.add(GREE_PROP_PWR_SAVING);\n+            columns.add(GREE_PROP_NOISESET);\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = GREE_CMDT_STATUS;\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Encrypt and send the Status Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            JsonReader receivedData = receiveResponse(clientSocket);\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson.isPresent() && statusResponseGson.get().packJson != null) {\n+                prevStatusResponsePackGson = Optional\n+                        .of(new GreeStatusResponsePackDTO(statusResponseGson.get().packJson));\n+            }\n+\n+            // Read the response, create the JSON to hold the response values\n+            GreeStatusResponseDTO resp = gson.fromJson(receivedData, GreeStatusResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(), resp.pack);\n+            logger.debug(\"Response from device: {}\", resp.decryptedPack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeStatusResponsePackDTO.class);\n+\n+            // save the results\n+            statusResponseGson = Optional.of(resp);\n+            updateTempFtoC();\n+        } catch (IOException e) {\n+            throw new GreeException(\"I/O exception while receiving data\", e);\n+        } catch (RuntimeException e) {\n+            String json = statusResponseGson.map(r -> r.packJson.toString()).orElse(\"n/a\");\n+            throw new GreeException(\"Exception while receiving data, JSON=\" + json, e);\n+        }\n+    }\n+\n+    public void bindWithDevice(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPackDTO bindReqPackGson = new GreeBindRequestPackDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = GREE_CMDT_BIND;\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Encrypt and send the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+            DatagramPacket sendPacket = createPackRequest(1,\n+                    new String(encryptedBindReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response, create the JSON to hold the response values\n+            GreeBindResponseDTO resp = gson.fromJson(receiveResponse(clientSocket), GreeBindResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), resp.pack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeBindResponsePackDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = resp.packJson.key;\n+\n+            // save the outcome\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(\"Unable to bind to device\", e);\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_POWER, value);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        if ((value < 0 || value > 4)) {\n+            throw new GreeException(\"Device mode out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_MODE, value);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if ((value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"SwingUpDown value out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_SWINGUPDOWN, value);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_SWINGLEFTRIGHT, value, 0, 6);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (value < 0 || value > 5) {\n+            throw new GreeException(\"Value out of range!\");\n+        }\n+\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_WINDSPEED, value);\n+        parameters.put(GREE_PROP_QUIET, 0);\n+        parameters.put(GREE_PROP_TURBO, 0);\n+        parameters.put(GREE_PROP_NOISE, 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_TURBO, value, 0, 1);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_QUIET, value, 0, 2);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(GREE_PROP_TURBO);\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_LIGHT, value);\n+    }\n+\n+    /**\n+     * @param value set temperature in degrees Celsius or Fahrenheit\n+     */\n+    public void setDeviceTempSet(DatagramSocket clientSocket, QuantityType<?> temp) throws GreeException {\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        Double newVal = temp.doubleValue();\n+        int CorF = temp.getUnit() == SIUnits.CELSIUS ? TEMP_UNIT_CELSIUS : TEMP_UNIT_FAHRENHEIT; // 0=Celsius,\n+                                                                                                 // 1=Fahrenheit\n+        if (((CorF == TEMP_UNIT_CELSIUS) && (newVal < TEMP_MIN_C || newVal > TEMP_MAX_C))\n+                || ((CorF == TEMP_UNIT_FAHRENHEIT) && (newVal < TEMP_MIN_F || newVal > TEMP_MAX_F))) {\n+            throw new IllegalArgumentException(\"Temp Value out of Range\");\n+        }\n+\n+        // Default for Celsius\n+        int outVal = newVal.intValue();\n+        int halfStep = TEMP_HALFSTEP_NO; // for whatever reason halfStep is not supported for Celsius\n+\n+        // If value argument is degrees F, convert Fahrenheit to Celsius,\n+        // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+        // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+        // F = [68...86]\n+        // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+        // 28.8, 29.4, 30.0]\n+        //\n+        // TemSet = [20..30] or [68..86]\n+        // TemRec = value - (value) > 0 ? 1 : 1 -> when xx.5 is request xx will become TemSet and halfStep the indicator\n+        // for \"half on top of TemSet\"\n+        // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+        // subtract the float version - the int version to get the fractional difference\n+        // if the difference is positive set halfStep to 1, negative to 0\n+        if (CorF == TEMP_UNIT_FAHRENHEIT) { // If Fahrenheit,\n+            /*\n+             * outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+             * halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+             */\n+            halfStep = newVal - outVal > 0 ? TEMP_HALFSTEP_YES : TEMP_HALFSTEP_NO;\n+        }\n+        logger.debug(\"Converted temp from {}{} to temp={}, halfStep={}, unit={})\", newVal, temp.getUnit(), outVal,\n+                halfStep, CorF == TEMP_UNIT_CELSIUS ? \"C\" : \"F\");\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_TEMPUNIT, CorF);\n+        parameters.put(GREE_PROP_SETTEMP, outVal);\n+        parameters.put(GREE_PROP_TEMPREC, halfStep);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_AIR, value);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_DRY, value);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_HEALTH, value);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_PWR_SAVING, value);\n+        parameters.put(GREE_PROP_WINDSPEED, 0);\n+        parameters.put(GREE_PROP_QUIET, 0);\n+        parameters.put(GREE_PROP_TURBO, 0);\n+        parameters.put(GREE_PROP_SLEEP, 0);\n+        parameters.put(GREE_PROP_SLEEPMODE, 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        if (isStatusAvailable()) {\n+            List<String> colList = Arrays.asList(statusResponseGson.get().packJson.cols);\n+            List<Integer> valList = Arrays.asList(statusResponseGson.get().packJson.dat);\n+            int valueArrayposition = colList.indexOf(valueName);\n+            if (valueArrayposition != -1) {\n+                // get the Corresponding value\n+                Integer value = valList.get(valueArrayposition);\n+                return value;\n+            }\n+        }\n+\n+        return -1;\n+    }\n+\n+    public boolean isStatusAvailable() {\n+        return statusResponseGson.isPresent();\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (!prevStatusResponsePackGson.isPresent()) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        List<String> currcolList = Arrays.asList(statusResponseGson.get().packJson.cols);\n+        List<Integer> currvalList = Arrays.asList(statusResponseGson.get().packJson.dat);\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\n+        if (currvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to decode device status\");\n+        }\n+\n+        // Find the valueName in the Previous Status object\n+        List<String> prevcolList = Arrays.asList(prevStatusResponsePackGson.get().cols);\n+        List<Integer> prevvalList = Arrays.asList(prevStatusResponsePackGson.get().dat);\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\n+        if (prevvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to get status value\");\n+        }\n+\n+        // Finally Compare the values\n+        return currvalList.get(currvalueArrayposition) != prevvalList.get(prevvalueArrayposition);\n+    }\n+\n+    protected void executeCommand(DatagramSocket clientSocket, Map<String, Integer> parameters) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        try {\n+            // Convert the parameter map values to arrays\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\n+\n+            // Prep the Command Request pack\n+            GreeExecuteCommandPackDTO execCmdPackGson = new GreeExecuteCommandPackDTO();\n+            execCmdPackGson.opt = keyArray;\n+            execCmdPackGson.p = valueArray;\n+            execCmdPackGson.t = GREE_CMDT_CMD;\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\n+\n+            // Now encrypt and send the Command Request pack\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), execCmdPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedCommandReqPacket.getBytes(), StandardCharsets.UTF_8));", "originalCommit": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzExNzA5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443117093", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-20T09:36:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwNTYxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwNTk5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441905992", "bodyText": "You should specify the charset for getBytes. And do the same for the other places you are using getKey() in this class.", "author": "cpmeister", "createdAt": "2020-06-18T00:37:52Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,530 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Gson gson = new Gson();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(GREE_PROP_POWER);\n+            columns.add(GREE_PROP_MODE);\n+            columns.add(GREE_PROP_SETTEMP);\n+            columns.add(GREE_PROP_WINDSPEED);\n+            columns.add(GREE_PROP_AIR);\n+            columns.add(GREE_PROP_DRY);\n+            columns.add(GREE_PROP_HEALTH);\n+            columns.add(GREE_PROP_SLEEP);\n+            columns.add(GREE_PROP_LIGHT);\n+            columns.add(GREE_PROP_SWINGLEFTRIGHT);\n+            columns.add(GREE_PROP_SWINGUPDOWN);\n+            columns.add(GREE_PROP_QUIET);\n+            columns.add(GREE_PROP_TURBO);\n+            columns.add(GREE_PROP_TEMPUNIT);\n+            columns.add(GREE_PROP_HEAT);\n+            columns.add(GREE_PROP_HEATCOOL);\n+            columns.add(GREE_PROP_TEMPREC);\n+            columns.add(GREE_PROP_PWR_SAVING);\n+            columns.add(GREE_PROP_NOISESET);\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = GREE_CMDT_STATUS;\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Encrypt and send the Status Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            JsonReader receivedData = receiveResponse(clientSocket);\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson.isPresent() && statusResponseGson.get().packJson != null) {\n+                prevStatusResponsePackGson = Optional\n+                        .of(new GreeStatusResponsePackDTO(statusResponseGson.get().packJson));\n+            }\n+\n+            // Read the response, create the JSON to hold the response values\n+            GreeStatusResponseDTO resp = gson.fromJson(receivedData, GreeStatusResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(), resp.pack);\n+            logger.debug(\"Response from device: {}\", resp.decryptedPack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeStatusResponsePackDTO.class);\n+\n+            // save the results\n+            statusResponseGson = Optional.of(resp);\n+            updateTempFtoC();\n+        } catch (IOException e) {\n+            throw new GreeException(\"I/O exception while receiving data\", e);\n+        } catch (RuntimeException e) {\n+            String json = statusResponseGson.map(r -> r.packJson.toString()).orElse(\"n/a\");\n+            throw new GreeException(\"Exception while receiving data, JSON=\" + json, e);\n+        }\n+    }\n+\n+    public void bindWithDevice(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPackDTO bindReqPackGson = new GreeBindRequestPackDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = GREE_CMDT_BIND;\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Encrypt and send the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+            DatagramPacket sendPacket = createPackRequest(1,\n+                    new String(encryptedBindReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response, create the JSON to hold the response values\n+            GreeBindResponseDTO resp = gson.fromJson(receiveResponse(clientSocket), GreeBindResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), resp.pack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeBindResponsePackDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = resp.packJson.key;\n+\n+            // save the outcome\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(\"Unable to bind to device\", e);\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_POWER, value);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        if ((value < 0 || value > 4)) {\n+            throw new GreeException(\"Device mode out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_MODE, value);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if ((value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"SwingUpDown value out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_SWINGUPDOWN, value);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_SWINGLEFTRIGHT, value, 0, 6);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (value < 0 || value > 5) {\n+            throw new GreeException(\"Value out of range!\");\n+        }\n+\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_WINDSPEED, value);\n+        parameters.put(GREE_PROP_QUIET, 0);\n+        parameters.put(GREE_PROP_TURBO, 0);\n+        parameters.put(GREE_PROP_NOISE, 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_TURBO, value, 0, 1);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_QUIET, value, 0, 2);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(GREE_PROP_TURBO);\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_LIGHT, value);\n+    }\n+\n+    /**\n+     * @param value set temperature in degrees Celsius or Fahrenheit\n+     */\n+    public void setDeviceTempSet(DatagramSocket clientSocket, QuantityType<?> temp) throws GreeException {\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        Double newVal = temp.doubleValue();\n+        int CorF = temp.getUnit() == SIUnits.CELSIUS ? TEMP_UNIT_CELSIUS : TEMP_UNIT_FAHRENHEIT; // 0=Celsius,\n+                                                                                                 // 1=Fahrenheit\n+        if (((CorF == TEMP_UNIT_CELSIUS) && (newVal < TEMP_MIN_C || newVal > TEMP_MAX_C))\n+                || ((CorF == TEMP_UNIT_FAHRENHEIT) && (newVal < TEMP_MIN_F || newVal > TEMP_MAX_F))) {\n+            throw new IllegalArgumentException(\"Temp Value out of Range\");\n+        }\n+\n+        // Default for Celsius\n+        int outVal = newVal.intValue();\n+        int halfStep = TEMP_HALFSTEP_NO; // for whatever reason halfStep is not supported for Celsius\n+\n+        // If value argument is degrees F, convert Fahrenheit to Celsius,\n+        // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+        // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+        // F = [68...86]\n+        // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+        // 28.8, 29.4, 30.0]\n+        //\n+        // TemSet = [20..30] or [68..86]\n+        // TemRec = value - (value) > 0 ? 1 : 1 -> when xx.5 is request xx will become TemSet and halfStep the indicator\n+        // for \"half on top of TemSet\"\n+        // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+        // subtract the float version - the int version to get the fractional difference\n+        // if the difference is positive set halfStep to 1, negative to 0\n+        if (CorF == TEMP_UNIT_FAHRENHEIT) { // If Fahrenheit,\n+            /*\n+             * outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+             * halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+             */\n+            halfStep = newVal - outVal > 0 ? TEMP_HALFSTEP_YES : TEMP_HALFSTEP_NO;\n+        }\n+        logger.debug(\"Converted temp from {}{} to temp={}, halfStep={}, unit={})\", newVal, temp.getUnit(), outVal,\n+                halfStep, CorF == TEMP_UNIT_CELSIUS ? \"C\" : \"F\");\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_TEMPUNIT, CorF);\n+        parameters.put(GREE_PROP_SETTEMP, outVal);\n+        parameters.put(GREE_PROP_TEMPREC, halfStep);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_AIR, value);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_DRY, value);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_HEALTH, value);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_PWR_SAVING, value);\n+        parameters.put(GREE_PROP_WINDSPEED, 0);\n+        parameters.put(GREE_PROP_QUIET, 0);\n+        parameters.put(GREE_PROP_TURBO, 0);\n+        parameters.put(GREE_PROP_SLEEP, 0);\n+        parameters.put(GREE_PROP_SLEEPMODE, 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        if (isStatusAvailable()) {\n+            List<String> colList = Arrays.asList(statusResponseGson.get().packJson.cols);\n+            List<Integer> valList = Arrays.asList(statusResponseGson.get().packJson.dat);\n+            int valueArrayposition = colList.indexOf(valueName);\n+            if (valueArrayposition != -1) {\n+                // get the Corresponding value\n+                Integer value = valList.get(valueArrayposition);\n+                return value;\n+            }\n+        }\n+\n+        return -1;\n+    }\n+\n+    public boolean isStatusAvailable() {\n+        return statusResponseGson.isPresent();\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (!prevStatusResponsePackGson.isPresent()) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        List<String> currcolList = Arrays.asList(statusResponseGson.get().packJson.cols);\n+        List<Integer> currvalList = Arrays.asList(statusResponseGson.get().packJson.dat);\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\n+        if (currvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to decode device status\");\n+        }\n+\n+        // Find the valueName in the Previous Status object\n+        List<String> prevcolList = Arrays.asList(prevStatusResponsePackGson.get().cols);\n+        List<Integer> prevvalList = Arrays.asList(prevStatusResponsePackGson.get().dat);\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\n+        if (prevvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to get status value\");\n+        }\n+\n+        // Finally Compare the values\n+        return currvalList.get(currvalueArrayposition) != prevvalList.get(prevvalueArrayposition);\n+    }\n+\n+    protected void executeCommand(DatagramSocket clientSocket, Map<String, Integer> parameters) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        try {\n+            // Convert the parameter map values to arrays\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\n+\n+            // Prep the Command Request pack\n+            GreeExecuteCommandPackDTO execCmdPackGson = new GreeExecuteCommandPackDTO();\n+            execCmdPackGson.opt = keyArray;\n+            execCmdPackGson.p = valueArray;\n+            execCmdPackGson.t = GREE_CMDT_CMD;\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\n+\n+            // Now encrypt and send the Command Request pack\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), execCmdPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedCommandReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            GreeExecResponseDTO execResponseGson = gson.fromJson(receiveResponse(clientSocket),\n+                    GreeExecResponseDTO.class);\n+            execResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(),", "originalCommit": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3MDM4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443070386", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-19T22:51:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwNTk5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwNjE4MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441906180", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n          \n          \n            \n                        DatagramPacket sendPacket = createPackRequest(0,\n          \n          \n            \n                                new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));\n          \n          \n            \n                        String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n          \n          \n            \n                        DatagramPacket sendPacket = createPackRequest(0, encryptedStatusReqPacket);", "author": "cpmeister", "createdAt": "2020-06-18T00:38:42Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,530 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Gson gson = new Gson();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(GREE_PROP_POWER);\n+            columns.add(GREE_PROP_MODE);\n+            columns.add(GREE_PROP_SETTEMP);\n+            columns.add(GREE_PROP_WINDSPEED);\n+            columns.add(GREE_PROP_AIR);\n+            columns.add(GREE_PROP_DRY);\n+            columns.add(GREE_PROP_HEALTH);\n+            columns.add(GREE_PROP_SLEEP);\n+            columns.add(GREE_PROP_LIGHT);\n+            columns.add(GREE_PROP_SWINGLEFTRIGHT);\n+            columns.add(GREE_PROP_SWINGUPDOWN);\n+            columns.add(GREE_PROP_QUIET);\n+            columns.add(GREE_PROP_TURBO);\n+            columns.add(GREE_PROP_TEMPUNIT);\n+            columns.add(GREE_PROP_HEAT);\n+            columns.add(GREE_PROP_HEATCOOL);\n+            columns.add(GREE_PROP_TEMPREC);\n+            columns.add(GREE_PROP_PWR_SAVING);\n+            columns.add(GREE_PROP_NOISESET);\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = GREE_CMDT_STATUS;\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Encrypt and send the Status Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));", "originalCommit": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzExNzEwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443117109", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-20T09:36:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwNjE4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwNjM3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441906372", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        DatagramPacket sendPacket = createPackRequest(1,\n          \n          \n            \n                                new String(encryptedBindReqPacket.getBytes(), StandardCharsets.UTF_8));\n          \n          \n            \n                        DatagramPacket sendPacket = createPackRequest(1, encryptedBindReqPacket);", "author": "cpmeister", "createdAt": "2020-06-18T00:39:34Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,530 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Gson gson = new Gson();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(GREE_PROP_POWER);\n+            columns.add(GREE_PROP_MODE);\n+            columns.add(GREE_PROP_SETTEMP);\n+            columns.add(GREE_PROP_WINDSPEED);\n+            columns.add(GREE_PROP_AIR);\n+            columns.add(GREE_PROP_DRY);\n+            columns.add(GREE_PROP_HEALTH);\n+            columns.add(GREE_PROP_SLEEP);\n+            columns.add(GREE_PROP_LIGHT);\n+            columns.add(GREE_PROP_SWINGLEFTRIGHT);\n+            columns.add(GREE_PROP_SWINGUPDOWN);\n+            columns.add(GREE_PROP_QUIET);\n+            columns.add(GREE_PROP_TURBO);\n+            columns.add(GREE_PROP_TEMPUNIT);\n+            columns.add(GREE_PROP_HEAT);\n+            columns.add(GREE_PROP_HEATCOOL);\n+            columns.add(GREE_PROP_TEMPREC);\n+            columns.add(GREE_PROP_PWR_SAVING);\n+            columns.add(GREE_PROP_NOISESET);\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = GREE_CMDT_STATUS;\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Encrypt and send the Status Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            JsonReader receivedData = receiveResponse(clientSocket);\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson.isPresent() && statusResponseGson.get().packJson != null) {\n+                prevStatusResponsePackGson = Optional\n+                        .of(new GreeStatusResponsePackDTO(statusResponseGson.get().packJson));\n+            }\n+\n+            // Read the response, create the JSON to hold the response values\n+            GreeStatusResponseDTO resp = gson.fromJson(receivedData, GreeStatusResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(), resp.pack);\n+            logger.debug(\"Response from device: {}\", resp.decryptedPack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeStatusResponsePackDTO.class);\n+\n+            // save the results\n+            statusResponseGson = Optional.of(resp);\n+            updateTempFtoC();\n+        } catch (IOException e) {\n+            throw new GreeException(\"I/O exception while receiving data\", e);\n+        } catch (RuntimeException e) {\n+            String json = statusResponseGson.map(r -> r.packJson.toString()).orElse(\"n/a\");\n+            throw new GreeException(\"Exception while receiving data, JSON=\" + json, e);\n+        }\n+    }\n+\n+    public void bindWithDevice(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPackDTO bindReqPackGson = new GreeBindRequestPackDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = GREE_CMDT_BIND;\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Encrypt and send the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+            DatagramPacket sendPacket = createPackRequest(1,\n+                    new String(encryptedBindReqPacket.getBytes(), StandardCharsets.UTF_8));", "originalCommit": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzExNzExNw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443117117", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-20T09:36:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwNjM3Mg=="}], "type": "inlineReview"}, {"oid": "a46683468d9c5bd20ec602c68e8f06f809522c77", "url": "https://github.com/openhab/openhab-addons/commit/a46683468d9c5bd20ec602c68e8f06f809522c77", "message": "review changes, ONLINE/OFFLINE handling, missing localized messages\nadded for logging/thing status, some minor issues fixed\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-20T09:34:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyNjkyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443326921", "bodyText": "remove these comments", "author": "cpmeister", "createdAt": "2020-06-22T05:40:53Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeBindingConstants.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link GreeBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeBindingConstants {\n+\n+    public static final String BINDING_ID = \"gree\";\n+\n+    public static final ThingTypeUID THING_TYPE_GREEAIRCON = new ThingTypeUID(BINDING_ID, \"airconditioner\");\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_GREEAIRCON);\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID GREE_THING_TYPE = new ThingTypeUID(BINDING_ID, \"airconditioner\");\n+\n+    // Thing configuration items\n+    public static final String PROPERTY_IP = \"ipAddress\";\n+    public static final String PROPERTY_BROADCAST = \"broadcastAddress\";\n+\n+    // List of all Channel ids\n+    public static final String POWER_CHANNEL = \"power\";\n+    public static final String MODE_CHANNEL = \"mode\";\n+    public static final String TURBO_CHANNEL = \"turbo\";\n+    public static final String LIGHT_CHANNEL = \"light\";\n+    public static final String TEMP_CHANNEL = \"temperature\";\n+    public static final String SWINGUD_CHANNEL = \"swingUpDown\";\n+    public static final String SWINGLR_CHANNEL = \"swingLeftRight\";\n+    public static final String WINDSPEED_CHANNEL = \"windspeed\";\n+    public static final String QUIET_CHANNEL = \"quiet\";\n+    public static final String AIR_CHANNEL = \"air\";\n+    public static final String DRY_CHANNEL = \"dry\";\n+    public static final String HEALTH_CHANNEL = \"health\";\n+    public static final String PWRSAV_CHANNEL = \"powersave\";\n+\n+    // Mode channel\n+    public static final String MODE_AUTO = \"auto\";\n+    public static final String MODE_COOL = \"cool\";\n+    public static final String MODE_DRY = \"dry\";\n+    public static final String MODE_FAN = \"fan\";\n+    public static final String MODE_FAN2 = \"fan-only\";\n+    public static final String MODE_HEAT = \"heat\";\n+    public static final String MODE_ECO = \"eco\";\n+    public static final String MODE_ON = \"on\";\n+    public static final String MODE_OFF = \"off\";\n+    public static final int GREE_MODE_AUTO = 0;\n+    public static final int GREE_MODE_COOL = 1;\n+    public static final int GREE_MODE_DRY = 2;\n+    public static final int GREE_MODE_FAN = 3;\n+    public static final int GREE_MODE_HEAT = 4;\n+\n+    // Quiet channel\n+    public static final String QUIET_OFF = \"off\";\n+    public static final String QUIET_AUTO = \"auto\";\n+    public static final String QUIET_QUIET = \"quiet\";\n+    public static final int GREE_QUIET_OFF = 0;\n+    public static final int GREE_QUIET_AUTO = 1;\n+    public static final int GREE_QUIET_QUIET = 2;\n+\n+    // UDPPort used to communicate using UDP with GREE Airconditioners. .\n+    public static final String VENDOR_GREE = \"gree\";\n+    public static final int GREE_PORT = 7000;\n+\n+    public static final String GREE_CID = \"app\";\n+    public static final String GREE_CMDT_BIND = \"bind\";\n+    public static final String GREE_CMDT_SCAN = \"scan\";\n+    public static final String GREE_CMDT_STATUS = \"status\";\n+    public static final String GREE_CMDT_CMD = \"cmd\";\n+    public static final String GREE_CMDT_PACK = \"pack\";\n+\n+    public static final String GREE_CMD_OPT_NAME = \"name\"; // unit name\n+    public static final String GREE_CMD_OPT_HOST = \"host\"; // remote host (cloud)\n+\n+    /*\n+     * Note : Values can be:\n+     * \"Pow\": Power (0 or 1)\n+     * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+     * \"SetTem\": Requested Temperature\n+     * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+     * \"Air\": Air Mode Enabled\n+     * \"Blo\": Dry\n+     * \"Health\": Health\n+     * \"SwhSlp\": Sleep\n+     * \"SlpMod\": ???\n+     * \"Lig\": Light On\n+     * \"SwingLfRig\": Swing Left Right\n+     * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+     * \"Quiet\": Quiet mode\n+     * \"Tur\": Turbo\n+     * \"StHt\": 0,\n+     * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+     * \"HeatCoolType\"\n+     * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+     * temp\n+     * \"SvSt\": Power Saving\n+     */\n+    public static final String GREE_PROP_POWER = \"Pow\";\n+    public static final String GREE_PROP_MODE = \"Mod\";\n+    public static final String GREE_PROP_SWINGUPDOWN = \"SwUpDn\";\n+    public static final String GREE_PROP_SWINGLEFTRIGHT = \"SwingLfRig\";\n+    public static final String GREE_PROP_WINDSPEED = \"WdSpd\";\n+    public static final String GREE_PROP_AIR = \"Air\";\n+    public static final String GREE_PROP_DRY = \"Blo\";\n+    public static final String GREE_PROP_TURBO = \"Tur\";\n+    public static final String GREE_PROP_QUIET = \"Quiet\";\n+    public static final String GREE_PROP_NOISE = \"NoiseSet\";\n+    public static final String GREE_PROP_LIGHT = \"Lig\";\n+    public static final String GREE_PROP_HEALTH = \"Health\";\n+    public static final String GREE_PROP_SLEEP = \"SwhSlp\";\n+    public static final String GREE_PROP_SLEEPMODE = \"SlpMod\";\n+    public static final String GREE_PROP_PWR_SAVING = \"SvSt\";\n+    public static final String GREE_PROP_SETTEMP = \"SetTem\";\n+    public static final String GREE_PROP_TEMPUNIT = \"TemUn\";\n+    public static final String GREE_PROP_TEMPREC = \"TemRec\";\n+    public static final String GREE_PROP_HEAT = \"StHt\";\n+    public static final String GREE_PROP_HEATCOOL = \"HeatCoolType\";\n+    public static final String GREE_PROP_NOISESET = \"NoiseSet\";\n+\n+    // Temperatur types and min/max ranges\n+    public static final int TEMP_UNIT_CELSIUS = 0;\n+    public static final int TEMP_UNIT_FAHRENHEIT = 1;\n+    public static final int TEMP_MIN_C = 16;\n+    public static final int TEMP_MAX_C = 30;\n+    public static final int TEMP_MIN_F = 61;\n+    public static final int TEMP_MAX_F = 86;\n+    public static final int TEMP_HALFSTEP_NO = 0;\n+    public static final int TEMP_HALFSTEP_YES = 1;\n+\n+    // parameters.put(\"SvSt\", value);\n+    // parameters.put(\"SwhSlp\", 0);\n+    // parameters.put(\"SlpMod\", 0);", "originalCommit": "a46683468d9c5bd20ec602c68e8f06f809522c77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg2Mjg3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443862875", "bodyText": "done", "author": "markus7017", "createdAt": "2020-06-22T22:36:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyNjkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyNzA0NA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443327044", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static String GetAESGeneralKey() {\n          \n          \n            \n                public static String getAESGeneralKey() {", "author": "cpmeister", "createdAt": "2020-06-22T05:41:28Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeCryptoUtil.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Base64;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The CryptoUtil class provides functionality for encrypting and decrypting\n+ * messages sent to and from the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeCryptoUtil {\n+    private static final String AES_KEY = \"a3K8Bx%2r8Y7#xDh\";\n+\n+    public static String GetAESGeneralKey() {", "originalCommit": "a46683468d9c5bd20ec602c68e8f06f809522c77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg2MzExNA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443863114", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-06-22T22:37:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyNzA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzNTk2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443335960", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n          \n          \n            \n                public void setDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {", "author": "cpmeister", "createdAt": "2020-06-22T06:12:59Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Gson gson = new Gson();\n+    private boolean isBound = false;\n+    private final InetAddress ipAddress;\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public GreeAirDevice() {\n+        ipAddress = InetAddress.getLoopbackAddress();\n+    }\n+\n+    public GreeAirDevice(InetAddress ipAddress, int port, GreeScanResponseDTO scanResponse) {\n+        this.ipAddress = ipAddress;\n+        this.port = port;\n+        this.scanResponseGson = Optional.of(scanResponse);\n+    }\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+\n+        if (!isBound) {\n+            throw new GreeException(\"Device not bound\");\n+        }\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(GREE_PROP_POWER);\n+            columns.add(GREE_PROP_MODE);\n+            columns.add(GREE_PROP_SETTEMP);\n+            columns.add(GREE_PROP_WINDSPEED);\n+            columns.add(GREE_PROP_AIR);\n+            columns.add(GREE_PROP_DRY);\n+            columns.add(GREE_PROP_HEALTH);\n+            columns.add(GREE_PROP_SLEEP);\n+            columns.add(GREE_PROP_LIGHT);\n+            columns.add(GREE_PROP_SWINGLEFTRIGHT);\n+            columns.add(GREE_PROP_SWINGUPDOWN);\n+            columns.add(GREE_PROP_QUIET);\n+            columns.add(GREE_PROP_TURBO);\n+            columns.add(GREE_PROP_TEMPUNIT);\n+            columns.add(GREE_PROP_HEAT);\n+            columns.add(GREE_PROP_HEATCOOL);\n+            columns.add(GREE_PROP_TEMPREC);\n+            columns.add(GREE_PROP_PWR_SAVING);\n+            columns.add(GREE_PROP_NOISESET);\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = GREE_CMDT_STATUS;\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Encrypt and send the Status Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey(), reqStatusPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson.isPresent() && statusResponseGson.get().packJson != null) {\n+                prevStatusResponsePackGson = Optional\n+                        .of(new GreeStatusResponsePackDTO(statusResponseGson.get().packJson));\n+            }\n+\n+            // Read the response, create the JSON to hold the response values\n+            GreeStatusResponseDTO resp = receiveResponse(clientSocket, GreeStatusResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(getKey(), resp.pack);\n+            logger.debug(\"Response from device: {}\", resp.decryptedPack);\n+            resp.packJson = gson.fromJson(resp.decryptedPack, GreeStatusResponsePackDTO.class);\n+\n+            // save the results\n+            statusResponseGson = Optional.of(resp);\n+            updateTempFtoC();\n+        } catch (IOException | JsonSyntaxException e) {\n+            throw new GreeException(\"I/O exception while updating status\", e);\n+        } catch (RuntimeException e) {\n+            logger.debug(\"Exception\", e);\n+            String json = statusResponseGson.map(r -> r.packJson.toString()).orElse(\"n/a\");\n+            throw new GreeException(\"Exception while updating status, JSON=\" + json, e);\n+        }\n+    }\n+\n+    public void bindWithDevice(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPackDTO bindReqPackGson = new GreeBindRequestPackDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = GREE_CMDT_BIND;\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Encrypt and send the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+            DatagramPacket sendPacket = createPackRequest(1, encryptedBindReqPacket);\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response, create the JSON to hold the response values\n+            GreeBindResponseDTO resp = receiveResponse(clientSocket, GreeBindResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), resp.pack);\n+            resp.packJson = gson.fromJson(resp.decryptedPack, GreeBindResponsePackDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = resp.packJson.key;\n+\n+            // save the outcome\n+            isBound = true;\n+        } catch (IOException | JsonSyntaxException e) {\n+            throw new GreeException(\"Unable to bind to device\", e);\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_POWER, value);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {", "originalCommit": "a46683468d9c5bd20ec602c68e8f06f809522c77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg2MzQwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443863403", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-22T22:38:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzNTk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzNjE3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443336176", "bodyText": "please specify the charset", "author": "cpmeister", "createdAt": "2020-06-22T06:13:50Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Gson gson = new Gson();\n+    private boolean isBound = false;\n+    private final InetAddress ipAddress;\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public GreeAirDevice() {\n+        ipAddress = InetAddress.getLoopbackAddress();\n+    }\n+\n+    public GreeAirDevice(InetAddress ipAddress, int port, GreeScanResponseDTO scanResponse) {\n+        this.ipAddress = ipAddress;\n+        this.port = port;\n+        this.scanResponseGson = Optional.of(scanResponse);\n+    }\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+\n+        if (!isBound) {\n+            throw new GreeException(\"Device not bound\");\n+        }\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(GREE_PROP_POWER);\n+            columns.add(GREE_PROP_MODE);\n+            columns.add(GREE_PROP_SETTEMP);\n+            columns.add(GREE_PROP_WINDSPEED);\n+            columns.add(GREE_PROP_AIR);\n+            columns.add(GREE_PROP_DRY);\n+            columns.add(GREE_PROP_HEALTH);\n+            columns.add(GREE_PROP_SLEEP);\n+            columns.add(GREE_PROP_LIGHT);\n+            columns.add(GREE_PROP_SWINGLEFTRIGHT);\n+            columns.add(GREE_PROP_SWINGUPDOWN);\n+            columns.add(GREE_PROP_QUIET);\n+            columns.add(GREE_PROP_TURBO);\n+            columns.add(GREE_PROP_TEMPUNIT);\n+            columns.add(GREE_PROP_HEAT);\n+            columns.add(GREE_PROP_HEATCOOL);\n+            columns.add(GREE_PROP_TEMPREC);\n+            columns.add(GREE_PROP_PWR_SAVING);\n+            columns.add(GREE_PROP_NOISESET);\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = GREE_CMDT_STATUS;\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Encrypt and send the Status Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey(), reqStatusPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson.isPresent() && statusResponseGson.get().packJson != null) {\n+                prevStatusResponsePackGson = Optional\n+                        .of(new GreeStatusResponsePackDTO(statusResponseGson.get().packJson));\n+            }\n+\n+            // Read the response, create the JSON to hold the response values\n+            GreeStatusResponseDTO resp = receiveResponse(clientSocket, GreeStatusResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(getKey(), resp.pack);\n+            logger.debug(\"Response from device: {}\", resp.decryptedPack);\n+            resp.packJson = gson.fromJson(resp.decryptedPack, GreeStatusResponsePackDTO.class);\n+\n+            // save the results\n+            statusResponseGson = Optional.of(resp);\n+            updateTempFtoC();\n+        } catch (IOException | JsonSyntaxException e) {\n+            throw new GreeException(\"I/O exception while updating status\", e);\n+        } catch (RuntimeException e) {\n+            logger.debug(\"Exception\", e);\n+            String json = statusResponseGson.map(r -> r.packJson.toString()).orElse(\"n/a\");\n+            throw new GreeException(\"Exception while updating status, JSON=\" + json, e);\n+        }\n+    }\n+\n+    public void bindWithDevice(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPackDTO bindReqPackGson = new GreeBindRequestPackDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = GREE_CMDT_BIND;\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Encrypt and send the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+            DatagramPacket sendPacket = createPackRequest(1, encryptedBindReqPacket);\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response, create the JSON to hold the response values\n+            GreeBindResponseDTO resp = receiveResponse(clientSocket, GreeBindResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), resp.pack);\n+            resp.packJson = gson.fromJson(resp.decryptedPack, GreeBindResponsePackDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = resp.packJson.key;\n+\n+            // save the outcome\n+            isBound = true;\n+        } catch (IOException | JsonSyntaxException e) {\n+            throw new GreeException(\"Unable to bind to device\", e);\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_POWER, value);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        if ((value < 0 || value > 4)) {\n+            throw new GreeException(\"Device mode out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_MODE, value);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if ((value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"SwingUpDown value out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_SWINGUPDOWN, value);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_SWINGLEFTRIGHT, value, 0, 6);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (value < 0 || value > 5) {\n+            throw new GreeException(\"Value out of range!\");\n+        }\n+\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_WINDSPEED, value);\n+        parameters.put(GREE_PROP_QUIET, 0);\n+        parameters.put(GREE_PROP_TURBO, 0);\n+        parameters.put(GREE_PROP_NOISE, 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_TURBO, value, 0, 1);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_QUIET, value, 0, 2);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(GREE_PROP_TURBO);\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_LIGHT, value);\n+    }\n+\n+    /**\n+     * @param value set temperature in degrees Celsius or Fahrenheit\n+     */\n+    public void setDeviceTempSet(DatagramSocket clientSocket, QuantityType<?> temp) throws GreeException {\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        double newVal = temp.doubleValue();\n+        int CorF = temp.getUnit() == SIUnits.CELSIUS ? TEMP_UNIT_CELSIUS : TEMP_UNIT_FAHRENHEIT; // 0=Celsius,\n+                                                                                                 // 1=Fahrenheit\n+        if (((CorF == TEMP_UNIT_CELSIUS) && (newVal < TEMP_MIN_C || newVal > TEMP_MAX_C))\n+                || ((CorF == TEMP_UNIT_FAHRENHEIT) && (newVal < TEMP_MIN_F || newVal > TEMP_MAX_F))) {\n+            throw new IllegalArgumentException(\"Temp Value out of Range\");\n+        }\n+\n+        // Default for Celsius\n+        int outVal = (int) newVal;\n+        int halfStep = TEMP_HALFSTEP_NO; // for whatever reason halfStep is not supported for Celsius\n+\n+        // If value argument is degrees F, convert Fahrenheit to Celsius,\n+        // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+        // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+        // F = [68...86]\n+        // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+        // 28.8, 29.4, 30.0]\n+        //\n+        // TemSet = [20..30] or [68..86]\n+        // TemRec = value - (value) > 0 ? 1 : 1 -> when xx.5 is request xx will become TemSet and halfStep the indicator\n+        // for \"half on top of TemSet\"\n+        // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+        // subtract the float version - the int version to get the fractional difference\n+        // if the difference is positive set halfStep to 1, negative to 0\n+        if (CorF == TEMP_UNIT_FAHRENHEIT) { // If Fahrenheit,\n+            halfStep = newVal - outVal > 0 ? TEMP_HALFSTEP_YES : TEMP_HALFSTEP_NO;\n+        }\n+        logger.debug(\"Converted temp from {}{} to temp={}, halfStep={}, unit={})\", newVal, temp.getUnit(), outVal,\n+                halfStep, CorF == TEMP_UNIT_CELSIUS ? \"C\" : \"F\");\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_TEMPUNIT, CorF);\n+        parameters.put(GREE_PROP_SETTEMP, outVal);\n+        parameters.put(GREE_PROP_TEMPREC, halfStep);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_AIR, value);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_DRY, value);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_HEALTH, value);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_PWR_SAVING, value);\n+        parameters.put(GREE_PROP_WINDSPEED, 0);\n+        parameters.put(GREE_PROP_QUIET, 0);\n+        parameters.put(GREE_PROP_TURBO, 0);\n+        parameters.put(GREE_PROP_SLEEP, 0);\n+        parameters.put(GREE_PROP_SLEEPMODE, 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        if (isStatusAvailable()) {\n+            List<String> colList = Arrays.asList(statusResponseGson.get().packJson.cols);\n+            List<Integer> valList = Arrays.asList(statusResponseGson.get().packJson.dat);\n+            int valueArrayposition = colList.indexOf(valueName);\n+            if (valueArrayposition != -1) {\n+                // get the Corresponding value\n+                Integer value = valList.get(valueArrayposition);\n+                return value;\n+            }\n+        }\n+\n+        return -1;\n+    }\n+\n+    public boolean isStatusAvailable() {\n+        return statusResponseGson.isPresent();\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (!prevStatusResponsePackGson.isPresent()) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        List<String> currcolList = Arrays.asList(statusResponseGson.get().packJson.cols);\n+        List<Integer> currvalList = Arrays.asList(statusResponseGson.get().packJson.dat);\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\n+        if (currvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to decode device status\");\n+        }\n+\n+        // Find the valueName in the Previous Status object\n+        List<String> prevcolList = Arrays.asList(prevStatusResponsePackGson.get().cols);\n+        List<Integer> prevvalList = Arrays.asList(prevStatusResponsePackGson.get().dat);\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\n+        if (prevvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to get status value\");\n+        }\n+\n+        // Finally Compare the values\n+        return currvalList.get(currvalueArrayposition) != prevvalList.get(prevvalueArrayposition);\n+    }\n+\n+    protected void executeCommand(DatagramSocket clientSocket, Map<String, Integer> parameters) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        try {\n+            // Convert the parameter map values to arrays\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\n+\n+            // Prep the Command Request pack\n+            GreeExecuteCommandPackDTO execCmdPackGson = new GreeExecuteCommandPackDTO();\n+            execCmdPackGson.opt = keyArray;\n+            execCmdPackGson.p = valueArray;\n+            execCmdPackGson.t = GREE_CMDT_CMD;\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\n+\n+            // Now encrypt and send the Command Request pack\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey(), execCmdPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0, encryptedCommandReqPacket);\n+            clientSocket.send(sendPacket);\n+\n+            // Receive and decode result\n+            GreeExecResponseDTO execResponseGson = receiveResponse(clientSocket, GreeExecResponseDTO.class);\n+            execResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(getKey(), execResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            execResponseGson.packJson = gson.fromJson(execResponseGson.decryptedPack, GreeExecResponsePackDTO.class);\n+        } catch (IOException | JsonSyntaxException e) {\n+            throw new GreeException(\"Exception on command execution\", e);\n+        }\n+    }\n+\n+    private void setCommandValue(DatagramSocket clientSocket, String command, int value) throws GreeException {\n+        executeCommand(clientSocket, Collections.singletonMap(command, value));\n+    }\n+\n+    private void setCommandValue(DatagramSocket clientSocket, String command, int value, int min, int max)\n+            throws GreeException {\n+        if ((value < min) || (value > max)) {\n+            throw new GreeException(\"Command value out of range!\");\n+        }\n+        executeCommand(clientSocket, Collections.singletonMap(command, value));\n+    }\n+\n+    private DatagramPacket createPackRequest(int i, String pack) {\n+        GreeRequestDTO request = new GreeRequestDTO();\n+        request.cid = GREE_CID;\n+        request.i = i;\n+        request.t = GREE_CMDT_PACK;\n+        request.uid = 0;\n+        request.tcid = getId();\n+        request.pack = pack;\n+        byte[] sendData = gson.toJson(request).getBytes();", "originalCommit": "a46683468d9c5bd20ec602c68e8f06f809522c77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg2MzcwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443863701", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-22T22:38:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzNjE3Ng=="}], "type": "inlineReview"}, {"oid": "5c171d858e3aa58b6de4206ed8ea96ebcc3514bb", "url": "https://github.com/openhab/openhab-addons/commit/5c171d858e3aa58b6de4206ed8ea96ebcc3514bb", "message": "review changes\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-22T22:40:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ3NTMxMA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r444475310", "bodyText": "This is populated in the constructor so you can make it final.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n          \n          \n            \n                private final GreeDeviceFinder deviceFinder;", "author": "cpmeister", "createdAt": "2020-06-23T20:04:19Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();", "originalCommit": "5c171d858e3aa58b6de4206ed8ea96ebcc3514bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5MTg0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r445191848", "bodyText": "done", "author": "markus7017", "createdAt": "2020-06-24T21:50:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ3NTMxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxMjI2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r444512260", "bodyText": "Thing labels can be changed at runtime, so you should either retrieve the label at runtime at the time when you need to use it, or you should just stick to the thing uid that doesn't change.", "author": "cpmeister", "createdAt": "2020-06-23T21:13:46Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+    private final String thingId;\n+    private boolean forceRefresh = false;\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages, GreeDeviceFinder deviceFinder) {\n+        super(thing);\n+        this.messages = messages;\n+        this.deviceFinder = deviceFinder;\n+        String label = getThing().getLabel();\n+        this.thingId = label != null ? label : getThing().getUID().getId();", "originalCommit": "5c171d858e3aa58b6de4206ed8ea96ebcc3514bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5MjMyMg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r445192322", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-24T21:51:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxMjI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxNTkxMA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r444515910", "bodyText": "Please move final fields above non-final fields.", "author": "cpmeister", "createdAt": "2020-06-23T21:21:42Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+    private final String thingId;", "originalCommit": "5c171d858e3aa58b6de4206ed8ea96ebcc3514bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5MzUxMA==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r445193510", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-24T21:54:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxNTkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxNjQxMg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r444516412", "bodyText": "You can safely remove synchronization here.", "author": "cpmeister", "createdAt": "2020-06-23T21:22:42Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+    private final String thingId;\n+    private boolean forceRefresh = false;\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages, GreeDeviceFinder deviceFinder) {\n+        super(thing);\n+        this.messages = messages;\n+        this.deviceFinder = deviceFinder;\n+        String label = getThing().getLabel();\n+        this.thingId = label != null ? label : getThing().getUID().getId();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            String message = messages.get(\"thinginit.invconf\");\n+            logger.warn(\"{}: {}\", thingId, message);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, message);\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Start the automatic refresh cycles\n+        startAutomaticRefresh();\n+        scheduler.execute(this::initializeThing);\n+    }\n+\n+    private void initializeThing() {\n+        String message = \"\";\n+        try {\n+            if (!clientSocket.isPresent()) {\n+                clientSocket = Optional.of(new DatagramSocket());\n+                clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+            }\n+            // Find the GREE device\n+            deviceFinder.scan(clientSocket.get(), config.ipAddress, false);\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket.get());\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    return;\n+                }\n+            }\n+\n+            message = messages.get(\"thinginit.failed\");\n+            logger.info(\"{}: {}\", thingId, message);\n+        } catch (GreeException e) {\n+            logger.info(\"{}: {}\", thingId, messages.get(\"thinginit.exception\", e.getMessage()));\n+        } catch (IOException e) {\n+            logger.warn(\"{}: {}\", thingId, messages.get(\"thinginit.exception\", \"I/O Error\"), e);\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: {}\", thingId, messages.get(\"thinginit.exception\", \"RuntimeException\"), e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            logger.debug(\"{}: Issue command {}\u00a0to channe {}\", thingId, command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"{}: Handle command {} for channel {}, command class {}\", thingId, command, channelId,\n+                    command.getClass());\n+            try {\n+                DatagramSocket socket = clientSocket.get();\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(socket, command);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        // Set value, read back effective one and update channel\n+                        // e.g. 22.5C will result in 22.0, because the AC doesn't support half-steps for C\n+                        device.setDeviceTempSet(socket, convertTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(socket, command);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+\n+                // force refresh on next status refresh cycle\n+                forceRefresh = true;\n+            } catch (GreeException e) {\n+                String message = logInfo(\"command.exception\", command, channelId) + \": \" + e.getMessage();\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+            } catch (IllegalArgumentException e) {\n+                logInfo(\"command.invarg\", command, channelId);\n+            } catch (RuntimeException e) {\n+                logger.warn(\"{}: {}\", thingId, messages.get(\"command.exception\", command, channelId), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"{}: Send Power-{}\", thingId, command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    logger.debug(\"{}: Turn unit {}\", thingId, modeStr);\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    return;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"{}: Mode {} mapped to {}\", thingId, modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(GREE_PROP_POWER) == 0)) {\n+            logger.debug(\"{}: Send Auto-ON for mode {}\", thingId, mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"{}: Select mode {}\", thingId, mode);\n+        device.setDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"{}: Turn on Power-Saving\", thingId);\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid QuietType\");\n+        }\n+    }\n+\n+    private int getOnOff(Command command) {\n+        if (command instanceof OnOffType) {\n+            return command == OnOffType.ON ? 1 : 0;\n+        }\n+        if (command instanceof DecimalType) {\n+            int value = ((DecimalType) command).intValue();\n+            if ((value == 0) || (value == 1)) {\n+                return value;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Invalid OnOffType\");\n+    }\n+\n+    private int getNumber(Command command) {\n+        if (command instanceof DecimalType) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalid Number type\");\n+    }\n+\n+    private QuantityType<?> convertTemp(Command command) {\n+        if (command instanceof DecimalType) {\n+            // The Number alone doesn't specify the temp unit\n+            // for this get current setting from the A/C unit\n+            int unit = device.getIntStatusVal(GREE_PROP_TEMPUNIT);\n+            return toQuantityType((DecimalType) command, DIGITS_TEMP,\n+                    unit == TEMP_UNIT_CELSIUS ? SIUnits.CELSIUS : ImperialUnits.FAHRENHEIT);\n+        }\n+        if (command instanceof QuantityType) {\n+            return (QuantityType<?>) command;\n+        }\n+        throw new IllegalArgumentException(\"Invalud Temp type\");\n+    }\n+\n+    private void startAutomaticRefresh() {\n+        Runnable refresher = () -> {\n+            try {\n+                // safeguard for multiple REFRESH commands\n+                if (isMinimumRefreshTimeExceeded()) {\n+                    // Get the current status from the Airconditioner\n+\n+                    if (getThing().getStatus() == ThingStatus.OFFLINE) {\n+                        initializeThing();\n+                        return;\n+                    }\n+\n+                    if (clientSocket.isPresent()) {\n+                        device.getDeviceStatus(clientSocket.get());\n+                        logger.debug(\"{}: Executing automatic update of values\", thingId);\n+                        List<Channel> channels = getThing().getChannels();\n+                        for (Channel channel : channels) {\n+                            publishChannel(channel.getUID());\n+                        }\n+                    }\n+                }\n+            } catch (GreeException e) {\n+                String subcode = \"\";\n+                if (e.getCause() != null) {\n+                    subcode = \" (\" + e.getCause().getMessage() + \")\";\n+                }\n+                String message = messages.get(\"update.exception\", e.getMessage() + subcode);\n+                if (getThing().getStatus() == ThingStatus.OFFLINE) {\n+                    logger.debug(\"{}: Thing still OFFLINE ({})\", thingId, message);\n+                } else {\n+                    if (!e.isTimeout()) {\n+                        logger.info(\"{}: {}\", thingId, message);\n+                    } else {\n+                        logger.debug(\"{}: {}\", thingId, message);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+                }\n+            } catch (RuntimeException e) {\n+                String message = messages.get(\"update.exception\", \"RuntimeException\");\n+                logger.warn(\"{}: {}\", thingId, message, e);\n+            }\n+        };\n+\n+        if (refreshTask == null) {\n+            refreshTask = scheduler.scheduleWithFixedDelay(refresher, 0, REFRESH_INTERVAL_SEC, TimeUnit.SECONDS);\n+            logger.debug(\"{}: Automatic refresh started ({} second interval)\", thingId, config.refresh);\n+        }\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = Instant.now().toEpochMilli();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (!forceRefresh && (timeSinceLastRefresh < config.refresh * 1000)) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void publishChannel(ChannelUID channelUID) {\n+        String channelID = channelUID.getId();\n+        try {\n+            State state = null;\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case POWER_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_POWER);\n+                    break;\n+                case MODE_CHANNEL:\n+                    state = updateMode();\n+                    break;\n+                case TURBO_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_TURBO);\n+                    break;\n+                case LIGHT_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_LIGHT);\n+                    break;\n+                case TEMP_CHANNEL:\n+                    state = updateTemp();\n+                    break;\n+                case SWINGUD_CHANNEL:\n+                    state = updateNumber(GREE_PROP_SWINGUPDOWN);\n+                    break;\n+                case SWINGLR_CHANNEL:\n+                    state = updateNumber(GREE_PROP_SWINGLEFTRIGHT);\n+                    break;\n+                case WINDSPEED_CHANNEL:\n+                    state = updateNumber(GREE_PROP_WINDSPEED);\n+                    break;\n+                case QUIET_CHANNEL:\n+                    state = updateQuiet();\n+                    break;\n+                case AIR_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_AIR);\n+                    break;\n+                case DRY_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_DRY);\n+                    break;\n+                case HEALTH_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_HEALTH);\n+                    break;\n+                case PWRSAV_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_PWR_SAVING);\n+                    break;\n+            }\n+            if (state != null) {\n+                logger.debug(\"{}: Updating channel {} : {}\", thingId, channelID, state);\n+                updateState(channelID, state);\n+            }\n+        } catch (GreeException e) {\n+            logger.info(\"{}: {}\", thingId, messages.get(\"channel.exception\", channelID, e.getMessage()));\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: {}\", thingId, messages.get(\"channel.exception\", \"RuntimeException\"), e);\n+        }\n+    }\n+\n+    private @Nullable State updateOnOff(final String valueName) throws GreeException {\n+        if (device.hasStatusValChanged(valueName)) {\n+            return device.getIntStatusVal(valueName) == 1 ? OnOffType.ON : OnOffType.OFF;\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateNumber(final String valueName) throws GreeException {\n+        if (device.hasStatusValChanged(valueName)) {\n+            return new DecimalType(device.getIntStatusVal(valueName));\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateMode() throws GreeException {\n+        if (device.hasStatusValChanged(GREE_PROP_MODE)) {\n+            int mode = device.getIntStatusVal(GREE_PROP_MODE);\n+            String modeStr = \"\";\n+            switch (mode) {\n+                case GREE_MODE_AUTO:\n+                    modeStr = MODE_AUTO;\n+                    break;\n+                case GREE_MODE_COOL:\n+                    boolean powerSave = device.getIntStatusVal(GREE_PROP_PWR_SAVING) == 1;\n+                    modeStr = !powerSave ? MODE_COOL : MODE_ECO;\n+                    break;\n+                case GREE_MODE_DRY:\n+                    modeStr = MODE_DRY;\n+                    break;\n+                case GREE_MODE_FAN:\n+                    modeStr = MODE_FAN;\n+                    break;\n+                case GREE_MODE_HEAT:\n+                    modeStr = MODE_HEAT;\n+                    break;\n+                default:\n+                    modeStr = String.valueOf(mode);\n+\n+            }\n+            if (!modeStr.isEmpty()) {\n+                logger.debug(\"{}: Updading mode channel with {}/{}\", thingId, mode, modeStr);\n+                return new StringType(modeStr);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateQuiet() throws GreeException {\n+        if (device.hasStatusValChanged(GREE_PROP_QUIET)) {\n+            switch (device.getIntStatusVal(GREE_PROP_QUIET)) {\n+                case GREE_QUIET_OFF:\n+                    return new StringType(QUIET_OFF);\n+                case GREE_QUIET_AUTO:\n+                    return new StringType(QUIET_AUTO);\n+                case GREE_QUIET_QUIET:\n+                    return new StringType(QUIET_QUIET);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateTemp() throws GreeException {\n+        if (device.hasStatusValChanged(GREE_PROP_SETTEMP) || device.hasStatusValChanged(GREE_PROP_TEMPUNIT)) {\n+            int unit = device.getIntStatusVal(GREE_PROP_TEMPUNIT);\n+            return toQuantityType(device.getIntStatusVal(GREE_PROP_SETTEMP), DIGITS_TEMP,\n+                    unit == TEMP_UNIT_CELSIUS ? SIUnits.CELSIUS : ImperialUnits.FAHRENHEIT);\n+        }\n+        return null;\n+    }\n+\n+    private String logInfo(String msgKey, Object... arg) {\n+        String message = messages.get(msgKey, arg);\n+        logger.info(\"{}: {}\", thingId, message);\n+        return message;\n+    }\n+\n+    public static QuantityType<?> toQuantityType(Number value, int digits, Unit<?> unit) {\n+        BigDecimal bd = new BigDecimal(value.doubleValue());\n+        return new QuantityType<>(bd.setScale(digits, BigDecimal.ROUND_HALF_EVEN), unit);\n+    }\n+\n+    private void stopRefrestTask() {\n+        forceRefresh = false;\n+        if (refreshTask == null) {\n+            return;\n+        }\n+        synchronized (refreshTask) {", "originalCommit": "5c171d858e3aa58b6de4206ed8ea96ebcc3514bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5MzQ1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r445193457", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-24T21:53:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxNjQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxNjYzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r444516636", "bodyText": "No harm in cancelling something that is already cancelled.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if ((task != null) && !task.isCancelled()) {\n          \n          \n            \n                        if (task != null) {", "author": "cpmeister", "createdAt": "2020-06-23T21:23:11Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+    private final String thingId;\n+    private boolean forceRefresh = false;\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages, GreeDeviceFinder deviceFinder) {\n+        super(thing);\n+        this.messages = messages;\n+        this.deviceFinder = deviceFinder;\n+        String label = getThing().getLabel();\n+        this.thingId = label != null ? label : getThing().getUID().getId();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            String message = messages.get(\"thinginit.invconf\");\n+            logger.warn(\"{}: {}\", thingId, message);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, message);\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Start the automatic refresh cycles\n+        startAutomaticRefresh();\n+        scheduler.execute(this::initializeThing);\n+    }\n+\n+    private void initializeThing() {\n+        String message = \"\";\n+        try {\n+            if (!clientSocket.isPresent()) {\n+                clientSocket = Optional.of(new DatagramSocket());\n+                clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+            }\n+            // Find the GREE device\n+            deviceFinder.scan(clientSocket.get(), config.ipAddress, false);\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket.get());\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    return;\n+                }\n+            }\n+\n+            message = messages.get(\"thinginit.failed\");\n+            logger.info(\"{}: {}\", thingId, message);\n+        } catch (GreeException e) {\n+            logger.info(\"{}: {}\", thingId, messages.get(\"thinginit.exception\", e.getMessage()));\n+        } catch (IOException e) {\n+            logger.warn(\"{}: {}\", thingId, messages.get(\"thinginit.exception\", \"I/O Error\"), e);\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: {}\", thingId, messages.get(\"thinginit.exception\", \"RuntimeException\"), e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            logger.debug(\"{}: Issue command {}\u00a0to channe {}\", thingId, command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"{}: Handle command {} for channel {}, command class {}\", thingId, command, channelId,\n+                    command.getClass());\n+            try {\n+                DatagramSocket socket = clientSocket.get();\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(socket, command);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        // Set value, read back effective one and update channel\n+                        // e.g. 22.5C will result in 22.0, because the AC doesn't support half-steps for C\n+                        device.setDeviceTempSet(socket, convertTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(socket, command);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+\n+                // force refresh on next status refresh cycle\n+                forceRefresh = true;\n+            } catch (GreeException e) {\n+                String message = logInfo(\"command.exception\", command, channelId) + \": \" + e.getMessage();\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+            } catch (IllegalArgumentException e) {\n+                logInfo(\"command.invarg\", command, channelId);\n+            } catch (RuntimeException e) {\n+                logger.warn(\"{}: {}\", thingId, messages.get(\"command.exception\", command, channelId), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"{}: Send Power-{}\", thingId, command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    logger.debug(\"{}: Turn unit {}\", thingId, modeStr);\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    return;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"{}: Mode {} mapped to {}\", thingId, modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(GREE_PROP_POWER) == 0)) {\n+            logger.debug(\"{}: Send Auto-ON for mode {}\", thingId, mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"{}: Select mode {}\", thingId, mode);\n+        device.setDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"{}: Turn on Power-Saving\", thingId);\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid QuietType\");\n+        }\n+    }\n+\n+    private int getOnOff(Command command) {\n+        if (command instanceof OnOffType) {\n+            return command == OnOffType.ON ? 1 : 0;\n+        }\n+        if (command instanceof DecimalType) {\n+            int value = ((DecimalType) command).intValue();\n+            if ((value == 0) || (value == 1)) {\n+                return value;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Invalid OnOffType\");\n+    }\n+\n+    private int getNumber(Command command) {\n+        if (command instanceof DecimalType) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalid Number type\");\n+    }\n+\n+    private QuantityType<?> convertTemp(Command command) {\n+        if (command instanceof DecimalType) {\n+            // The Number alone doesn't specify the temp unit\n+            // for this get current setting from the A/C unit\n+            int unit = device.getIntStatusVal(GREE_PROP_TEMPUNIT);\n+            return toQuantityType((DecimalType) command, DIGITS_TEMP,\n+                    unit == TEMP_UNIT_CELSIUS ? SIUnits.CELSIUS : ImperialUnits.FAHRENHEIT);\n+        }\n+        if (command instanceof QuantityType) {\n+            return (QuantityType<?>) command;\n+        }\n+        throw new IllegalArgumentException(\"Invalud Temp type\");\n+    }\n+\n+    private void startAutomaticRefresh() {\n+        Runnable refresher = () -> {\n+            try {\n+                // safeguard for multiple REFRESH commands\n+                if (isMinimumRefreshTimeExceeded()) {\n+                    // Get the current status from the Airconditioner\n+\n+                    if (getThing().getStatus() == ThingStatus.OFFLINE) {\n+                        initializeThing();\n+                        return;\n+                    }\n+\n+                    if (clientSocket.isPresent()) {\n+                        device.getDeviceStatus(clientSocket.get());\n+                        logger.debug(\"{}: Executing automatic update of values\", thingId);\n+                        List<Channel> channels = getThing().getChannels();\n+                        for (Channel channel : channels) {\n+                            publishChannel(channel.getUID());\n+                        }\n+                    }\n+                }\n+            } catch (GreeException e) {\n+                String subcode = \"\";\n+                if (e.getCause() != null) {\n+                    subcode = \" (\" + e.getCause().getMessage() + \")\";\n+                }\n+                String message = messages.get(\"update.exception\", e.getMessage() + subcode);\n+                if (getThing().getStatus() == ThingStatus.OFFLINE) {\n+                    logger.debug(\"{}: Thing still OFFLINE ({})\", thingId, message);\n+                } else {\n+                    if (!e.isTimeout()) {\n+                        logger.info(\"{}: {}\", thingId, message);\n+                    } else {\n+                        logger.debug(\"{}: {}\", thingId, message);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+                }\n+            } catch (RuntimeException e) {\n+                String message = messages.get(\"update.exception\", \"RuntimeException\");\n+                logger.warn(\"{}: {}\", thingId, message, e);\n+            }\n+        };\n+\n+        if (refreshTask == null) {\n+            refreshTask = scheduler.scheduleWithFixedDelay(refresher, 0, REFRESH_INTERVAL_SEC, TimeUnit.SECONDS);\n+            logger.debug(\"{}: Automatic refresh started ({} second interval)\", thingId, config.refresh);\n+        }\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = Instant.now().toEpochMilli();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (!forceRefresh && (timeSinceLastRefresh < config.refresh * 1000)) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void publishChannel(ChannelUID channelUID) {\n+        String channelID = channelUID.getId();\n+        try {\n+            State state = null;\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case POWER_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_POWER);\n+                    break;\n+                case MODE_CHANNEL:\n+                    state = updateMode();\n+                    break;\n+                case TURBO_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_TURBO);\n+                    break;\n+                case LIGHT_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_LIGHT);\n+                    break;\n+                case TEMP_CHANNEL:\n+                    state = updateTemp();\n+                    break;\n+                case SWINGUD_CHANNEL:\n+                    state = updateNumber(GREE_PROP_SWINGUPDOWN);\n+                    break;\n+                case SWINGLR_CHANNEL:\n+                    state = updateNumber(GREE_PROP_SWINGLEFTRIGHT);\n+                    break;\n+                case WINDSPEED_CHANNEL:\n+                    state = updateNumber(GREE_PROP_WINDSPEED);\n+                    break;\n+                case QUIET_CHANNEL:\n+                    state = updateQuiet();\n+                    break;\n+                case AIR_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_AIR);\n+                    break;\n+                case DRY_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_DRY);\n+                    break;\n+                case HEALTH_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_HEALTH);\n+                    break;\n+                case PWRSAV_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_PWR_SAVING);\n+                    break;\n+            }\n+            if (state != null) {\n+                logger.debug(\"{}: Updating channel {} : {}\", thingId, channelID, state);\n+                updateState(channelID, state);\n+            }\n+        } catch (GreeException e) {\n+            logger.info(\"{}: {}\", thingId, messages.get(\"channel.exception\", channelID, e.getMessage()));\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: {}\", thingId, messages.get(\"channel.exception\", \"RuntimeException\"), e);\n+        }\n+    }\n+\n+    private @Nullable State updateOnOff(final String valueName) throws GreeException {\n+        if (device.hasStatusValChanged(valueName)) {\n+            return device.getIntStatusVal(valueName) == 1 ? OnOffType.ON : OnOffType.OFF;\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateNumber(final String valueName) throws GreeException {\n+        if (device.hasStatusValChanged(valueName)) {\n+            return new DecimalType(device.getIntStatusVal(valueName));\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateMode() throws GreeException {\n+        if (device.hasStatusValChanged(GREE_PROP_MODE)) {\n+            int mode = device.getIntStatusVal(GREE_PROP_MODE);\n+            String modeStr = \"\";\n+            switch (mode) {\n+                case GREE_MODE_AUTO:\n+                    modeStr = MODE_AUTO;\n+                    break;\n+                case GREE_MODE_COOL:\n+                    boolean powerSave = device.getIntStatusVal(GREE_PROP_PWR_SAVING) == 1;\n+                    modeStr = !powerSave ? MODE_COOL : MODE_ECO;\n+                    break;\n+                case GREE_MODE_DRY:\n+                    modeStr = MODE_DRY;\n+                    break;\n+                case GREE_MODE_FAN:\n+                    modeStr = MODE_FAN;\n+                    break;\n+                case GREE_MODE_HEAT:\n+                    modeStr = MODE_HEAT;\n+                    break;\n+                default:\n+                    modeStr = String.valueOf(mode);\n+\n+            }\n+            if (!modeStr.isEmpty()) {\n+                logger.debug(\"{}: Updading mode channel with {}/{}\", thingId, mode, modeStr);\n+                return new StringType(modeStr);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateQuiet() throws GreeException {\n+        if (device.hasStatusValChanged(GREE_PROP_QUIET)) {\n+            switch (device.getIntStatusVal(GREE_PROP_QUIET)) {\n+                case GREE_QUIET_OFF:\n+                    return new StringType(QUIET_OFF);\n+                case GREE_QUIET_AUTO:\n+                    return new StringType(QUIET_AUTO);\n+                case GREE_QUIET_QUIET:\n+                    return new StringType(QUIET_QUIET);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateTemp() throws GreeException {\n+        if (device.hasStatusValChanged(GREE_PROP_SETTEMP) || device.hasStatusValChanged(GREE_PROP_TEMPUNIT)) {\n+            int unit = device.getIntStatusVal(GREE_PROP_TEMPUNIT);\n+            return toQuantityType(device.getIntStatusVal(GREE_PROP_SETTEMP), DIGITS_TEMP,\n+                    unit == TEMP_UNIT_CELSIUS ? SIUnits.CELSIUS : ImperialUnits.FAHRENHEIT);\n+        }\n+        return null;\n+    }\n+\n+    private String logInfo(String msgKey, Object... arg) {\n+        String message = messages.get(msgKey, arg);\n+        logger.info(\"{}: {}\", thingId, message);\n+        return message;\n+    }\n+\n+    public static QuantityType<?> toQuantityType(Number value, int digits, Unit<?> unit) {\n+        BigDecimal bd = new BigDecimal(value.doubleValue());\n+        return new QuantityType<>(bd.setScale(digits, BigDecimal.ROUND_HALF_EVEN), unit);\n+    }\n+\n+    private void stopRefrestTask() {\n+        forceRefresh = false;\n+        if (refreshTask == null) {\n+            return;\n+        }\n+        synchronized (refreshTask) {\n+            ScheduledFuture<?> task = refreshTask;\n+            if ((task != null) && !task.isCancelled()) {", "originalCommit": "5c171d858e3aa58b6de4206ed8ea96ebcc3514bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5Mzg3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r445193877", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-24T21:54:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxNjYzNg=="}], "type": "inlineReview"}, {"oid": "fdde046cbff4b752165c1de442adb4daad23afca", "url": "https://github.com/openhab/openhab-addons/commit/fdde046cbff4b752165c1de442adb4daad23afca", "message": "commit\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-24T21:59:01Z", "type": "commit"}, {"oid": "b33acc6856c4abf4fba3646107029414a373166c", "url": "https://github.com/openhab/openhab-addons/commit/b33acc6856c4abf4fba3646107029414a373166c", "message": "gree added\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-24T21:59:14Z", "type": "commit"}, {"oid": "cad9ffd82bfe4cb49b9555543307fb9c260d8bc8", "url": "https://github.com/openhab/openhab-addons/commit/cad9ffd82bfe4cb49b9555543307fb9c260d8bc8", "message": "ordering fixed\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-24T22:07:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5ODA2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r445198067", "bodyText": "You should make sure that this returns a future so you can cancel it on dispose.", "author": "cpmeister", "createdAt": "2020-06-24T22:05:21Z", "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,546 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private final GreeDeviceFinder deviceFinder;\n+    private final String thingId;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+    private boolean forceRefresh = false;\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages, GreeDeviceFinder deviceFinder) {\n+        super(thing);\n+        this.messages = messages;\n+        this.deviceFinder = deviceFinder;\n+        this.thingId = getThing().getUID().getId();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            String message = messages.get(\"thinginit.invconf\");\n+            logger.warn(\"{}: {}\", thingId, message);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, message);\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Start the automatic refresh cycles\n+        startAutomaticRefresh();\n+        scheduler.execute(this::initializeThing);", "originalCommit": "b33acc6856c4abf4fba3646107029414a373166c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIxNDg1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r445214855", "bodyText": "what do you mean?\n\nstartAutomaticRefresh() creates the refreshTask\nscheduler.execute() does not return a ScheduledFuture\n\nthat's what I also saw in other bindings", "author": "markus7017", "createdAt": "2020-06-24T22:53:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5ODA2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI0MTg4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r445241885", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    scheduler.execute(this::initializeThing);\n          \n          \n            \n                    initializeFuture = scheduler.submit(this::initializeThing);", "author": "cpmeister", "createdAt": "2020-06-25T00:23:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5ODA2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc5MjA2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r445792063", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-25T19:33:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5ODA2Nw=="}], "type": "inlineReview"}, {"oid": "d185fbef94d9672fbb2d5a2b851b0b3445727bab", "url": "https://github.com/openhab/openhab-addons/commit/d185fbef94d9672fbb2d5a2b851b0b3445727bab", "message": "order change reverted\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-24T22:56:11Z", "type": "commit"}, {"oid": "77a3e2f1a23592c952b0ae4622f7647de3bb4fdd", "url": "https://github.com/openhab/openhab-addons/commit/77a3e2f1a23592c952b0ae4622f7647de3bb4fdd", "message": "review change, force status update on init", "committedDate": "2020-06-25T19:32:44Z", "type": "commit"}, {"oid": "d02afd67855da8b4600742a9275b4a37adc694b8", "url": "https://github.com/openhab/openhab-addons/commit/d02afd67855da8b4600742a9275b4a37adc694b8", "message": "removed empty line\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-25T19:34:46Z", "type": "commit"}, {"oid": "d02afd67855da8b4600742a9275b4a37adc694b8", "url": "https://github.com/openhab/openhab-addons/commit/d02afd67855da8b4600742a9275b4a37adc694b8", "message": "removed empty line\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-25T19:34:46Z", "type": "forcePushed"}, {"oid": "079b7452df9d58f2f03e4f8f7716083c1d6614e7", "url": "https://github.com/openhab/openhab-addons/commit/079b7452df9d58f2f03e4f8f7716083c1d6614e7", "message": "duplicate removed\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-06-26T17:49:42Z", "type": "commit"}]}