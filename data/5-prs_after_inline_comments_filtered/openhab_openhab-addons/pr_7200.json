{"pr_number": 7200, "pr_title": "[meteoalerte] M\u00e9t\u00e9o Alerte binding", "pr_createdAt": "2020-03-21T08:48:04Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7200", "timeline": [{"oid": "dd6ec1660b5749cb06e2fcc22eb43ae7b0850dc5", "url": "https://github.com/openhab/openhab-addons/commit/dd6ec1660b5749cb06e2fcc22eb43ae7b0850dc5", "message": "Initial commit of M\u00e9t\u00e9 Alerte binding\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-04-28T13:58:18Z", "type": "commit"}, {"oid": "b3a311e3a2cc07f0c9cf5f28162045e77677d83d", "url": "https://github.com/openhab/openhab-addons/commit/b3a311e3a2cc07f0c9cf5f28162045e77677d83d", "message": "[WIP] M\u00e9t\u00e9o Alerte Binding\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-04-28T13:58:19Z", "type": "commit"}, {"oid": "d8a3878271cce475178fb43021aa169c9db34c47", "url": "https://github.com/openhab/openhab-addons/commit/d8a3878271cce475178fb43021aa169c9db34c47", "message": "Adding alert level pictograms\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-04-28T13:58:20Z", "type": "commit"}, {"oid": "af82f58287e3477f32d98a13f2dedfd9b08a5048", "url": "https://github.com/openhab/openhab-addons/commit/af82f58287e3477f32d98a13f2dedfd9b08a5048", "message": "Adding Codeowners, reactor ...\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-04-28T13:58:21Z", "type": "commit"}, {"oid": "389182ce42bca260ad2f3f8aa5bcd34d77031a48", "url": "https://github.com/openhab/openhab-addons/commit/389182ce42bca260ad2f3f8aa5bcd34d77031a48", "message": "SAT corrections\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-04-28T13:58:22Z", "type": "commit"}, {"oid": "aa4528bbd1d6f1bf146cd9aa1af82209d7ef5f6b", "url": "https://github.com/openhab/openhab-addons/commit/aa4528bbd1d6f1bf146cd9aa1af82209d7ef5f6b", "message": "Some progress in documentation\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-04-28T13:58:23Z", "type": "commit"}, {"oid": "4813882ae294626e8e85af9a6dbec0fecf9f40b6", "url": "https://github.com/openhab/openhab-addons/commit/4813882ae294626e8e85af9a6dbec0fecf9f40b6", "message": "Small bug and documentation\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-04-28T13:58:24Z", "type": "commit"}, {"oid": "4813882ae294626e8e85af9a6dbec0fecf9f40b6", "url": "https://github.com/openhab/openhab-addons/commit/4813882ae294626e8e85af9a6dbec0fecf9f40b6", "message": "Small bug and documentation\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-04-28T13:58:24Z", "type": "forcePushed"}, {"oid": "0b8fade47e8bd4e0390dfd2ac9030ae6e31a2ccf", "url": "https://github.com/openhab/openhab-addons/commit/0b8fade47e8bd4e0390dfd2ac9030ae6e31a2ccf", "message": "Correction pom file\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-04-28T14:04:18Z", "type": "commit"}, {"oid": "ff165fd51752cc74296be9afa5e4e81c3bd77329", "url": "https://github.com/openhab/openhab-addons/commit/ff165fd51752cc74296be9afa5e4e81c3bd77329", "message": "DTO cleaning\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-04-28T14:57:03Z", "type": "commit"}, {"oid": "95c824c510307a343589e6d482ec6f00e864e9b2", "url": "https://github.com/openhab/openhab-addons/commit/95c824c510307a343589e6d482ec6f00e864e9b2", "message": "Some leftovers\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-04-29T09:25:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk0OTYyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r418949626", "bodyText": "Please set thing status to OFFLINE with COMMUNICATION_ERROR.", "author": "lolodomo", "createdAt": "2020-05-02T11:55:36Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.awt.image.BufferedImage;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.imageio.ImageIO;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final ArrayList<String> ALERT_LEVELS = new ArrayList<>(\n+            Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\"));\n+    private final Logger logger = LoggerFactory.getLogger(MeteoAlerteHandler.class);\n+    private final Gson gson = new GsonBuilder()\n+            .registerTypeAdapter(ZonedDateTime.class, (JsonDeserializer<ZonedDateTime>) (json, type,\n+                    jsonDeserializationContext) -> ZonedDateTime.parse(json.getAsJsonPrimitive().getAsString()))\n+            .create();\n+\n+    // Time zone provider representing time zone configured in openHAB configuration\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private @NonNullByDefault({}) String queryUrl;\n+\n+    public MeteoAlerteHandler(Thing thing, TimeZoneProvider timeZoneProvider) {\n+        super(thing);\n+        this.timeZoneProvider = timeZoneProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing M\u00e9t\u00e9o Alerte handler.\");\n+\n+        MeteoAlerteConfiguration config = getConfigAs(MeteoAlerteConfiguration.class);\n+        logger.debug(\"config department = {}\", config.department);\n+        logger.debug(\"config refresh = {}\", config.refresh);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        queryUrl = URL + config.department;\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateAndPublish, 0, config.refresh, TimeUnit.HOURS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the M\u00e9t\u00e9o Alerte handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAndPublish();\n+        } else {\n+            logger.debug(\"The Meteo Alerte binding is read-only and can not handle command {}\", command);\n+        }\n+    }\n+\n+    private void updateAndPublish() {\n+        try {\n+            URL url = new URL(queryUrl);\n+            try {\n+                URLConnection connection = url.openConnection();\n+                String response = IOUtils.toString(connection.getInputStream());\n+                IOUtils.closeQuietly(connection.getInputStream());\n+                updateStatus(ThingStatus.ONLINE);\n+                ApiResponse apiResponse = gson.fromJson(response, ApiResponse.class);\n+                updateChannels(apiResponse);\n+            } catch (IOException e) {\n+                logger.warn(\"Error opening connection to Meteo Alerte webservice : {}\", e.getMessage());", "originalCommit": "95c824c510307a343589e6d482ec6f00e864e9b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk0OTc1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r418949756", "bodyText": "Max WARN level", "author": "lolodomo", "createdAt": "2020-05-02T11:56:43Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.awt.image.BufferedImage;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.imageio.ImageIO;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final ArrayList<String> ALERT_LEVELS = new ArrayList<>(\n+            Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\"));\n+    private final Logger logger = LoggerFactory.getLogger(MeteoAlerteHandler.class);\n+    private final Gson gson = new GsonBuilder()\n+            .registerTypeAdapter(ZonedDateTime.class, (JsonDeserializer<ZonedDateTime>) (json, type,\n+                    jsonDeserializationContext) -> ZonedDateTime.parse(json.getAsJsonPrimitive().getAsString()))\n+            .create();\n+\n+    // Time zone provider representing time zone configured in openHAB configuration\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private @NonNullByDefault({}) String queryUrl;\n+\n+    public MeteoAlerteHandler(Thing thing, TimeZoneProvider timeZoneProvider) {\n+        super(thing);\n+        this.timeZoneProvider = timeZoneProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing M\u00e9t\u00e9o Alerte handler.\");\n+\n+        MeteoAlerteConfiguration config = getConfigAs(MeteoAlerteConfiguration.class);\n+        logger.debug(\"config department = {}\", config.department);\n+        logger.debug(\"config refresh = {}\", config.refresh);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        queryUrl = URL + config.department;\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateAndPublish, 0, config.refresh, TimeUnit.HOURS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the M\u00e9t\u00e9o Alerte handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAndPublish();\n+        } else {\n+            logger.debug(\"The Meteo Alerte binding is read-only and can not handle command {}\", command);\n+        }\n+    }\n+\n+    private void updateAndPublish() {\n+        try {\n+            URL url = new URL(queryUrl);\n+            try {\n+                URLConnection connection = url.openConnection();\n+                String response = IOUtils.toString(connection.getInputStream());\n+                IOUtils.closeQuietly(connection.getInputStream());\n+                updateStatus(ThingStatus.ONLINE);\n+                ApiResponse apiResponse = gson.fromJson(response, ApiResponse.class);\n+                updateChannels(apiResponse);\n+            } catch (IOException e) {\n+                logger.warn(\"Error opening connection to Meteo Alerte webservice : {}\", e.getMessage());\n+            }\n+        } catch (MalformedURLException e) {\n+            logger.error(\"Malformed URL in M\u00e9t\u00e9o Alerte request : {}\", queryUrl);", "originalCommit": "95c824c510307a343589e6d482ec6f00e864e9b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk1MDk0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r418950941", "bodyText": "Please add a security control in case index is not found and set the channel state to UNDEF.", "author": "lolodomo", "createdAt": "2020-05-02T12:08:29Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.awt.image.BufferedImage;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.imageio.ImageIO;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final ArrayList<String> ALERT_LEVELS = new ArrayList<>(\n+            Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\"));\n+    private final Logger logger = LoggerFactory.getLogger(MeteoAlerteHandler.class);\n+    private final Gson gson = new GsonBuilder()\n+            .registerTypeAdapter(ZonedDateTime.class, (JsonDeserializer<ZonedDateTime>) (json, type,\n+                    jsonDeserializationContext) -> ZonedDateTime.parse(json.getAsJsonPrimitive().getAsString()))\n+            .create();\n+\n+    // Time zone provider representing time zone configured in openHAB configuration\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private @NonNullByDefault({}) String queryUrl;\n+\n+    public MeteoAlerteHandler(Thing thing, TimeZoneProvider timeZoneProvider) {\n+        super(thing);\n+        this.timeZoneProvider = timeZoneProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing M\u00e9t\u00e9o Alerte handler.\");\n+\n+        MeteoAlerteConfiguration config = getConfigAs(MeteoAlerteConfiguration.class);\n+        logger.debug(\"config department = {}\", config.department);\n+        logger.debug(\"config refresh = {}\", config.refresh);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        queryUrl = URL + config.department;\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateAndPublish, 0, config.refresh, TimeUnit.HOURS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the M\u00e9t\u00e9o Alerte handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAndPublish();\n+        } else {\n+            logger.debug(\"The Meteo Alerte binding is read-only and can not handle command {}\", command);\n+        }\n+    }\n+\n+    private void updateAndPublish() {\n+        try {\n+            URL url = new URL(queryUrl);\n+            try {\n+                URLConnection connection = url.openConnection();\n+                String response = IOUtils.toString(connection.getInputStream());\n+                IOUtils.closeQuietly(connection.getInputStream());\n+                updateStatus(ThingStatus.ONLINE);\n+                ApiResponse apiResponse = gson.fromJson(response, ApiResponse.class);\n+                updateChannels(apiResponse);\n+            } catch (IOException e) {\n+                logger.warn(\"Error opening connection to Meteo Alerte webservice : {}\", e.getMessage());\n+            }\n+        } catch (MalformedURLException e) {\n+            logger.error(\"Malformed URL in M\u00e9t\u00e9o Alerte request : {}\", queryUrl);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Meteo Alerte data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannels(ApiResponse apiResponse) {\n+        Arrays.stream(apiResponse.getRecords()).findFirst().ifPresent(record -> {\n+            record.getFields().ifPresent(fields -> {\n+                updateAlertString(WIND, fields.getVent());\n+                updateAlertString(RAIN, fields.getPluieInondation());\n+                updateAlertString(STORM, fields.getOrage());\n+                updateAlertString(FLOOD, fields.getInondation());\n+                updateAlertString(SNOW, fields.getNeige());\n+                updateAlertString(HEAT, fields.getCanicule());\n+                updateAlertString(FREEZE, fields.getGrandFroid());\n+                updateAlertString(AVALANCHE, fields.getAvalanches());\n+\n+                fields.getDateInsert().ifPresent(date -> updateDate(OBSERVATION_TIME, date));\n+                updateState(COMMENT, new StringType(fields.getVigilanceComment()));\n+                updateIcon(WIND, fields.getVent());\n+                updateIcon(RAIN, fields.getPluieInondation());\n+                updateIcon(STORM, fields.getOrage());\n+                updateIcon(FLOOD, fields.getInondation());\n+                updateIcon(SNOW, fields.getNeige());\n+                updateIcon(HEAT, fields.getCanicule());\n+                updateIcon(FREEZE, fields.getGrandFroid());\n+                updateIcon(AVALANCHE, fields.getAvalanches());\n+            });\n+        });\n+    }\n+\n+    public void updateIcon(String channelId, String value) {\n+        String iconChannelId = channelId + \"-icon\";\n+        if (isLinked(iconChannelId)) {\n+            String pictoName = channelId + (!value.isEmpty() ? \"_\" + value.toLowerCase() : \"\");\n+            byte[] image = getImage(\"picto\" + File.separator + pictoName + \".gif\");\n+            if (image != null) {\n+                RawType picto = new RawType(image, \"image/gif\");\n+                updateState(iconChannelId, picto);\n+            }\n+        }\n+    }\n+\n+    private byte @Nullable [] getImage(String iconPath) {\n+        byte[] data = null;\n+        URL url = FrameworkUtil.getBundle(getClass()).getResource(iconPath);\n+        logger.trace(\"Path to icon image resource is: {}\", url);\n+        if (url != null) {\n+            try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n+                InputStream is = url.openStream();\n+                BufferedImage image = ImageIO.read(is);\n+                ImageIO.write(image, \"gif\", out);\n+                out.flush();\n+                data = out.toByteArray();\n+            } catch (IOException e) {\n+                logger.debug(\"I/O exception occurred getting image data: {}\", e.getMessage(), e);\n+            }\n+        }\n+        return data;\n+    }\n+\n+    public void updateAlertString(String channelId, String value) {\n+        if (!value.isEmpty() && isLinked(channelId)) {\n+            int level = ALERT_LEVELS.indexOf(value);", "originalCommit": "95c824c510307a343589e6d482ec6f00e864e9b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk1MTg3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r418951879", "bodyText": "What is the advantage to use java.awt.image.BufferedImage ?\nWould a byte copy not be sufficient ?", "author": "lolodomo", "createdAt": "2020-05-02T12:17:51Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.awt.image.BufferedImage;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.imageio.ImageIO;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final ArrayList<String> ALERT_LEVELS = new ArrayList<>(\n+            Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\"));\n+    private final Logger logger = LoggerFactory.getLogger(MeteoAlerteHandler.class);\n+    private final Gson gson = new GsonBuilder()\n+            .registerTypeAdapter(ZonedDateTime.class, (JsonDeserializer<ZonedDateTime>) (json, type,\n+                    jsonDeserializationContext) -> ZonedDateTime.parse(json.getAsJsonPrimitive().getAsString()))\n+            .create();\n+\n+    // Time zone provider representing time zone configured in openHAB configuration\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private @NonNullByDefault({}) String queryUrl;\n+\n+    public MeteoAlerteHandler(Thing thing, TimeZoneProvider timeZoneProvider) {\n+        super(thing);\n+        this.timeZoneProvider = timeZoneProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing M\u00e9t\u00e9o Alerte handler.\");\n+\n+        MeteoAlerteConfiguration config = getConfigAs(MeteoAlerteConfiguration.class);\n+        logger.debug(\"config department = {}\", config.department);\n+        logger.debug(\"config refresh = {}\", config.refresh);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        queryUrl = URL + config.department;\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateAndPublish, 0, config.refresh, TimeUnit.HOURS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the M\u00e9t\u00e9o Alerte handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAndPublish();\n+        } else {\n+            logger.debug(\"The Meteo Alerte binding is read-only and can not handle command {}\", command);\n+        }\n+    }\n+\n+    private void updateAndPublish() {\n+        try {\n+            URL url = new URL(queryUrl);\n+            try {\n+                URLConnection connection = url.openConnection();\n+                String response = IOUtils.toString(connection.getInputStream());\n+                IOUtils.closeQuietly(connection.getInputStream());\n+                updateStatus(ThingStatus.ONLINE);\n+                ApiResponse apiResponse = gson.fromJson(response, ApiResponse.class);\n+                updateChannels(apiResponse);\n+            } catch (IOException e) {\n+                logger.warn(\"Error opening connection to Meteo Alerte webservice : {}\", e.getMessage());\n+            }\n+        } catch (MalformedURLException e) {\n+            logger.error(\"Malformed URL in M\u00e9t\u00e9o Alerte request : {}\", queryUrl);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Meteo Alerte data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannels(ApiResponse apiResponse) {\n+        Arrays.stream(apiResponse.getRecords()).findFirst().ifPresent(record -> {\n+            record.getFields().ifPresent(fields -> {\n+                updateAlertString(WIND, fields.getVent());\n+                updateAlertString(RAIN, fields.getPluieInondation());\n+                updateAlertString(STORM, fields.getOrage());\n+                updateAlertString(FLOOD, fields.getInondation());\n+                updateAlertString(SNOW, fields.getNeige());\n+                updateAlertString(HEAT, fields.getCanicule());\n+                updateAlertString(FREEZE, fields.getGrandFroid());\n+                updateAlertString(AVALANCHE, fields.getAvalanches());\n+\n+                fields.getDateInsert().ifPresent(date -> updateDate(OBSERVATION_TIME, date));\n+                updateState(COMMENT, new StringType(fields.getVigilanceComment()));\n+                updateIcon(WIND, fields.getVent());\n+                updateIcon(RAIN, fields.getPluieInondation());\n+                updateIcon(STORM, fields.getOrage());\n+                updateIcon(FLOOD, fields.getInondation());\n+                updateIcon(SNOW, fields.getNeige());\n+                updateIcon(HEAT, fields.getCanicule());\n+                updateIcon(FREEZE, fields.getGrandFroid());\n+                updateIcon(AVALANCHE, fields.getAvalanches());\n+            });\n+        });\n+    }\n+\n+    public void updateIcon(String channelId, String value) {\n+        String iconChannelId = channelId + \"-icon\";\n+        if (isLinked(iconChannelId)) {\n+            String pictoName = channelId + (!value.isEmpty() ? \"_\" + value.toLowerCase() : \"\");\n+            byte[] image = getImage(\"picto\" + File.separator + pictoName + \".gif\");\n+            if (image != null) {\n+                RawType picto = new RawType(image, \"image/gif\");\n+                updateState(iconChannelId, picto);\n+            }\n+        }\n+    }\n+\n+    private byte @Nullable [] getImage(String iconPath) {\n+        byte[] data = null;\n+        URL url = FrameworkUtil.getBundle(getClass()).getResource(iconPath);\n+        logger.trace(\"Path to icon image resource is: {}\", url);\n+        if (url != null) {\n+            try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n+                InputStream is = url.openStream();\n+                BufferedImage image = ImageIO.read(is);\n+                ImageIO.write(image, \"gif\", out);", "originalCommit": "95c824c510307a343589e6d482ec6f00e864e9b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk2NjM4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r418966384", "bodyText": "I'm not a specialist of this matter, found this in another binding. I think this takes care of the image format as being a gif.", "author": "clinique", "createdAt": "2020-05-02T14:40:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk1MTg3OQ=="}], "type": "inlineReview"}, {"oid": "76982741b65b72a7fa1a6ed581685c7028b63db8", "url": "https://github.com/openhab/openhab-addons/commit/76982741b65b72a7fa1a6ed581685c7028b63db8", "message": "Code review corrections\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-05-02T14:40:57Z", "type": "commit"}, {"oid": "d83b015a533c4f3a2e0df779c911c9adae76adf2", "url": "https://github.com/openhab/openhab-addons/commit/d83b015a533c4f3a2e0df779c911c9adae76adf2", "message": "Code review\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-05-02T17:30:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MjgyMA==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r428852820", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n          \n          \n            \n                private @Nullable ScheduledFuture<?> refreshJob;", "author": "cpmeister", "createdAt": "2020-05-21T19:02:39Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.awt.image.BufferedImage;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.imageio.ImageIO;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final ArrayList<String> ALERT_LEVELS = new ArrayList<>(\n+            Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\"));\n+    private final Logger logger = LoggerFactory.getLogger(MeteoAlerteHandler.class);\n+    private final Gson gson = new GsonBuilder()\n+            .registerTypeAdapter(ZonedDateTime.class, (JsonDeserializer<ZonedDateTime>) (json, type,\n+                    jsonDeserializationContext) -> ZonedDateTime.parse(json.getAsJsonPrimitive().getAsString()))\n+            .create();\n+\n+    // Time zone provider representing time zone configured in openHAB configuration\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;", "originalCommit": "d83b015a533c4f3a2e0df779c911c9adae76adf2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MzExNw==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r428853117", "bodyText": "Either set this to some default value or let it be nullable.", "author": "cpmeister", "createdAt": "2020-05-21T19:03:13Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.awt.image.BufferedImage;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.imageio.ImageIO;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final ArrayList<String> ALERT_LEVELS = new ArrayList<>(\n+            Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\"));\n+    private final Logger logger = LoggerFactory.getLogger(MeteoAlerteHandler.class);\n+    private final Gson gson = new GsonBuilder()\n+            .registerTypeAdapter(ZonedDateTime.class, (JsonDeserializer<ZonedDateTime>) (json, type,\n+                    jsonDeserializationContext) -> ZonedDateTime.parse(json.getAsJsonPrimitive().getAsString()))\n+            .create();\n+\n+    // Time zone provider representing time zone configured in openHAB configuration\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private @NonNullByDefault({}) String queryUrl;", "originalCommit": "d83b015a533c4f3a2e0df779c911c9adae76adf2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MzYzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r428853638", "bodyText": "Any reason you aren't using an HttpClient?", "author": "cpmeister", "createdAt": "2020-05-21T19:04:12Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.awt.image.BufferedImage;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.imageio.ImageIO;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final ArrayList<String> ALERT_LEVELS = new ArrayList<>(\n+            Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\"));\n+    private final Logger logger = LoggerFactory.getLogger(MeteoAlerteHandler.class);\n+    private final Gson gson = new GsonBuilder()\n+            .registerTypeAdapter(ZonedDateTime.class, (JsonDeserializer<ZonedDateTime>) (json, type,\n+                    jsonDeserializationContext) -> ZonedDateTime.parse(json.getAsJsonPrimitive().getAsString()))\n+            .create();\n+\n+    // Time zone provider representing time zone configured in openHAB configuration\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private @NonNullByDefault({}) String queryUrl;\n+\n+    public MeteoAlerteHandler(Thing thing, TimeZoneProvider timeZoneProvider) {\n+        super(thing);\n+        this.timeZoneProvider = timeZoneProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing M\u00e9t\u00e9o Alerte handler.\");\n+\n+        MeteoAlerteConfiguration config = getConfigAs(MeteoAlerteConfiguration.class);\n+        logger.debug(\"config department = {}\", config.department);\n+        logger.debug(\"config refresh = {}\", config.refresh);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        queryUrl = URL + config.department;\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateAndPublish, 0, config.refresh, TimeUnit.HOURS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the M\u00e9t\u00e9o Alerte handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAndPublish();\n+        } else {\n+            logger.debug(\"The Meteo Alerte binding is read-only and can not handle command {}\", command);\n+        }\n+    }\n+\n+    private void updateAndPublish() {\n+        try {\n+            URL url = new URL(queryUrl);\n+            try {\n+                URLConnection connection = url.openConnection();\n+                String response = IOUtils.toString(connection.getInputStream());\n+                IOUtils.closeQuietly(connection.getInputStream());", "originalCommit": "d83b015a533c4f3a2e0df779c911c9adae76adf2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2OTk1MA==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r428869950", "bodyText": "Yes, a simple call of this kind should be ok:\nString response = HttpUtil.executeUrl(\"GET\", queryUrl, timeout);", "author": "lolodomo", "createdAt": "2020-05-21T19:37:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MzYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NzUzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r428857533", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n          \n          \n            \n                            InputStream is = url.openStream();\n          \n          \n            \n                        try (ByteArrayOutputStream out = new ByteArrayOutputStream();\n          \n          \n            \n                                     InputStream is = url.openStream()) {", "author": "cpmeister", "createdAt": "2020-05-21T19:12:13Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.awt.image.BufferedImage;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.imageio.ImageIO;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final ArrayList<String> ALERT_LEVELS = new ArrayList<>(\n+            Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\"));\n+    private final Logger logger = LoggerFactory.getLogger(MeteoAlerteHandler.class);\n+    private final Gson gson = new GsonBuilder()\n+            .registerTypeAdapter(ZonedDateTime.class, (JsonDeserializer<ZonedDateTime>) (json, type,\n+                    jsonDeserializationContext) -> ZonedDateTime.parse(json.getAsJsonPrimitive().getAsString()))\n+            .create();\n+\n+    // Time zone provider representing time zone configured in openHAB configuration\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private @NonNullByDefault({}) String queryUrl;\n+\n+    public MeteoAlerteHandler(Thing thing, TimeZoneProvider timeZoneProvider) {\n+        super(thing);\n+        this.timeZoneProvider = timeZoneProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing M\u00e9t\u00e9o Alerte handler.\");\n+\n+        MeteoAlerteConfiguration config = getConfigAs(MeteoAlerteConfiguration.class);\n+        logger.debug(\"config department = {}\", config.department);\n+        logger.debug(\"config refresh = {}\", config.refresh);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        queryUrl = URL + config.department;\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateAndPublish, 0, config.refresh, TimeUnit.HOURS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the M\u00e9t\u00e9o Alerte handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAndPublish();\n+        } else {\n+            logger.debug(\"The Meteo Alerte binding is read-only and can not handle command {}\", command);\n+        }\n+    }\n+\n+    private void updateAndPublish() {\n+        try {\n+            URL url = new URL(queryUrl);\n+            try {\n+                URLConnection connection = url.openConnection();\n+                String response = IOUtils.toString(connection.getInputStream());\n+                IOUtils.closeQuietly(connection.getInputStream());\n+                updateStatus(ThingStatus.ONLINE);\n+                ApiResponse apiResponse = gson.fromJson(response, ApiResponse.class);\n+                updateChannels(apiResponse);\n+            } catch (IOException e) {\n+                logger.warn(\"Error opening connection to Meteo Alerte webservice : {}\", e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+            }\n+        } catch (MalformedURLException e) {\n+            logger.warn(\"Malformed URL in M\u00e9t\u00e9o Alerte request : {}\", queryUrl);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Meteo Alerte data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannels(ApiResponse apiResponse) {\n+        Arrays.stream(apiResponse.getRecords()).findFirst().ifPresent(record -> {\n+            record.getFields().ifPresent(fields -> {\n+                updateAlertString(WIND, fields.getVent());\n+                updateAlertString(RAIN, fields.getPluieInondation());\n+                updateAlertString(STORM, fields.getOrage());\n+                updateAlertString(FLOOD, fields.getInondation());\n+                updateAlertString(SNOW, fields.getNeige());\n+                updateAlertString(HEAT, fields.getCanicule());\n+                updateAlertString(FREEZE, fields.getGrandFroid());\n+                updateAlertString(AVALANCHE, fields.getAvalanches());\n+\n+                fields.getDateInsert().ifPresent(date -> updateDate(OBSERVATION_TIME, date));\n+                updateState(COMMENT, new StringType(fields.getVigilanceComment()));\n+                updateIcon(WIND, fields.getVent());\n+                updateIcon(RAIN, fields.getPluieInondation());\n+                updateIcon(STORM, fields.getOrage());\n+                updateIcon(FLOOD, fields.getInondation());\n+                updateIcon(SNOW, fields.getNeige());\n+                updateIcon(HEAT, fields.getCanicule());\n+                updateIcon(FREEZE, fields.getGrandFroid());\n+                updateIcon(AVALANCHE, fields.getAvalanches());\n+            });\n+        });\n+    }\n+\n+    public void updateIcon(String channelId, String value) {\n+        String iconChannelId = channelId + \"-icon\";\n+        if (isLinked(iconChannelId)) {\n+            String pictoName = channelId + (!value.isEmpty() ? \"_\" + value.toLowerCase() : \"\");\n+            byte[] image = getImage(\"picto\" + File.separator + pictoName + \".gif\");\n+            if (image != null) {\n+                RawType picto = new RawType(image, \"image/gif\");\n+                updateState(iconChannelId, picto);\n+            }\n+        }\n+    }\n+\n+    private byte @Nullable [] getImage(String iconPath) {\n+        byte[] data = null;\n+        URL url = FrameworkUtil.getBundle(getClass()).getResource(iconPath);\n+        logger.trace(\"Path to icon image resource is: {}\", url);\n+        if (url != null) {\n+            try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n+                InputStream is = url.openStream();", "originalCommit": "d83b015a533c4f3a2e0df779c911c9adae76adf2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MjA5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r428862094", "bodyText": "Since your images are already gifs, a simple byte copy should suffice. I can't think of another reason that you would need to parse the image and then write it out again unless there is some weird image metadata you are trying to accomplish with this.", "author": "cpmeister", "createdAt": "2020-05-21T19:21:17Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.awt.image.BufferedImage;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.imageio.ImageIO;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final ArrayList<String> ALERT_LEVELS = new ArrayList<>(\n+            Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\"));\n+    private final Logger logger = LoggerFactory.getLogger(MeteoAlerteHandler.class);\n+    private final Gson gson = new GsonBuilder()\n+            .registerTypeAdapter(ZonedDateTime.class, (JsonDeserializer<ZonedDateTime>) (json, type,\n+                    jsonDeserializationContext) -> ZonedDateTime.parse(json.getAsJsonPrimitive().getAsString()))\n+            .create();\n+\n+    // Time zone provider representing time zone configured in openHAB configuration\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private @NonNullByDefault({}) String queryUrl;\n+\n+    public MeteoAlerteHandler(Thing thing, TimeZoneProvider timeZoneProvider) {\n+        super(thing);\n+        this.timeZoneProvider = timeZoneProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing M\u00e9t\u00e9o Alerte handler.\");\n+\n+        MeteoAlerteConfiguration config = getConfigAs(MeteoAlerteConfiguration.class);\n+        logger.debug(\"config department = {}\", config.department);\n+        logger.debug(\"config refresh = {}\", config.refresh);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        queryUrl = URL + config.department;\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateAndPublish, 0, config.refresh, TimeUnit.HOURS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the M\u00e9t\u00e9o Alerte handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAndPublish();\n+        } else {\n+            logger.debug(\"The Meteo Alerte binding is read-only and can not handle command {}\", command);\n+        }\n+    }\n+\n+    private void updateAndPublish() {\n+        try {\n+            URL url = new URL(queryUrl);\n+            try {\n+                URLConnection connection = url.openConnection();\n+                String response = IOUtils.toString(connection.getInputStream());\n+                IOUtils.closeQuietly(connection.getInputStream());\n+                updateStatus(ThingStatus.ONLINE);\n+                ApiResponse apiResponse = gson.fromJson(response, ApiResponse.class);\n+                updateChannels(apiResponse);\n+            } catch (IOException e) {\n+                logger.warn(\"Error opening connection to Meteo Alerte webservice : {}\", e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+            }\n+        } catch (MalformedURLException e) {\n+            logger.warn(\"Malformed URL in M\u00e9t\u00e9o Alerte request : {}\", queryUrl);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Meteo Alerte data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannels(ApiResponse apiResponse) {\n+        Arrays.stream(apiResponse.getRecords()).findFirst().ifPresent(record -> {\n+            record.getFields().ifPresent(fields -> {\n+                updateAlertString(WIND, fields.getVent());\n+                updateAlertString(RAIN, fields.getPluieInondation());\n+                updateAlertString(STORM, fields.getOrage());\n+                updateAlertString(FLOOD, fields.getInondation());\n+                updateAlertString(SNOW, fields.getNeige());\n+                updateAlertString(HEAT, fields.getCanicule());\n+                updateAlertString(FREEZE, fields.getGrandFroid());\n+                updateAlertString(AVALANCHE, fields.getAvalanches());\n+\n+                fields.getDateInsert().ifPresent(date -> updateDate(OBSERVATION_TIME, date));\n+                updateState(COMMENT, new StringType(fields.getVigilanceComment()));\n+                updateIcon(WIND, fields.getVent());\n+                updateIcon(RAIN, fields.getPluieInondation());\n+                updateIcon(STORM, fields.getOrage());\n+                updateIcon(FLOOD, fields.getInondation());\n+                updateIcon(SNOW, fields.getNeige());\n+                updateIcon(HEAT, fields.getCanicule());\n+                updateIcon(FREEZE, fields.getGrandFroid());\n+                updateIcon(AVALANCHE, fields.getAvalanches());\n+            });\n+        });\n+    }\n+\n+    public void updateIcon(String channelId, String value) {\n+        String iconChannelId = channelId + \"-icon\";\n+        if (isLinked(iconChannelId)) {\n+            String pictoName = channelId + (!value.isEmpty() ? \"_\" + value.toLowerCase() : \"\");\n+            byte[] image = getImage(\"picto\" + File.separator + pictoName + \".gif\");\n+            if (image != null) {\n+                RawType picto = new RawType(image, \"image/gif\");\n+                updateState(iconChannelId, picto);\n+            }\n+        }\n+    }\n+\n+    private byte @Nullable [] getImage(String iconPath) {\n+        byte[] data = null;\n+        URL url = FrameworkUtil.getBundle(getClass()).getResource(iconPath);\n+        logger.trace(\"Path to icon image resource is: {}\", url);\n+        if (url != null) {\n+            try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n+                InputStream is = url.openStream();\n+                BufferedImage image = ImageIO.read(is);\n+                ImageIO.write(image, \"gif\", out);", "originalCommit": "d83b015a533c4f3a2e0df779c911c9adae76adf2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTEwOTM3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r429109371", "bodyText": "Well, I copied the way it was done in the weathercompany binding.", "author": "clinique", "createdAt": "2020-05-22T08:20:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MjA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MzYzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r428863639", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final ArrayList<String> ALERT_LEVELS = new ArrayList<>(\n          \n          \n            \n                        Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\"));\n          \n          \n            \n                private static final List<String> ALERT_LEVELS = Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\");", "author": "cpmeister", "createdAt": "2020-05-21T19:24:28Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.awt.image.BufferedImage;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.imageio.ImageIO;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final ArrayList<String> ALERT_LEVELS = new ArrayList<>(\n+            Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\"));", "originalCommit": "d83b015a533c4f3a2e0df779c911c9adae76adf2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "925f5c4d9f99157f1282b87c11416e6a7bb026ae", "url": "https://github.com/openhab/openhab-addons/commit/925f5c4d9f99157f1282b87c11416e6a7bb026ae", "message": "Code review corrections\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-05-22T08:44:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NTI2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r429585269", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            throw new MalformedURLException();\n          \n          \n            \n                            throw new MalformedURLException(\"queryUrl not initialized\");", "author": "cpmeister", "createdAt": "2020-05-23T23:16:58Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final int TIMEOUT_MS = 30000;\n+    private static final List<String> ALERT_LEVELS = Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\");\n+    private final Logger logger = LoggerFactory.getLogger(MeteoAlerteHandler.class);\n+    private final Gson gson = new GsonBuilder()\n+            .registerTypeAdapter(ZonedDateTime.class, (JsonDeserializer<ZonedDateTime>) (json, type,\n+                    jsonDeserializationContext) -> ZonedDateTime.parse(json.getAsJsonPrimitive().getAsString()))\n+            .create();\n+\n+    // Time zone provider representing time zone configured in openHAB configuration\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private String queryUrl = \"\";\n+\n+    public MeteoAlerteHandler(Thing thing, TimeZoneProvider timeZoneProvider) {\n+        super(thing);\n+        this.timeZoneProvider = timeZoneProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing M\u00e9t\u00e9o Alerte handler.\");\n+\n+        MeteoAlerteConfiguration config = getConfigAs(MeteoAlerteConfiguration.class);\n+        logger.debug(\"config department = {}\", config.department);\n+        logger.debug(\"config refresh = {}\", config.refresh);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        queryUrl = URL + config.department;\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateAndPublish, 0, config.refresh, TimeUnit.HOURS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the M\u00e9t\u00e9o Alerte handler.\");\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            this.refreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAndPublish();\n+        } else {\n+            logger.debug(\"The Meteo Alerte binding is read-only and can not handle command {}\", command);\n+        }\n+    }\n+\n+    private void updateAndPublish() {\n+        try {\n+            if (queryUrl.isEmpty()) {\n+                throw new MalformedURLException();", "originalCommit": "925f5c4d9f99157f1282b87c11416e6a7bb026ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NTI4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r429585282", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n          \n          \n            \n                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());", "author": "cpmeister", "createdAt": "2020-05-23T23:17:18Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final int TIMEOUT_MS = 30000;\n+    private static final List<String> ALERT_LEVELS = Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\");\n+    private final Logger logger = LoggerFactory.getLogger(MeteoAlerteHandler.class);\n+    private final Gson gson = new GsonBuilder()\n+            .registerTypeAdapter(ZonedDateTime.class, (JsonDeserializer<ZonedDateTime>) (json, type,\n+                    jsonDeserializationContext) -> ZonedDateTime.parse(json.getAsJsonPrimitive().getAsString()))\n+            .create();\n+\n+    // Time zone provider representing time zone configured in openHAB configuration\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private String queryUrl = \"\";\n+\n+    public MeteoAlerteHandler(Thing thing, TimeZoneProvider timeZoneProvider) {\n+        super(thing);\n+        this.timeZoneProvider = timeZoneProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing M\u00e9t\u00e9o Alerte handler.\");\n+\n+        MeteoAlerteConfiguration config = getConfigAs(MeteoAlerteConfiguration.class);\n+        logger.debug(\"config department = {}\", config.department);\n+        logger.debug(\"config refresh = {}\", config.refresh);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        queryUrl = URL + config.department;\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateAndPublish, 0, config.refresh, TimeUnit.HOURS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the M\u00e9t\u00e9o Alerte handler.\");\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            this.refreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAndPublish();\n+        } else {\n+            logger.debug(\"The Meteo Alerte binding is read-only and can not handle command {}\", command);\n+        }\n+    }\n+\n+    private void updateAndPublish() {\n+        try {\n+            if (queryUrl.isEmpty()) {\n+                throw new MalformedURLException();\n+            }\n+            try {\n+                String response = HttpUtil.executeUrl(\"GET\", queryUrl, TIMEOUT_MS);\n+                updateStatus(ThingStatus.ONLINE);\n+                ApiResponse apiResponse = gson.fromJson(response, ApiResponse.class);\n+                updateChannels(apiResponse);\n+            } catch (IOException e) {\n+                logger.warn(\"Error opening connection to Meteo Alerte webservice : {}\", e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);", "originalCommit": "925f5c4d9f99157f1282b87c11416e6a7bb026ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NTUyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r429585525", "bodyText": "Use try-with-resources to make sure that the url stream gets closed. You should also use a buffered input stream so that it will do batch reads behind the scenes for you which improves performance.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    try {\n          \n          \n            \n                        InputStream in = url.openStream();\n          \n          \n            \n                    try (InputStream in = new BufferedInputStream(url.openStream())){", "author": "cpmeister", "createdAt": "2020-05-23T23:22:28Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final int TIMEOUT_MS = 30000;\n+    private static final List<String> ALERT_LEVELS = Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\");\n+    private final Logger logger = LoggerFactory.getLogger(MeteoAlerteHandler.class);\n+    private final Gson gson = new GsonBuilder()\n+            .registerTypeAdapter(ZonedDateTime.class, (JsonDeserializer<ZonedDateTime>) (json, type,\n+                    jsonDeserializationContext) -> ZonedDateTime.parse(json.getAsJsonPrimitive().getAsString()))\n+            .create();\n+\n+    // Time zone provider representing time zone configured in openHAB configuration\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private String queryUrl = \"\";\n+\n+    public MeteoAlerteHandler(Thing thing, TimeZoneProvider timeZoneProvider) {\n+        super(thing);\n+        this.timeZoneProvider = timeZoneProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing M\u00e9t\u00e9o Alerte handler.\");\n+\n+        MeteoAlerteConfiguration config = getConfigAs(MeteoAlerteConfiguration.class);\n+        logger.debug(\"config department = {}\", config.department);\n+        logger.debug(\"config refresh = {}\", config.refresh);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        queryUrl = URL + config.department;\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateAndPublish, 0, config.refresh, TimeUnit.HOURS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the M\u00e9t\u00e9o Alerte handler.\");\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            this.refreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAndPublish();\n+        } else {\n+            logger.debug(\"The Meteo Alerte binding is read-only and can not handle command {}\", command);\n+        }\n+    }\n+\n+    private void updateAndPublish() {\n+        try {\n+            if (queryUrl.isEmpty()) {\n+                throw new MalformedURLException();\n+            }\n+            try {\n+                String response = HttpUtil.executeUrl(\"GET\", queryUrl, TIMEOUT_MS);\n+                updateStatus(ThingStatus.ONLINE);\n+                ApiResponse apiResponse = gson.fromJson(response, ApiResponse.class);\n+                updateChannels(apiResponse);\n+            } catch (IOException e) {\n+                logger.warn(\"Error opening connection to Meteo Alerte webservice : {}\", e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+            }\n+        } catch (MalformedURLException e) {\n+            logger.warn(\"Malformed URL in M\u00e9t\u00e9o Alerte request : {}\", queryUrl);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Meteo Alerte data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannels(ApiResponse apiResponse) {\n+        Arrays.stream(apiResponse.getRecords()).findFirst().ifPresent(record -> {\n+            record.getFields().ifPresent(fields -> {\n+                updateAlertString(WIND, fields.getVent());\n+                updateAlertString(RAIN, fields.getPluieInondation());\n+                updateAlertString(STORM, fields.getOrage());\n+                updateAlertString(FLOOD, fields.getInondation());\n+                updateAlertString(SNOW, fields.getNeige());\n+                updateAlertString(HEAT, fields.getCanicule());\n+                updateAlertString(FREEZE, fields.getGrandFroid());\n+                updateAlertString(AVALANCHE, fields.getAvalanches());\n+\n+                fields.getDateInsert().ifPresent(date -> updateDate(OBSERVATION_TIME, date));\n+                updateState(COMMENT, new StringType(fields.getVigilanceComment()));\n+                updateIcon(WIND, fields.getVent());\n+                updateIcon(RAIN, fields.getPluieInondation());\n+                updateIcon(STORM, fields.getOrage());\n+                updateIcon(FLOOD, fields.getInondation());\n+                updateIcon(SNOW, fields.getNeige());\n+                updateIcon(HEAT, fields.getCanicule());\n+                updateIcon(FREEZE, fields.getGrandFroid());\n+                updateIcon(AVALANCHE, fields.getAvalanches());\n+            });\n+        });\n+    }\n+\n+    public void updateIcon(String channelId, String value) {\n+        String iconChannelId = channelId + \"-icon\";\n+        if (isLinked(iconChannelId)) {\n+            String pictoName = channelId + (!value.isEmpty() ? \"_\" + value.toLowerCase() : \"\");\n+            byte[] image = getImage(\"picto\" + File.separator + pictoName + \".gif\");\n+            if (image != null) {\n+                RawType picto = new RawType(image, \"image/gif\");\n+                updateState(iconChannelId, picto);\n+            }\n+        }\n+    }\n+\n+    private byte @Nullable [] getImage(String iconPath) {\n+        URL url = FrameworkUtil.getBundle(getClass()).getResource(iconPath);\n+        logger.debug(\"Path to icon image resource is: {}\", url);\n+        try {\n+            InputStream in = url.openStream();", "originalCommit": "925f5c4d9f99157f1282b87c11416e6a7bb026ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NjI5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r429586299", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n          \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());", "author": "cpmeister", "createdAt": "2020-05-23T23:38:36Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final int TIMEOUT_MS = 30000;\n+    private static final List<String> ALERT_LEVELS = Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\");\n+    private final Logger logger = LoggerFactory.getLogger(MeteoAlerteHandler.class);\n+    private final Gson gson = new GsonBuilder()\n+            .registerTypeAdapter(ZonedDateTime.class, (JsonDeserializer<ZonedDateTime>) (json, type,\n+                    jsonDeserializationContext) -> ZonedDateTime.parse(json.getAsJsonPrimitive().getAsString()))\n+            .create();\n+\n+    // Time zone provider representing time zone configured in openHAB configuration\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private String queryUrl = \"\";\n+\n+    public MeteoAlerteHandler(Thing thing, TimeZoneProvider timeZoneProvider) {\n+        super(thing);\n+        this.timeZoneProvider = timeZoneProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing M\u00e9t\u00e9o Alerte handler.\");\n+\n+        MeteoAlerteConfiguration config = getConfigAs(MeteoAlerteConfiguration.class);\n+        logger.debug(\"config department = {}\", config.department);\n+        logger.debug(\"config refresh = {}\", config.refresh);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        queryUrl = URL + config.department;\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateAndPublish, 0, config.refresh, TimeUnit.HOURS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the M\u00e9t\u00e9o Alerte handler.\");\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            this.refreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAndPublish();\n+        } else {\n+            logger.debug(\"The Meteo Alerte binding is read-only and can not handle command {}\", command);\n+        }\n+    }\n+\n+    private void updateAndPublish() {\n+        try {\n+            if (queryUrl.isEmpty()) {\n+                throw new MalformedURLException();\n+            }\n+            try {\n+                String response = HttpUtil.executeUrl(\"GET\", queryUrl, TIMEOUT_MS);\n+                updateStatus(ThingStatus.ONLINE);\n+                ApiResponse apiResponse = gson.fromJson(response, ApiResponse.class);\n+                updateChannels(apiResponse);\n+            } catch (IOException e) {\n+                logger.warn(\"Error opening connection to Meteo Alerte webservice : {}\", e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+            }\n+        } catch (MalformedURLException e) {\n+            logger.warn(\"Malformed URL in M\u00e9t\u00e9o Alerte request : {}\", queryUrl);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);", "originalCommit": "925f5c4d9f99157f1282b87c11416e6a7bb026ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NjM2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r429586368", "bodyText": "might as well merge the inner and outer try blocks into a single try block.", "author": "cpmeister", "createdAt": "2020-05-23T23:40:12Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final int TIMEOUT_MS = 30000;\n+    private static final List<String> ALERT_LEVELS = Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\");\n+    private final Logger logger = LoggerFactory.getLogger(MeteoAlerteHandler.class);\n+    private final Gson gson = new GsonBuilder()\n+            .registerTypeAdapter(ZonedDateTime.class, (JsonDeserializer<ZonedDateTime>) (json, type,\n+                    jsonDeserializationContext) -> ZonedDateTime.parse(json.getAsJsonPrimitive().getAsString()))\n+            .create();\n+\n+    // Time zone provider representing time zone configured in openHAB configuration\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private String queryUrl = \"\";\n+\n+    public MeteoAlerteHandler(Thing thing, TimeZoneProvider timeZoneProvider) {\n+        super(thing);\n+        this.timeZoneProvider = timeZoneProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing M\u00e9t\u00e9o Alerte handler.\");\n+\n+        MeteoAlerteConfiguration config = getConfigAs(MeteoAlerteConfiguration.class);\n+        logger.debug(\"config department = {}\", config.department);\n+        logger.debug(\"config refresh = {}\", config.refresh);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        queryUrl = URL + config.department;\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateAndPublish, 0, config.refresh, TimeUnit.HOURS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the M\u00e9t\u00e9o Alerte handler.\");\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            this.refreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAndPublish();\n+        } else {\n+            logger.debug(\"The Meteo Alerte binding is read-only and can not handle command {}\", command);\n+        }\n+    }\n+\n+    private void updateAndPublish() {\n+        try {\n+            if (queryUrl.isEmpty()) {\n+                throw new MalformedURLException();\n+            }\n+            try {", "originalCommit": "925f5c4d9f99157f1282b87c11416e6a7bb026ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9e1886cd2c01f4b02f1c7aa93137b786074a5b8f", "url": "https://github.com/openhab/openhab-addons/commit/9e1886cd2c01f4b02f1c7aa93137b786074a5b8f", "message": "Code review enhancements\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-05-24T07:51:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY1Mjc1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r430652758", "bodyText": "I would prefer to have this initialization in the constructor. It's a bit long here. You could also add that to the handler factory and pass it to the thing handler as parameter of the constructor.", "author": "J-N-K", "createdAt": "2020-05-26T19:25:56Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final int TIMEOUT_MS = 30000;\n+    private static final List<String> ALERT_LEVELS = Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\");\n+    private final Logger logger = LoggerFactory.getLogger(MeteoAlerteHandler.class);\n+    private final Gson gson = new GsonBuilder()", "originalCommit": "9e1886cd2c01f4b02f1c7aa93137b786074a5b8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY1NDk0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r430654947", "bodyText": "Would it make sense to increase granularity here and use MINUTES instead of HOURS? Since lead times of warnings are sometimes very short, it might be desirable to have it at 30 minutes or so.", "author": "J-N-K", "createdAt": "2020-05-26T19:30:10Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final int TIMEOUT_MS = 30000;\n+    private static final List<String> ALERT_LEVELS = Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\");\n+    private final Logger logger = LoggerFactory.getLogger(MeteoAlerteHandler.class);\n+    private final Gson gson = new GsonBuilder()\n+            .registerTypeAdapter(ZonedDateTime.class, (JsonDeserializer<ZonedDateTime>) (json, type,\n+                    jsonDeserializationContext) -> ZonedDateTime.parse(json.getAsJsonPrimitive().getAsString()))\n+            .create();\n+\n+    // Time zone provider representing time zone configured in openHAB configuration\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private String queryUrl = \"\";\n+\n+    public MeteoAlerteHandler(Thing thing, TimeZoneProvider timeZoneProvider) {\n+        super(thing);\n+        this.timeZoneProvider = timeZoneProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing M\u00e9t\u00e9o Alerte handler.\");\n+\n+        MeteoAlerteConfiguration config = getConfigAs(MeteoAlerteConfiguration.class);\n+        logger.debug(\"config department = {}\", config.department);\n+        logger.debug(\"config refresh = {}\", config.refresh);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        queryUrl = URL + config.department;\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateAndPublish, 0, config.refresh, TimeUnit.HOURS);", "originalCommit": "9e1886cd2c01f4b02f1c7aa93137b786074a5b8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY1NTQ0NA==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r430655444", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (refreshJob != null && !refreshJob.isCancelled()) {\n          \n          \n            \n                    if (refreshJob != null) {\n          \n      \n    \n    \n  \n\nCancelling doesn't hurt even if it is already cancelled. Another option would be to move the null-assignment outside if the if-block (otherwise the field will never be assigned null im case of a cancelled job).", "author": "J-N-K", "createdAt": "2020-05-26T19:31:03Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final int TIMEOUT_MS = 30000;\n+    private static final List<String> ALERT_LEVELS = Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\");\n+    private final Logger logger = LoggerFactory.getLogger(MeteoAlerteHandler.class);\n+    private final Gson gson = new GsonBuilder()\n+            .registerTypeAdapter(ZonedDateTime.class, (JsonDeserializer<ZonedDateTime>) (json, type,\n+                    jsonDeserializationContext) -> ZonedDateTime.parse(json.getAsJsonPrimitive().getAsString()))\n+            .create();\n+\n+    // Time zone provider representing time zone configured in openHAB configuration\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private String queryUrl = \"\";\n+\n+    public MeteoAlerteHandler(Thing thing, TimeZoneProvider timeZoneProvider) {\n+        super(thing);\n+        this.timeZoneProvider = timeZoneProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing M\u00e9t\u00e9o Alerte handler.\");\n+\n+        MeteoAlerteConfiguration config = getConfigAs(MeteoAlerteConfiguration.class);\n+        logger.debug(\"config department = {}\", config.department);\n+        logger.debug(\"config refresh = {}\", config.refresh);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        queryUrl = URL + config.department;\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateAndPublish, 0, config.refresh, TimeUnit.HOURS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the M\u00e9t\u00e9o Alerte handler.\");\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null && !refreshJob.isCancelled()) {", "originalCommit": "9e1886cd2c01f4b02f1c7aa93137b786074a5b8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY1NjY4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r430656686", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else {\n          \n          \n            \n                        logger.debug(\"The Meteo Alerte binding is read-only and can not handle command {}\", command);\n          \n          \n            \n                    }\n          \n          \n            \n                    } \n          \n      \n    \n    \n  \n\nOther bindings that support commands might be linked to these channels. Ignoring that silently is ok,", "author": "J-N-K", "createdAt": "2020-05-26T19:33:22Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final int TIMEOUT_MS = 30000;\n+    private static final List<String> ALERT_LEVELS = Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\");\n+    private final Logger logger = LoggerFactory.getLogger(MeteoAlerteHandler.class);\n+    private final Gson gson = new GsonBuilder()\n+            .registerTypeAdapter(ZonedDateTime.class, (JsonDeserializer<ZonedDateTime>) (json, type,\n+                    jsonDeserializationContext) -> ZonedDateTime.parse(json.getAsJsonPrimitive().getAsString()))\n+            .create();\n+\n+    // Time zone provider representing time zone configured in openHAB configuration\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private String queryUrl = \"\";\n+\n+    public MeteoAlerteHandler(Thing thing, TimeZoneProvider timeZoneProvider) {\n+        super(thing);\n+        this.timeZoneProvider = timeZoneProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing M\u00e9t\u00e9o Alerte handler.\");\n+\n+        MeteoAlerteConfiguration config = getConfigAs(MeteoAlerteConfiguration.class);\n+        logger.debug(\"config department = {}\", config.department);\n+        logger.debug(\"config refresh = {}\", config.refresh);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        queryUrl = URL + config.department;\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateAndPublish, 0, config.refresh, TimeUnit.HOURS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the M\u00e9t\u00e9o Alerte handler.\");\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            this.refreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAndPublish();\n+        } else {\n+            logger.debug(\"The Meteo Alerte binding is read-only and can not handle command {}\", command);\n+        }", "originalCommit": "9e1886cd2c01f4b02f1c7aa93137b786074a5b8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY1ODA3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r430658074", "bodyText": "I would suggest to add the URL to the thing status. Since thing status changes are logged by default, there is no need to add additional logging. Also below.", "author": "J-N-K", "createdAt": "2020-05-26T19:35:04Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final int TIMEOUT_MS = 30000;\n+    private static final List<String> ALERT_LEVELS = Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\");\n+    private final Logger logger = LoggerFactory.getLogger(MeteoAlerteHandler.class);\n+    private final Gson gson = new GsonBuilder()\n+            .registerTypeAdapter(ZonedDateTime.class, (JsonDeserializer<ZonedDateTime>) (json, type,\n+                    jsonDeserializationContext) -> ZonedDateTime.parse(json.getAsJsonPrimitive().getAsString()))\n+            .create();\n+\n+    // Time zone provider representing time zone configured in openHAB configuration\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private String queryUrl = \"\";\n+\n+    public MeteoAlerteHandler(Thing thing, TimeZoneProvider timeZoneProvider) {\n+        super(thing);\n+        this.timeZoneProvider = timeZoneProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing M\u00e9t\u00e9o Alerte handler.\");\n+\n+        MeteoAlerteConfiguration config = getConfigAs(MeteoAlerteConfiguration.class);\n+        logger.debug(\"config department = {}\", config.department);\n+        logger.debug(\"config refresh = {}\", config.refresh);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        queryUrl = URL + config.department;\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateAndPublish, 0, config.refresh, TimeUnit.HOURS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the M\u00e9t\u00e9o Alerte handler.\");\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            this.refreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAndPublish();\n+        } else {\n+            logger.debug(\"The Meteo Alerte binding is read-only and can not handle command {}\", command);\n+        }\n+    }\n+\n+    private void updateAndPublish() {\n+        try {\n+            if (queryUrl.isEmpty()) {\n+                throw new MalformedURLException(\"queryUrl not initialized\");\n+            }\n+            String response = HttpUtil.executeUrl(\"GET\", queryUrl, TIMEOUT_MS);\n+            updateStatus(ThingStatus.ONLINE);\n+            ApiResponse apiResponse = gson.fromJson(response, ApiResponse.class);\n+            updateChannels(apiResponse);\n+        } catch (MalformedURLException e) {\n+            logger.warn(\"Malformed URL in M\u00e9t\u00e9o Alerte request : {}\", queryUrl);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());", "originalCommit": "9e1886cd2c01f4b02f1c7aa93137b786074a5b8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY1ODg4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r430658885", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Arrays.stream(apiResponse.getRecords()).findFirst().ifPresent(record -> {\n          \n          \n            \n                    Arrays.stream(apiResponse.getRecords()).findFirst().ifPresent(record ->\n          \n      \n    \n    \n  \n\nstatement lambda can be replaced by expression lambda if only a single expression ins present.", "author": "J-N-K", "createdAt": "2020-05-26T19:35:55Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final int TIMEOUT_MS = 30000;\n+    private static final List<String> ALERT_LEVELS = Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\");\n+    private final Logger logger = LoggerFactory.getLogger(MeteoAlerteHandler.class);\n+    private final Gson gson = new GsonBuilder()\n+            .registerTypeAdapter(ZonedDateTime.class, (JsonDeserializer<ZonedDateTime>) (json, type,\n+                    jsonDeserializationContext) -> ZonedDateTime.parse(json.getAsJsonPrimitive().getAsString()))\n+            .create();\n+\n+    // Time zone provider representing time zone configured in openHAB configuration\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private String queryUrl = \"\";\n+\n+    public MeteoAlerteHandler(Thing thing, TimeZoneProvider timeZoneProvider) {\n+        super(thing);\n+        this.timeZoneProvider = timeZoneProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing M\u00e9t\u00e9o Alerte handler.\");\n+\n+        MeteoAlerteConfiguration config = getConfigAs(MeteoAlerteConfiguration.class);\n+        logger.debug(\"config department = {}\", config.department);\n+        logger.debug(\"config refresh = {}\", config.refresh);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        queryUrl = URL + config.department;\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateAndPublish, 0, config.refresh, TimeUnit.HOURS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the M\u00e9t\u00e9o Alerte handler.\");\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            this.refreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAndPublish();\n+        } else {\n+            logger.debug(\"The Meteo Alerte binding is read-only and can not handle command {}\", command);\n+        }\n+    }\n+\n+    private void updateAndPublish() {\n+        try {\n+            if (queryUrl.isEmpty()) {\n+                throw new MalformedURLException(\"queryUrl not initialized\");\n+            }\n+            String response = HttpUtil.executeUrl(\"GET\", queryUrl, TIMEOUT_MS);\n+            updateStatus(ThingStatus.ONLINE);\n+            ApiResponse apiResponse = gson.fromJson(response, ApiResponse.class);\n+            updateChannels(apiResponse);\n+        } catch (MalformedURLException e) {\n+            logger.warn(\"Malformed URL in M\u00e9t\u00e9o Alerte request : {}\", queryUrl);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+        } catch (IOException e) {\n+            logger.warn(\"Error opening connection to Meteo Alerte webservice : {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Meteo Alerte data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannels(ApiResponse apiResponse) {\n+        Arrays.stream(apiResponse.getRecords()).findFirst().ifPresent(record -> {", "originalCommit": "9e1886cd2c01f4b02f1c7aa93137b786074a5b8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY1OTk0NA==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r430659944", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    });\n          \n          \n            \n                    );", "author": "J-N-K", "createdAt": "2020-05-26T19:37:15Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final int TIMEOUT_MS = 30000;\n+    private static final List<String> ALERT_LEVELS = Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\");\n+    private final Logger logger = LoggerFactory.getLogger(MeteoAlerteHandler.class);\n+    private final Gson gson = new GsonBuilder()\n+            .registerTypeAdapter(ZonedDateTime.class, (JsonDeserializer<ZonedDateTime>) (json, type,\n+                    jsonDeserializationContext) -> ZonedDateTime.parse(json.getAsJsonPrimitive().getAsString()))\n+            .create();\n+\n+    // Time zone provider representing time zone configured in openHAB configuration\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private String queryUrl = \"\";\n+\n+    public MeteoAlerteHandler(Thing thing, TimeZoneProvider timeZoneProvider) {\n+        super(thing);\n+        this.timeZoneProvider = timeZoneProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing M\u00e9t\u00e9o Alerte handler.\");\n+\n+        MeteoAlerteConfiguration config = getConfigAs(MeteoAlerteConfiguration.class);\n+        logger.debug(\"config department = {}\", config.department);\n+        logger.debug(\"config refresh = {}\", config.refresh);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        queryUrl = URL + config.department;\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateAndPublish, 0, config.refresh, TimeUnit.HOURS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the M\u00e9t\u00e9o Alerte handler.\");\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            this.refreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAndPublish();\n+        } else {\n+            logger.debug(\"The Meteo Alerte binding is read-only and can not handle command {}\", command);\n+        }\n+    }\n+\n+    private void updateAndPublish() {\n+        try {\n+            if (queryUrl.isEmpty()) {\n+                throw new MalformedURLException(\"queryUrl not initialized\");\n+            }\n+            String response = HttpUtil.executeUrl(\"GET\", queryUrl, TIMEOUT_MS);\n+            updateStatus(ThingStatus.ONLINE);\n+            ApiResponse apiResponse = gson.fromJson(response, ApiResponse.class);\n+            updateChannels(apiResponse);\n+        } catch (MalformedURLException e) {\n+            logger.warn(\"Malformed URL in M\u00e9t\u00e9o Alerte request : {}\", queryUrl);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+        } catch (IOException e) {\n+            logger.warn(\"Error opening connection to Meteo Alerte webservice : {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Meteo Alerte data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannels(ApiResponse apiResponse) {\n+        Arrays.stream(apiResponse.getRecords()).findFirst().ifPresent(record -> {\n+            record.getFields().ifPresent(fields -> {\n+                updateAlertString(WIND, fields.getVent());\n+                updateAlertString(RAIN, fields.getPluieInondation());\n+                updateAlertString(STORM, fields.getOrage());\n+                updateAlertString(FLOOD, fields.getInondation());\n+                updateAlertString(SNOW, fields.getNeige());\n+                updateAlertString(HEAT, fields.getCanicule());\n+                updateAlertString(FREEZE, fields.getGrandFroid());\n+                updateAlertString(AVALANCHE, fields.getAvalanches());\n+\n+                fields.getDateInsert().ifPresent(date -> updateDate(OBSERVATION_TIME, date));\n+                updateState(COMMENT, new StringType(fields.getVigilanceComment()));\n+                updateIcon(WIND, fields.getVent());\n+                updateIcon(RAIN, fields.getPluieInondation());\n+                updateIcon(STORM, fields.getOrage());\n+                updateIcon(FLOOD, fields.getInondation());\n+                updateIcon(SNOW, fields.getNeige());\n+                updateIcon(HEAT, fields.getCanicule());\n+                updateIcon(FREEZE, fields.getGrandFroid());\n+                updateIcon(AVALANCHE, fields.getAvalanches());\n+            });\n+        });", "originalCommit": "9e1886cd2c01f4b02f1c7aa93137b786074a5b8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY2MjcxMA==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r430662710", "bodyText": "Can be refactored in OH3 with in.readAllBytes() (available in JDK9+) (just a comment)", "author": "J-N-K", "createdAt": "2020-05-26T19:40:33Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/handler/MeteoAlerteHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.handler;\n+\n+import static org.openhab.binding.meteoalerte.internal.MeteoAlerteBindingConstants.*;\n+\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.TimeZoneProvider;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.meteoalerte.internal.MeteoAlerteConfiguration;\n+import org.openhab.binding.meteoalerte.internal.json.ApiResponse;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializer;\n+\n+/**\n+ * The {@link MeteoAlerteHandler} is responsible for updating channels\n+ * and querying the API\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MeteoAlerteHandler extends BaseThingHandler {\n+    private static final String URL = \"https://public.opendatasoft.com/api/records/1.0/search/?dataset=risques-meteorologiques-copy&\"\n+            + \"facet=etat_vent&facet=etat_pluie_inondation&facet=etat_orage&facet=etat_inondation&facet=etat_neige&facet=etat_canicule&\"\n+            + \"facet=etat_grand_froid&facet=etat_avalanches&refine.nom_dept=\";\n+    private static final int TIMEOUT_MS = 30000;\n+    private static final List<String> ALERT_LEVELS = Arrays.asList(\"Vert\", \"Jaune\", \"Orange\", \"Rouge\");\n+    private final Logger logger = LoggerFactory.getLogger(MeteoAlerteHandler.class);\n+    private final Gson gson = new GsonBuilder()\n+            .registerTypeAdapter(ZonedDateTime.class, (JsonDeserializer<ZonedDateTime>) (json, type,\n+                    jsonDeserializationContext) -> ZonedDateTime.parse(json.getAsJsonPrimitive().getAsString()))\n+            .create();\n+\n+    // Time zone provider representing time zone configured in openHAB configuration\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private String queryUrl = \"\";\n+\n+    public MeteoAlerteHandler(Thing thing, TimeZoneProvider timeZoneProvider) {\n+        super(thing);\n+        this.timeZoneProvider = timeZoneProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing M\u00e9t\u00e9o Alerte handler.\");\n+\n+        MeteoAlerteConfiguration config = getConfigAs(MeteoAlerteConfiguration.class);\n+        logger.debug(\"config department = {}\", config.department);\n+        logger.debug(\"config refresh = {}\", config.refresh);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        queryUrl = URL + config.department;\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateAndPublish, 0, config.refresh, TimeUnit.HOURS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the M\u00e9t\u00e9o Alerte handler.\");\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            this.refreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAndPublish();\n+        } else {\n+            logger.debug(\"The Meteo Alerte binding is read-only and can not handle command {}\", command);\n+        }\n+    }\n+\n+    private void updateAndPublish() {\n+        try {\n+            if (queryUrl.isEmpty()) {\n+                throw new MalformedURLException(\"queryUrl not initialized\");\n+            }\n+            String response = HttpUtil.executeUrl(\"GET\", queryUrl, TIMEOUT_MS);\n+            updateStatus(ThingStatus.ONLINE);\n+            ApiResponse apiResponse = gson.fromJson(response, ApiResponse.class);\n+            updateChannels(apiResponse);\n+        } catch (MalformedURLException e) {\n+            logger.warn(\"Malformed URL in M\u00e9t\u00e9o Alerte request : {}\", queryUrl);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+        } catch (IOException e) {\n+            logger.warn(\"Error opening connection to Meteo Alerte webservice : {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Meteo Alerte data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannels(ApiResponse apiResponse) {\n+        Arrays.stream(apiResponse.getRecords()).findFirst().ifPresent(record -> {\n+            record.getFields().ifPresent(fields -> {\n+                updateAlertString(WIND, fields.getVent());\n+                updateAlertString(RAIN, fields.getPluieInondation());\n+                updateAlertString(STORM, fields.getOrage());\n+                updateAlertString(FLOOD, fields.getInondation());\n+                updateAlertString(SNOW, fields.getNeige());\n+                updateAlertString(HEAT, fields.getCanicule());\n+                updateAlertString(FREEZE, fields.getGrandFroid());\n+                updateAlertString(AVALANCHE, fields.getAvalanches());\n+\n+                fields.getDateInsert().ifPresent(date -> updateDate(OBSERVATION_TIME, date));\n+                updateState(COMMENT, new StringType(fields.getVigilanceComment()));\n+                updateIcon(WIND, fields.getVent());\n+                updateIcon(RAIN, fields.getPluieInondation());\n+                updateIcon(STORM, fields.getOrage());\n+                updateIcon(FLOOD, fields.getInondation());\n+                updateIcon(SNOW, fields.getNeige());\n+                updateIcon(HEAT, fields.getCanicule());\n+                updateIcon(FREEZE, fields.getGrandFroid());\n+                updateIcon(AVALANCHE, fields.getAvalanches());\n+            });\n+        });\n+    }\n+\n+    public void updateIcon(String channelId, String value) {\n+        String iconChannelId = channelId + \"-icon\";\n+        if (isLinked(iconChannelId)) {\n+            String pictoName = channelId + (!value.isEmpty() ? \"_\" + value.toLowerCase() : \"\");\n+            byte[] image = getImage(\"picto\" + File.separator + pictoName + \".gif\");\n+            if (image != null) {\n+                RawType picto = new RawType(image, \"image/gif\");\n+                updateState(iconChannelId, picto);\n+            }\n+        }\n+    }\n+\n+    private byte @Nullable [] getImage(String iconPath) {\n+        URL url = FrameworkUtil.getBundle(getClass()).getResource(iconPath);\n+        logger.debug(\"Path to icon image resource is: {}\", url);\n+        try (InputStream in = new BufferedInputStream(url.openStream())) {\n+            ByteArrayOutputStream bos = new ByteArrayOutputStream();", "originalCommit": "9e1886cd2c01f4b02f1c7aa93137b786074a5b8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY2NDY3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r430664672", "bodyText": "I would prefer a name that is not so close to a standard java class name (Field). Maybe ResponseFieldDTO, WDYT?", "author": "J-N-K", "createdAt": "2020-05-26T19:43:11Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/json/Fields.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.meteoalerte.internal.json;\n+\n+import java.time.ZonedDateTime;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * The {@link Fields} is the Java class used to map the JSON\n+ * response to the webservice request.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Fields {", "originalCommit": "9e1886cd2c01f4b02f1c7aa93137b786074a5b8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7c3297163ee0681fb08c3d1009ee9498e8a1206c", "url": "https://github.com/openhab/openhab-addons/commit/7c3297163ee0681fb08c3d1009ee9498e8a1206c", "message": "Code review enhancements\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-05-27T07:48:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkyNzY4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7200#discussion_r430927683", "bodyText": "1440", "author": "lolodomo", "createdAt": "2020-05-27T07:58:35Z", "path": "bundles/org.openhab.binding.meteoalerte/src/main/java/org/openhab/binding/meteoalerte/internal/MeteoAlerteConfiguration.java", "diffHunk": "@@ -23,5 +23,5 @@\n @NonNullByDefault\n public class MeteoAlerteConfiguration {\n     public String department = \"\";\n-    public Integer refresh = 24;\n+    public Integer refresh = 1400;", "originalCommit": "7c3297163ee0681fb08c3d1009ee9498e8a1206c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "303cb20f0e74a045fb038f6d2461c5fe91bb6dc3", "url": "https://github.com/openhab/openhab-addons/commit/303cb20f0e74a045fb038f6d2461c5fe91bb6dc3", "message": "Typo\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-05-27T08:06:48Z", "type": "commit"}]}