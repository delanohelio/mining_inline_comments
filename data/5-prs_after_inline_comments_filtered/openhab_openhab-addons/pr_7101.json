{"pr_number": 7101, "pr_title": "[linky] Linky binding", "pr_createdAt": "2020-03-05T09:47:49Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7101", "timeline": [{"oid": "6fafb9ef1a77ba0e01c577023f1c9f8f912ea59a", "url": "https://github.com/openhab/openhab-addons/commit/6fafb9ef1a77ba0e01c577023f1c9f8f912ea59a", "message": "Clean new PR for Linky binding\n\nSigned-off-by: Ga\u00ebl L'hopital <gael@lhopital.org>", "committedDate": "2020-03-05T09:46:17Z", "type": "commit"}, {"oid": "730a3c0cc8bf606279e8660930db27874e2b79c4", "url": "https://github.com/openhab/openhab-addons/commit/730a3c0cc8bf606279e8660930db27874e2b79c4", "message": "Missing bom file\n\nSigned-off-by: Ga\u00ebl L'hopital <gael@lhopital.org>", "committedDate": "2020-03-05T09:49:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI0NjU3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r388246574", "bodyText": "Could you please add @NonNullByDefault to this class (sorry, I forgot to do it).", "author": "lolodomo", "createdAt": "2020-03-05T11:53:27Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/console/LinkyCommandExtension.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.console;\n+\n+import java.time.LocalDate;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingRegistry;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.console.Console;\n+import org.eclipse.smarthome.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.eclipse.smarthome.io.console.extensions.ConsoleCommandExtension;\n+import org.openhab.binding.linky.internal.handler.LinkyHandler;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link LinkyCommandExtension} is responsible for handling console commands\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@Component(service = ConsoleCommandExtension.class)\n+public class LinkyCommandExtension extends AbstractConsoleCommandExtension {", "originalCommit": "730a3c0cc8bf606279e8660930db27874e2b79c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI0NjkxOA==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r388246918", "bodyText": "This could be replaced by a Reference parameter in the constructor.", "author": "lolodomo", "createdAt": "2020-03-05T11:54:14Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/console/LinkyCommandExtension.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.console;\n+\n+import java.time.LocalDate;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingRegistry;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.console.Console;\n+import org.eclipse.smarthome.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.eclipse.smarthome.io.console.extensions.ConsoleCommandExtension;\n+import org.openhab.binding.linky.internal.handler.LinkyHandler;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link LinkyCommandExtension} is responsible for handling console commands\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@Component(service = ConsoleCommandExtension.class)\n+public class LinkyCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String REPORT = \"report\";\n+\n+    private ThingRegistry thingRegistry;\n+\n+    public LinkyCommandExtension() {\n+        super(\"linky\", \"Interact with the Linky binding.\");\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length >= 2) {\n+            LinkyHandler handler = null;\n+            try {\n+                ThingUID thingUID = new ThingUID(args[0]);\n+                Thing thing = thingRegistry.get(thingUID);\n+                if ((thing != null) && (thing.getHandler() != null) && (thing.getHandler() instanceof LinkyHandler)) {\n+                    handler = (LinkyHandler) thing.getHandler();\n+                }\n+            } catch (Exception e) {\n+                handler = null;\n+            }\n+            if (handler == null) {\n+                console.println(\"Bad thing id '\" + args[0] + \"'\");\n+                printUsage(console);\n+            } else {\n+                switch (args[1]) {\n+                    case REPORT:\n+                        LocalDate now = LocalDate.now();\n+                        LocalDate start = now.minusDays(7);\n+                        LocalDate end = now.minusDays(1);\n+                        String separator = \" \";\n+                        if (args.length >= 3) {\n+                            try {\n+                                start = LocalDate.parse(args[2], DateTimeFormatter.ISO_LOCAL_DATE);\n+                            } catch (DateTimeParseException e) {\n+                                console.println(\"Invalid format for start day '\" + args[2]\n+                                        + \"'; expected format is YYYY-MM-DD\");\n+                                printUsage(console);\n+                                break;\n+                            }\n+                        }\n+                        if (args.length >= 4) {\n+                            try {\n+                                end = LocalDate.parse(args[3], DateTimeFormatter.ISO_LOCAL_DATE);\n+                            } catch (DateTimeParseException e) {\n+                                console.println(\n+                                        \"Invalid format for end day '\" + args[3] + \"'; expected format is YYYY-MM-DD\");\n+                                printUsage(console);\n+                                break;\n+                            }\n+                        }\n+                        if (!start.isBefore(now)) {\n+                            console.println(\"Start day must be in the past\");\n+                            printUsage(console);\n+                            break;\n+                        }\n+                        if (start.isAfter(end)) {\n+                            console.println(\"Start day must be earlier than end day\");\n+                            printUsage(console);\n+                            break;\n+                        }\n+                        if (end.isAfter(now.minusDays(1))) {\n+                            end = now.minusDays(1);\n+                        }\n+                        if (args.length >= 5) {\n+                            separator = args[4];\n+                        }\n+                        for (String line : handler.reportValues(start, end, separator).split(\"\\n\")) {\n+                            console.println(line);\n+                        }\n+                        break;\n+                    default:\n+                        console.println(\"Unknown Linky sub command '\" + args[1] + \"'\");\n+                        printUsage(console);\n+                        break;\n+                }\n+            }\n+        } else {\n+            printUsage(console);\n+        }\n+    }\n+\n+    @Override\n+    public List<String> getUsages() {\n+        return Arrays.asList(\n+                new String[] { buildCommandUsage(\"<thingUID> \" + REPORT + \" <start day> <end day> [<separator>]\",\n+                        \"report daily consumptions between two dates\") });\n+    }\n+\n+    @Reference", "originalCommit": "730a3c0cc8bf606279e8660930db27874e2b79c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI0OTA3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r388249071", "bodyText": "In other bindings, you find ComponentContext as parameter of activate and deactivate methods but not as parameter of the constructor.\nIs this parameter really necessary here ?", "author": "lolodomo", "createdAt": "2020-03-05T11:58:58Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/LinkyHandlerFactory.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.THING_TYPE_LINKY;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.binding.linky.internal.handler.LinkyHandler;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link LinkyHandlerFactory} is responsible for creating things handlers.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, configurationPid = \"binding.linky\")\n+public class LinkyHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final LocaleProvider localeProvider;\n+\n+    @Activate\n+    public LinkyHandlerFactory(final @Reference LocaleProvider localeProvider, ComponentContext componentContext) {", "originalCommit": "730a3c0cc8bf606279e8660930db27874e2b79c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5NDc5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r388294799", "bodyText": "You're right.", "author": "clinique", "createdAt": "2020-03-05T13:34:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI0OTA3MQ=="}], "type": "inlineReview"}, {"oid": "ca24f3c60dbe4244f0ac1c2a64db4810d0d75582", "url": "https://github.com/openhab/openhab-addons/commit/ca24f3c60dbe4244f0ac1c2a64db4810d0d75582", "message": "Code review corrections\n\nSigned-off-by: Ga\u00ebl L'hopital <gael@lhopital.org>", "committedDate": "2020-03-05T13:35:55Z", "type": "commit"}, {"oid": "4380fdb26e67dc341c0567a290f79267d46dfe34", "url": "https://github.com/openhab/openhab-addons/commit/4380fdb26e67dc341c0567a290f79267d46dfe34", "message": "Debugging\n\nSigned-off-by: Ga\u00ebl L'hopital <gael@lhopital.org>", "committedDate": "2020-03-06T08:18:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTk3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r390011975", "bodyText": "Please make these final", "author": "cpmeister", "createdAt": "2020-03-09T23:15:20Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;", "originalCommit": "4380fdb26e67dc341c0567a290f79267d46dfe34", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMjUyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r390012524", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    scheduler.schedule(this::login, 0, TimeUnit.SECONDS);\n          \n          \n            \n                    scheduler.execute(this::login);", "author": "cpmeister", "createdAt": "2020-03-09T23:16:58Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+\n+        scheduler.schedule(this::login, 0, TimeUnit.SECONDS);", "originalCommit": "4380fdb26e67dc341c0567a290f79267d46dfe34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU3NTI0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r392575246", "bodyText": "This method does not existwithout parameters", "author": "clinique", "createdAt": "2020-03-14T10:37:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMjUyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0MzE1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r395443158", "bodyText": "How about this then?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    scheduler.schedule(this::login, 0, TimeUnit.SECONDS);\n          \n          \n            \n                    scheduler.submit(this::login);", "author": "cpmeister", "createdAt": "2020-03-20T05:20:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMjUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNzA3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r392527079", "bodyText": "What exception are you expecting here?", "author": "cpmeister", "createdAt": "2020-03-13T23:29:20Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/console/LinkyCommandExtension.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.console;\n+\n+import java.time.LocalDate;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingRegistry;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.console.Console;\n+import org.eclipse.smarthome.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.eclipse.smarthome.io.console.extensions.ConsoleCommandExtension;\n+import org.openhab.binding.linky.internal.handler.LinkyHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link LinkyCommandExtension} is responsible for handling console commands\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@Component(service = ConsoleCommandExtension.class)\n+public class LinkyCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String REPORT = \"report\";\n+\n+    private final ThingRegistry thingRegistry;\n+\n+    @Activate\n+    public LinkyCommandExtension(final @Reference ThingRegistry thingRegistry) {\n+        super(\"linky\", \"Interact with the Linky binding.\");\n+        this.thingRegistry = thingRegistry;\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length >= 2) {\n+            LinkyHandler handler = null;\n+            try {\n+                ThingUID thingUID = new ThingUID(args[0]);\n+                Thing thing = thingRegistry.get(thingUID);\n+                if ((thing != null) && (thing.getHandler() != null) && (thing.getHandler() instanceof LinkyHandler)) {\n+                    handler = (LinkyHandler) thing.getHandler();\n+                }\n+            } catch (Exception e) {", "originalCommit": "4380fdb26e67dc341c0567a290f79267d46dfe34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU3MTM3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r392571372", "bodyText": "At least, I see that new ThingUID(args[0]) could throw IllegalArgumentException.\nI don't think thingRegistry.get(thingUID) can throw any exception.\nSo Exception could probably be replaced by IllegalArgumentException.\nIn fact, I copied this pattern from my Powermax binding.", "author": "lolodomo", "createdAt": "2020-03-14T09:29:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNzA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU3NTgxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r392575813", "bodyText": "Changed to IllegalArgumentException", "author": "clinique", "createdAt": "2020-03-14T10:47:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNzA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNzg4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r392527884", "bodyText": "please call updateStatus(ThingStatus.UNKNOWN); just in case something goes horribly wrong with the login that the Thing will be in a valid state.", "author": "cpmeister", "createdAt": "2020-03-13T23:33:36Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");", "originalCommit": "4380fdb26e67dc341c0567a290f79267d46dfe34", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "43039363b2e2795c326571cf80a034f1c0a90a5a", "url": "https://github.com/openhab/openhab-addons/commit/43039363b2e2795c326571cf80a034f1c0a90a5a", "message": "Corrections after code review\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-03-14T10:42:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcwMzQwNw==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r392703407", "bodyText": "Are more commands expected here in the future? If not, this switch statement should be changed to an if statement.", "author": "cpmeister", "createdAt": "2020-03-15T19:15:22Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/console/LinkyCommandExtension.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.console;\n+\n+import java.time.LocalDate;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingRegistry;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.console.Console;\n+import org.eclipse.smarthome.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.eclipse.smarthome.io.console.extensions.ConsoleCommandExtension;\n+import org.openhab.binding.linky.internal.handler.LinkyHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link LinkyCommandExtension} is responsible for handling console commands\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@Component(service = ConsoleCommandExtension.class)\n+public class LinkyCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String REPORT = \"report\";\n+\n+    private final ThingRegistry thingRegistry;\n+\n+    @Activate\n+    public LinkyCommandExtension(final @Reference ThingRegistry thingRegistry) {\n+        super(\"linky\", \"Interact with the Linky binding.\");\n+        this.thingRegistry = thingRegistry;\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length >= 2) {\n+            LinkyHandler handler = null;\n+            try {\n+                ThingUID thingUID = new ThingUID(args[0]);\n+                Thing thing = thingRegistry.get(thingUID);\n+                if ((thing != null) && (thing.getHandler() != null) && (thing.getHandler() instanceof LinkyHandler)) {\n+                    handler = (LinkyHandler) thing.getHandler();\n+                }\n+            } catch (IllegalArgumentException e) {\n+                handler = null;\n+            }\n+            if (handler == null) {\n+                console.println(\"Bad thing id '\" + args[0] + \"'\");\n+                printUsage(console);\n+            } else {\n+                switch (args[1]) {\n+                    case REPORT:", "originalCommit": "43039363b2e2795c326571cf80a034f1c0a90a5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ1MzE3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r395453175", "bodyText": "As I implemented this part, I can answer there is no immediate plan to add other commands.", "author": "lolodomo", "createdAt": "2020-03-20T06:15:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcwMzQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0MzQ5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r395443491", "bodyText": "I think this is more understandable at a glance.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        lastMonth = result.getData().get(jump++).valeur;\n          \n          \n            \n                        thisMonth = result.getData().get(jump).valeur;\n          \n          \n            \n                        lastMonth = result.getData().get(jump).valeur;\n          \n          \n            \n                        thisMonth = result.getData().get(jump+1).valeur;", "author": "cpmeister", "createdAt": "2020-03-20T05:22:09Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.schedule(this::login, 0, TimeUnit.SECONDS);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        try {\n+            Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                    .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                    .build();\n+            Response response = client.newCall(requestLogin).execute();\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            response.close();\n+\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        double lastWeek = -1;\n+        double thisWeek = -1;\n+        double yesterday = -1;\n+        LinkyConsumptionData result = cachedDaylyData.getValue();\n+        if (result != null && result.success()) {\n+            LocalDate rangeStart = LocalDate.now().minusDays(13);\n+            int jump = result.getDecalage();\n+            while (rangeStart.getDayOfWeek() != weekFields.getFirstDayOfWeek()) {\n+                rangeStart = rangeStart.plusDays(1);\n+                jump++;\n+            }\n+\n+            int lastWeekNumber = rangeStart.get(weekFields.weekOfWeekBasedYear());\n+\n+            lastWeek = 0;\n+            thisWeek = 0;\n+            yesterday = -1;\n+            while (jump < result.getData().size()) {\n+                double consumption = result.getData().get(jump).valeur;\n+                if (consumption > 0) {\n+                    if (rangeStart.get(weekFields.weekOfWeekBasedYear()) == lastWeekNumber) {\n+                        lastWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to last week: {}\", jump, consumption);\n+                    } else {\n+                        thisWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to current week: {}\", jump, consumption);\n+                    }\n+                    yesterday = consumption;\n+                }\n+                jump++;\n+                rangeStart = rangeStart.plusDays(1);\n+            }\n+        } else {\n+            cachedDaylyData.invalidateValue();\n+        }\n+        updateKwhChannel(YESTERDAY, yesterday);\n+        updateKwhChannel(THIS_WEEK, thisWeek);\n+        updateKwhChannel(LAST_WEEK, lastWeek);\n+    }\n+\n+    /**\n+     * Request new monthly data and updates channels\n+     */\n+    private synchronized void updateMonthlyData() {\n+        if (!isLinked(LAST_MONTH) && !isLinked(THIS_MONTH)) {\n+            return;\n+        }\n+\n+        double lastMonth = -1;\n+        double thisMonth = -1;\n+        LinkyConsumptionData result = cachedMonthlyData.getValue();\n+        if (result != null && result.success()) {\n+            int jump = result.getDecalage();\n+            lastMonth = result.getData().get(jump++).valeur;\n+            thisMonth = result.getData().get(jump).valeur;", "originalCommit": "43039363b2e2795c326571cf80a034f1c0a90a5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ1NjcyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r395456726", "bodyText": "I agree.", "author": "lolodomo", "createdAt": "2020-03-20T06:33:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0MzQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0MzY1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r395443657", "bodyText": "Please use StringBuilder instead of string concatenation to build up this value.", "author": "cpmeister", "createdAt": "2020-03-20T05:23:03Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.schedule(this::login, 0, TimeUnit.SECONDS);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        try {\n+            Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                    .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                    .build();\n+            Response response = client.newCall(requestLogin).execute();\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            response.close();\n+\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        double lastWeek = -1;\n+        double thisWeek = -1;\n+        double yesterday = -1;\n+        LinkyConsumptionData result = cachedDaylyData.getValue();\n+        if (result != null && result.success()) {\n+            LocalDate rangeStart = LocalDate.now().minusDays(13);\n+            int jump = result.getDecalage();\n+            while (rangeStart.getDayOfWeek() != weekFields.getFirstDayOfWeek()) {\n+                rangeStart = rangeStart.plusDays(1);\n+                jump++;\n+            }\n+\n+            int lastWeekNumber = rangeStart.get(weekFields.weekOfWeekBasedYear());\n+\n+            lastWeek = 0;\n+            thisWeek = 0;\n+            yesterday = -1;\n+            while (jump < result.getData().size()) {\n+                double consumption = result.getData().get(jump).valeur;\n+                if (consumption > 0) {\n+                    if (rangeStart.get(weekFields.weekOfWeekBasedYear()) == lastWeekNumber) {\n+                        lastWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to last week: {}\", jump, consumption);\n+                    } else {\n+                        thisWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to current week: {}\", jump, consumption);\n+                    }\n+                    yesterday = consumption;\n+                }\n+                jump++;\n+                rangeStart = rangeStart.plusDays(1);\n+            }\n+        } else {\n+            cachedDaylyData.invalidateValue();\n+        }\n+        updateKwhChannel(YESTERDAY, yesterday);\n+        updateKwhChannel(THIS_WEEK, thisWeek);\n+        updateKwhChannel(LAST_WEEK, lastWeek);\n+    }\n+\n+    /**\n+     * Request new monthly data and updates channels\n+     */\n+    private synchronized void updateMonthlyData() {\n+        if (!isLinked(LAST_MONTH) && !isLinked(THIS_MONTH)) {\n+            return;\n+        }\n+\n+        double lastMonth = -1;\n+        double thisMonth = -1;\n+        LinkyConsumptionData result = cachedMonthlyData.getValue();\n+        if (result != null && result.success()) {\n+            int jump = result.getDecalage();\n+            lastMonth = result.getData().get(jump++).valeur;\n+            thisMonth = result.getData().get(jump).valeur;\n+            if (thisMonth < 0) {\n+                thisMonth = 0;\n+            }\n+        } else {\n+            cachedMonthlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_MONTH, lastMonth);\n+        updateKwhChannel(THIS_MONTH, thisMonth);\n+    }\n+\n+    /**\n+     * Request new yearly data and updates channels\n+     */\n+    private synchronized void updateYearlyData() {\n+        if (!isLinked(LAST_YEAR) && !isLinked(THIS_YEAR)) {\n+            return;\n+        }\n+\n+        double thisYear = -1;\n+        double lastYear = -1;\n+        LinkyConsumptionData result = cachedYearlyData.getValue();\n+        if (result != null && result.success()) {\n+            int elementQuantity = result.getData().size();\n+            thisYear = elementQuantity > 0 ? result.getData().get(elementQuantity - 1).valeur : -1;\n+            lastYear = elementQuantity > 1 ? result.getData().get(elementQuantity - 2).valeur : -1;\n+        } else {\n+            cachedYearlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_YEAR, lastYear);\n+        updateKwhChannel(THIS_YEAR, thisYear);\n+    }\n+\n+    private void updateKwhChannel(String channelId, double consumption) {\n+        logger.debug(\"Update channel {} with {}\", channelId, consumption);\n+        updateState(channelId,\n+                consumption != -1 ? new QuantityType<>(consumption, SmartHomeUnits.KILOWATT_HOUR) : UnDefType.UNDEF);\n+    }\n+\n+    /**\n+     * Produce a report of all daily values between two dates\n+     *\n+     * @param startDay the start day of the report\n+     * @param endDay the end day of the report\n+     * @param separator the separator to be used betwwen the date and the value\n+     *\n+     * @return the report as a string\n+     */\n+    public String reportValues(LocalDate startDay, LocalDate endDay, @Nullable String separator) {\n+        String dump = \"\";", "originalCommit": "43039363b2e2795c326571cf80a034f1c0a90a5a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0Mzk5OA==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r395443998", "bodyText": "Surely there is a way to implement this without recursion right?", "author": "cpmeister", "createdAt": "2020-03-20T05:24:56Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.schedule(this::login, 0, TimeUnit.SECONDS);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        try {\n+            Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                    .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                    .build();\n+            Response response = client.newCall(requestLogin).execute();\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            response.close();\n+\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        double lastWeek = -1;\n+        double thisWeek = -1;\n+        double yesterday = -1;\n+        LinkyConsumptionData result = cachedDaylyData.getValue();\n+        if (result != null && result.success()) {\n+            LocalDate rangeStart = LocalDate.now().minusDays(13);\n+            int jump = result.getDecalage();\n+            while (rangeStart.getDayOfWeek() != weekFields.getFirstDayOfWeek()) {\n+                rangeStart = rangeStart.plusDays(1);\n+                jump++;\n+            }\n+\n+            int lastWeekNumber = rangeStart.get(weekFields.weekOfWeekBasedYear());\n+\n+            lastWeek = 0;\n+            thisWeek = 0;\n+            yesterday = -1;\n+            while (jump < result.getData().size()) {\n+                double consumption = result.getData().get(jump).valeur;\n+                if (consumption > 0) {\n+                    if (rangeStart.get(weekFields.weekOfWeekBasedYear()) == lastWeekNumber) {\n+                        lastWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to last week: {}\", jump, consumption);\n+                    } else {\n+                        thisWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to current week: {}\", jump, consumption);\n+                    }\n+                    yesterday = consumption;\n+                }\n+                jump++;\n+                rangeStart = rangeStart.plusDays(1);\n+            }\n+        } else {\n+            cachedDaylyData.invalidateValue();\n+        }\n+        updateKwhChannel(YESTERDAY, yesterday);\n+        updateKwhChannel(THIS_WEEK, thisWeek);\n+        updateKwhChannel(LAST_WEEK, lastWeek);\n+    }\n+\n+    /**\n+     * Request new monthly data and updates channels\n+     */\n+    private synchronized void updateMonthlyData() {\n+        if (!isLinked(LAST_MONTH) && !isLinked(THIS_MONTH)) {\n+            return;\n+        }\n+\n+        double lastMonth = -1;\n+        double thisMonth = -1;\n+        LinkyConsumptionData result = cachedMonthlyData.getValue();\n+        if (result != null && result.success()) {\n+            int jump = result.getDecalage();\n+            lastMonth = result.getData().get(jump++).valeur;\n+            thisMonth = result.getData().get(jump).valeur;\n+            if (thisMonth < 0) {\n+                thisMonth = 0;\n+            }\n+        } else {\n+            cachedMonthlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_MONTH, lastMonth);\n+        updateKwhChannel(THIS_MONTH, thisMonth);\n+    }\n+\n+    /**\n+     * Request new yearly data and updates channels\n+     */\n+    private synchronized void updateYearlyData() {\n+        if (!isLinked(LAST_YEAR) && !isLinked(THIS_YEAR)) {\n+            return;\n+        }\n+\n+        double thisYear = -1;\n+        double lastYear = -1;\n+        LinkyConsumptionData result = cachedYearlyData.getValue();\n+        if (result != null && result.success()) {\n+            int elementQuantity = result.getData().size();\n+            thisYear = elementQuantity > 0 ? result.getData().get(elementQuantity - 1).valeur : -1;\n+            lastYear = elementQuantity > 1 ? result.getData().get(elementQuantity - 2).valeur : -1;\n+        } else {\n+            cachedYearlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_YEAR, lastYear);\n+        updateKwhChannel(THIS_YEAR, thisYear);\n+    }\n+\n+    private void updateKwhChannel(String channelId, double consumption) {\n+        logger.debug(\"Update channel {} with {}\", channelId, consumption);\n+        updateState(channelId,\n+                consumption != -1 ? new QuantityType<>(consumption, SmartHomeUnits.KILOWATT_HOUR) : UnDefType.UNDEF);\n+    }\n+\n+    /**\n+     * Produce a report of all daily values between two dates\n+     *\n+     * @param startDay the start day of the report\n+     * @param endDay the end day of the report\n+     * @param separator the separator to be used betwwen the date and the value\n+     *\n+     * @return the report as a string\n+     */\n+    public String reportValues(LocalDate startDay, LocalDate endDay, @Nullable String separator) {\n+        String dump = \"\";\n+        if (startDay.getYear() == endDay.getYear() && startDay.getMonthValue() == endDay.getMonthValue()) {\n+            // All values in the same month\n+            LinkyConsumptionData result = getConsumptionData(DAILY, startDay, endDay, true);\n+            if (result != null && result.success()) {\n+                LocalDate currentDay = startDay;\n+                int jump = result.getDecalage();\n+                while (jump < result.getData().size() && !currentDay.isAfter(endDay)) {\n+                    double consumption = result.getData().get(jump).valeur;\n+                    dump += currentDay.format(DateTimeFormatter.ISO_LOCAL_DATE) + separator;\n+                    if (consumption >= 0) {\n+                        dump += String.valueOf(consumption);\n+                    }\n+                    dump += \"\\n\";\n+                    jump++;\n+                    currentDay = currentDay.plusDays(1);\n+                }\n+            } else {\n+                LocalDate currentDay = startDay;\n+                while (!currentDay.isAfter(endDay)) {\n+                    dump += currentDay.format(DateTimeFormatter.ISO_LOCAL_DATE) + separator + \"\\n\";\n+                    currentDay = currentDay.plusDays(1);\n+                }\n+            }\n+        } else {\n+            // Concatenate the report produced for each month between the two dates\n+            LocalDate first = startDay;\n+            do {\n+                LocalDate last = first.withDayOfMonth(first.lengthOfMonth());\n+                if (last.isAfter(endDay)) {\n+                    last = endDay;\n+                }\n+                dump += reportValues(first, last, separator);", "originalCommit": "43039363b2e2795c326571cf80a034f1c0a90a5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ1NjI2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r395456264", "bodyText": "Why not using recursion ? This looks perfectly natural to me in this case.\nBut yes, I think this could be avoided by creating a method reportValuesForMonth that would contain mainly the code from the if branch.\n@clinique: let me know if you need my help", "author": "lolodomo", "createdAt": "2020-03-20T06:30:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0Mzk5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ2OTUzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r395469538", "bodyText": "I would keep recursion also.", "author": "clinique", "createdAt": "2020-03-20T07:23:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0Mzk5OA=="}], "type": "inlineReview"}, {"oid": "00bed837d677a440e07ef1e33ff891b470a852bb", "url": "https://github.com/openhab/openhab-addons/commit/00bed837d677a440e07ef1e33ff891b470a852bb", "message": "Code review corrections\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-03-20T07:25:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwNjg3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r395906876", "bodyText": "Instead of -1, use Double.NaN to represent the the absence of data. This makes the code look safer as well as using an already existing definition for bad data.", "author": "cpmeister", "createdAt": "2020-03-20T21:55:03Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        try {\n+            Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                    .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                    .build();\n+            Response response = client.newCall(requestLogin).execute();\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            response.close();\n+\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        double lastWeek = -1;\n+        double thisWeek = -1;\n+        double yesterday = -1;\n+        LinkyConsumptionData result = cachedDaylyData.getValue();\n+        if (result != null && result.success()) {\n+            LocalDate rangeStart = LocalDate.now().minusDays(13);\n+            int jump = result.getDecalage();\n+            while (rangeStart.getDayOfWeek() != weekFields.getFirstDayOfWeek()) {\n+                rangeStart = rangeStart.plusDays(1);\n+                jump++;\n+            }\n+\n+            int lastWeekNumber = rangeStart.get(weekFields.weekOfWeekBasedYear());\n+\n+            lastWeek = 0;\n+            thisWeek = 0;\n+            yesterday = -1;\n+            while (jump < result.getData().size()) {\n+                double consumption = result.getData().get(jump).valeur;\n+                if (consumption > 0) {\n+                    if (rangeStart.get(weekFields.weekOfWeekBasedYear()) == lastWeekNumber) {\n+                        lastWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to last week: {}\", jump, consumption);\n+                    } else {\n+                        thisWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to current week: {}\", jump, consumption);\n+                    }\n+                    yesterday = consumption;\n+                }\n+                jump++;\n+                rangeStart = rangeStart.plusDays(1);\n+            }\n+        } else {\n+            cachedDaylyData.invalidateValue();\n+        }\n+        updateKwhChannel(YESTERDAY, yesterday);\n+        updateKwhChannel(THIS_WEEK, thisWeek);\n+        updateKwhChannel(LAST_WEEK, lastWeek);\n+    }\n+\n+    /**\n+     * Request new monthly data and updates channels\n+     */\n+    private synchronized void updateMonthlyData() {\n+        if (!isLinked(LAST_MONTH) && !isLinked(THIS_MONTH)) {\n+            return;\n+        }\n+\n+        double lastMonth = -1;\n+        double thisMonth = -1;\n+        LinkyConsumptionData result = cachedMonthlyData.getValue();\n+        if (result != null && result.success()) {\n+            int jump = result.getDecalage();\n+            lastMonth = result.getData().get(jump).valeur;\n+            thisMonth = result.getData().get(jump + 1).valeur;\n+            if (thisMonth < 0) {\n+                thisMonth = 0;\n+            }\n+        } else {\n+            cachedMonthlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_MONTH, lastMonth);\n+        updateKwhChannel(THIS_MONTH, thisMonth);\n+    }\n+\n+    /**\n+     * Request new yearly data and updates channels\n+     */\n+    private synchronized void updateYearlyData() {\n+        if (!isLinked(LAST_YEAR) && !isLinked(THIS_YEAR)) {\n+            return;\n+        }\n+\n+        double thisYear = -1;\n+        double lastYear = -1;\n+        LinkyConsumptionData result = cachedYearlyData.getValue();\n+        if (result != null && result.success()) {\n+            int elementQuantity = result.getData().size();\n+            thisYear = elementQuantity > 0 ? result.getData().get(elementQuantity - 1).valeur : -1;\n+            lastYear = elementQuantity > 1 ? result.getData().get(elementQuantity - 2).valeur : -1;\n+        } else {\n+            cachedYearlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_YEAR, lastYear);\n+        updateKwhChannel(THIS_YEAR, thisYear);\n+    }\n+\n+    private void updateKwhChannel(String channelId, double consumption) {\n+        logger.debug(\"Update channel {} with {}\", channelId, consumption);\n+        updateState(channelId,\n+                consumption != -1 ? new QuantityType<>(consumption, SmartHomeUnits.KILOWATT_HOUR) : UnDefType.UNDEF);", "originalCommit": "00bed837d677a440e07ef1e33ff891b470a852bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c9d3e3703c0b91732f52dee340cc0b8bc9ed5157", "url": "https://github.com/openhab/openhab-addons/commit/c9d3e3703c0b91732f52dee340cc0b8bc9ed5157", "message": "Switch to Double.NaN and license headers\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-03-21T07:42:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIzMjE2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r396232169", "bodyText": "Minor correction.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    updateState(channelId, consumption != Double.NaN ? new QuantityType<>(consumption, SmartHomeUnits.KILOWATT_HOUR)\n          \n          \n            \n                    updateState(channelId, !Double.isNaN(consumption) ? new QuantityType<>(consumption, SmartHomeUnits.KILOWATT_HOUR)", "author": "cpmeister", "createdAt": "2020-03-23T06:21:17Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        try {\n+            Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                    .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                    .build();\n+            Response response = client.newCall(requestLogin).execute();\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            response.close();\n+\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        Double lastWeek = Double.NaN;\n+        Double thisWeek = Double.NaN;\n+        Double yesterday = Double.NaN;\n+        LinkyConsumptionData result = cachedDaylyData.getValue();\n+        if (result != null && result.success()) {\n+            LocalDate rangeStart = LocalDate.now().minusDays(13);\n+            int jump = result.getDecalage();\n+            while (rangeStart.getDayOfWeek() != weekFields.getFirstDayOfWeek()) {\n+                rangeStart = rangeStart.plusDays(1);\n+                jump++;\n+            }\n+\n+            int lastWeekNumber = rangeStart.get(weekFields.weekOfWeekBasedYear());\n+\n+            lastWeek = 0.0;\n+            thisWeek = 0.0;\n+            yesterday = Double.NaN;\n+            while (jump < result.getData().size()) {\n+                double consumption = result.getData().get(jump).valeur;\n+                if (consumption > 0) {\n+                    if (rangeStart.get(weekFields.weekOfWeekBasedYear()) == lastWeekNumber) {\n+                        lastWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to last week: {}\", jump, consumption);\n+                    } else {\n+                        thisWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to current week: {}\", jump, consumption);\n+                    }\n+                    yesterday = consumption;\n+                }\n+                jump++;\n+                rangeStart = rangeStart.plusDays(1);\n+            }\n+        } else {\n+            cachedDaylyData.invalidateValue();\n+        }\n+        updateKwhChannel(YESTERDAY, yesterday);\n+        updateKwhChannel(THIS_WEEK, thisWeek);\n+        updateKwhChannel(LAST_WEEK, lastWeek);\n+    }\n+\n+    /**\n+     * Request new monthly data and updates channels\n+     */\n+    private synchronized void updateMonthlyData() {\n+        if (!isLinked(LAST_MONTH) && !isLinked(THIS_MONTH)) {\n+            return;\n+        }\n+\n+        Double lastMonth = Double.NaN;\n+        Double thisMonth = Double.NaN;\n+        LinkyConsumptionData result = cachedMonthlyData.getValue();\n+        if (result != null && result.success()) {\n+            int jump = result.getDecalage();\n+            lastMonth = result.getData().get(jump).valeur;\n+            thisMonth = result.getData().get(jump + 1).valeur;\n+            if (thisMonth < 0) {\n+                thisMonth = 0.0;\n+            }\n+        } else {\n+            cachedMonthlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_MONTH, lastMonth);\n+        updateKwhChannel(THIS_MONTH, thisMonth);\n+    }\n+\n+    /**\n+     * Request new yearly data and updates channels\n+     */\n+    private synchronized void updateYearlyData() {\n+        if (!isLinked(LAST_YEAR) && !isLinked(THIS_YEAR)) {\n+            return;\n+        }\n+\n+        Double thisYear = Double.NaN;\n+        Double lastYear = Double.NaN;\n+        LinkyConsumptionData result = cachedYearlyData.getValue();\n+        if (result != null && result.success()) {\n+            int elementQuantity = result.getData().size();\n+            thisYear = elementQuantity > 0 ? result.getData().get(elementQuantity - 1).valeur : Double.NaN;\n+            lastYear = elementQuantity > 1 ? result.getData().get(elementQuantity - 2).valeur : Double.NaN;\n+        } else {\n+            cachedYearlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_YEAR, lastYear);\n+        updateKwhChannel(THIS_YEAR, thisYear);\n+    }\n+\n+    private void updateKwhChannel(String channelId, Double consumption) {\n+        logger.debug(\"Update channel {} with {}\", channelId, consumption);\n+        updateState(channelId, consumption != Double.NaN ? new QuantityType<>(consumption, SmartHomeUnits.KILOWATT_HOUR)", "originalCommit": "c9d3e3703c0b91732f52dee340cc0b8bc9ed5157", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIzMjYyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r396232625", "bodyText": "Should this also update the ThingStatus?", "author": "cpmeister", "createdAt": "2020-03-23T06:22:57Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        try {\n+            Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                    .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                    .build();\n+            Response response = client.newCall(requestLogin).execute();\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            response.close();\n+\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        Double lastWeek = Double.NaN;\n+        Double thisWeek = Double.NaN;\n+        Double yesterday = Double.NaN;\n+        LinkyConsumptionData result = cachedDaylyData.getValue();\n+        if (result != null && result.success()) {\n+            LocalDate rangeStart = LocalDate.now().minusDays(13);\n+            int jump = result.getDecalage();\n+            while (rangeStart.getDayOfWeek() != weekFields.getFirstDayOfWeek()) {\n+                rangeStart = rangeStart.plusDays(1);\n+                jump++;\n+            }\n+\n+            int lastWeekNumber = rangeStart.get(weekFields.weekOfWeekBasedYear());\n+\n+            lastWeek = 0.0;\n+            thisWeek = 0.0;\n+            yesterday = Double.NaN;\n+            while (jump < result.getData().size()) {\n+                double consumption = result.getData().get(jump).valeur;\n+                if (consumption > 0) {\n+                    if (rangeStart.get(weekFields.weekOfWeekBasedYear()) == lastWeekNumber) {\n+                        lastWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to last week: {}\", jump, consumption);\n+                    } else {\n+                        thisWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to current week: {}\", jump, consumption);\n+                    }\n+                    yesterday = consumption;\n+                }\n+                jump++;\n+                rangeStart = rangeStart.plusDays(1);\n+            }\n+        } else {\n+            cachedDaylyData.invalidateValue();\n+        }\n+        updateKwhChannel(YESTERDAY, yesterday);\n+        updateKwhChannel(THIS_WEEK, thisWeek);\n+        updateKwhChannel(LAST_WEEK, lastWeek);\n+    }\n+\n+    /**\n+     * Request new monthly data and updates channels\n+     */\n+    private synchronized void updateMonthlyData() {\n+        if (!isLinked(LAST_MONTH) && !isLinked(THIS_MONTH)) {\n+            return;\n+        }\n+\n+        Double lastMonth = Double.NaN;\n+        Double thisMonth = Double.NaN;\n+        LinkyConsumptionData result = cachedMonthlyData.getValue();\n+        if (result != null && result.success()) {\n+            int jump = result.getDecalage();\n+            lastMonth = result.getData().get(jump).valeur;\n+            thisMonth = result.getData().get(jump + 1).valeur;\n+            if (thisMonth < 0) {\n+                thisMonth = 0.0;\n+            }\n+        } else {\n+            cachedMonthlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_MONTH, lastMonth);\n+        updateKwhChannel(THIS_MONTH, thisMonth);\n+    }\n+\n+    /**\n+     * Request new yearly data and updates channels\n+     */\n+    private synchronized void updateYearlyData() {\n+        if (!isLinked(LAST_YEAR) && !isLinked(THIS_YEAR)) {\n+            return;\n+        }\n+\n+        Double thisYear = Double.NaN;\n+        Double lastYear = Double.NaN;\n+        LinkyConsumptionData result = cachedYearlyData.getValue();\n+        if (result != null && result.success()) {\n+            int elementQuantity = result.getData().size();\n+            thisYear = elementQuantity > 0 ? result.getData().get(elementQuantity - 1).valeur : Double.NaN;\n+            lastYear = elementQuantity > 1 ? result.getData().get(elementQuantity - 2).valeur : Double.NaN;\n+        } else {\n+            cachedYearlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_YEAR, lastYear);\n+        updateKwhChannel(THIS_YEAR, thisYear);\n+    }\n+\n+    private void updateKwhChannel(String channelId, Double consumption) {\n+        logger.debug(\"Update channel {} with {}\", channelId, consumption);\n+        updateState(channelId, consumption != Double.NaN ? new QuantityType<>(consumption, SmartHomeUnits.KILOWATT_HOUR)\n+                : UnDefType.UNDEF);\n+    }\n+\n+    /**\n+     * Produce a report of all daily values between two dates\n+     *\n+     * @param startDay the start day of the report\n+     * @param endDay the end day of the report\n+     * @param separator the separator to be used betwwen the date and the value\n+     *\n+     * @return the report as a string\n+     */\n+    public String reportValues(LocalDate startDay, LocalDate endDay, @Nullable String separator) {\n+        StringBuilder dump = new StringBuilder();\n+        if (startDay.getYear() == endDay.getYear() && startDay.getMonthValue() == endDay.getMonthValue()) {\n+            // All values in the same month\n+            LinkyConsumptionData result = getConsumptionData(DAILY, startDay, endDay, true);\n+            if (result != null && result.success()) {\n+                LocalDate currentDay = startDay;\n+                int jump = result.getDecalage();\n+                while (jump < result.getData().size() && !currentDay.isAfter(endDay)) {\n+                    double consumption = result.getData().get(jump).valeur;\n+                    dump.append(currentDay.format(DateTimeFormatter.ISO_LOCAL_DATE) + separator);\n+                    if (consumption >= 0) {\n+                        dump.append(String.valueOf(consumption));\n+                    }\n+                    dump.append(\"\\n\");\n+                    jump++;\n+                    currentDay = currentDay.plusDays(1);\n+                }\n+            } else {\n+                LocalDate currentDay = startDay;\n+                while (!currentDay.isAfter(endDay)) {\n+                    dump.append(currentDay.format(DateTimeFormatter.ISO_LOCAL_DATE) + separator + \"\\n\");\n+                    currentDay = currentDay.plusDays(1);\n+                }\n+            }\n+        } else {\n+            // Concatenate the report produced for each month between the two dates\n+            LocalDate first = startDay;\n+            do {\n+                LocalDate last = first.withDayOfMonth(first.lengthOfMonth());\n+                if (last.isAfter(endDay)) {\n+                    last = endDay;\n+                }\n+                dump.append(reportValues(first, last, separator));\n+                first = last.plusDays(1);\n+            } while (!first.isAfter(endDay));\n+        }\n+        return dump.toString();\n+    }\n+\n+    private @Nullable LinkyConsumptionData getConsumptionData(LinkyTimeScale timeScale, LocalDate from, LocalDate to,\n+            boolean reLog) {\n+        logger.debug(\"getConsumptionData {}\", timeScale);\n+\n+        LinkyConsumptionData result = null;\n+        boolean tryRelog = false;\n+\n+        FormBody formBody = new FormBody.Builder().add(\"p_p_id\", \"lincspartdisplaycdc_WAR_lincspartcdcportlet\")\n+                .add(\"p_p_lifecycle\", \"2\").add(\"p_p_resource_id\", timeScale.getId())\n+                .add(\"_lincspartdisplaycdc_WAR_lincspartcdcportlet_dateDebut\", from.format(API_DATE_FORMAT))\n+                .add(\"_lincspartdisplaycdc_WAR_lincspartcdcportlet_dateFin\", to.format(API_DATE_FORMAT)).build();\n+\n+        Request requestData = new Request.Builder().url(API_BASE_URI).post(formBody).build();\n+        try (Response response = client.newCall(requestData).execute()) {\n+            if (response.isRedirect()) {\n+                String location = response.header(\"Location\");\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(), location);\n+                if (reLog && location != null && location.startsWith(LOGIN_BASE_URI)) {\n+                    tryRelog = true;\n+                }\n+            } else {\n+                String body = (response.body() != null) ? response.body().string() : null;\n+                logger.debug(\"Response status {} {} : {}\", response.code(), response.message(), body);\n+                if (body != null && !body.isEmpty()) {\n+                    result = gson.fromJson(body, LinkyConsumptionData.class);\n+                }\n+            }\n+            response.close();\n+        } catch (IOException e) {\n+            logger.debug(\"Exception calling API : {} - {}\", e.getClass().getCanonicalName(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"Exception while converting JSON response : {}\", e.getMessage());", "originalCommit": "c9d3e3703c0b91732f52dee340cc0b8bc9ed5157", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIzNDM4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r396234384", "bodyText": "Since Response implements Closable please wrap this in a try-with-resources.", "author": "cpmeister", "createdAt": "2020-03-23T06:29:53Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        try {\n+            Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                    .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                    .build();\n+            Response response = client.newCall(requestLogin).execute();\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            response.close();", "originalCommit": "c9d3e3703c0b91732f52dee340cc0b8bc9ed5157", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIzODA5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r396238090", "bodyText": "From what I can tell, the only caller of this method splits apart the returned string into each line. Why can't this method just return a List<String>? Seems kinda strange to add in a bunch of newline characters only for callers of the method to immediately remove them.\nIt would be more efficient to pass in the List as a parameter so it can be used on recursive calls.\nWDYT?", "author": "cpmeister", "createdAt": "2020-03-23T06:43:35Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        try {\n+            Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                    .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                    .build();\n+            Response response = client.newCall(requestLogin).execute();\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            response.close();\n+\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        Double lastWeek = Double.NaN;\n+        Double thisWeek = Double.NaN;\n+        Double yesterday = Double.NaN;\n+        LinkyConsumptionData result = cachedDaylyData.getValue();\n+        if (result != null && result.success()) {\n+            LocalDate rangeStart = LocalDate.now().minusDays(13);\n+            int jump = result.getDecalage();\n+            while (rangeStart.getDayOfWeek() != weekFields.getFirstDayOfWeek()) {\n+                rangeStart = rangeStart.plusDays(1);\n+                jump++;\n+            }\n+\n+            int lastWeekNumber = rangeStart.get(weekFields.weekOfWeekBasedYear());\n+\n+            lastWeek = 0.0;\n+            thisWeek = 0.0;\n+            yesterday = Double.NaN;\n+            while (jump < result.getData().size()) {\n+                double consumption = result.getData().get(jump).valeur;\n+                if (consumption > 0) {\n+                    if (rangeStart.get(weekFields.weekOfWeekBasedYear()) == lastWeekNumber) {\n+                        lastWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to last week: {}\", jump, consumption);\n+                    } else {\n+                        thisWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to current week: {}\", jump, consumption);\n+                    }\n+                    yesterday = consumption;\n+                }\n+                jump++;\n+                rangeStart = rangeStart.plusDays(1);\n+            }\n+        } else {\n+            cachedDaylyData.invalidateValue();\n+        }\n+        updateKwhChannel(YESTERDAY, yesterday);\n+        updateKwhChannel(THIS_WEEK, thisWeek);\n+        updateKwhChannel(LAST_WEEK, lastWeek);\n+    }\n+\n+    /**\n+     * Request new monthly data and updates channels\n+     */\n+    private synchronized void updateMonthlyData() {\n+        if (!isLinked(LAST_MONTH) && !isLinked(THIS_MONTH)) {\n+            return;\n+        }\n+\n+        Double lastMonth = Double.NaN;\n+        Double thisMonth = Double.NaN;\n+        LinkyConsumptionData result = cachedMonthlyData.getValue();\n+        if (result != null && result.success()) {\n+            int jump = result.getDecalage();\n+            lastMonth = result.getData().get(jump).valeur;\n+            thisMonth = result.getData().get(jump + 1).valeur;\n+            if (thisMonth < 0) {\n+                thisMonth = 0.0;\n+            }\n+        } else {\n+            cachedMonthlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_MONTH, lastMonth);\n+        updateKwhChannel(THIS_MONTH, thisMonth);\n+    }\n+\n+    /**\n+     * Request new yearly data and updates channels\n+     */\n+    private synchronized void updateYearlyData() {\n+        if (!isLinked(LAST_YEAR) && !isLinked(THIS_YEAR)) {\n+            return;\n+        }\n+\n+        Double thisYear = Double.NaN;\n+        Double lastYear = Double.NaN;\n+        LinkyConsumptionData result = cachedYearlyData.getValue();\n+        if (result != null && result.success()) {\n+            int elementQuantity = result.getData().size();\n+            thisYear = elementQuantity > 0 ? result.getData().get(elementQuantity - 1).valeur : Double.NaN;\n+            lastYear = elementQuantity > 1 ? result.getData().get(elementQuantity - 2).valeur : Double.NaN;\n+        } else {\n+            cachedYearlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_YEAR, lastYear);\n+        updateKwhChannel(THIS_YEAR, thisYear);\n+    }\n+\n+    private void updateKwhChannel(String channelId, Double consumption) {\n+        logger.debug(\"Update channel {} with {}\", channelId, consumption);\n+        updateState(channelId, consumption != Double.NaN ? new QuantityType<>(consumption, SmartHomeUnits.KILOWATT_HOUR)\n+                : UnDefType.UNDEF);\n+    }\n+\n+    /**\n+     * Produce a report of all daily values between two dates\n+     *\n+     * @param startDay the start day of the report\n+     * @param endDay the end day of the report\n+     * @param separator the separator to be used betwwen the date and the value\n+     *\n+     * @return the report as a string\n+     */\n+    public String reportValues(LocalDate startDay, LocalDate endDay, @Nullable String separator) {", "originalCommit": "c9d3e3703c0b91732f52dee340cc0b8bc9ed5157", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI1NDEzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r396254136", "bodyText": "I agree that it is a good remark.", "author": "lolodomo", "createdAt": "2020-03-23T07:32:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIzODA5MA=="}], "type": "inlineReview"}, {"oid": "2f9ef7e5bfe5d91b0edf7eafa97d17a325709a72", "url": "https://github.com/openhab/openhab-addons/commit/2f9ef7e5bfe5d91b0edf7eafa97d17a325709a72", "message": "Code review corrections\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-03-23T07:29:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1OTg2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r396559865", "bodyText": "Just for fun.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            handler.reportValues(start, end, separator).forEach(line -> console.println(line));\n          \n          \n            \n                            handler.reportValues(start, end, separator).forEach(console::println);", "author": "cpmeister", "createdAt": "2020-03-23T15:56:29Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/console/LinkyCommandExtension.java", "diffHunk": "@@ -101,9 +101,7 @@ public void execute(String[] args, Console console) {\n                 if (args.length >= 5) {\n                     separator = args[4];\n                 }\n-                for (String line : handler.reportValues(start, end, separator).split(\"\\n\")) {\n-                    console.println(line);\n-                }\n+                handler.reportValues(start, end, separator).forEach(line -> console.println(line));", "originalCommit": "2f9ef7e5bfe5d91b0edf7eafa97d17a325709a72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2MDU1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r396560553", "bodyText": "This can be omitted since try-with-resources handles this for you.", "author": "cpmeister", "createdAt": "2020-03-23T15:57:20Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,390 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                .build();\n+        try (Response response = client.newCall(requestLogin).execute()) {\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            response.close();\n+\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        Double lastWeek = Double.NaN;\n+        Double thisWeek = Double.NaN;\n+        Double yesterday = Double.NaN;\n+        LinkyConsumptionData result = cachedDaylyData.getValue();\n+        if (result != null && result.success()) {\n+            LocalDate rangeStart = LocalDate.now().minusDays(13);\n+            int jump = result.getDecalage();\n+            while (rangeStart.getDayOfWeek() != weekFields.getFirstDayOfWeek()) {\n+                rangeStart = rangeStart.plusDays(1);\n+                jump++;\n+            }\n+\n+            int lastWeekNumber = rangeStart.get(weekFields.weekOfWeekBasedYear());\n+\n+            lastWeek = 0.0;\n+            thisWeek = 0.0;\n+            yesterday = Double.NaN;\n+            while (jump < result.getData().size()) {\n+                double consumption = result.getData().get(jump).valeur;\n+                if (consumption > 0) {\n+                    if (rangeStart.get(weekFields.weekOfWeekBasedYear()) == lastWeekNumber) {\n+                        lastWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to last week: {}\", jump, consumption);\n+                    } else {\n+                        thisWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to current week: {}\", jump, consumption);\n+                    }\n+                    yesterday = consumption;\n+                }\n+                jump++;\n+                rangeStart = rangeStart.plusDays(1);\n+            }\n+        } else {\n+            cachedDaylyData.invalidateValue();\n+        }\n+        updateKwhChannel(YESTERDAY, yesterday);\n+        updateKwhChannel(THIS_WEEK, thisWeek);\n+        updateKwhChannel(LAST_WEEK, lastWeek);\n+    }\n+\n+    /**\n+     * Request new monthly data and updates channels\n+     */\n+    private synchronized void updateMonthlyData() {\n+        if (!isLinked(LAST_MONTH) && !isLinked(THIS_MONTH)) {\n+            return;\n+        }\n+\n+        Double lastMonth = Double.NaN;\n+        Double thisMonth = Double.NaN;\n+        LinkyConsumptionData result = cachedMonthlyData.getValue();\n+        if (result != null && result.success()) {\n+            int jump = result.getDecalage();\n+            lastMonth = result.getData().get(jump).valeur;\n+            thisMonth = result.getData().get(jump + 1).valeur;\n+            if (thisMonth < 0) {\n+                thisMonth = 0.0;\n+            }\n+        } else {\n+            cachedMonthlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_MONTH, lastMonth);\n+        updateKwhChannel(THIS_MONTH, thisMonth);\n+    }\n+\n+    /**\n+     * Request new yearly data and updates channels\n+     */\n+    private synchronized void updateYearlyData() {\n+        if (!isLinked(LAST_YEAR) && !isLinked(THIS_YEAR)) {\n+            return;\n+        }\n+\n+        Double thisYear = Double.NaN;\n+        Double lastYear = Double.NaN;\n+        LinkyConsumptionData result = cachedYearlyData.getValue();\n+        if (result != null && result.success()) {\n+            int elementQuantity = result.getData().size();\n+            thisYear = elementQuantity > 0 ? result.getData().get(elementQuantity - 1).valeur : Double.NaN;\n+            lastYear = elementQuantity > 1 ? result.getData().get(elementQuantity - 2).valeur : Double.NaN;\n+        } else {\n+            cachedYearlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_YEAR, lastYear);\n+        updateKwhChannel(THIS_YEAR, thisYear);\n+    }\n+\n+    private void updateKwhChannel(String channelId, Double consumption) {\n+        logger.debug(\"Update channel {} with {}\", channelId, consumption);\n+        updateState(channelId,\n+                !Double.isNaN(consumption) ? new QuantityType<>(consumption, SmartHomeUnits.KILOWATT_HOUR)\n+                        : UnDefType.UNDEF);\n+    }\n+\n+    /**\n+     * Produce a report of all daily values between two dates\n+     *\n+     * @param startDay the start day of the report\n+     * @param endDay the end day of the report\n+     * @param separator the separator to be used betwwen the date and the value\n+     *\n+     * @return the report as a string\n+     */\n+    public List<String> reportValues(LocalDate startDay, LocalDate endDay, @Nullable String separator) {\n+        List<String> report = new ArrayList<>();\n+        if (startDay.getYear() == endDay.getYear() && startDay.getMonthValue() == endDay.getMonthValue()) {\n+            // All values in the same month\n+            LinkyConsumptionData result = getConsumptionData(DAILY, startDay, endDay, true);\n+            if (result != null && result.success()) {\n+                LocalDate currentDay = startDay;\n+                int jump = result.getDecalage();\n+                while (jump < result.getData().size() && !currentDay.isAfter(endDay)) {\n+                    double consumption = result.getData().get(jump).valeur;\n+                    String line = currentDay.format(DateTimeFormatter.ISO_LOCAL_DATE) + separator;\n+                    if (consumption >= 0) {\n+                        line += String.valueOf(consumption);\n+                    }\n+                    report.add(line);\n+                    jump++;\n+                    currentDay = currentDay.plusDays(1);\n+                }\n+            } else {\n+                LocalDate currentDay = startDay;\n+                while (!currentDay.isAfter(endDay)) {\n+                    report.add(currentDay.format(DateTimeFormatter.ISO_LOCAL_DATE) + separator);\n+                    currentDay = currentDay.plusDays(1);\n+                }\n+            }\n+        } else {\n+            // Concatenate the report produced for each month between the two dates\n+            LocalDate first = startDay;\n+            do {\n+                LocalDate last = first.withDayOfMonth(first.lengthOfMonth());\n+                if (last.isAfter(endDay)) {\n+                    last = endDay;\n+                }\n+                report.addAll(reportValues(first, last, separator));\n+                first = last.plusDays(1);\n+            } while (!first.isAfter(endDay));\n+        }\n+        return report;\n+    }\n+\n+    private @Nullable LinkyConsumptionData getConsumptionData(LinkyTimeScale timeScale, LocalDate from, LocalDate to,\n+            boolean reLog) {\n+        logger.debug(\"getConsumptionData {}\", timeScale);\n+\n+        LinkyConsumptionData result = null;\n+        boolean tryRelog = false;\n+\n+        FormBody formBody = new FormBody.Builder().add(\"p_p_id\", \"lincspartdisplaycdc_WAR_lincspartcdcportlet\")\n+                .add(\"p_p_lifecycle\", \"2\").add(\"p_p_resource_id\", timeScale.getId())\n+                .add(\"_lincspartdisplaycdc_WAR_lincspartcdcportlet_dateDebut\", from.format(API_DATE_FORMAT))\n+                .add(\"_lincspartdisplaycdc_WAR_lincspartcdcportlet_dateFin\", to.format(API_DATE_FORMAT)).build();\n+\n+        Request requestData = new Request.Builder().url(API_BASE_URI).post(formBody).build();\n+        try (Response response = client.newCall(requestData).execute()) {\n+            if (response.isRedirect()) {\n+                String location = response.header(\"Location\");\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(), location);\n+                if (reLog && location != null && location.startsWith(LOGIN_BASE_URI)) {\n+                    tryRelog = true;\n+                }\n+            } else {\n+                String body = (response.body() != null) ? response.body().string() : null;\n+                logger.debug(\"Response status {} {} : {}\", response.code(), response.message(), body);\n+                if (body != null && !body.isEmpty()) {\n+                    result = gson.fromJson(body, LinkyConsumptionData.class);\n+                }\n+            }\n+            response.close();", "originalCommit": "2f9ef7e5bfe5d91b0edf7eafa97d17a325709a72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE2MDY5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r399160697", "bodyText": "missed this one?", "author": "cpmeister", "createdAt": "2020-03-27T10:14:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2MDU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTIyNzg3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r399227879", "bodyText": "Yes, sh**t !", "author": "clinique", "createdAt": "2020-03-27T12:26:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2MDU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2MTc4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r396561783", "bodyText": "This can be omitted since try-with-resources handles this for you.", "author": "cpmeister", "createdAt": "2020-03-23T15:58:50Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,390 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                .build();\n+        try (Response response = client.newCall(requestLogin).execute()) {\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            response.close();", "originalCommit": "2f9ef7e5bfe5d91b0edf7eafa97d17a325709a72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7f08a6e8e99fa7892536494fc0301067ea00d7f0", "url": "https://github.com/openhab/openhab-addons/commit/7f08a6e8e99fa7892536494fc0301067ea00d7f0", "message": "Code review final corrections\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-03-27T08:32:24Z", "type": "commit"}, {"oid": "50d9992342e2a7d8a8a038ad8f3d5da8f55b346c", "url": "https://github.com/openhab/openhab-addons/commit/50d9992342e2a7d8a8a038ad8f3d5da8f55b346c", "message": "Forgot one\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-03-27T12:26:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzNDc4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r399334785", "bodyText": "Perhaps you should have an else statement here that prints usage as well?", "author": "cpmeister", "createdAt": "2020-03-27T15:09:43Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/console/LinkyCommandExtension.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.console;\n+\n+import java.time.LocalDate;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingRegistry;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.console.Console;\n+import org.eclipse.smarthome.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.eclipse.smarthome.io.console.extensions.ConsoleCommandExtension;\n+import org.openhab.binding.linky.internal.handler.LinkyHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link LinkyCommandExtension} is responsible for handling console commands\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@Component(service = ConsoleCommandExtension.class)\n+public class LinkyCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String REPORT = \"report\";\n+\n+    private final ThingRegistry thingRegistry;\n+\n+    @Activate\n+    public LinkyCommandExtension(final @Reference ThingRegistry thingRegistry) {\n+        super(\"linky\", \"Interact with the Linky binding.\");\n+        this.thingRegistry = thingRegistry;\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length >= 2) {\n+            LinkyHandler handler = null;\n+            try {\n+                ThingUID thingUID = new ThingUID(args[0]);\n+                Thing thing = thingRegistry.get(thingUID);\n+                if ((thing != null) && (thing.getHandler() != null) && (thing.getHandler() instanceof LinkyHandler)) {\n+                    handler = (LinkyHandler) thing.getHandler();\n+                }\n+            } catch (IllegalArgumentException e) {\n+                handler = null;\n+            }\n+            if (handler == null) {\n+                console.println(\"Bad thing id '\" + args[0] + \"'\");\n+                printUsage(console);\n+            } else if (args[1] == REPORT) {\n+                LocalDate now = LocalDate.now();\n+                LocalDate start = now.minusDays(7);\n+                LocalDate end = now.minusDays(1);\n+                String separator = \" \";\n+                if (args.length >= 3) {\n+                    try {\n+                        start = LocalDate.parse(args[2], DateTimeFormatter.ISO_LOCAL_DATE);\n+                    } catch (DateTimeParseException e) {\n+                        console.println(\n+                                \"Invalid format for start day '\" + args[2] + \"'; expected format is YYYY-MM-DD\");\n+                        printUsage(console);\n+                        return;\n+                    }\n+                }\n+                if (args.length >= 4) {\n+                    try {\n+                        end = LocalDate.parse(args[3], DateTimeFormatter.ISO_LOCAL_DATE);\n+                    } catch (DateTimeParseException e) {\n+                        console.println(\"Invalid format for end day '\" + args[3] + \"'; expected format is YYYY-MM-DD\");\n+                        printUsage(console);\n+                        return;\n+                    }\n+                }\n+                if (!start.isBefore(now) || start.isAfter(end)) {\n+                    console.println(\"Start day must be in the past and before the end day\");\n+                    printUsage(console);\n+                    return;\n+                }\n+                if (end.isAfter(now.minusDays(1))) {\n+                    end = now.minusDays(1);\n+                }\n+                if (args.length >= 5) {\n+                    separator = args[4];\n+                }\n+                handler.reportValues(start, end, separator).forEach(console::println);\n+            }", "originalCommit": "50d9992342e2a7d8a8a038ad8f3d5da8f55b346c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgzMDAwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r399830001", "bodyText": "There is one in line 107", "author": "clinique", "createdAt": "2020-03-29T17:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzNDc4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzNzQwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r399337409", "bodyText": "Most builder designs return the same object, so I don't think you should use a builder as a static field and instead should construct it each time. Does LOGIN_BODY_BUILDER return a new builder instance each time you mutate it? If not then LOGIN_BODY_BUILDER should instead be a static method, named appropriately of course.", "author": "cpmeister", "createdAt": "2020-03-27T15:13:29Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())", "originalCommit": "50d9992342e2a7d8a8a038ad8f3d5da8f55b346c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzODE4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r399338187", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void updateKwhChannel(String channelId, Double consumption) {\n          \n          \n            \n                private void updateKwhChannel(String channelId, double consumption) {", "author": "cpmeister", "createdAt": "2020-03-27T15:14:31Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                .build();\n+        try (Response response = client.newCall(requestLogin).execute()) {\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        Double lastWeek = Double.NaN;\n+        Double thisWeek = Double.NaN;\n+        Double yesterday = Double.NaN;\n+        LinkyConsumptionData result = cachedDaylyData.getValue();\n+        if (result != null && result.success()) {\n+            LocalDate rangeStart = LocalDate.now().minusDays(13);\n+            int jump = result.getDecalage();\n+            while (rangeStart.getDayOfWeek() != weekFields.getFirstDayOfWeek()) {\n+                rangeStart = rangeStart.plusDays(1);\n+                jump++;\n+            }\n+\n+            int lastWeekNumber = rangeStart.get(weekFields.weekOfWeekBasedYear());\n+\n+            lastWeek = 0.0;\n+            thisWeek = 0.0;\n+            yesterday = Double.NaN;\n+            while (jump < result.getData().size()) {\n+                double consumption = result.getData().get(jump).valeur;\n+                if (consumption > 0) {\n+                    if (rangeStart.get(weekFields.weekOfWeekBasedYear()) == lastWeekNumber) {\n+                        lastWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to last week: {}\", jump, consumption);\n+                    } else {\n+                        thisWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to current week: {}\", jump, consumption);\n+                    }\n+                    yesterday = consumption;\n+                }\n+                jump++;\n+                rangeStart = rangeStart.plusDays(1);\n+            }\n+        } else {\n+            cachedDaylyData.invalidateValue();\n+        }\n+        updateKwhChannel(YESTERDAY, yesterday);\n+        updateKwhChannel(THIS_WEEK, thisWeek);\n+        updateKwhChannel(LAST_WEEK, lastWeek);\n+    }\n+\n+    /**\n+     * Request new monthly data and updates channels\n+     */\n+    private synchronized void updateMonthlyData() {\n+        if (!isLinked(LAST_MONTH) && !isLinked(THIS_MONTH)) {\n+            return;\n+        }\n+\n+        Double lastMonth = Double.NaN;\n+        Double thisMonth = Double.NaN;\n+        LinkyConsumptionData result = cachedMonthlyData.getValue();\n+        if (result != null && result.success()) {\n+            int jump = result.getDecalage();\n+            lastMonth = result.getData().get(jump).valeur;\n+            thisMonth = result.getData().get(jump + 1).valeur;\n+            if (thisMonth < 0) {\n+                thisMonth = 0.0;\n+            }\n+        } else {\n+            cachedMonthlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_MONTH, lastMonth);\n+        updateKwhChannel(THIS_MONTH, thisMonth);\n+    }\n+\n+    /**\n+     * Request new yearly data and updates channels\n+     */\n+    private synchronized void updateYearlyData() {\n+        if (!isLinked(LAST_YEAR) && !isLinked(THIS_YEAR)) {\n+            return;\n+        }\n+\n+        Double thisYear = Double.NaN;\n+        Double lastYear = Double.NaN;\n+        LinkyConsumptionData result = cachedYearlyData.getValue();\n+        if (result != null && result.success()) {\n+            int elementQuantity = result.getData().size();\n+            thisYear = elementQuantity > 0 ? result.getData().get(elementQuantity - 1).valeur : Double.NaN;\n+            lastYear = elementQuantity > 1 ? result.getData().get(elementQuantity - 2).valeur : Double.NaN;\n+        } else {\n+            cachedYearlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_YEAR, lastYear);\n+        updateKwhChannel(THIS_YEAR, thisYear);\n+    }\n+\n+    private void updateKwhChannel(String channelId, Double consumption) {", "originalCommit": "50d9992342e2a7d8a8a038ad8f3d5da8f55b346c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzODM4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r399338388", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Double thisYear = Double.NaN;\n          \n          \n            \n                    Double lastYear = Double.NaN;\n          \n          \n            \n                    double thisYear = Double.NaN;\n          \n          \n            \n                    double lastYear = Double.NaN;", "author": "cpmeister", "createdAt": "2020-03-27T15:14:48Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                .build();\n+        try (Response response = client.newCall(requestLogin).execute()) {\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        Double lastWeek = Double.NaN;\n+        Double thisWeek = Double.NaN;\n+        Double yesterday = Double.NaN;\n+        LinkyConsumptionData result = cachedDaylyData.getValue();\n+        if (result != null && result.success()) {\n+            LocalDate rangeStart = LocalDate.now().minusDays(13);\n+            int jump = result.getDecalage();\n+            while (rangeStart.getDayOfWeek() != weekFields.getFirstDayOfWeek()) {\n+                rangeStart = rangeStart.plusDays(1);\n+                jump++;\n+            }\n+\n+            int lastWeekNumber = rangeStart.get(weekFields.weekOfWeekBasedYear());\n+\n+            lastWeek = 0.0;\n+            thisWeek = 0.0;\n+            yesterday = Double.NaN;\n+            while (jump < result.getData().size()) {\n+                double consumption = result.getData().get(jump).valeur;\n+                if (consumption > 0) {\n+                    if (rangeStart.get(weekFields.weekOfWeekBasedYear()) == lastWeekNumber) {\n+                        lastWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to last week: {}\", jump, consumption);\n+                    } else {\n+                        thisWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to current week: {}\", jump, consumption);\n+                    }\n+                    yesterday = consumption;\n+                }\n+                jump++;\n+                rangeStart = rangeStart.plusDays(1);\n+            }\n+        } else {\n+            cachedDaylyData.invalidateValue();\n+        }\n+        updateKwhChannel(YESTERDAY, yesterday);\n+        updateKwhChannel(THIS_WEEK, thisWeek);\n+        updateKwhChannel(LAST_WEEK, lastWeek);\n+    }\n+\n+    /**\n+     * Request new monthly data and updates channels\n+     */\n+    private synchronized void updateMonthlyData() {\n+        if (!isLinked(LAST_MONTH) && !isLinked(THIS_MONTH)) {\n+            return;\n+        }\n+\n+        Double lastMonth = Double.NaN;\n+        Double thisMonth = Double.NaN;\n+        LinkyConsumptionData result = cachedMonthlyData.getValue();\n+        if (result != null && result.success()) {\n+            int jump = result.getDecalage();\n+            lastMonth = result.getData().get(jump).valeur;\n+            thisMonth = result.getData().get(jump + 1).valeur;\n+            if (thisMonth < 0) {\n+                thisMonth = 0.0;\n+            }\n+        } else {\n+            cachedMonthlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_MONTH, lastMonth);\n+        updateKwhChannel(THIS_MONTH, thisMonth);\n+    }\n+\n+    /**\n+     * Request new yearly data and updates channels\n+     */\n+    private synchronized void updateYearlyData() {\n+        if (!isLinked(LAST_YEAR) && !isLinked(THIS_YEAR)) {\n+            return;\n+        }\n+\n+        Double thisYear = Double.NaN;\n+        Double lastYear = Double.NaN;", "originalCommit": "50d9992342e2a7d8a8a038ad8f3d5da8f55b346c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzODY2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r399338662", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Double lastMonth = Double.NaN;\n          \n          \n            \n                    Double thisMonth = Double.NaN;\n          \n          \n            \n                    double lastMonth = Double.NaN;\n          \n          \n            \n                    double thisMonth = Double.NaN;", "author": "cpmeister", "createdAt": "2020-03-27T15:15:12Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                .build();\n+        try (Response response = client.newCall(requestLogin).execute()) {\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        Double lastWeek = Double.NaN;\n+        Double thisWeek = Double.NaN;\n+        Double yesterday = Double.NaN;\n+        LinkyConsumptionData result = cachedDaylyData.getValue();\n+        if (result != null && result.success()) {\n+            LocalDate rangeStart = LocalDate.now().minusDays(13);\n+            int jump = result.getDecalage();\n+            while (rangeStart.getDayOfWeek() != weekFields.getFirstDayOfWeek()) {\n+                rangeStart = rangeStart.plusDays(1);\n+                jump++;\n+            }\n+\n+            int lastWeekNumber = rangeStart.get(weekFields.weekOfWeekBasedYear());\n+\n+            lastWeek = 0.0;\n+            thisWeek = 0.0;\n+            yesterday = Double.NaN;\n+            while (jump < result.getData().size()) {\n+                double consumption = result.getData().get(jump).valeur;\n+                if (consumption > 0) {\n+                    if (rangeStart.get(weekFields.weekOfWeekBasedYear()) == lastWeekNumber) {\n+                        lastWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to last week: {}\", jump, consumption);\n+                    } else {\n+                        thisWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to current week: {}\", jump, consumption);\n+                    }\n+                    yesterday = consumption;\n+                }\n+                jump++;\n+                rangeStart = rangeStart.plusDays(1);\n+            }\n+        } else {\n+            cachedDaylyData.invalidateValue();\n+        }\n+        updateKwhChannel(YESTERDAY, yesterday);\n+        updateKwhChannel(THIS_WEEK, thisWeek);\n+        updateKwhChannel(LAST_WEEK, lastWeek);\n+    }\n+\n+    /**\n+     * Request new monthly data and updates channels\n+     */\n+    private synchronized void updateMonthlyData() {\n+        if (!isLinked(LAST_MONTH) && !isLinked(THIS_MONTH)) {\n+            return;\n+        }\n+\n+        Double lastMonth = Double.NaN;\n+        Double thisMonth = Double.NaN;", "originalCommit": "50d9992342e2a7d8a8a038ad8f3d5da8f55b346c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzODkyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r399338925", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Double lastWeek = Double.NaN;\n          \n          \n            \n                    Double thisWeek = Double.NaN;\n          \n          \n            \n                    Double yesterday = Double.NaN;\n          \n          \n            \n                    double lastWeek = Double.NaN;\n          \n          \n            \n                    double thisWeek = Double.NaN;\n          \n          \n            \n                    double yesterday = Double.NaN;", "author": "cpmeister", "createdAt": "2020-03-27T15:15:32Z", "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                .build();\n+        try (Response response = client.newCall(requestLogin).execute()) {\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        Double lastWeek = Double.NaN;\n+        Double thisWeek = Double.NaN;\n+        Double yesterday = Double.NaN;", "originalCommit": "50d9992342e2a7d8a8a038ad8f3d5da8f55b346c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "07971052ac2179e43fbdf8e45d9123bf508e6dbf", "url": "https://github.com/openhab/openhab-addons/commit/07971052ac2179e43fbdf8e45d9123bf508e6dbf", "message": "Code rerereview :) cocococorrections\nThis PR is dedicated to Julie, 16 yo young girl, passed away with the COVID-19\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-03-29T17:52:37Z", "type": "commit"}, {"oid": "dae11993577ba5608602eb8b6ca35be88cdf626d", "url": "https://github.com/openhab/openhab-addons/commit/dae11993577ba5608602eb8b6ca35be88cdf626d", "message": "Correction of console extension\n\nSigned-off-by: clinique <gael@lhopital.org>", "committedDate": "2020-04-05T17:32:12Z", "type": "commit"}]}