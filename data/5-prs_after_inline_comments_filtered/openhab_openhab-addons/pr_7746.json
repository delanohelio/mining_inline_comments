{"pr_number": 7746, "pr_title": "[oppo] Oppo Blu-ray Player Binding - initial contribution", "pr_createdAt": "2020-05-22T21:06:59Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7746", "timeline": [{"oid": "29400b516a30c2ef2c2cfab386cd5863b935cda0", "url": "https://github.com/openhab/openhab-addons/commit/29400b516a30c2ef2c2cfab386cd5863b935cda0", "message": "Merge pull request #1 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-04-13T19:56:53Z", "type": "commit"}, {"oid": "37d791e6a6a787b77a5c60383d1f6a88adc6c9cd", "url": "https://github.com/openhab/openhab-addons/commit/37d791e6a6a787b77a5c60383d1f6a88adc6c9cd", "message": "Merge pull request #2 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-04-19T18:41:08Z", "type": "commit"}, {"oid": "da326a52491feb053c9fe842cc9ef17054f88145", "url": "https://github.com/openhab/openhab-addons/commit/da326a52491feb053c9fe842cc9ef17054f88145", "message": "Oppo Binding - initial contribution\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-21T20:13:08Z", "type": "commit"}, {"oid": "5b5eaefdcf50eb96656fb57198665d479b371155", "url": "https://github.com/openhab/openhab-addons/commit/5b5eaefdcf50eb96656fb57198665d479b371155", "message": "Finish oppo binding implementation\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-22T21:04:26Z", "type": "commit"}, {"oid": "4cb2155c14b76e149a7509e7c62ea513e680d3d7", "url": "https://github.com/openhab/openhab-addons/commit/4cb2155c14b76e149a7509e7c62ea513e680d3d7", "message": "Add README.md\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-22T22:28:55Z", "type": "commit"}, {"oid": "b9db4c7923815661726d2b385d3d5099caf55f95", "url": "https://github.com/openhab/openhab-addons/commit/b9db4c7923815661726d2b385d3d5099caf55f95", "message": "update pom version to 2.5.6\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-23T04:49:08Z", "type": "commit"}, {"oid": "ac0e3865ede3d406a6adefbe39cca773ed18bde5", "url": "https://github.com/openhab/openhab-addons/commit/ac0e3865ede3d406a6adefbe39cca773ed18bde5", "message": "Remove org.apache.commons.lang dependency\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-26T04:29:50Z", "type": "commit"}, {"oid": "82462cd7c0499460c54237c70b956459bd53d8b3", "url": "https://github.com/openhab/openhab-addons/commit/82462cd7c0499460c54237c70b956459bd53d8b3", "message": "Merge pull request #3 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-05-27T03:57:29Z", "type": "commit"}, {"oid": "0c6eb31a426bc5ff5cb886f6b92fe3b4f55b1de4", "url": "https://github.com/openhab/openhab-addons/commit/0c6eb31a426bc5ff5cb886f6b92fe3b4f55b1de4", "message": "Merge branch '2.5.x' into OppoBluRay", "committedDate": "2020-05-28T04:43:50Z", "type": "commit"}, {"oid": "c4e65427d2970058d8ddf7544302285cc489fd8d", "url": "https://github.com/openhab/openhab-addons/commit/c4e65427d2970058d8ddf7544302285cc489fd8d", "message": "spotles cleanup and label cleanup\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-28T05:25:19Z", "type": "commit"}, {"oid": "238b3107a55b71f127689a89e40d1824c16ee835", "url": "https://github.com/openhab/openhab-addons/commit/238b3107a55b71f127689a89e40d1824c16ee835", "message": "remove httpClient from discovery service\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-28T20:31:48Z", "type": "commit"}, {"oid": "0b89e29f612eba99d87b92debefd012cc46133cb", "url": "https://github.com/openhab/openhab-addons/commit/0b89e29f612eba99d87b92debefd012cc46133cb", "message": "implement code review changes from other PR\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-01T19:47:50Z", "type": "commit"}, {"oid": "5d548ccb1f0c2dc140c006242aa61ed0b07b3d87", "url": "https://github.com/openhab/openhab-addons/commit/5d548ccb1f0c2dc140c006242aa61ed0b07b3d87", "message": "Merge pull request #4 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-06-04T21:19:29Z", "type": "commit"}, {"oid": "41709ef3f47b576df3eca355a6a0cc138bf36fd5", "url": "https://github.com/openhab/openhab-addons/commit/41709ef3f47b576df3eca355a6a0cc138bf36fd5", "message": "Merge pull request #5 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-06-24T13:47:17Z", "type": "commit"}, {"oid": "1379d486980393d8a6de0ed55b4b612dfc8b5977", "url": "https://github.com/openhab/openhab-addons/commit/1379d486980393d8a6de0ed55b4b612dfc8b5977", "message": "Merge branch '2.5.x' into OppoBluRay", "committedDate": "2020-06-26T19:13:07Z", "type": "commit"}, {"oid": "bb9efdf34684921912cabddd3553bd8d5403eb27", "url": "https://github.com/openhab/openhab-addons/commit/bb9efdf34684921912cabddd3553bd8d5403eb27", "message": "rollforward review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-26T21:21:34Z", "type": "commit"}, {"oid": "51b8e3c55472c06fb3c0699f4709c0559ec2145f", "url": "https://github.com/openhab/openhab-addons/commit/51b8e3c55472c06fb3c0699f4709c0559ec2145f", "message": "rollforward review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-09T02:42:49Z", "type": "commit"}, {"oid": "b3285d67faf4f4c6261dd86e7bc1b3ce855a07b0", "url": "https://github.com/openhab/openhab-addons/commit/b3285d67faf4f4c6261dd86e7bc1b3ce855a07b0", "message": "Merge pull request #6 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-07-16T21:38:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4MDIzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7746#discussion_r459680234", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Thread thread = new OppoReaderThread(this, this.address + \".\" + this.port);\n          \n          \n            \n                        Thread thread = new OppoReaderThread(this, this.address + \":\" + this.port);", "author": "fwolter", "createdAt": "2020-07-23T19:31:31Z", "path": "bundles/org.openhab.binding.oppo/src/main/java/org/openhab/binding/oppo/internal/communication/OppoIpConnector.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.oppo.internal.communication;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.oppo.internal.OppoException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the Oppo player directly or through a serial over IP connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Oppo binding\n+ */\n+@NonNullByDefault\n+public class OppoIpConnector extends OppoConnector {\n+    private final Logger logger = LoggerFactory.getLogger(OppoIpConnector.class);\n+\n+    private @Nullable String address;\n+    private int port;\n+\n+    private @Nullable Socket clientSocket;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param address the IP address of the player or serial over ip adapter\n+     * @param port the TCP port to be used\n+     */\n+    public OppoIpConnector(@Nullable String address, int port) {\n+        this.address = address;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public synchronized void open() throws OppoException {\n+        logger.debug(\"Opening IP connection on IP {} port {}\", this.address, this.port);\n+        try {\n+            Socket clientSocket = new Socket(this.address, this.port);\n+            clientSocket.setSoTimeout(100);\n+\n+            dataOut = new DataOutputStream(clientSocket.getOutputStream());\n+            dataIn = new DataInputStream(clientSocket.getInputStream());\n+\n+            Thread thread = new OppoReaderThread(this, this.address + \".\" + this.port);", "originalCommit": "51b8e3c55472c06fb3c0699f4709c0559ec2145f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4MzEyMA==", "url": "https://github.com/openhab/openhab-addons/pull/7746#discussion_r459683120", "bodyText": "Is this exception thrown anywhere?", "author": "fwolter", "createdAt": "2020-07-23T19:37:08Z", "path": "bundles/org.openhab.binding.oppo/src/main/java/org/openhab/binding/oppo/internal/communication/OppoSerialConnector.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.oppo.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.oppo.internal.OppoException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the Oppo player through a serial connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Oppo binding\n+ */\n+@NonNullByDefault\n+public class OppoSerialConnector extends OppoConnector {\n+    private final Logger logger = LoggerFactory.getLogger(OppoSerialConnector.class);\n+\n+    private String serialPortName;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param serialPortManager the serial port manager\n+     * @param serialPortName the serial port name to be used\n+     */\n+    public OppoSerialConnector(SerialPortManager serialPortManager, String serialPortName) {\n+        this.serialPortManager = serialPortManager;\n+        this.serialPortName = serialPortName;\n+    }\n+\n+    @Override\n+    public synchronized void open() throws OppoException {\n+        logger.debug(\"Opening serial connection on port {}\", serialPortName);\n+        try {\n+            SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialPortName);\n+            if (portIdentifier == null) {\n+                setConnected(false);\n+                throw new OppoException(\"Opening serial connection failed: No Such Port\");\n+            }\n+\n+            SerialPort commPort = portIdentifier.open(this.getClass().getName(), 2000);\n+\n+            commPort.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+            commPort.enableReceiveThreshold(1);\n+            commPort.enableReceiveTimeout(100);\n+            commPort.setFlowControlMode(SerialPort.FLOWCONTROL_NONE);\n+\n+            InputStream dataIn = commPort.getInputStream();\n+            OutputStream dataOut = commPort.getOutputStream();\n+\n+            if (dataOut != null) {\n+                dataOut.flush();\n+            }\n+            if (dataIn != null && dataIn.markSupported()) {\n+                try {\n+                    dataIn.reset();\n+                } catch (IOException e) {\n+                }\n+            }\n+\n+            Thread thread = new OppoReaderThread(this, this.serialPortName);\n+            setReaderThread(thread);\n+            thread.start();\n+\n+            this.serialPort = commPort;\n+            this.dataIn = dataIn;\n+            this.dataOut = dataOut;\n+\n+            setConnected(true);\n+\n+            logger.debug(\"Serial connection opened\");\n+        } catch (PortInUseException e) {\n+            setConnected(false);\n+            throw new OppoException(\"Opening serial connection failed: Port in Use Exception\", e);\n+        } catch (UnsupportedCommOperationException e) {\n+            setConnected(false);\n+            throw new OppoException(\"Opening serial connection failed: Unsupported Comm Operation Exception\", e);\n+        } catch (UnsupportedEncodingException e) {", "originalCommit": "51b8e3c55472c06fb3c0699f4709c0559ec2145f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM1NTc1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7746#discussion_r460355759", "bodyText": "no, removed.", "author": "mlobstein", "createdAt": "2020-07-25T02:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4MzEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4Mzc5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7746#discussion_r459683795", "bodyText": "It's good practice to append the unit to the field name e.g. TIMEOUT_MS.", "author": "fwolter", "createdAt": "2020-07-23T19:38:33Z", "path": "bundles/org.openhab.binding.oppo/src/main/java/org/openhab/binding/oppo/internal/discovery/OppoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.oppo.internal.discovery;\n+\n+import static org.openhab.binding.oppo.internal.OppoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Discovery class for the Oppo Blu-ray Player line.\n+ * The player sends SDDP packets continuously for us to discover.\n+ *\n+ * @author Tim Roberts - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Oppo binding\n+ */\n+\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.oppo\")\n+public class OppoDiscoveryService extends AbstractDiscoveryService {\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_PLAYER);\n+\n+    private final Logger logger = LoggerFactory.getLogger(OppoDiscoveryService.class);\n+\n+    /**\n+     * Address SDDP broadcasts on\n+     */\n+    private static final String SDDP_ADDR = \"239.255.255.251\";\n+\n+    /**\n+     * Port number SDDP uses\n+     */\n+    private static final int SDDP_PORT = 7624;\n+\n+    /**\n+     * SDDP packet should be only 512 in size - make it 600 to give us some room\n+     */\n+    private static final int BUFFER_SIZE = 600;\n+\n+    /**\n+     * Socket read timeout (in ms) - allows us to shutdown the listening every TIMEOUT\n+     */\n+    private static final int TIMEOUT = 1000;", "originalCommit": "51b8e3c55472c06fb3c0699f4709c0559ec2145f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4NTM4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7746#discussion_r459685382", "bodyText": "Can you specify the expected encoding?", "author": "fwolter", "createdAt": "2020-07-23T19:41:50Z", "path": "bundles/org.openhab.binding.oppo/src/main/java/org/openhab/binding/oppo/internal/discovery/OppoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.oppo.internal.discovery;\n+\n+import static org.openhab.binding.oppo.internal.OppoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Discovery class for the Oppo Blu-ray Player line.\n+ * The player sends SDDP packets continuously for us to discover.\n+ *\n+ * @author Tim Roberts - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Oppo binding\n+ */\n+\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.oppo\")\n+public class OppoDiscoveryService extends AbstractDiscoveryService {\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_PLAYER);\n+\n+    private final Logger logger = LoggerFactory.getLogger(OppoDiscoveryService.class);\n+\n+    /**\n+     * Address SDDP broadcasts on\n+     */\n+    private static final String SDDP_ADDR = \"239.255.255.251\";\n+\n+    /**\n+     * Port number SDDP uses\n+     */\n+    private static final int SDDP_PORT = 7624;\n+\n+    /**\n+     * SDDP packet should be only 512 in size - make it 600 to give us some room\n+     */\n+    private static final int BUFFER_SIZE = 600;\n+\n+    /**\n+     * Socket read timeout (in ms) - allows us to shutdown the listening every TIMEOUT\n+     */\n+    private static final int TIMEOUT = 1000;\n+\n+    /**\n+     * Whether we are currently scanning or not\n+     */\n+    private boolean scanning;\n+\n+    /**\n+     * The {@link ExecutorService} to run the listening threads on.\n+     */\n+    @Nullable\n+    private ExecutorService executorService;\n+\n+    private static final String DISPLAY_NAME_83 = \"OPPO BDP-83/93/95\";\n+    private static final String DISPLAY_NAME_103 = \"OPPO BDP-103\";\n+    private static final String DISPLAY_NAME_105 = \"OPPO BDP-105\";\n+\n+    /**\n+     * Constructs the discovery class using the thing IDs that we can discover.\n+     */\n+    public OppoDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 30, false);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Starts the scan. This discovery will:\n+     * <ul>\n+     * <li>Request all the network interfaces</li>\n+     * <li>For each network interface, create a listening thread using {@link #executorService}</li>\n+     * <li>Each listening thread will open up a {@link MulticastSocket} using {@link #SDDP_ADDR} and {@link #SDDP_PORT}\n+     * and\n+     * will receive any {@link DatagramPacket} that comes in</li>\n+     * <li>The {@link DatagramPacket} is then investigated to see if is a SDDP packet and will create a new thing from\n+     * it</li>\n+     * </ul>\n+     * The process will continue until {@link #stopScan()} is called.\n+     */\n+    @Override\n+    protected void startScan() {\n+        if (executorService != null) {\n+            stopScan();\n+        }\n+\n+        logger.debug(\"Starting Discovery\");\n+\n+        try {\n+            final InetAddress addr = InetAddress.getByName(SDDP_ADDR);\n+            final List<NetworkInterface> networkInterfaces = Collections.list(NetworkInterface.getNetworkInterfaces());\n+            final ExecutorService service = Executors.newFixedThreadPool(networkInterfaces.size());\n+            executorService = service;\n+\n+            scanning = true;\n+            for (final NetworkInterface netint : networkInterfaces) {\n+\n+                service.execute(() -> {\n+                    try {\n+                        MulticastSocket multiSocket = new MulticastSocket(SDDP_PORT);\n+                        multiSocket.setSoTimeout(TIMEOUT);\n+                        multiSocket.setNetworkInterface(netint);\n+                        multiSocket.joinGroup(addr);\n+\n+                        while (scanning) {\n+                            DatagramPacket receivePacket = new DatagramPacket(new byte[BUFFER_SIZE], BUFFER_SIZE);\n+                            try {\n+                                multiSocket.receive(receivePacket);\n+\n+                                String message = new String(receivePacket.getData()).trim();", "originalCommit": "51b8e3c55472c06fb3c0699f4709c0559ec2145f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4NTk0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7746#discussion_r459685942", "bodyText": "Better specify the exact type you expect, since Exception catches also runtime exceptions.", "author": "fwolter", "createdAt": "2020-07-23T19:43:02Z", "path": "bundles/org.openhab.binding.oppo/src/main/java/org/openhab/binding/oppo/internal/discovery/OppoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.oppo.internal.discovery;\n+\n+import static org.openhab.binding.oppo.internal.OppoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Discovery class for the Oppo Blu-ray Player line.\n+ * The player sends SDDP packets continuously for us to discover.\n+ *\n+ * @author Tim Roberts - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Oppo binding\n+ */\n+\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.oppo\")\n+public class OppoDiscoveryService extends AbstractDiscoveryService {\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_PLAYER);\n+\n+    private final Logger logger = LoggerFactory.getLogger(OppoDiscoveryService.class);\n+\n+    /**\n+     * Address SDDP broadcasts on\n+     */\n+    private static final String SDDP_ADDR = \"239.255.255.251\";\n+\n+    /**\n+     * Port number SDDP uses\n+     */\n+    private static final int SDDP_PORT = 7624;\n+\n+    /**\n+     * SDDP packet should be only 512 in size - make it 600 to give us some room\n+     */\n+    private static final int BUFFER_SIZE = 600;\n+\n+    /**\n+     * Socket read timeout (in ms) - allows us to shutdown the listening every TIMEOUT\n+     */\n+    private static final int TIMEOUT = 1000;\n+\n+    /**\n+     * Whether we are currently scanning or not\n+     */\n+    private boolean scanning;\n+\n+    /**\n+     * The {@link ExecutorService} to run the listening threads on.\n+     */\n+    @Nullable\n+    private ExecutorService executorService;\n+\n+    private static final String DISPLAY_NAME_83 = \"OPPO BDP-83/93/95\";\n+    private static final String DISPLAY_NAME_103 = \"OPPO BDP-103\";\n+    private static final String DISPLAY_NAME_105 = \"OPPO BDP-105\";\n+\n+    /**\n+     * Constructs the discovery class using the thing IDs that we can discover.\n+     */\n+    public OppoDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 30, false);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Starts the scan. This discovery will:\n+     * <ul>\n+     * <li>Request all the network interfaces</li>\n+     * <li>For each network interface, create a listening thread using {@link #executorService}</li>\n+     * <li>Each listening thread will open up a {@link MulticastSocket} using {@link #SDDP_ADDR} and {@link #SDDP_PORT}\n+     * and\n+     * will receive any {@link DatagramPacket} that comes in</li>\n+     * <li>The {@link DatagramPacket} is then investigated to see if is a SDDP packet and will create a new thing from\n+     * it</li>\n+     * </ul>\n+     * The process will continue until {@link #stopScan()} is called.\n+     */\n+    @Override\n+    protected void startScan() {\n+        if (executorService != null) {\n+            stopScan();\n+        }\n+\n+        logger.debug(\"Starting Discovery\");\n+\n+        try {\n+            final InetAddress addr = InetAddress.getByName(SDDP_ADDR);\n+            final List<NetworkInterface> networkInterfaces = Collections.list(NetworkInterface.getNetworkInterfaces());\n+            final ExecutorService service = Executors.newFixedThreadPool(networkInterfaces.size());\n+            executorService = service;\n+\n+            scanning = true;\n+            for (final NetworkInterface netint : networkInterfaces) {\n+\n+                service.execute(() -> {\n+                    try {\n+                        MulticastSocket multiSocket = new MulticastSocket(SDDP_PORT);\n+                        multiSocket.setSoTimeout(TIMEOUT);\n+                        multiSocket.setNetworkInterface(netint);\n+                        multiSocket.joinGroup(addr);\n+\n+                        while (scanning) {\n+                            DatagramPacket receivePacket = new DatagramPacket(new byte[BUFFER_SIZE], BUFFER_SIZE);\n+                            try {\n+                                multiSocket.receive(receivePacket);\n+\n+                                String message = new String(receivePacket.getData()).trim();\n+                                if (message != null && message.length() > 0) {\n+                                    messageReceive(message);\n+                                }\n+                            } catch (SocketTimeoutException e) {\n+                                // ignore\n+                            }\n+                        }\n+\n+                        multiSocket.close();\n+                    } catch (Exception e) {", "originalCommit": "51b8e3c55472c06fb3c0699f4709c0559ec2145f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM1NTkxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7746#discussion_r460355911", "bodyText": "done", "author": "mlobstein", "createdAt": "2020-07-25T03:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4NTk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4NzE2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7746#discussion_r459687169", "bodyText": "Is this message adequate? If I see correctly this is also invoked when the socket throws an exception. Do you log the stacktrace by intention?", "author": "fwolter", "createdAt": "2020-07-23T19:45:26Z", "path": "bundles/org.openhab.binding.oppo/src/main/java/org/openhab/binding/oppo/internal/discovery/OppoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.oppo.internal.discovery;\n+\n+import static org.openhab.binding.oppo.internal.OppoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Discovery class for the Oppo Blu-ray Player line.\n+ * The player sends SDDP packets continuously for us to discover.\n+ *\n+ * @author Tim Roberts - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Oppo binding\n+ */\n+\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.oppo\")\n+public class OppoDiscoveryService extends AbstractDiscoveryService {\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_PLAYER);\n+\n+    private final Logger logger = LoggerFactory.getLogger(OppoDiscoveryService.class);\n+\n+    /**\n+     * Address SDDP broadcasts on\n+     */\n+    private static final String SDDP_ADDR = \"239.255.255.251\";\n+\n+    /**\n+     * Port number SDDP uses\n+     */\n+    private static final int SDDP_PORT = 7624;\n+\n+    /**\n+     * SDDP packet should be only 512 in size - make it 600 to give us some room\n+     */\n+    private static final int BUFFER_SIZE = 600;\n+\n+    /**\n+     * Socket read timeout (in ms) - allows us to shutdown the listening every TIMEOUT\n+     */\n+    private static final int TIMEOUT = 1000;\n+\n+    /**\n+     * Whether we are currently scanning or not\n+     */\n+    private boolean scanning;\n+\n+    /**\n+     * The {@link ExecutorService} to run the listening threads on.\n+     */\n+    @Nullable\n+    private ExecutorService executorService;\n+\n+    private static final String DISPLAY_NAME_83 = \"OPPO BDP-83/93/95\";\n+    private static final String DISPLAY_NAME_103 = \"OPPO BDP-103\";\n+    private static final String DISPLAY_NAME_105 = \"OPPO BDP-105\";\n+\n+    /**\n+     * Constructs the discovery class using the thing IDs that we can discover.\n+     */\n+    public OppoDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 30, false);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Starts the scan. This discovery will:\n+     * <ul>\n+     * <li>Request all the network interfaces</li>\n+     * <li>For each network interface, create a listening thread using {@link #executorService}</li>\n+     * <li>Each listening thread will open up a {@link MulticastSocket} using {@link #SDDP_ADDR} and {@link #SDDP_PORT}\n+     * and\n+     * will receive any {@link DatagramPacket} that comes in</li>\n+     * <li>The {@link DatagramPacket} is then investigated to see if is a SDDP packet and will create a new thing from\n+     * it</li>\n+     * </ul>\n+     * The process will continue until {@link #stopScan()} is called.\n+     */\n+    @Override\n+    protected void startScan() {\n+        if (executorService != null) {\n+            stopScan();\n+        }\n+\n+        logger.debug(\"Starting Discovery\");\n+\n+        try {\n+            final InetAddress addr = InetAddress.getByName(SDDP_ADDR);\n+            final List<NetworkInterface> networkInterfaces = Collections.list(NetworkInterface.getNetworkInterfaces());\n+            final ExecutorService service = Executors.newFixedThreadPool(networkInterfaces.size());\n+            executorService = service;\n+\n+            scanning = true;\n+            for (final NetworkInterface netint : networkInterfaces) {\n+\n+                service.execute(() -> {\n+                    try {\n+                        MulticastSocket multiSocket = new MulticastSocket(SDDP_PORT);\n+                        multiSocket.setSoTimeout(TIMEOUT);\n+                        multiSocket.setNetworkInterface(netint);\n+                        multiSocket.joinGroup(addr);\n+\n+                        while (scanning) {\n+                            DatagramPacket receivePacket = new DatagramPacket(new byte[BUFFER_SIZE], BUFFER_SIZE);\n+                            try {\n+                                multiSocket.receive(receivePacket);\n+\n+                                String message = new String(receivePacket.getData()).trim();\n+                                if (message != null && message.length() > 0) {\n+                                    messageReceive(message);\n+                                }\n+                            } catch (SocketTimeoutException e) {\n+                                // ignore\n+                            }\n+                        }\n+\n+                        multiSocket.close();\n+                    } catch (Exception e) {\n+                        if (!e.getMessage().contains(\"No IP addresses bound to interface\")) {\n+                            logger.debug(\"Error getting ip addresses: {}\", e.getMessage(), e);", "originalCommit": "51b8e3c55472c06fb3c0699f4709c0559ec2145f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM1NjAyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7746#discussion_r460356021", "bodyText": "I improved the logging.", "author": "mlobstein", "createdAt": "2020-07-25T03:01:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4NzE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4NzU1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7746#discussion_r459687557", "bodyText": "Do you log the stacktrace by intention?", "author": "fwolter", "createdAt": "2020-07-23T19:46:16Z", "path": "bundles/org.openhab.binding.oppo/src/main/java/org/openhab/binding/oppo/internal/discovery/OppoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.oppo.internal.discovery;\n+\n+import static org.openhab.binding.oppo.internal.OppoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Discovery class for the Oppo Blu-ray Player line.\n+ * The player sends SDDP packets continuously for us to discover.\n+ *\n+ * @author Tim Roberts - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Oppo binding\n+ */\n+\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.oppo\")\n+public class OppoDiscoveryService extends AbstractDiscoveryService {\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_PLAYER);\n+\n+    private final Logger logger = LoggerFactory.getLogger(OppoDiscoveryService.class);\n+\n+    /**\n+     * Address SDDP broadcasts on\n+     */\n+    private static final String SDDP_ADDR = \"239.255.255.251\";\n+\n+    /**\n+     * Port number SDDP uses\n+     */\n+    private static final int SDDP_PORT = 7624;\n+\n+    /**\n+     * SDDP packet should be only 512 in size - make it 600 to give us some room\n+     */\n+    private static final int BUFFER_SIZE = 600;\n+\n+    /**\n+     * Socket read timeout (in ms) - allows us to shutdown the listening every TIMEOUT\n+     */\n+    private static final int TIMEOUT = 1000;\n+\n+    /**\n+     * Whether we are currently scanning or not\n+     */\n+    private boolean scanning;\n+\n+    /**\n+     * The {@link ExecutorService} to run the listening threads on.\n+     */\n+    @Nullable\n+    private ExecutorService executorService;\n+\n+    private static final String DISPLAY_NAME_83 = \"OPPO BDP-83/93/95\";\n+    private static final String DISPLAY_NAME_103 = \"OPPO BDP-103\";\n+    private static final String DISPLAY_NAME_105 = \"OPPO BDP-105\";\n+\n+    /**\n+     * Constructs the discovery class using the thing IDs that we can discover.\n+     */\n+    public OppoDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 30, false);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Starts the scan. This discovery will:\n+     * <ul>\n+     * <li>Request all the network interfaces</li>\n+     * <li>For each network interface, create a listening thread using {@link #executorService}</li>\n+     * <li>Each listening thread will open up a {@link MulticastSocket} using {@link #SDDP_ADDR} and {@link #SDDP_PORT}\n+     * and\n+     * will receive any {@link DatagramPacket} that comes in</li>\n+     * <li>The {@link DatagramPacket} is then investigated to see if is a SDDP packet and will create a new thing from\n+     * it</li>\n+     * </ul>\n+     * The process will continue until {@link #stopScan()} is called.\n+     */\n+    @Override\n+    protected void startScan() {\n+        if (executorService != null) {\n+            stopScan();\n+        }\n+\n+        logger.debug(\"Starting Discovery\");\n+\n+        try {\n+            final InetAddress addr = InetAddress.getByName(SDDP_ADDR);\n+            final List<NetworkInterface> networkInterfaces = Collections.list(NetworkInterface.getNetworkInterfaces());\n+            final ExecutorService service = Executors.newFixedThreadPool(networkInterfaces.size());\n+            executorService = service;\n+\n+            scanning = true;\n+            for (final NetworkInterface netint : networkInterfaces) {\n+\n+                service.execute(() -> {\n+                    try {\n+                        MulticastSocket multiSocket = new MulticastSocket(SDDP_PORT);\n+                        multiSocket.setSoTimeout(TIMEOUT);\n+                        multiSocket.setNetworkInterface(netint);\n+                        multiSocket.joinGroup(addr);\n+\n+                        while (scanning) {\n+                            DatagramPacket receivePacket = new DatagramPacket(new byte[BUFFER_SIZE], BUFFER_SIZE);\n+                            try {\n+                                multiSocket.receive(receivePacket);\n+\n+                                String message = new String(receivePacket.getData()).trim();\n+                                if (message != null && message.length() > 0) {\n+                                    messageReceive(message);\n+                                }\n+                            } catch (SocketTimeoutException e) {\n+                                // ignore\n+                            }\n+                        }\n+\n+                        multiSocket.close();\n+                    } catch (Exception e) {\n+                        if (!e.getMessage().contains(\"No IP addresses bound to interface\")) {\n+                            logger.debug(\"Error getting ip addresses: {}\", e.getMessage(), e);\n+                        }\n+                    }\n+                });\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error getting ip addresses: {}\", e.getMessage(), e);", "originalCommit": "51b8e3c55472c06fb3c0699f4709c0559ec2145f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM1NjAzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7746#discussion_r460356034", "bodyText": "fixed.", "author": "mlobstein", "createdAt": "2020-07-25T03:01:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4NzU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4ODYwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7746#discussion_r459688602", "bodyText": "The elements can't be null. This check can be removed.", "author": "fwolter", "createdAt": "2020-07-23T19:48:30Z", "path": "bundles/org.openhab.binding.oppo/src/main/java/org/openhab/binding/oppo/internal/discovery/OppoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.oppo.internal.discovery;\n+\n+import static org.openhab.binding.oppo.internal.OppoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Discovery class for the Oppo Blu-ray Player line.\n+ * The player sends SDDP packets continuously for us to discover.\n+ *\n+ * @author Tim Roberts - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Oppo binding\n+ */\n+\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.oppo\")\n+public class OppoDiscoveryService extends AbstractDiscoveryService {\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_PLAYER);\n+\n+    private final Logger logger = LoggerFactory.getLogger(OppoDiscoveryService.class);\n+\n+    /**\n+     * Address SDDP broadcasts on\n+     */\n+    private static final String SDDP_ADDR = \"239.255.255.251\";\n+\n+    /**\n+     * Port number SDDP uses\n+     */\n+    private static final int SDDP_PORT = 7624;\n+\n+    /**\n+     * SDDP packet should be only 512 in size - make it 600 to give us some room\n+     */\n+    private static final int BUFFER_SIZE = 600;\n+\n+    /**\n+     * Socket read timeout (in ms) - allows us to shutdown the listening every TIMEOUT\n+     */\n+    private static final int TIMEOUT = 1000;\n+\n+    /**\n+     * Whether we are currently scanning or not\n+     */\n+    private boolean scanning;\n+\n+    /**\n+     * The {@link ExecutorService} to run the listening threads on.\n+     */\n+    @Nullable\n+    private ExecutorService executorService;\n+\n+    private static final String DISPLAY_NAME_83 = \"OPPO BDP-83/93/95\";\n+    private static final String DISPLAY_NAME_103 = \"OPPO BDP-103\";\n+    private static final String DISPLAY_NAME_105 = \"OPPO BDP-105\";\n+\n+    /**\n+     * Constructs the discovery class using the thing IDs that we can discover.\n+     */\n+    public OppoDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 30, false);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Starts the scan. This discovery will:\n+     * <ul>\n+     * <li>Request all the network interfaces</li>\n+     * <li>For each network interface, create a listening thread using {@link #executorService}</li>\n+     * <li>Each listening thread will open up a {@link MulticastSocket} using {@link #SDDP_ADDR} and {@link #SDDP_PORT}\n+     * and\n+     * will receive any {@link DatagramPacket} that comes in</li>\n+     * <li>The {@link DatagramPacket} is then investigated to see if is a SDDP packet and will create a new thing from\n+     * it</li>\n+     * </ul>\n+     * The process will continue until {@link #stopScan()} is called.\n+     */\n+    @Override\n+    protected void startScan() {\n+        if (executorService != null) {\n+            stopScan();\n+        }\n+\n+        logger.debug(\"Starting Discovery\");\n+\n+        try {\n+            final InetAddress addr = InetAddress.getByName(SDDP_ADDR);\n+            final List<NetworkInterface> networkInterfaces = Collections.list(NetworkInterface.getNetworkInterfaces());\n+            final ExecutorService service = Executors.newFixedThreadPool(networkInterfaces.size());\n+            executorService = service;\n+\n+            scanning = true;\n+            for (final NetworkInterface netint : networkInterfaces) {\n+\n+                service.execute(() -> {\n+                    try {\n+                        MulticastSocket multiSocket = new MulticastSocket(SDDP_PORT);\n+                        multiSocket.setSoTimeout(TIMEOUT);\n+                        multiSocket.setNetworkInterface(netint);\n+                        multiSocket.joinGroup(addr);\n+\n+                        while (scanning) {\n+                            DatagramPacket receivePacket = new DatagramPacket(new byte[BUFFER_SIZE], BUFFER_SIZE);\n+                            try {\n+                                multiSocket.receive(receivePacket);\n+\n+                                String message = new String(receivePacket.getData()).trim();\n+                                if (message != null && message.length() > 0) {\n+                                    messageReceive(message);\n+                                }\n+                            } catch (SocketTimeoutException e) {\n+                                // ignore\n+                            }\n+                        }\n+\n+                        multiSocket.close();\n+                    } catch (Exception e) {\n+                        if (!e.getMessage().contains(\"No IP addresses bound to interface\")) {\n+                            logger.debug(\"Error getting ip addresses: {}\", e.getMessage(), e);\n+                        }\n+                    }\n+                });\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error getting ip addresses: {}\", e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * SDDP message has the following format\n+     *\n+     * <pre>\n+     * Notify: OPPO Player Start\n+     * Server IP: 192.168.0.2\n+     * Server Port: 23\n+     * Server Name: OPPO UDP-203\n+     * </pre>\n+     *\n+     *\n+     * @param message possibly null, possibly empty SDDP message\n+     */\n+    private void messageReceive(String message) {\n+        if (message.trim().length() == 0) {\n+            return;\n+        }\n+\n+        String host = null;\n+        String port = null;\n+        String model = null;\n+        String displayName = null;\n+\n+        for (String msg : message.split(\"\\n\")) {\n+            String[] line = msg.split(\":\");\n+\n+            if (line.length == 2) {\n+                if (line[0] != null && line[1] != null) {", "originalCommit": "51b8e3c55472c06fb3c0699f4709c0559ec2145f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5MzA1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7746#discussion_r459693054", "bodyText": "Better check the length of the array, as protocol anomalies should not lead to a crash of the binding. Same for below.", "author": "fwolter", "createdAt": "2020-07-23T19:57:17Z", "path": "bundles/org.openhab.binding.oppo/src/main/java/org/openhab/binding/oppo/internal/handler/OppoHandler.java", "diffHunk": "@@ -0,0 +1,834 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.oppo.internal.handler;\n+\n+import static org.openhab.binding.oppo.internal.OppoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.oppo.internal.OppoException;\n+import org.openhab.binding.oppo.internal.OppoStateDescriptionOptionProvider;\n+import org.openhab.binding.oppo.internal.communication.OppoCommand;\n+import org.openhab.binding.oppo.internal.communication.OppoConnector;\n+import org.openhab.binding.oppo.internal.communication.OppoDefaultConnector;\n+import org.openhab.binding.oppo.internal.communication.OppoIpConnector;\n+import org.openhab.binding.oppo.internal.communication.OppoMessageEvent;\n+import org.openhab.binding.oppo.internal.communication.OppoMessageEventListener;\n+import org.openhab.binding.oppo.internal.communication.OppoSerialConnector;\n+import org.openhab.binding.oppo.internal.communication.OppoStatusCodes;\n+import org.openhab.binding.oppo.internal.configuration.OppoThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OppoHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OppoHandler extends BaseThingHandler implements OppoMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_SEC = 60;\n+    private static final long POLLING_INTERVAL_SEC = 30;\n+    private static final long INITIAL_POLLING_DELAY_SEC = 10;\n+    private static final long SLEEP_BETWEEN_CMD_MS = 100;\n+\n+    private static final Pattern TIME_CODE_PATTERN = Pattern\n+            .compile(\"^(\\\\d{3}) (\\\\d{3}) ([A-Z]{1}) (\\\\d{2}:\\\\d{2}:\\\\d{2})$\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(OppoHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private OppoStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+    private OppoConnector connector = new OppoDefaultConnector();\n+\n+    private List<StateOption> inputSourceOptions = new ArrayList<>();\n+    private List<StateOption> hdmiModeOptions = new ArrayList<>();\n+\n+    private long lastEventReceived = System.currentTimeMillis();\n+    private String versionString = BLANK;\n+    private String verboseMode = VERBOSE_2;\n+    private String currentChapter = BLANK;\n+    private String currentTimeMode = T;\n+    private String currentPlayMode = BLANK;\n+    private boolean isUDP20X = false;\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public OppoHandler(Thing thing, OppoStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        OppoThingConfiguration config = getConfigAs(OppoThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        String model = BLANK;\n+        boolean override = false;\n+\n+        Integer mod = config.model;\n+        String serialPort = config.serialPort;\n+        String host = config.host;\n+        Integer port = config.port;\n+\n+        if (mod == null) {\n+            configError = \"player model must be specified\";\n+            return;\n+        }\n+\n+        if ((serialPort == null || serialPort.isEmpty()) && (host == null || host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (serialPort != null && (host == null || host.isEmpty())) {\n+            if (serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (port == null) {\n+                if ((MODEL83).equals(model)) {\n+                    port = BDP83_PORT;\n+                    override = true;\n+                } else if ((MODEL103).equals(model) || (MODEL105).equals(model)) {\n+                    port = BDP10X_PORT;\n+                    override = true;\n+                } else {\n+                    port = BDP20X_PORT;\n+                }\n+            } else if (port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (serialPort != null) {\n+            connector = new OppoSerialConnector(serialPortManager, serialPort);\n+        } else if (port != null) {\n+            connector = new OppoIpConnector(host, port);\n+            connector.overrideCmdPreamble(override);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"configuration error\");\n+            return;\n+        }\n+\n+        if (config.verboseMode) {\n+            this.verboseMode = VERBOSE_3;\n+        }\n+\n+        if (MODEL203.equals(model) || MODEL205.equals(model)) {\n+            this.isUDP20X = true;\n+        }\n+\n+        this.buildOptionDropdowns(model);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_SOURCE),\n+                inputSourceOptions);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_HDMI_MODE),\n+                hdmiModeOptions);\n+\n+        // remove channels not needed for this model\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        if (MODEL83.equals(model)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(CHANNEL_SUB_SHIFT)\n+                    || c.getUID().getId().equals(CHANNEL_OSD_POSITION)));\n+        }\n+\n+        if (MODEL83.equals(model) || MODEL103.equals(model) || MODEL105.equals(model)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(CHANNEL_ASPECT_RATIO)\n+                    || c.getUID().getId().equals(CHANNEL_HDR_MODE)));\n+        }\n+\n+        // no query to determine this, so set the default value at startup\n+        updateChannelState(CHANNEL_TIME_MODE, currentTimeMode);\n+\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Handle a command the UI\n+     *\n+     * @param channelUID the channel sending the command\n+     * @param command the command received\n+     * \n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        synchronized (sequenceLock) {\n+            try {\n+                String commandStr = command.toString();\n+                switch (channel) {\n+                    case CHANNEL_POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(\n+                                    command == OnOffType.ON ? OppoCommand.POWER_ON : OppoCommand.POWER_OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            connector.sendCommand(OppoCommand.SET_VOLUME_LEVEL, commandStr);\n+                        }\n+                        break;\n+                    case CHANNEL_MUTE:\n+                        if (command instanceof OnOffType) {\n+                            if (command == OnOffType.ON) {\n+                                connector.sendCommand(OppoCommand.SET_VOLUME_LEVEL, MUTE);\n+                            } else {\n+                                connector.sendCommand(OppoCommand.MUTE);\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            connector.sendCommand(OppoCommand.SET_INPUT_SOURCE, String.valueOf(value));\n+                        }\n+                        break;\n+                    case CHANNEL_CONTROL:\n+                        this.handleControlCommand(command);\n+                        break;\n+                    case CHANNEL_TIME_MODE:\n+                        if (command instanceof StringType) {\n+                            connector.sendCommand(OppoCommand.SET_TIME_DISPLAY, commandStr);\n+                            currentTimeMode = commandStr;\n+                        }\n+                        break;\n+                    case CHANNEL_REPEAT_MODE:\n+                        if (command instanceof StringType) {\n+                            // this one is lame, the response code when querying repeat mode is two digits,\n+                            // but setting it is a 2-3 letter code.\n+                            connector.sendCommand(OppoCommand.SET_REPEAT, OppoStatusCodes.REPEAT_MODE.get(commandStr));\n+                        }\n+                        break;\n+                    case CHANNEL_ZOOM_MODE:\n+                        if (command instanceof StringType) {\n+                            // again why could't they make the query code and set code the same?\n+                            connector.sendCommand(OppoCommand.SET_ZOOM_RATIO,\n+                                    OppoStatusCodes.ZOOM_MODE.get(commandStr));\n+                        }\n+                        break;\n+                    case CHANNEL_SUB_SHIFT:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            connector.sendCommand(OppoCommand.SET_SUBTITLE_SHIFT, String.valueOf(value));\n+                        }\n+                        break;\n+                    case CHANNEL_OSD_POSITION:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            connector.sendCommand(OppoCommand.SET_OSD_POSITION, String.valueOf(value));\n+                        }\n+                        break;\n+                    case CHANNEL_HDMI_MODE:\n+                        if (command instanceof StringType) {\n+                            connector.sendCommand(OppoCommand.SET_HDMI_MODE, commandStr);\n+                        }\n+                        break;\n+                    case CHANNEL_HDR_MODE:\n+                        if (command instanceof StringType) {\n+                            connector.sendCommand(OppoCommand.SET_HDR_MODE, commandStr);\n+                        }\n+                        break;\n+                    case CHANNEL_REMOTE_BUTTON:\n+                        if (command instanceof StringType) {\n+                            connector.sendCommand(commandStr);\n+                        }\n+                        break;\n+                    default:\n+                        logger.warn(\"Unknown Command {} from channel {}\", command, channel);\n+                        break;\n+                }\n+            } catch (OppoException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the Oppo player\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (OppoException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the Oppo player\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    /**\n+     * Handle an event received from the Oppo player\n+     *\n+     * @param event the event to process\n+     */\n+    @Override\n+    public void onNewMessageEvent(OppoMessageEvent evt) {\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+        lastEventReceived = System.currentTimeMillis();\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (this.getThing().getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.versionString);\n+        }\n+\n+        synchronized (sequenceLock) {\n+            try {\n+                switch (key) {\n+                    case NOP: // ignore\n+                        break;\n+                    case UTC:\n+                        // Player sent a time code update ie: 000 000 T 00:00:01\n+                        // g1 = title(movie only; cd always 000), g2 = chapter(movie)/track(cd), g3 = time display code,\n+                        // g4 = time\n+                        Matcher matcher = TIME_CODE_PATTERN.matcher(updateData);\n+                        if (matcher.find()) {\n+                            // only update these when chapter/track changes to prevent spamming the channels with\n+                            // unnecessary updates\n+                            if (!currentChapter.equals(matcher.group(2))) {\n+                                currentChapter = matcher.group(2);\n+                                // for CDs this will get track 1/x also\n+                                connector.sendCommand(OppoCommand.QUERY_TITLE_TRACK);\n+                                // for movies shows chapter 1/x; always 0/0 for CDs\n+                                connector.sendCommand(OppoCommand.QUERY_CHAPTER);\n+                            }\n+\n+                            if (!currentTimeMode.equals(matcher.group(3))) {\n+                                currentTimeMode = matcher.group(3);\n+                                updateChannelState(CHANNEL_TIME_MODE, currentTimeMode);\n+                            }\n+                            updateChannelState(CHANNEL_TIME_DISPLAY, matcher.group(4));\n+                        } else {\n+                            logger.debug(\"no match on message: {}\", updateData);\n+                        }\n+                        break;\n+                    case QTE:\n+                    case QTR:\n+                    case QCE:\n+                    case QCR:\n+                        // these are used with verbose mode 2\n+                        updateChannelState(CHANNEL_TIME_DISPLAY, updateData);\n+                        break;\n+                    case QVR:\n+                        this.versionString = updateData;\n+                        break;\n+                    case QPW:\n+                        updateChannelState(CHANNEL_POWER, updateData);\n+                        if (OFF.equals(updateData)) {\n+                            currentPlayMode = BLANK;\n+                        }\n+                        break;\n+                    case UPW:\n+                        updateChannelState(CHANNEL_POWER, ONE.equals(updateData) ? ON : OFF);\n+                        if (ZERO.equals(updateData)) {\n+                            currentPlayMode = BLANK;\n+                        }\n+                        break;\n+                    case QVL:\n+                    case UVL:\n+                    case VUP:\n+                    case VDN:\n+                        if (MUTE.equals(updateData) || MUT.equals(updateData)) { // query sends MUTE, update sends MUT\n+                            updateChannelState(CHANNEL_MUTE, ON);\n+                        } else if (UMT.equals(updateData)) {\n+                            updateChannelState(CHANNEL_MUTE, OFF);\n+                        } else {\n+                            updateChannelState(CHANNEL_VOLUME, updateData);\n+                            updateChannelState(CHANNEL_MUTE, OFF);\n+                        }\n+                        break;\n+                    case QIS:\n+                    case UIS:\n+                        // example: 0 BD-PLAYER, split off just the number\n+                        updateChannelState(CHANNEL_SOURCE, updateData.split(SPACE)[0]);\n+                        break;\n+                    case UPL:\n+                        // we got the playback status update, throw it away and call the query because the text output\n+                        // is better\n+                        connector.sendCommand(OppoCommand.QUERY_PLAYBACK_STATUS);\n+                        break;\n+                    case QTK:\n+                        // example: 02/10, split off both numbers\n+                        updateChannelState(CHANNEL_CURRENT_TITLE, updateData.split(SLASH)[0]);\n+                        updateChannelState(CHANNEL_TOTAL_TITLE, updateData.split(SLASH)[1]);", "originalCommit": "51b8e3c55472c06fb3c0699f4709c0559ec2145f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM1NjA3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7746#discussion_r460356077", "bodyText": "done for all", "author": "mlobstein", "createdAt": "2020-07-25T03:02:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5MzA1NA=="}], "type": "inlineReview"}, {"oid": "c17ea6feeb6b09f53b37ce4be4daf8a55b5946c3", "url": "https://github.com/openhab/openhab-addons/commit/c17ea6feeb6b09f53b37ce4be4daf8a55b5946c3", "message": "Merge branch '2.5.x' into OppoBluray", "committedDate": "2020-07-24T14:19:24Z", "type": "commit"}, {"oid": "0abfee38903fa16d60e53e6a1aa0e9d8c995e9b5", "url": "https://github.com/openhab/openhab-addons/commit/0abfee38903fa16d60e53e6a1aa0e9d8c995e9b5", "message": "review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-25T03:18:34Z", "type": "commit"}, {"oid": "9b579193ad576302dc462c6574b4890746be2025", "url": "https://github.com/openhab/openhab-addons/commit/9b579193ad576302dc462c6574b4890746be2025", "message": "Merge pull request #7 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-07-25T03:38:33Z", "type": "commit"}, {"oid": "0d943cba8e1c11af413eafaa29d5c9383954e2de", "url": "https://github.com/openhab/openhab-addons/commit/0d943cba8e1c11af413eafaa29d5c9383954e2de", "message": "Merge branch '2.5.x' into OppoBluRay", "committedDate": "2020-07-25T03:39:46Z", "type": "commit"}, {"oid": "ee1778f12816c1413bbaf2dbf849b9f19416ee3d", "url": "https://github.com/openhab/openhab-addons/commit/ee1778f12816c1413bbaf2dbf849b9f19416ee3d", "message": "update version\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-25T03:46:18Z", "type": "commit"}, {"oid": "ee1778f12816c1413bbaf2dbf849b9f19416ee3d", "url": "https://github.com/openhab/openhab-addons/commit/ee1778f12816c1413bbaf2dbf849b9f19416ee3d", "message": "update version\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-25T03:46:18Z", "type": "forcePushed"}, {"oid": "42fa555b6b40d18b9a8e36aff41de41c1022adbf", "url": "https://github.com/openhab/openhab-addons/commit/42fa555b6b40d18b9a8e36aff41de41c1022adbf", "message": "review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-27T05:24:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY4OTc3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7746#discussion_r453689774", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final Set<OppoCommand> INITIAL_COMMANDS = new HashSet<OppoCommand>(\n          \n          \n            \n                public static final Set<OppoCommand> INITIAL_COMMANDS = new HashSet<>(\n          \n      \n    \n    \n  \n\nSame comment below.", "author": "Hilbrand", "createdAt": "2020-07-13T14:27:20Z", "path": "bundles/org.openhab.binding.oppo/src/main/java/org/openhab/binding/oppo/internal/communication/OppoCommand.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.oppo.internal.communication;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Represents the different kinds of commands\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum OppoCommand {\n+    POWER_ON(\"PON\"),\n+    POWER_OFF(\"POF\"),\n+    PLAY(\"PLA\"),\n+    PAUSE(\"PAU\"),\n+    PREV(\"PRE\"),\n+    REWIND(\"REV\"),\n+    FFORWARD(\"FWD\"),\n+    NEXT(\"NXT\"),\n+    MUTE(\"MUT\"),\n+    QUERY_POWER_STATUS(\"QPW\"),\n+    QUERY_FIRMWARE_VERSION(\"QVR\"),\n+    QUERY_VOLUME(\"QVL\"),\n+    QUERY_HDMI_RESOLUTION(\"QHD\"),\n+    QUERY_HDR_SETTING(\"QHR\"),\n+    QUERY_PLAYBACK_STATUS(\"QPL\"),\n+    QUERY_TITLE_TRACK(\"QTK\"),\n+    QUERY_CHAPTER(\"QCH\"),\n+    QUERY_TITLE_ELAPSED(\"QTE\"),\n+    QUERY_TITLE_REMAIN(\"QTR\"),\n+    QUERY_CHAPTER_ELAPSED(\"QCE\"),\n+    QUERY_CHAPTER_REMAIN(\"QCR\"),\n+    QUERY_DISC_TYPE(\"QDT\"),\n+    QUERY_AUDIO_TYPE(\"QAT\"),\n+    QUERY_SUBTITLE_TYPE(\"QST\"),\n+    QUERY_SUBTITLE_SHIFT(\"QSH\"),\n+    QUERY_OSD_POSITION(\"QOP\"),\n+    QUERY_REPEAT_MODE(\"QRP\"),\n+    QUERY_ZOOM_MODE(\"QZM\"),\n+    QUERY_INPUT_SOURCE(\"QIS\"),\n+    SET_VERBOSE_MODE(\"SVM\"),\n+    SET_HDMI_MODE(\"SHD\"),\n+    SET_HDR_MODE(\"SHR\"),\n+    SET_ZOOM_RATIO(\"SZM\"),\n+    SET_VOLUME_LEVEL(\"SVL\"),\n+    SET_REPEAT(\"SRP\"),\n+    SET_SUBTITLE_SHIFT(\"SSH\"),\n+    SET_OSD_POSITION(\"SOP\"),\n+    SET_TIME_DISPLAY(\"STC\"),\n+    SET_INPUT_SOURCE(\"SIS\"),\n+    NO_OP(\"NOP\");\n+\n+    private String value;\n+\n+    public static final Set<OppoCommand> INITIAL_COMMANDS = new HashSet<OppoCommand>(", "originalCommit": "51b8e3c55472c06fb3c0699f4709c0559ec2145f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY5Mjc2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7746#discussion_r453692767", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private ExecutorService executorService;\n          \n          \n            \n                private @Nullable ExecutorService executorService;", "author": "Hilbrand", "createdAt": "2020-07-13T14:31:24Z", "path": "bundles/org.openhab.binding.oppo/src/main/java/org/openhab/binding/oppo/internal/discovery/OppoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.oppo.internal.discovery;\n+\n+import static org.openhab.binding.oppo.internal.OppoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Discovery class for the Oppo Blu-ray Player line.\n+ * The player sends SDDP packets continuously for us to discover.\n+ *\n+ * @author Tim Roberts - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Oppo binding\n+ */\n+\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.oppo\")\n+public class OppoDiscoveryService extends AbstractDiscoveryService {\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_PLAYER);\n+\n+    private final Logger logger = LoggerFactory.getLogger(OppoDiscoveryService.class);\n+\n+    /**\n+     * Address SDDP broadcasts on\n+     */\n+    private static final String SDDP_ADDR = \"239.255.255.251\";\n+\n+    /**\n+     * Port number SDDP uses\n+     */\n+    private static final int SDDP_PORT = 7624;\n+\n+    /**\n+     * SDDP packet should be only 512 in size - make it 600 to give us some room\n+     */\n+    private static final int BUFFER_SIZE = 600;\n+\n+    /**\n+     * Socket read timeout (in ms) - allows us to shutdown the listening every TIMEOUT\n+     */\n+    private static final int TIMEOUT = 1000;\n+\n+    /**\n+     * Whether we are currently scanning or not\n+     */\n+    private boolean scanning;\n+\n+    /**\n+     * The {@link ExecutorService} to run the listening threads on.\n+     */\n+    @Nullable\n+    private ExecutorService executorService;", "originalCommit": "51b8e3c55472c06fb3c0699f4709c0559ec2145f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcwOTYxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7746#discussion_r453709615", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void overrideCmdPreamble(Boolean override) {\n          \n          \n            \n                public void overrideCmdPreamble(boolean override) {", "author": "Hilbrand", "createdAt": "2020-07-13T14:54:19Z", "path": "bundles/org.openhab.binding.oppo/src/main/java/org/openhab/binding/oppo/internal/communication/OppoConnector.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.oppo.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.oppo.internal.OppoException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the Oppo player\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Oppo binding\n+ */\n+@NonNullByDefault\n+public abstract class OppoConnector {\n+    private static final Pattern QRY_PATTERN = Pattern.compile(\"^@(Q[A-Z0-9]{2}|VUP|VDN) OK (.*)$\");\n+    private static final Pattern STUS_PATTERN = Pattern.compile(\"^@(U[A-Z0-9]{2}) (.*)$\");\n+\n+    private static final String NOP_OK = \"@NOP OK\";\n+    private static final String NOP = \"NOP\";\n+    private static final String OK = \"OK\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(OppoConnector.class);\n+\n+    private String beginCmd = \"#\";\n+    private String endCmd = \"\\r\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<OppoMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Called when using direct IP connection for 83/93/95/103/105\n+     * overrides the command message preamble and removes the CR at the end\n+     */\n+    public void overrideCmdPreamble(Boolean override) {", "originalCommit": "51b8e3c55472c06fb3c0699f4709c0559ec2145f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxMDIxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7746#discussion_r453710211", "bodyText": "Can you give a more specific error message. The generic configuration error won't help the user fix the configuration problem.", "author": "Hilbrand", "createdAt": "2020-07-13T14:55:03Z", "path": "bundles/org.openhab.binding.oppo/src/main/java/org/openhab/binding/oppo/internal/handler/OppoHandler.java", "diffHunk": "@@ -0,0 +1,834 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.oppo.internal.handler;\n+\n+import static org.openhab.binding.oppo.internal.OppoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.oppo.internal.OppoException;\n+import org.openhab.binding.oppo.internal.OppoStateDescriptionOptionProvider;\n+import org.openhab.binding.oppo.internal.communication.OppoCommand;\n+import org.openhab.binding.oppo.internal.communication.OppoConnector;\n+import org.openhab.binding.oppo.internal.communication.OppoDefaultConnector;\n+import org.openhab.binding.oppo.internal.communication.OppoIpConnector;\n+import org.openhab.binding.oppo.internal.communication.OppoMessageEvent;\n+import org.openhab.binding.oppo.internal.communication.OppoMessageEventListener;\n+import org.openhab.binding.oppo.internal.communication.OppoSerialConnector;\n+import org.openhab.binding.oppo.internal.communication.OppoStatusCodes;\n+import org.openhab.binding.oppo.internal.configuration.OppoThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OppoHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OppoHandler extends BaseThingHandler implements OppoMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_SEC = 60;\n+    private static final long POLLING_INTERVAL_SEC = 30;\n+    private static final long INITIAL_POLLING_DELAY_SEC = 10;\n+    private static final long SLEEP_BETWEEN_CMD_MS = 100;\n+\n+    private static final Pattern TIME_CODE_PATTERN = Pattern\n+            .compile(\"^(\\\\d{3}) (\\\\d{3}) ([A-Z]{1}) (\\\\d{2}:\\\\d{2}:\\\\d{2})$\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(OppoHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private OppoStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+    private OppoConnector connector = new OppoDefaultConnector();\n+\n+    private List<StateOption> inputSourceOptions = new ArrayList<>();\n+    private List<StateOption> hdmiModeOptions = new ArrayList<>();\n+\n+    private long lastEventReceived = System.currentTimeMillis();\n+    private String versionString = BLANK;\n+    private String verboseMode = VERBOSE_2;\n+    private String currentChapter = BLANK;\n+    private String currentTimeMode = T;\n+    private String currentPlayMode = BLANK;\n+    private boolean isUDP20X = false;\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public OppoHandler(Thing thing, OppoStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        OppoThingConfiguration config = getConfigAs(OppoThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        String model = BLANK;\n+        boolean override = false;\n+\n+        Integer mod = config.model;\n+        String serialPort = config.serialPort;\n+        String host = config.host;\n+        Integer port = config.port;\n+\n+        if (mod == null) {\n+            configError = \"player model must be specified\";\n+            return;\n+        }\n+\n+        if ((serialPort == null || serialPort.isEmpty()) && (host == null || host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (serialPort != null && (host == null || host.isEmpty())) {\n+            if (serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (port == null) {\n+                if ((MODEL83).equals(model)) {\n+                    port = BDP83_PORT;\n+                    override = true;\n+                } else if ((MODEL103).equals(model) || (MODEL105).equals(model)) {\n+                    port = BDP10X_PORT;\n+                    override = true;\n+                } else {\n+                    port = BDP20X_PORT;\n+                }\n+            } else if (port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (serialPort != null) {\n+            connector = new OppoSerialConnector(serialPortManager, serialPort);\n+        } else if (port != null) {\n+            connector = new OppoIpConnector(host, port);\n+            connector.overrideCmdPreamble(override);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"configuration error\");", "originalCommit": "51b8e3c55472c06fb3c0699f4709c0559ec2145f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE5ODY2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7746#discussion_r461198666", "bodyText": "done", "author": "mlobstein", "createdAt": "2020-07-27T22:08:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxMDIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEyMTQ5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7746#discussion_r461121495", "bodyText": "Something to consider. You could put these different models in an enum, with specific model features in the enum, that are then accessed via generic methods. That way you can write the rest of the code in a generic way. It makes is also easier to add new models. If you understand what I mean. But that might be something if you want to do some generic improvements in the future.", "author": "Hilbrand", "createdAt": "2020-07-27T19:34:17Z", "path": "bundles/org.openhab.binding.oppo/src/main/java/org/openhab/binding/oppo/internal/OppoBindingConstants.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.oppo.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link OppoBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OppoBindingConstants {\n+    public static final String BINDING_ID = \"oppo\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_PLAYER = new ThingTypeUID(BINDING_ID, \"player\");\n+\n+    public static final int MODEL83 = 83;", "originalCommit": "42fa555b6b40d18b9a8e36aff41de41c1022adbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwMDQ1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7746#discussion_r461200456", "bodyText": "That is a good idea. But with this line of players, there will be no new models. I will keep your suggestion in mind for my other bindings.", "author": "mlobstein", "createdAt": "2020-07-27T22:12:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEyMTQ5NQ=="}], "type": "inlineReview"}, {"oid": "697ba58981ea6d486a45d6486fd2cbdc3c4fa396", "url": "https://github.com/openhab/openhab-addons/commit/697ba58981ea6d486a45d6486fd2cbdc3c4fa396", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-27T22:03:29Z", "type": "commit"}]}