{"pr_number": 9146, "pr_title": "[mielecloud] Initial contribution of the Miele Cloud binding", "pr_createdAt": "2020-11-27T17:23:50Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/9146", "timeline": [{"oid": "6582025c1528e8b30c0ace82e86da942293af0d5", "url": "https://github.com/openhab/openhab-addons/commit/6582025c1528e8b30c0ace82e86da942293af0d5", "message": "Initial contribution of the Miele Cloud binding\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2020-11-30T07:55:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY0NDMzMg==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r533644332", "bodyText": "Does this annotation has any effect? Same for below.", "author": "fwolter", "createdAt": "2020-12-01T18:50:54Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/MieleCloudBindingConstants.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link MieleCloudBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Roland Edelhoff - Initial contribution\n+ * @author Bj\u00f6rn Lange - Added locale config parameter, added i18n key collection\n+ * @author Benjamin Bolte - Add pre-heat finished and plate step channels, door state and door alarm channels, info\n+ *         state channel and map signal flags from API\n+ * @author Bj\u00f6rn Lange - Add elapsed time channel, dish warmer thing\n+ */\n+@NonNullByDefault\n+public final class MieleCloudBindingConstants {\n+\n+    private MieleCloudBindingConstants() {\n+    }\n+\n+    /**\n+     * ID of the binding.\n+     */\n+    public static final String BINDING_ID = \"mielecloud\";\n+\n+    /**\n+     * Thing type ID of Miele cloud bridges / accounts.\n+     */\n+    public static final String BRIDGE_TYPE_ID = \"account\";\n+\n+    /**\n+     * The {@link ThingTypeUID} of Miele cloud bridges / accounts.\n+     */\n+    public static final ThingTypeUID THING_TYPE_BRIDGE = new ThingTypeUID(BINDING_ID, BRIDGE_TYPE_ID);\n+\n+    /**\n+     * The {@link ThingTypeUID} of Miele washing machines.\n+     */\n+    public static final ThingTypeUID THING_TYPE_WASHING_MACHINE = new ThingTypeUID(BINDING_ID, \"washing_machine\");\n+\n+    /**\n+     * The {@link ThingTypeUID} of Miele washer-dryers.\n+     */\n+    public static final ThingTypeUID THING_TYPE_WASHER_DRYER = new ThingTypeUID(BINDING_ID, \"washer_dryer\");\n+\n+    /**\n+     * The {@link ThingTypeUID} of Miele coffee machines.\n+     */\n+    public static final ThingTypeUID THING_TYPE_COFFEE_SYSTEM = new ThingTypeUID(BINDING_ID, \"coffee_system\");\n+\n+    /**\n+     * The {@link ThingTypeUID} of Miele fridge-freezers.\n+     */\n+    public static final ThingTypeUID THING_TYPE_FRIDGE_FREEZER = new ThingTypeUID(BINDING_ID, \"fridge_freezer\");\n+\n+    /**\n+     * The {@link ThingTypeUID} of Miele fridges.\n+     */\n+    public static final ThingTypeUID THING_TYPE_FRIDGE = new ThingTypeUID(BINDING_ID, \"fridge\");\n+\n+    /**\n+     * The {@link ThingTypeUID} of Miele freezers.\n+     */\n+    public static final ThingTypeUID THING_TYPE_FREEZER = new ThingTypeUID(BINDING_ID, \"freezer\");\n+\n+    /**\n+     * The {@link ThingTypeUID} of Miele ovens.\n+     */\n+    public static final ThingTypeUID THING_TYPE_OVEN = new ThingTypeUID(BINDING_ID, \"oven\");\n+\n+    /**\n+     * The {@link ThingTypeUID} of Miele hobs.\n+     */\n+    public static final ThingTypeUID THING_TYPE_HOB = new ThingTypeUID(BINDING_ID, \"hob\");\n+\n+    /**\n+     * The {@link ThingTypeUID} of Miele wine storages.\n+     */\n+    public static final ThingTypeUID THING_TYPE_WINE_STORAGE = new ThingTypeUID(BINDING_ID, \"wine_storage\");\n+\n+    /**\n+     * The {@link ThingTypeUID} of Miele dishwashers.\n+     */\n+    public static final ThingTypeUID THING_TYPE_DISHWASHER = new ThingTypeUID(BINDING_ID, \"dishwasher\");\n+\n+    /**\n+     * The {@link ThingTypeUID} of Miele dryers.\n+     */\n+    public static final ThingTypeUID THING_TYPE_DRYER = new ThingTypeUID(BINDING_ID, \"dryer\");\n+\n+    /**\n+     * The {@link ThingTypeUID} of Miele hoods.\n+     */\n+    public static final ThingTypeUID THING_TYPE_HOOD = new ThingTypeUID(BINDING_ID, \"hood\");\n+\n+    /**\n+     * The {@link ThingTypeUID} of Miele dish warmers.\n+     */\n+    public static final ThingTypeUID THING_TYPE_DISH_WARMER = new ThingTypeUID(BINDING_ID, \"dish_warmer\");\n+\n+    /**\n+     * The {@link ThingTypeUID} of Miele robotic vacuum cleaners.\n+     */\n+    public static final ThingTypeUID THING_TYPE_ROBOTIC_VACUUM_CLEANER = new ThingTypeUID(BINDING_ID,\n+            \"robotic_vacuum_cleaner\");\n+\n+    /**\n+     * Name of the property storing the OAuth2 access token.\n+     */\n+    public static final String PROPERTY_ACCESS_TOKEN = \"accessToken\";\n+\n+    /**\n+     * Name of the configuration parameter for the locale. The locale is stored as a 2-letter language code.\n+     */\n+    public static final String CONFIG_PARAM_LOCALE = \"locale\";\n+\n+    /**\n+     * Constants for all channels.\n+     */\n+    @NonNullByDefault({})", "originalCommit": "6582025c1528e8b30c0ace82e86da942293af0d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA0OTY0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r536049641", "bodyText": "The build for openHAB 2.5.x used to warn on internal classes that they should be annotated with @NonNullByDefault although the containing class was annotated. This was our workaround. I checked and it seems it isn't necessary any more so I will remove these annotations.", "author": "BjoernLange", "createdAt": "2020-12-04T12:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY0NDMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY0NDY5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r533644692", "bodyText": "Did you make this an unchecked exception by intention?", "author": "fwolter", "createdAt": "2020-12-01T18:51:33Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/auth/OAuthException.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.auth;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Indicates an error in the OAuth2 authorization process.\n+ *\n+ * @author Roland Edelhoff - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OAuthException extends RuntimeException {", "originalCommit": "6582025c1528e8b30c0ace82e86da942293af0d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA1Mjc3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r536052775", "bodyText": "Yes, we actually prefer unchecked exceptions. Shall we change it to a checked one?", "author": "BjoernLange", "createdAt": "2020-12-04T12:06:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY0NDY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA5MDk0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r537090941", "bodyText": "That would fit better to the other code in this repo, but I won't insist on it. As you're using many lambdas converting could be painful.", "author": "fwolter", "createdAt": "2020-12-06T17:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY0NDY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY0NTA0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r533645045", "bodyText": "You could inject this via the constructor to avoid the Nullable annotation. The framework takes care, that this is not null. Same for MieleCloudConfigService.", "author": "fwolter", "createdAt": "2020-12-01T18:52:09Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/auth/OpenHabOAuthTokenRefresher.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.auth;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handles refreshing of OAuth2 tokens managed by the openHAB runtime.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial contribution\n+ */\n+@Component\n+@NonNullByDefault\n+public final class OpenHabOAuthTokenRefresher implements OAuthTokenRefresher {\n+    private final Logger logger = LoggerFactory.getLogger(OpenHabOAuthTokenRefresher.class);\n+\n+    @Nullable\n+    private OAuthFactory oauthFactory;", "originalCommit": "6582025c1528e8b30c0ace82e86da942293af0d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA4MzAxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r536083019", "bodyText": "Thank you for pointing this out! It saves a lot of trouble. Is this also possible for MieleHandlerFactory?", "author": "BjoernLange", "createdAt": "2020-12-04T13:00:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY0NTA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA5MTExNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r537091115", "bodyText": "Yes.", "author": "fwolter", "createdAt": "2020-12-06T17:58:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY0NTA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY0OTQxNw==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r533649417", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "author": "fwolter", "createdAt": "2020-12-01T18:59:03Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/auth/OpenHabOAuthTokenRefresher.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.auth;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handles refreshing of OAuth2 tokens managed by the openHAB runtime.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial contribution\n+ */\n+@Component\n+@NonNullByDefault\n+public final class OpenHabOAuthTokenRefresher implements OAuthTokenRefresher {\n+    private final Logger logger = LoggerFactory.getLogger(OpenHabOAuthTokenRefresher.class);\n+\n+    @Nullable\n+    private OAuthFactory oauthFactory;\n+    private Map<String, @Nullable AccessTokenRefreshListener> listenerByServiceHandle = new HashMap<>();\n+\n+    @Reference\n+    public void setOAuthFactory(OAuthFactory oauthFactory) {\n+        this.oauthFactory = oauthFactory;\n+    }\n+\n+    public void unsetOAuthFactory(OAuthFactory oauthFactory) {\n+        this.oauthFactory = null;\n+    }\n+\n+    @Override\n+    public void setRefreshListener(OAuthTokenRefreshListener listener, String serviceHandle) {\n+        final AccessTokenRefreshListener refreshListener = tokenResponse -> {\n+            final String accessToken = tokenResponse.getAccessToken();\n+            if (accessToken == null) {\n+                // Fail without exception to ensure that the OAuthClientService notifies all listeners.\n+                logger.warn(\"Ignoring access token response without access token.\");\n+            } else {\n+                listener.onNewAccessToken(accessToken);\n+            }\n+        };\n+\n+        OAuthClientService clientService = getOAuthClientService(serviceHandle);\n+        clientService.addAccessTokenRefreshListener(refreshListener);\n+        listenerByServiceHandle.put(serviceHandle, refreshListener);\n+    }\n+\n+    @Override\n+    public void unsetRefreshListener(String serviceHandle) {\n+        final AccessTokenRefreshListener refreshListener = listenerByServiceHandle.get(serviceHandle);\n+        if (refreshListener != null) {\n+            try {\n+                OAuthClientService clientService = getOAuthClientService(serviceHandle);\n+                clientService.removeAccessTokenRefreshListener(refreshListener);\n+            } catch (OAuthException e) {\n+                logger.warn(\"Failed to remove refresh listener: OAuth client service is unavailable.\");\n+                logger.debug(\"Exception details:\", e);\n+            }\n+        }\n+        listenerByServiceHandle.remove(serviceHandle);\n+    }\n+\n+    @Override\n+    public void refreshToken(String serviceHandle) {\n+        if (listenerByServiceHandle.get(serviceHandle) == null) {\n+            logger.warn(\"Token refreshing was requested but there is no token refresh listener registered!\");\n+            return;\n+        }\n+\n+        OAuthClientService clientService = getOAuthClientService(serviceHandle);\n+        refreshAccessToken(clientService);\n+    }\n+\n+    private OAuthClientService getOAuthClientService(String serviceHandle) {\n+        final OAuthFactory oauthFactory = this.oauthFactory;\n+        if (oauthFactory == null) {\n+            throw new OAuthException(\"OAuth factory is not available.\");\n+        }\n+\n+        final OAuthClientService clientService = oauthFactory.getOAuthClientService(serviceHandle);\n+        if (clientService == null) {\n+            throw new OAuthException(\"OAuth client service is not available.\");\n+        }\n+        return clientService;\n+    }\n+\n+    private void refreshAccessToken(OAuthClientService clientService) {\n+        try {\n+            final AccessTokenResponse accessTokenResponse = clientService.refreshToken();\n+            final String accessToken = accessTokenResponse.getAccessToken();\n+            if (accessToken == null) {\n+                throw new OAuthException(\"Access token is not available.\");\n+            }\n+        } catch (org.openhab.core.auth.client.oauth2.OAuthException e) {\n+            throw new OAuthException(\"An error occured during token refresh: \" + e.getMessage(), e);\n+        } catch (IOException e) {\n+            throw new OAuthException(\"A network error occured during token refresh: \" + e.getMessage(), e);\n+        } catch (OAuthResponseException e) {\n+            throw new OAuthException(\"Miele cloud service returned an illegal response: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    @Override\n+    public Optional<String> getAccessTokenFromStorage(String serviceHandle) {\n+        try {\n+            AccessTokenResponse tokenResponse = getOAuthClientService(serviceHandle).getAccessTokenResponse();\n+            if (tokenResponse == null) {\n+                return Optional.empty();\n+            } else {\n+                return Optional.of(tokenResponse.getAccessToken());\n+            }\n+        } catch (Exception e) {", "originalCommit": "6582025c1528e8b30c0ace82e86da942293af0d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEwNzE3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r536107176", "bodyText": "We expect multiple exceptions here:\n\norg.openhab.binding.mielecloud.internal.auth.OAuthException: If the OAuthClientService is not available\nIOException: If a network/IO issue occurs while getting the access token response\nOAuthErrorException / OAuthResponseException: If an OAUTH error response was returned by the cloud while getting the access token response\nOAuthException: For other exceptions that occurred  while getting the access token response\n\nThe latter three come from OAuthClientService.getAccessTokenResponse() (btw. the documentation seems to be outdated there). We want to handle all these exceptions the same way and their common parent is, well, Exception.", "author": "BjoernLange", "createdAt": "2020-12-04T13:41:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY0OTQxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjc5NjU5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r536796597", "bodyText": "In general you want to avoid catching Exception unless you are handling all cases of Exception.  If you have multiple exception types and want to handle them the same way you use multi-catch:\ncatch (OAuthException | IOException | OAuthErrorException | OAuthResponseException( {", "author": "boc-tothefuture", "createdAt": "2020-12-05T14:42:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY0OTQxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA5MTIyMg==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r537091222", "bodyText": "I agree to @boc-tothefuture . Catching Exception catches also all RuntimeExceptions", "author": "fwolter", "createdAt": "2020-12-06T17:58:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY0OTQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1MDEwMA==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r533650100", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug or warn.", "author": "fwolter", "createdAt": "2020-12-01T19:00:02Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/auth/OpenHabOAuthTokenRefresher.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.auth;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handles refreshing of OAuth2 tokens managed by the openHAB runtime.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial contribution\n+ */\n+@Component\n+@NonNullByDefault\n+public final class OpenHabOAuthTokenRefresher implements OAuthTokenRefresher {\n+    private final Logger logger = LoggerFactory.getLogger(OpenHabOAuthTokenRefresher.class);\n+\n+    @Nullable\n+    private OAuthFactory oauthFactory;\n+    private Map<String, @Nullable AccessTokenRefreshListener> listenerByServiceHandle = new HashMap<>();\n+\n+    @Reference\n+    public void setOAuthFactory(OAuthFactory oauthFactory) {\n+        this.oauthFactory = oauthFactory;\n+    }\n+\n+    public void unsetOAuthFactory(OAuthFactory oauthFactory) {\n+        this.oauthFactory = null;\n+    }\n+\n+    @Override\n+    public void setRefreshListener(OAuthTokenRefreshListener listener, String serviceHandle) {\n+        final AccessTokenRefreshListener refreshListener = tokenResponse -> {\n+            final String accessToken = tokenResponse.getAccessToken();\n+            if (accessToken == null) {\n+                // Fail without exception to ensure that the OAuthClientService notifies all listeners.\n+                logger.warn(\"Ignoring access token response without access token.\");\n+            } else {\n+                listener.onNewAccessToken(accessToken);\n+            }\n+        };\n+\n+        OAuthClientService clientService = getOAuthClientService(serviceHandle);\n+        clientService.addAccessTokenRefreshListener(refreshListener);\n+        listenerByServiceHandle.put(serviceHandle, refreshListener);\n+    }\n+\n+    @Override\n+    public void unsetRefreshListener(String serviceHandle) {\n+        final AccessTokenRefreshListener refreshListener = listenerByServiceHandle.get(serviceHandle);\n+        if (refreshListener != null) {\n+            try {\n+                OAuthClientService clientService = getOAuthClientService(serviceHandle);\n+                clientService.removeAccessTokenRefreshListener(refreshListener);\n+            } catch (OAuthException e) {\n+                logger.warn(\"Failed to remove refresh listener: OAuth client service is unavailable.\");\n+                logger.debug(\"Exception details:\", e);\n+            }\n+        }\n+        listenerByServiceHandle.remove(serviceHandle);\n+    }\n+\n+    @Override\n+    public void refreshToken(String serviceHandle) {\n+        if (listenerByServiceHandle.get(serviceHandle) == null) {\n+            logger.warn(\"Token refreshing was requested but there is no token refresh listener registered!\");\n+            return;\n+        }\n+\n+        OAuthClientService clientService = getOAuthClientService(serviceHandle);\n+        refreshAccessToken(clientService);\n+    }\n+\n+    private OAuthClientService getOAuthClientService(String serviceHandle) {\n+        final OAuthFactory oauthFactory = this.oauthFactory;\n+        if (oauthFactory == null) {\n+            throw new OAuthException(\"OAuth factory is not available.\");\n+        }\n+\n+        final OAuthClientService clientService = oauthFactory.getOAuthClientService(serviceHandle);\n+        if (clientService == null) {\n+            throw new OAuthException(\"OAuth client service is not available.\");\n+        }\n+        return clientService;\n+    }\n+\n+    private void refreshAccessToken(OAuthClientService clientService) {\n+        try {\n+            final AccessTokenResponse accessTokenResponse = clientService.refreshToken();\n+            final String accessToken = accessTokenResponse.getAccessToken();\n+            if (accessToken == null) {\n+                throw new OAuthException(\"Access token is not available.\");\n+            }\n+        } catch (org.openhab.core.auth.client.oauth2.OAuthException e) {\n+            throw new OAuthException(\"An error occured during token refresh: \" + e.getMessage(), e);\n+        } catch (IOException e) {\n+            throw new OAuthException(\"A network error occured during token refresh: \" + e.getMessage(), e);\n+        } catch (OAuthResponseException e) {\n+            throw new OAuthException(\"Miele cloud service returned an illegal response: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    @Override\n+    public Optional<String> getAccessTokenFromStorage(String serviceHandle) {\n+        try {\n+            AccessTokenResponse tokenResponse = getOAuthClientService(serviceHandle).getAccessTokenResponse();\n+            if (tokenResponse == null) {\n+                return Optional.empty();\n+            } else {\n+                return Optional.of(tokenResponse.getAccessToken());\n+            }\n+        } catch (Exception e) {\n+            logger.info(\"Cannot obtain access token from persistent storage.\");", "originalCommit": "6582025c1528e8b30c0ace82e86da942293af0d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NjkxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r533656919", "bodyText": "This logging pattern is uncommon to OH bindings. If you have a recoverable error like a network fail, you would log a text with the exception's message to debug. If you have a persistent error you would log to warn. These are only examples. See the definitions: https://www.openhab.org/docs/developer/guidelines.html#f-logging\nThe stack trace should only be logged if the message on its own is not sufficient and the stack trace is crucial for debugging.", "author": "fwolter", "createdAt": "2020-12-01T19:11:50Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/auth/OpenHabOAuthTokenRefresher.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.auth;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handles refreshing of OAuth2 tokens managed by the openHAB runtime.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial contribution\n+ */\n+@Component\n+@NonNullByDefault\n+public final class OpenHabOAuthTokenRefresher implements OAuthTokenRefresher {\n+    private final Logger logger = LoggerFactory.getLogger(OpenHabOAuthTokenRefresher.class);\n+\n+    @Nullable\n+    private OAuthFactory oauthFactory;\n+    private Map<String, @Nullable AccessTokenRefreshListener> listenerByServiceHandle = new HashMap<>();\n+\n+    @Reference\n+    public void setOAuthFactory(OAuthFactory oauthFactory) {\n+        this.oauthFactory = oauthFactory;\n+    }\n+\n+    public void unsetOAuthFactory(OAuthFactory oauthFactory) {\n+        this.oauthFactory = null;\n+    }\n+\n+    @Override\n+    public void setRefreshListener(OAuthTokenRefreshListener listener, String serviceHandle) {\n+        final AccessTokenRefreshListener refreshListener = tokenResponse -> {\n+            final String accessToken = tokenResponse.getAccessToken();\n+            if (accessToken == null) {\n+                // Fail without exception to ensure that the OAuthClientService notifies all listeners.\n+                logger.warn(\"Ignoring access token response without access token.\");\n+            } else {\n+                listener.onNewAccessToken(accessToken);\n+            }\n+        };\n+\n+        OAuthClientService clientService = getOAuthClientService(serviceHandle);\n+        clientService.addAccessTokenRefreshListener(refreshListener);\n+        listenerByServiceHandle.put(serviceHandle, refreshListener);\n+    }\n+\n+    @Override\n+    public void unsetRefreshListener(String serviceHandle) {\n+        final AccessTokenRefreshListener refreshListener = listenerByServiceHandle.get(serviceHandle);\n+        if (refreshListener != null) {\n+            try {\n+                OAuthClientService clientService = getOAuthClientService(serviceHandle);\n+                clientService.removeAccessTokenRefreshListener(refreshListener);\n+            } catch (OAuthException e) {\n+                logger.warn(\"Failed to remove refresh listener: OAuth client service is unavailable.\");\n+                logger.debug(\"Exception details:\", e);", "originalCommit": "6582025c1528e8b30c0ace82e86da942293af0d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc0NjUyOA==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r540746528", "bodyText": "I replaced this pattern in all locations it occurred. Please check again.", "author": "BjoernLange", "createdAt": "2020-12-11T07:37:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NjkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3NjE2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r534376161", "bodyText": "What's the purpose of this sleep? If you want to ensure that there's some delay, you should choose a value of at least 100ms, otherwise the JVM may skip the sleep entirely.", "author": "fwolter", "createdAt": "2020-12-02T18:08:03Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/config/servlet/CreateBridgeServlet.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.config.servlet;\n+\n+import java.util.Collections;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.inbox.Inbox;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingRegistry;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthException;\n+import org.openhab.binding.mielecloud.internal.config.OAuthAuthorizationHandler;\n+import org.openhab.binding.mielecloud.internal.config.exception.BridgeCreationFailedException;\n+import org.openhab.binding.mielecloud.internal.config.exception.BridgeReconfigurationFailedException;\n+import org.openhab.binding.mielecloud.internal.util.LocaleValidator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Servlet that automatically creates a bridge and then redirects the browser to the account overview page.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial Contribution\n+ */\n+@NonNullByDefault\n+public final class CreateBridgeServlet extends AbstractRedirectionServlet {\n+    private static final String MIELE_CLOUD_BRIDGE_NAME = \"Cloud Connector\";\n+    private static final String MIELE_CLOUD_BRIDGE_LABEL = \"Miele@home Account\";\n+\n+    private static final String LOCALE_PARAMETER_NAME = \"locale\";\n+    public static final String BRIDGE_UID_PARAMETER_NAME = \"bridgeUid\";\n+\n+    private static final long serialVersionUID = -2912042079128722887L;\n+\n+    private static final String DEFAULT_LOCALE = \"en\";\n+\n+    private static final long ONLINE_WAIT_TIMEOUT_IN_MILLISECONDS = 5000;\n+    private static final long ONLINE_CHECK_INTERVAL_IN_MILLISECONDS = 100;\n+\n+    private final Logger logger = LoggerFactory.getLogger(CreateBridgeServlet.class);\n+\n+    private final Inbox inbox;\n+    private final ThingRegistry thingRegistry;\n+    private final OAuthAuthorizationHandler authorizationHandler;\n+\n+    /**\n+     * Creates a new {@link CreateBridgeServlet}.\n+     *\n+     * @param inbox openHAB inbox for discovery results.\n+     * @param thingRegistry openHAB thing registry.\n+     * @param authorizationHandler Handler for the authorization process.\n+     */\n+    public CreateBridgeServlet(Inbox inbox, ThingRegistry thingRegistry,\n+            OAuthAuthorizationHandler authorizationHandler) {\n+        this.inbox = inbox;\n+        this.thingRegistry = thingRegistry;\n+        this.authorizationHandler = authorizationHandler;\n+    }\n+\n+    @Override\n+    protected String getRedirectionDestination(HttpServletRequest request) {\n+        String bridgeUidString = request.getParameter(BRIDGE_UID_PARAMETER_NAME);\n+        if (bridgeUidString == null || bridgeUidString.isEmpty()) {\n+            logger.warn(\"Cannot create bridge: Bridge UID is missing.\");\n+            return \"/mielecloud/failure?\" + FailureServlet.MISSING_BRIDGE_UID_PARAMETER_NAME + \"=true\";\n+        }\n+\n+        ThingUID bridgeUid = null;\n+        try {\n+            bridgeUid = new ThingUID(bridgeUidString);\n+        } catch (IllegalArgumentException e) {\n+            logger.warn(\"Cannot create bridge: Bridge UID '{}' is malformed.\", bridgeUid);\n+            return \"/mielecloud/failure?\" + FailureServlet.MALFORMED_BRIDGE_UID_PARAMETER_NAME + \"=true\";\n+        }\n+\n+        String locale = getValidLocale(request.getParameter(LOCALE_PARAMETER_NAME));\n+\n+        String accessToken = null;\n+        try {\n+            accessToken = authorizationHandler.getAccessToken(bridgeUid);\n+        } catch (OAuthException e) {\n+            logger.warn(\"Failed to obtain access token\");\n+            logger.debug(\"Exception details:\", e);\n+            return \"/mielecloud/success?\" + SuccessServlet.MISSING_ACCESS_TOKEN_PARAMETER_NAME + \"=true&\"\n+                    + SuccessServlet.BRIDGE_UID_PARAMETER_NAME + \"=\" + bridgeUidString;\n+        }\n+\n+        logger.info(\"Auto configuring Miele account using locale '{}' (requested locale was '{}')\", locale,\n+                request.getParameter(LOCALE_PARAMETER_NAME));\n+        try {\n+            Thing bridge = pairOrReconfigureBridge(accessToken, locale, bridgeUid);\n+            waitForBridgeToComeOnline(bridge);\n+            return \"/mielecloud\";\n+        } catch (BridgeReconfigurationFailedException e) {\n+            logger.warn(\"{}\", e.getMessage());\n+            return \"/mielecloud/success?\" + SuccessServlet.BRIDGE_RECONFIGURATION_FAILED_PARAMETER_NAME + \"=true&\"\n+                    + SuccessServlet.BRIDGE_UID_PARAMETER_NAME + \"=\" + bridgeUidString;\n+        } catch (BridgeCreationFailedException e) {\n+            logger.warn(\"Thing creation failed because there was no binding available that supports the thing.\");\n+            return \"/mielecloud/success?\" + SuccessServlet.BRIDGE_CREATION_FAILED_PARAMETER_NAME + \"=true&\"\n+                    + SuccessServlet.BRIDGE_UID_PARAMETER_NAME + \"=\" + bridgeUidString;\n+        }\n+    }\n+\n+    private Thing pairOrReconfigureBridge(String accessToken, String locale, ThingUID bridgeUid) {\n+        DiscoveryResult result = DiscoveryResultBuilder.create(bridgeUid)\n+                .withRepresentationProperty(Thing.PROPERTY_MODEL_ID).withLabel(MIELE_CLOUD_BRIDGE_LABEL)\n+                .withProperty(Thing.PROPERTY_MODEL_ID, MIELE_CLOUD_BRIDGE_NAME).withProperty(\"accessToken\", accessToken)\n+                .withProperty(LOCALE_PARAMETER_NAME, locale).build();\n+        if (inbox.add(result)) {\n+            return pairBridge(bridgeUid);\n+        } else {\n+            return reconfigureBridge(bridgeUid, locale);\n+        }\n+    }\n+\n+    private Thing pairBridge(ThingUID thingUid) {\n+        Thing thing = inbox.approve(thingUid, MIELE_CLOUD_BRIDGE_LABEL, null);\n+        if (thing == null) {\n+            throw new BridgeCreationFailedException();\n+        }\n+\n+        logger.info(\"Successfully created bridge {}\", thingUid);\n+        return thing;\n+    }\n+\n+    private Thing reconfigureBridge(ThingUID thingUid, String locale) {\n+        logger.info(\"Thing already exists. Modifying configuration.\");\n+        Thing thing = thingRegistry.get(thingUid);\n+        if (thing == null) {\n+            throw new BridgeReconfigurationFailedException(\n+                    \"Cannot modify non existing bridge: Could neither add bridge via inbox nor find existing bridge.\");\n+        }\n+\n+        ThingHandler handler = thing.getHandler();\n+        if (handler == null) {\n+            throw new BridgeReconfigurationFailedException(\"Bridge exists but has no handler.\");\n+        }\n+\n+        handler.handleConfigurationUpdate(\n+                Collections.singletonMap(MieleCloudBindingConstants.CONFIG_PARAM_LOCALE, locale));\n+\n+        // As the parameters will not necessarily change we need to force the thing to re-initialize.\n+        handler.dispose();\n+        handler.initialize();\n+\n+        return thing;\n+    }\n+\n+    private String getValidLocale(@Nullable String localeParameterValue) {\n+        if (localeParameterValue == null || localeParameterValue.isEmpty()\n+                || !LocaleValidator.isValidLanguage(localeParameterValue)) {\n+            return DEFAULT_LOCALE;\n+        } else {\n+            return localeParameterValue;\n+        }\n+    }\n+\n+    private void waitForBridgeToComeOnline(Thing bridge) {\n+        long remainingWaitTime = ONLINE_WAIT_TIMEOUT_IN_MILLISECONDS;\n+        while (bridge.getStatus() != ThingStatus.ONLINE && remainingWaitTime > 0) {\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(ONLINE_CHECK_INTERVAL_IN_MILLISECONDS);\n+                remainingWaitTime -= ONLINE_CHECK_INTERVAL_IN_MILLISECONDS;\n+            } catch (InterruptedException e) {\n+                return;\n+            }\n+        }\n+\n+        try {\n+            TimeUnit.SECONDS.sleep(1);\n+        } catch (InterruptedException e) {\n+        }", "originalCommit": "6582025c1528e8b30c0ace82e86da942293af0d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjExMjcwMw==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r536112703", "bodyText": "The delay is 1s which is larger than 100ms \ud83d\ude09\nYou are right, the purpose is not that obvious here: After our bridge changed to ONLINE (see the sleep above) it might take a moment for our discovery service to initialize and discover all devices. We wait for this because the overview page which the user is redirected to shows a template for a .things file which is populated with the discovery results. If these are missing then the template is incomplete. We want to avoid confusing the user here. Obviously that is a hacky workaround and we should rather wait until a maximum delay expired or the number of discovered things in the inbox doesn't change any more. Or is there a more common / easier solution?", "author": "BjoernLange", "createdAt": "2020-12-04T13:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3NjE2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA5MTk0MA==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r537091940", "bodyText": "It seems it was a bit too late that day...\nIt'd be good if you solve this in a more elegant way. Unfortunately I can't come up with a solution.", "author": "fwolter", "createdAt": "2020-12-06T18:02:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3NjE2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc1ODQ1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r540758453", "bodyText": "We now wait until the number of discovery results from this binding doesn't change any more.", "author": "BjoernLange", "createdAt": "2020-12-11T08:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3NjE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3OTQ5OA==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r534379498", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Set<String> SUPPORTED_LANGUAGES = Collections\n          \n          \n            \n                        .unmodifiableSet(new HashSet<>(Arrays.asList(\"da\", \"nl\", \"en\", \"fr\", \"de\", \"it\", \"nb\", \"es\")));\n          \n          \n            \n                private static final Set<String> SUPPORTED_LANGUAGES = Set.of(\"da\", \"nl\", \"en\", \"fr\", \"de\", \"it\", \"nb\", \"es\");", "author": "fwolter", "createdAt": "2020-12-02T18:13:33Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/config/servlet/SuccessServlet.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.config.servlet;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.binding.mielecloud.internal.config.ThingsTemplateGenerator;\n+import org.openhab.binding.mielecloud.internal.webservice.language.LanguageProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Servlet showing the success page.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class SuccessServlet extends AbstractShowPageServlet {\n+    private static final long serialVersionUID = 7013060161686096950L;\n+\n+    public static final String BRIDGE_UID_PARAMETER_NAME = \"bridgeUid\";\n+\n+    public static final String MISSING_ACCESS_TOKEN_PARAMETER_NAME = \"missingAccessToken\";\n+    public static final String BRIDGE_CREATION_FAILED_PARAMETER_NAME = \"bridgeCreationFailed\";\n+    public static final String BRIDGE_RECONFIGURATION_FAILED_PARAMETER_NAME = \"bridgeReconfigurationFailed\";\n+\n+    private static final String ERROR_MESSAGE_TEXT_PLACEHOLDER = \"<!-- ERROR MESSAGE TEXT -->\";\n+    private static final String BRIDGE_UID_PLACEHOLDER = \"<!-- BRIDGE UID -->\";\n+    private static final String THINGS_TEMPLATE_CODE_PLACEHOLDER = \"<!-- THINGS TEMPLATE CODE -->\";\n+\n+    private static final String LOCALE_OPTIONS_PLACEHOLDER = \"<!-- LOCALE OPTIONS -->\";\n+\n+    private static final String DEFAULT_LANGUAGE = \"en\";\n+    private static final Set<String> SUPPORTED_LANGUAGES = Collections\n+            .unmodifiableSet(new HashSet<>(Arrays.asList(\"da\", \"nl\", \"en\", \"fr\", \"de\", \"it\", \"nb\", \"es\")));", "originalCommit": "6582025c1528e8b30c0ace82e86da942293af0d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM4NDA0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r534384045", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                triggerPowerState(OnOffType.ON.equals(OnOffType.from(command.toString())));\n          \n          \n            \n                                triggerPowerState(OnOffType.ON == command);", "author": "fwolter", "createdAt": "2020-12-02T18:20:24Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/handler/AbstractMieleThingHandler.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.handler;\n+\n+import static org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants.Channels.*;\n+import static org.openhab.binding.mielecloud.internal.webservice.api.PowerStatus.*;\n+import static org.openhab.binding.mielecloud.internal.webservice.api.ProgramStatus.*;\n+import static org.openhab.binding.mielecloud.internal.webservice.api.json.ProcessAction.*;\n+\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants.I18NKeys;\n+import org.openhab.binding.mielecloud.internal.handler.channel.ActionsChannelState;\n+import org.openhab.binding.mielecloud.internal.handler.channel.DeviceChannelState;\n+import org.openhab.binding.mielecloud.internal.handler.channel.TransitionChannelState;\n+import org.openhab.binding.mielecloud.internal.webservice.ActionStateFetcher;\n+import org.openhab.binding.mielecloud.internal.webservice.MieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.UnavailableMieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.api.ActionsState;\n+import org.openhab.binding.mielecloud.internal.webservice.api.DeviceState;\n+import org.openhab.binding.mielecloud.internal.webservice.api.PowerStatus;\n+import org.openhab.binding.mielecloud.internal.webservice.api.ProgramStatus;\n+import org.openhab.binding.mielecloud.internal.webservice.api.TransitionState;\n+import org.openhab.binding.mielecloud.internal.webservice.api.json.ProcessAction;\n+import org.openhab.binding.mielecloud.internal.webservice.api.json.StateType;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.TooManyRequestsException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for all Miele thing handlers.\n+ *\n+ * @author Roland Edelhoff - Initial contribution\n+ * @author Bj\u00f6rn Lange - Add channel state wrappers\n+ */\n+@NonNullByDefault\n+public abstract class AbstractMieleThingHandler extends BaseThingHandler {\n+    protected final ActionStateFetcher actionFetcher;\n+    protected DeviceState latestDeviceState = new DeviceState(getDeviceId(), null);\n+    protected TransitionState latestTransitionState = new TransitionState(null, latestDeviceState);\n+    protected ActionsState latestActionsState = new ActionsState(getDeviceId(), null);\n+\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+\n+    /**\n+     * Creates a new {@link AbstractMieleThingHandler}.\n+     * \n+     * @param thing The thing to handle.\n+     */\n+    public AbstractMieleThingHandler(Thing thing) {\n+        super(thing);\n+        this.actionFetcher = new ActionStateFetcher(this::getWebservice, scheduler);\n+    }\n+\n+    private Optional<MieleBridgeHandler> getMieleBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            return Optional.empty();\n+        }\n+\n+        BridgeHandler handler = bridge.getHandler();\n+        if (handler == null || !(handler instanceof MieleBridgeHandler)) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of((MieleBridgeHandler) handler);\n+    }\n+\n+    protected MieleWebservice getWebservice() {\n+        return getMieleBridgeHandler().map(MieleBridgeHandler::getWebservice)\n+                .orElse(UnavailableMieleWebservice.INSTANCE);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        getWebservice().dispatchDeviceState(getDeviceId());\n+\n+        // If no device state update was received so far, set the device to OFFLINE.\n+        if (getThing().getStatus() == ThingStatus.INITIALIZING) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH.equals(command)) {\n+            updateDeviceState(new DeviceChannelState(latestDeviceState));\n+            updateTransitionState(new TransitionChannelState(latestTransitionState));\n+            updateActionState(new ActionsChannelState(latestActionsState));\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case PROGRAM_START_STOP:\n+                if (PROGRAM_STARTED.matches(command.toString())) {\n+                    triggerProcessAction(START);\n+                } else if (PROGRAM_STOPPED.matches(command.toString())) {\n+                    triggerProcessAction(STOP);\n+                }\n+                break;\n+\n+            case PROGRAM_START_STOP_PAUSE:\n+                if (PROGRAM_STARTED.matches(command.toString())) {\n+                    triggerProcessAction(START);\n+                } else if (PROGRAM_STOPPED.matches(command.toString())) {\n+                    triggerProcessAction(STOP);\n+                } else if (PROGRAM_PAUSED.matches(command.toString())) {\n+                    triggerProcessAction(PAUSE);\n+                }\n+                break;\n+\n+            case LIGHT_SWITCH:\n+                if (command instanceof OnOffType) {\n+                    triggerLight(OnOffType.ON.equals(command));\n+                }\n+                break;\n+\n+            case POWER_ON_OFF:\n+                if (POWER_ON.matches(command.toString()) || POWER_OFF.matches(command.toString())) {\n+                    triggerPowerState(OnOffType.ON.equals(OnOffType.from(command.toString())));", "originalCommit": "6582025c1528e8b30c0ace82e86da942293af0d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgwNjQxMA==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r540806410", "bodyText": "This replacement doesn't work. command is of type StringType (because the POWER_ON_OFF channel is a string channel with options \"on\" and \"off\"). Thus, we need to convert it here.\nA note on why this is a String channel: Initially the binding was planned to have an additional channel POWER_ON_OFF_STANDBY that was not implemented for the contribution but may be added in the future. For consistency purposes we decided to make POWER_ON_OFF a String channel, too. Would you prefer to convert it to a Switch channel for now?", "author": "BjoernLange", "createdAt": "2020-12-11T09:25:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM4NDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk1OTQwNw==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r541959407", "bodyText": "I overlooked that it's of StringType. I'd keep it as StringType, otherwise you would break compatibility when changing it from Switch to StringType later.", "author": "fwolter", "createdAt": "2020-12-13T16:37:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM4NDA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM4NDgwMA==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r534384800", "bodyText": "The log message could be removed, as the status update is already logged by the framework.\nThe state change originated by updateStatus() is logged to events.log. Including the status detail message.", "author": "fwolter", "createdAt": "2020-12-02T18:21:32Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/handler/AbstractMieleThingHandler.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.handler;\n+\n+import static org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants.Channels.*;\n+import static org.openhab.binding.mielecloud.internal.webservice.api.PowerStatus.*;\n+import static org.openhab.binding.mielecloud.internal.webservice.api.ProgramStatus.*;\n+import static org.openhab.binding.mielecloud.internal.webservice.api.json.ProcessAction.*;\n+\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants.I18NKeys;\n+import org.openhab.binding.mielecloud.internal.handler.channel.ActionsChannelState;\n+import org.openhab.binding.mielecloud.internal.handler.channel.DeviceChannelState;\n+import org.openhab.binding.mielecloud.internal.handler.channel.TransitionChannelState;\n+import org.openhab.binding.mielecloud.internal.webservice.ActionStateFetcher;\n+import org.openhab.binding.mielecloud.internal.webservice.MieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.UnavailableMieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.api.ActionsState;\n+import org.openhab.binding.mielecloud.internal.webservice.api.DeviceState;\n+import org.openhab.binding.mielecloud.internal.webservice.api.PowerStatus;\n+import org.openhab.binding.mielecloud.internal.webservice.api.ProgramStatus;\n+import org.openhab.binding.mielecloud.internal.webservice.api.TransitionState;\n+import org.openhab.binding.mielecloud.internal.webservice.api.json.ProcessAction;\n+import org.openhab.binding.mielecloud.internal.webservice.api.json.StateType;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.TooManyRequestsException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for all Miele thing handlers.\n+ *\n+ * @author Roland Edelhoff - Initial contribution\n+ * @author Bj\u00f6rn Lange - Add channel state wrappers\n+ */\n+@NonNullByDefault\n+public abstract class AbstractMieleThingHandler extends BaseThingHandler {\n+    protected final ActionStateFetcher actionFetcher;\n+    protected DeviceState latestDeviceState = new DeviceState(getDeviceId(), null);\n+    protected TransitionState latestTransitionState = new TransitionState(null, latestDeviceState);\n+    protected ActionsState latestActionsState = new ActionsState(getDeviceId(), null);\n+\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+\n+    /**\n+     * Creates a new {@link AbstractMieleThingHandler}.\n+     * \n+     * @param thing The thing to handle.\n+     */\n+    public AbstractMieleThingHandler(Thing thing) {\n+        super(thing);\n+        this.actionFetcher = new ActionStateFetcher(this::getWebservice, scheduler);\n+    }\n+\n+    private Optional<MieleBridgeHandler> getMieleBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            return Optional.empty();\n+        }\n+\n+        BridgeHandler handler = bridge.getHandler();\n+        if (handler == null || !(handler instanceof MieleBridgeHandler)) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of((MieleBridgeHandler) handler);\n+    }\n+\n+    protected MieleWebservice getWebservice() {\n+        return getMieleBridgeHandler().map(MieleBridgeHandler::getWebservice)\n+                .orElse(UnavailableMieleWebservice.INSTANCE);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        getWebservice().dispatchDeviceState(getDeviceId());\n+\n+        // If no device state update was received so far, set the device to OFFLINE.\n+        if (getThing().getStatus() == ThingStatus.INITIALIZING) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH.equals(command)) {\n+            updateDeviceState(new DeviceChannelState(latestDeviceState));\n+            updateTransitionState(new TransitionChannelState(latestTransitionState));\n+            updateActionState(new ActionsChannelState(latestActionsState));\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case PROGRAM_START_STOP:\n+                if (PROGRAM_STARTED.matches(command.toString())) {\n+                    triggerProcessAction(START);\n+                } else if (PROGRAM_STOPPED.matches(command.toString())) {\n+                    triggerProcessAction(STOP);\n+                }\n+                break;\n+\n+            case PROGRAM_START_STOP_PAUSE:\n+                if (PROGRAM_STARTED.matches(command.toString())) {\n+                    triggerProcessAction(START);\n+                } else if (PROGRAM_STOPPED.matches(command.toString())) {\n+                    triggerProcessAction(STOP);\n+                } else if (PROGRAM_PAUSED.matches(command.toString())) {\n+                    triggerProcessAction(PAUSE);\n+                }\n+                break;\n+\n+            case LIGHT_SWITCH:\n+                if (command instanceof OnOffType) {\n+                    triggerLight(OnOffType.ON.equals(command));\n+                }\n+                break;\n+\n+            case POWER_ON_OFF:\n+                if (POWER_ON.matches(command.toString()) || POWER_OFF.matches(command.toString())) {\n+                    triggerPowerState(OnOffType.ON.equals(OnOffType.from(command.toString())));\n+                }\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+    }\n+\n+    /**\n+     * Invoked when an update of the available actions for the device managed by this handler is received from the Miele\n+     * cloud.\n+     */\n+    public final void onProcessActionUpdated(ActionsState actionState) {\n+        latestActionsState = actionState;\n+        updateActionState(new ActionsChannelState(latestActionsState));\n+    }\n+\n+    /**\n+     * Invoked when the device managed by this handler was removed from the Miele cloud.\n+     */\n+    public final void onDeviceRemoved() {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.GONE, I18NKeys.THING_STATUS_DESCRIPTION_REMOVED);\n+    }\n+\n+    /**\n+     * Invoked when a device state update for the device managed by this handler is received from the Miele cloud.\n+     */\n+    public final void onDeviceStateUpdated(DeviceState deviceState) {\n+        actionFetcher.onDeviceStateUpdated(deviceState);\n+\n+        latestTransitionState = new TransitionState(latestTransitionState, deviceState);\n+        latestDeviceState = deviceState;\n+\n+        updateDeviceState(new DeviceChannelState(latestDeviceState));\n+        updateTransitionState(new TransitionChannelState(latestTransitionState));\n+        updateThingStatus(latestDeviceState);\n+    }\n+\n+    protected void triggerProcessAction(final ProcessAction processAction) {\n+        performPutAction(() -> getWebservice().putProcessAction(getDeviceId(), processAction), t -> {\n+            logger.warn(\"Failed to perform '{}' operation for device '{}'.\", processAction, getDeviceId());\n+            logger.debug(\"Exception details:\", t);\n+        });\n+    }\n+\n+    protected void triggerLight(final boolean on) {\n+        performPutAction(() -> getWebservice().putLight(getDeviceId(), on), t -> {\n+            logger.warn(\"Failed to set light state to '{}' for device '{}'.\", on, getDeviceId());\n+            logger.debug(\"Exception details:\", t);\n+        });\n+    }\n+\n+    protected void triggerPowerState(final boolean on) {\n+        performPutAction(() -> getWebservice().putPowerState(getDeviceId(), on), t -> {\n+            logger.warn(\"Failed to set the power state to '{}' for device '{}'.\", on, getDeviceId());\n+            logger.debug(\"Exception details:\", t);\n+        });\n+    }\n+\n+    protected void triggerProgram(final long programId) {\n+        performPutAction(() -> getWebservice().putProgram(getDeviceId(), programId), t -> {\n+            logger.warn(\"Failed to activate program with ID '{}' for device '{}'.\", programId, getDeviceId());\n+            logger.debug(\"Exception details:\", t);\n+        });\n+    }\n+\n+    private void performPutAction(Runnable action, Consumer<Exception> onError) {\n+        scheduler.schedule(() -> {\n+            try {\n+                action.run();\n+            } catch (TooManyRequestsException e) {\n+                logger.warn(\"Rate limit is reached.\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        I18NKeys.THING_STATUS_DESCRIPTION_RATELIMIT);", "originalCommit": "6582025c1528e8b30c0ace82e86da942293af0d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM4NTIxMA==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r534385210", "bodyText": "You could use execute() or submit() for scheduling an immediate one-shot task.", "author": "fwolter", "createdAt": "2020-12-02T18:22:13Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/handler/AbstractMieleThingHandler.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.handler;\n+\n+import static org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants.Channels.*;\n+import static org.openhab.binding.mielecloud.internal.webservice.api.PowerStatus.*;\n+import static org.openhab.binding.mielecloud.internal.webservice.api.ProgramStatus.*;\n+import static org.openhab.binding.mielecloud.internal.webservice.api.json.ProcessAction.*;\n+\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants.I18NKeys;\n+import org.openhab.binding.mielecloud.internal.handler.channel.ActionsChannelState;\n+import org.openhab.binding.mielecloud.internal.handler.channel.DeviceChannelState;\n+import org.openhab.binding.mielecloud.internal.handler.channel.TransitionChannelState;\n+import org.openhab.binding.mielecloud.internal.webservice.ActionStateFetcher;\n+import org.openhab.binding.mielecloud.internal.webservice.MieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.UnavailableMieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.api.ActionsState;\n+import org.openhab.binding.mielecloud.internal.webservice.api.DeviceState;\n+import org.openhab.binding.mielecloud.internal.webservice.api.PowerStatus;\n+import org.openhab.binding.mielecloud.internal.webservice.api.ProgramStatus;\n+import org.openhab.binding.mielecloud.internal.webservice.api.TransitionState;\n+import org.openhab.binding.mielecloud.internal.webservice.api.json.ProcessAction;\n+import org.openhab.binding.mielecloud.internal.webservice.api.json.StateType;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.TooManyRequestsException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for all Miele thing handlers.\n+ *\n+ * @author Roland Edelhoff - Initial contribution\n+ * @author Bj\u00f6rn Lange - Add channel state wrappers\n+ */\n+@NonNullByDefault\n+public abstract class AbstractMieleThingHandler extends BaseThingHandler {\n+    protected final ActionStateFetcher actionFetcher;\n+    protected DeviceState latestDeviceState = new DeviceState(getDeviceId(), null);\n+    protected TransitionState latestTransitionState = new TransitionState(null, latestDeviceState);\n+    protected ActionsState latestActionsState = new ActionsState(getDeviceId(), null);\n+\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+\n+    /**\n+     * Creates a new {@link AbstractMieleThingHandler}.\n+     * \n+     * @param thing The thing to handle.\n+     */\n+    public AbstractMieleThingHandler(Thing thing) {\n+        super(thing);\n+        this.actionFetcher = new ActionStateFetcher(this::getWebservice, scheduler);\n+    }\n+\n+    private Optional<MieleBridgeHandler> getMieleBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            return Optional.empty();\n+        }\n+\n+        BridgeHandler handler = bridge.getHandler();\n+        if (handler == null || !(handler instanceof MieleBridgeHandler)) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of((MieleBridgeHandler) handler);\n+    }\n+\n+    protected MieleWebservice getWebservice() {\n+        return getMieleBridgeHandler().map(MieleBridgeHandler::getWebservice)\n+                .orElse(UnavailableMieleWebservice.INSTANCE);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        getWebservice().dispatchDeviceState(getDeviceId());\n+\n+        // If no device state update was received so far, set the device to OFFLINE.\n+        if (getThing().getStatus() == ThingStatus.INITIALIZING) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH.equals(command)) {\n+            updateDeviceState(new DeviceChannelState(latestDeviceState));\n+            updateTransitionState(new TransitionChannelState(latestTransitionState));\n+            updateActionState(new ActionsChannelState(latestActionsState));\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case PROGRAM_START_STOP:\n+                if (PROGRAM_STARTED.matches(command.toString())) {\n+                    triggerProcessAction(START);\n+                } else if (PROGRAM_STOPPED.matches(command.toString())) {\n+                    triggerProcessAction(STOP);\n+                }\n+                break;\n+\n+            case PROGRAM_START_STOP_PAUSE:\n+                if (PROGRAM_STARTED.matches(command.toString())) {\n+                    triggerProcessAction(START);\n+                } else if (PROGRAM_STOPPED.matches(command.toString())) {\n+                    triggerProcessAction(STOP);\n+                } else if (PROGRAM_PAUSED.matches(command.toString())) {\n+                    triggerProcessAction(PAUSE);\n+                }\n+                break;\n+\n+            case LIGHT_SWITCH:\n+                if (command instanceof OnOffType) {\n+                    triggerLight(OnOffType.ON.equals(command));\n+                }\n+                break;\n+\n+            case POWER_ON_OFF:\n+                if (POWER_ON.matches(command.toString()) || POWER_OFF.matches(command.toString())) {\n+                    triggerPowerState(OnOffType.ON.equals(OnOffType.from(command.toString())));\n+                }\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+    }\n+\n+    /**\n+     * Invoked when an update of the available actions for the device managed by this handler is received from the Miele\n+     * cloud.\n+     */\n+    public final void onProcessActionUpdated(ActionsState actionState) {\n+        latestActionsState = actionState;\n+        updateActionState(new ActionsChannelState(latestActionsState));\n+    }\n+\n+    /**\n+     * Invoked when the device managed by this handler was removed from the Miele cloud.\n+     */\n+    public final void onDeviceRemoved() {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.GONE, I18NKeys.THING_STATUS_DESCRIPTION_REMOVED);\n+    }\n+\n+    /**\n+     * Invoked when a device state update for the device managed by this handler is received from the Miele cloud.\n+     */\n+    public final void onDeviceStateUpdated(DeviceState deviceState) {\n+        actionFetcher.onDeviceStateUpdated(deviceState);\n+\n+        latestTransitionState = new TransitionState(latestTransitionState, deviceState);\n+        latestDeviceState = deviceState;\n+\n+        updateDeviceState(new DeviceChannelState(latestDeviceState));\n+        updateTransitionState(new TransitionChannelState(latestTransitionState));\n+        updateThingStatus(latestDeviceState);\n+    }\n+\n+    protected void triggerProcessAction(final ProcessAction processAction) {\n+        performPutAction(() -> getWebservice().putProcessAction(getDeviceId(), processAction), t -> {\n+            logger.warn(\"Failed to perform '{}' operation for device '{}'.\", processAction, getDeviceId());\n+            logger.debug(\"Exception details:\", t);\n+        });\n+    }\n+\n+    protected void triggerLight(final boolean on) {\n+        performPutAction(() -> getWebservice().putLight(getDeviceId(), on), t -> {\n+            logger.warn(\"Failed to set light state to '{}' for device '{}'.\", on, getDeviceId());\n+            logger.debug(\"Exception details:\", t);\n+        });\n+    }\n+\n+    protected void triggerPowerState(final boolean on) {\n+        performPutAction(() -> getWebservice().putPowerState(getDeviceId(), on), t -> {\n+            logger.warn(\"Failed to set the power state to '{}' for device '{}'.\", on, getDeviceId());\n+            logger.debug(\"Exception details:\", t);\n+        });\n+    }\n+\n+    protected void triggerProgram(final long programId) {\n+        performPutAction(() -> getWebservice().putProgram(getDeviceId(), programId), t -> {\n+            logger.warn(\"Failed to activate program with ID '{}' for device '{}'.\", programId, getDeviceId());\n+            logger.debug(\"Exception details:\", t);\n+        });\n+    }\n+\n+    private void performPutAction(Runnable action, Consumer<Exception> onError) {\n+        scheduler.schedule(() -> {\n+            try {\n+                action.run();\n+            } catch (TooManyRequestsException e) {\n+                logger.warn(\"Rate limit is reached.\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        I18NKeys.THING_STATUS_DESCRIPTION_RATELIMIT);\n+                onError.accept(e);\n+            } catch (Exception e) {\n+                onError.accept(e);\n+            }\n+        }, 1, TimeUnit.NANOSECONDS);", "originalCommit": "6582025c1528e8b30c0ace82e86da942293af0d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM4Nzc0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r534387746", "bodyText": "You could add the exception's message as the ThingStatusDetailMessage. Then, the logging can be removed, too. Same for below.", "author": "fwolter", "createdAt": "2020-12-02T18:26:19Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/handler/MieleBridgeHandler.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.handler;\n+\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants;\n+import org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants.I18NKeys;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthException;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthTokenRefreshListener;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthTokenRefresher;\n+import org.openhab.binding.mielecloud.internal.discovery.ThingDiscoveryService;\n+import org.openhab.binding.mielecloud.internal.util.LocaleValidator;\n+import org.openhab.binding.mielecloud.internal.util.OptionalUtils;\n+import org.openhab.binding.mielecloud.internal.webservice.ConnectionError;\n+import org.openhab.binding.mielecloud.internal.webservice.ConnectionStatusListener;\n+import org.openhab.binding.mielecloud.internal.webservice.DeviceStateListener;\n+import org.openhab.binding.mielecloud.internal.webservice.MieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.UnavailableMieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.api.ActionsState;\n+import org.openhab.binding.mielecloud.internal.webservice.api.DeviceState;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceInitializationException;\n+import org.openhab.binding.mielecloud.internal.webservice.language.CombiningLanguageProvider;\n+import org.openhab.binding.mielecloud.internal.webservice.language.LanguageProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * BridgeHandler implementation for the Miele cloud account.\n+ *\n+ * @author Roland Edelhoff - Initial contribution\n+ * @author Bj\u00f6rn Lange - Introduced CombiningLanguageProvider field and interactions, added LanguageProvider super\n+ *         interface, switched from polling to SSE, added support for multiple bridges\n+ */\n+@NonNullByDefault\n+public class MieleBridgeHandler extends BaseBridgeHandler\n+        implements OAuthTokenRefreshListener, LanguageProvider, ConnectionStatusListener, DeviceStateListener {\n+    private static final int NUMBER_OF_SSE_RECONNECTION_ATTEMPTS_BEFORE_STATUS_IS_UPDATED = 6;\n+\n+    private final Supplier<MieleWebservice> webserviceFactory;\n+\n+    private final OAuthTokenRefresher tokenRefresher;\n+    private final CombiningLanguageProvider languageProvider;\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+\n+    @Nullable\n+    private CompletableFuture<@Nullable Void> logoutFuture;\n+    @Nullable\n+    private MieleWebservice webService;\n+    @Nullable\n+    private ThingDiscoveryService discoveryService;\n+\n+    /**\n+     * Creates a new {@link MieleBridgeHandler}.\n+     *\n+     * @param bridge The bridge to handle.\n+     * @param webserviceFactory Factory for creating {@link MieleWebservice} instances.\n+     * @param tokenRefresher Token refresher.\n+     * @param languageProvider Language provider.\n+     */\n+    public MieleBridgeHandler(Bridge bridge, Function<ScheduledExecutorService, MieleWebservice> webserviceFactory,\n+            OAuthTokenRefresher tokenRefresher, CombiningLanguageProvider languageProvider) {\n+        super(bridge);\n+        this.webserviceFactory = () -> webserviceFactory.apply(scheduler);\n+        this.tokenRefresher = tokenRefresher;\n+        this.languageProvider = languageProvider;\n+    }\n+\n+    public void setDiscoveryService(@Nullable ThingDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    /**\n+     * Gets the current webservice instance for communication with the Miele service.\n+     *\n+     * This function may return an {@link UnavailableMieleWebservice} in case no webservice is available at the moment.\n+     */\n+    public MieleWebservice getWebservice() {\n+        MieleWebservice webservice = webService;\n+        if (webservice != null) {\n+            return webservice;\n+        } else {\n+            return UnavailableMieleWebservice.INSTANCE;\n+        }\n+    }\n+\n+    private String getOAuthServiceHandle() {\n+        return getThing().getUID().getAsString();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // It is required to set a status in this method as stated in the Javadoc of ThingHandler.initialize\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        try {\n+            webService = webserviceFactory.get();\n+        } catch (MieleWebserviceInitializationException e) {\n+            logger.warn(\"Failed to initialize webservice: {}\", e.getMessage());\n+            logger.debug(\"Exception details:\", e);\n+            updateStatus(ThingStatus.OFFLINE);", "originalCommit": "6582025c1528e8b30c0ace82e86da942293af0d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgxNzY3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r540817672", "bodyText": "We would prefer not to do that for several reasons:\n\ni18n of all messages is planned (we could write the localized message to the status, though)\nWhen this exception is thrown then no system resources could be allocated to fire up an HttpClient (cf. RequestFactoryImpl). In that case something seems to be really wrong with the system openHAB is running on and the user/admin should look into the logs anyway.\n\nWhat we could do in my opinion is to define a localizable constant that gives a hint for this, something like \"Could not allocate required system resources, please check your system.\". How about that?", "author": "BjoernLange", "createdAt": "2020-12-11T09:42:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM4Nzc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM5NzM0OA==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r534397348", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-12-02T18:41:19Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/handler/MieleBridgeHandler.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.handler;\n+\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants;\n+import org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants.I18NKeys;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthException;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthTokenRefreshListener;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthTokenRefresher;\n+import org.openhab.binding.mielecloud.internal.discovery.ThingDiscoveryService;\n+import org.openhab.binding.mielecloud.internal.util.LocaleValidator;\n+import org.openhab.binding.mielecloud.internal.util.OptionalUtils;\n+import org.openhab.binding.mielecloud.internal.webservice.ConnectionError;\n+import org.openhab.binding.mielecloud.internal.webservice.ConnectionStatusListener;\n+import org.openhab.binding.mielecloud.internal.webservice.DeviceStateListener;\n+import org.openhab.binding.mielecloud.internal.webservice.MieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.UnavailableMieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.api.ActionsState;\n+import org.openhab.binding.mielecloud.internal.webservice.api.DeviceState;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceInitializationException;\n+import org.openhab.binding.mielecloud.internal.webservice.language.CombiningLanguageProvider;\n+import org.openhab.binding.mielecloud.internal.webservice.language.LanguageProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * BridgeHandler implementation for the Miele cloud account.\n+ *\n+ * @author Roland Edelhoff - Initial contribution\n+ * @author Bj\u00f6rn Lange - Introduced CombiningLanguageProvider field and interactions, added LanguageProvider super\n+ *         interface, switched from polling to SSE, added support for multiple bridges\n+ */\n+@NonNullByDefault\n+public class MieleBridgeHandler extends BaseBridgeHandler\n+        implements OAuthTokenRefreshListener, LanguageProvider, ConnectionStatusListener, DeviceStateListener {\n+    private static final int NUMBER_OF_SSE_RECONNECTION_ATTEMPTS_BEFORE_STATUS_IS_UPDATED = 6;\n+\n+    private final Supplier<MieleWebservice> webserviceFactory;\n+\n+    private final OAuthTokenRefresher tokenRefresher;\n+    private final CombiningLanguageProvider languageProvider;\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+\n+    @Nullable\n+    private CompletableFuture<@Nullable Void> logoutFuture;\n+    @Nullable\n+    private MieleWebservice webService;\n+    @Nullable\n+    private ThingDiscoveryService discoveryService;\n+\n+    /**\n+     * Creates a new {@link MieleBridgeHandler}.\n+     *\n+     * @param bridge The bridge to handle.\n+     * @param webserviceFactory Factory for creating {@link MieleWebservice} instances.\n+     * @param tokenRefresher Token refresher.\n+     * @param languageProvider Language provider.\n+     */\n+    public MieleBridgeHandler(Bridge bridge, Function<ScheduledExecutorService, MieleWebservice> webserviceFactory,\n+            OAuthTokenRefresher tokenRefresher, CombiningLanguageProvider languageProvider) {\n+        super(bridge);\n+        this.webserviceFactory = () -> webserviceFactory.apply(scheduler);\n+        this.tokenRefresher = tokenRefresher;\n+        this.languageProvider = languageProvider;\n+    }\n+\n+    public void setDiscoveryService(@Nullable ThingDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    /**\n+     * Gets the current webservice instance for communication with the Miele service.\n+     *\n+     * This function may return an {@link UnavailableMieleWebservice} in case no webservice is available at the moment.\n+     */\n+    public MieleWebservice getWebservice() {\n+        MieleWebservice webservice = webService;\n+        if (webservice != null) {\n+            return webservice;\n+        } else {\n+            return UnavailableMieleWebservice.INSTANCE;\n+        }\n+    }\n+\n+    private String getOAuthServiceHandle() {\n+        return getThing().getUID().getAsString();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // It is required to set a status in this method as stated in the Javadoc of ThingHandler.initialize\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        try {\n+            webService = webserviceFactory.get();\n+        } catch (MieleWebserviceInitializationException e) {\n+            logger.warn(\"Failed to initialize webservice: {}\", e.getMessage());\n+            logger.debug(\"Exception details:\", e);\n+            updateStatus(ThingStatus.OFFLINE);\n+            return;\n+        }\n+\n+        try {\n+            tokenRefresher.setRefreshListener(this, getOAuthServiceHandle());\n+        } catch (OAuthException e) {\n+            logger.warn(\"Could not initialize Miele Cloud bridge: {}\", e.getMessage());\n+            logger.debug(\"Exception details:\", e);\n+            logger.warn(\"The account has not been authorized. Please consult the documentation on how to do that.\");\n+            logger.warn(\"If using things-files reload your thing configuration afterwards.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    I18NKeys.BRIDGE_STATUS_DESCRIPTION_ACCOUNT_NOT_AUTHORIZED);\n+            // When the authorization takes place handleConfigurationUpdate() will be called which triggers a new\n+            // initialization. Therefore we can leave the bridge in this state.\n+            return;\n+        }\n+        languageProvider.setPrioritizedLanguageProvider(this);\n+        tryInitializeWebservice();\n+\n+        MieleWebservice webservice = getWebservice();\n+        webservice.addConnectionStatusListener(this);\n+        webservice.addDeviceStateListener(this);\n+        if (webservice.hasAccessToken()) {\n+            webservice.connectSse();\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        performLogout();\n+        tokenRefresher.removeTokensFromStorage(getOAuthServiceHandle());\n+        super.handleRemoval();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing {}\", this.getClass().getName());\n+        getWebservice().removeConnectionStatusListener(this);\n+        getWebservice().removeDeviceStateListener(this);\n+        getWebservice().disconnectSse();\n+        languageProvider.unsetPrioritizedLanguageProvider();\n+        tokenRefresher.unsetRefreshListener(getOAuthServiceHandle());\n+\n+        stopWebservice();\n+    }\n+\n+    private void stopWebservice() {\n+        final MieleWebservice webService = this.webService;\n+        this.webService = null;\n+        if (webService == null) {\n+            return;\n+        }\n+\n+        scheduler.submit(() -> {\n+            CompletableFuture<@Nullable Void> logoutFuture = this.logoutFuture;\n+            if (logoutFuture != null) {\n+                try {\n+                    logoutFuture.get();\n+                } catch (InterruptedException e) {\n+                    logger.warn(\"Interrupted while waiting for logout!\");\n+                } catch (ExecutionException e) {\n+                    logger.warn(\"Failed to wait for logout: {}\", e.getMessage());\n+                    logger.debug(\"Exception details:\", e);\n+                }\n+            }\n+\n+            try {\n+                webService.close();\n+            } catch (Exception e) {\n+                logger.warn(\"Failed to close webservice: {}\", e.getMessage());\n+                logger.debug(\"Exception details:\", e);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void onNewAccessToken(String accessToken) {\n+        logger.info(\"Setting new access token for webservice access.\");\n+        updateProperty(MieleCloudBindingConstants.PROPERTY_ACCESS_TOKEN, accessToken);\n+\n+        // Without this the retry would fail causing the thing to go OFFLINE\n+        getWebservice().setAccessToken(accessToken);\n+\n+        // If there was no access token during initialization then the SSE connection was not established.\n+        getWebservice().connectSse();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    private void performLogout() {\n+        logoutFuture = new CompletableFuture<>();\n+        scheduler.schedule(() -> {\n+            try {\n+                getWebservice().logout();\n+            } catch (Exception exception) {\n+                logger.warn(\"Failed to logout from Miele cloud.\");\n+                logger.debug(\"Exception details:\", exception);\n+            }\n+            OptionalUtils.ofNullable(logoutFuture).map(future -> future.complete(null));\n+        }, 1, TimeUnit.NANOSECONDS);", "originalCommit": "6582025c1528e8b30c0ace82e86da942293af0d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM5ODkwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r534398909", "bodyText": "Actually updateStatus() shouldn't be called when the Thing was already disposed. What's the purpose of this?", "author": "fwolter", "createdAt": "2020-12-02T18:43:56Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/handler/MieleBridgeHandler.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.handler;\n+\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants;\n+import org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants.I18NKeys;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthException;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthTokenRefreshListener;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthTokenRefresher;\n+import org.openhab.binding.mielecloud.internal.discovery.ThingDiscoveryService;\n+import org.openhab.binding.mielecloud.internal.util.LocaleValidator;\n+import org.openhab.binding.mielecloud.internal.util.OptionalUtils;\n+import org.openhab.binding.mielecloud.internal.webservice.ConnectionError;\n+import org.openhab.binding.mielecloud.internal.webservice.ConnectionStatusListener;\n+import org.openhab.binding.mielecloud.internal.webservice.DeviceStateListener;\n+import org.openhab.binding.mielecloud.internal.webservice.MieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.UnavailableMieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.api.ActionsState;\n+import org.openhab.binding.mielecloud.internal.webservice.api.DeviceState;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceInitializationException;\n+import org.openhab.binding.mielecloud.internal.webservice.language.CombiningLanguageProvider;\n+import org.openhab.binding.mielecloud.internal.webservice.language.LanguageProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * BridgeHandler implementation for the Miele cloud account.\n+ *\n+ * @author Roland Edelhoff - Initial contribution\n+ * @author Bj\u00f6rn Lange - Introduced CombiningLanguageProvider field and interactions, added LanguageProvider super\n+ *         interface, switched from polling to SSE, added support for multiple bridges\n+ */\n+@NonNullByDefault\n+public class MieleBridgeHandler extends BaseBridgeHandler\n+        implements OAuthTokenRefreshListener, LanguageProvider, ConnectionStatusListener, DeviceStateListener {\n+    private static final int NUMBER_OF_SSE_RECONNECTION_ATTEMPTS_BEFORE_STATUS_IS_UPDATED = 6;\n+\n+    private final Supplier<MieleWebservice> webserviceFactory;\n+\n+    private final OAuthTokenRefresher tokenRefresher;\n+    private final CombiningLanguageProvider languageProvider;\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+\n+    @Nullable\n+    private CompletableFuture<@Nullable Void> logoutFuture;\n+    @Nullable\n+    private MieleWebservice webService;\n+    @Nullable\n+    private ThingDiscoveryService discoveryService;\n+\n+    /**\n+     * Creates a new {@link MieleBridgeHandler}.\n+     *\n+     * @param bridge The bridge to handle.\n+     * @param webserviceFactory Factory for creating {@link MieleWebservice} instances.\n+     * @param tokenRefresher Token refresher.\n+     * @param languageProvider Language provider.\n+     */\n+    public MieleBridgeHandler(Bridge bridge, Function<ScheduledExecutorService, MieleWebservice> webserviceFactory,\n+            OAuthTokenRefresher tokenRefresher, CombiningLanguageProvider languageProvider) {\n+        super(bridge);\n+        this.webserviceFactory = () -> webserviceFactory.apply(scheduler);\n+        this.tokenRefresher = tokenRefresher;\n+        this.languageProvider = languageProvider;\n+    }\n+\n+    public void setDiscoveryService(@Nullable ThingDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    /**\n+     * Gets the current webservice instance for communication with the Miele service.\n+     *\n+     * This function may return an {@link UnavailableMieleWebservice} in case no webservice is available at the moment.\n+     */\n+    public MieleWebservice getWebservice() {\n+        MieleWebservice webservice = webService;\n+        if (webservice != null) {\n+            return webservice;\n+        } else {\n+            return UnavailableMieleWebservice.INSTANCE;\n+        }\n+    }\n+\n+    private String getOAuthServiceHandle() {\n+        return getThing().getUID().getAsString();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // It is required to set a status in this method as stated in the Javadoc of ThingHandler.initialize\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        try {\n+            webService = webserviceFactory.get();\n+        } catch (MieleWebserviceInitializationException e) {\n+            logger.warn(\"Failed to initialize webservice: {}\", e.getMessage());\n+            logger.debug(\"Exception details:\", e);\n+            updateStatus(ThingStatus.OFFLINE);\n+            return;\n+        }\n+\n+        try {\n+            tokenRefresher.setRefreshListener(this, getOAuthServiceHandle());\n+        } catch (OAuthException e) {\n+            logger.warn(\"Could not initialize Miele Cloud bridge: {}\", e.getMessage());\n+            logger.debug(\"Exception details:\", e);\n+            logger.warn(\"The account has not been authorized. Please consult the documentation on how to do that.\");\n+            logger.warn(\"If using things-files reload your thing configuration afterwards.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    I18NKeys.BRIDGE_STATUS_DESCRIPTION_ACCOUNT_NOT_AUTHORIZED);\n+            // When the authorization takes place handleConfigurationUpdate() will be called which triggers a new\n+            // initialization. Therefore we can leave the bridge in this state.\n+            return;\n+        }\n+        languageProvider.setPrioritizedLanguageProvider(this);\n+        tryInitializeWebservice();\n+\n+        MieleWebservice webservice = getWebservice();\n+        webservice.addConnectionStatusListener(this);\n+        webservice.addDeviceStateListener(this);\n+        if (webservice.hasAccessToken()) {\n+            webservice.connectSse();\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        performLogout();\n+        tokenRefresher.removeTokensFromStorage(getOAuthServiceHandle());\n+        super.handleRemoval();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing {}\", this.getClass().getName());\n+        getWebservice().removeConnectionStatusListener(this);\n+        getWebservice().removeDeviceStateListener(this);\n+        getWebservice().disconnectSse();\n+        languageProvider.unsetPrioritizedLanguageProvider();\n+        tokenRefresher.unsetRefreshListener(getOAuthServiceHandle());\n+\n+        stopWebservice();\n+    }\n+\n+    private void stopWebservice() {\n+        final MieleWebservice webService = this.webService;\n+        this.webService = null;\n+        if (webService == null) {\n+            return;\n+        }\n+\n+        scheduler.submit(() -> {\n+            CompletableFuture<@Nullable Void> logoutFuture = this.logoutFuture;\n+            if (logoutFuture != null) {\n+                try {\n+                    logoutFuture.get();\n+                } catch (InterruptedException e) {\n+                    logger.warn(\"Interrupted while waiting for logout!\");\n+                } catch (ExecutionException e) {\n+                    logger.warn(\"Failed to wait for logout: {}\", e.getMessage());\n+                    logger.debug(\"Exception details:\", e);\n+                }\n+            }\n+\n+            try {\n+                webService.close();\n+            } catch (Exception e) {\n+                logger.warn(\"Failed to close webservice: {}\", e.getMessage());\n+                logger.debug(\"Exception details:\", e);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void onNewAccessToken(String accessToken) {\n+        logger.info(\"Setting new access token for webservice access.\");\n+        updateProperty(MieleCloudBindingConstants.PROPERTY_ACCESS_TOKEN, accessToken);\n+\n+        // Without this the retry would fail causing the thing to go OFFLINE\n+        getWebservice().setAccessToken(accessToken);\n+\n+        // If there was no access token during initialization then the SSE connection was not established.\n+        getWebservice().connectSse();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    private void performLogout() {\n+        logoutFuture = new CompletableFuture<>();\n+        scheduler.schedule(() -> {\n+            try {\n+                getWebservice().logout();\n+            } catch (Exception exception) {\n+                logger.warn(\"Failed to logout from Miele cloud.\");\n+                logger.debug(\"Exception details:\", exception);\n+            }\n+            OptionalUtils.ofNullable(logoutFuture).map(future -> future.complete(null));\n+        }, 1, TimeUnit.NANOSECONDS);\n+    }\n+\n+    private void tryInitializeWebservice() {\n+        Optional<String> accessToken = tokenRefresher.getAccessTokenFromStorage(getOAuthServiceHandle());\n+        if (!accessToken.isPresent()) {\n+            logger.info(\"No OAuth2 access token available. Retrying later.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                    I18NKeys.BRIDGE_STATUS_DESCRIPTION_ACCESS_TOKEN_NOT_CONFIGURED);\n+            return;\n+        }\n+        getWebservice().setAccessToken(accessToken.get());\n+        updateProperty(MieleCloudBindingConstants.PROPERTY_ACCESS_TOKEN, accessToken.get());\n+    }\n+\n+    @Override\n+    protected void updateStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        synchronized (this) {\n+            if (getThing().getStatus() == ThingStatus.REMOVING && status != ThingStatus.REMOVED) {\n+                return;\n+            }\n+\n+            super.updateStatus(status, statusDetail, description);\n+        }\n+    }", "originalCommit": "6582025c1528e8b30c0ace82e86da942293af0d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEyNDQzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r536124439", "bodyText": "In short: Preventing status updates from asynchronous operations after the thing was disposed.\nIn long: In the unlikely event that an OAuth token refresh is triggered short before the bridge is placed in REMOVING the token refresh will run asynchronously and on success try to update the thing status on a then REMOVING bridge. We cannot simply cancel refreshing the tokens as this is handled by the framework. However, checking whether the thing is REMOVING before updating the status is not intuitive either and may cause problems in the future as the caller must synchronize on this, then check whether the thing is disposing and only then update the status. In our opinion it is less error prone to simply suppress status updates while transitioning from REMOVING into REMOVED state.", "author": "BjoernLange", "createdAt": "2020-12-04T14:08:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM5ODkwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTkxNTg4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r611915885", "bodyText": "Wouldn't it then make sense to do this in the framework for ALL bindings and not here as a specific implementation just for this one? I'd also prefer to remove this here and rather have an issue/PR filed for openhab-core.", "author": "kaikreuzer", "createdAt": "2021-04-12T20:00:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM5ODkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwMDM1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r534400359", "bodyText": "Can you somehow include a detail message, which will be displayed in the UI, that the user gets a clue what's wrong?", "author": "fwolter", "createdAt": "2020-12-02T18:46:07Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/handler/MieleBridgeHandler.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.handler;\n+\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants;\n+import org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants.I18NKeys;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthException;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthTokenRefreshListener;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthTokenRefresher;\n+import org.openhab.binding.mielecloud.internal.discovery.ThingDiscoveryService;\n+import org.openhab.binding.mielecloud.internal.util.LocaleValidator;\n+import org.openhab.binding.mielecloud.internal.util.OptionalUtils;\n+import org.openhab.binding.mielecloud.internal.webservice.ConnectionError;\n+import org.openhab.binding.mielecloud.internal.webservice.ConnectionStatusListener;\n+import org.openhab.binding.mielecloud.internal.webservice.DeviceStateListener;\n+import org.openhab.binding.mielecloud.internal.webservice.MieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.UnavailableMieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.api.ActionsState;\n+import org.openhab.binding.mielecloud.internal.webservice.api.DeviceState;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceInitializationException;\n+import org.openhab.binding.mielecloud.internal.webservice.language.CombiningLanguageProvider;\n+import org.openhab.binding.mielecloud.internal.webservice.language.LanguageProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * BridgeHandler implementation for the Miele cloud account.\n+ *\n+ * @author Roland Edelhoff - Initial contribution\n+ * @author Bj\u00f6rn Lange - Introduced CombiningLanguageProvider field and interactions, added LanguageProvider super\n+ *         interface, switched from polling to SSE, added support for multiple bridges\n+ */\n+@NonNullByDefault\n+public class MieleBridgeHandler extends BaseBridgeHandler\n+        implements OAuthTokenRefreshListener, LanguageProvider, ConnectionStatusListener, DeviceStateListener {\n+    private static final int NUMBER_OF_SSE_RECONNECTION_ATTEMPTS_BEFORE_STATUS_IS_UPDATED = 6;\n+\n+    private final Supplier<MieleWebservice> webserviceFactory;\n+\n+    private final OAuthTokenRefresher tokenRefresher;\n+    private final CombiningLanguageProvider languageProvider;\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+\n+    @Nullable\n+    private CompletableFuture<@Nullable Void> logoutFuture;\n+    @Nullable\n+    private MieleWebservice webService;\n+    @Nullable\n+    private ThingDiscoveryService discoveryService;\n+\n+    /**\n+     * Creates a new {@link MieleBridgeHandler}.\n+     *\n+     * @param bridge The bridge to handle.\n+     * @param webserviceFactory Factory for creating {@link MieleWebservice} instances.\n+     * @param tokenRefresher Token refresher.\n+     * @param languageProvider Language provider.\n+     */\n+    public MieleBridgeHandler(Bridge bridge, Function<ScheduledExecutorService, MieleWebservice> webserviceFactory,\n+            OAuthTokenRefresher tokenRefresher, CombiningLanguageProvider languageProvider) {\n+        super(bridge);\n+        this.webserviceFactory = () -> webserviceFactory.apply(scheduler);\n+        this.tokenRefresher = tokenRefresher;\n+        this.languageProvider = languageProvider;\n+    }\n+\n+    public void setDiscoveryService(@Nullable ThingDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    /**\n+     * Gets the current webservice instance for communication with the Miele service.\n+     *\n+     * This function may return an {@link UnavailableMieleWebservice} in case no webservice is available at the moment.\n+     */\n+    public MieleWebservice getWebservice() {\n+        MieleWebservice webservice = webService;\n+        if (webservice != null) {\n+            return webservice;\n+        } else {\n+            return UnavailableMieleWebservice.INSTANCE;\n+        }\n+    }\n+\n+    private String getOAuthServiceHandle() {\n+        return getThing().getUID().getAsString();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // It is required to set a status in this method as stated in the Javadoc of ThingHandler.initialize\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        try {\n+            webService = webserviceFactory.get();\n+        } catch (MieleWebserviceInitializationException e) {\n+            logger.warn(\"Failed to initialize webservice: {}\", e.getMessage());\n+            logger.debug(\"Exception details:\", e);\n+            updateStatus(ThingStatus.OFFLINE);\n+            return;\n+        }\n+\n+        try {\n+            tokenRefresher.setRefreshListener(this, getOAuthServiceHandle());\n+        } catch (OAuthException e) {\n+            logger.warn(\"Could not initialize Miele Cloud bridge: {}\", e.getMessage());\n+            logger.debug(\"Exception details:\", e);\n+            logger.warn(\"The account has not been authorized. Please consult the documentation on how to do that.\");\n+            logger.warn(\"If using things-files reload your thing configuration afterwards.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    I18NKeys.BRIDGE_STATUS_DESCRIPTION_ACCOUNT_NOT_AUTHORIZED);\n+            // When the authorization takes place handleConfigurationUpdate() will be called which triggers a new\n+            // initialization. Therefore we can leave the bridge in this state.\n+            return;\n+        }\n+        languageProvider.setPrioritizedLanguageProvider(this);\n+        tryInitializeWebservice();\n+\n+        MieleWebservice webservice = getWebservice();\n+        webservice.addConnectionStatusListener(this);\n+        webservice.addDeviceStateListener(this);\n+        if (webservice.hasAccessToken()) {\n+            webservice.connectSse();\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        performLogout();\n+        tokenRefresher.removeTokensFromStorage(getOAuthServiceHandle());\n+        super.handleRemoval();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing {}\", this.getClass().getName());\n+        getWebservice().removeConnectionStatusListener(this);\n+        getWebservice().removeDeviceStateListener(this);\n+        getWebservice().disconnectSse();\n+        languageProvider.unsetPrioritizedLanguageProvider();\n+        tokenRefresher.unsetRefreshListener(getOAuthServiceHandle());\n+\n+        stopWebservice();\n+    }\n+\n+    private void stopWebservice() {\n+        final MieleWebservice webService = this.webService;\n+        this.webService = null;\n+        if (webService == null) {\n+            return;\n+        }\n+\n+        scheduler.submit(() -> {\n+            CompletableFuture<@Nullable Void> logoutFuture = this.logoutFuture;\n+            if (logoutFuture != null) {\n+                try {\n+                    logoutFuture.get();\n+                } catch (InterruptedException e) {\n+                    logger.warn(\"Interrupted while waiting for logout!\");\n+                } catch (ExecutionException e) {\n+                    logger.warn(\"Failed to wait for logout: {}\", e.getMessage());\n+                    logger.debug(\"Exception details:\", e);\n+                }\n+            }\n+\n+            try {\n+                webService.close();\n+            } catch (Exception e) {\n+                logger.warn(\"Failed to close webservice: {}\", e.getMessage());\n+                logger.debug(\"Exception details:\", e);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void onNewAccessToken(String accessToken) {\n+        logger.info(\"Setting new access token for webservice access.\");\n+        updateProperty(MieleCloudBindingConstants.PROPERTY_ACCESS_TOKEN, accessToken);\n+\n+        // Without this the retry would fail causing the thing to go OFFLINE\n+        getWebservice().setAccessToken(accessToken);\n+\n+        // If there was no access token during initialization then the SSE connection was not established.\n+        getWebservice().connectSse();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    private void performLogout() {\n+        logoutFuture = new CompletableFuture<>();\n+        scheduler.schedule(() -> {\n+            try {\n+                getWebservice().logout();\n+            } catch (Exception exception) {\n+                logger.warn(\"Failed to logout from Miele cloud.\");\n+                logger.debug(\"Exception details:\", exception);\n+            }\n+            OptionalUtils.ofNullable(logoutFuture).map(future -> future.complete(null));\n+        }, 1, TimeUnit.NANOSECONDS);\n+    }\n+\n+    private void tryInitializeWebservice() {\n+        Optional<String> accessToken = tokenRefresher.getAccessTokenFromStorage(getOAuthServiceHandle());\n+        if (!accessToken.isPresent()) {\n+            logger.info(\"No OAuth2 access token available. Retrying later.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                    I18NKeys.BRIDGE_STATUS_DESCRIPTION_ACCESS_TOKEN_NOT_CONFIGURED);\n+            return;\n+        }\n+        getWebservice().setAccessToken(accessToken.get());\n+        updateProperty(MieleCloudBindingConstants.PROPERTY_ACCESS_TOKEN, accessToken.get());\n+    }\n+\n+    @Override\n+    protected void updateStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        synchronized (this) {\n+            if (getThing().getStatus() == ThingStatus.REMOVING && status != ThingStatus.REMOVED) {\n+                return;\n+            }\n+\n+            super.updateStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    @Override\n+    public void onConnectionAlive() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void onConnectionError(ConnectionError connectionError, int failedReconnectionAttempts) {\n+        if (connectionError == ConnectionError.AUTHORIZATION_FAILED) {\n+            tryToRefreshAccessToken();\n+            return;\n+        }\n+\n+        if (failedReconnectionAttempts <= NUMBER_OF_SSE_RECONNECTION_ATTEMPTS_BEFORE_STATUS_IS_UPDATED\n+                && getThing().getStatus() != ThingStatus.UNKNOWN) {\n+            return;\n+        }\n+\n+        if (getThing().getStatus() == ThingStatus.UNKNOWN && connectionError == ConnectionError.REQUEST_INTERRUPTED\n+                && failedReconnectionAttempts <= NUMBER_OF_SSE_RECONNECTION_ATTEMPTS_BEFORE_STATUS_IS_UPDATED) {\n+            return;\n+        }\n+\n+        switch (connectionError) {\n+            case AUTHORIZATION_FAILED:\n+                // Handled above.\n+                break;\n+\n+            case REQUEST_EXECUTION_FAILED:\n+            case SERVICE_UNAVAILABLE:\n+            case RESPONSE_MALFORMED:\n+            case TIMEOUT:\n+            case TOO_MANY_RERQUESTS:\n+            case SSE_STREAM_ENDED:\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                break;\n+\n+            case SERVER_ERROR:\n+            case REQUEST_INTERRUPTED:\n+            case OTHER_HTTP_ERROR:\n+            default:\n+                updateStatus(ThingStatus.OFFLINE);", "originalCommit": "6582025c1528e8b30c0ace82e86da942293af0d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgyNzkxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r540827919", "bodyText": "I think it wouldn't be helpful as this case handles\n\nHTTP errors we cannot handle any other way than retrying later (what we do)\nInterruptions while sending a request (likely because openHAB is shutting down)\n\nWe could include some generic messages like \"Request to cloud service failed\", but does that really provide reasonable assistance to the user?", "author": "BjoernLange", "createdAt": "2020-12-11T09:58:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwMDM1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk2MDQ1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r541960457", "bodyText": "You could set a generic message that this is a transient error. InterruptedExceptions might not be seen by the user at all in the UI.", "author": "fwolter", "createdAt": "2020-12-13T16:42:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwMDM1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcxODM5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r545718395", "bodyText": "I added an error message. Please check again.", "author": "BjoernLange", "createdAt": "2020-12-18T09:46:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwMDM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwMTI2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r534401267", "bodyText": "This shouldn't be necessary.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = ThingHandlerFactory.class, immediate = true, configurationPid = \"binding.mielecloud\")\n          \n          \n            \n            @Component(service = ThingHandlerFactory.class, configurationPid = \"binding.mielecloud\")", "author": "fwolter", "createdAt": "2020-12-02T18:47:33Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/handler/MieleHandlerFactory.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.handler;\n+\n+import static org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants.*;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.function.Function;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthTokenRefresher;\n+import org.openhab.binding.mielecloud.internal.discovery.ThingDiscoveryService;\n+import org.openhab.binding.mielecloud.internal.webservice.DefaultMieleWebserviceFactory;\n+import org.openhab.binding.mielecloud.internal.webservice.MieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.MieleWebserviceConfiguration;\n+import org.openhab.binding.mielecloud.internal.webservice.MieleWebserviceFactory;\n+import org.openhab.binding.mielecloud.internal.webservice.language.CombiningLanguageProvider;\n+import org.openhab.binding.mielecloud.internal.webservice.language.JvmLanguageProvider;\n+import org.openhab.binding.mielecloud.internal.webservice.language.OpenHabLanguageProvider;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Factory producing the {@link ThingHandler}s for all things supported by this binding.\n+ *\n+ * @author Roland Edelhoff - Initial contribution\n+ * @author Bj\u00f6rn Lange - Added language provider, added support for multiple bridges\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, immediate = true, configurationPid = \"binding.mielecloud\")", "originalCommit": "6582025c1528e8b30c0ace82e86da942293af0d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwMjE0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r534402145", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections.unmodifiableSet(new HashSet<ThingTypeUID>(\n          \n          \n            \n                        Arrays.asList(THING_TYPE_BRIDGE, THING_TYPE_WASHING_MACHINE, THING_TYPE_WASHER_DRYER,\n          \n          \n            \n                                THING_TYPE_COFFEE_SYSTEM, THING_TYPE_FRIDGE_FREEZER, THING_TYPE_FRIDGE, THING_TYPE_FREEZER,\n          \n          \n            \n                                THING_TYPE_OVEN, THING_TYPE_WINE_STORAGE, THING_TYPE_HOB, THING_TYPE_DRYER, THING_TYPE_DISHWASHER,\n          \n          \n            \n                                THING_TYPE_HOOD, THING_TYPE_DISH_WARMER, THING_TYPE_ROBOTIC_VACUUM_CLEANER)));\n          \n          \n            \n                public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Set.of(THING_TYPE_BRIDGE, THING_TYPE_WASHING_MACHINE,\n          \n          \n            \n                        THING_TYPE_WASHER_DRYER, THING_TYPE_COFFEE_SYSTEM, THING_TYPE_FRIDGE_FREEZER, THING_TYPE_FRIDGE,\n          \n          \n            \n                        THING_TYPE_FREEZER, THING_TYPE_OVEN, THING_TYPE_WINE_STORAGE, THING_TYPE_HOB, THING_TYPE_DRYER,\n          \n          \n            \n                        THING_TYPE_DISHWASHER, THING_TYPE_HOOD, THING_TYPE_DISH_WARMER, THING_TYPE_ROBOTIC_VACUUM_CLEANER);", "author": "fwolter", "createdAt": "2020-12-02T18:48:54Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/handler/MieleHandlerFactory.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.handler;\n+\n+import static org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants.*;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.function.Function;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthTokenRefresher;\n+import org.openhab.binding.mielecloud.internal.discovery.ThingDiscoveryService;\n+import org.openhab.binding.mielecloud.internal.webservice.DefaultMieleWebserviceFactory;\n+import org.openhab.binding.mielecloud.internal.webservice.MieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.MieleWebserviceConfiguration;\n+import org.openhab.binding.mielecloud.internal.webservice.MieleWebserviceFactory;\n+import org.openhab.binding.mielecloud.internal.webservice.language.CombiningLanguageProvider;\n+import org.openhab.binding.mielecloud.internal.webservice.language.JvmLanguageProvider;\n+import org.openhab.binding.mielecloud.internal.webservice.language.OpenHabLanguageProvider;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Factory producing the {@link ThingHandler}s for all things supported by this binding.\n+ *\n+ * @author Roland Edelhoff - Initial contribution\n+ * @author Bj\u00f6rn Lange - Added language provider, added support for multiple bridges\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, immediate = true, configurationPid = \"binding.mielecloud\")\n+public class MieleHandlerFactory extends BaseThingHandlerFactory {\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+\n+    @Nullable\n+    private HttpClientFactory httpClientFactory;\n+    @Nullable\n+    private OAuthTokenRefresher tokenRefresher;\n+    @Nullable\n+    private LocaleProvider localeProvider;\n+\n+    private final MieleWebserviceFactory webserviceFactory = new DefaultMieleWebserviceFactory();\n+\n+    private final Map<ThingUID, @Nullable ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+\n+    @Reference\n+    protected void setHttpClientFactory(HttpClientFactory httpClientFactory) {\n+        this.httpClientFactory = httpClientFactory;\n+    }\n+\n+    protected void unsetHttpClientFactory(HttpClientFactory httpClientFactory) {\n+        this.httpClientFactory = null;\n+    }\n+\n+    @Reference\n+    protected void setOAuthTokenRefresher(OAuthTokenRefresher tokenRefresher) {\n+        this.tokenRefresher = tokenRefresher;\n+    }\n+\n+    protected void unsetOAuthTokenRefresher(OAuthTokenRefresher tokenRefresher) {\n+        this.tokenRefresher = null;\n+    }\n+\n+    @Reference\n+    protected void setLocaleProvider(LocaleProvider localeProvider) {\n+        this.localeProvider = localeProvider;\n+    }\n+\n+    protected void unsetLocaleProvider(LocaleProvider localeProvider) {\n+        this.localeProvider = null;\n+    }\n+\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections.unmodifiableSet(new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_BRIDGE, THING_TYPE_WASHING_MACHINE, THING_TYPE_WASHER_DRYER,\n+                    THING_TYPE_COFFEE_SYSTEM, THING_TYPE_FRIDGE_FREEZER, THING_TYPE_FRIDGE, THING_TYPE_FREEZER,\n+                    THING_TYPE_OVEN, THING_TYPE_WINE_STORAGE, THING_TYPE_HOB, THING_TYPE_DRYER, THING_TYPE_DISHWASHER,\n+                    THING_TYPE_HOOD, THING_TYPE_DISH_WARMER, THING_TYPE_ROBOTIC_VACUUM_CLEANER)));", "originalCommit": "6582025c1528e8b30c0ace82e86da942293af0d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwNTUyNg==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r534405526", "bodyText": "You could use ThingHandlerService which would make this code unnecessary. The documentation for this is not yet merged, but available in the PR: https://github.com/openhab/openhab-docs/pull/1262/files#diff-c4a4d8725430bc2ea046182bfc73ac51349d989c7f6a8a6fa3001a226a09ad98R932", "author": "fwolter", "createdAt": "2020-12-02T18:54:15Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/handler/MieleHandlerFactory.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.handler;\n+\n+import static org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants.*;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.function.Function;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthTokenRefresher;\n+import org.openhab.binding.mielecloud.internal.discovery.ThingDiscoveryService;\n+import org.openhab.binding.mielecloud.internal.webservice.DefaultMieleWebserviceFactory;\n+import org.openhab.binding.mielecloud.internal.webservice.MieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.MieleWebserviceConfiguration;\n+import org.openhab.binding.mielecloud.internal.webservice.MieleWebserviceFactory;\n+import org.openhab.binding.mielecloud.internal.webservice.language.CombiningLanguageProvider;\n+import org.openhab.binding.mielecloud.internal.webservice.language.JvmLanguageProvider;\n+import org.openhab.binding.mielecloud.internal.webservice.language.OpenHabLanguageProvider;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Factory producing the {@link ThingHandler}s for all things supported by this binding.\n+ *\n+ * @author Roland Edelhoff - Initial contribution\n+ * @author Bj\u00f6rn Lange - Added language provider, added support for multiple bridges\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, immediate = true, configurationPid = \"binding.mielecloud\")\n+public class MieleHandlerFactory extends BaseThingHandlerFactory {\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+\n+    @Nullable\n+    private HttpClientFactory httpClientFactory;\n+    @Nullable\n+    private OAuthTokenRefresher tokenRefresher;\n+    @Nullable\n+    private LocaleProvider localeProvider;\n+\n+    private final MieleWebserviceFactory webserviceFactory = new DefaultMieleWebserviceFactory();\n+\n+    private final Map<ThingUID, @Nullable ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+\n+    @Reference\n+    protected void setHttpClientFactory(HttpClientFactory httpClientFactory) {\n+        this.httpClientFactory = httpClientFactory;\n+    }\n+\n+    protected void unsetHttpClientFactory(HttpClientFactory httpClientFactory) {\n+        this.httpClientFactory = null;\n+    }\n+\n+    @Reference\n+    protected void setOAuthTokenRefresher(OAuthTokenRefresher tokenRefresher) {\n+        this.tokenRefresher = tokenRefresher;\n+    }\n+\n+    protected void unsetOAuthTokenRefresher(OAuthTokenRefresher tokenRefresher) {\n+        this.tokenRefresher = null;\n+    }\n+\n+    @Reference\n+    protected void setLocaleProvider(LocaleProvider localeProvider) {\n+        this.localeProvider = localeProvider;\n+    }\n+\n+    protected void unsetLocaleProvider(LocaleProvider localeProvider) {\n+        this.localeProvider = null;\n+    }\n+\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections.unmodifiableSet(new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_BRIDGE, THING_TYPE_WASHING_MACHINE, THING_TYPE_WASHER_DRYER,\n+                    THING_TYPE_COFFEE_SYSTEM, THING_TYPE_FRIDGE_FREEZER, THING_TYPE_FRIDGE, THING_TYPE_FREEZER,\n+                    THING_TYPE_OVEN, THING_TYPE_WINE_STORAGE, THING_TYPE_HOB, THING_TYPE_DRYER, THING_TYPE_DISHWASHER,\n+                    THING_TYPE_HOOD, THING_TYPE_DISH_WARMER, THING_TYPE_ROBOTIC_VACUUM_CLEANER)));\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    @Nullable\n+    protected ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (thingTypeUID.equals(THING_TYPE_BRIDGE)) {\n+            return createBridgeHandler(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_WASHING_MACHINE) || thingTypeUID.equals(THING_TYPE_WASHER_DRYER)) {\n+            return new WashingDeviceThingHandler(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_COFFEE_SYSTEM)) {\n+            return new CoffeeSystemThingHandler(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_FRIDGE_FREEZER) || thingTypeUID.equals(THING_TYPE_FRIDGE)\n+                || thingTypeUID.equals(THING_TYPE_FREEZER)) {\n+            return new CoolingDeviceThingHandler(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_WINE_STORAGE)) {\n+            return new WineStorageDeviceThingHandler(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_OVEN)) {\n+            return new OvenDeviceThingHandler(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_HOB)) {\n+            return new HobDeviceThingHandler(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_DISHWASHER)) {\n+            return new DishwasherDeviceThingHandler(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_DRYER)) {\n+            return new DryerDeviceThingHandler(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_HOOD)) {\n+            return new HoodDeviceThingHandler(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_DISH_WARMER)) {\n+            return new DishWarmerDeviceThingHandler(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_ROBOTIC_VACUUM_CLEANER)) {\n+            return new RoboticVacuumCleanerDeviceThingHandler(thing);\n+        }\n+\n+        return null;\n+    }\n+\n+    private ThingHandler createBridgeHandler(Thing thing) {\n+        CombiningLanguageProvider languageProvider = getLanguageProvider();\n+        Function<ScheduledExecutorService, MieleWebservice> webserviceFactoryFunction = scheduler -> webserviceFactory\n+                .create(MieleWebserviceConfiguration.builder()\n+                        .withHttpClientFactory(requireNonNull(httpClientFactory, \"httpClientFactory\"))\n+                        .withLanguageProvider(languageProvider)\n+                        .withTokenRefresher(requireNonNull(tokenRefresher, \"tokenRefreseher\"))\n+                        .withServiceHandle(thing.getUID().getAsString()).withScheduler(scheduler).build());\n+\n+        MieleBridgeHandler bridgeHandler = new MieleBridgeHandler((Bridge) thing, webserviceFactoryFunction,\n+                requireNonNull(tokenRefresher, \"tokenRefresher\"), languageProvider);\n+        registerThingDiscoveryService(bridgeHandler);\n+        return bridgeHandler;\n+    }\n+\n+    private CombiningLanguageProvider getLanguageProvider() {\n+        final LocaleProvider localeProvider = this.localeProvider;\n+        if (localeProvider == null) {\n+            return new CombiningLanguageProvider(null, new JvmLanguageProvider());\n+        } else {\n+            return new CombiningLanguageProvider(null, new OpenHabLanguageProvider(localeProvider));\n+        }\n+    }\n+\n+    private synchronized void registerThingDiscoveryService(MieleBridgeHandler bridgeHandler) {\n+        ThingDiscoveryService discoveryService = new ThingDiscoveryService(bridgeHandler);\n+        discoveryService.activate();\n+\n+        ServiceRegistration<?> registration = bundleContext.registerService(DiscoveryService.class.getName(),\n+                discoveryService, new Hashtable<String, Object>());\n+        discoveryServiceRegs.put(bridgeHandler.getThing().getUID(), registration);\n+\n+        logger.debug(\"OSGi service [{}] for {} registered.\", discoveryService.getClass().getName(),\n+                DiscoveryService.class.getName());\n+    }", "originalCommit": "6582025c1528e8b30c0ace82e86da942293af0d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1MTI4NA==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r540851284", "bodyText": "That's pretty cool! Changed it!", "author": "BjoernLange", "createdAt": "2020-12-11T10:36:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwNTUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwNjA2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r534406061", "bodyText": "What about Objects.requireNonNull()?", "author": "fwolter", "createdAt": "2020-12-02T18:55:02Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/handler/MieleHandlerFactory.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.handler;\n+\n+import static org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants.*;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.function.Function;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthTokenRefresher;\n+import org.openhab.binding.mielecloud.internal.discovery.ThingDiscoveryService;\n+import org.openhab.binding.mielecloud.internal.webservice.DefaultMieleWebserviceFactory;\n+import org.openhab.binding.mielecloud.internal.webservice.MieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.MieleWebserviceConfiguration;\n+import org.openhab.binding.mielecloud.internal.webservice.MieleWebserviceFactory;\n+import org.openhab.binding.mielecloud.internal.webservice.language.CombiningLanguageProvider;\n+import org.openhab.binding.mielecloud.internal.webservice.language.JvmLanguageProvider;\n+import org.openhab.binding.mielecloud.internal.webservice.language.OpenHabLanguageProvider;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Factory producing the {@link ThingHandler}s for all things supported by this binding.\n+ *\n+ * @author Roland Edelhoff - Initial contribution\n+ * @author Bj\u00f6rn Lange - Added language provider, added support for multiple bridges\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, immediate = true, configurationPid = \"binding.mielecloud\")\n+public class MieleHandlerFactory extends BaseThingHandlerFactory {\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+\n+    @Nullable\n+    private HttpClientFactory httpClientFactory;\n+    @Nullable\n+    private OAuthTokenRefresher tokenRefresher;\n+    @Nullable\n+    private LocaleProvider localeProvider;\n+\n+    private final MieleWebserviceFactory webserviceFactory = new DefaultMieleWebserviceFactory();\n+\n+    private final Map<ThingUID, @Nullable ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+\n+    @Reference\n+    protected void setHttpClientFactory(HttpClientFactory httpClientFactory) {\n+        this.httpClientFactory = httpClientFactory;\n+    }\n+\n+    protected void unsetHttpClientFactory(HttpClientFactory httpClientFactory) {\n+        this.httpClientFactory = null;\n+    }\n+\n+    @Reference\n+    protected void setOAuthTokenRefresher(OAuthTokenRefresher tokenRefresher) {\n+        this.tokenRefresher = tokenRefresher;\n+    }\n+\n+    protected void unsetOAuthTokenRefresher(OAuthTokenRefresher tokenRefresher) {\n+        this.tokenRefresher = null;\n+    }\n+\n+    @Reference\n+    protected void setLocaleProvider(LocaleProvider localeProvider) {\n+        this.localeProvider = localeProvider;\n+    }\n+\n+    protected void unsetLocaleProvider(LocaleProvider localeProvider) {\n+        this.localeProvider = null;\n+    }\n+\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections.unmodifiableSet(new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_BRIDGE, THING_TYPE_WASHING_MACHINE, THING_TYPE_WASHER_DRYER,\n+                    THING_TYPE_COFFEE_SYSTEM, THING_TYPE_FRIDGE_FREEZER, THING_TYPE_FRIDGE, THING_TYPE_FREEZER,\n+                    THING_TYPE_OVEN, THING_TYPE_WINE_STORAGE, THING_TYPE_HOB, THING_TYPE_DRYER, THING_TYPE_DISHWASHER,\n+                    THING_TYPE_HOOD, THING_TYPE_DISH_WARMER, THING_TYPE_ROBOTIC_VACUUM_CLEANER)));\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    @Nullable\n+    protected ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (thingTypeUID.equals(THING_TYPE_BRIDGE)) {\n+            return createBridgeHandler(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_WASHING_MACHINE) || thingTypeUID.equals(THING_TYPE_WASHER_DRYER)) {\n+            return new WashingDeviceThingHandler(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_COFFEE_SYSTEM)) {\n+            return new CoffeeSystemThingHandler(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_FRIDGE_FREEZER) || thingTypeUID.equals(THING_TYPE_FRIDGE)\n+                || thingTypeUID.equals(THING_TYPE_FREEZER)) {\n+            return new CoolingDeviceThingHandler(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_WINE_STORAGE)) {\n+            return new WineStorageDeviceThingHandler(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_OVEN)) {\n+            return new OvenDeviceThingHandler(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_HOB)) {\n+            return new HobDeviceThingHandler(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_DISHWASHER)) {\n+            return new DishwasherDeviceThingHandler(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_DRYER)) {\n+            return new DryerDeviceThingHandler(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_HOOD)) {\n+            return new HoodDeviceThingHandler(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_DISH_WARMER)) {\n+            return new DishWarmerDeviceThingHandler(thing);\n+        } else if (thingTypeUID.equals(THING_TYPE_ROBOTIC_VACUUM_CLEANER)) {\n+            return new RoboticVacuumCleanerDeviceThingHandler(thing);\n+        }\n+\n+        return null;\n+    }\n+\n+    private ThingHandler createBridgeHandler(Thing thing) {\n+        CombiningLanguageProvider languageProvider = getLanguageProvider();\n+        Function<ScheduledExecutorService, MieleWebservice> webserviceFactoryFunction = scheduler -> webserviceFactory\n+                .create(MieleWebserviceConfiguration.builder()\n+                        .withHttpClientFactory(requireNonNull(httpClientFactory, \"httpClientFactory\"))\n+                        .withLanguageProvider(languageProvider)\n+                        .withTokenRefresher(requireNonNull(tokenRefresher, \"tokenRefreseher\"))\n+                        .withServiceHandle(thing.getUID().getAsString()).withScheduler(scheduler).build());\n+\n+        MieleBridgeHandler bridgeHandler = new MieleBridgeHandler((Bridge) thing, webserviceFactoryFunction,\n+                requireNonNull(tokenRefresher, \"tokenRefresher\"), languageProvider);\n+        registerThingDiscoveryService(bridgeHandler);\n+        return bridgeHandler;\n+    }\n+\n+    private CombiningLanguageProvider getLanguageProvider() {\n+        final LocaleProvider localeProvider = this.localeProvider;\n+        if (localeProvider == null) {\n+            return new CombiningLanguageProvider(null, new JvmLanguageProvider());\n+        } else {\n+            return new CombiningLanguageProvider(null, new OpenHabLanguageProvider(localeProvider));\n+        }\n+    }\n+\n+    private synchronized void registerThingDiscoveryService(MieleBridgeHandler bridgeHandler) {\n+        ThingDiscoveryService discoveryService = new ThingDiscoveryService(bridgeHandler);\n+        discoveryService.activate();\n+\n+        ServiceRegistration<?> registration = bundleContext.registerService(DiscoveryService.class.getName(),\n+                discoveryService, new Hashtable<String, Object>());\n+        discoveryServiceRegs.put(bridgeHandler.getThing().getUID(), registration);\n+\n+        logger.debug(\"OSGi service [{}] for {} registered.\", discoveryService.getClass().getName(),\n+                DiscoveryService.class.getName());\n+    }\n+\n+    @Override\n+    protected void removeHandler(ThingHandler thingHandler) {\n+        if (!(thingHandler instanceof MieleBridgeHandler)) {\n+            return;\n+        }\n+\n+        unregisterDiscoveryService(thingHandler.getThing().getUID());\n+    }\n+\n+    private synchronized void unregisterDiscoveryService(ThingUID uid) {\n+        ServiceRegistration<?> registration = discoveryServiceRegs.remove(uid);\n+        if (registration != null) {\n+            ThingDiscoveryService service = (ThingDiscoveryService) bundleContext\n+                    .getService(registration.getReference());\n+            registration.unregister();\n+            if (service != null) {\n+                service.deactivate();\n+            }\n+        }\n+    }\n+\n+    private <T> T requireNonNull(@Nullable T obj, String objName) {\n+        if (obj == null) {\n+            throw new IllegalArgumentException(objName + \" must not be null\");\n+        }\n+        return obj;\n+    }", "originalCommit": "6582025c1528e8b30c0ace82e86da942293af0d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1MjEzNw==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r540852137", "bodyText": "This was a remnant of our workarounds for the static null-checks and became obsolete through constructor injection. I deleted it.", "author": "BjoernLange", "createdAt": "2020-12-11T10:38:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwNjA2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwODI3NA==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r534408274", "bodyText": "We had an update to the null annotation checks recently. Did you check if this is still necessary?", "author": "fwolter", "createdAt": "2020-12-02T18:58:41Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/util/OptionalUtils.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.util;\n+\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Utility class to prevent problems with null annotations with {@link Optional}s.", "originalCommit": "6582025c1528e8b30c0ace82e86da942293af0d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2MDgyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r540860825", "bodyText": "It isn't, I inlined the class.", "author": "BjoernLange", "createdAt": "2020-12-11T10:52:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwODI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk3NTkxNg==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r535975916", "bodyText": "Set.of()", "author": "fwolter", "createdAt": "2020-12-04T09:56:09Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/webservice/api/WineStorageDeviceTemperatureState.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.webservice.api;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.mielecloud.internal.webservice.api.json.DeviceType;\n+\n+/**\n+ * Provides easy access to temperature values mapped for wine storage devices.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WineStorageDeviceTemperatureState {\n+    private static final Set<DeviceType> ALL_WINE_STORAGES = Collections.unmodifiableSet(\n+            new HashSet<>(Arrays.asList(DeviceType.WINE_CABINET, DeviceType.WINE_CABINET_FREEZER_COMBINATION,\n+                    DeviceType.WINE_CONDITIONING_UNIT, DeviceType.WINE_STORAGE_CONDITIONING_UNIT)));", "originalCommit": "1e00ed69f68c36844faad18348fce47fead41cd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a36c6fb2c16dd5114841e508db5c011c40930224", "url": "https://github.com/openhab/openhab-addons/commit/a36c6fb2c16dd5114841e508db5c011c40930224", "message": "Lists instead of tables for channel IDs in README\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2020-12-09T09:27:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgzNTA4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r545835083", "bodyText": "It seems a bit unreasonable to log the stack trace when the authentication failed. You could log the exception's message. The stack trace should only be logged in rare cases e.g. a bug in your code has been detected.", "author": "fwolter", "createdAt": "2020-12-18T13:37:08Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/config/servlet/CreateBridgeServlet.java", "diffHunk": "@@ -98,8 +98,7 @@ protected String getRedirectionDestination(HttpServletRequest request) {\n         try {\n             accessToken = authorizationHandler.getAccessToken(bridgeUid);\n         } catch (OAuthException e) {\n-            logger.warn(\"Failed to obtain access token\");\n-            logger.debug(\"Exception details:\", e);\n+            logger.warn(\"Failed to obtain access token.\", e);", "originalCommit": "5e9c9198d65500475deee39d1608f61028972055", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU0OTEzNg==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r546549136", "bodyText": "Sorry for the inconvenience, this part of the code should have been removed. The access token is no longer part of the bridge configuration, so accessing it here is unnecessary. I removed the code.", "author": "BjoernLange", "createdAt": "2020-12-21T07:30:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgzNTA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkzMjg5OA==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r547932898", "bodyText": "Should be debug level", "author": "mhilbush", "createdAt": "2020-12-23T12:22:50Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/webservice/sse/SseConnection.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.webservice.sse;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Response;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.InputStreamResponseListener;\n+import org.openhab.binding.mielecloud.internal.webservice.ConnectionError;\n+import org.openhab.binding.mielecloud.internal.webservice.HttpUtil;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.AuthorizationFailedException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceDisconnectSseException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceTransientException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.TooManyRequestsException;\n+import org.openhab.binding.mielecloud.internal.webservice.retry.AuthorizationFailedRetryStrategy;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An active or inactive SSE connection emitting a stream of events.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial Contribution\n+ */\n+@NonNullByDefault\n+public final class SseConnection {\n+    private static final long CONNECTION_TIMEOUT = 30;\n+    private static final TimeUnit CONNECTION_TIMEOUT_UNIT = TimeUnit.SECONDS;\n+\n+    private static final long MINIMUM_RECONNECT_ATTEMPT_WAIT_TIME_IN_SECONDS = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(SseConnection.class);\n+\n+    private final String endpoint;\n+    private final SseRequestFactory requestFactory;\n+    private final ScheduledExecutorService scheduler;\n+    private final BackoffStrategy backoffStrategy;\n+\n+    private final List<SseListener> listeners = new ArrayList<>();\n+\n+    private boolean active = false;\n+\n+    private int failedConnectionAttempts = 0;\n+\n+    @Nullable\n+    private Request sseRequest;\n+\n+    /**\n+     * Creates a new {@link SseConnection} to the given endpoint.\n+     *\n+     * Note: It is required to call {@link #connect()} in order to open the connection and start receiving events.\n+     *\n+     * @param endpoint The endpoint to connect to.\n+     * @param requestFactory Factory for creating requests.\n+     * @param scheduler Scheduler to run scheduled and concurrent tasks on.\n+     */\n+    public SseConnection(String endpoint, SseRequestFactory requestFactory, ScheduledExecutorService scheduler) {\n+        this(endpoint, requestFactory, scheduler, new ExponentialBackoffWithJitter());\n+    }\n+\n+    /**\n+     * Creates a new {@link SseConnection} to the given endpoint.\n+     *\n+     * Note: It is required to call {@link #connect()} in order to open the connection and start receiving events.\n+     *\n+     * @param endpoint The endpoint to connect to.\n+     * @param requestFactory Factory for creating requests.\n+     * @param scheduler Scheduler to run scheduled and concurrent tasks on.\n+     * @param backoffStrategy Strategy for deriving the wait time between connection attempts.\n+     */\n+    SseConnection(String endpoint, SseRequestFactory requestFactory, ScheduledExecutorService scheduler,\n+            BackoffStrategy backoffStrategy) {\n+        this.endpoint = endpoint;\n+        this.requestFactory = requestFactory;\n+        this.scheduler = scheduler;\n+        this.backoffStrategy = backoffStrategy;\n+    }\n+\n+    public synchronized void connect() {\n+        active = true;\n+        connectInternal();\n+    }\n+\n+    private synchronized void connectInternal() {\n+        if (!active) {\n+            return;\n+        }\n+\n+        Request runningRequest = this.sseRequest;\n+        if (runningRequest != null) {\n+            return;\n+        }\n+\n+        logger.info(\"Opening SSE connection...\");", "originalCommit": "e5c8232f49175447ecf3f61cf135f66f327e79dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkzMzEyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r547933129", "bodyText": "Should be debug level", "author": "mhilbush", "createdAt": "2020-12-23T12:23:25Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/webservice/sse/SseConnection.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.webservice.sse;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Response;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.InputStreamResponseListener;\n+import org.openhab.binding.mielecloud.internal.webservice.ConnectionError;\n+import org.openhab.binding.mielecloud.internal.webservice.HttpUtil;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.AuthorizationFailedException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceDisconnectSseException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceTransientException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.TooManyRequestsException;\n+import org.openhab.binding.mielecloud.internal.webservice.retry.AuthorizationFailedRetryStrategy;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An active or inactive SSE connection emitting a stream of events.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial Contribution\n+ */\n+@NonNullByDefault\n+public final class SseConnection {\n+    private static final long CONNECTION_TIMEOUT = 30;\n+    private static final TimeUnit CONNECTION_TIMEOUT_UNIT = TimeUnit.SECONDS;\n+\n+    private static final long MINIMUM_RECONNECT_ATTEMPT_WAIT_TIME_IN_SECONDS = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(SseConnection.class);\n+\n+    private final String endpoint;\n+    private final SseRequestFactory requestFactory;\n+    private final ScheduledExecutorService scheduler;\n+    private final BackoffStrategy backoffStrategy;\n+\n+    private final List<SseListener> listeners = new ArrayList<>();\n+\n+    private boolean active = false;\n+\n+    private int failedConnectionAttempts = 0;\n+\n+    @Nullable\n+    private Request sseRequest;\n+\n+    /**\n+     * Creates a new {@link SseConnection} to the given endpoint.\n+     *\n+     * Note: It is required to call {@link #connect()} in order to open the connection and start receiving events.\n+     *\n+     * @param endpoint The endpoint to connect to.\n+     * @param requestFactory Factory for creating requests.\n+     * @param scheduler Scheduler to run scheduled and concurrent tasks on.\n+     */\n+    public SseConnection(String endpoint, SseRequestFactory requestFactory, ScheduledExecutorService scheduler) {\n+        this(endpoint, requestFactory, scheduler, new ExponentialBackoffWithJitter());\n+    }\n+\n+    /**\n+     * Creates a new {@link SseConnection} to the given endpoint.\n+     *\n+     * Note: It is required to call {@link #connect()} in order to open the connection and start receiving events.\n+     *\n+     * @param endpoint The endpoint to connect to.\n+     * @param requestFactory Factory for creating requests.\n+     * @param scheduler Scheduler to run scheduled and concurrent tasks on.\n+     * @param backoffStrategy Strategy for deriving the wait time between connection attempts.\n+     */\n+    SseConnection(String endpoint, SseRequestFactory requestFactory, ScheduledExecutorService scheduler,\n+            BackoffStrategy backoffStrategy) {\n+        this.endpoint = endpoint;\n+        this.requestFactory = requestFactory;\n+        this.scheduler = scheduler;\n+        this.backoffStrategy = backoffStrategy;\n+    }\n+\n+    public synchronized void connect() {\n+        active = true;\n+        connectInternal();\n+    }\n+\n+    private synchronized void connectInternal() {\n+        if (!active) {\n+            return;\n+        }\n+\n+        Request runningRequest = this.sseRequest;\n+        if (runningRequest != null) {\n+            return;\n+        }\n+\n+        logger.info(\"Opening SSE connection...\");\n+        Request sseRequest = createRequest();\n+        if (sseRequest == null) {\n+            logger.warn(\"Could not create SSE request, not opening SSE connection.\");\n+            return;\n+        }\n+\n+        final InputStreamResponseListener stream = new InputStreamResponseListener();\n+        SseStreamParser eventStreamParser = new SseStreamParser(stream.getInputStream(), this::onServerSentEvent,\n+                this::onSseStreamClosed);\n+\n+        sseRequest = sseRequest\n+                .onResponseHeaders(\n+                        response -> scheduler.schedule(eventStreamParser::parseAndDispatchEvents, 0, TimeUnit.SECONDS))\n+                .onComplete(result -> onConnectionComplete(result));\n+        sseRequest.send(stream);\n+        this.sseRequest = sseRequest;\n+    }\n+\n+    @Nullable\n+    private Request createRequest() {\n+        Request sseRequest = requestFactory.createSseRequest(endpoint);\n+        if (sseRequest == null) {\n+            return null;\n+        }\n+\n+        return sseRequest.timeout(0, TimeUnit.SECONDS).idleTimeout(CONNECTION_TIMEOUT, CONNECTION_TIMEOUT_UNIT);\n+    }\n+\n+    private synchronized void onSseStreamClosed(@Nullable Throwable exception) {\n+        if (exception != null && AuthorizationFailedRetryStrategy.JETTY_401_HEADER_BODY_MISMATCH_EXCEPTION_MESSAGE\n+                .equals(exception.getMessage())) {\n+            onConnectionError(ConnectionError.AUTHORIZATION_FAILED);\n+        } else if (exception instanceof TimeoutException) {\n+            onConnectionError(ConnectionError.TIMEOUT);\n+        } else {\n+            onConnectionError(ConnectionError.SSE_STREAM_ENDED);\n+        }\n+    }\n+\n+    private synchronized void onConnectionComplete(@Nullable Result result) {\n+        sseRequest = null;\n+\n+        if (result == null) {\n+            logger.warn(\"SSE stream was closed but there was no result delivered.\");\n+            onConnectionError(ConnectionError.SSE_STREAM_ENDED);\n+            return;\n+        }\n+\n+        Response response = result.getResponse();\n+        if (response == null) {\n+            logger.warn(\"SSE stream was closed without response.\");\n+            onConnectionError(ConnectionError.SSE_STREAM_ENDED);\n+            return;\n+        }\n+\n+        onConnectionClosed(response);\n+    }\n+\n+    private void onConnectionClosed(Response response) {\n+        try {\n+            HttpUtil.checkHttpSuccess(response);\n+            onConnectionError(ConnectionError.SSE_STREAM_ENDED);\n+        } catch (AuthorizationFailedException e) {\n+            onConnectionError(ConnectionError.AUTHORIZATION_FAILED);\n+        } catch (TooManyRequestsException e) {\n+            long secondsUntilRetry = e.getSecondsUntilRetry();\n+            if (secondsUntilRetry < 0) {\n+                onConnectionError(ConnectionError.TOO_MANY_RERQUESTS);\n+            } else {\n+                onConnectionError(ConnectionError.TOO_MANY_RERQUESTS, secondsUntilRetry);\n+            }\n+        } catch (MieleWebserviceTransientException e) {\n+            onConnectionError(e.getConnectionError(), 0);\n+        } catch (MieleWebserviceException e) {\n+            onConnectionError(e.getConnectionError());\n+        }\n+    }\n+\n+    private void onConnectionError(ConnectionError connectionError) {\n+        onConnectionError(connectionError, backoffStrategy.getSecondsUntilRetry(failedConnectionAttempts));\n+    }\n+\n+    private synchronized void onConnectionError(ConnectionError connectionError, long secondsUntilRetry) {\n+        if (!active) {\n+            return;\n+        }\n+\n+        if (connectionError != ConnectionError.AUTHORIZATION_FAILED) {\n+            scheduleReconnect(secondsUntilRetry);\n+        }\n+\n+        fireConnectionError(connectionError);\n+        failedConnectionAttempts++;\n+    }\n+\n+    private void scheduleReconnect(long secondsUntilRetry) {\n+        long retryInSeconds = Math.max(MINIMUM_RECONNECT_ATTEMPT_WAIT_TIME_IN_SECONDS, secondsUntilRetry);\n+        scheduler.schedule(this::connectInternal, retryInSeconds, TimeUnit.SECONDS);\n+        logger.info(\"Scheduled reconnect attempt for Miele webservice to take place in {} seconds\", retryInSeconds);", "originalCommit": "e5c8232f49175447ecf3f61cf135f66f327e79dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkzMzM3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r547933376", "bodyText": "Should be debug level", "author": "mhilbush", "createdAt": "2020-12-23T12:24:03Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/webservice/sse/SseConnection.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.webservice.sse;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Response;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.InputStreamResponseListener;\n+import org.openhab.binding.mielecloud.internal.webservice.ConnectionError;\n+import org.openhab.binding.mielecloud.internal.webservice.HttpUtil;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.AuthorizationFailedException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceDisconnectSseException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceTransientException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.TooManyRequestsException;\n+import org.openhab.binding.mielecloud.internal.webservice.retry.AuthorizationFailedRetryStrategy;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An active or inactive SSE connection emitting a stream of events.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial Contribution\n+ */\n+@NonNullByDefault\n+public final class SseConnection {\n+    private static final long CONNECTION_TIMEOUT = 30;\n+    private static final TimeUnit CONNECTION_TIMEOUT_UNIT = TimeUnit.SECONDS;\n+\n+    private static final long MINIMUM_RECONNECT_ATTEMPT_WAIT_TIME_IN_SECONDS = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(SseConnection.class);\n+\n+    private final String endpoint;\n+    private final SseRequestFactory requestFactory;\n+    private final ScheduledExecutorService scheduler;\n+    private final BackoffStrategy backoffStrategy;\n+\n+    private final List<SseListener> listeners = new ArrayList<>();\n+\n+    private boolean active = false;\n+\n+    private int failedConnectionAttempts = 0;\n+\n+    @Nullable\n+    private Request sseRequest;\n+\n+    /**\n+     * Creates a new {@link SseConnection} to the given endpoint.\n+     *\n+     * Note: It is required to call {@link #connect()} in order to open the connection and start receiving events.\n+     *\n+     * @param endpoint The endpoint to connect to.\n+     * @param requestFactory Factory for creating requests.\n+     * @param scheduler Scheduler to run scheduled and concurrent tasks on.\n+     */\n+    public SseConnection(String endpoint, SseRequestFactory requestFactory, ScheduledExecutorService scheduler) {\n+        this(endpoint, requestFactory, scheduler, new ExponentialBackoffWithJitter());\n+    }\n+\n+    /**\n+     * Creates a new {@link SseConnection} to the given endpoint.\n+     *\n+     * Note: It is required to call {@link #connect()} in order to open the connection and start receiving events.\n+     *\n+     * @param endpoint The endpoint to connect to.\n+     * @param requestFactory Factory for creating requests.\n+     * @param scheduler Scheduler to run scheduled and concurrent tasks on.\n+     * @param backoffStrategy Strategy for deriving the wait time between connection attempts.\n+     */\n+    SseConnection(String endpoint, SseRequestFactory requestFactory, ScheduledExecutorService scheduler,\n+            BackoffStrategy backoffStrategy) {\n+        this.endpoint = endpoint;\n+        this.requestFactory = requestFactory;\n+        this.scheduler = scheduler;\n+        this.backoffStrategy = backoffStrategy;\n+    }\n+\n+    public synchronized void connect() {\n+        active = true;\n+        connectInternal();\n+    }\n+\n+    private synchronized void connectInternal() {\n+        if (!active) {\n+            return;\n+        }\n+\n+        Request runningRequest = this.sseRequest;\n+        if (runningRequest != null) {\n+            return;\n+        }\n+\n+        logger.info(\"Opening SSE connection...\");\n+        Request sseRequest = createRequest();\n+        if (sseRequest == null) {\n+            logger.warn(\"Could not create SSE request, not opening SSE connection.\");\n+            return;\n+        }\n+\n+        final InputStreamResponseListener stream = new InputStreamResponseListener();\n+        SseStreamParser eventStreamParser = new SseStreamParser(stream.getInputStream(), this::onServerSentEvent,\n+                this::onSseStreamClosed);\n+\n+        sseRequest = sseRequest\n+                .onResponseHeaders(\n+                        response -> scheduler.schedule(eventStreamParser::parseAndDispatchEvents, 0, TimeUnit.SECONDS))\n+                .onComplete(result -> onConnectionComplete(result));\n+        sseRequest.send(stream);\n+        this.sseRequest = sseRequest;\n+    }\n+\n+    @Nullable\n+    private Request createRequest() {\n+        Request sseRequest = requestFactory.createSseRequest(endpoint);\n+        if (sseRequest == null) {\n+            return null;\n+        }\n+\n+        return sseRequest.timeout(0, TimeUnit.SECONDS).idleTimeout(CONNECTION_TIMEOUT, CONNECTION_TIMEOUT_UNIT);\n+    }\n+\n+    private synchronized void onSseStreamClosed(@Nullable Throwable exception) {\n+        if (exception != null && AuthorizationFailedRetryStrategy.JETTY_401_HEADER_BODY_MISMATCH_EXCEPTION_MESSAGE\n+                .equals(exception.getMessage())) {\n+            onConnectionError(ConnectionError.AUTHORIZATION_FAILED);\n+        } else if (exception instanceof TimeoutException) {\n+            onConnectionError(ConnectionError.TIMEOUT);\n+        } else {\n+            onConnectionError(ConnectionError.SSE_STREAM_ENDED);\n+        }\n+    }\n+\n+    private synchronized void onConnectionComplete(@Nullable Result result) {\n+        sseRequest = null;\n+\n+        if (result == null) {\n+            logger.warn(\"SSE stream was closed but there was no result delivered.\");\n+            onConnectionError(ConnectionError.SSE_STREAM_ENDED);\n+            return;\n+        }\n+\n+        Response response = result.getResponse();\n+        if (response == null) {\n+            logger.warn(\"SSE stream was closed without response.\");\n+            onConnectionError(ConnectionError.SSE_STREAM_ENDED);\n+            return;\n+        }\n+\n+        onConnectionClosed(response);\n+    }\n+\n+    private void onConnectionClosed(Response response) {\n+        try {\n+            HttpUtil.checkHttpSuccess(response);\n+            onConnectionError(ConnectionError.SSE_STREAM_ENDED);\n+        } catch (AuthorizationFailedException e) {\n+            onConnectionError(ConnectionError.AUTHORIZATION_FAILED);\n+        } catch (TooManyRequestsException e) {\n+            long secondsUntilRetry = e.getSecondsUntilRetry();\n+            if (secondsUntilRetry < 0) {\n+                onConnectionError(ConnectionError.TOO_MANY_RERQUESTS);\n+            } else {\n+                onConnectionError(ConnectionError.TOO_MANY_RERQUESTS, secondsUntilRetry);\n+            }\n+        } catch (MieleWebserviceTransientException e) {\n+            onConnectionError(e.getConnectionError(), 0);\n+        } catch (MieleWebserviceException e) {\n+            onConnectionError(e.getConnectionError());\n+        }\n+    }\n+\n+    private void onConnectionError(ConnectionError connectionError) {\n+        onConnectionError(connectionError, backoffStrategy.getSecondsUntilRetry(failedConnectionAttempts));\n+    }\n+\n+    private synchronized void onConnectionError(ConnectionError connectionError, long secondsUntilRetry) {\n+        if (!active) {\n+            return;\n+        }\n+\n+        if (connectionError != ConnectionError.AUTHORIZATION_FAILED) {\n+            scheduleReconnect(secondsUntilRetry);\n+        }\n+\n+        fireConnectionError(connectionError);\n+        failedConnectionAttempts++;\n+    }\n+\n+    private void scheduleReconnect(long secondsUntilRetry) {\n+        long retryInSeconds = Math.max(MINIMUM_RECONNECT_ATTEMPT_WAIT_TIME_IN_SECONDS, secondsUntilRetry);\n+        scheduler.schedule(this::connectInternal, retryInSeconds, TimeUnit.SECONDS);\n+        logger.info(\"Scheduled reconnect attempt for Miele webservice to take place in {} seconds\", retryInSeconds);\n+    }\n+\n+    public synchronized void disconnect() {\n+        active = false;\n+\n+        Request runningRequest = sseRequest;\n+        if (runningRequest == null) {\n+            logger.info(\"SSE connection is not established, skipping SSE disconnect.\");\n+            return;\n+        }\n+\n+        logger.info(\"Disconnecting SSE\");", "originalCommit": "e5c8232f49175447ecf3f61cf135f66f327e79dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkzMzQzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r547933431", "bodyText": "Should be debug level", "author": "mhilbush", "createdAt": "2020-12-23T12:24:12Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/webservice/sse/SseConnection.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.webservice.sse;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Response;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.InputStreamResponseListener;\n+import org.openhab.binding.mielecloud.internal.webservice.ConnectionError;\n+import org.openhab.binding.mielecloud.internal.webservice.HttpUtil;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.AuthorizationFailedException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceDisconnectSseException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceTransientException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.TooManyRequestsException;\n+import org.openhab.binding.mielecloud.internal.webservice.retry.AuthorizationFailedRetryStrategy;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An active or inactive SSE connection emitting a stream of events.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial Contribution\n+ */\n+@NonNullByDefault\n+public final class SseConnection {\n+    private static final long CONNECTION_TIMEOUT = 30;\n+    private static final TimeUnit CONNECTION_TIMEOUT_UNIT = TimeUnit.SECONDS;\n+\n+    private static final long MINIMUM_RECONNECT_ATTEMPT_WAIT_TIME_IN_SECONDS = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(SseConnection.class);\n+\n+    private final String endpoint;\n+    private final SseRequestFactory requestFactory;\n+    private final ScheduledExecutorService scheduler;\n+    private final BackoffStrategy backoffStrategy;\n+\n+    private final List<SseListener> listeners = new ArrayList<>();\n+\n+    private boolean active = false;\n+\n+    private int failedConnectionAttempts = 0;\n+\n+    @Nullable\n+    private Request sseRequest;\n+\n+    /**\n+     * Creates a new {@link SseConnection} to the given endpoint.\n+     *\n+     * Note: It is required to call {@link #connect()} in order to open the connection and start receiving events.\n+     *\n+     * @param endpoint The endpoint to connect to.\n+     * @param requestFactory Factory for creating requests.\n+     * @param scheduler Scheduler to run scheduled and concurrent tasks on.\n+     */\n+    public SseConnection(String endpoint, SseRequestFactory requestFactory, ScheduledExecutorService scheduler) {\n+        this(endpoint, requestFactory, scheduler, new ExponentialBackoffWithJitter());\n+    }\n+\n+    /**\n+     * Creates a new {@link SseConnection} to the given endpoint.\n+     *\n+     * Note: It is required to call {@link #connect()} in order to open the connection and start receiving events.\n+     *\n+     * @param endpoint The endpoint to connect to.\n+     * @param requestFactory Factory for creating requests.\n+     * @param scheduler Scheduler to run scheduled and concurrent tasks on.\n+     * @param backoffStrategy Strategy for deriving the wait time between connection attempts.\n+     */\n+    SseConnection(String endpoint, SseRequestFactory requestFactory, ScheduledExecutorService scheduler,\n+            BackoffStrategy backoffStrategy) {\n+        this.endpoint = endpoint;\n+        this.requestFactory = requestFactory;\n+        this.scheduler = scheduler;\n+        this.backoffStrategy = backoffStrategy;\n+    }\n+\n+    public synchronized void connect() {\n+        active = true;\n+        connectInternal();\n+    }\n+\n+    private synchronized void connectInternal() {\n+        if (!active) {\n+            return;\n+        }\n+\n+        Request runningRequest = this.sseRequest;\n+        if (runningRequest != null) {\n+            return;\n+        }\n+\n+        logger.info(\"Opening SSE connection...\");\n+        Request sseRequest = createRequest();\n+        if (sseRequest == null) {\n+            logger.warn(\"Could not create SSE request, not opening SSE connection.\");\n+            return;\n+        }\n+\n+        final InputStreamResponseListener stream = new InputStreamResponseListener();\n+        SseStreamParser eventStreamParser = new SseStreamParser(stream.getInputStream(), this::onServerSentEvent,\n+                this::onSseStreamClosed);\n+\n+        sseRequest = sseRequest\n+                .onResponseHeaders(\n+                        response -> scheduler.schedule(eventStreamParser::parseAndDispatchEvents, 0, TimeUnit.SECONDS))\n+                .onComplete(result -> onConnectionComplete(result));\n+        sseRequest.send(stream);\n+        this.sseRequest = sseRequest;\n+    }\n+\n+    @Nullable\n+    private Request createRequest() {\n+        Request sseRequest = requestFactory.createSseRequest(endpoint);\n+        if (sseRequest == null) {\n+            return null;\n+        }\n+\n+        return sseRequest.timeout(0, TimeUnit.SECONDS).idleTimeout(CONNECTION_TIMEOUT, CONNECTION_TIMEOUT_UNIT);\n+    }\n+\n+    private synchronized void onSseStreamClosed(@Nullable Throwable exception) {\n+        if (exception != null && AuthorizationFailedRetryStrategy.JETTY_401_HEADER_BODY_MISMATCH_EXCEPTION_MESSAGE\n+                .equals(exception.getMessage())) {\n+            onConnectionError(ConnectionError.AUTHORIZATION_FAILED);\n+        } else if (exception instanceof TimeoutException) {\n+            onConnectionError(ConnectionError.TIMEOUT);\n+        } else {\n+            onConnectionError(ConnectionError.SSE_STREAM_ENDED);\n+        }\n+    }\n+\n+    private synchronized void onConnectionComplete(@Nullable Result result) {\n+        sseRequest = null;\n+\n+        if (result == null) {\n+            logger.warn(\"SSE stream was closed but there was no result delivered.\");\n+            onConnectionError(ConnectionError.SSE_STREAM_ENDED);\n+            return;\n+        }\n+\n+        Response response = result.getResponse();\n+        if (response == null) {\n+            logger.warn(\"SSE stream was closed without response.\");\n+            onConnectionError(ConnectionError.SSE_STREAM_ENDED);\n+            return;\n+        }\n+\n+        onConnectionClosed(response);\n+    }\n+\n+    private void onConnectionClosed(Response response) {\n+        try {\n+            HttpUtil.checkHttpSuccess(response);\n+            onConnectionError(ConnectionError.SSE_STREAM_ENDED);\n+        } catch (AuthorizationFailedException e) {\n+            onConnectionError(ConnectionError.AUTHORIZATION_FAILED);\n+        } catch (TooManyRequestsException e) {\n+            long secondsUntilRetry = e.getSecondsUntilRetry();\n+            if (secondsUntilRetry < 0) {\n+                onConnectionError(ConnectionError.TOO_MANY_RERQUESTS);\n+            } else {\n+                onConnectionError(ConnectionError.TOO_MANY_RERQUESTS, secondsUntilRetry);\n+            }\n+        } catch (MieleWebserviceTransientException e) {\n+            onConnectionError(e.getConnectionError(), 0);\n+        } catch (MieleWebserviceException e) {\n+            onConnectionError(e.getConnectionError());\n+        }\n+    }\n+\n+    private void onConnectionError(ConnectionError connectionError) {\n+        onConnectionError(connectionError, backoffStrategy.getSecondsUntilRetry(failedConnectionAttempts));\n+    }\n+\n+    private synchronized void onConnectionError(ConnectionError connectionError, long secondsUntilRetry) {\n+        if (!active) {\n+            return;\n+        }\n+\n+        if (connectionError != ConnectionError.AUTHORIZATION_FAILED) {\n+            scheduleReconnect(secondsUntilRetry);\n+        }\n+\n+        fireConnectionError(connectionError);\n+        failedConnectionAttempts++;\n+    }\n+\n+    private void scheduleReconnect(long secondsUntilRetry) {\n+        long retryInSeconds = Math.max(MINIMUM_RECONNECT_ATTEMPT_WAIT_TIME_IN_SECONDS, secondsUntilRetry);\n+        scheduler.schedule(this::connectInternal, retryInSeconds, TimeUnit.SECONDS);\n+        logger.info(\"Scheduled reconnect attempt for Miele webservice to take place in {} seconds\", retryInSeconds);\n+    }\n+\n+    public synchronized void disconnect() {\n+        active = false;\n+\n+        Request runningRequest = sseRequest;\n+        if (runningRequest == null) {\n+            logger.info(\"SSE connection is not established, skipping SSE disconnect.\");\n+            return;\n+        }\n+\n+        logger.info(\"Disconnecting SSE\");\n+        runningRequest.abort(new MieleWebserviceDisconnectSseException());\n+        sseRequest = null;\n+        logger.info(\"Disconnected\");", "originalCommit": "e5c8232f49175447ecf3f61cf135f66f327e79dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkzMzU5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r547933599", "bodyText": "Should be debug level", "author": "mhilbush", "createdAt": "2020-12-23T12:24:38Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/webservice/sse/SseStreamParser.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.webservice.sse;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceDisconnectSseException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Parses events from the SSE event stream and emits them via the given dispatcher.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial Contribution\n+ */\n+@NonNullByDefault\n+class SseStreamParser {\n+    private static final String SSE_KEY_EVENT = \"event:\";\n+    private static final String SSE_KEY_DATA = \"data:\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SseStreamParser.class);\n+\n+    private final BufferedReader reader;\n+    private final Consumer<ServerSentEvent> onServerSentEventCallback;\n+    private final Consumer<@Nullable Throwable> onStreamClosedCallback;\n+\n+    @Nullable\n+    private String event;\n+\n+    SseStreamParser(InputStream inputStream, Consumer<ServerSentEvent> onServerSentEventCallback,\n+            Consumer<@Nullable Throwable> onStreamClosedCallback) {\n+        this.reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));\n+        this.onServerSentEventCallback = onServerSentEventCallback;\n+        this.onStreamClosedCallback = onStreamClosedCallback;\n+    }\n+\n+    void parseAndDispatchEvents() {\n+        try {\n+            String line = null;\n+            while ((line = reader.readLine()) != null) {\n+                onLineReceived(line);\n+            }\n+\n+            silentlyCloseReader();\n+            logger.info(\"SSE stream ended. Closing stream.\");", "originalCommit": "e5c8232f49175447ecf3f61cf135f66f327e79dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkzMzY2OA==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r547933668", "bodyText": "Should be debug level", "author": "mhilbush", "createdAt": "2020-12-23T12:24:49Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/webservice/sse/SseStreamParser.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.webservice.sse;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceDisconnectSseException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Parses events from the SSE event stream and emits them via the given dispatcher.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial Contribution\n+ */\n+@NonNullByDefault\n+class SseStreamParser {\n+    private static final String SSE_KEY_EVENT = \"event:\";\n+    private static final String SSE_KEY_DATA = \"data:\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SseStreamParser.class);\n+\n+    private final BufferedReader reader;\n+    private final Consumer<ServerSentEvent> onServerSentEventCallback;\n+    private final Consumer<@Nullable Throwable> onStreamClosedCallback;\n+\n+    @Nullable\n+    private String event;\n+\n+    SseStreamParser(InputStream inputStream, Consumer<ServerSentEvent> onServerSentEventCallback,\n+            Consumer<@Nullable Throwable> onStreamClosedCallback) {\n+        this.reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));\n+        this.onServerSentEventCallback = onServerSentEventCallback;\n+        this.onStreamClosedCallback = onStreamClosedCallback;\n+    }\n+\n+    void parseAndDispatchEvents() {\n+        try {\n+            String line = null;\n+            while ((line = reader.readLine()) != null) {\n+                onLineReceived(line);\n+            }\n+\n+            silentlyCloseReader();\n+            logger.info(\"SSE stream ended. Closing stream.\");\n+            onStreamClosedCallback.accept(null);\n+        } catch (IOException exception) {\n+            silentlyCloseReader();\n+\n+            if (!(exception.getCause() instanceof MieleWebserviceDisconnectSseException)) {\n+                logger.warn(\"SSE connection failed unexpectedly: {}\", exception.getMessage());\n+                onStreamClosedCallback.accept(exception.getCause());\n+            }\n+        }\n+        logger.info(\"SSE stream closed.\");", "originalCommit": "e5c8232f49175447ecf3f61cf135f66f327e79dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ff76f6501027701605f749dbc7890dd43083915a", "url": "https://github.com/openhab/openhab-addons/commit/ff76f6501027701605f749dbc7890dd43083915a", "message": "Add test for Retry-After header exceeding maximum SSE reconnect wait time\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-02-03T07:08:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU1MjYwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r571552605", "bodyText": "You need to update the dates of all of your copyright headers.", "author": "cpmeister", "createdAt": "2021-02-07T06:08:49Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/webservice/exception/TooManyRequestsException.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project", "originalCommit": "3144c8aac31f48ff8661aa1a9e928a3d017499e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU1NjExMg==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r571556112", "bodyText": "Because there is a lot of code getting called here, you should make sure that it isn't done unnecessarily.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"Send {} request to Miele webservice on uri {}\",\n          \n          \n            \n                                Optional.ofNullable(request).map(Request::getMethod).orElse(\"null\"),\n          \n          \n            \n                                Optional.ofNullable(request).map(Request::getURI).map(URI::toString).orElse(\"null\"));\n          \n          \n            \n                        if(logger.isDebugEnabled()){\n          \n          \n            \n                            logger.debug(\"Send {} request to Miele webservice on uri {}\",\n          \n          \n            \n                                Optional.ofNullable(request).map(Request::getMethod).orElse(\"null\"),\n          \n          \n            \n                                Optional.ofNullable(request).map(Request::getURI).map(URI::toString).orElse(\"null\"));\n          \n          \n            \n                        }", "author": "cpmeister", "createdAt": "2021-02-07T06:19:35Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/webservice/DefaultMieleWebservice.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.webservice;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.openhab.binding.mielecloud.internal.webservice.api.json.Actions;\n+import org.openhab.binding.mielecloud.internal.webservice.api.json.DeviceCollection;\n+import org.openhab.binding.mielecloud.internal.webservice.api.json.Light;\n+import org.openhab.binding.mielecloud.internal.webservice.api.json.MieleSyntaxException;\n+import org.openhab.binding.mielecloud.internal.webservice.api.json.ProcessAction;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.AuthorizationFailedException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceInitializationException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceTransientException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.TooManyRequestsException;\n+import org.openhab.binding.mielecloud.internal.webservice.request.RequestFactory;\n+import org.openhab.binding.mielecloud.internal.webservice.request.RequestFactoryImpl;\n+import org.openhab.binding.mielecloud.internal.webservice.retry.AuthorizationFailedRetryStrategy;\n+import org.openhab.binding.mielecloud.internal.webservice.retry.NTimesRetryStrategy;\n+import org.openhab.binding.mielecloud.internal.webservice.retry.RetryStrategy;\n+import org.openhab.binding.mielecloud.internal.webservice.retry.RetryStrategyCombiner;\n+import org.openhab.binding.mielecloud.internal.webservice.sse.ServerSentEvent;\n+import org.openhab.binding.mielecloud.internal.webservice.sse.SseConnection;\n+import org.openhab.binding.mielecloud.internal.webservice.sse.SseListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * Default implementation of the {@link MieleWebservice}.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial contribution\n+ */\n+@NonNullByDefault\n+public final class DefaultMieleWebservice implements MieleWebservice, SseListener {\n+    private static final String SERVER_ADDRESS = \"https://api.mcs3.miele.com\";\n+    public static final String THIRD_PARTY_ENDPOINTS_BASENAME = SERVER_ADDRESS + \"/thirdparty\";\n+    private static final String ENDPOINT_DEVICES = SERVER_ADDRESS + \"/v1/devices/\";\n+    private static final String ENDPOINT_ACTIONS = ENDPOINT_DEVICES + \"%s\" + \"/actions\";\n+    private static final String ENDPOINT_LOGOUT = THIRD_PARTY_ENDPOINTS_BASENAME + \"/logout\";\n+    private static final String ENDPOINT_ALL_SSE_EVENTS = ENDPOINT_DEVICES + \"all/events\";\n+\n+    private static final String SSE_EVENT_TYPE_DEVICES = \"devices\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(DefaultMieleWebservice.class);\n+\n+    private Optional<String> accessToken = Optional.empty();\n+    private final RequestFactory requestFactory;\n+\n+    private final DeviceStateDispatcher deviceStateDispatcher;\n+    private final List<ConnectionStatusListener> connectionStatusListeners = new ArrayList<>();\n+\n+    private final RetryStrategy retryStrategy;\n+\n+    private final SseConnection sseConnection;\n+\n+    /**\n+     * Creates a new {@link DefaultMieleWebservice} with default retry configuration which is to retry failed operations\n+     * once on a transient error. In case an authorization error occurs, a new access token is requested and a retry of\n+     * the failed request is executed.\n+     *\n+     * @param configuration The configuration holding all parameters for constructing the instance.\n+     * @throws MieleWebserviceInitializationException if initializing the HTTP client fails.\n+     */\n+    public DefaultMieleWebservice(MieleWebserviceConfiguration configuration) {\n+        this(new RequestFactoryImpl(configuration.getHttpClientFactory(), configuration.getLanguageProvider()),\n+                new RetryStrategyCombiner(new NTimesRetryStrategy(1),\n+                        new AuthorizationFailedRetryStrategy(configuration.getTokenRefresher(),\n+                                configuration.getServiceHandle())),\n+                new DeviceStateDispatcher(), configuration.getScheduler());\n+    }\n+\n+    /**\n+     * This constructor only exists for testing.\n+     */\n+    DefaultMieleWebservice(RequestFactory requestFactory, RetryStrategy retryStrategy,\n+            DeviceStateDispatcher deviceStateDispatcher, ScheduledExecutorService scheduler) {\n+        this.requestFactory = requestFactory;\n+        this.retryStrategy = retryStrategy;\n+        this.deviceStateDispatcher = deviceStateDispatcher;\n+        this.sseConnection = new SseConnection(ENDPOINT_ALL_SSE_EVENTS, this::createSseRequest, scheduler);\n+        this.sseConnection.addSseListener(this);\n+    }\n+\n+    @Override\n+    public void setAccessToken(String accessToken) {\n+        this.accessToken = Optional.of(accessToken);\n+    }\n+\n+    @Override\n+    public boolean hasAccessToken() {\n+        return accessToken.isPresent();\n+    }\n+\n+    @Override\n+    public synchronized void connectSse() {\n+        sseConnection.connect();\n+    }\n+\n+    @Override\n+    public synchronized void disconnectSse() {\n+        sseConnection.disconnect();\n+    }\n+\n+    @Nullable\n+    private Request createSseRequest(String endpoint) {\n+        Optional<String> accessToken = this.accessToken;\n+        if (!accessToken.isPresent()) {\n+            logger.warn(\"No access token present.\");\n+            return null;\n+        }\n+\n+        return requestFactory.createSseRequest(endpoint, accessToken.get());\n+    }\n+\n+    @Override\n+    public void onServerSentEvent(ServerSentEvent event) {\n+        fireConnectionAlive();\n+\n+        if (!SSE_EVENT_TYPE_DEVICES.equals(event.getEvent())) {\n+            return;\n+        }\n+\n+        try {\n+            deviceStateDispatcher.dispatchDeviceStateUpdates(DeviceCollection.fromJson(event.getData()));\n+        } catch (MieleSyntaxException e) {\n+            logger.warn(\"SSE payload is not valid Json: {}\", event.getData());\n+        }\n+    }\n+\n+    private void fireConnectionAlive() {\n+        connectionStatusListeners.forEach(ConnectionStatusListener::onConnectionAlive);\n+    }\n+\n+    @Override\n+    public void onConnectionError(ConnectionError connectionError, int failedReconnectAttempts) {\n+        connectionStatusListeners.forEach(l -> l.onConnectionError(connectionError, failedReconnectAttempts));\n+    }\n+\n+    @Override\n+    public void fetchActions(String deviceId) {\n+        Actions actions = retryStrategy.performRetryableOperation(() -> getActions(deviceId),\n+                e -> logger.warn(\"Cannot poll action state: {}. Retrying...\", e.getMessage()));\n+        if (actions != null) {\n+            deviceStateDispatcher.dispatchActionStateUpdates(deviceId, actions);\n+        } else {\n+            logger.warn(\"Cannot poll action state. Response is missing actions.\");\n+        }\n+    }\n+\n+    @Override\n+    public void putProcessAction(String deviceId, ProcessAction processAction) {\n+        if (processAction.equals(ProcessAction.UNKNOWN)) {\n+            throw new IllegalArgumentException(\"Process action must not be UNKNOWN.\");\n+        }\n+\n+        String formattedProcessAction = new Gson().toJson(processAction, ProcessAction.class);\n+        formattedProcessAction = formattedProcessAction.substring(1, formattedProcessAction.length() - 1);\n+        String json = \"{\\\"processAction\\\":\" + formattedProcessAction + \"}\";\n+\n+        logger.debug(\"Activate process action {} of Miele device {}\", processAction.toString(), deviceId);\n+        putActions(deviceId, json);\n+    }\n+\n+    @Override\n+    public void putLight(String deviceId, boolean enabled) {\n+        Light light = enabled ? Light.ENABLE : Light.DISABLE;\n+        String json = \"{\\\"light\\\":\" + light.format() + \"}\";\n+\n+        logger.debug(\"Set light of Miele device {} to {}\", deviceId, enabled);\n+        putActions(deviceId, json);\n+    }\n+\n+    @Override\n+    public void putPowerState(String deviceId, boolean enabled) {\n+        String action = enabled ? \"powerOn\" : \"powerOff\";\n+        String json = \"{\\\"\" + action + \"\\\":true}\";\n+\n+        logger.debug(\"Set power state of Miele device {} to {}\", deviceId, action);\n+        putActions(deviceId, json);\n+    }\n+\n+    @Override\n+    public void putProgram(String deviceId, long programId) {\n+        String json = \"{\\\"programId\\\":\" + programId + \"}\";\n+\n+        logger.debug(\"Activate program with ID {} of Miele device {}\", programId, deviceId);\n+        putActions(deviceId, json);\n+    }\n+\n+    @Override\n+    public void logout() {\n+        Optional<String> accessToken = this.accessToken;\n+        if (!accessToken.isPresent()) {\n+            logger.debug(\"No access token present.\");\n+            return;\n+        }\n+\n+        try {\n+            logger.debug(\"Invalidating Miele webservice access token.\");\n+            Request request = requestFactory.createPostRequest(ENDPOINT_LOGOUT, accessToken.get());\n+            this.accessToken = Optional.empty();\n+            sendRequest(request);\n+        } catch (MieleWebserviceTransientException e) {\n+            throw new MieleWebserviceException(\"Transient error occurred during logout.\", e, e.getConnectionError());\n+        }\n+    }\n+\n+    /**\n+     * Sends the given request and wraps the possible exceptions in Miele exception types.\n+     *\n+     * @param request The {@link Request} to send.\n+     * @return The obtained {@link ContentResponse}.\n+     * @throws MieleWebserviceException if an irrecoverable error occurred.\n+     * @throws MieleWebserviceTransientException if a recoverable error occurred.\n+     */\n+    private ContentResponse sendRequest(Request request) {\n+        try {\n+            logger.debug(\"Send {} request to Miele webservice on uri {}\",\n+                    Optional.ofNullable(request).map(Request::getMethod).orElse(\"null\"),\n+                    Optional.ofNullable(request).map(Request::getURI).map(URI::toString).orElse(\"null\"));", "originalCommit": "3144c8aac31f48ff8661aa1a9e928a3d017499e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU1NzA3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r571557075", "bodyText": "Please reuse your Gson instances, preferably as a static final constant.", "author": "cpmeister", "createdAt": "2021-02-07T06:20:19Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/webservice/DefaultMieleWebservice.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.webservice;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.openhab.binding.mielecloud.internal.webservice.api.json.Actions;\n+import org.openhab.binding.mielecloud.internal.webservice.api.json.DeviceCollection;\n+import org.openhab.binding.mielecloud.internal.webservice.api.json.Light;\n+import org.openhab.binding.mielecloud.internal.webservice.api.json.MieleSyntaxException;\n+import org.openhab.binding.mielecloud.internal.webservice.api.json.ProcessAction;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.AuthorizationFailedException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceInitializationException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceTransientException;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.TooManyRequestsException;\n+import org.openhab.binding.mielecloud.internal.webservice.request.RequestFactory;\n+import org.openhab.binding.mielecloud.internal.webservice.request.RequestFactoryImpl;\n+import org.openhab.binding.mielecloud.internal.webservice.retry.AuthorizationFailedRetryStrategy;\n+import org.openhab.binding.mielecloud.internal.webservice.retry.NTimesRetryStrategy;\n+import org.openhab.binding.mielecloud.internal.webservice.retry.RetryStrategy;\n+import org.openhab.binding.mielecloud.internal.webservice.retry.RetryStrategyCombiner;\n+import org.openhab.binding.mielecloud.internal.webservice.sse.ServerSentEvent;\n+import org.openhab.binding.mielecloud.internal.webservice.sse.SseConnection;\n+import org.openhab.binding.mielecloud.internal.webservice.sse.SseListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * Default implementation of the {@link MieleWebservice}.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial contribution\n+ */\n+@NonNullByDefault\n+public final class DefaultMieleWebservice implements MieleWebservice, SseListener {\n+    private static final String SERVER_ADDRESS = \"https://api.mcs3.miele.com\";\n+    public static final String THIRD_PARTY_ENDPOINTS_BASENAME = SERVER_ADDRESS + \"/thirdparty\";\n+    private static final String ENDPOINT_DEVICES = SERVER_ADDRESS + \"/v1/devices/\";\n+    private static final String ENDPOINT_ACTIONS = ENDPOINT_DEVICES + \"%s\" + \"/actions\";\n+    private static final String ENDPOINT_LOGOUT = THIRD_PARTY_ENDPOINTS_BASENAME + \"/logout\";\n+    private static final String ENDPOINT_ALL_SSE_EVENTS = ENDPOINT_DEVICES + \"all/events\";\n+\n+    private static final String SSE_EVENT_TYPE_DEVICES = \"devices\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(DefaultMieleWebservice.class);\n+\n+    private Optional<String> accessToken = Optional.empty();\n+    private final RequestFactory requestFactory;\n+\n+    private final DeviceStateDispatcher deviceStateDispatcher;\n+    private final List<ConnectionStatusListener> connectionStatusListeners = new ArrayList<>();\n+\n+    private final RetryStrategy retryStrategy;\n+\n+    private final SseConnection sseConnection;\n+\n+    /**\n+     * Creates a new {@link DefaultMieleWebservice} with default retry configuration which is to retry failed operations\n+     * once on a transient error. In case an authorization error occurs, a new access token is requested and a retry of\n+     * the failed request is executed.\n+     *\n+     * @param configuration The configuration holding all parameters for constructing the instance.\n+     * @throws MieleWebserviceInitializationException if initializing the HTTP client fails.\n+     */\n+    public DefaultMieleWebservice(MieleWebserviceConfiguration configuration) {\n+        this(new RequestFactoryImpl(configuration.getHttpClientFactory(), configuration.getLanguageProvider()),\n+                new RetryStrategyCombiner(new NTimesRetryStrategy(1),\n+                        new AuthorizationFailedRetryStrategy(configuration.getTokenRefresher(),\n+                                configuration.getServiceHandle())),\n+                new DeviceStateDispatcher(), configuration.getScheduler());\n+    }\n+\n+    /**\n+     * This constructor only exists for testing.\n+     */\n+    DefaultMieleWebservice(RequestFactory requestFactory, RetryStrategy retryStrategy,\n+            DeviceStateDispatcher deviceStateDispatcher, ScheduledExecutorService scheduler) {\n+        this.requestFactory = requestFactory;\n+        this.retryStrategy = retryStrategy;\n+        this.deviceStateDispatcher = deviceStateDispatcher;\n+        this.sseConnection = new SseConnection(ENDPOINT_ALL_SSE_EVENTS, this::createSseRequest, scheduler);\n+        this.sseConnection.addSseListener(this);\n+    }\n+\n+    @Override\n+    public void setAccessToken(String accessToken) {\n+        this.accessToken = Optional.of(accessToken);\n+    }\n+\n+    @Override\n+    public boolean hasAccessToken() {\n+        return accessToken.isPresent();\n+    }\n+\n+    @Override\n+    public synchronized void connectSse() {\n+        sseConnection.connect();\n+    }\n+\n+    @Override\n+    public synchronized void disconnectSse() {\n+        sseConnection.disconnect();\n+    }\n+\n+    @Nullable\n+    private Request createSseRequest(String endpoint) {\n+        Optional<String> accessToken = this.accessToken;\n+        if (!accessToken.isPresent()) {\n+            logger.warn(\"No access token present.\");\n+            return null;\n+        }\n+\n+        return requestFactory.createSseRequest(endpoint, accessToken.get());\n+    }\n+\n+    @Override\n+    public void onServerSentEvent(ServerSentEvent event) {\n+        fireConnectionAlive();\n+\n+        if (!SSE_EVENT_TYPE_DEVICES.equals(event.getEvent())) {\n+            return;\n+        }\n+\n+        try {\n+            deviceStateDispatcher.dispatchDeviceStateUpdates(DeviceCollection.fromJson(event.getData()));\n+        } catch (MieleSyntaxException e) {\n+            logger.warn(\"SSE payload is not valid Json: {}\", event.getData());\n+        }\n+    }\n+\n+    private void fireConnectionAlive() {\n+        connectionStatusListeners.forEach(ConnectionStatusListener::onConnectionAlive);\n+    }\n+\n+    @Override\n+    public void onConnectionError(ConnectionError connectionError, int failedReconnectAttempts) {\n+        connectionStatusListeners.forEach(l -> l.onConnectionError(connectionError, failedReconnectAttempts));\n+    }\n+\n+    @Override\n+    public void fetchActions(String deviceId) {\n+        Actions actions = retryStrategy.performRetryableOperation(() -> getActions(deviceId),\n+                e -> logger.warn(\"Cannot poll action state: {}. Retrying...\", e.getMessage()));\n+        if (actions != null) {\n+            deviceStateDispatcher.dispatchActionStateUpdates(deviceId, actions);\n+        } else {\n+            logger.warn(\"Cannot poll action state. Response is missing actions.\");\n+        }\n+    }\n+\n+    @Override\n+    public void putProcessAction(String deviceId, ProcessAction processAction) {\n+        if (processAction.equals(ProcessAction.UNKNOWN)) {\n+            throw new IllegalArgumentException(\"Process action must not be UNKNOWN.\");\n+        }\n+\n+        String formattedProcessAction = new Gson().toJson(processAction, ProcessAction.class);", "originalCommit": "3144c8aac31f48ff8661aa1a9e928a3d017499e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU2MDI2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r571560265", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private CompletableFuture<@Nullable Void> logoutFuture;\n          \n          \n            \n                @Nullable\n          \n          \n            \n                private MieleWebservice webService;\n          \n          \n            \n                @Nullable\n          \n          \n            \n                private ThingDiscoveryService discoveryService;\n          \n          \n            \n                private @Nullable CompletableFuture<@Nullable Void> logoutFuture;\n          \n          \n            \n                private @Nullable MieleWebservice webService;\n          \n          \n            \n                private @Nullable ThingDiscoveryService discoveryService;", "author": "cpmeister", "createdAt": "2021-02-07T06:32:53Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/handler/MieleBridgeHandler.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.handler;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants;\n+import org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants.I18NKeys;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthException;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthTokenRefreshListener;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthTokenRefresher;\n+import org.openhab.binding.mielecloud.internal.discovery.ThingDiscoveryService;\n+import org.openhab.binding.mielecloud.internal.util.LocaleValidator;\n+import org.openhab.binding.mielecloud.internal.webservice.ConnectionError;\n+import org.openhab.binding.mielecloud.internal.webservice.ConnectionStatusListener;\n+import org.openhab.binding.mielecloud.internal.webservice.DeviceStateListener;\n+import org.openhab.binding.mielecloud.internal.webservice.MieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.UnavailableMieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.api.ActionsState;\n+import org.openhab.binding.mielecloud.internal.webservice.api.DeviceState;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceInitializationException;\n+import org.openhab.binding.mielecloud.internal.webservice.language.CombiningLanguageProvider;\n+import org.openhab.binding.mielecloud.internal.webservice.language.LanguageProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * BridgeHandler implementation for the Miele cloud account.\n+ *\n+ * @author Roland Edelhoff - Initial contribution\n+ * @author Bj\u00f6rn Lange - Introduced CombiningLanguageProvider field and interactions, added LanguageProvider super\n+ *         interface, switched from polling to SSE, added support for multiple bridges\n+ */\n+@NonNullByDefault\n+public class MieleBridgeHandler extends BaseBridgeHandler\n+        implements OAuthTokenRefreshListener, LanguageProvider, ConnectionStatusListener, DeviceStateListener {\n+    private static final int NUMBER_OF_SSE_RECONNECTION_ATTEMPTS_BEFORE_STATUS_IS_UPDATED = 6;\n+\n+    private final Supplier<MieleWebservice> webserviceFactory;\n+\n+    private final OAuthTokenRefresher tokenRefresher;\n+    private final CombiningLanguageProvider languageProvider;\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+\n+    @Nullable\n+    private CompletableFuture<@Nullable Void> logoutFuture;\n+    @Nullable\n+    private MieleWebservice webService;\n+    @Nullable\n+    private ThingDiscoveryService discoveryService;", "originalCommit": "3144c8aac31f48ff8661aa1a9e928a3d017499e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU2MTI1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r571561253", "bodyText": "You already have a StringBuilder instance, so might as well use it.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    result.append(\"Thing \" + thing.getThingTypeUID().getId() + \" \" + thing.getUID().getId() + \" \");\n          \n          \n            \n                    result.append(\"Thing \").append(thing.getThingTypeUID().getId()).append(\" \").append(thing.getUID().getId()) .append(\" \");\n          \n      \n    \n    \n  \n\nThere are many other places in this file that could use a similar change.", "author": "cpmeister", "createdAt": "2021-02-07T06:43:19Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/config/ThingsTemplateGenerator.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.config;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+\n+/**\n+ * Generator for templates which can be copy-pasted into .things files by the user.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class ThingsTemplateGenerator {\n+    /**\n+     * Creates a template for the bridge.\n+     *\n+     * @param bridgeId Id of the bridge (last part of the thing UID).\n+     * @param locale Locale for accessing the Miele cloud service.\n+     * @return The template.\n+     */\n+    public String createBridgeConfigurationTemplate(String bridgeId, String locale) {\n+        return \"Bridge \" + MieleCloudBindingConstants.THING_TYPE_BRIDGE.getAsString() + \":\" + bridgeId + \" [ locale=\\\"\"\n+                + locale + \"\\\" ]\";\n+    }\n+\n+    /**\n+     * Creates a complete template containing the bridge and all paired devices.\n+     *\n+     * @param bridge The bridge which is used to pair the things.\n+     * @param pairedThings The paired things.\n+     * @param discoveryResults The discovery results which can be paired.\n+     * @return The template.\n+     */\n+    public String createBridgeAndThingConfigurationTemplate(Bridge bridge, List<Thing> pairedThings,\n+            List<DiscoveryResult> discoveryResults) {\n+        StringBuilder result = new StringBuilder();\n+        result.append(createBridgeConfigurationTemplate(bridge.getUID().getId(),\n+                bridge.getConfiguration().get(MieleCloudBindingConstants.CONFIG_PARAM_LOCALE).toString()));\n+        result.append(\" {\\n\");\n+\n+        for (Thing thing : pairedThings) {\n+            result.append(\"    \" + createThingConfigurationTemplate(thing) + \"\\n\");\n+        }\n+\n+        for (DiscoveryResult discoveryResult : discoveryResults) {\n+            result.append(\"    \" + createThingConfigurationTemplate(discoveryResult) + \"\\n\");\n+        }\n+\n+        result.append(\"}\");\n+        return result.toString();\n+    }\n+\n+    private String createThingConfigurationTemplate(Thing thing) {\n+        StringBuilder result = new StringBuilder();\n+        result.append(\"Thing \" + thing.getThingTypeUID().getId() + \" \" + thing.getUID().getId() + \" \");", "originalCommit": "3144c8aac31f48ff8661aa1a9e928a3d017499e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTk4MzI4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r575983286", "bodyText": "We prefer this style because it's easier to read than a chain of .appends and the performance impact is low because the code is only called when the user opens the configuration UI. However, this is opionionated so I changed it.", "author": "BjoernLange", "createdAt": "2021-02-15T07:21:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU2MTI1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU2MTQ0OA==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r571561448", "bodyText": "You should always include the cause exception.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new OAuthException(\n          \n          \n            \n                                \"Network error during token refresh or error while reading from persistent storage: \"\n          \n          \n            \n                                        + e.getMessage());\n          \n          \n            \n                        throw new OAuthException(\n          \n          \n            \n                                \"Network error during token refresh or error while reading from persistent storage: \"\n          \n          \n            \n                                        + e.getMessage(), e);", "author": "cpmeister", "createdAt": "2021-02-07T06:45:33Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/config/OAuthAuthorizationHandlerImpl.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.config;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthException;\n+import org.openhab.binding.mielecloud.internal.config.exception.NoOngoingAuthorizationException;\n+import org.openhab.binding.mielecloud.internal.config.exception.OngoingAuthorizationException;\n+import org.openhab.binding.mielecloud.internal.webservice.DefaultMieleWebservice;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.thing.ThingUID;\n+\n+/**\n+ * {@link OAuthAuthorizationHandler} implementation handling the OAuth 2 authorization via openHAB services.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial Contribution\n+ */\n+@NonNullByDefault\n+public final class OAuthAuthorizationHandlerImpl implements OAuthAuthorizationHandler {\n+    private static final String TOKEN_URL = DefaultMieleWebservice.THIRD_PARTY_ENDPOINTS_BASENAME + \"/token\";\n+    private static final String AUTHORIZATION_URL = DefaultMieleWebservice.THIRD_PARTY_ENDPOINTS_BASENAME + \"/login\";\n+\n+    private static final long AUTHORIZATION_TIMEOUT_IN_MINUTES = 5;\n+\n+    private final OAuthFactory oauthFactory;\n+    private final ScheduledExecutorService scheduler;\n+\n+    @Nullable\n+    private OAuthClientService oauthClientService;\n+    @Nullable\n+    private ThingUID bridgeUid;\n+    @Nullable\n+    private String redirectUri;\n+    @Nullable\n+    private ScheduledFuture<?> timer;\n+    @Nullable\n+    private LocalDateTime timerExpiryTimestamp;\n+\n+    /**\n+     * Creates a new {@link OAuthAuthorizationHandlerImpl}.\n+     *\n+     * @param oauthFactory Factory for accessing the {@link OAuthClientService}.\n+     * @param scheduler System-wide scheduler.\n+     */\n+    public OAuthAuthorizationHandlerImpl(OAuthFactory oauthFactory, ScheduledExecutorService scheduler) {\n+        this.oauthFactory = oauthFactory;\n+        this.scheduler = scheduler;\n+    }\n+\n+    @Override\n+    public synchronized void beginAuthorization(String clientId, String clientSecret, ThingUID bridgeUid) {\n+        if (this.oauthClientService != null) {\n+            throw new OngoingAuthorizationException(\"There is already an ongoing authorization!\", timerExpiryTimestamp);\n+        }\n+\n+        this.oauthClientService = oauthFactory.createOAuthClientService(bridgeUid.getAsString(), TOKEN_URL,\n+                AUTHORIZATION_URL, clientId, clientSecret, null, false);\n+        this.bridgeUid = bridgeUid;\n+        redirectUri = null;\n+        timer = null;\n+        timerExpiryTimestamp = null;\n+    }\n+\n+    @Override\n+    public synchronized String getAuthorizationUrl(String redirectUri) {\n+        final OAuthClientService oauthClientService = this.oauthClientService;\n+        if (oauthClientService == null) {\n+            throw new NoOngoingAuthorizationException(\"There is no ongoing authorization!\");\n+        }\n+\n+        this.redirectUri = redirectUri;\n+        try {\n+            timer = scheduler.schedule(this::cancelAuthorization, AUTHORIZATION_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);\n+            timerExpiryTimestamp = LocalDateTime.now().plusMinutes(AUTHORIZATION_TIMEOUT_IN_MINUTES);\n+            return oauthClientService.getAuthorizationUrl(redirectUri, null, null);\n+        } catch (org.openhab.core.auth.client.oauth2.OAuthException e) {\n+            abortTimer();\n+            cancelAuthorization();\n+            throw new OAuthException(\"Failed to determine authorization URL: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    @Override\n+    public ThingUID getBridgeUid() {\n+        final ThingUID bridgeUid = this.bridgeUid;\n+        if (bridgeUid == null) {\n+            throw new NoOngoingAuthorizationException(\"There is no ongoing authorization.\");\n+        }\n+        return bridgeUid;\n+    }\n+\n+    @Override\n+    public synchronized void completeAuthorization(String redirectUrlWithParameters) {\n+        abortTimer();\n+\n+        final OAuthClientService oauthClientService = this.oauthClientService;\n+        if (oauthClientService == null) {\n+            throw new NoOngoingAuthorizationException(\"There is no ongoing authorization.\");\n+        }\n+\n+        try {\n+            String authorizationCode = oauthClientService.extractAuthCodeFromAuthResponse(redirectUrlWithParameters);\n+\n+            // Although this method is called \"get\" it actually fetches and stores the token response as a side effect.\n+            oauthClientService.getAccessTokenResponseByAuthorizationCode(authorizationCode, redirectUri);\n+        } catch (IOException e) {\n+            throw new OAuthException(\"Network error while retrieving token response: \" + e.getMessage());\n+        } catch (OAuthResponseException e) {\n+            throw new OAuthException(\"Failed to retrieve token response: \" + e.getMessage());\n+        } catch (org.openhab.core.auth.client.oauth2.OAuthException e) {\n+            throw new OAuthException(\"Error while processing Miele service response: \" + e.getMessage());\n+        } finally {\n+            this.oauthClientService = null;\n+            this.bridgeUid = null;\n+            this.redirectUri = null;\n+        }\n+    }\n+\n+    /**\n+     * Aborts the timer.\n+     *\n+     * Note: All calls to this method must be {@code synchronized} to ensure thread-safety. Also note that\n+     * {@link #cancelAuthorization()} is {@code synchronized} so the execution of this method and\n+     * {@link #cancelAuthorization()} cannot overlap. Therefore, this method is an atomic operation from the timer's\n+     * perspective.\n+     */\n+    private void abortTimer() {\n+        final ScheduledFuture<?> timer = this.timer;\n+        if (timer == null) {\n+            return;\n+        }\n+\n+        if (!timer.isDone()) {\n+            timer.cancel(false);\n+        }\n+        this.timer = null;\n+        timerExpiryTimestamp = null;\n+    }\n+\n+    private synchronized void cancelAuthorization() {\n+        oauthClientService = null;\n+        bridgeUid = null;\n+        redirectUri = null;\n+        final ScheduledFuture<?> timer = this.timer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            this.timer = null;\n+            timerExpiryTimestamp = null;\n+        }\n+    }\n+\n+    @Override\n+    public String getAccessToken(ThingUID bridgeUid) {\n+        OAuthClientService clientService = oauthFactory.getOAuthClientService(bridgeUid.getAsString());\n+        if (clientService == null) {\n+            throw new OAuthException(\"There is no access token registered for '\" + bridgeUid.getAsString() + \"'\");\n+        }\n+\n+        try {\n+            AccessTokenResponse response = clientService.getAccessTokenResponse();\n+            if (response == null) {\n+                throw new OAuthException(\n+                        \"There is no access token in the persistent storage or it already expired and could not be refreshed\");\n+            } else {\n+                return response.getAccessToken();\n+            }\n+        } catch (org.openhab.core.auth.client.oauth2.OAuthException e) {\n+            throw new OAuthException(\"Failed to read access token from persistent storage: \" + e.getMessage());\n+        } catch (IOException e) {\n+            throw new OAuthException(\n+                    \"Network error during token refresh or error while reading from persistent storage: \"\n+                            + e.getMessage());", "originalCommit": "3144c8aac31f48ff8661aa1a9e928a3d017499e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU2MTUxMA==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r571561510", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new OAuthException(\"Failed to read access token from persistent storage: \" + e.getMessage());\n          \n          \n            \n                        throw new OAuthException(\"Failed to read access token from persistent storage: \" + e.getMessage(), e);", "author": "cpmeister", "createdAt": "2021-02-07T06:45:54Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/config/OAuthAuthorizationHandlerImpl.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.config;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthException;\n+import org.openhab.binding.mielecloud.internal.config.exception.NoOngoingAuthorizationException;\n+import org.openhab.binding.mielecloud.internal.config.exception.OngoingAuthorizationException;\n+import org.openhab.binding.mielecloud.internal.webservice.DefaultMieleWebservice;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.thing.ThingUID;\n+\n+/**\n+ * {@link OAuthAuthorizationHandler} implementation handling the OAuth 2 authorization via openHAB services.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial Contribution\n+ */\n+@NonNullByDefault\n+public final class OAuthAuthorizationHandlerImpl implements OAuthAuthorizationHandler {\n+    private static final String TOKEN_URL = DefaultMieleWebservice.THIRD_PARTY_ENDPOINTS_BASENAME + \"/token\";\n+    private static final String AUTHORIZATION_URL = DefaultMieleWebservice.THIRD_PARTY_ENDPOINTS_BASENAME + \"/login\";\n+\n+    private static final long AUTHORIZATION_TIMEOUT_IN_MINUTES = 5;\n+\n+    private final OAuthFactory oauthFactory;\n+    private final ScheduledExecutorService scheduler;\n+\n+    @Nullable\n+    private OAuthClientService oauthClientService;\n+    @Nullable\n+    private ThingUID bridgeUid;\n+    @Nullable\n+    private String redirectUri;\n+    @Nullable\n+    private ScheduledFuture<?> timer;\n+    @Nullable\n+    private LocalDateTime timerExpiryTimestamp;\n+\n+    /**\n+     * Creates a new {@link OAuthAuthorizationHandlerImpl}.\n+     *\n+     * @param oauthFactory Factory for accessing the {@link OAuthClientService}.\n+     * @param scheduler System-wide scheduler.\n+     */\n+    public OAuthAuthorizationHandlerImpl(OAuthFactory oauthFactory, ScheduledExecutorService scheduler) {\n+        this.oauthFactory = oauthFactory;\n+        this.scheduler = scheduler;\n+    }\n+\n+    @Override\n+    public synchronized void beginAuthorization(String clientId, String clientSecret, ThingUID bridgeUid) {\n+        if (this.oauthClientService != null) {\n+            throw new OngoingAuthorizationException(\"There is already an ongoing authorization!\", timerExpiryTimestamp);\n+        }\n+\n+        this.oauthClientService = oauthFactory.createOAuthClientService(bridgeUid.getAsString(), TOKEN_URL,\n+                AUTHORIZATION_URL, clientId, clientSecret, null, false);\n+        this.bridgeUid = bridgeUid;\n+        redirectUri = null;\n+        timer = null;\n+        timerExpiryTimestamp = null;\n+    }\n+\n+    @Override\n+    public synchronized String getAuthorizationUrl(String redirectUri) {\n+        final OAuthClientService oauthClientService = this.oauthClientService;\n+        if (oauthClientService == null) {\n+            throw new NoOngoingAuthorizationException(\"There is no ongoing authorization!\");\n+        }\n+\n+        this.redirectUri = redirectUri;\n+        try {\n+            timer = scheduler.schedule(this::cancelAuthorization, AUTHORIZATION_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);\n+            timerExpiryTimestamp = LocalDateTime.now().plusMinutes(AUTHORIZATION_TIMEOUT_IN_MINUTES);\n+            return oauthClientService.getAuthorizationUrl(redirectUri, null, null);\n+        } catch (org.openhab.core.auth.client.oauth2.OAuthException e) {\n+            abortTimer();\n+            cancelAuthorization();\n+            throw new OAuthException(\"Failed to determine authorization URL: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    @Override\n+    public ThingUID getBridgeUid() {\n+        final ThingUID bridgeUid = this.bridgeUid;\n+        if (bridgeUid == null) {\n+            throw new NoOngoingAuthorizationException(\"There is no ongoing authorization.\");\n+        }\n+        return bridgeUid;\n+    }\n+\n+    @Override\n+    public synchronized void completeAuthorization(String redirectUrlWithParameters) {\n+        abortTimer();\n+\n+        final OAuthClientService oauthClientService = this.oauthClientService;\n+        if (oauthClientService == null) {\n+            throw new NoOngoingAuthorizationException(\"There is no ongoing authorization.\");\n+        }\n+\n+        try {\n+            String authorizationCode = oauthClientService.extractAuthCodeFromAuthResponse(redirectUrlWithParameters);\n+\n+            // Although this method is called \"get\" it actually fetches and stores the token response as a side effect.\n+            oauthClientService.getAccessTokenResponseByAuthorizationCode(authorizationCode, redirectUri);\n+        } catch (IOException e) {\n+            throw new OAuthException(\"Network error while retrieving token response: \" + e.getMessage());\n+        } catch (OAuthResponseException e) {\n+            throw new OAuthException(\"Failed to retrieve token response: \" + e.getMessage());\n+        } catch (org.openhab.core.auth.client.oauth2.OAuthException e) {\n+            throw new OAuthException(\"Error while processing Miele service response: \" + e.getMessage());\n+        } finally {\n+            this.oauthClientService = null;\n+            this.bridgeUid = null;\n+            this.redirectUri = null;\n+        }\n+    }\n+\n+    /**\n+     * Aborts the timer.\n+     *\n+     * Note: All calls to this method must be {@code synchronized} to ensure thread-safety. Also note that\n+     * {@link #cancelAuthorization()} is {@code synchronized} so the execution of this method and\n+     * {@link #cancelAuthorization()} cannot overlap. Therefore, this method is an atomic operation from the timer's\n+     * perspective.\n+     */\n+    private void abortTimer() {\n+        final ScheduledFuture<?> timer = this.timer;\n+        if (timer == null) {\n+            return;\n+        }\n+\n+        if (!timer.isDone()) {\n+            timer.cancel(false);\n+        }\n+        this.timer = null;\n+        timerExpiryTimestamp = null;\n+    }\n+\n+    private synchronized void cancelAuthorization() {\n+        oauthClientService = null;\n+        bridgeUid = null;\n+        redirectUri = null;\n+        final ScheduledFuture<?> timer = this.timer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            this.timer = null;\n+            timerExpiryTimestamp = null;\n+        }\n+    }\n+\n+    @Override\n+    public String getAccessToken(ThingUID bridgeUid) {\n+        OAuthClientService clientService = oauthFactory.getOAuthClientService(bridgeUid.getAsString());\n+        if (clientService == null) {\n+            throw new OAuthException(\"There is no access token registered for '\" + bridgeUid.getAsString() + \"'\");\n+        }\n+\n+        try {\n+            AccessTokenResponse response = clientService.getAccessTokenResponse();\n+            if (response == null) {\n+                throw new OAuthException(\n+                        \"There is no access token in the persistent storage or it already expired and could not be refreshed\");\n+            } else {\n+                return response.getAccessToken();\n+            }\n+        } catch (org.openhab.core.auth.client.oauth2.OAuthException e) {\n+            throw new OAuthException(\"Failed to read access token from persistent storage: \" + e.getMessage());", "originalCommit": "3144c8aac31f48ff8661aa1a9e928a3d017499e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU2MTU1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r571561551", "bodyText": "Similar suggestion here.", "author": "cpmeister", "createdAt": "2021-02-07T06:46:31Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/config/OAuthAuthorizationHandlerImpl.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.config;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthException;\n+import org.openhab.binding.mielecloud.internal.config.exception.NoOngoingAuthorizationException;\n+import org.openhab.binding.mielecloud.internal.config.exception.OngoingAuthorizationException;\n+import org.openhab.binding.mielecloud.internal.webservice.DefaultMieleWebservice;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.thing.ThingUID;\n+\n+/**\n+ * {@link OAuthAuthorizationHandler} implementation handling the OAuth 2 authorization via openHAB services.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial Contribution\n+ */\n+@NonNullByDefault\n+public final class OAuthAuthorizationHandlerImpl implements OAuthAuthorizationHandler {\n+    private static final String TOKEN_URL = DefaultMieleWebservice.THIRD_PARTY_ENDPOINTS_BASENAME + \"/token\";\n+    private static final String AUTHORIZATION_URL = DefaultMieleWebservice.THIRD_PARTY_ENDPOINTS_BASENAME + \"/login\";\n+\n+    private static final long AUTHORIZATION_TIMEOUT_IN_MINUTES = 5;\n+\n+    private final OAuthFactory oauthFactory;\n+    private final ScheduledExecutorService scheduler;\n+\n+    @Nullable\n+    private OAuthClientService oauthClientService;\n+    @Nullable\n+    private ThingUID bridgeUid;\n+    @Nullable\n+    private String redirectUri;\n+    @Nullable\n+    private ScheduledFuture<?> timer;\n+    @Nullable\n+    private LocalDateTime timerExpiryTimestamp;\n+\n+    /**\n+     * Creates a new {@link OAuthAuthorizationHandlerImpl}.\n+     *\n+     * @param oauthFactory Factory for accessing the {@link OAuthClientService}.\n+     * @param scheduler System-wide scheduler.\n+     */\n+    public OAuthAuthorizationHandlerImpl(OAuthFactory oauthFactory, ScheduledExecutorService scheduler) {\n+        this.oauthFactory = oauthFactory;\n+        this.scheduler = scheduler;\n+    }\n+\n+    @Override\n+    public synchronized void beginAuthorization(String clientId, String clientSecret, ThingUID bridgeUid) {\n+        if (this.oauthClientService != null) {\n+            throw new OngoingAuthorizationException(\"There is already an ongoing authorization!\", timerExpiryTimestamp);\n+        }\n+\n+        this.oauthClientService = oauthFactory.createOAuthClientService(bridgeUid.getAsString(), TOKEN_URL,\n+                AUTHORIZATION_URL, clientId, clientSecret, null, false);\n+        this.bridgeUid = bridgeUid;\n+        redirectUri = null;\n+        timer = null;\n+        timerExpiryTimestamp = null;\n+    }\n+\n+    @Override\n+    public synchronized String getAuthorizationUrl(String redirectUri) {\n+        final OAuthClientService oauthClientService = this.oauthClientService;\n+        if (oauthClientService == null) {\n+            throw new NoOngoingAuthorizationException(\"There is no ongoing authorization!\");\n+        }\n+\n+        this.redirectUri = redirectUri;\n+        try {\n+            timer = scheduler.schedule(this::cancelAuthorization, AUTHORIZATION_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);\n+            timerExpiryTimestamp = LocalDateTime.now().plusMinutes(AUTHORIZATION_TIMEOUT_IN_MINUTES);\n+            return oauthClientService.getAuthorizationUrl(redirectUri, null, null);\n+        } catch (org.openhab.core.auth.client.oauth2.OAuthException e) {\n+            abortTimer();\n+            cancelAuthorization();\n+            throw new OAuthException(\"Failed to determine authorization URL: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    @Override\n+    public ThingUID getBridgeUid() {\n+        final ThingUID bridgeUid = this.bridgeUid;\n+        if (bridgeUid == null) {\n+            throw new NoOngoingAuthorizationException(\"There is no ongoing authorization.\");\n+        }\n+        return bridgeUid;\n+    }\n+\n+    @Override\n+    public synchronized void completeAuthorization(String redirectUrlWithParameters) {\n+        abortTimer();\n+\n+        final OAuthClientService oauthClientService = this.oauthClientService;\n+        if (oauthClientService == null) {\n+            throw new NoOngoingAuthorizationException(\"There is no ongoing authorization.\");\n+        }\n+\n+        try {\n+            String authorizationCode = oauthClientService.extractAuthCodeFromAuthResponse(redirectUrlWithParameters);\n+\n+            // Although this method is called \"get\" it actually fetches and stores the token response as a side effect.\n+            oauthClientService.getAccessTokenResponseByAuthorizationCode(authorizationCode, redirectUri);\n+        } catch (IOException e) {\n+            throw new OAuthException(\"Network error while retrieving token response: \" + e.getMessage());\n+        } catch (OAuthResponseException e) {\n+            throw new OAuthException(\"Failed to retrieve token response: \" + e.getMessage());\n+        } catch (org.openhab.core.auth.client.oauth2.OAuthException e) {\n+            throw new OAuthException(\"Error while processing Miele service response: \" + e.getMessage());\n+        } finally {", "originalCommit": "3144c8aac31f48ff8661aa1a9e928a3d017499e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU2MTc0MA==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r571561740", "bodyText": "You should include the exception message or maybe even the exception stacktrace.", "author": "cpmeister", "createdAt": "2021-02-07T06:47:57Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/auth/OpenHabOAuthTokenRefresher.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.auth;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handles refreshing of OAuth2 tokens managed by the openHAB runtime.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial contribution\n+ */\n+@Component\n+@NonNullByDefault\n+public final class OpenHabOAuthTokenRefresher implements OAuthTokenRefresher {\n+    private final Logger logger = LoggerFactory.getLogger(OpenHabOAuthTokenRefresher.class);\n+\n+    private final OAuthFactory oauthFactory;\n+    private Map<String, @Nullable AccessTokenRefreshListener> listenerByServiceHandle = new HashMap<>();\n+\n+    @Activate\n+    public OpenHabOAuthTokenRefresher(@Reference OAuthFactory oauthFactory) {\n+        this.oauthFactory = oauthFactory;\n+    }\n+\n+    @Override\n+    public void setRefreshListener(OAuthTokenRefreshListener listener, String serviceHandle) {\n+        final AccessTokenRefreshListener refreshListener = tokenResponse -> {\n+            final String accessToken = tokenResponse.getAccessToken();\n+            if (accessToken == null) {\n+                // Fail without exception to ensure that the OAuthClientService notifies all listeners.\n+                logger.warn(\"Ignoring access token response without access token.\");\n+            } else {\n+                listener.onNewAccessToken(accessToken);\n+            }\n+        };\n+\n+        OAuthClientService clientService = getOAuthClientService(serviceHandle);\n+        clientService.addAccessTokenRefreshListener(refreshListener);\n+        listenerByServiceHandle.put(serviceHandle, refreshListener);\n+    }\n+\n+    @Override\n+    public void unsetRefreshListener(String serviceHandle) {\n+        final AccessTokenRefreshListener refreshListener = listenerByServiceHandle.get(serviceHandle);\n+        if (refreshListener != null) {\n+            try {\n+                OAuthClientService clientService = getOAuthClientService(serviceHandle);\n+                clientService.removeAccessTokenRefreshListener(refreshListener);\n+            } catch (OAuthException e) {\n+                logger.warn(\"Failed to remove refresh listener: OAuth client service is unavailable.\");", "originalCommit": "3144c8aac31f48ff8661aa1a9e928a3d017499e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTk4NTU1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r575985550", "bodyText": "Included the exception message.", "author": "BjoernLange", "createdAt": "2021-02-15T07:27:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU2MTc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU2MTk5MA==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r571561990", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private LanguageProvider prioritizedLanguageProvider;\n          \n          \n            \n                @Nullable\n          \n          \n            \n                private LanguageProvider fallbackLanguageProvider;\n          \n          \n            \n                private @Nullable LanguageProvider prioritizedLanguageProvider;\n          \n          \n            \n                private @Nullable LanguageProvider fallbackLanguageProvider;", "author": "cpmeister", "createdAt": "2021-02-07T06:50:18Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/webservice/language/CombiningLanguageProvider.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.webservice.language;\n+\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * {@link LanguageProvider} combining two {@link LanguageProvider}s, a prioritized and a fallback provider.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial contribution\n+ */\n+@NonNullByDefault\n+public class CombiningLanguageProvider implements LanguageProvider {\n+    @Nullable\n+    private LanguageProvider prioritizedLanguageProvider;\n+    @Nullable\n+    private LanguageProvider fallbackLanguageProvider;", "originalCommit": "3144c8aac31f48ff8661aa1a9e928a3d017499e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU2MjIyNw==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r571562227", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        @Nullable\n          \n          \n            \n                        public Void get() {\n          \n          \n            \n                        public @Nullable Void get() {", "author": "cpmeister", "createdAt": "2021-02-07T06:53:01Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/webservice/retry/RetryStrategy.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.webservice.retry;\n+\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Interface for strategies implementing the retry behavior of requests against the Miele cloud.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial contribution\n+ */\n+@NonNullByDefault\n+public interface RetryStrategy {\n+    /**\n+     * Performs an operation which may be retried several times.\n+     *\n+     * If retrying fails or a critical error occurred, this method may throw {@link Exception}s of any type.\n+     *\n+     * @param operation The operation to perform. To signal that an error can be resolved by retrying this operation it\n+     *            should throw an {@link Exception}. Whether the operation is retried is up to the {@link RetryStrategy}\n+     *            implementation.\n+     * @param onException Handler to invoke when an {@link Exception} is handled by retrying the {@code operation}. This\n+     *            handler should at least log a message. It must not throw any exception.\n+     * @return The object returned by {@code operation} if it completed successfully.\n+     */\n+    <@Nullable T> T performRetryableOperation(Supplier<T> operation, Consumer<Exception> onException);\n+\n+    /**\n+     * Performs an operation which may be retried several times.\n+     *\n+     * If retrying fails or a critical error occurred, this method may throw {@link Exception}s of any type.\n+     *\n+     * @param operation The operation to perform. To signal that an error can be resolved by retrying this operation it\n+     *            should throw an {@link Exception}. Whether the operation is retried is up to the {@link RetryStrategy}\n+     *            implementation\n+     * @param onException Handler to invoke when an {@link Exception} is handled by retrying the {@code operation}. This\n+     *            handler should at least log a message. It may not throw any exception.\n+     */\n+    default void performRetryableOperation(Runnable operation, Consumer<Exception> onException) {\n+        performRetryableOperation(new Supplier<@Nullable Void>() {\n+            @Override\n+            @Nullable\n+            public Void get() {", "originalCommit": "3144c8aac31f48ff8661aa1a9e928a3d017499e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU2MjQ4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r571562487", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private String event;\n          \n          \n            \n                private @Nullable String event;", "author": "cpmeister", "createdAt": "2021-02-07T06:55:54Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/webservice/sse/SseStreamParser.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.webservice.sse;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceDisconnectSseException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Parses events from the SSE event stream and emits them via the given dispatcher.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial Contribution\n+ */\n+@NonNullByDefault\n+class SseStreamParser {\n+    private static final String SSE_KEY_EVENT = \"event:\";\n+    private static final String SSE_KEY_DATA = \"data:\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SseStreamParser.class);\n+\n+    private final BufferedReader reader;\n+    private final Consumer<ServerSentEvent> onServerSentEventCallback;\n+    private final Consumer<@Nullable Throwable> onStreamClosedCallback;\n+\n+    @Nullable\n+    private String event;", "originalCommit": "3144c8aac31f48ff8661aa1a9e928a3d017499e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "af128c39877ac97ece4918295dbf112eb02c0ab5", "url": "https://github.com/openhab/openhab-addons/commit/af128c39877ac97ece4918295dbf112eb02c0ab5", "message": "Remove outdated information from README\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-02-15T06:43:30Z", "type": "forcePushed"}, {"oid": "2eb5614bcc65e1eaa6cb6ed642957665f340797c", "url": "https://github.com/openhab/openhab-addons/commit/2eb5614bcc65e1eaa6cb6ed642957665f340797c", "message": "Update integration test run configuration\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-04-12T06:36:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTkxMzIyMw==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r611913223", "bodyText": "Dispose and initialized are meant to be only called by the framework.\nIt's highly recommended to make the implementation of handleConfigurationUpdate in such a way that anything that needs to be restarted internally is done within that method directly.", "author": "kaikreuzer", "createdAt": "2021-04-12T19:55:50Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/config/servlet/CreateBridgeServlet.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.config.servlet;\n+\n+import java.util.Collections;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BooleanSupplier;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants;\n+import org.openhab.binding.mielecloud.internal.config.exception.BridgeCreationFailedException;\n+import org.openhab.binding.mielecloud.internal.config.exception.BridgeReconfigurationFailedException;\n+import org.openhab.binding.mielecloud.internal.util.LocaleValidator;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.inbox.Inbox;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingRegistry;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Servlet that automatically creates a bridge and then redirects the browser to the account overview page.\n+ *\n+ * @author Bj\u00f6rn Lange - Initial Contribution\n+ */\n+@NonNullByDefault\n+public final class CreateBridgeServlet extends AbstractRedirectionServlet {\n+    private static final String MIELE_CLOUD_BRIDGE_NAME = \"Cloud Connector\";\n+    private static final String MIELE_CLOUD_BRIDGE_LABEL = \"Miele@home Account\";\n+\n+    private static final String LOCALE_PARAMETER_NAME = \"locale\";\n+    public static final String BRIDGE_UID_PARAMETER_NAME = \"bridgeUid\";\n+\n+    private static final long serialVersionUID = -2912042079128722887L;\n+\n+    private static final String DEFAULT_LOCALE = \"en\";\n+\n+    private static final long ONLINE_WAIT_TIMEOUT_IN_MILLISECONDS = 5000;\n+    private static final long DISCOVERY_COMPLETION_TIMEOUT_IN_MILLISECONDS = 5000;\n+    private static final long CHECK_INTERVAL_IN_MILLISECONDS = 100;\n+\n+    private final Logger logger = LoggerFactory.getLogger(CreateBridgeServlet.class);\n+\n+    private final Inbox inbox;\n+    private final ThingRegistry thingRegistry;\n+\n+    /**\n+     * Creates a new {@link CreateBridgeServlet}.\n+     *\n+     * @param inbox openHAB inbox for discovery results.\n+     * @param thingRegistry openHAB thing registry.\n+     */\n+    public CreateBridgeServlet(Inbox inbox, ThingRegistry thingRegistry) {\n+        this.inbox = inbox;\n+        this.thingRegistry = thingRegistry;\n+    }\n+\n+    @Override\n+    protected String getRedirectionDestination(HttpServletRequest request) {\n+        String bridgeUidString = request.getParameter(BRIDGE_UID_PARAMETER_NAME);\n+        if (bridgeUidString == null || bridgeUidString.isEmpty()) {\n+            logger.warn(\"Cannot create bridge: Bridge UID is missing.\");\n+            return \"/mielecloud/failure?\" + FailureServlet.MISSING_BRIDGE_UID_PARAMETER_NAME + \"=true\";\n+        }\n+\n+        ThingUID bridgeUid = null;\n+        try {\n+            bridgeUid = new ThingUID(bridgeUidString);\n+        } catch (IllegalArgumentException e) {\n+            logger.warn(\"Cannot create bridge: Bridge UID '{}' is malformed.\", bridgeUid);\n+            return \"/mielecloud/failure?\" + FailureServlet.MALFORMED_BRIDGE_UID_PARAMETER_NAME + \"=true\";\n+        }\n+\n+        String locale = getValidLocale(request.getParameter(LOCALE_PARAMETER_NAME));\n+\n+        logger.debug(\"Auto configuring Miele account using locale '{}' (requested locale was '{}')\", locale,\n+                request.getParameter(LOCALE_PARAMETER_NAME));\n+        try {\n+            Thing bridge = pairOrReconfigureBridge(locale, bridgeUid);\n+            waitForBridgeToComeOnline(bridge);\n+            return \"/mielecloud\";\n+        } catch (BridgeReconfigurationFailedException e) {\n+            logger.warn(\"{}\", e.getMessage());\n+            return \"/mielecloud/success?\" + SuccessServlet.BRIDGE_RECONFIGURATION_FAILED_PARAMETER_NAME + \"=true&\"\n+                    + SuccessServlet.BRIDGE_UID_PARAMETER_NAME + \"=\" + bridgeUidString;\n+        } catch (BridgeCreationFailedException e) {\n+            logger.warn(\"Thing creation failed because there was no binding available that supports the thing.\");\n+            return \"/mielecloud/success?\" + SuccessServlet.BRIDGE_CREATION_FAILED_PARAMETER_NAME + \"=true&\"\n+                    + SuccessServlet.BRIDGE_UID_PARAMETER_NAME + \"=\" + bridgeUidString;\n+        }\n+    }\n+\n+    private Thing pairOrReconfigureBridge(String locale, ThingUID bridgeUid) {\n+        DiscoveryResult result = DiscoveryResultBuilder.create(bridgeUid)\n+                .withRepresentationProperty(Thing.PROPERTY_MODEL_ID).withLabel(MIELE_CLOUD_BRIDGE_LABEL)\n+                .withProperty(Thing.PROPERTY_MODEL_ID, MIELE_CLOUD_BRIDGE_NAME)\n+                .withProperty(MieleCloudBindingConstants.CONFIG_PARAM_LOCALE, locale).build();\n+        if (inbox.add(result)) {\n+            return pairBridge(bridgeUid);\n+        } else {\n+            return reconfigureBridge(bridgeUid, locale);\n+        }\n+    }\n+\n+    private Thing pairBridge(ThingUID thingUid) {\n+        Thing thing = inbox.approve(thingUid, MIELE_CLOUD_BRIDGE_LABEL, null);\n+        if (thing == null) {\n+            throw new BridgeCreationFailedException();\n+        }\n+\n+        logger.debug(\"Successfully created bridge {}\", thingUid);\n+        return thing;\n+    }\n+\n+    private Thing reconfigureBridge(ThingUID thingUid, String locale) {\n+        logger.debug(\"Thing already exists. Modifying configuration.\");\n+        Thing thing = thingRegistry.get(thingUid);\n+        if (thing == null) {\n+            throw new BridgeReconfigurationFailedException(\n+                    \"Cannot modify non existing bridge: Could neither add bridge via inbox nor find existing bridge.\");\n+        }\n+\n+        ThingHandler handler = thing.getHandler();\n+        if (handler == null) {\n+            throw new BridgeReconfigurationFailedException(\"Bridge exists but has no handler.\");\n+        }\n+\n+        handler.handleConfigurationUpdate(\n+                Collections.singletonMap(MieleCloudBindingConstants.CONFIG_PARAM_LOCALE, locale));\n+\n+        // As the parameters will not necessarily change we need to force the thing to re-initialize.\n+        handler.dispose();", "originalCommit": "2eb5614bcc65e1eaa6cb6ed642957665f340797c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTIyMzI1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r619223259", "bodyText": "I had a detailed look at the alternative implementation by overriding handleConfigurationUpdate in the MieleBridgeHandler. That would be copy-pasting the code from BaseThingHandler and removing the check whether the configuration parameters changed which isn't a better solution in imho. We really want to trigger a reinitialization here because we don't know in which state the Thing and  ThingHandler are. Isn't there a framework call we could use instead?", "author": "BjoernLange", "createdAt": "2021-04-23T13:32:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTkxMzIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjUyMDg1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r622520853", "bodyText": "My suggestion would be to put the logic that is in dispose and that you want to call here into a separate method, which you can call from here and from dispose likewise. Same for initialize. This way you can avoid calling these methods directly.", "author": "kaikreuzer", "createdAt": "2021-04-28T20:38:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTkxMzIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzY0NDY1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r623644651", "bodyText": "That would be the complete initialize and dispose cycle. I decided that overwriting handleConfiguationUpdate is probably the better alternative and did so.", "author": "BjoernLange", "createdAt": "2021-04-30T06:38:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTkxMzIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTkxNDQxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r611914419", "bodyText": "There should not be any warn logging in such cases - the feedback to the user happens through the Thing status message instead.", "author": "kaikreuzer", "createdAt": "2021-04-12T19:57:43Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/handler/MieleBridgeHandler.java", "diffHunk": "@@ -0,0 +1,357 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.handler;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants;\n+import org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants.I18NKeys;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthException;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthTokenRefreshListener;\n+import org.openhab.binding.mielecloud.internal.auth.OAuthTokenRefresher;\n+import org.openhab.binding.mielecloud.internal.discovery.ThingDiscoveryService;\n+import org.openhab.binding.mielecloud.internal.util.LocaleValidator;\n+import org.openhab.binding.mielecloud.internal.webservice.ConnectionError;\n+import org.openhab.binding.mielecloud.internal.webservice.ConnectionStatusListener;\n+import org.openhab.binding.mielecloud.internal.webservice.DeviceStateListener;\n+import org.openhab.binding.mielecloud.internal.webservice.MieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.UnavailableMieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.api.ActionsState;\n+import org.openhab.binding.mielecloud.internal.webservice.api.DeviceState;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.MieleWebserviceInitializationException;\n+import org.openhab.binding.mielecloud.internal.webservice.language.CombiningLanguageProvider;\n+import org.openhab.binding.mielecloud.internal.webservice.language.LanguageProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * BridgeHandler implementation for the Miele cloud account.\n+ *\n+ * @author Roland Edelhoff - Initial contribution\n+ * @author Bj\u00f6rn Lange - Introduced CombiningLanguageProvider field and interactions, added LanguageProvider super\n+ *         interface, switched from polling to SSE, added support for multiple bridges\n+ */\n+@NonNullByDefault\n+public class MieleBridgeHandler extends BaseBridgeHandler\n+        implements OAuthTokenRefreshListener, LanguageProvider, ConnectionStatusListener, DeviceStateListener {\n+    private static final int NUMBER_OF_SSE_RECONNECTION_ATTEMPTS_BEFORE_STATUS_IS_UPDATED = 6;\n+\n+    private final Supplier<MieleWebservice> webserviceFactory;\n+\n+    private final OAuthTokenRefresher tokenRefresher;\n+    private final CombiningLanguageProvider languageProvider;\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+\n+    private @Nullable CompletableFuture<@Nullable Void> logoutFuture;\n+    private @Nullable MieleWebservice webService;\n+    private @Nullable ThingDiscoveryService discoveryService;\n+\n+    /**\n+     * Creates a new {@link MieleBridgeHandler}.\n+     *\n+     * @param bridge The bridge to handle.\n+     * @param webserviceFactory Factory for creating {@link MieleWebservice} instances.\n+     * @param tokenRefresher Token refresher.\n+     * @param languageProvider Language provider.\n+     */\n+    public MieleBridgeHandler(Bridge bridge, Function<ScheduledExecutorService, MieleWebservice> webserviceFactory,\n+            OAuthTokenRefresher tokenRefresher, CombiningLanguageProvider languageProvider) {\n+        super(bridge);\n+        this.webserviceFactory = () -> webserviceFactory.apply(scheduler);\n+        this.tokenRefresher = tokenRefresher;\n+        this.languageProvider = languageProvider;\n+    }\n+\n+    public void setDiscoveryService(@Nullable ThingDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    /**\n+     * Gets the current webservice instance for communication with the Miele service.\n+     *\n+     * This function may return an {@link UnavailableMieleWebservice} in case no webservice is available at the moment.\n+     */\n+    public MieleWebservice getWebservice() {\n+        MieleWebservice webservice = webService;\n+        if (webservice != null) {\n+            return webservice;\n+        } else {\n+            return UnavailableMieleWebservice.INSTANCE;\n+        }\n+    }\n+\n+    private String getOAuthServiceHandle() {\n+        return getThing().getUID().getAsString();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // It is required to set a status in this method as stated in the Javadoc of ThingHandler.initialize\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        try {\n+            webService = webserviceFactory.get();\n+        } catch (MieleWebserviceInitializationException e) {\n+            logger.warn(\"Failed to initialize webservice.\", e);\n+            updateStatus(ThingStatus.OFFLINE);\n+            return;\n+        }\n+\n+        try {\n+            tokenRefresher.setRefreshListener(this, getOAuthServiceHandle());\n+        } catch (OAuthException e) {\n+            logger.debug(\"Could not initialize Miele Cloud bridge.\", e);\n+            logger.warn(\"The account has not been authorized. Please consult the documentation on how to do that.\");", "originalCommit": "2eb5614bcc65e1eaa6cb6ed642957665f340797c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDkwODcwNA==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r614908704", "bodyText": "Both is done here (see the following lines). Should I still remove the log messages?", "author": "BjoernLange", "createdAt": "2021-04-16T15:02:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTkxNDQxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTMwNDc1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r615304753", "bodyText": "Yes, according to the logging guidelines, only the Thing status should be used.", "author": "kaikreuzer", "createdAt": "2021-04-17T21:09:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTkxNDQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTkxNzM0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r611917345", "bodyText": "In case of a COMMUNICATION_ERROR, a message text to tell the user what happened is highly recommended.\nIn the situation here, I feel that you probably only want to say OFFLINE without actually knowing the exact reason for it, don't you?", "author": "kaikreuzer", "createdAt": "2021-04-12T20:02:47Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/handler/AbstractMieleThingHandler.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mielecloud.internal.handler;\n+\n+import static org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants.Channels.*;\n+import static org.openhab.binding.mielecloud.internal.webservice.api.PowerStatus.*;\n+import static org.openhab.binding.mielecloud.internal.webservice.api.ProgramStatus.*;\n+import static org.openhab.binding.mielecloud.internal.webservice.api.json.ProcessAction.*;\n+\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.mielecloud.internal.MieleCloudBindingConstants.I18NKeys;\n+import org.openhab.binding.mielecloud.internal.discovery.ThingInformationExtractor;\n+import org.openhab.binding.mielecloud.internal.handler.channel.ActionsChannelState;\n+import org.openhab.binding.mielecloud.internal.handler.channel.DeviceChannelState;\n+import org.openhab.binding.mielecloud.internal.handler.channel.TransitionChannelState;\n+import org.openhab.binding.mielecloud.internal.webservice.ActionStateFetcher;\n+import org.openhab.binding.mielecloud.internal.webservice.MieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.UnavailableMieleWebservice;\n+import org.openhab.binding.mielecloud.internal.webservice.api.ActionsState;\n+import org.openhab.binding.mielecloud.internal.webservice.api.DeviceState;\n+import org.openhab.binding.mielecloud.internal.webservice.api.PowerStatus;\n+import org.openhab.binding.mielecloud.internal.webservice.api.ProgramStatus;\n+import org.openhab.binding.mielecloud.internal.webservice.api.TransitionState;\n+import org.openhab.binding.mielecloud.internal.webservice.api.json.ProcessAction;\n+import org.openhab.binding.mielecloud.internal.webservice.api.json.StateType;\n+import org.openhab.binding.mielecloud.internal.webservice.exception.TooManyRequestsException;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for all Miele thing handlers.\n+ *\n+ * @author Roland Edelhoff - Initial contribution\n+ * @author Bj\u00f6rn Lange - Add channel state wrappers\n+ */\n+@NonNullByDefault\n+public abstract class AbstractMieleThingHandler extends BaseThingHandler {\n+    protected final ActionStateFetcher actionFetcher;\n+    protected DeviceState latestDeviceState = new DeviceState(getDeviceId(), null);\n+    protected TransitionState latestTransitionState = new TransitionState(null, latestDeviceState);\n+    protected ActionsState latestActionsState = new ActionsState(getDeviceId(), null);\n+\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+\n+    /**\n+     * Creates a new {@link AbstractMieleThingHandler}.\n+     *\n+     * @param thing The thing to handle.\n+     */\n+    public AbstractMieleThingHandler(Thing thing) {\n+        super(thing);\n+        this.actionFetcher = new ActionStateFetcher(this::getWebservice, scheduler);\n+    }\n+\n+    private Optional<MieleBridgeHandler> getMieleBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            return Optional.empty();\n+        }\n+\n+        BridgeHandler handler = bridge.getHandler();\n+        if (handler == null || !(handler instanceof MieleBridgeHandler)) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of((MieleBridgeHandler) handler);\n+    }\n+\n+    protected MieleWebservice getWebservice() {\n+        return getMieleBridgeHandler().map(MieleBridgeHandler::getWebservice)\n+                .orElse(UnavailableMieleWebservice.INSTANCE);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        getWebservice().dispatchDeviceState(getDeviceId());\n+\n+        // If no device state update was received so far, set the device to OFFLINE.\n+        if (getThing().getStatus() == ThingStatus.INITIALIZING) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);", "originalCommit": "2eb5614bcc65e1eaa6cb6ed642957665f340797c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDkxNTMwOA==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r614915308", "bodyText": "I must admit, if I think closely of this we take a slight guess here. When the thing is initialized, it calls out to the bridge to synchronously dispatch the current state of all things. This update is processed by the AbstractMieleThingHandler and the status is set accordingly. If the status is not set then either there is no connection to the Miele cloud or the thing was removed while the binding was inactive. The guess is that it is far more uncommon that a device was removed in the cloud than a communication problem is. You are right setting it to just OFFLINE seems to be the better option here.", "author": "BjoernLange", "createdAt": "2021-04-16T15:11:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTkxNzM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNTk4OTYxMw==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r625989613", "bodyText": "Hm, this does not really make sense to me. This method is again one that is called by the framework and should behave accordingly. If the framework calls it and nothing has changed about the configuration, no re-initialization is necessary and should hence not be done.\nIsn't what you want to do to introduce a new private method instead, which you can call from reconfigureBridge() and that re-initializes what is necessary (without calling initialize() nor dispose())?", "author": "kaikreuzer", "createdAt": "2021-05-04T17:56:13Z", "path": "bundles/org.openhab.binding.mielecloud/src/main/java/org/openhab/binding/mielecloud/internal/handler/MieleBridgeHandler.java", "diffHunk": "@@ -153,6 +158,39 @@ public void handleRemoval() {\n         super.handleRemoval();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Note: This is the same implementation as in {@link BaseThingHandler} except that it is not checked whether the", "originalCommit": "f2e35cf48e927016a813dc987bf9e7a2ff8bcde0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNjU1NTM1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r626555359", "bodyText": "Hm, this does not really make sense to me. This method is again one that is called by the framework and should behave accordingly. If the framework calls it and nothing has changed about the configuration, no re-initialization is necessary and should hence not be done.\n\nThe problem we try to solve by doing this is that the configuration of the bridge is made up of the configuration parameters and the current access token. We could check whether the access token changed prior to calling dispose() and initialize() here. Would that be a valid solution?\n\nIsn't what you want to do to introduce a new private method instead, which you can call from reconfigureBridge() and that re-initializes what is necessary (without calling initialize() nor dispose())?\n\nI could do so, but it is necessary to do everything that is done in initialize() and dispose(). I could put all of that into separate methods, like internalInitialize() and internalDispose() and call these from reconfigureBridge(), initialize() and dispose() but I don't see the advantage of doing this apart from not calling framework methods. It would rather confuse me when I would be reading such code.", "author": "BjoernLange", "createdAt": "2021-05-05T13:17:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNTk4OTYxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMTQyMTczOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r631421739", "bodyText": "Maybe you better see the advantage if you think of better names for the private methods, e.g. something like startBackgroundThreads() and stopBackgroundThreads() or something describing what the code does.\nMy problem with dispose() is that the name of the method signals that after calling it, the object is/can be garbage collected and that it is not in use anymore. Calling such a method and still continuing to work with the object seems wrong.\nLikewise, initialize() as a method is similar to the OSGi services activate(), which is called exactly once in the lifecycle of an object. So any additional call seems fishy.\nThese issues can be escaped by defining your own private methods with a suitable naming.", "author": "kaikreuzer", "createdAt": "2021-05-12T21:43:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNTk4OTYxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjg4Njg1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9146#discussion_r636886858", "bodyText": "I did as you requested and decided to use initializeWebservice and disposeWebservice as the webservice component used by the handler is disposed and initialized again. Hope this is fine now.", "author": "BjoernLange", "createdAt": "2021-05-21T12:41:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNTk4OTYxMw=="}], "type": "inlineReview"}, {"oid": "0a9ed5b965e7650b7c65ae793c0986b99149aec1", "url": "https://github.com/openhab/openhab-addons/commit/0a9ed5b965e7650b7c65ae793c0986b99149aec1", "message": "Initial contribution of the Miele Cloud binding\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:08:01Z", "type": "commit"}, {"oid": "98f90acfcfe1e29476d45c4453efe0dc87ce1c39", "url": "https://github.com/openhab/openhab-addons/commit/98f90acfcfe1e29476d45c4453efe0dc87ce1c39", "message": "Removed references to Paper UI from README\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:08:04Z", "type": "commit"}, {"oid": "892ca3f0623141916fb8acfe3800b20a5ae24fde", "url": "https://github.com/openhab/openhab-addons/commit/892ca3f0623141916fb8acfe3800b20a5ae24fde", "message": "Move property extraction to own class\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:08:04Z", "type": "commit"}, {"oid": "07a04d0efc8fe96ac649cd8b818b72faa25669e0", "url": "https://github.com/openhab/openhab-addons/commit/07a04d0efc8fe96ac649cd8b818b72faa25669e0", "message": "Remove plate_is_present channels\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:08:05Z", "type": "commit"}, {"oid": "e89cf43cf7db7a2685e80857a88beddd3decfd0c", "url": "https://github.com/openhab/openhab-addons/commit/e89cf43cf7db7a2685e80857a88beddd3decfd0c", "message": "Add plateCount property to hob discovery results\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:08:05Z", "type": "commit"}, {"oid": "0a181a752204d7ea4f4ff70de343b394de0e741d", "url": "https://github.com/openhab/openhab-addons/commit/0a181a752204d7ea4f4ff70de343b394de0e741d", "message": "Refactorings to improve code quality\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:08:05Z", "type": "commit"}, {"oid": "e61005da2dd81de7cc7e92e7620b9ba988e4159d", "url": "https://github.com/openhab/openhab-addons/commit/e61005da2dd81de7cc7e92e7620b9ba988e4159d", "message": "Fix compile errors in integration tests\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:08:05Z", "type": "commit"}, {"oid": "fceb1fc8dc5b2f8a8813d7b989817dfc764ca42e", "url": "https://github.com/openhab/openhab-addons/commit/fceb1fc8dc5b2f8a8813d7b989817dfc764ca42e", "message": "Update thing properties on device status update\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:08:05Z", "type": "commit"}, {"oid": "364402bb363c711c0a63466f30487d62979b5a9a", "url": "https://github.com/openhab/openhab-addons/commit/364402bb363c711c0a63466f30487d62979b5a9a", "message": "Fix spotless checks\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:08Z", "type": "commit"}, {"oid": "0394f2876ab50d025151d1aaf41a789b863003a6", "url": "https://github.com/openhab/openhab-addons/commit/0394f2876ab50d025151d1aaf41a789b863003a6", "message": "Remove accessToken from documentation images\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:10Z", "type": "commit"}, {"oid": "0f3634945f59acc2bf1e6d1cc36dd59229b95706", "url": "https://github.com/openhab/openhab-addons/commit/0f3634945f59acc2bf1e6d1cc36dd59229b95706", "message": "plateCount property changes for README\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:10Z", "type": "commit"}, {"oid": "7f0f4697a9c96309827e239a37de17e2e7b77562", "url": "https://github.com/openhab/openhab-addons/commit/7f0f4697a9c96309827e239a37de17e2e7b77562", "message": "Corrected capitalization in feature.xml\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:10Z", "type": "commit"}, {"oid": "d866deeaa0aef24d74055816987a811b9db429de", "url": "https://github.com/openhab/openhab-addons/commit/d866deeaa0aef24d74055816987a811b9db429de", "message": "Fixed build warnings for README\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:10Z", "type": "commit"}, {"oid": "5c8aeeb95be65e7c3c7d9976fd4d9c3302abbb71", "url": "https://github.com/openhab/openhab-addons/commit/5c8aeeb95be65e7c3c7d9976fd4d9c3302abbb71", "message": "Remove unnecessary @NonNullByDefault annotations\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:10Z", "type": "commit"}, {"oid": "b527dafebd8cdf508fb50ef43c7e283422c55af7", "url": "https://github.com/openhab/openhab-addons/commit/b527dafebd8cdf508fb50ef43c7e283422c55af7", "message": "Use constructor instead of method injection\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:10Z", "type": "commit"}, {"oid": "72272d9d571db6001dc7404262e9775a82565f13", "url": "https://github.com/openhab/openhab-addons/commit/72272d9d571db6001dc7404262e9775a82565f13", "message": "Lists instead of tables for channel IDs in README\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:11Z", "type": "commit"}, {"oid": "9c8a840447be136bf671b88c9d8d32566bfe2632", "url": "https://github.com/openhab/openhab-addons/commit/9c8a840447be136bf671b88c9d8d32566bfe2632", "message": "Use UoM for temperatures\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:11Z", "type": "commit"}, {"oid": "b01fdaee66673b438add03e44f5dec9885dbcb9b", "url": "https://github.com/openhab/openhab-addons/commit/b01fdaee66673b438add03e44f5dec9885dbcb9b", "message": "Corrected binding name in pom.xml\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:11Z", "type": "commit"}, {"oid": "a54614841de23f92960fd46b2b66d3b75b075c2f", "url": "https://github.com/openhab/openhab-addons/commit/a54614841de23f92960fd46b2b66d3b75b075c2f", "message": "Use constructor injection for handler factory\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:11Z", "type": "commit"}, {"oid": "185175cbe7d02a8a05858e7daee8a443f6bca12d", "url": "https://github.com/openhab/openhab-addons/commit/185175cbe7d02a8a05858e7daee8a443f6bca12d", "message": "Catch specific exceptions\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:11Z", "type": "commit"}, {"oid": "d3343af1dac93069b80a6a871c107e5c9e1251f6", "url": "https://github.com/openhab/openhab-addons/commit/d3343af1dac93069b80a6a871c107e5c9e1251f6", "message": "Adapted logging according to guidelines\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:11Z", "type": "commit"}, {"oid": "e2cd6d4dc64bbeae84fa828a4941877147a268e5", "url": "https://github.com/openhab/openhab-addons/commit/e2cd6d4dc64bbeae84fa828a4941877147a268e5", "message": "Replace fixed delay with check of inbox\n\nInstead of waiting one second the binding waits until the number of\ndiscovery results doesn't change any more.\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:11Z", "type": "commit"}, {"oid": "f30dd1e8ffcd906e37732f41b2278ff2e3ad1ba9", "url": "https://github.com/openhab/openhab-addons/commit/f30dd1e8ffcd906e37732f41b2278ff2e3ad1ba9", "message": "Use Set.of\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:11Z", "type": "commit"}, {"oid": "11814dd34a27534378535434f553327215800f03", "url": "https://github.com/openhab/openhab-addons/commit/11814dd34a27534378535434f553327215800f03", "message": "Apply review comments in AbstractMieleThingHandler\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:11Z", "type": "commit"}, {"oid": "8111513b917f957e962d8b50bc4a1b738981f61d", "url": "https://github.com/openhab/openhab-addons/commit/8111513b917f957e962d8b50bc4a1b738981f61d", "message": "Use execute rather than schedule\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:11Z", "type": "commit"}, {"oid": "046772b719fef666639e30dec5eb97de7487d16b", "url": "https://github.com/openhab/openhab-addons/commit/046772b719fef666639e30dec5eb97de7487d16b", "message": "No immediate loading of handler factory\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:12Z", "type": "commit"}, {"oid": "546c21a4ab1812bf12696c738eeff66955c43728", "url": "https://github.com/openhab/openhab-addons/commit/546c21a4ab1812bf12696c738eeff66955c43728", "message": "Use ThingHandlerService for thing discovery\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:12Z", "type": "commit"}, {"oid": "8ebd0a72f857443731fc6e4237756a9f89489e9a", "url": "https://github.com/openhab/openhab-addons/commit/8ebd0a72f857443731fc6e4237756a9f89489e9a", "message": "Remove obsolete OptionalUtils\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:12Z", "type": "commit"}, {"oid": "82d120ed70b12ee69956a7693afaa03d541b91d4", "url": "https://github.com/openhab/openhab-addons/commit/82d120ed70b12ee69956a7693afaa03d541b91d4", "message": "Remove deprecated author tag\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:12Z", "type": "commit"}, {"oid": "ae1420931aa0f964f65c2286f1a04d960c88f524", "url": "https://github.com/openhab/openhab-addons/commit/ae1420931aa0f964f65c2286f1a04d960c88f524", "message": "Removed obsolete config description\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:12Z", "type": "commit"}, {"oid": "2eb9762fa421b120cf749a70487dca7c7322c5df", "url": "https://github.com/openhab/openhab-addons/commit/2eb9762fa421b120cf749a70487dca7c7322c5df", "message": "Capitalize and shorten labels\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:12Z", "type": "commit"}, {"oid": "39d26bd56a84411647c37696f61b027ebc1a96e1", "url": "https://github.com/openhab/openhab-addons/commit/39d26bd56a84411647c37696f61b027ebc1a96e1", "message": "Use required attribute instead of tag\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:12Z", "type": "commit"}, {"oid": "7e54fefb8b3321dc1ffcb451b334d0b8b865cd0c", "url": "https://github.com/openhab/openhab-addons/commit/7e54fefb8b3321dc1ffcb451b334d0b8b865cd0c", "message": "Use Number instead of Number:Time\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:12Z", "type": "commit"}, {"oid": "84b365c248a34771eba9450d845cc90689951ca1", "url": "https://github.com/openhab/openhab-addons/commit/84b365c248a34771eba9450d845cc90689951ca1", "message": "Use Number:Temperature type for temperatures\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:12Z", "type": "commit"}, {"oid": "3ff53fc99c151631288207d14f040e0075f49c29", "url": "https://github.com/openhab/openhab-addons/commit/3ff53fc99c151631288207d14f040e0075f49c29", "message": "Error message for transient HTTP errors\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:13Z", "type": "commit"}, {"oid": "79a40264ed1855b6f0df1ba602446e4d3fd8980a", "url": "https://github.com/openhab/openhab-addons/commit/79a40264ed1855b6f0df1ba602446e4d3fd8980a", "message": "Remove minified js and css files\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:13Z", "type": "commit"}, {"oid": "c429eab7b13b771b370f2c14f2cc6d1431963328", "url": "https://github.com/openhab/openhab-addons/commit/c429eab7b13b771b370f2c14f2cc6d1431963328", "message": "Fix some build warnings\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:13Z", "type": "commit"}, {"oid": "c2cd6d1b61baca01d93633e673316807f808fea0", "url": "https://github.com/openhab/openhab-addons/commit/c2cd6d1b61baca01d93633e673316807f808fea0", "message": "Remove access token from auto pairing\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:13Z", "type": "commit"}, {"oid": "4ab527d89d55fa6c1e9a7f248755e4c92921298f", "url": "https://github.com/openhab/openhab-addons/commit/4ab527d89d55fa6c1e9a7f248755e4c92921298f", "message": "Fix typo in README\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:13Z", "type": "commit"}, {"oid": "4241badba86eb6cdb4932e79f4630d0b35808d3d", "url": "https://github.com/openhab/openhab-addons/commit/4241badba86eb6cdb4932e79f4630d0b35808d3d", "message": "Added acknowledgement note to README\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:13Z", "type": "commit"}, {"oid": "1825e14733a219cdacd1a7563285e163f0751e8b", "url": "https://github.com/openhab/openhab-addons/commit/1825e14733a219cdacd1a7563285e163f0751e8b", "message": "Use DEBUG/WARN rather than INFO log level\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:13Z", "type": "commit"}, {"oid": "5894439dfb2f5adf639c8b4cb9de582f80a66cde", "url": "https://github.com/openhab/openhab-addons/commit/5894439dfb2f5adf639c8b4cb9de582f80a66cde", "message": "Additional logging for Retry-After parsing\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:13Z", "type": "commit"}, {"oid": "1b895b5d3c4268b7b0d8d034124f7c0a688335d1", "url": "https://github.com/openhab/openhab-addons/commit/1b895b5d3c4268b7b0d8d034124f7c0a688335d1", "message": "Limit retry connect interval in all cases\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:13Z", "type": "commit"}, {"oid": "81ff50db25f6af9b34ac6fdeec6dce282a1cf30a", "url": "https://github.com/openhab/openhab-addons/commit/81ff50db25f6af9b34ac6fdeec6dce282a1cf30a", "message": "Add test for Retry-After header exceeding maximum SSE reconnect wait time\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:14Z", "type": "commit"}, {"oid": "d5c9d14e7603363097a7467a1f88f6222bdd4d5a", "url": "https://github.com/openhab/openhab-addons/commit/d5c9d14e7603363097a7467a1f88f6222bdd4d5a", "message": "Remove outdated information from README\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:14Z", "type": "commit"}, {"oid": "65e80aabf4acb252d919860bacfc194e8ab19b2f", "url": "https://github.com/openhab/openhab-addons/commit/65e80aabf4acb252d919860bacfc194e8ab19b2f", "message": "Upgrade to openHAB 3.1.0\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:14Z", "type": "commit"}, {"oid": "b9d1a64ceb43ec655e07c61ff4d57190fe14a6ff", "url": "https://github.com/openhab/openhab-addons/commit/b9d1a64ceb43ec655e07c61ff4d57190fe14a6ff", "message": "Conditional logging on enabled debug\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:14Z", "type": "commit"}, {"oid": "bd29b93c7f722ef638c4a6e461995973cbdb2bd3", "url": "https://github.com/openhab/openhab-addons/commit/bd29b93c7f722ef638c4a6e461995973cbdb2bd3", "message": "Use static final Gson\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:14Z", "type": "commit"}, {"oid": "4b54d7e835ea2373da55141dc7fc6ba7dee3f1fd", "url": "https://github.com/openhab/openhab-addons/commit/4b54d7e835ea2373da55141dc7fc6ba7dee3f1fd", "message": "Nullable annotation as part of the type\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:14Z", "type": "commit"}, {"oid": "16273c3d09072cacb1daedf739c16b77b0d4027a", "url": "https://github.com/openhab/openhab-addons/commit/16273c3d09072cacb1daedf739c16b77b0d4027a", "message": "Consistent use of StringBuilder in ThingsTemplateGenerator\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:14Z", "type": "commit"}, {"oid": "543538e42c2e97f65c3879771e66745418bd5b55", "url": "https://github.com/openhab/openhab-addons/commit/543538e42c2e97f65c3879771e66745418bd5b55", "message": "Include cause exception\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:15Z", "type": "commit"}, {"oid": "f5154e662b289b1201d3ffa6905e8ca658087807", "url": "https://github.com/openhab/openhab-addons/commit/f5154e662b289b1201d3ffa6905e8ca658087807", "message": "Include cause message\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:15Z", "type": "commit"}, {"oid": "687408eda5f72af0acabc831e5e7fc49802e8c73", "url": "https://github.com/openhab/openhab-addons/commit/687408eda5f72af0acabc831e5e7fc49802e8c73", "message": "More nullable annotations on types\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:15Z", "type": "commit"}, {"oid": "e9058d6e200ad4231678d8d2b6b7017a23edcf2c", "url": "https://github.com/openhab/openhab-addons/commit/e9058d6e200ad4231678d8d2b6b7017a23edcf2c", "message": "Fix unit tests broken by logging adaption\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:15Z", "type": "commit"}, {"oid": "dbe28869b4aa7b412eb59c4521a0463cd05afe46", "url": "https://github.com/openhab/openhab-addons/commit/dbe28869b4aa7b412eb59c4521a0463cd05afe46", "message": "Fix logging performance warning\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:15Z", "type": "commit"}, {"oid": "da95ff1b92f8439f518057fb696379d701fb2176", "url": "https://github.com/openhab/openhab-addons/commit/da95ff1b92f8439f518057fb696379d701fb2176", "message": "Update integration test run configuration\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:15Z", "type": "commit"}, {"oid": "dde3d3c2aebf58e09c27fa2bd0e4c575d042654d", "url": "https://github.com/openhab/openhab-addons/commit/dde3d3c2aebf58e09c27fa2bd0e4c575d042654d", "message": "Remove logo from README\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:15Z", "type": "commit"}, {"oid": "0254fe5a4a96ec93501e5a4cce9d43ad76f07a8d", "url": "https://github.com/openhab/openhab-addons/commit/0254fe5a4a96ec93501e5a4cce9d43ad76f07a8d", "message": "Remove example thing file in favor of full example\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:15Z", "type": "commit"}, {"oid": "abf424781d122a8bb2592d302fa4fcccd8f224b4", "url": "https://github.com/openhab/openhab-addons/commit/abf424781d122a8bb2592d302fa4fcccd8f224b4", "message": "Remove outdated note about locale parameter\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:16Z", "type": "commit"}, {"oid": "f9ab516b4ee0cc5523793e89102e660a9292c47d", "url": "https://github.com/openhab/openhab-addons/commit/f9ab516b4ee0cc5523793e89102e660a9292c47d", "message": "Remove other ithings file example\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:16Z", "type": "commit"}, {"oid": "e183560efc0eec480346b3df95af0b42405a7e51", "url": "https://github.com/openhab/openhab-addons/commit/e183560efc0eec480346b3df95af0b42405a7e51", "message": "Add table with technical thing types\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:16Z", "type": "commit"}, {"oid": "3ca02d4bee92ffa8676492d309a9f49b47a5bf86", "url": "https://github.com/openhab/openhab-addons/commit/3ca02d4bee92ffa8676492d309a9f49b47a5bf86", "message": "Remove warning logs when account is not authorized\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:16Z", "type": "commit"}, {"oid": "46bb587c3c4b0707de8c641e9cde0ddb1e20e989", "url": "https://github.com/openhab/openhab-addons/commit/46bb587c3c4b0707de8c641e9cde0ddb1e20e989", "message": "Things use just OFFLINE if the reason is unclear\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:16Z", "type": "commit"}, {"oid": "ce1035897bae30b41d48c2f76b2222c1737a663b", "url": "https://github.com/openhab/openhab-addons/commit/ce1035897bae30b41d48c2f76b2222c1737a663b", "message": "Remove updateStatus workaround\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:16Z", "type": "commit"}, {"oid": "519887434b40e6cd1ee8b62420d0de159fd948f7", "url": "https://github.com/openhab/openhab-addons/commit/519887434b40e6cd1ee8b62420d0de159fd948f7", "message": "handleConfigurationUpdate reinitializes the bridge\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:16Z", "type": "commit"}, {"oid": "594c94050ae5ea63da5b487e5494447e9a725e2a", "url": "https://github.com/openhab/openhab-addons/commit/594c94050ae5ea63da5b487e5494447e9a725e2a", "message": "Locale parameter is not required\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T08:09:16Z", "type": "commit"}, {"oid": "7389bf95fdc222311add5222c3cb70c4489a1126", "url": "https://github.com/openhab/openhab-addons/commit/7389bf95fdc222311add5222c3cb70c4489a1126", "message": "Add required e-mail address config param\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T11:14:15Z", "type": "forcePushed"}, {"oid": "7389bf95fdc222311add5222c3cb70c4489a1126", "url": "https://github.com/openhab/openhab-addons/commit/7389bf95fdc222311add5222c3cb70c4489a1126", "message": "Add required e-mail address config param\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T11:14:15Z", "type": "commit"}, {"oid": "ffcb467b08829915b4e30138bb4db21e6e046310", "url": "https://github.com/openhab/openhab-addons/commit/ffcb467b08829915b4e30138bb4db21e6e046310", "message": "Add device identifier config param\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T12:25:52Z", "type": "commit"}, {"oid": "2bd65a62b67e5ad324b4fbf026d8fc47340af627", "url": "https://github.com/openhab/openhab-addons/commit/2bd65a62b67e5ad324b4fbf026d8fc47340af627", "message": "Do not call framework methods for reinit\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-21T12:40:26Z", "type": "commit"}, {"oid": "9d522960deaf170bed5004973aa68bd5e961d3f2", "url": "https://github.com/openhab/openhab-addons/commit/9d522960deaf170bed5004973aa68bd5e961d3f2", "message": "Add integration test for e-mail address validity\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-25T05:34:45Z", "type": "commit"}, {"oid": "2f3d31bf33b35d8cf659fcc4d3f964572a31180d", "url": "https://github.com/openhab/openhab-addons/commit/2f3d31bf33b35d8cf659fcc4d3f964572a31180d", "message": "Update documentation\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-25T07:56:16Z", "type": "forcePushed"}, {"oid": "2f3d31bf33b35d8cf659fcc4d3f964572a31180d", "url": "https://github.com/openhab/openhab-addons/commit/2f3d31bf33b35d8cf659fcc4d3f964572a31180d", "message": "Update documentation\n\nAlso-by: Bert Plonus <bert.plonus@miele.com>\nAlso-by: Martin Lepsy <martin.lepsy@miele.com>\nAlso-by: Benjamin Bolte <benjamin.bolte@itemis.de>\nSigned-off-by: Bj\u00f6rn Lange <bjoern.lange@itemis.de>", "committedDate": "2021-05-25T07:56:16Z", "type": "commit"}]}