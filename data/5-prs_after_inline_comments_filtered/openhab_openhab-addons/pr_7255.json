{"pr_number": 7255, "pr_title": "[miio]  Add Xiaomi cloud logon (token download) and map download", "pr_createdAt": "2020-03-29T21:46:23Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7255", "timeline": [{"oid": "13976de829f08bc18d34b94c02768d9bae599f56", "url": "https://github.com/openhab/openhab-addons/commit/13976de829f08bc18d34b94c02768d9bae599f56", "message": "[miio] Squash/rebase Xiaomi cloud logon and map download\n[miio] WIP cloudlogon to get device tokens and map\n[miio] save server responses\n[miio] cloudstuff cleanup\n[miio] Cloud - more updates map download\n[miio] WIP get vacuum map from cloud\n[miio] WIP get tokens from cloud\n[miio] WIP output vacuum image\n[miio] first working  version with map and tokens from cloud\n[miio] improvements map downloads\n[miio] improve map decoding\n[miio] finalized map drawing logic\n[miio] 2nd alpha version cloud+map funcionality\n[miio] fixing spotbugs issues\n[miio] more spot bug issues resolving\n[miio] improved map reading\n[miio] map version 1.1\n[miio] cleanup many notnullbydefault issues alpha release3\n[miio] cleaning cloudconnector\n[miio] alpha release 3\n[mio] cached logons\n[miio] small cleanup\n[miio] minor fix text drawing\n[miio] alpha 4\n[miio] new models added\n[miio] Improve path color\n[miio] generic county request\n[miio] mapviewer cleanup\n[miio] log levels adjustment\n[miio] update readme\n\nSigned-off-by: Marcel Verpaalen marcel@verpaalen.com", "committedDate": "2020-03-29T21:42:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzMzQyMA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399933420", "bodyText": "Why does this need the NonNullByDefault annotation? It is already non-null.", "author": "cpmeister", "createdAt": "2020-03-30T05:23:08Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/MiIoHandlerFactory.java", "diffHunk": "@@ -41,10 +46,27 @@\n public class MiIoHandlerFactory extends BaseThingHandlerFactory {\n \n     private MiIoDatabaseWatchService miIoDatabaseWatchService;\n+    private @NonNullByDefault({}) HttpClient httpClient;", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA1NTQ1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r400055452", "bodyText": "ah, I think it is remaining from the time the class was not yet NonNullByDefault..\nI'll remove it", "author": "marcelrv", "createdAt": "2020-03-30T09:37:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzMzQyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzMzgzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399933830", "bodyText": "Instead of a singleton instance I would prefer you make this an OSGI component instead.", "author": "cpmeister", "createdAt": "2020-03-30T05:24:44Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/CloudConnector.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.jetbrains.annotations.NotNull;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link CloudConnector} is responsible for connecting OH to the Xiaomi cloud communication.\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class CloudConnector {\n+\n+    protected static final long CACHE_EXPIRY = TimeUnit.SECONDS.toMillis(60);\n+    private static final int FAILED = -1;\n+    private static final int STARTING = 0;\n+    private static final int REFRESHING = 1;\n+    private static final int AVAILABLE = 2;\n+    private int deviceListState = STARTING;\n+\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String country = \"ru,us,tw,sg,cn,de\";\n+\n+    private List<JsonObject> deviceList = new ArrayList<JsonObject>();\n+    private final JsonParser parser = new JsonParser();\n+    private boolean connected;\n+\n+    private @Nullable HttpClient httpClient;\n+\n+    private @Nullable MiCloudConnector cloudConnector;\n+    public static final CloudConnector CC_INSTANCE = new CloudConnector();", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDkwOTU1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r400909553", "bodyText": "gave that a shot.. seems indeed to work. Not sure if I understand if I need to make it a service or not. For now it appears to work as just a component", "author": "marcelrv", "createdAt": "2020-03-31T13:23:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzMzgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzNDMzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399934331", "bodyText": "please remove this blank line.", "author": "cpmeister", "createdAt": "2020-03-30T05:26:42Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/CloudConnector.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.jetbrains.annotations.NotNull;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link CloudConnector} is responsible for connecting OH to the Xiaomi cloud communication.\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class CloudConnector {\n+\n+    protected static final long CACHE_EXPIRY = TimeUnit.SECONDS.toMillis(60);\n+    private static final int FAILED = -1;\n+    private static final int STARTING = 0;\n+    private static final int REFRESHING = 1;\n+    private static final int AVAILABLE = 2;\n+    private int deviceListState = STARTING;\n+\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String country = \"ru,us,tw,sg,cn,de\";\n+\n+    private List<JsonObject> deviceList = new ArrayList<JsonObject>();\n+    private final JsonParser parser = new JsonParser();\n+    private boolean connected;\n+\n+    private @Nullable HttpClient httpClient;\n+\n+    private @Nullable MiCloudConnector cloudConnector;\n+    public static final CloudConnector CC_INSTANCE = new CloudConnector();\n+    private final Logger logger = LoggerFactory.getLogger(CloudConnector.class);\n+\n+    private ExpiringCache<Boolean> logonCache = new ExpiringCache<Boolean>(CACHE_EXPIRY, () -> {\n+        return logon();\n+    });\n+\n+    private ExpiringCache<String> refreshDeviceList = new ExpiringCache<String>(CACHE_EXPIRY, () -> {\n+        if (deviceListState == FAILED && !isConnected()) {\n+            return (\"Could not connect to Xiaomi cloud\");\n+        }\n+        final @Nullable MiCloudConnector cl = this.cloudConnector;\n+        if (cl == null) {\n+            return (\"Could not connect to Xiaomi cloud\");\n+        }\n+        deviceListState = REFRESHING;\n+        deviceList.clear();\n+        for (String server : country.split(\",\")) {\n+            try {\n+                JsonElement response = parser.parse(cl.getDevices(server));\n+                if (response.isJsonObject() && response.getAsJsonObject().has(\"result\")\n+                        && response.getAsJsonObject().get(\"result\").isJsonObject()) {\n+                    JsonObject result = response.getAsJsonObject().get(\"result\").getAsJsonObject();\n+                    result.addProperty(\"server\", server);\n+                    deviceList.add(result);\n+                }\n+            } catch (JsonParseException e) {\n+                logger.debug(\"Parsing error getting devices: {}\", e.getMessage());\n+            }\n+        }\n+        deviceListState = AVAILABLE;\n+        return \"done\";// deviceList;\n+    });\n+\n+    private CloudConnector() {\n+    }\n+\n+    public static CloudConnector getInstance() {\n+        return CC_INSTANCE;\n+    }\n+\n+    public boolean isConnected() {\n+        final MiCloudConnector cl = cloudConnector;\n+        if (cl != null && cl.hasLoginToken()) {\n+            return true;\n+        }\n+        final @Nullable Boolean c = logonCache.getValue();\n+        if (c != null && c.booleanValue()) {\n+            return true;\n+        }\n+        deviceListState = FAILED;\n+        return false;\n+    }\n+\n+    public byte[] getMap(String mapId, String country) throws MiCloudException {\n+        logger.info(\"Getting vacuum map {} from Xiaomi cloud server: {}\", mapId, country);\n+        String mapCountry;\n+        String mapUrl = \"\";\n+        final @Nullable MiCloudConnector cl = this.cloudConnector;\n+        if (cl == null || !isConnected()) {\n+            throw new MiCloudException(\"Cannot execute request. Cloudservice not available\");\n+        }\n+        if (country.isEmpty()) {\n+            // TODO: pick the right server in a more intelligent way\n+            logger.debug(\"Server not defined in thing. Trying servers: {}\", this.country);\n+            for (String mapCountryServer : this.country.split(\",\")) {\n+                ;\n+                mapCountry = mapCountryServer.trim().toLowerCase();\n+                mapUrl = cl.getMapUrl(mapId, mapCountry);\n+                logger.debug(\"Map download from server {} returned {}\", mapCountry, mapUrl);\n+\n+                if (!mapUrl.isEmpty()) {\n+                    break;\n+                }\n+            }\n+        } else {\n+            mapCountry = country.trim().toLowerCase();\n+            mapUrl = cl.getMapUrl(mapId, mapCountry);\n+        }\n+        byte[] mapData = HttpUtil.downloadData(mapUrl, null, false, -1).getBytes();\n+        return mapData;\n+    }\n+\n+    public void setCredentials(@Nullable String username, @Nullable String password, @Nullable String country) {\n+        if (country != null) {\n+            this.country = country;\n+        }\n+        if (username != null && password != null) {\n+            this.username = username;\n+            this.password = password;\n+            logon();\n+        }\n+    }\n+\n+    public void setHttpClient(@NotNull HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+    }\n+\n+    private boolean logon() {\n+        if (username.isEmpty() || password.isEmpty()) {\n+            logger.info(\"No Xiaomi cloud credentials. Cloud connectivity diabled\");\n+            logger.debug(\"Username: {} pass: {}, country:{}\", username, password.replaceAll(\".\", \"*\"), country);\n+            return connected;\n+        }\n+        final HttpClient httpClient = this.httpClient;\n+        if (httpClient != null) {\n+            try {\n+                final MiCloudConnector cl = new MiCloudConnector(username, password, httpClient);\n+                this.cloudConnector = cl;\n+                connected = cl.login();\n+                if (connected) {\n+                    getDevicesList();\n+                } else {\n+                    deviceListState = FAILED;\n+                }\n+            } catch (MiCloudException e) {\n+                connected = false;\n+                deviceListState = FAILED;\n+                logger.debug(\"Xiaomi cloud login failed: {}\", e.getMessage());\n+            }\n+        } else {\n+            logger.info(\"HTTP client not set. Cloud connectivity diabled\");\n+            connected = false;\n+            deviceListState = FAILED;\n+        }\n+        return connected;\n+    }\n+\n+    public List<JsonObject> getDevicesList() {\n+        refreshDeviceList.getValue();\n+        return deviceList;\n+", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzNDcwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399934703", "bodyText": "Make sure to include the cause exception.", "author": "cpmeister", "createdAt": "2020-03-30T05:28:05Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/CloudCrypto.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.security.InvalidKeyException;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Base64;\n+\n+import javax.crypto.Mac;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.miio.internal.MiIoCryptoException;\n+\n+/**\n+ * The {@link CloudCrypto} is responsible for encryption for Xiaomi cloud communication.\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class CloudCrypto {\n+\n+    /**\n+     * Compute SHA256 hash value for the byte array\n+     *\n+     * @param inBytes ByteArray to be hashed\n+     * @return BASE64 encoded hash value\n+     * @throws MiIoCryptoException\n+     */\n+    public static String sha256Hash(byte[] inBytes) throws MiIoCryptoException {\n+        try {\n+            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n+            return Base64.getEncoder().encodeToString(md.digest(inBytes));\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new MiIoCryptoException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Compute HmacSHA256 hash value for the byte array\n+     *\n+     * @param key for encoding\n+     * @param cipherText ByteArray to be encoded\n+     * @return BASE64 encoded hash value\n+     * @throws MiIoCryptoException\n+     */\n+    public static String hMacSha256Encode(byte[] key, byte[] cipherText) throws MiIoCryptoException {\n+        try {\n+            Mac sha256Hmac = Mac.getInstance(\"HmacSHA256\");\n+            SecretKeySpec secretKey = new SecretKeySpec(key, \"HmacSHA256\");\n+            sha256Hmac.init(secretKey);\n+            return Base64.getEncoder().encodeToString(sha256Hmac.doFinal(cipherText));\n+        } catch (NoSuchAlgorithmException | InvalidKeyException e) {\n+            throw new MiIoCryptoException(e.getMessage());", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDkwMzIxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r400903216", "bodyText": "I'm not sure if I understand what you mean with this.", "author": "marcelrv", "createdAt": "2020-03-31T13:14:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzNDcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDkwNzE0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r400907146", "bodyText": "Do you mean I should make add a\n    public MiCloudException(String arg0, Exception e) {\n        super(arg0, e);\n    }\n\nand pass the exception as well?", "author": "marcelrv", "createdAt": "2020-03-31T13:20:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzNDcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI0OTU4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r401249585", "bodyText": "Yep, that is exactly what I mean. I guess I should have been clearer though", "author": "cpmeister", "createdAt": "2020-03-31T22:20:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzNDcwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzNDc1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399934759", "bodyText": "Make sure to include the cause exception", "author": "cpmeister", "createdAt": "2020-03-30T05:28:22Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/CloudCrypto.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.security.InvalidKeyException;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Base64;\n+\n+import javax.crypto.Mac;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.miio.internal.MiIoCryptoException;\n+\n+/**\n+ * The {@link CloudCrypto} is responsible for encryption for Xiaomi cloud communication.\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class CloudCrypto {\n+\n+    /**\n+     * Compute SHA256 hash value for the byte array\n+     *\n+     * @param inBytes ByteArray to be hashed\n+     * @return BASE64 encoded hash value\n+     * @throws MiIoCryptoException\n+     */\n+    public static String sha256Hash(byte[] inBytes) throws MiIoCryptoException {\n+        try {\n+            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n+            return Base64.getEncoder().encodeToString(md.digest(inBytes));\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new MiIoCryptoException(e.getMessage());", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzNDk1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399934957", "bodyText": "Please catch specific exceptions.", "author": "cpmeister", "createdAt": "2020-03-30T05:28:59Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/CloudUtil.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.openhab.binding.miio.internal.MiIoBindingConstants;\n+import org.openhab.binding.miio.internal.MiIoCryptoException;\n+import org.slf4j.Logger;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link CloudUtil} class is used for supporting functions for Xiaomi cloud access\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class CloudUtil {\n+\n+    private static final Random RANDOM = new Random();\n+\n+    public static String getElementString(JsonElement jsonElement, String element, Logger logger) {\n+        String value = \"\";\n+        try {\n+            value = jsonElement.getAsJsonObject().get(element).getAsString();\n+        } catch (Exception e) {", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzNjgyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399936828", "bodyText": "Can this be made private?", "author": "cpmeister", "createdAt": "2020-03-30T05:35:57Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/MiCloudConnector.java", "diffHunk": "@@ -0,0 +1,468 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.io.IOException;\n+import java.net.CookieStore;\n+import java.net.HttpCookie;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpResponseException;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.FormContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.util.Fields;\n+import org.openhab.binding.miio.internal.MiIoCrypto;\n+import org.openhab.binding.miio.internal.MiIoCryptoException;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MiCloudConnector} class is used for connecting to the Xiaomi cloud access\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MiCloudConnector {\n+\n+    private static final int REQUEST_TIMEOUT_SECONDS = 10;\n+    private static final String UNEXPECTED = \"Unexpected :\";\n+    private static final String AGENT_ID = (new Random().ints(65, 70).limit(13)\n+            .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    private static final String USERAGENT = \"Android-7.1.1-1.0.0-ONEPLUS A3010-136-\" + AGENT_ID\n+            + \" APP/xiaomi.smarthome APPV/62830\";\n+    private final JsonParser parser = new JsonParser();\n+\n+    // String\n+    private String username;\n+    private String password;\n+\n+    private final String clientId;\n+    private String userId = \"\";\n+    private String serviceToken = \"\";\n+    private String ssecurity = \"\";\n+    int loginFailedCounter = 0;", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzNzc3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399937770", "bodyText": "remove blank line", "author": "cpmeister", "createdAt": "2020-03-30T05:39:41Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/MiCloudConnector.java", "diffHunk": "@@ -0,0 +1,468 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.io.IOException;\n+import java.net.CookieStore;\n+import java.net.HttpCookie;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpResponseException;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.FormContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.util.Fields;\n+import org.openhab.binding.miio.internal.MiIoCrypto;\n+import org.openhab.binding.miio.internal.MiIoCryptoException;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MiCloudConnector} class is used for connecting to the Xiaomi cloud access\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MiCloudConnector {\n+\n+    private static final int REQUEST_TIMEOUT_SECONDS = 10;\n+    private static final String UNEXPECTED = \"Unexpected :\";\n+    private static final String AGENT_ID = (new Random().ints(65, 70).limit(13)\n+            .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    private static final String USERAGENT = \"Android-7.1.1-1.0.0-ONEPLUS A3010-136-\" + AGENT_ID\n+            + \" APP/xiaomi.smarthome APPV/62830\";\n+    private final JsonParser parser = new JsonParser();\n+\n+    // String\n+    private String username;\n+    private String password;\n+\n+    private final String clientId;\n+    private String userId = \"\";\n+    private String serviceToken = \"\";\n+    private String ssecurity = \"\";\n+    int loginFailedCounter = 0;\n+\n+    private HttpClient httpClient;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MiCloudConnector.class);\n+\n+    public MiCloudConnector(String username, String password, HttpClient httpClient) throws MiCloudException {\n+        this.username = username;\n+        this.password = password;\n+        this.httpClient = httpClient;\n+        if (!checkCredentials()) {\n+            throw new MiCloudException(\"username or password can't be empty\");\n+        }\n+        clientId = (new Random().ints(97, 122 + 1).limit(6)\n+                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    }\n+\n+    void startClient() throws MiCloudException {\n+        if (!httpClient.isStarted()) {\n+            try {\n+                httpClient.start();\n+                // set default cookies\n+                CookieStore cookieStore = httpClient.getCookieStore();\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"mi.com\");\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"xiaomi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"mi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"xiaomi.com\");\n+            } catch (Exception e) {\n+                throw new MiCloudException(\"No http client cannot be started: \" + e.getMessage());\n+            }\n+        }\n+    }\n+\n+    public void stopClient() {\n+        try {\n+            this.httpClient.stop();\n+        } catch (Exception e) {\n+            logger.debug(\"Error stopping httpclient :{}\", e.getMessage());\n+        }\n+    }\n+\n+    private boolean checkCredentials() {\n+        if (username.trim().isEmpty() || password.trim().isEmpty()) {\n+            logger.info(\"Xiaomi Cloud: username or password missing.\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private String getApiUrl(String country) {\n+        return \"https://\" + (country.trim().equalsIgnoreCase(\"cn\") ? \"\" : country.trim().toLowerCase() + \".\")\n+                + \"api.io.mi.com/app\";\n+    }\n+\n+    public String getClientId() {\n+        return clientId;\n+    }\n+\n+    String parseJson(String data) {\n+        if (data.contains(\"&&&START&&&\")) {\n+            return data.replace(\"&&&START&&&\", \"\");\n+        } else {\n+            return UNEXPECTED.concat(data);\n+        }\n+    }\n+\n+    public String getMapUrl(String vacuumMap, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/getmapfileurl\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"obj_name\\\":\\\"\" + vacuumMap + \"\\\"}\");\n+        String mapResponse = request(url, map);\n+        logger.trace(\"response: {}\", mapResponse);\n+        String errorMsg = \"\";\n+        JsonElement response = parser.parse(mapResponse);\n+        if (response.isJsonObject()) {\n+            logger.debug(\"Received  JSON message {}\", response.toString());\n+            if (response.getAsJsonObject().has(\"result\") && response.getAsJsonObject().get(\"result\").isJsonObject()) {\n+                JsonObject jo = response.getAsJsonObject().get(\"result\").getAsJsonObject();\n+                if (jo.has(\"url\")) {\n+                    return jo.get(\"url\").getAsString();\n+                } else {\n+                    errorMsg = \"Could not get url\";\n+                }\n+            } else {\n+                errorMsg = \"Could not get result\";\n+            }\n+        } else {\n+            errorMsg = \"Received message is invalid JSON\";\n+        }\n+        logger.debug(\"{}: {}\", errorMsg, mapResponse);\n+        return \"\";\n+    }\n+\n+    public String getDeviceStatus(String device, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"dids\\\":[\\\"\" + device + \"\\\"]}\");\n+        logger.debug(\"response: {}\", request(url, map));\n+        return \"\";\n+    }\n+\n+    public String getLatest(String model, String country) {\n+        String url = getApiUrl(country) + \"/home/latest_version\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"model\\\":\\\"\" + model + \"\\\"}\");\n+        String resp;\n+        try {\n+            resp = request(url, map);\n+            logger.debug(\"Response: {}\", resp);\n+            // CloudUtil.printDevices(resp, logger);\n+            if (resp.length() > 2) {\n+                // CloudUtil.saveFile(resp, country, logger);\n+                return resp;\n+            }\n+        } catch (MiCloudException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+            return \"\";\n+        }\n+        return \"\";\n+    }\n+\n+    public String getDevices(String country) {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"getVirtualModel\\\":false,\\\"getHuamiDevices\\\":0}\");\n+        String resp;\n+        try {\n+            resp = request(url, map);\n+            logger.trace(\"Get devices response: {}\", resp);\n+            CloudUtil.printDevices(resp, country, logger);\n+            if (resp.length() > 2) {\n+                CloudUtil.saveFile(resp, country, logger);\n+                return resp;\n+            }\n+        } catch (MiCloudException e) {\n+            logger.info(\"{}\", e.getMessage());\n+        }\n+        return \"\";\n+    }\n+\n+    public String request(String urlPart, String country, Map<String, String> params) throws MiCloudException {\n+        String url = getApiUrl(country) + urlPart;\n+        String response = request(url, params);\n+        logger.debug(\"Request to {} server {}. Response: {}\", country, urlPart, response);\n+        return response;\n+    }\n+\n+    public String request(String url, Map<String, String> params) throws MiCloudException {\n+        if (this.serviceToken.isEmpty() || this.userId.isEmpty()) {\n+            throw new MiCloudException(\"Cannot execute request. service token or userId missing\");\n+        }\n+        try {\n+            startClient();\n+        } catch (Exception e) {\n+            throw new MiCloudException(\"Cannot Execute request. service token or userId missing\" + e.getMessage());\n+        }\n+        logger.debug(\"Send request: {} to {}\", params.get(\"data\"), url);\n+        Request request = httpClient.newRequest(url).timeout(REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        request.agent(USERAGENT);\n+        request.header(\"x-xiaomi-protocal-flag-cli\", \"PROTOCAL-HTTP2\");\n+        request.header(HttpHeader.CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n+        request.cookie(new HttpCookie(\"userId\", this.userId));\n+        request.cookie(new HttpCookie(\"yetAnotherServiceToken\", this.serviceToken));\n+        request.cookie(new HttpCookie(\"serviceToken\", this.serviceToken));\n+        request.cookie(new HttpCookie(\"locale\", \"uk_GB\"));\n+        request.cookie(new HttpCookie(\"timezone\", \"GMT%2B01%3A00\"));\n+        request.cookie(new HttpCookie(\"is_daylight\", \"1\"));\n+        request.cookie(new HttpCookie(\"dst_offset\", \"3600000\"));\n+        request.cookie(new HttpCookie(\"channel\", \"MI_APP_STORE\"));\n+\n+        for (HttpCookie cookie : request.getCookies()) {\n+            logger.trace(\"Cookie set for request ({}) : {} --> {}     (path: {})\", cookie.getDomain(), cookie.getName(),\n+                    cookie.getValue(), cookie.getPath());\n+        }\n+        String method = \"POST\";\n+        request.method(method);\n+\n+        try {\n+            String nonce = CloudUtil.generateNonce(System.currentTimeMillis());\n+            String signedNonce = CloudUtil.signedNonce(ssecurity, nonce);\n+            String signature = CloudUtil.generateSignature(url.replace(\"/app\", \"\"), signedNonce, nonce, params);\n+\n+            Fields fields = new Fields();\n+            fields.put(\"signature\", signature);\n+            fields.put(\"_nonce\", nonce);\n+            fields.put(\"data\", params.get(\"data\"));\n+            request.content(new FormContentProvider(fields));\n+\n+            logger.trace(\"fieldcontent: {}\", fields.toString());\n+            final ContentResponse response = request.send();\n+            return response.getContentAsString();\n+        } catch (HttpResponseException e) {\n+            serviceToken = \"\";\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (ExecutionException e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (IOException e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (MiIoCryptoException e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage(), e);\n+        } catch (Exception e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage(), e);\n+        }\n+        return \"\";\n+    }\n+\n+    private void addCookie(CookieStore cookieStore, String name, String value, String domain) {\n+        HttpCookie cookie = new HttpCookie(name, value);\n+        cookie.setDomain(\".\" + domain);\n+        cookie.setPath(\"/\");\n+        cookieStore.add(URI.create(\"https://\" + domain), cookie);\n+    }\n+\n+    // TODO: better way instead of blocking ?\n+    public synchronized boolean login() {\n+        if (!checkCredentials()) {\n+            return false;\n+        }\n+        if (!userId.isEmpty() && !serviceToken.isEmpty()) {\n+            return true;\n+        }\n+        logger.debug(\"Xiaomi cloud login with userid {}\", username);\n+        try {\n+            if (loginRequest()) {\n+                loginFailedCounter = 0;\n+            } else {\n+                loginFailedCounter++;\n+                logger.debug(\"Xiaomi cloud login attempt {}\", loginFailedCounter);\n+            }\n+        } catch (MiCloudException e) {\n+            logger.info(\"Error logging on to Xiaomi cloud ({}): {}\", loginFailedCounter, e.getMessage());\n+            loginFailedCounter++;\n+            serviceToken = \"\";\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    protected boolean loginRequest() throws MiCloudException {\n+        try {\n+            startClient();\n+            String sign = loginStep1();\n+            String location = loginStep2(sign);\n+            final ContentResponse responseStep3 = loginStep3(location);\n+\n+            switch (responseStep3.getStatus()) {\n+                case HttpStatus.FORBIDDEN_403:\n+                    throw new MiCloudException(\"Access denied. Did you set the correct api-key and/or username?\");\n+                case HttpStatus.OK_200:\n+                    return true;\n+                default:\n+                    logger.trace(\"request returned status '{}', reason: {}, content = {}\", responseStep3.getStatus(),\n+                            responseStep3.getReason(), responseStep3.getContentAsString());\n+                    throw new MiCloudException(responseStep3.getStatus() + responseStep3.getReason());\n+            }\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new MiCloudException(\"Cannot logon to Xiaomi cloud: \" + e.getMessage());\n+        } catch (MiIoCryptoException e) {\n+            throw new MiCloudException(\"Error decrypting. Cannot logon to Xiaomi cloud: \" + e.getMessage());\n+        } catch (MalformedURLException e) {\n+            throw new MiCloudException(\"Error getting logon URL. Cannot logon to Xiaomi cloud: \" + e.getMessage());\n+        }\n+\n+    }\n+\n+    private String loginStep1() throws InterruptedException, TimeoutException, ExecutionException, MiCloudException {\n+        final ContentResponse responseStep1;\n+\n+        logger.trace(\"Xiaomi Login step 1\");\n+        String url = \"https://account.xiaomi.com/pass/serviceLogin?sid=xiaomiio&_json=true\";\n+        Request request = httpClient.newRequest(url).timeout(REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        request.agent(USERAGENT);\n+        request.header(HttpHeader.CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n+        request.cookie(new HttpCookie(\"userId\", this.userId.length() > 0 ? this.userId : this.username));\n+\n+        responseStep1 = request.send();\n+        final String content = responseStep1.getContentAsString();\n+        logger.trace(\"Xiaomi Login step 1 content response= {}\", content);\n+        logger.trace(\"Xiaomi Login step 1 response = {}\", responseStep1);\n+        try {\n+            JsonElement resp = new JsonParser().parse(parseJson(content));\n+            String sign = resp.getAsJsonObject().get(\"_sign\").getAsString();\n+            logger.trace(\"Xiaomi Login step 1 sign = {}\", sign);\n+            return sign;\n+        } catch (JsonSyntaxException e) {\n+            throw new MiCloudException(\"Error getting logon sign. Cannot parse response: \" + e.getMessage());\n+        }\n+    }\n+\n+    private String loginStep2(String sign)\n+            throws MiIoCryptoException, InterruptedException, TimeoutException, ExecutionException, MiCloudException {\n+        String passToken;\n+        String cUserId;\n+\n+        logger.trace(\"Xiaomi Login step 2\");\n+        String url = \"https://account.xiaomi.com/pass/serviceLoginAuth2\";\n+        Request request = httpClient.newRequest(url).timeout(REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        request.agent(USERAGENT);\n+        request.method(HttpMethod.POST);\n+        final ContentResponse responseStep2;\n+\n+        Fields fields = new Fields();\n+        fields.put(\"sid\", \"xiaomiio\");\n+        // fields.put(\"hash\", encodePassword(password));\n+        fields.put(\"hash\", Utils.getHex(MiIoCrypto.md5(password.getBytes())));\n+        fields.put(\"callback\", \"https://sts.api.io.mi.com/sts\");\n+        fields.put(\"qs\", \"%3Fsid%3Dxiaomiio%26_json%3Dtrue\");\n+        fields.put(\"user\", username);\n+        fields.put(\"_sign\", sign);\n+        fields.put(\"_json\", \"true\");\n+\n+        request.content(new FormContentProvider(fields));\n+        responseStep2 = request.send();\n+\n+        final String content2 = responseStep2.getContentAsString();\n+        logger.trace(\"Xiaomi login step 2 response = {}\", responseStep2);\n+        logger.trace(\"Xiaomi login step 2 content = {}\", content2);\n+\n+        JsonElement resp2 = new JsonParser().parse(parseJson(content2));\n+        ssecurity = CloudUtil.getElementString(resp2, \"ssecurity\", logger);\n+        userId = CloudUtil.getElementString(resp2, \"userId\", logger);\n+        cUserId = CloudUtil.getElementString(resp2, \"cUserId\", logger);\n+        passToken = CloudUtil.getElementString(resp2, \"passToken\", logger);\n+        String location = CloudUtil.getElementString(resp2, \"location\", logger);\n+        String code = CloudUtil.getElementString(resp2, \"code\", logger);\n+\n+        logger.trace(\"Xiaomi login ssecurity = {}\", ssecurity);\n+        logger.trace(\"Xiaomi login userId = {}\", userId);\n+        logger.trace(\"Xiaomi login cUserId = {}\", cUserId);\n+        logger.trace(\"Xiaomi login passToken = {}\", passToken);\n+        logger.trace(\"Xiaomi login location = {}\", location);\n+        logger.trace(\"Xiaomi login code = {}\", code);\n+\n+        dumpCookies(url);\n+        if (!location.isEmpty()) {\n+            return location;\n+        } else {\n+            throw new MiCloudException(\"Error getting logon location URL. Return code: \" + code);\n+        }\n+    }\n+\n+    private ContentResponse loginStep3(String location)\n+            throws MalformedURLException, InterruptedException, TimeoutException, ExecutionException {\n+        final ContentResponse responseStep3;\n+        Request request;\n+        logger.trace(\"Xiaomi Login step 3 @ {}\", (new URL(location)).getHost());\n+        request = httpClient.newRequest(location).timeout(REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        request.agent(USERAGENT);\n+        request.header(HttpHeader.CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n+        responseStep3 = request.send();\n+        logger.trace(\"Xiaomi login step 3 content = {}\", responseStep3.getContentAsString());\n+        logger.trace(\"Xiaomi login step 3 response = {}\", responseStep3);\n+\n+        dumpCookies(location);\n+        URI uri = URI.create(\"http://sts.api.io.mi.com\");\n+        String serviceToken = extractServiceToken(uri);\n+        if (!serviceToken.isEmpty()) {\n+            this.serviceToken = serviceToken;\n+        }\n+        return responseStep3;\n+    }\n+\n+    private void dumpCookies(String url) {\n+        URI uri = URI.create(url);\n+        logger.trace(\"Cookie dump for {}\", url);\n+        List<HttpCookie> cookies = httpClient.getCookieStore().get(uri);\n+        for (HttpCookie cookie : cookies) {\n+            logger.trace(\"Cookie ({}) : {} --> {}     (path: {})\", cookie.getDomain(), cookie.getName(),\n+                    cookie.getValue(), cookie.getPath());\n+        }\n+    }\n+\n+    private String extractServiceToken(URI uri) {\n+        String serviceToken = \"\";\n+        List<HttpCookie> cookies = httpClient.getCookieStore().get(uri);\n+        for (HttpCookie cookie : cookies) {\n+            logger.trace(\"Cookie :{} --> {}\", cookie.getName(), cookie.getValue());\n+            if (cookie.getName().contentEquals(\"serviceToken\")) {\n+                serviceToken = cookie.getValue();\n+                logger.debug(\"Xiaomi cloud logon succesfull.\");\n+                logger.trace(\"Xiaomi cloud servicetoken: {}\", serviceToken);\n+", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzNzk3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399937972", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public MiCloudException(String arg0) {\n          \n          \n            \n                public MiCloudException(String message) {", "author": "cpmeister", "createdAt": "2020-03-30T05:40:21Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/MiCloudException.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Will be thrown for cloud errors\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MiCloudException extends Exception {\n+\n+    public MiCloudException() {\n+        super();\n+    }\n+\n+    public MiCloudException(String arg0) {", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzODE0NA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399938144", "bodyText": "Please also add a constructor for including a cause exception", "author": "cpmeister", "createdAt": "2020-03-30T05:40:52Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/MiCloudException.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Will be thrown for cloud errors\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MiCloudException extends Exception {", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE0MDYyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r401140628", "bodyText": "okay, done. I assume that is what you ment above", "author": "marcelrv", "createdAt": "2020-03-31T18:54:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzODE0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0MDU4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399940585", "bodyText": "This constant should be loaded from a file at runtime, it is too large to keep as a string literal in code.", "author": "cpmeister", "createdAt": "2020-03-30T05:49:38Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/robot/RRMapDraw.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.robot;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics2D;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Ellipse2D;\n+import java.awt.geom.Line2D;\n+import java.awt.geom.Path2D;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.image.AffineTransformOp;\n+import java.awt.image.BufferedImage;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Base64;\n+\n+import javax.imageio.ImageIO;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Draws the vacuum map file to an image\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RRMapDraw {\n+\n+    private static final Color COLOR_MAP_INSIDE = new Color(32, 115, 185);\n+    private static final Color COLOR_MAP_OUTSIDE = new Color(19, 87, 148);\n+    private static final Color COLOR_MAP_WALL = new Color(100, 196, 254);\n+    private static final Color COLOR_GREY_WALL = new Color(93, 109, 126);\n+    private static final Color COLOR_PATH = new Color(147, 194, 238);\n+    private static final Color COLOR_ZONES = new Color(0xAD, 0xD8, 0xFF, 0x8F);\n+    private static final Color COLOR_NO_GO_ZONES = new Color(255, 33, 55, 127);\n+    private static final Color COLOR_CHARGER_HALO = new Color(0x66, 0xfe, 0xda, 0x7f);\n+    private static final Color COLOR_ROBO = new Color(75, 235, 149);\n+    private static final Color COLOR_SCAN = new Color(0xDF, 0xDF, 0xDF);\n+    private static final Color ROOM1 = new Color(240, 178, 122);\n+    private static final Color ROOM2 = new Color(133, 193, 233);\n+    private static final Color ROOM3 = new Color(217, 136, 128);\n+    private static final Color ROOM4 = new Color(52, 152, 219);\n+    private static final Color ROOM5 = new Color(205, 97, 85);\n+    private static final Color ROOM6 = new Color(243, 156, 18);\n+    private static final Color ROOM7 = new Color(88, 214, 141);\n+    private static final Color ROOM8 = new Color(245, 176, 65);\n+    private static final Color ROOM9 = new Color(0xFc, 0xD4, 0x51);\n+    private static final Color ROOM10 = new Color(72, 201, 176);\n+    private static final Color ROOM11 = new Color(84, 153, 199);\n+    private static final Color ROOM12 = new Color(133, 193, 233);\n+    private static final Color ROOM13 = new Color(245, 176, 65);\n+    private static final Color ROOM14 = new Color(82, 190, 128);\n+    private static final Color ROOM15 = new Color(72, 201, 176);\n+    private static final Color ROOM16 = new Color(165, 105, 189);\n+    private static final Color[] ROOM_COLORS = { ROOM1, ROOM2, ROOM3, ROOM4, ROOM5, ROOM6, ROOM7, ROOM8, ROOM9, ROOM10,\n+            ROOM11, ROOM12, ROOM13, ROOM14, ROOM15, ROOM16 };\n+    private boolean multicolor = false;\n+\n+    Dimension size = new Dimension();\n+    private RRMapFileParser rmfp;\n+\n+    public RRMapDraw(RRMapFileParser rmfp) {\n+        this.rmfp = rmfp;\n+    }\n+\n+    public void setRRFileDecoder(RRMapFileParser rmfp) {\n+        this.rmfp = rmfp;\n+    }\n+\n+    public int getWidth() {\n+        return rmfp.getImgWidth();\n+    }\n+\n+    public int getHeight() {\n+        return rmfp.getImgHeight();\n+    }\n+\n+    /**\n+     * load Gzipped RR inputstream\n+     *\n+     * @throws IOException\n+     */\n+    public static RRMapDraw loadImage(InputStream is) throws IOException {\n+        byte[] inputdata = RRMapFileParser.readRRMapFile(is);\n+        RRMapFileParser rf = new RRMapFileParser(inputdata);\n+        return new RRMapDraw(rf);\n+    }\n+\n+    /**\n+     * load Gzipped RR file\n+     *\n+     * @throws IOException\n+     */\n+    public static RRMapDraw loadImage(File file) throws IOException {\n+        return loadImage(new FileInputStream(file));\n+    }\n+\n+    /**\n+     * draws the map from the individual pixels\n+     */\n+    private void drawMap(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(1.1f * scale);\n+        g2d.setStroke(stroke);\n+        for (int y = 0; y < rmfp.getImgHeight() - 1; y++) {\n+            for (int x = 0; x < rmfp.getImgWidth() + 1; x++) {\n+                byte walltype = rmfp.getImage()[x + rmfp.getImgWidth() * y];\n+                switch (walltype & 0xFF) {\n+                    case 0x00:\n+                        g2d.setColor(COLOR_MAP_OUTSIDE);\n+                        break;\n+                    case 0x01:\n+                        g2d.setColor(COLOR_MAP_WALL);\n+                        break;\n+                    case 0xFF:\n+                        g2d.setColor(COLOR_MAP_INSIDE);\n+                        break;\n+                    case 0x07:\n+                        g2d.setColor(COLOR_SCAN);\n+                        break;\n+                    default:\n+                        int obstacle = (walltype & 0x07);\n+                        int mapId = (walltype & 0xFF) >>> 3;\n+                        switch (obstacle) {\n+                            case 0:\n+                                g2d.setColor(COLOR_GREY_WALL);\n+                                break;\n+                            case 1:\n+                                g2d.setColor(Color.BLACK);\n+                                break;\n+                            case 7:\n+                                g2d.setColor(ROOM_COLORS[Math.round(mapId / 2)]);\n+                                multicolor = true;\n+                                break;\n+                            default:\n+                                g2d.setColor(Color.WHITE);\n+                                break;\n+                        }\n+                }\n+                float xPos = scale * (rmfp.getImgWidth() - x);\n+                float yP = scale * y;\n+                g2d.draw(new Line2D.Float(xPos, yP, xPos, yP));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * draws the vacuum path\n+     *\n+     * @param scale\n+     */\n+    private void drawPath(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(0.5f * scale);\n+        g2d.setStroke(stroke);\n+        for (Integer pathType : rmfp.getPaths().keySet()) {\n+            switch (pathType) {\n+                case RRMapFileParser.PATH:\n+                    if (!multicolor) {\n+                        g2d.setColor(COLOR_PATH);\n+                    } else {\n+                        g2d.setColor(Color.WHITE);\n+                    }\n+                    break;\n+                case RRMapFileParser.GOTO_PATH:\n+                    g2d.setColor(Color.GREEN);\n+                    break;\n+                case RRMapFileParser.GOTO_PREDICTED_PATH:\n+                    g2d.setColor(Color.YELLOW);\n+                    break;\n+                default:\n+                    g2d.setColor(Color.CYAN);\n+            }\n+            float prvX = 0;\n+            float prvY = 0;\n+            for (Float[] point : rmfp.getPaths().get(pathType)) {\n+                float x = point[0] * scale;\n+                float y = point[1] * scale;\n+                if (prvX > 1) {\n+                    g2d.draw(new Line2D.Float(prvX, prvY, x, y));\n+                }\n+                prvX = x;\n+                prvY = y;\n+            }\n+        }\n+    }\n+\n+    private void drawZones(Graphics2D g2d, float scale) {\n+        for (Float[] point : rmfp.getZones()) {\n+            float x = point[0] * scale;\n+            float y = point[1] * scale;\n+            float x1 = point[2] * scale;\n+            float y1 = point[3] * scale;\n+            float sx = Math.min(x, x1);\n+            float w = Math.max(x, x1) - sx;\n+            float sy = Math.min(y, y1);\n+            float h = Math.max(y, y1) - sy;\n+            g2d.setColor(COLOR_ZONES);\n+            g2d.fill(new Rectangle2D.Float(sx, sy, w, h));\n+        }\n+    }\n+\n+    private void drawNoGo(Graphics2D g2d, float scale) {\n+        for (Integer area : rmfp.getAreas().keySet()) {\n+            for (Float[] point : rmfp.getAreas().get(area)) {\n+                float x = point[0] * scale;\n+                float y = point[1] * scale;\n+                float x1 = point[2] * scale;\n+                float y1 = point[3] * scale;\n+                float x2 = point[4] * scale;\n+                float y2 = point[5] * scale;\n+                float x3 = point[6] * scale;\n+                float y3 = point[7] * scale;\n+                Path2D noGo = new Path2D.Float();\n+                noGo.moveTo(x, y);\n+                noGo.lineTo(x1, y1);\n+                noGo.lineTo(x2, y2);\n+                noGo.lineTo(x3, y3);\n+                noGo.lineTo(x, y);\n+                g2d.setColor(COLOR_NO_GO_ZONES);\n+                g2d.fill(noGo);\n+                g2d.setColor(area == 9 ? Color.RED : Color.WHITE);\n+                g2d.draw(noGo);\n+            }\n+        }\n+    }\n+\n+    private void drawWalls(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(3 * scale);\n+        g2d.setStroke(stroke);\n+        for (Float[] point : rmfp.getWalls()) {\n+            float x = point[0] * scale;\n+            float y = point[1] * scale;\n+            float x1 = point[2] * scale;\n+            float y1 = point[3] * scale;\n+            g2d.setColor(Color.RED);\n+            g2d.draw(new Line2D.Float(x, y, x1, y1));\n+        }\n+    }\n+\n+    private void drawRobo(Graphics2D g2d, float scale) {\n+        float radius = 3 * scale;\n+        Stroke stroke = new BasicStroke(2 * scale);\n+        g2d.setStroke(stroke);\n+        g2d.setColor(COLOR_CHARGER_HALO);\n+        drawCircle(g2d, rmfp.getChargerX() * scale, rmfp.getChargerY() * scale, radius);\n+        drawCenteredImg(g2d, scale / 8,\n+                \"iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAADAFBMVEVHcExF5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o7////w/fa69tVm6qL1/vlt66br/PNf6p7+//7o/PGE7rR37ay39dOL77nM+OCh8sbB99n2/vlH5o9e6Z2c8sPk++/j++5s66Vj6qBg6p6i88dn66Nq66VY6Zq99td67a6S8L30/vjb+ul57a2C7rNW6Jiv9M5Q55UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABmUTLUAAAALnRSTlMAJPkvN+wI+4DP1eoxP47t7v4GrpmcB6+Ptj7w+vMJ9Lm11DIlMI0m0DUuM/G06wfbVgAAAfxJREFUeNqNletzmzAMwGVhXg0NTbLkbtl12fvW/f//ya7Xy7h82Nruwa5p8yhhgPGAFrCN6VWfbOmHZEtCNkCSMUX/ZZ6S4SvkrneQbETceE66ELY/aLzXo8bru1M5Blw6IWvt9cIa8LmvkOAPbqcJU7wS5yPoJYi55PUs+tBDwmSNuYBSew69MqVRxWIV3R7BEzKySe3VsjTRrUWSNtneInu41vCNhuTZ0X27jb9VBzD+aUmYCPvvXyqvb4+1pBuJGv618OrddcjTgoSppLryCtRVqwn0Oqtz037tAp2ZHTKvypMqZ5ohnejJ0UEpGsW1ngR2oxjW6OtJuZGrLsOdtJ/XJGQqukPp9M5NTYJpVNKmLKVMJHnSrB+z3RaXYQ9Zpyhv12i062GXJHH7a1GhAuZjCCvWkIVV6JVrVsmotpOxQMIxbjrNUh+D4C9RvcFxB61rgHJqTczUAsKRlsxdDNVrfwp1JPwJEYa6+B0SZkUDr7ayrswYnank9rw0mEtJWUCU/FbI5WXlI7BF5eefBdkpm80ewp0EgjKONWRyUp6qHLlk9b7tbdIlVxFvxhu3nOa/4EwlN7e58F9QctY73S541qSmvPYi6CODd5k84It5e/VCAy7zKFTfArYHMuiQf3c79rzHyF/1vVvF0E3TwcHyYJ+496Ypj5P/uAmtfUpJqE0AAAAASUVORK5CYII=\",", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0MDY3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399940679", "bodyText": "this one too.", "author": "cpmeister", "createdAt": "2020-03-30T05:49:55Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/robot/RRMapDraw.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.robot;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics2D;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Ellipse2D;\n+import java.awt.geom.Line2D;\n+import java.awt.geom.Path2D;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.image.AffineTransformOp;\n+import java.awt.image.BufferedImage;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Base64;\n+\n+import javax.imageio.ImageIO;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Draws the vacuum map file to an image\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RRMapDraw {\n+\n+    private static final Color COLOR_MAP_INSIDE = new Color(32, 115, 185);\n+    private static final Color COLOR_MAP_OUTSIDE = new Color(19, 87, 148);\n+    private static final Color COLOR_MAP_WALL = new Color(100, 196, 254);\n+    private static final Color COLOR_GREY_WALL = new Color(93, 109, 126);\n+    private static final Color COLOR_PATH = new Color(147, 194, 238);\n+    private static final Color COLOR_ZONES = new Color(0xAD, 0xD8, 0xFF, 0x8F);\n+    private static final Color COLOR_NO_GO_ZONES = new Color(255, 33, 55, 127);\n+    private static final Color COLOR_CHARGER_HALO = new Color(0x66, 0xfe, 0xda, 0x7f);\n+    private static final Color COLOR_ROBO = new Color(75, 235, 149);\n+    private static final Color COLOR_SCAN = new Color(0xDF, 0xDF, 0xDF);\n+    private static final Color ROOM1 = new Color(240, 178, 122);\n+    private static final Color ROOM2 = new Color(133, 193, 233);\n+    private static final Color ROOM3 = new Color(217, 136, 128);\n+    private static final Color ROOM4 = new Color(52, 152, 219);\n+    private static final Color ROOM5 = new Color(205, 97, 85);\n+    private static final Color ROOM6 = new Color(243, 156, 18);\n+    private static final Color ROOM7 = new Color(88, 214, 141);\n+    private static final Color ROOM8 = new Color(245, 176, 65);\n+    private static final Color ROOM9 = new Color(0xFc, 0xD4, 0x51);\n+    private static final Color ROOM10 = new Color(72, 201, 176);\n+    private static final Color ROOM11 = new Color(84, 153, 199);\n+    private static final Color ROOM12 = new Color(133, 193, 233);\n+    private static final Color ROOM13 = new Color(245, 176, 65);\n+    private static final Color ROOM14 = new Color(82, 190, 128);\n+    private static final Color ROOM15 = new Color(72, 201, 176);\n+    private static final Color ROOM16 = new Color(165, 105, 189);\n+    private static final Color[] ROOM_COLORS = { ROOM1, ROOM2, ROOM3, ROOM4, ROOM5, ROOM6, ROOM7, ROOM8, ROOM9, ROOM10,\n+            ROOM11, ROOM12, ROOM13, ROOM14, ROOM15, ROOM16 };\n+    private boolean multicolor = false;\n+\n+    Dimension size = new Dimension();\n+    private RRMapFileParser rmfp;\n+\n+    public RRMapDraw(RRMapFileParser rmfp) {\n+        this.rmfp = rmfp;\n+    }\n+\n+    public void setRRFileDecoder(RRMapFileParser rmfp) {\n+        this.rmfp = rmfp;\n+    }\n+\n+    public int getWidth() {\n+        return rmfp.getImgWidth();\n+    }\n+\n+    public int getHeight() {\n+        return rmfp.getImgHeight();\n+    }\n+\n+    /**\n+     * load Gzipped RR inputstream\n+     *\n+     * @throws IOException\n+     */\n+    public static RRMapDraw loadImage(InputStream is) throws IOException {\n+        byte[] inputdata = RRMapFileParser.readRRMapFile(is);\n+        RRMapFileParser rf = new RRMapFileParser(inputdata);\n+        return new RRMapDraw(rf);\n+    }\n+\n+    /**\n+     * load Gzipped RR file\n+     *\n+     * @throws IOException\n+     */\n+    public static RRMapDraw loadImage(File file) throws IOException {\n+        return loadImage(new FileInputStream(file));\n+    }\n+\n+    /**\n+     * draws the map from the individual pixels\n+     */\n+    private void drawMap(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(1.1f * scale);\n+        g2d.setStroke(stroke);\n+        for (int y = 0; y < rmfp.getImgHeight() - 1; y++) {\n+            for (int x = 0; x < rmfp.getImgWidth() + 1; x++) {\n+                byte walltype = rmfp.getImage()[x + rmfp.getImgWidth() * y];\n+                switch (walltype & 0xFF) {\n+                    case 0x00:\n+                        g2d.setColor(COLOR_MAP_OUTSIDE);\n+                        break;\n+                    case 0x01:\n+                        g2d.setColor(COLOR_MAP_WALL);\n+                        break;\n+                    case 0xFF:\n+                        g2d.setColor(COLOR_MAP_INSIDE);\n+                        break;\n+                    case 0x07:\n+                        g2d.setColor(COLOR_SCAN);\n+                        break;\n+                    default:\n+                        int obstacle = (walltype & 0x07);\n+                        int mapId = (walltype & 0xFF) >>> 3;\n+                        switch (obstacle) {\n+                            case 0:\n+                                g2d.setColor(COLOR_GREY_WALL);\n+                                break;\n+                            case 1:\n+                                g2d.setColor(Color.BLACK);\n+                                break;\n+                            case 7:\n+                                g2d.setColor(ROOM_COLORS[Math.round(mapId / 2)]);\n+                                multicolor = true;\n+                                break;\n+                            default:\n+                                g2d.setColor(Color.WHITE);\n+                                break;\n+                        }\n+                }\n+                float xPos = scale * (rmfp.getImgWidth() - x);\n+                float yP = scale * y;\n+                g2d.draw(new Line2D.Float(xPos, yP, xPos, yP));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * draws the vacuum path\n+     *\n+     * @param scale\n+     */\n+    private void drawPath(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(0.5f * scale);\n+        g2d.setStroke(stroke);\n+        for (Integer pathType : rmfp.getPaths().keySet()) {\n+            switch (pathType) {\n+                case RRMapFileParser.PATH:\n+                    if (!multicolor) {\n+                        g2d.setColor(COLOR_PATH);\n+                    } else {\n+                        g2d.setColor(Color.WHITE);\n+                    }\n+                    break;\n+                case RRMapFileParser.GOTO_PATH:\n+                    g2d.setColor(Color.GREEN);\n+                    break;\n+                case RRMapFileParser.GOTO_PREDICTED_PATH:\n+                    g2d.setColor(Color.YELLOW);\n+                    break;\n+                default:\n+                    g2d.setColor(Color.CYAN);\n+            }\n+            float prvX = 0;\n+            float prvY = 0;\n+            for (Float[] point : rmfp.getPaths().get(pathType)) {\n+                float x = point[0] * scale;\n+                float y = point[1] * scale;\n+                if (prvX > 1) {\n+                    g2d.draw(new Line2D.Float(prvX, prvY, x, y));\n+                }\n+                prvX = x;\n+                prvY = y;\n+            }\n+        }\n+    }\n+\n+    private void drawZones(Graphics2D g2d, float scale) {\n+        for (Float[] point : rmfp.getZones()) {\n+            float x = point[0] * scale;\n+            float y = point[1] * scale;\n+            float x1 = point[2] * scale;\n+            float y1 = point[3] * scale;\n+            float sx = Math.min(x, x1);\n+            float w = Math.max(x, x1) - sx;\n+            float sy = Math.min(y, y1);\n+            float h = Math.max(y, y1) - sy;\n+            g2d.setColor(COLOR_ZONES);\n+            g2d.fill(new Rectangle2D.Float(sx, sy, w, h));\n+        }\n+    }\n+\n+    private void drawNoGo(Graphics2D g2d, float scale) {\n+        for (Integer area : rmfp.getAreas().keySet()) {\n+            for (Float[] point : rmfp.getAreas().get(area)) {\n+                float x = point[0] * scale;\n+                float y = point[1] * scale;\n+                float x1 = point[2] * scale;\n+                float y1 = point[3] * scale;\n+                float x2 = point[4] * scale;\n+                float y2 = point[5] * scale;\n+                float x3 = point[6] * scale;\n+                float y3 = point[7] * scale;\n+                Path2D noGo = new Path2D.Float();\n+                noGo.moveTo(x, y);\n+                noGo.lineTo(x1, y1);\n+                noGo.lineTo(x2, y2);\n+                noGo.lineTo(x3, y3);\n+                noGo.lineTo(x, y);\n+                g2d.setColor(COLOR_NO_GO_ZONES);\n+                g2d.fill(noGo);\n+                g2d.setColor(area == 9 ? Color.RED : Color.WHITE);\n+                g2d.draw(noGo);\n+            }\n+        }\n+    }\n+\n+    private void drawWalls(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(3 * scale);\n+        g2d.setStroke(stroke);\n+        for (Float[] point : rmfp.getWalls()) {\n+            float x = point[0] * scale;\n+            float y = point[1] * scale;\n+            float x1 = point[2] * scale;\n+            float y1 = point[3] * scale;\n+            g2d.setColor(Color.RED);\n+            g2d.draw(new Line2D.Float(x, y, x1, y1));\n+        }\n+    }\n+\n+    private void drawRobo(Graphics2D g2d, float scale) {\n+        float radius = 3 * scale;\n+        Stroke stroke = new BasicStroke(2 * scale);\n+        g2d.setStroke(stroke);\n+        g2d.setColor(COLOR_CHARGER_HALO);\n+        drawCircle(g2d, rmfp.getChargerX() * scale, rmfp.getChargerY() * scale, radius);\n+        drawCenteredImg(g2d, scale / 8,\n+                \"iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAADAFBMVEVHcExF5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o7////w/fa69tVm6qL1/vlt66br/PNf6p7+//7o/PGE7rR37ay39dOL77nM+OCh8sbB99n2/vlH5o9e6Z2c8sPk++/j++5s66Vj6qBg6p6i88dn66Nq66VY6Zq99td67a6S8L30/vjb+ul57a2C7rNW6Jiv9M5Q55UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABmUTLUAAAALnRSTlMAJPkvN+wI+4DP1eoxP47t7v4GrpmcB6+Ptj7w+vMJ9Lm11DIlMI0m0DUuM/G06wfbVgAAAfxJREFUeNqNletzmzAMwGVhXg0NTbLkbtl12fvW/f//ya7Xy7h82Nruwa5p8yhhgPGAFrCN6VWfbOmHZEtCNkCSMUX/ZZ6S4SvkrneQbETceE66ELY/aLzXo8bru1M5Blw6IWvt9cIa8LmvkOAPbqcJU7wS5yPoJYi55PUs+tBDwmSNuYBSew69MqVRxWIV3R7BEzKySe3VsjTRrUWSNtneInu41vCNhuTZ0X27jb9VBzD+aUmYCPvvXyqvb4+1pBuJGv618OrddcjTgoSppLryCtRVqwn0Oqtz037tAp2ZHTKvypMqZ5ohnejJ0UEpGsW1ngR2oxjW6OtJuZGrLsOdtJ/XJGQqukPp9M5NTYJpVNKmLKVMJHnSrB+z3RaXYQ9Zpyhv12i062GXJHH7a1GhAuZjCCvWkIVV6JVrVsmotpOxQMIxbjrNUh+D4C9RvcFxB61rgHJqTczUAsKRlsxdDNVrfwp1JPwJEYa6+B0SZkUDr7ayrswYnank9rw0mEtJWUCU/FbI5WXlI7BF5eefBdkpm80ewp0EgjKONWRyUp6qHLlk9b7tbdIlVxFvxhu3nOa/4EwlN7e58F9QctY73S541qSmvPYi6CODd5k84It5e/VCAy7zKFTfArYHMuiQf3c79rzHyF/1vVvF0E3TwcHyYJ+496Ypj5P/uAmtfUpJqE0AAAAASUVORK5CYII=\",\n+                rmfp.getChargerX() * scale, rmfp.getChargerY() * scale);\n+        radius = 3 * scale;\n+        g2d.setColor(COLOR_ROBO);\n+        drawCircle(g2d, rmfp.getRoboX() * scale, rmfp.getRoboY() * scale, radius);\n+        if (scale > 1.5) {\n+            drawCenteredImg(g2d, scale / 15,\n+                    \"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\",", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0MDcwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399940709", "bodyText": "blank line", "author": "cpmeister", "createdAt": "2020-03-30T05:50:02Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/robot/RRMapDraw.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.robot;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics2D;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Ellipse2D;\n+import java.awt.geom.Line2D;\n+import java.awt.geom.Path2D;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.image.AffineTransformOp;\n+import java.awt.image.BufferedImage;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Base64;\n+\n+import javax.imageio.ImageIO;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Draws the vacuum map file to an image\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RRMapDraw {\n+\n+    private static final Color COLOR_MAP_INSIDE = new Color(32, 115, 185);\n+    private static final Color COLOR_MAP_OUTSIDE = new Color(19, 87, 148);\n+    private static final Color COLOR_MAP_WALL = new Color(100, 196, 254);\n+    private static final Color COLOR_GREY_WALL = new Color(93, 109, 126);\n+    private static final Color COLOR_PATH = new Color(147, 194, 238);\n+    private static final Color COLOR_ZONES = new Color(0xAD, 0xD8, 0xFF, 0x8F);\n+    private static final Color COLOR_NO_GO_ZONES = new Color(255, 33, 55, 127);\n+    private static final Color COLOR_CHARGER_HALO = new Color(0x66, 0xfe, 0xda, 0x7f);\n+    private static final Color COLOR_ROBO = new Color(75, 235, 149);\n+    private static final Color COLOR_SCAN = new Color(0xDF, 0xDF, 0xDF);\n+    private static final Color ROOM1 = new Color(240, 178, 122);\n+    private static final Color ROOM2 = new Color(133, 193, 233);\n+    private static final Color ROOM3 = new Color(217, 136, 128);\n+    private static final Color ROOM4 = new Color(52, 152, 219);\n+    private static final Color ROOM5 = new Color(205, 97, 85);\n+    private static final Color ROOM6 = new Color(243, 156, 18);\n+    private static final Color ROOM7 = new Color(88, 214, 141);\n+    private static final Color ROOM8 = new Color(245, 176, 65);\n+    private static final Color ROOM9 = new Color(0xFc, 0xD4, 0x51);\n+    private static final Color ROOM10 = new Color(72, 201, 176);\n+    private static final Color ROOM11 = new Color(84, 153, 199);\n+    private static final Color ROOM12 = new Color(133, 193, 233);\n+    private static final Color ROOM13 = new Color(245, 176, 65);\n+    private static final Color ROOM14 = new Color(82, 190, 128);\n+    private static final Color ROOM15 = new Color(72, 201, 176);\n+    private static final Color ROOM16 = new Color(165, 105, 189);\n+    private static final Color[] ROOM_COLORS = { ROOM1, ROOM2, ROOM3, ROOM4, ROOM5, ROOM6, ROOM7, ROOM8, ROOM9, ROOM10,\n+            ROOM11, ROOM12, ROOM13, ROOM14, ROOM15, ROOM16 };\n+    private boolean multicolor = false;\n+\n+    Dimension size = new Dimension();\n+    private RRMapFileParser rmfp;\n+\n+    public RRMapDraw(RRMapFileParser rmfp) {\n+        this.rmfp = rmfp;\n+    }\n+\n+    public void setRRFileDecoder(RRMapFileParser rmfp) {\n+        this.rmfp = rmfp;\n+    }\n+\n+    public int getWidth() {\n+        return rmfp.getImgWidth();\n+    }\n+\n+    public int getHeight() {\n+        return rmfp.getImgHeight();\n+    }\n+\n+    /**\n+     * load Gzipped RR inputstream\n+     *\n+     * @throws IOException\n+     */\n+    public static RRMapDraw loadImage(InputStream is) throws IOException {\n+        byte[] inputdata = RRMapFileParser.readRRMapFile(is);\n+        RRMapFileParser rf = new RRMapFileParser(inputdata);\n+        return new RRMapDraw(rf);\n+    }\n+\n+    /**\n+     * load Gzipped RR file\n+     *\n+     * @throws IOException\n+     */\n+    public static RRMapDraw loadImage(File file) throws IOException {\n+        return loadImage(new FileInputStream(file));\n+    }\n+\n+    /**\n+     * draws the map from the individual pixels\n+     */\n+    private void drawMap(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(1.1f * scale);\n+        g2d.setStroke(stroke);\n+        for (int y = 0; y < rmfp.getImgHeight() - 1; y++) {\n+            for (int x = 0; x < rmfp.getImgWidth() + 1; x++) {\n+                byte walltype = rmfp.getImage()[x + rmfp.getImgWidth() * y];\n+                switch (walltype & 0xFF) {\n+                    case 0x00:\n+                        g2d.setColor(COLOR_MAP_OUTSIDE);\n+                        break;\n+                    case 0x01:\n+                        g2d.setColor(COLOR_MAP_WALL);\n+                        break;\n+                    case 0xFF:\n+                        g2d.setColor(COLOR_MAP_INSIDE);\n+                        break;\n+                    case 0x07:\n+                        g2d.setColor(COLOR_SCAN);\n+                        break;\n+                    default:\n+                        int obstacle = (walltype & 0x07);\n+                        int mapId = (walltype & 0xFF) >>> 3;\n+                        switch (obstacle) {\n+                            case 0:\n+                                g2d.setColor(COLOR_GREY_WALL);\n+                                break;\n+                            case 1:\n+                                g2d.setColor(Color.BLACK);\n+                                break;\n+                            case 7:\n+                                g2d.setColor(ROOM_COLORS[Math.round(mapId / 2)]);\n+                                multicolor = true;\n+                                break;\n+                            default:\n+                                g2d.setColor(Color.WHITE);\n+                                break;\n+                        }\n+                }\n+                float xPos = scale * (rmfp.getImgWidth() - x);\n+                float yP = scale * y;\n+                g2d.draw(new Line2D.Float(xPos, yP, xPos, yP));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * draws the vacuum path\n+     *\n+     * @param scale\n+     */\n+    private void drawPath(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(0.5f * scale);\n+        g2d.setStroke(stroke);\n+        for (Integer pathType : rmfp.getPaths().keySet()) {\n+            switch (pathType) {\n+                case RRMapFileParser.PATH:\n+                    if (!multicolor) {\n+                        g2d.setColor(COLOR_PATH);\n+                    } else {\n+                        g2d.setColor(Color.WHITE);\n+                    }\n+                    break;\n+                case RRMapFileParser.GOTO_PATH:\n+                    g2d.setColor(Color.GREEN);\n+                    break;\n+                case RRMapFileParser.GOTO_PREDICTED_PATH:\n+                    g2d.setColor(Color.YELLOW);\n+                    break;\n+                default:\n+                    g2d.setColor(Color.CYAN);\n+            }\n+            float prvX = 0;\n+            float prvY = 0;\n+            for (Float[] point : rmfp.getPaths().get(pathType)) {\n+                float x = point[0] * scale;\n+                float y = point[1] * scale;\n+                if (prvX > 1) {\n+                    g2d.draw(new Line2D.Float(prvX, prvY, x, y));\n+                }\n+                prvX = x;\n+                prvY = y;\n+            }\n+        }\n+    }\n+\n+    private void drawZones(Graphics2D g2d, float scale) {\n+        for (Float[] point : rmfp.getZones()) {\n+            float x = point[0] * scale;\n+            float y = point[1] * scale;\n+            float x1 = point[2] * scale;\n+            float y1 = point[3] * scale;\n+            float sx = Math.min(x, x1);\n+            float w = Math.max(x, x1) - sx;\n+            float sy = Math.min(y, y1);\n+            float h = Math.max(y, y1) - sy;\n+            g2d.setColor(COLOR_ZONES);\n+            g2d.fill(new Rectangle2D.Float(sx, sy, w, h));\n+        }\n+    }\n+\n+    private void drawNoGo(Graphics2D g2d, float scale) {\n+        for (Integer area : rmfp.getAreas().keySet()) {\n+            for (Float[] point : rmfp.getAreas().get(area)) {\n+                float x = point[0] * scale;\n+                float y = point[1] * scale;\n+                float x1 = point[2] * scale;\n+                float y1 = point[3] * scale;\n+                float x2 = point[4] * scale;\n+                float y2 = point[5] * scale;\n+                float x3 = point[6] * scale;\n+                float y3 = point[7] * scale;\n+                Path2D noGo = new Path2D.Float();\n+                noGo.moveTo(x, y);\n+                noGo.lineTo(x1, y1);\n+                noGo.lineTo(x2, y2);\n+                noGo.lineTo(x3, y3);\n+                noGo.lineTo(x, y);\n+                g2d.setColor(COLOR_NO_GO_ZONES);\n+                g2d.fill(noGo);\n+                g2d.setColor(area == 9 ? Color.RED : Color.WHITE);\n+                g2d.draw(noGo);\n+            }\n+        }\n+    }\n+\n+    private void drawWalls(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(3 * scale);\n+        g2d.setStroke(stroke);\n+        for (Float[] point : rmfp.getWalls()) {\n+            float x = point[0] * scale;\n+            float y = point[1] * scale;\n+            float x1 = point[2] * scale;\n+            float y1 = point[3] * scale;\n+            g2d.setColor(Color.RED);\n+            g2d.draw(new Line2D.Float(x, y, x1, y1));\n+        }\n+    }\n+\n+    private void drawRobo(Graphics2D g2d, float scale) {\n+        float radius = 3 * scale;\n+        Stroke stroke = new BasicStroke(2 * scale);\n+        g2d.setStroke(stroke);\n+        g2d.setColor(COLOR_CHARGER_HALO);\n+        drawCircle(g2d, rmfp.getChargerX() * scale, rmfp.getChargerY() * scale, radius);\n+        drawCenteredImg(g2d, scale / 8,\n+                \"iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAADAFBMVEVHcExF5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o7////w/fa69tVm6qL1/vlt66br/PNf6p7+//7o/PGE7rR37ay39dOL77nM+OCh8sbB99n2/vlH5o9e6Z2c8sPk++/j++5s66Vj6qBg6p6i88dn66Nq66VY6Zq99td67a6S8L30/vjb+ul57a2C7rNW6Jiv9M5Q55UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABmUTLUAAAALnRSTlMAJPkvN+wI+4DP1eoxP47t7v4GrpmcB6+Ptj7w+vMJ9Lm11DIlMI0m0DUuM/G06wfbVgAAAfxJREFUeNqNletzmzAMwGVhXg0NTbLkbtl12fvW/f//ya7Xy7h82Nruwa5p8yhhgPGAFrCN6VWfbOmHZEtCNkCSMUX/ZZ6S4SvkrneQbETceE66ELY/aLzXo8bru1M5Blw6IWvt9cIa8LmvkOAPbqcJU7wS5yPoJYi55PUs+tBDwmSNuYBSew69MqVRxWIV3R7BEzKySe3VsjTRrUWSNtneInu41vCNhuTZ0X27jb9VBzD+aUmYCPvvXyqvb4+1pBuJGv618OrddcjTgoSppLryCtRVqwn0Oqtz037tAp2ZHTKvypMqZ5ohnejJ0UEpGsW1ngR2oxjW6OtJuZGrLsOdtJ/XJGQqukPp9M5NTYJpVNKmLKVMJHnSrB+z3RaXYQ9Zpyhv12i062GXJHH7a1GhAuZjCCvWkIVV6JVrVsmotpOxQMIxbjrNUh+D4C9RvcFxB61rgHJqTczUAsKRlsxdDNVrfwp1JPwJEYa6+B0SZkUDr7ayrswYnank9rw0mEtJWUCU/FbI5WXlI7BF5eefBdkpm80ewp0EgjKONWRyUp6qHLlk9b7tbdIlVxFvxhu3nOa/4EwlN7e58F9QctY73S541qSmvPYi6CODd5k84It5e/VCAy7zKFTfArYHMuiQf3c79rzHyF/1vVvF0E3TwcHyYJ+496Ypj5P/uAmtfUpJqE0AAAAASUVORK5CYII=\",\n+                rmfp.getChargerX() * scale, rmfp.getChargerY() * scale);\n+        radius = 3 * scale;\n+        g2d.setColor(COLOR_ROBO);\n+        drawCircle(g2d, rmfp.getRoboX() * scale, rmfp.getRoboY() * scale, radius);\n+        if (scale > 1.5) {\n+            drawCenteredImg(g2d, scale / 15,\n+                    \"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\",\n+                    rmfp.getRoboX() * scale, rmfp.getRoboY() * scale);\n+        }\n+    }\n+\n+    private void drawCircle(Graphics2D g2d, float x, float y, float radius) {\n+        g2d.draw(new Ellipse2D.Double(x - radius, y - radius, 2.0 * radius, 2.0 * radius));\n+    }\n+\n+    private void drawCenteredImg(Graphics2D g2d, float scale, String imgData, float x, float y) {\n+        try {\n+            BufferedImage addImg = ImageIO.read(new ByteArrayInputStream(Base64.getDecoder().decode(imgData)));\n+            int xpos = Math.round(x - (addImg.getWidth() / 2 * scale));\n+            int ypos = Math.round(y - (addImg.getHeight() / 2 * scale));\n+            AffineTransform at = new AffineTransform();\n+            at.scale(scale, scale);\n+            AffineTransformOp scaleOp = new AffineTransformOp(at, AffineTransformOp.TYPE_BILINEAR);\n+            g2d.drawImage(addImg, scaleOp, xpos, ypos);\n+        } catch (IOException e) {\n+            // ignore\n+        }\n+    }\n+\n+    private void drawGoTo(Graphics2D g2d, float scale) {\n+        float x = rmfp.getGotoX() * scale;\n+        float y = rmfp.getGotoY() * scale;\n+        if (!(x == 0 && y == 0)) {\n+            g2d.setStroke(new BasicStroke());\n+            g2d.setColor(Color.YELLOW);\n+            int x3[] = { (int) x, (int) (x - 2 * scale), (int) (x + 2 * scale) };\n+            int y3[] = { (int) y, (int) (y - 5 * scale), (int) (y - 5 * scale) };\n+            g2d.fill(new Polygon(x3, y3, 3));\n+", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0MDc2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399940768", "bodyText": "see other comment", "author": "cpmeister", "createdAt": "2020-03-30T05:50:15Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/robot/RRMapDraw.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.robot;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics2D;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Ellipse2D;\n+import java.awt.geom.Line2D;\n+import java.awt.geom.Path2D;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.image.AffineTransformOp;\n+import java.awt.image.BufferedImage;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Base64;\n+\n+import javax.imageio.ImageIO;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Draws the vacuum map file to an image\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RRMapDraw {\n+\n+    private static final Color COLOR_MAP_INSIDE = new Color(32, 115, 185);\n+    private static final Color COLOR_MAP_OUTSIDE = new Color(19, 87, 148);\n+    private static final Color COLOR_MAP_WALL = new Color(100, 196, 254);\n+    private static final Color COLOR_GREY_WALL = new Color(93, 109, 126);\n+    private static final Color COLOR_PATH = new Color(147, 194, 238);\n+    private static final Color COLOR_ZONES = new Color(0xAD, 0xD8, 0xFF, 0x8F);\n+    private static final Color COLOR_NO_GO_ZONES = new Color(255, 33, 55, 127);\n+    private static final Color COLOR_CHARGER_HALO = new Color(0x66, 0xfe, 0xda, 0x7f);\n+    private static final Color COLOR_ROBO = new Color(75, 235, 149);\n+    private static final Color COLOR_SCAN = new Color(0xDF, 0xDF, 0xDF);\n+    private static final Color ROOM1 = new Color(240, 178, 122);\n+    private static final Color ROOM2 = new Color(133, 193, 233);\n+    private static final Color ROOM3 = new Color(217, 136, 128);\n+    private static final Color ROOM4 = new Color(52, 152, 219);\n+    private static final Color ROOM5 = new Color(205, 97, 85);\n+    private static final Color ROOM6 = new Color(243, 156, 18);\n+    private static final Color ROOM7 = new Color(88, 214, 141);\n+    private static final Color ROOM8 = new Color(245, 176, 65);\n+    private static final Color ROOM9 = new Color(0xFc, 0xD4, 0x51);\n+    private static final Color ROOM10 = new Color(72, 201, 176);\n+    private static final Color ROOM11 = new Color(84, 153, 199);\n+    private static final Color ROOM12 = new Color(133, 193, 233);\n+    private static final Color ROOM13 = new Color(245, 176, 65);\n+    private static final Color ROOM14 = new Color(82, 190, 128);\n+    private static final Color ROOM15 = new Color(72, 201, 176);\n+    private static final Color ROOM16 = new Color(165, 105, 189);\n+    private static final Color[] ROOM_COLORS = { ROOM1, ROOM2, ROOM3, ROOM4, ROOM5, ROOM6, ROOM7, ROOM8, ROOM9, ROOM10,\n+            ROOM11, ROOM12, ROOM13, ROOM14, ROOM15, ROOM16 };\n+    private boolean multicolor = false;\n+\n+    Dimension size = new Dimension();\n+    private RRMapFileParser rmfp;\n+\n+    public RRMapDraw(RRMapFileParser rmfp) {\n+        this.rmfp = rmfp;\n+    }\n+\n+    public void setRRFileDecoder(RRMapFileParser rmfp) {\n+        this.rmfp = rmfp;\n+    }\n+\n+    public int getWidth() {\n+        return rmfp.getImgWidth();\n+    }\n+\n+    public int getHeight() {\n+        return rmfp.getImgHeight();\n+    }\n+\n+    /**\n+     * load Gzipped RR inputstream\n+     *\n+     * @throws IOException\n+     */\n+    public static RRMapDraw loadImage(InputStream is) throws IOException {\n+        byte[] inputdata = RRMapFileParser.readRRMapFile(is);\n+        RRMapFileParser rf = new RRMapFileParser(inputdata);\n+        return new RRMapDraw(rf);\n+    }\n+\n+    /**\n+     * load Gzipped RR file\n+     *\n+     * @throws IOException\n+     */\n+    public static RRMapDraw loadImage(File file) throws IOException {\n+        return loadImage(new FileInputStream(file));\n+    }\n+\n+    /**\n+     * draws the map from the individual pixels\n+     */\n+    private void drawMap(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(1.1f * scale);\n+        g2d.setStroke(stroke);\n+        for (int y = 0; y < rmfp.getImgHeight() - 1; y++) {\n+            for (int x = 0; x < rmfp.getImgWidth() + 1; x++) {\n+                byte walltype = rmfp.getImage()[x + rmfp.getImgWidth() * y];\n+                switch (walltype & 0xFF) {\n+                    case 0x00:\n+                        g2d.setColor(COLOR_MAP_OUTSIDE);\n+                        break;\n+                    case 0x01:\n+                        g2d.setColor(COLOR_MAP_WALL);\n+                        break;\n+                    case 0xFF:\n+                        g2d.setColor(COLOR_MAP_INSIDE);\n+                        break;\n+                    case 0x07:\n+                        g2d.setColor(COLOR_SCAN);\n+                        break;\n+                    default:\n+                        int obstacle = (walltype & 0x07);\n+                        int mapId = (walltype & 0xFF) >>> 3;\n+                        switch (obstacle) {\n+                            case 0:\n+                                g2d.setColor(COLOR_GREY_WALL);\n+                                break;\n+                            case 1:\n+                                g2d.setColor(Color.BLACK);\n+                                break;\n+                            case 7:\n+                                g2d.setColor(ROOM_COLORS[Math.round(mapId / 2)]);\n+                                multicolor = true;\n+                                break;\n+                            default:\n+                                g2d.setColor(Color.WHITE);\n+                                break;\n+                        }\n+                }\n+                float xPos = scale * (rmfp.getImgWidth() - x);\n+                float yP = scale * y;\n+                g2d.draw(new Line2D.Float(xPos, yP, xPos, yP));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * draws the vacuum path\n+     *\n+     * @param scale\n+     */\n+    private void drawPath(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(0.5f * scale);\n+        g2d.setStroke(stroke);\n+        for (Integer pathType : rmfp.getPaths().keySet()) {\n+            switch (pathType) {\n+                case RRMapFileParser.PATH:\n+                    if (!multicolor) {\n+                        g2d.setColor(COLOR_PATH);\n+                    } else {\n+                        g2d.setColor(Color.WHITE);\n+                    }\n+                    break;\n+                case RRMapFileParser.GOTO_PATH:\n+                    g2d.setColor(Color.GREEN);\n+                    break;\n+                case RRMapFileParser.GOTO_PREDICTED_PATH:\n+                    g2d.setColor(Color.YELLOW);\n+                    break;\n+                default:\n+                    g2d.setColor(Color.CYAN);\n+            }\n+            float prvX = 0;\n+            float prvY = 0;\n+            for (Float[] point : rmfp.getPaths().get(pathType)) {\n+                float x = point[0] * scale;\n+                float y = point[1] * scale;\n+                if (prvX > 1) {\n+                    g2d.draw(new Line2D.Float(prvX, prvY, x, y));\n+                }\n+                prvX = x;\n+                prvY = y;\n+            }\n+        }\n+    }\n+\n+    private void drawZones(Graphics2D g2d, float scale) {\n+        for (Float[] point : rmfp.getZones()) {\n+            float x = point[0] * scale;\n+            float y = point[1] * scale;\n+            float x1 = point[2] * scale;\n+            float y1 = point[3] * scale;\n+            float sx = Math.min(x, x1);\n+            float w = Math.max(x, x1) - sx;\n+            float sy = Math.min(y, y1);\n+            float h = Math.max(y, y1) - sy;\n+            g2d.setColor(COLOR_ZONES);\n+            g2d.fill(new Rectangle2D.Float(sx, sy, w, h));\n+        }\n+    }\n+\n+    private void drawNoGo(Graphics2D g2d, float scale) {\n+        for (Integer area : rmfp.getAreas().keySet()) {\n+            for (Float[] point : rmfp.getAreas().get(area)) {\n+                float x = point[0] * scale;\n+                float y = point[1] * scale;\n+                float x1 = point[2] * scale;\n+                float y1 = point[3] * scale;\n+                float x2 = point[4] * scale;\n+                float y2 = point[5] * scale;\n+                float x3 = point[6] * scale;\n+                float y3 = point[7] * scale;\n+                Path2D noGo = new Path2D.Float();\n+                noGo.moveTo(x, y);\n+                noGo.lineTo(x1, y1);\n+                noGo.lineTo(x2, y2);\n+                noGo.lineTo(x3, y3);\n+                noGo.lineTo(x, y);\n+                g2d.setColor(COLOR_NO_GO_ZONES);\n+                g2d.fill(noGo);\n+                g2d.setColor(area == 9 ? Color.RED : Color.WHITE);\n+                g2d.draw(noGo);\n+            }\n+        }\n+    }\n+\n+    private void drawWalls(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(3 * scale);\n+        g2d.setStroke(stroke);\n+        for (Float[] point : rmfp.getWalls()) {\n+            float x = point[0] * scale;\n+            float y = point[1] * scale;\n+            float x1 = point[2] * scale;\n+            float y1 = point[3] * scale;\n+            g2d.setColor(Color.RED);\n+            g2d.draw(new Line2D.Float(x, y, x1, y1));\n+        }\n+    }\n+\n+    private void drawRobo(Graphics2D g2d, float scale) {\n+        float radius = 3 * scale;\n+        Stroke stroke = new BasicStroke(2 * scale);\n+        g2d.setStroke(stroke);\n+        g2d.setColor(COLOR_CHARGER_HALO);\n+        drawCircle(g2d, rmfp.getChargerX() * scale, rmfp.getChargerY() * scale, radius);\n+        drawCenteredImg(g2d, scale / 8,\n+                \"iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAADAFBMVEVHcExF5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o7////w/fa69tVm6qL1/vlt66br/PNf6p7+//7o/PGE7rR37ay39dOL77nM+OCh8sbB99n2/vlH5o9e6Z2c8sPk++/j++5s66Vj6qBg6p6i88dn66Nq66VY6Zq99td67a6S8L30/vjb+ul57a2C7rNW6Jiv9M5Q55UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABmUTLUAAAALnRSTlMAJPkvN+wI+4DP1eoxP47t7v4GrpmcB6+Ptj7w+vMJ9Lm11DIlMI0m0DUuM/G06wfbVgAAAfxJREFUeNqNletzmzAMwGVhXg0NTbLkbtl12fvW/f//ya7Xy7h82Nruwa5p8yhhgPGAFrCN6VWfbOmHZEtCNkCSMUX/ZZ6S4SvkrneQbETceE66ELY/aLzXo8bru1M5Blw6IWvt9cIa8LmvkOAPbqcJU7wS5yPoJYi55PUs+tBDwmSNuYBSew69MqVRxWIV3R7BEzKySe3VsjTRrUWSNtneInu41vCNhuTZ0X27jb9VBzD+aUmYCPvvXyqvb4+1pBuJGv618OrddcjTgoSppLryCtRVqwn0Oqtz037tAp2ZHTKvypMqZ5ohnejJ0UEpGsW1ngR2oxjW6OtJuZGrLsOdtJ/XJGQqukPp9M5NTYJpVNKmLKVMJHnSrB+z3RaXYQ9Zpyhv12i062GXJHH7a1GhAuZjCCvWkIVV6JVrVsmotpOxQMIxbjrNUh+D4C9RvcFxB61rgHJqTczUAsKRlsxdDNVrfwp1JPwJEYa6+B0SZkUDr7ayrswYnank9rw0mEtJWUCU/FbI5WXlI7BF5eefBdkpm80ewp0EgjKONWRyUp6qHLlk9b7tbdIlVxFvxhu3nOa/4EwlN7e58F9QctY73S541qSmvPYi6CODd5k84It5e/VCAy7zKFTfArYHMuiQf3c79rzHyF/1vVvF0E3TwcHyYJ+496Ypj5P/uAmtfUpJqE0AAAAASUVORK5CYII=\",\n+                rmfp.getChargerX() * scale, rmfp.getChargerY() * scale);\n+        radius = 3 * scale;\n+        g2d.setColor(COLOR_ROBO);\n+        drawCircle(g2d, rmfp.getRoboX() * scale, rmfp.getRoboY() * scale, radius);\n+        if (scale > 1.5) {\n+            drawCenteredImg(g2d, scale / 15,\n+                    \"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\",\n+                    rmfp.getRoboX() * scale, rmfp.getRoboY() * scale);\n+        }\n+    }\n+\n+    private void drawCircle(Graphics2D g2d, float x, float y, float radius) {\n+        g2d.draw(new Ellipse2D.Double(x - radius, y - radius, 2.0 * radius, 2.0 * radius));\n+    }\n+\n+    private void drawCenteredImg(Graphics2D g2d, float scale, String imgData, float x, float y) {\n+        try {\n+            BufferedImage addImg = ImageIO.read(new ByteArrayInputStream(Base64.getDecoder().decode(imgData)));\n+            int xpos = Math.round(x - (addImg.getWidth() / 2 * scale));\n+            int ypos = Math.round(y - (addImg.getHeight() / 2 * scale));\n+            AffineTransform at = new AffineTransform();\n+            at.scale(scale, scale);\n+            AffineTransformOp scaleOp = new AffineTransformOp(at, AffineTransformOp.TYPE_BILINEAR);\n+            g2d.drawImage(addImg, scaleOp, xpos, ypos);\n+        } catch (IOException e) {\n+            // ignore\n+        }\n+    }\n+\n+    private void drawGoTo(Graphics2D g2d, float scale) {\n+        float x = rmfp.getGotoX() * scale;\n+        float y = rmfp.getGotoY() * scale;\n+        if (!(x == 0 && y == 0)) {\n+            g2d.setStroke(new BasicStroke());\n+            g2d.setColor(Color.YELLOW);\n+            int x3[] = { (int) x, (int) (x - 2 * scale), (int) (x + 2 * scale) };\n+            int y3[] = { (int) y, (int) (y - 5 * scale), (int) (y - 5 * scale) };\n+            g2d.fill(new Polygon(x3, y3, 3));\n+\n+        }\n+    }\n+\n+    private void drawOpenHabRocks(Graphics2D g2d, int width, int height, float scale) {\n+        // easter egg gift :\n+        int offset = 5;\n+        int textPos = 55;\n+        try {\n+            BufferedImage ohLogo = ImageIO.read(new ByteArrayInputStream(Base64.getDecoder().decode(\n+                    \"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\")));", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0MTQzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399941430", "bodyText": "I think TimesRoman is a Microsoft licensed font, and may not be available on all systems. Is there another font you can use instead?", "author": "cpmeister", "createdAt": "2020-03-30T05:52:32Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/robot/RRMapDraw.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.robot;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics2D;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Ellipse2D;\n+import java.awt.geom.Line2D;\n+import java.awt.geom.Path2D;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.image.AffineTransformOp;\n+import java.awt.image.BufferedImage;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Base64;\n+\n+import javax.imageio.ImageIO;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Draws the vacuum map file to an image\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RRMapDraw {\n+\n+    private static final Color COLOR_MAP_INSIDE = new Color(32, 115, 185);\n+    private static final Color COLOR_MAP_OUTSIDE = new Color(19, 87, 148);\n+    private static final Color COLOR_MAP_WALL = new Color(100, 196, 254);\n+    private static final Color COLOR_GREY_WALL = new Color(93, 109, 126);\n+    private static final Color COLOR_PATH = new Color(147, 194, 238);\n+    private static final Color COLOR_ZONES = new Color(0xAD, 0xD8, 0xFF, 0x8F);\n+    private static final Color COLOR_NO_GO_ZONES = new Color(255, 33, 55, 127);\n+    private static final Color COLOR_CHARGER_HALO = new Color(0x66, 0xfe, 0xda, 0x7f);\n+    private static final Color COLOR_ROBO = new Color(75, 235, 149);\n+    private static final Color COLOR_SCAN = new Color(0xDF, 0xDF, 0xDF);\n+    private static final Color ROOM1 = new Color(240, 178, 122);\n+    private static final Color ROOM2 = new Color(133, 193, 233);\n+    private static final Color ROOM3 = new Color(217, 136, 128);\n+    private static final Color ROOM4 = new Color(52, 152, 219);\n+    private static final Color ROOM5 = new Color(205, 97, 85);\n+    private static final Color ROOM6 = new Color(243, 156, 18);\n+    private static final Color ROOM7 = new Color(88, 214, 141);\n+    private static final Color ROOM8 = new Color(245, 176, 65);\n+    private static final Color ROOM9 = new Color(0xFc, 0xD4, 0x51);\n+    private static final Color ROOM10 = new Color(72, 201, 176);\n+    private static final Color ROOM11 = new Color(84, 153, 199);\n+    private static final Color ROOM12 = new Color(133, 193, 233);\n+    private static final Color ROOM13 = new Color(245, 176, 65);\n+    private static final Color ROOM14 = new Color(82, 190, 128);\n+    private static final Color ROOM15 = new Color(72, 201, 176);\n+    private static final Color ROOM16 = new Color(165, 105, 189);\n+    private static final Color[] ROOM_COLORS = { ROOM1, ROOM2, ROOM3, ROOM4, ROOM5, ROOM6, ROOM7, ROOM8, ROOM9, ROOM10,\n+            ROOM11, ROOM12, ROOM13, ROOM14, ROOM15, ROOM16 };\n+    private boolean multicolor = false;\n+\n+    Dimension size = new Dimension();\n+    private RRMapFileParser rmfp;\n+\n+    public RRMapDraw(RRMapFileParser rmfp) {\n+        this.rmfp = rmfp;\n+    }\n+\n+    public void setRRFileDecoder(RRMapFileParser rmfp) {\n+        this.rmfp = rmfp;\n+    }\n+\n+    public int getWidth() {\n+        return rmfp.getImgWidth();\n+    }\n+\n+    public int getHeight() {\n+        return rmfp.getImgHeight();\n+    }\n+\n+    /**\n+     * load Gzipped RR inputstream\n+     *\n+     * @throws IOException\n+     */\n+    public static RRMapDraw loadImage(InputStream is) throws IOException {\n+        byte[] inputdata = RRMapFileParser.readRRMapFile(is);\n+        RRMapFileParser rf = new RRMapFileParser(inputdata);\n+        return new RRMapDraw(rf);\n+    }\n+\n+    /**\n+     * load Gzipped RR file\n+     *\n+     * @throws IOException\n+     */\n+    public static RRMapDraw loadImage(File file) throws IOException {\n+        return loadImage(new FileInputStream(file));\n+    }\n+\n+    /**\n+     * draws the map from the individual pixels\n+     */\n+    private void drawMap(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(1.1f * scale);\n+        g2d.setStroke(stroke);\n+        for (int y = 0; y < rmfp.getImgHeight() - 1; y++) {\n+            for (int x = 0; x < rmfp.getImgWidth() + 1; x++) {\n+                byte walltype = rmfp.getImage()[x + rmfp.getImgWidth() * y];\n+                switch (walltype & 0xFF) {\n+                    case 0x00:\n+                        g2d.setColor(COLOR_MAP_OUTSIDE);\n+                        break;\n+                    case 0x01:\n+                        g2d.setColor(COLOR_MAP_WALL);\n+                        break;\n+                    case 0xFF:\n+                        g2d.setColor(COLOR_MAP_INSIDE);\n+                        break;\n+                    case 0x07:\n+                        g2d.setColor(COLOR_SCAN);\n+                        break;\n+                    default:\n+                        int obstacle = (walltype & 0x07);\n+                        int mapId = (walltype & 0xFF) >>> 3;\n+                        switch (obstacle) {\n+                            case 0:\n+                                g2d.setColor(COLOR_GREY_WALL);\n+                                break;\n+                            case 1:\n+                                g2d.setColor(Color.BLACK);\n+                                break;\n+                            case 7:\n+                                g2d.setColor(ROOM_COLORS[Math.round(mapId / 2)]);\n+                                multicolor = true;\n+                                break;\n+                            default:\n+                                g2d.setColor(Color.WHITE);\n+                                break;\n+                        }\n+                }\n+                float xPos = scale * (rmfp.getImgWidth() - x);\n+                float yP = scale * y;\n+                g2d.draw(new Line2D.Float(xPos, yP, xPos, yP));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * draws the vacuum path\n+     *\n+     * @param scale\n+     */\n+    private void drawPath(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(0.5f * scale);\n+        g2d.setStroke(stroke);\n+        for (Integer pathType : rmfp.getPaths().keySet()) {\n+            switch (pathType) {\n+                case RRMapFileParser.PATH:\n+                    if (!multicolor) {\n+                        g2d.setColor(COLOR_PATH);\n+                    } else {\n+                        g2d.setColor(Color.WHITE);\n+                    }\n+                    break;\n+                case RRMapFileParser.GOTO_PATH:\n+                    g2d.setColor(Color.GREEN);\n+                    break;\n+                case RRMapFileParser.GOTO_PREDICTED_PATH:\n+                    g2d.setColor(Color.YELLOW);\n+                    break;\n+                default:\n+                    g2d.setColor(Color.CYAN);\n+            }\n+            float prvX = 0;\n+            float prvY = 0;\n+            for (Float[] point : rmfp.getPaths().get(pathType)) {\n+                float x = point[0] * scale;\n+                float y = point[1] * scale;\n+                if (prvX > 1) {\n+                    g2d.draw(new Line2D.Float(prvX, prvY, x, y));\n+                }\n+                prvX = x;\n+                prvY = y;\n+            }\n+        }\n+    }\n+\n+    private void drawZones(Graphics2D g2d, float scale) {\n+        for (Float[] point : rmfp.getZones()) {\n+            float x = point[0] * scale;\n+            float y = point[1] * scale;\n+            float x1 = point[2] * scale;\n+            float y1 = point[3] * scale;\n+            float sx = Math.min(x, x1);\n+            float w = Math.max(x, x1) - sx;\n+            float sy = Math.min(y, y1);\n+            float h = Math.max(y, y1) - sy;\n+            g2d.setColor(COLOR_ZONES);\n+            g2d.fill(new Rectangle2D.Float(sx, sy, w, h));\n+        }\n+    }\n+\n+    private void drawNoGo(Graphics2D g2d, float scale) {\n+        for (Integer area : rmfp.getAreas().keySet()) {\n+            for (Float[] point : rmfp.getAreas().get(area)) {\n+                float x = point[0] * scale;\n+                float y = point[1] * scale;\n+                float x1 = point[2] * scale;\n+                float y1 = point[3] * scale;\n+                float x2 = point[4] * scale;\n+                float y2 = point[5] * scale;\n+                float x3 = point[6] * scale;\n+                float y3 = point[7] * scale;\n+                Path2D noGo = new Path2D.Float();\n+                noGo.moveTo(x, y);\n+                noGo.lineTo(x1, y1);\n+                noGo.lineTo(x2, y2);\n+                noGo.lineTo(x3, y3);\n+                noGo.lineTo(x, y);\n+                g2d.setColor(COLOR_NO_GO_ZONES);\n+                g2d.fill(noGo);\n+                g2d.setColor(area == 9 ? Color.RED : Color.WHITE);\n+                g2d.draw(noGo);\n+            }\n+        }\n+    }\n+\n+    private void drawWalls(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(3 * scale);\n+        g2d.setStroke(stroke);\n+        for (Float[] point : rmfp.getWalls()) {\n+            float x = point[0] * scale;\n+            float y = point[1] * scale;\n+            float x1 = point[2] * scale;\n+            float y1 = point[3] * scale;\n+            g2d.setColor(Color.RED);\n+            g2d.draw(new Line2D.Float(x, y, x1, y1));\n+        }\n+    }\n+\n+    private void drawRobo(Graphics2D g2d, float scale) {\n+        float radius = 3 * scale;\n+        Stroke stroke = new BasicStroke(2 * scale);\n+        g2d.setStroke(stroke);\n+        g2d.setColor(COLOR_CHARGER_HALO);\n+        drawCircle(g2d, rmfp.getChargerX() * scale, rmfp.getChargerY() * scale, radius);\n+        drawCenteredImg(g2d, scale / 8,\n+                \"iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAADAFBMVEVHcExF5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o7////w/fa69tVm6qL1/vlt66br/PNf6p7+//7o/PGE7rR37ay39dOL77nM+OCh8sbB99n2/vlH5o9e6Z2c8sPk++/j++5s66Vj6qBg6p6i88dn66Nq66VY6Zq99td67a6S8L30/vjb+ul57a2C7rNW6Jiv9M5Q55UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABmUTLUAAAALnRSTlMAJPkvN+wI+4DP1eoxP47t7v4GrpmcB6+Ptj7w+vMJ9Lm11DIlMI0m0DUuM/G06wfbVgAAAfxJREFUeNqNletzmzAMwGVhXg0NTbLkbtl12fvW/f//ya7Xy7h82Nruwa5p8yhhgPGAFrCN6VWfbOmHZEtCNkCSMUX/ZZ6S4SvkrneQbETceE66ELY/aLzXo8bru1M5Blw6IWvt9cIa8LmvkOAPbqcJU7wS5yPoJYi55PUs+tBDwmSNuYBSew69MqVRxWIV3R7BEzKySe3VsjTRrUWSNtneInu41vCNhuTZ0X27jb9VBzD+aUmYCPvvXyqvb4+1pBuJGv618OrddcjTgoSppLryCtRVqwn0Oqtz037tAp2ZHTKvypMqZ5ohnejJ0UEpGsW1ngR2oxjW6OtJuZGrLsOdtJ/XJGQqukPp9M5NTYJpVNKmLKVMJHnSrB+z3RaXYQ9Zpyhv12i062GXJHH7a1GhAuZjCCvWkIVV6JVrVsmotpOxQMIxbjrNUh+D4C9RvcFxB61rgHJqTczUAsKRlsxdDNVrfwp1JPwJEYa6+B0SZkUDr7ayrswYnank9rw0mEtJWUCU/FbI5WXlI7BF5eefBdkpm80ewp0EgjKONWRyUp6qHLlk9b7tbdIlVxFvxhu3nOa/4EwlN7e58F9QctY73S541qSmvPYi6CODd5k84It5e/VCAy7zKFTfArYHMuiQf3c79rzHyF/1vVvF0E3TwcHyYJ+496Ypj5P/uAmtfUpJqE0AAAAASUVORK5CYII=\",\n+                rmfp.getChargerX() * scale, rmfp.getChargerY() * scale);\n+        radius = 3 * scale;\n+        g2d.setColor(COLOR_ROBO);\n+        drawCircle(g2d, rmfp.getRoboX() * scale, rmfp.getRoboY() * scale, radius);\n+        if (scale > 1.5) {\n+            drawCenteredImg(g2d, scale / 15,\n+                    \"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\",\n+                    rmfp.getRoboX() * scale, rmfp.getRoboY() * scale);\n+        }\n+    }\n+\n+    private void drawCircle(Graphics2D g2d, float x, float y, float radius) {\n+        g2d.draw(new Ellipse2D.Double(x - radius, y - radius, 2.0 * radius, 2.0 * radius));\n+    }\n+\n+    private void drawCenteredImg(Graphics2D g2d, float scale, String imgData, float x, float y) {\n+        try {\n+            BufferedImage addImg = ImageIO.read(new ByteArrayInputStream(Base64.getDecoder().decode(imgData)));\n+            int xpos = Math.round(x - (addImg.getWidth() / 2 * scale));\n+            int ypos = Math.round(y - (addImg.getHeight() / 2 * scale));\n+            AffineTransform at = new AffineTransform();\n+            at.scale(scale, scale);\n+            AffineTransformOp scaleOp = new AffineTransformOp(at, AffineTransformOp.TYPE_BILINEAR);\n+            g2d.drawImage(addImg, scaleOp, xpos, ypos);\n+        } catch (IOException e) {\n+            // ignore\n+        }\n+    }\n+\n+    private void drawGoTo(Graphics2D g2d, float scale) {\n+        float x = rmfp.getGotoX() * scale;\n+        float y = rmfp.getGotoY() * scale;\n+        if (!(x == 0 && y == 0)) {\n+            g2d.setStroke(new BasicStroke());\n+            g2d.setColor(Color.YELLOW);\n+            int x3[] = { (int) x, (int) (x - 2 * scale), (int) (x + 2 * scale) };\n+            int y3[] = { (int) y, (int) (y - 5 * scale), (int) (y - 5 * scale) };\n+            g2d.fill(new Polygon(x3, y3, 3));\n+\n+        }\n+    }\n+\n+    private void drawOpenHabRocks(Graphics2D g2d, int width, int height, float scale) {\n+        // easter egg gift :\n+        int offset = 5;\n+        int textPos = 55;\n+        try {\n+            BufferedImage ohLogo = ImageIO.read(new ByteArrayInputStream(Base64.getDecoder().decode(\n+                    \"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\")));\n+            textPos = (int) (ohLogo.getWidth() * scale / 2 + offset);\n+            AffineTransform at = new AffineTransform();\n+            at.scale(scale / 2, scale / 2);\n+            AffineTransformOp scaleOp = new AffineTransformOp(at, AffineTransformOp.TYPE_BILINEAR);\n+            g2d.drawImage(ohLogo, scaleOp, offset, height - (int) (ohLogo.getHeight() * scale / 2) - offset);\n+        } catch (IOException e) {\n+            // no joy\n+        }\n+        Font font = new Font(\"TimesRoman\", Font.BOLD, 14);\n+        g2d.setFont(font);\n+        String message = \"Openhab rocks your Xiaomi vacuum!\";\n+        FontMetrics fontMetrics = g2d.getFontMetrics();\n+        int stringWidth = fontMetrics.stringWidth(message);\n+        if ((stringWidth + textPos) > rmfp.getImgWidth() * scale) {\n+            font = new Font(\"TimesRoman\", Font.BOLD,", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyODYyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402528626", "bodyText": "Any resolution for this?", "author": "cpmeister", "createdAt": "2020-04-02T18:35:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0MTQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0MTU2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399941562", "bodyText": "Not even going to log this?", "author": "cpmeister", "createdAt": "2020-03-30T05:52:54Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/robot/RRMapDraw.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.robot;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics2D;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Ellipse2D;\n+import java.awt.geom.Line2D;\n+import java.awt.geom.Path2D;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.image.AffineTransformOp;\n+import java.awt.image.BufferedImage;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Base64;\n+\n+import javax.imageio.ImageIO;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Draws the vacuum map file to an image\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RRMapDraw {\n+\n+    private static final Color COLOR_MAP_INSIDE = new Color(32, 115, 185);\n+    private static final Color COLOR_MAP_OUTSIDE = new Color(19, 87, 148);\n+    private static final Color COLOR_MAP_WALL = new Color(100, 196, 254);\n+    private static final Color COLOR_GREY_WALL = new Color(93, 109, 126);\n+    private static final Color COLOR_PATH = new Color(147, 194, 238);\n+    private static final Color COLOR_ZONES = new Color(0xAD, 0xD8, 0xFF, 0x8F);\n+    private static final Color COLOR_NO_GO_ZONES = new Color(255, 33, 55, 127);\n+    private static final Color COLOR_CHARGER_HALO = new Color(0x66, 0xfe, 0xda, 0x7f);\n+    private static final Color COLOR_ROBO = new Color(75, 235, 149);\n+    private static final Color COLOR_SCAN = new Color(0xDF, 0xDF, 0xDF);\n+    private static final Color ROOM1 = new Color(240, 178, 122);\n+    private static final Color ROOM2 = new Color(133, 193, 233);\n+    private static final Color ROOM3 = new Color(217, 136, 128);\n+    private static final Color ROOM4 = new Color(52, 152, 219);\n+    private static final Color ROOM5 = new Color(205, 97, 85);\n+    private static final Color ROOM6 = new Color(243, 156, 18);\n+    private static final Color ROOM7 = new Color(88, 214, 141);\n+    private static final Color ROOM8 = new Color(245, 176, 65);\n+    private static final Color ROOM9 = new Color(0xFc, 0xD4, 0x51);\n+    private static final Color ROOM10 = new Color(72, 201, 176);\n+    private static final Color ROOM11 = new Color(84, 153, 199);\n+    private static final Color ROOM12 = new Color(133, 193, 233);\n+    private static final Color ROOM13 = new Color(245, 176, 65);\n+    private static final Color ROOM14 = new Color(82, 190, 128);\n+    private static final Color ROOM15 = new Color(72, 201, 176);\n+    private static final Color ROOM16 = new Color(165, 105, 189);\n+    private static final Color[] ROOM_COLORS = { ROOM1, ROOM2, ROOM3, ROOM4, ROOM5, ROOM6, ROOM7, ROOM8, ROOM9, ROOM10,\n+            ROOM11, ROOM12, ROOM13, ROOM14, ROOM15, ROOM16 };\n+    private boolean multicolor = false;\n+\n+    Dimension size = new Dimension();\n+    private RRMapFileParser rmfp;\n+\n+    public RRMapDraw(RRMapFileParser rmfp) {\n+        this.rmfp = rmfp;\n+    }\n+\n+    public void setRRFileDecoder(RRMapFileParser rmfp) {\n+        this.rmfp = rmfp;\n+    }\n+\n+    public int getWidth() {\n+        return rmfp.getImgWidth();\n+    }\n+\n+    public int getHeight() {\n+        return rmfp.getImgHeight();\n+    }\n+\n+    /**\n+     * load Gzipped RR inputstream\n+     *\n+     * @throws IOException\n+     */\n+    public static RRMapDraw loadImage(InputStream is) throws IOException {\n+        byte[] inputdata = RRMapFileParser.readRRMapFile(is);\n+        RRMapFileParser rf = new RRMapFileParser(inputdata);\n+        return new RRMapDraw(rf);\n+    }\n+\n+    /**\n+     * load Gzipped RR file\n+     *\n+     * @throws IOException\n+     */\n+    public static RRMapDraw loadImage(File file) throws IOException {\n+        return loadImage(new FileInputStream(file));\n+    }\n+\n+    /**\n+     * draws the map from the individual pixels\n+     */\n+    private void drawMap(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(1.1f * scale);\n+        g2d.setStroke(stroke);\n+        for (int y = 0; y < rmfp.getImgHeight() - 1; y++) {\n+            for (int x = 0; x < rmfp.getImgWidth() + 1; x++) {\n+                byte walltype = rmfp.getImage()[x + rmfp.getImgWidth() * y];\n+                switch (walltype & 0xFF) {\n+                    case 0x00:\n+                        g2d.setColor(COLOR_MAP_OUTSIDE);\n+                        break;\n+                    case 0x01:\n+                        g2d.setColor(COLOR_MAP_WALL);\n+                        break;\n+                    case 0xFF:\n+                        g2d.setColor(COLOR_MAP_INSIDE);\n+                        break;\n+                    case 0x07:\n+                        g2d.setColor(COLOR_SCAN);\n+                        break;\n+                    default:\n+                        int obstacle = (walltype & 0x07);\n+                        int mapId = (walltype & 0xFF) >>> 3;\n+                        switch (obstacle) {\n+                            case 0:\n+                                g2d.setColor(COLOR_GREY_WALL);\n+                                break;\n+                            case 1:\n+                                g2d.setColor(Color.BLACK);\n+                                break;\n+                            case 7:\n+                                g2d.setColor(ROOM_COLORS[Math.round(mapId / 2)]);\n+                                multicolor = true;\n+                                break;\n+                            default:\n+                                g2d.setColor(Color.WHITE);\n+                                break;\n+                        }\n+                }\n+                float xPos = scale * (rmfp.getImgWidth() - x);\n+                float yP = scale * y;\n+                g2d.draw(new Line2D.Float(xPos, yP, xPos, yP));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * draws the vacuum path\n+     *\n+     * @param scale\n+     */\n+    private void drawPath(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(0.5f * scale);\n+        g2d.setStroke(stroke);\n+        for (Integer pathType : rmfp.getPaths().keySet()) {\n+            switch (pathType) {\n+                case RRMapFileParser.PATH:\n+                    if (!multicolor) {\n+                        g2d.setColor(COLOR_PATH);\n+                    } else {\n+                        g2d.setColor(Color.WHITE);\n+                    }\n+                    break;\n+                case RRMapFileParser.GOTO_PATH:\n+                    g2d.setColor(Color.GREEN);\n+                    break;\n+                case RRMapFileParser.GOTO_PREDICTED_PATH:\n+                    g2d.setColor(Color.YELLOW);\n+                    break;\n+                default:\n+                    g2d.setColor(Color.CYAN);\n+            }\n+            float prvX = 0;\n+            float prvY = 0;\n+            for (Float[] point : rmfp.getPaths().get(pathType)) {\n+                float x = point[0] * scale;\n+                float y = point[1] * scale;\n+                if (prvX > 1) {\n+                    g2d.draw(new Line2D.Float(prvX, prvY, x, y));\n+                }\n+                prvX = x;\n+                prvY = y;\n+            }\n+        }\n+    }\n+\n+    private void drawZones(Graphics2D g2d, float scale) {\n+        for (Float[] point : rmfp.getZones()) {\n+            float x = point[0] * scale;\n+            float y = point[1] * scale;\n+            float x1 = point[2] * scale;\n+            float y1 = point[3] * scale;\n+            float sx = Math.min(x, x1);\n+            float w = Math.max(x, x1) - sx;\n+            float sy = Math.min(y, y1);\n+            float h = Math.max(y, y1) - sy;\n+            g2d.setColor(COLOR_ZONES);\n+            g2d.fill(new Rectangle2D.Float(sx, sy, w, h));\n+        }\n+    }\n+\n+    private void drawNoGo(Graphics2D g2d, float scale) {\n+        for (Integer area : rmfp.getAreas().keySet()) {\n+            for (Float[] point : rmfp.getAreas().get(area)) {\n+                float x = point[0] * scale;\n+                float y = point[1] * scale;\n+                float x1 = point[2] * scale;\n+                float y1 = point[3] * scale;\n+                float x2 = point[4] * scale;\n+                float y2 = point[5] * scale;\n+                float x3 = point[6] * scale;\n+                float y3 = point[7] * scale;\n+                Path2D noGo = new Path2D.Float();\n+                noGo.moveTo(x, y);\n+                noGo.lineTo(x1, y1);\n+                noGo.lineTo(x2, y2);\n+                noGo.lineTo(x3, y3);\n+                noGo.lineTo(x, y);\n+                g2d.setColor(COLOR_NO_GO_ZONES);\n+                g2d.fill(noGo);\n+                g2d.setColor(area == 9 ? Color.RED : Color.WHITE);\n+                g2d.draw(noGo);\n+            }\n+        }\n+    }\n+\n+    private void drawWalls(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(3 * scale);\n+        g2d.setStroke(stroke);\n+        for (Float[] point : rmfp.getWalls()) {\n+            float x = point[0] * scale;\n+            float y = point[1] * scale;\n+            float x1 = point[2] * scale;\n+            float y1 = point[3] * scale;\n+            g2d.setColor(Color.RED);\n+            g2d.draw(new Line2D.Float(x, y, x1, y1));\n+        }\n+    }\n+\n+    private void drawRobo(Graphics2D g2d, float scale) {\n+        float radius = 3 * scale;\n+        Stroke stroke = new BasicStroke(2 * scale);\n+        g2d.setStroke(stroke);\n+        g2d.setColor(COLOR_CHARGER_HALO);\n+        drawCircle(g2d, rmfp.getChargerX() * scale, rmfp.getChargerY() * scale, radius);\n+        drawCenteredImg(g2d, scale / 8,\n+                \"iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAADAFBMVEVHcExF5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o7////w/fa69tVm6qL1/vlt66br/PNf6p7+//7o/PGE7rR37ay39dOL77nM+OCh8sbB99n2/vlH5o9e6Z2c8sPk++/j++5s66Vj6qBg6p6i88dn66Nq66VY6Zq99td67a6S8L30/vjb+ul57a2C7rNW6Jiv9M5Q55UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABmUTLUAAAALnRSTlMAJPkvN+wI+4DP1eoxP47t7v4GrpmcB6+Ptj7w+vMJ9Lm11DIlMI0m0DUuM/G06wfbVgAAAfxJREFUeNqNletzmzAMwGVhXg0NTbLkbtl12fvW/f//ya7Xy7h82Nruwa5p8yhhgPGAFrCN6VWfbOmHZEtCNkCSMUX/ZZ6S4SvkrneQbETceE66ELY/aLzXo8bru1M5Blw6IWvt9cIa8LmvkOAPbqcJU7wS5yPoJYi55PUs+tBDwmSNuYBSew69MqVRxWIV3R7BEzKySe3VsjTRrUWSNtneInu41vCNhuTZ0X27jb9VBzD+aUmYCPvvXyqvb4+1pBuJGv618OrddcjTgoSppLryCtRVqwn0Oqtz037tAp2ZHTKvypMqZ5ohnejJ0UEpGsW1ngR2oxjW6OtJuZGrLsOdtJ/XJGQqukPp9M5NTYJpVNKmLKVMJHnSrB+z3RaXYQ9Zpyhv12i062GXJHH7a1GhAuZjCCvWkIVV6JVrVsmotpOxQMIxbjrNUh+D4C9RvcFxB61rgHJqTczUAsKRlsxdDNVrfwp1JPwJEYa6+B0SZkUDr7ayrswYnank9rw0mEtJWUCU/FbI5WXlI7BF5eefBdkpm80ewp0EgjKONWRyUp6qHLlk9b7tbdIlVxFvxhu3nOa/4EwlN7e58F9QctY73S541qSmvPYi6CODd5k84It5e/VCAy7zKFTfArYHMuiQf3c79rzHyF/1vVvF0E3TwcHyYJ+496Ypj5P/uAmtfUpJqE0AAAAASUVORK5CYII=\",\n+                rmfp.getChargerX() * scale, rmfp.getChargerY() * scale);\n+        radius = 3 * scale;\n+        g2d.setColor(COLOR_ROBO);\n+        drawCircle(g2d, rmfp.getRoboX() * scale, rmfp.getRoboY() * scale, radius);\n+        if (scale > 1.5) {\n+            drawCenteredImg(g2d, scale / 15,\n+                    \"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\",\n+                    rmfp.getRoboX() * scale, rmfp.getRoboY() * scale);\n+        }\n+    }\n+\n+    private void drawCircle(Graphics2D g2d, float x, float y, float radius) {\n+        g2d.draw(new Ellipse2D.Double(x - radius, y - radius, 2.0 * radius, 2.0 * radius));\n+    }\n+\n+    private void drawCenteredImg(Graphics2D g2d, float scale, String imgData, float x, float y) {\n+        try {\n+            BufferedImage addImg = ImageIO.read(new ByteArrayInputStream(Base64.getDecoder().decode(imgData)));\n+            int xpos = Math.round(x - (addImg.getWidth() / 2 * scale));\n+            int ypos = Math.round(y - (addImg.getHeight() / 2 * scale));\n+            AffineTransform at = new AffineTransform();\n+            at.scale(scale, scale);\n+            AffineTransformOp scaleOp = new AffineTransformOp(at, AffineTransformOp.TYPE_BILINEAR);\n+            g2d.drawImage(addImg, scaleOp, xpos, ypos);\n+        } catch (IOException e) {\n+            // ignore", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0MTk3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399941975", "bodyText": "blank line", "author": "cpmeister", "createdAt": "2020-03-30T05:54:09Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/robot/RRMapDraw.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.robot;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics2D;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Ellipse2D;\n+import java.awt.geom.Line2D;\n+import java.awt.geom.Path2D;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.image.AffineTransformOp;\n+import java.awt.image.BufferedImage;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Base64;\n+\n+import javax.imageio.ImageIO;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Draws the vacuum map file to an image\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RRMapDraw {\n+\n+    private static final Color COLOR_MAP_INSIDE = new Color(32, 115, 185);\n+    private static final Color COLOR_MAP_OUTSIDE = new Color(19, 87, 148);\n+    private static final Color COLOR_MAP_WALL = new Color(100, 196, 254);\n+    private static final Color COLOR_GREY_WALL = new Color(93, 109, 126);\n+    private static final Color COLOR_PATH = new Color(147, 194, 238);\n+    private static final Color COLOR_ZONES = new Color(0xAD, 0xD8, 0xFF, 0x8F);\n+    private static final Color COLOR_NO_GO_ZONES = new Color(255, 33, 55, 127);\n+    private static final Color COLOR_CHARGER_HALO = new Color(0x66, 0xfe, 0xda, 0x7f);\n+    private static final Color COLOR_ROBO = new Color(75, 235, 149);\n+    private static final Color COLOR_SCAN = new Color(0xDF, 0xDF, 0xDF);\n+    private static final Color ROOM1 = new Color(240, 178, 122);\n+    private static final Color ROOM2 = new Color(133, 193, 233);\n+    private static final Color ROOM3 = new Color(217, 136, 128);\n+    private static final Color ROOM4 = new Color(52, 152, 219);\n+    private static final Color ROOM5 = new Color(205, 97, 85);\n+    private static final Color ROOM6 = new Color(243, 156, 18);\n+    private static final Color ROOM7 = new Color(88, 214, 141);\n+    private static final Color ROOM8 = new Color(245, 176, 65);\n+    private static final Color ROOM9 = new Color(0xFc, 0xD4, 0x51);\n+    private static final Color ROOM10 = new Color(72, 201, 176);\n+    private static final Color ROOM11 = new Color(84, 153, 199);\n+    private static final Color ROOM12 = new Color(133, 193, 233);\n+    private static final Color ROOM13 = new Color(245, 176, 65);\n+    private static final Color ROOM14 = new Color(82, 190, 128);\n+    private static final Color ROOM15 = new Color(72, 201, 176);\n+    private static final Color ROOM16 = new Color(165, 105, 189);\n+    private static final Color[] ROOM_COLORS = { ROOM1, ROOM2, ROOM3, ROOM4, ROOM5, ROOM6, ROOM7, ROOM8, ROOM9, ROOM10,\n+            ROOM11, ROOM12, ROOM13, ROOM14, ROOM15, ROOM16 };\n+    private boolean multicolor = false;\n+\n+    Dimension size = new Dimension();\n+    private RRMapFileParser rmfp;\n+\n+    public RRMapDraw(RRMapFileParser rmfp) {\n+        this.rmfp = rmfp;\n+    }\n+\n+    public void setRRFileDecoder(RRMapFileParser rmfp) {\n+        this.rmfp = rmfp;\n+    }\n+\n+    public int getWidth() {\n+        return rmfp.getImgWidth();\n+    }\n+\n+    public int getHeight() {\n+        return rmfp.getImgHeight();\n+    }\n+\n+    /**\n+     * load Gzipped RR inputstream\n+     *\n+     * @throws IOException\n+     */\n+    public static RRMapDraw loadImage(InputStream is) throws IOException {\n+        byte[] inputdata = RRMapFileParser.readRRMapFile(is);\n+        RRMapFileParser rf = new RRMapFileParser(inputdata);\n+        return new RRMapDraw(rf);\n+    }\n+\n+    /**\n+     * load Gzipped RR file\n+     *\n+     * @throws IOException\n+     */\n+    public static RRMapDraw loadImage(File file) throws IOException {\n+        return loadImage(new FileInputStream(file));\n+    }\n+\n+    /**\n+     * draws the map from the individual pixels\n+     */\n+    private void drawMap(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(1.1f * scale);\n+        g2d.setStroke(stroke);\n+        for (int y = 0; y < rmfp.getImgHeight() - 1; y++) {\n+            for (int x = 0; x < rmfp.getImgWidth() + 1; x++) {\n+                byte walltype = rmfp.getImage()[x + rmfp.getImgWidth() * y];\n+                switch (walltype & 0xFF) {\n+                    case 0x00:\n+                        g2d.setColor(COLOR_MAP_OUTSIDE);\n+                        break;\n+                    case 0x01:\n+                        g2d.setColor(COLOR_MAP_WALL);\n+                        break;\n+                    case 0xFF:\n+                        g2d.setColor(COLOR_MAP_INSIDE);\n+                        break;\n+                    case 0x07:\n+                        g2d.setColor(COLOR_SCAN);\n+                        break;\n+                    default:\n+                        int obstacle = (walltype & 0x07);\n+                        int mapId = (walltype & 0xFF) >>> 3;\n+                        switch (obstacle) {\n+                            case 0:\n+                                g2d.setColor(COLOR_GREY_WALL);\n+                                break;\n+                            case 1:\n+                                g2d.setColor(Color.BLACK);\n+                                break;\n+                            case 7:\n+                                g2d.setColor(ROOM_COLORS[Math.round(mapId / 2)]);\n+                                multicolor = true;\n+                                break;\n+                            default:\n+                                g2d.setColor(Color.WHITE);\n+                                break;\n+                        }\n+                }\n+                float xPos = scale * (rmfp.getImgWidth() - x);\n+                float yP = scale * y;\n+                g2d.draw(new Line2D.Float(xPos, yP, xPos, yP));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * draws the vacuum path\n+     *\n+     * @param scale\n+     */\n+    private void drawPath(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(0.5f * scale);\n+        g2d.setStroke(stroke);\n+        for (Integer pathType : rmfp.getPaths().keySet()) {\n+            switch (pathType) {\n+                case RRMapFileParser.PATH:\n+                    if (!multicolor) {\n+                        g2d.setColor(COLOR_PATH);\n+                    } else {\n+                        g2d.setColor(Color.WHITE);\n+                    }\n+                    break;\n+                case RRMapFileParser.GOTO_PATH:\n+                    g2d.setColor(Color.GREEN);\n+                    break;\n+                case RRMapFileParser.GOTO_PREDICTED_PATH:\n+                    g2d.setColor(Color.YELLOW);\n+                    break;\n+                default:\n+                    g2d.setColor(Color.CYAN);\n+            }\n+            float prvX = 0;\n+            float prvY = 0;\n+            for (Float[] point : rmfp.getPaths().get(pathType)) {\n+                float x = point[0] * scale;\n+                float y = point[1] * scale;\n+                if (prvX > 1) {\n+                    g2d.draw(new Line2D.Float(prvX, prvY, x, y));\n+                }\n+                prvX = x;\n+                prvY = y;\n+            }\n+        }\n+    }\n+\n+    private void drawZones(Graphics2D g2d, float scale) {\n+        for (Float[] point : rmfp.getZones()) {\n+            float x = point[0] * scale;\n+            float y = point[1] * scale;\n+            float x1 = point[2] * scale;\n+            float y1 = point[3] * scale;\n+            float sx = Math.min(x, x1);\n+            float w = Math.max(x, x1) - sx;\n+            float sy = Math.min(y, y1);\n+            float h = Math.max(y, y1) - sy;\n+            g2d.setColor(COLOR_ZONES);\n+            g2d.fill(new Rectangle2D.Float(sx, sy, w, h));\n+        }\n+    }\n+\n+    private void drawNoGo(Graphics2D g2d, float scale) {\n+        for (Integer area : rmfp.getAreas().keySet()) {\n+            for (Float[] point : rmfp.getAreas().get(area)) {\n+                float x = point[0] * scale;\n+                float y = point[1] * scale;\n+                float x1 = point[2] * scale;\n+                float y1 = point[3] * scale;\n+                float x2 = point[4] * scale;\n+                float y2 = point[5] * scale;\n+                float x3 = point[6] * scale;\n+                float y3 = point[7] * scale;\n+                Path2D noGo = new Path2D.Float();\n+                noGo.moveTo(x, y);\n+                noGo.lineTo(x1, y1);\n+                noGo.lineTo(x2, y2);\n+                noGo.lineTo(x3, y3);\n+                noGo.lineTo(x, y);\n+                g2d.setColor(COLOR_NO_GO_ZONES);\n+                g2d.fill(noGo);\n+                g2d.setColor(area == 9 ? Color.RED : Color.WHITE);\n+                g2d.draw(noGo);\n+            }\n+        }\n+    }\n+\n+    private void drawWalls(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(3 * scale);\n+        g2d.setStroke(stroke);\n+        for (Float[] point : rmfp.getWalls()) {\n+            float x = point[0] * scale;\n+            float y = point[1] * scale;\n+            float x1 = point[2] * scale;\n+            float y1 = point[3] * scale;\n+            g2d.setColor(Color.RED);\n+            g2d.draw(new Line2D.Float(x, y, x1, y1));\n+        }\n+    }\n+\n+    private void drawRobo(Graphics2D g2d, float scale) {\n+        float radius = 3 * scale;\n+        Stroke stroke = new BasicStroke(2 * scale);\n+        g2d.setStroke(stroke);\n+        g2d.setColor(COLOR_CHARGER_HALO);\n+        drawCircle(g2d, rmfp.getChargerX() * scale, rmfp.getChargerY() * scale, radius);\n+        drawCenteredImg(g2d, scale / 8,\n+                \"iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAADAFBMVEVHcExF5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o5F5o7////w/fa69tVm6qL1/vlt66br/PNf6p7+//7o/PGE7rR37ay39dOL77nM+OCh8sbB99n2/vlH5o9e6Z2c8sPk++/j++5s66Vj6qBg6p6i88dn66Nq66VY6Zq99td67a6S8L30/vjb+ul57a2C7rNW6Jiv9M5Q55UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABmUTLUAAAALnRSTlMAJPkvN+wI+4DP1eoxP47t7v4GrpmcB6+Ptj7w+vMJ9Lm11DIlMI0m0DUuM/G06wfbVgAAAfxJREFUeNqNletzmzAMwGVhXg0NTbLkbtl12fvW/f//ya7Xy7h82Nruwa5p8yhhgPGAFrCN6VWfbOmHZEtCNkCSMUX/ZZ6S4SvkrneQbETceE66ELY/aLzXo8bru1M5Blw6IWvt9cIa8LmvkOAPbqcJU7wS5yPoJYi55PUs+tBDwmSNuYBSew69MqVRxWIV3R7BEzKySe3VsjTRrUWSNtneInu41vCNhuTZ0X27jb9VBzD+aUmYCPvvXyqvb4+1pBuJGv618OrddcjTgoSppLryCtRVqwn0Oqtz037tAp2ZHTKvypMqZ5ohnejJ0UEpGsW1ngR2oxjW6OtJuZGrLsOdtJ/XJGQqukPp9M5NTYJpVNKmLKVMJHnSrB+z3RaXYQ9Zpyhv12i062GXJHH7a1GhAuZjCCvWkIVV6JVrVsmotpOxQMIxbjrNUh+D4C9RvcFxB61rgHJqTczUAsKRlsxdDNVrfwp1JPwJEYa6+B0SZkUDr7ayrswYnank9rw0mEtJWUCU/FbI5WXlI7BF5eefBdkpm80ewp0EgjKONWRyUp6qHLlk9b7tbdIlVxFvxhu3nOa/4EwlN7e58F9QctY73S541qSmvPYi6CODd5k84It5e/VCAy7zKFTfArYHMuiQf3c79rzHyF/1vVvF0E3TwcHyYJ+496Ypj5P/uAmtfUpJqE0AAAAASUVORK5CYII=\",\n+                rmfp.getChargerX() * scale, rmfp.getChargerY() * scale);\n+        radius = 3 * scale;\n+        g2d.setColor(COLOR_ROBO);\n+        drawCircle(g2d, rmfp.getRoboX() * scale, rmfp.getRoboY() * scale, radius);\n+        if (scale > 1.5) {\n+            drawCenteredImg(g2d, scale / 15,\n+                    \"iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAnxUlEQVR42u2dCXCd13XfQTlW7TqZWrHjGTu2bE/spHabONO4cS1Zcp3G44lrJ7LazqSJOpad2lZrxWpjjWPRai1Vscx9BUhiIQESCwkCBECC2LiBIAECIBZiJwACBEgQC4l94waAt+d3P5yHD48POx4W8n0zZ972vW+553//Z7nn3i8oKLAFtsAW2AJbYAtsge0R3O7cufPk4ODgBwYGBp6S1w/39/d/oq+v7xNdXV1Pd3Z2qvDdx/le9vuYyG/Lvk/dvn37ydHR0TWBVlwlmyjuiYaGho9fvnz5a7W1tT+qrb38Rk1NTXhVVVViRUXFmerq6sLq6qo2eb0h+9yQ31oQeS9S0yL73ZDfGysrK8/Le/YPld/flWP9UOQv6+vr/2Vvb+/7Ay29wraxsbF/Jcp5vaSkJKOtra2xvb2jW2Tk1q1O09vbbwYHh0SG7evAwKBH+vsHJ30eGND9hs3Q0LD8PmA6O7tNR8fN0Zs3bw20tbW3lJeXFwsw/lGY4TljzPsCrb/EmzT6GpHfEAX8idD7xqGhoevDw8P3RURpQ0Zo3EpPjyPd3b2mq6tnkqDUqUT34X8Ix+jrG7ACSDgPIuceldcWMRPx9+/ff1Gu6SmuLaAhP20PHjz4nbGx0Wfu3r37tjR8pdhoUciAVXZvb48oqtejbBR582bnlHLrVtckmeq7mzed997AgFUcQAx4ACHSf+/e3X0CzG8JI30yAIZF2ujp9+7df/P27TvnpAcO0gtpfKd3o+wuK9B9R8ctK45CO+33Qt2mpeWGEd/AVFfXmNLSS+bixSKTn19g8vIumAsXLtj3hYUX7W+VlVWmvv6KuX69xf5XmYFjThxbQdFtgdfb22fNBWYDuXv3TpWwwga59j8OaHD+dv0zQq+J0rO6xTaPYq9RuvZw7aWqdFVOa2u7qaioNKdPnzYJCQkmMjLShIWFmdDQUCvh4eFW3N/xXj+7v+e/8fGHzcmTp82lS+UCihsPndfNEGouYCcxR2NiJnpE0kdGRr4U0Ogs7btQ/Sek0dZBr0rxSu1uem5vv2na2jqsUmpr682ZM2dNdHSsCQ7eZXbuDPYoMCYmxhw6dMiCITk52Rw9etQcO3bMpKammuPHj1vhPd/xG/skJiba//DfqKj9AooIExKyW44bYvbvjzYnTpwSNrlszw3guBa3GVEzgVMJIwiQH8g9JQuovyD3+N6Apn3b+M8K1f9SKH4IOoVaoVionEbVHs5rY2OTKSm5ZLKyTlqFoByUBAAOH04wSUkoOsUqNyszy2SfyTbnzp0Tys8bp/x8U1BQMEn4jt/Y5/z58yY7O1sUfUKOkSbHOibASJFjJ5rY2IMmImKfPee+fVEmLS1DTEqxmI0GzzUiygqYqf7+fuugCpvdE9OwWYDw+YDGXdu9e/d+JD3lKj0GCqUHualWG7WysloUku5RQmTkfumph0U5x6QHp9oefOrUKVHIRSPxu2lqajKtN1pNe1u7uXnrlunq7pae2WuVIT3SyHmtiGNJL7WK6u7G5sMw7ebGjRumubnZHquoqEhYJlvYIk3OBShSLSCiog6ISdlrwcd3paVlHjbQV8c89I/7CZz7diM+grDBbz7ulP9h6RUZYjNHUAyKdztcUCuvVVU15uDBeLN3b6RtcN7T2Onp6VbOnDkjlFwtjX3LEwaiTDUj1lsflIYfvm36hFkqysrNmVOnzXEBTar07lMnTprS4hLTJWxz9/YdqySNMlQ4Hsft6uoSk1NrWSI9PdMKoIiPT7BsBBgOHIixrMD1q3lw+wn4M+LUAsJyYYM/fBwV/x7xkF/Eq3d6XY+le7fiW1pareLpZbt3h9pGTUg4Yhv71Kkz5uzZc8IIlVbp9GZvhbmlU/YpFi8/7kC02bp5i9kbHmGSjySZjLR0kymSIiYjMmKv2bxxk/3tgpiBmx0dpr+v3+dxHTq/bZV5+XKdXEuOOJ3Z1hwkJiZZNtizJ0x8iDhTVlZhfQW30+j4CH2e4wgbvC5t8i8eF1v/uxIv/7qvb8Kr9/asy8srhWaPe6g1KSnFKj47O0e88UuWljUGR0HevV2VBJ3TU2P3HzBJiUdMmfy3U0I7evn9u/dcctd+1yXUX1FWZpIFaAcioywzdIgp4FicA0DY13GRoNT+hrS0tEj0UW5ycnLstXLNAAAgHDmSbH0WnFY1Z45/4LDB8PAdzFCasMG/ftRDuz8RpV1Uz947vm5qumYVD81DpzQcNh9nrK6uzsblKHeq3q5AwJ43X20yB8SDp3c31NdblhgbHTVjD8amldGxUesTNDU0mnRxAKP27jONVxrM0PDQlAzjvib8B5xUwMq1p6Qcs0DAfAGKhoarD/kHTrp6kGu8KiHj9x9V5f+FNFAntp5GUuXTKwiliLNRPALtY1szM09Ir6qShu2fluJV+U6vHDRX6q+YPbt2m/zcPNtrx0ZFsaL8EZHRkZlkxIyMy20J4TAdITt2WkdwtiDAmaVnE54SMmZkZFkwA+rQ0HCTm3vB3rf6OCSsenp6FLxECv+HdPejlM37IY0C5WkSR209vZ5EC1QZF3fIMgCfCwsLrH330O+4ePd2d+MrFUdERJiCwkJrIlSZ0qjmPl7//RlE9mFf/gMb3BMTUVleYXYH7zLVVdVmcGh6EOi1IJwfwBcXF9voJDX1uHVgCVlhhitXGsfNntMhYEWiILmPUbmGtaseBCQ9pEF/rqGdt4ePrSeMgx5xnmgg0rNNTc0PKdoNAm8waKPT2Pv377exPL9rmKehHmZgNsK+Vu7dtWC4K9/VVEskEhcnDt31h1hnquvS9wABYBYUFFpHEVNADgHTQLSgbeI4iD32PvifXMNWacN/vprj+3X9/X0j3JTaPaiPmy0ouOhpBHp9ZmaW0H2Fddyma9ypGholx8XF2YweDYgf4C2ugZtpxf0fBQSvpaWl9vj4MLO9Rrdp6hNzVF/faEGAowjjAX4SWhoyOmMYndYk8D+5htRVCQLpOf/oTuporwcAhEy7du2xefa0tDTr5F29evUhup+t8D9ie+x+VVWVh35V1FN35LZLpv/eDQgAcPPmTRMtEcWVunozNDA4r2vFn+E4JJXwc2A+oh1AQbg4kVYmb9Br/Ynbt+9Er5qkkVzoE6L811C+hniq/GvXWuyNYgOJ6dPTM2yYRoPMV/nKBHGxsSYrI9Nm8Hw5jBP7OoUgjvRP+n5CHrbnFhTyWnyxyMRGx5jhBV4vrMgIJG2ASaBNkpOPSkdonjRsTQfiWu/dux+yKgpQRPn/Uyj4dmfnhPLp9SR2uEFoH484PT1LYuNSj/c738ZEGhsbTXhYmCkrvWTpU7N2bsEsIM7nXs/nyd/7FjFjNuZH6R1t7SZyPDTUHMR8QcCxyWAy3oBTSNvExcVb59A9pqAgEFMUttK9/a/KzQ13d3dN6vkIoR03mJKSYmm/rKxsUopV07cq3p+nk5KiYhMRGib2td5090xUA7mrgiZLj/U1JstEBZBbiNEnCkAGLWBPZp2wbIN58HXtcxH+S61CZmam9S+io6PtWAf5AvWXlAnkGh7cuzfy8xVbsSM31E6unPBNlX/jRpu1cwzewABpaenW2aPx3I0wXwCwHzn9pIRE09zU5LME7OGSMOcanXxE5/j77in3V2A4Q7wDFnD7I6OsX7AYAIBJAC++ECBgkAsTSYis2UOXOeiXjvbNlWb3Pyg2spTeQYNi0zWfTzYMTxflk9ghoaL0txjCOWMORJt0CSGvXbvmyTNMJ62tbUKz9Xa0sLm5ydTV1cr1djy0n3etoO2FYg6uNjTaMYOpzM18BB8DEMAEDHTRZphKHUeYMAc9AOaydLjfXzEDO9ITYp1hVC3W6LDIJR3qKD/FjtoxeKP22JeNnuqzL3tt31MzIOeMCAs3JzKyBADXH6oS8iWwEulaMpC8p2RMe5p7+Nm7hlBH81qut9ho4HrzNZ8A8GY2/W4mtoAJACVtRQ0CrAl7atZQQUCtxPDw7dMrAgAjIyMvy03ddah/wu4zCsYoHlRGYQYFFnj8DN1SrqVChgzqy8rKsuh3C995C9/TQFAlAzzxBw+ZTRs2il0+KSbAoUwV9T+8hV6l9Mpn7C1s5et/k+sMHVYAAJiAw4fiTXJSkqe6SK85IyPjoev3dW/c98mTJz1CW5w9e9YWr+AYEh145wkUBHQAagqW2+5/Uuj8qtp9bbC6uis2ziftSZKHShsduZtKJsfkE6Ixvb53/8YY/2D/gB30STt63PZqejQ9W8cYphLCLaf3t1qv29d/3IBw03BT41XLAIwsPpxn8H0Pvu516vYYMJculdlkkfpPjJVo+ZnDRnb8YGRsbOzfLRsAhPr3aWUuI3Wa22cINyYm1tLYuXPnrZfti8q9BXs+0z7e0t3VbWIkLk84lGDqLtdbhboFJfsSrvOKhHINYs9JPSsY3P/xBkN7x017n1WVVSYiPNyaoLle72zECVP7bFo8JeWohIYHrWMIaLkWJzLotDUUQ0PD+RTWLEfI9w3H6XOcLpTPxTHyxYge4R4U19raOusbnw8A+E96RroJ3RNmKsurbLJJBaqfWlpFrlnHkVf3b1OBqK2t3d5PTvZZm3YmCvAHANTPoeNgGgABACB1jPJpZ1dkIKHh/VeXdB4CGSlxWq45jt/EsC41e2S0oC3sNB4/zo1bWSoLbSD3MSgSWb9ug8k9l2fNQHPzdStuMPiWay7xvY+CwmGENpsASjycYHLETusAlPf9zfTdXABPZpN6RxJFpIxJo6ufNeEP9HVRaLNkALh7997b4omOTXj9TshHAoPBnZSUVGv3p2qgxQYAnvNGcQSPSSNRrg29u0UB4RY3AJqbr00LFGUFJouUl5WZHdu3m+s3Wh4ya3O9t9nuy/gGvhQONf5ATU3tJL8Ef0DYaNsSFXY8+MzAwGCDe5CHV+r0NJ+dlXVKnZQlERQRtS/SbN+6zeQX5Fvbjr2ci3iDBvEGAcdl3sDBgwfNkDigC71u704x1T60JVEULIB/BRi4nolMYSfm4oE4hH/q94Ee6f3/13tsn8JIKl1AKBdJD1sq5SsAqNR97bXXJCxLFl+g0oZ2CCbBLXMFBvdCY3MsBm+2S+9n5HKp7k39AeoJaFuSQ3Q0zK0TFdyyjilRmERkRf4O+57u6+u/7z3Kh813qP+YHed3EiZLKwzZRkVFmV+8sdacETaiopjwDlEw+ALEdKIA4D1hGN44cw+Wgt28xyrInhYWFtksIaaWQhpPdNLeYbOvst+AOOf/1p8FHu86s3W6PbafhA9eP9SP40fFrvsGfN3MbG7Y128zNRoO57p168z69RtsFhIQMGMHUTB4A2IqUQAwUIOTSVTDvEEqgnxd01Sfp7tv7/0Blo5NeAvf8zsJItqaPEtRUYmnxoKyMumUDyQsDPdLRCAHfVKoqM8BQJdnoEdn6oBMHD9ngkf3sgkOIQDYvHmrnS9I2RnFmSSnAIK+eoNChe8BAO9xtoqKiu28wi1bttjK5JnubyrlT7e/JtJmIzU1l22GkCQbDqETnnZ4MpZinlvGxkb/wA+e/903enq6xwd7nN5PI+mgBfTf1tY25wbwhzQ2XjXvvPMr8+6762xeArMEG6B8/BUAoaDwJezDFC8mnxw4EG02btxoo4XFvDc9FkqFvmejfPYjD4HDrWnic+dyJ6Wu8QckIvg5/tpi9v5/Jp2/1ru8ixy1k/Q5aidXQsGgebmFxu3o6LC99s03fyENtVfMU5pc4wWh8woLhqqqy7aHEzaqUIIOrTJegbe/Y8cOs3v3bjtHUCl6IaLK1xHT+QhAcEzSMcsCsK9GBA4IOmCpmkWtHhoZGflLadRh9fx1QAXPHwcQAJCwcN+or/e+GmMuv3u/n0r0dxwnBlg2bdpk1q5dawFBj8aOnj59xtbnX7hQYHJyzgtTZNqZxaGhYdaP2Llzpx2wodHdNnqqa53Nvat9B5wLAQARAdercw1gKx0n6Ohw9hNn8N8sGgDEw96to32agoQeqfBJSjpqc9Z6g+6bdb/3Fu+Gmel3731n6m26D8qjwajN37dvn/nZz35mXnrpJfO9771sXnnlx+bHP/5784MfvGK++93vmp/+9B/smgIXLxZ6nNmZ7mu6c7sdO5SC4hdDOF5eXr6dFc2cSZiYRJUDAmcfYeMTizWj52MDA4Ml7pw/JgDlU9WblJRk4+KpFLnSBKXAVtAoQ68I4AAkE7OWFke0ty+2ACacXcxUfHy8iY6O8YxuqkMovsAoC1ctwqDPyHPd3T2j7sQPoZ8WdzKmj/O3GpTvZg93Jk7tsr8VD/DcMhtlT7Uv14yJOnLkiDVbRDs6cun4Au0Ukf5woc7fGvEo33RP5wIEeNY4H8SjLMawWnq/v0Vp3lvR/hDOQ0UxIaouTqH1DI5D2E4GMWPBqd/BwcGz7kEf8uKkfKnyxZkiBet2cFab0hbjmp0ayPYlFVgXIUGVkJBoHXJ3/QK6Er1dFxP+9EIA8JTj/E3E/oRL9H6ntt+ZiLGYjekvxbkzarP5fjbnRfEoYamVrwCwtQk5ORKJOaOExcWlk1hA/IDb9+/f/68LCf/+zGmgTs8EDyYzEnpA/6yMgR2dbRZroTJdmnQux/BW/nTfT5WQcffC5ZTy8nILADolo4ToaKIsrv3B8PDwO/MGgPx5W2fnLU/v58BM3Wbgh5W4qO+HIeYb0841/tXGn8tvU+3rvb+v770Vj93Vnqevyy2Ut5MUYnCIkFArndUUiB+QOO/JpRJLnnIaYqLog8QPCyIR/pEhm23Dr0ZRxdPbV5LS3UI4mJV1wvpkAIAUt+YEqGCSDporfsD8agblz50O8p0RJ4ZGSf0CAoZFlf6XUiH+2HcqUcWvZCF/kZ191uoEM8CQ8UTxayusdW10dPT35lP0+fuOo+MAAAZgpIy6NE5GAsWb/t2JitUqGsbR22G4lS5cJ5lYnHIAwAiomgHHFLSOiS/35fmM/v0VAHCv1we6lAFKSko8vcwf2a75ZsgW8j+l+NWgeDcAGAvAKcc3I0ejJe76eufO3b+ZT/7/NadhbnlGmljwiJMAAOL/laT8hQiNCJWuRgEElIdppRCvWsbmFLLeYBLK+jkDYGBgYK8bALyCsoMHD1mHg/Hx2WaspvreV7pzLseY737uEI4GXK3KVwCwvD0hIMPD1AlQp+GuZJZIIGbOABgcHHpXq0zUBBBqIEQAy5UAWQxRmqe8yy2rFQSMXDJXkujMYed6DwCuXWvGWY+djxP4VG9v3+sORTomgJwzI4CpqU71z1LlvRdLfCn9URAAzQRVAIDoUvbMehY/LU6cwM/OKwwcHBxc097e9s2rV5uG8SyJM0kAMbuVky5HNsybwqfbz03zj6LiVbhHVl1JTEy2ANCK6Kama+vnpXiJAD4qTqAdS25oaPj8kSNJt5iSBP2TdWIIGOpZyfGxesmTp38traCcpTgPAKBT4qMBAMZomEsoQPju+CTeD4kj+IW5JIB+Kj3ofE9Pzwt1dXW/FxMT200BIiNOjD1zspUIALdTt5yKX2rhvinJ16eaMHGEeg0JD/9WdPhVaY+z4ifMfmhY7MYbN260QKNDTU1NFQkJR+4S/hFmhIWF2wUQ1ANdKQIA6HE4RI+T8hHuHRPA43IYqENXmOsrVxpOSZv0XLlyhaqtE3MBwC9wIHRAgcEgSqs5MIkg5v4RXqwU5aviH1cBAFQ96yrrlIqjN53jiD/Q2Ng0JwCsVQBoSpGaM6gFU4CNAXne8ehsZKb9Z3s8ta8MhjiLPT2+AKA9iAIiIiI9q4mQDFIAkMIXAGTOwQfofIMe7gYAB2TNHwRH0BsASyXeip+r0GAL+X0lCgCgNhDd0EkBgHuCK3kBAcLxuTiBbzFn3r1sCsIJsDOHDx/2GwC8mcAtC1H8oyRUYU8GQKvNAu7atUsYep8tENXezxzHmpo6TPbsQ8Kenu63+LMqXmeeMBIYHBwiDsYBe+KliHGdBRya/dZ4S6kofx2X5fHQCQDgOYeMDSgAmOdIXqC1te31WQOgt7f3x01NzaNuAGAOyAQSavBQRufEvmNfbwX6iot9/e4WtW/crIrevPuzrwbx/n2676bbx9e5pvr/TMqe67lncy/6PTOYmf7GjOGYmIM2E6j0DwAAREfHre/NGgB9fb3/meyfrozBK+aAMWdOQqzJqpb+SnR432RAphbairWYmLoOA5Cqv3y53iof+gcAmISurp5Pz6UU7E8bGho73EukwARMQQIAO3YE25k1iw2AgOLnBwBqM1A+gjOoC1zoNHdxCu/09vZ/cC5jAH9w5UrDdfdKWzABuQAcwe3bd9rVLN1UvRDhJljyfbUJCljuY9F+6CI4ONgCgBVL1fYjRAAlJZfyhofvrJlLMcj7q6qqK7yXWuNgRAEwAItAEir6CqO0N/tStPu93jQ2TMW7MfS76cS9z1THcB/f13G1R/n63f39fBQ107lnupfp7oO25KETOOek6Zn1rLaf+J8p8JWVVVvmPCAknuMpaMS9zBqfSQRhBpzVKVp9AsDttXsDQHu7+2bc4lbEVPv4alBfv830/9kcy5cS53Jcfwu+GAU6dEyiNMr20BPUz2IXOIB1dfVznyMoCn+blTLcy6aBKgoOMAM4gjDCXEK0ldZ4j4IwP3D//gOep5mjM+396IcFMaTt514UKmHDC8SP7owSyGJiiAIgNzdvxuSMd29mYALxdTO+vp9q38dZ3G3Ck8xgZJ67SJiOqda1kMaXuhkUpp77I2klbPgQ8SRocoMAiiHd6GQEE23Wzldsqop3X6z3e7f4usnlkMU4/1LeA6ub4JMxVM8YDTpC+fR+OrBEAAUdHR0fmVdhiCi/loO5l01jHR19OnZExF5rg7xDk+VU4OMktD1VQHRGWIAHVGP7UT7OH/G/yI6bN2/Nb8EoUfjbsICurafOha5Wid1hcShv75kLCyjI/8pn2Tp0gPJxzvHTUD7UT+8X+h+T19eD5rtdv379U3iRunYewkmYH8AJOTnDkN42nosLiH8FXbDI1bZtO6xPxoQQd+93Vjwr7pJ9vzhvALS0tLxHGOAKiNIFFmEBlojREjGWZyUVuRDad9/YbPed7hgzHcv79/n8Z67X7esapzvGTOfjIRdU/eCMAwBdEFNtP58LCgrjFrRCSGtr6xpR/h5dZFFBgKdJeRg+AGvpsUyMUj+0NFc08x+V2e473TFmOpb37/P5z1yv29c1TneMmb5jOhi2H+XjjNNJ6fna+1ks4uLF4hcWvEhUbW3tD8rLK+yB3SwA/TjDw7utT8BDkX0pISCLL5hcinJIyaMDJoQCALX99P68vPwH8v4jCwaAUM8XhPKHcAbVFCCAgNJjzAAX4mScAsrxt9D7WRUkPDzC9n7MAN6/rnpK74cdzp/Py1qUdQLFw39fRUVlAqjiJO6Flyk+JBogDoWGiP+ZNBoQ/wkgYHk4bL+zUGeKx/GjE+KfsYhkUVHJ84u2UmhlZdVfC6pucwJlArU55ARgAUBAVooLDCjKP3L58mX78E2qf+n9vJKYU+p3bH8JC0dlCEv8xqIBoKqq+rcuXSpvBl2cCMUrCFi5mogARLJqJRQVUJb/ej8LcxH6MRhHHaCWfNE5KQbNzy8QBsh7uaKiYnGfGSBeZRS2BpRxQgUAJyUiwBkJCQmxiSEuFLQGZHGFcJshXxI/mF7MMoys1M9K5+fOnW8QHXxm0Z8XUFxc/PGiouL7paWXjNsU4AuQg2ZCgjM+kDAOkIDCFlMIs5n7p3n/tLQMa/sBgTp+BQUXH5w5k73Tb4+Myc3NfYsnaIA2BYE6hkQE0NLWrduFBQoDSltEgf4LCwuFYXfZMRg6G+2P8pX66f3Z2Tn9wgBf9BsAhFp+68KFC3WYAk7uPHjBSRLheQIAnJM9e8Lts+4CylscYcw/OtoZ88ffwu9C8fR8OiNJH/IyJ0+ePuv35waKh/kDagOhHAUBFwILsEwJvgA0xRO29Lk72K6VKGpXV7bUmszME7bki7bF31Ll0/50RvTBI2bPnDnzlSUAwLmP5OScL2LJWKhHHZHxoUc7gdTJEO6yF+6AYGUqHyFqWclAoI2duRjhlmEJ+zTbRydED2L3AcDeJXt0rFDNG7m5+WNQDxcBGkElF8bj2vAHMAVcNBe80hoVSo0/eNDs/NWvzNZf/tLEx8XZ7NpKZCc6k3r9ONs43bQ5wED5UH9W1om2zMzMjy0ZALKzz645efJUMTEnIOBilJJgA/LUoBXkHjgQa5MXNPrKkCoTFRllkl/5H6boG98wRV/7mkl56b9JbL3NU2O33FJTU22Vz4pstCGOny7+hPI15MPZFn9gJC0t/ZUlf3x8enr6p1kqhh6OHXKDQDOEOlgUExNjhzNXQuPybMOYtWtN2fNfNYUvvmjyX/xPpvS5582uV18158+f9zhdywuAGlt2r9RPW6J02lmdPuw+z206fjy9Mj094yNBy7EdPXr0rxkPgIr04tQzhQm0ZgAHhhnF2NvlblwmUST/5Cem7NlnzcW/esGU/PmfmxIBw9GXX7bFLYRcy32NPLYOH4q2ow2heTqYW/nnz+eh/FFxvF8LWq5N7M57U1PTolir1g0CBQLswICFk73aZRsYdBMiLjcAyp/9isn925dM/gsvmEtf+YoFAMusLCYDzPU+OTcstHNnsNC+40MxHU8fZInyaVNCbh4bd+xYauHx42lrgpZzS05O/mhGRkZFXl6eBQEXCQDUJEBTzuJS4daZ4TEzpIrxC2igpRYaOPknr5my554zFQKC8meeNWXPPGOOjQNAAbrUQptgUjXZQ1uhfOy+Otsofzze51ExLUlJRz4ZtBK2+Pj4z3HxeXkFD4EAU0DBguPMhNsb5Dk3+ATLDYDyZx3lI24GWOprAnQ84HLPnj1WtMaPtsPZ03CPnk+UxXrAYlK/EbSStujo6Nfp7XimFy9OOIaAARSDWpANtWEOEhMTl6WxHwLAOAiOLhsDVItSs+1AGusuMM2bMX4caU240fN5wqmj/GNj8fEJb8vrEytG+Tk5OdYOxcbG/vezZ7OHCgryPUygIADNpDCJDAACjEARiTqMNARmwd/iAcDzz5uib33bFIqUfXnCBGCLl+I6qqvJoFbbns5QOm2i6y85Ty0vsZ2IdnSUf876UIcOHdoUtJK3gwcPrsXRys+/aJHLjQACTRgRNehUJl3XDqSz4vVSNDzXlvL34gRK6Jfz/b8zRf/xW6bo6183R7//fTu1Ggbw17np8TxnCZBdulRmV17VtkD5sCQJNdpMHT6UD7OSBIqLi9satBo2YYLthCmYA25CnRgdROK9Yw4cZwcH8cSJk+II1fodADirsW+9bRmg4MUXzYXvfMc6gu++8oqwUZlVkj/PD8B4NjEV1bt3h9l7hxXpGLCh5lVU+Tk5uVb50dFxETExMU8GrZZNQJDJxedfuCg9vMjjzKiDCBtQ0KjmABrkQdQ6wOQvBeB3sJ5O8quvmtI/+w+m9Kv/3hz74Y9M8M6dnujEX72/puayh/KdUdMwT5yvYbPG+Th89PzU1GMj0pYR+/fvf3/QatoiIyPXCGLDSWqAZG5KcwUKApSNR6tz26guZhyBCY+aPvZLL5Tjiqkyu1hXd9t2+/Blf1G/Dovje+giW7reIj6QO6+v6V0AQeR0/Hi6iYmJ/nXQat2ioqLeGxcX8xNWGgfRgEBRDhDUJHDTOuOYBuJV7J3sX2Azc9jNxRbAxQAQax3xfrGPz7HJfLJ+D7WSoaF7PMoH7CgYxdMe3so/ffqs9Pw0kmj/W9hqTdBq3yRE/OapU6dHc3Nzma5kb1jZQB0eaF+dIgcEIZYq6SWaUfMHEBZb6PXu+gg1cXpfZEa1hEs7A68oH7+JSCk5OXk0IiLif+3bt+89QY/Ktnnz5j8SL7sOhHOzTr6g2MMGAIHKItgCuwgLIICA6Wepqcdlv1Lbs1YiGNTDx5HEm9fl9JTRGB3F/nOP3LdGSGrvcQL5X0LCkRthYWFfC3oUt5CQkI/Fxx/eDgjUL9CGQGgYLSwhDYp3TAk0DYh/AH3yuHT8Choap225ezs07wkvU1JsJm/79mB7zVw7DEABp4bD6gupl09bkOABHDExcYcFOF8KepQ3AcEToaFhL1LFwiASTKBAcDOC5g2gRG3MHTtCbLmZLojEY9NpRGc9nNpx+q3wvM6kvLnuD/vwXmdDc61k7fbti/Qsm4PpAqxcL06cFmyqneeVe6bXa14fdhPKj5f/fjDocdm2b9/+9ZSUozcJdVCi5gy0odQ20oAomPIyaHXCLAR7BJrlSWbE+FrqNRvluyONmRw6KN6pzi2yCiOlrdfBq75H8UQ2ZDeJdLg3ZTiAzmdsPZEOzCAAuiP/+1XQ47ht3brtU/v3x4QL/bXRIxQI3qaBz2TISJHiI1B3SNRACToNrj1OhSlTKIF9OV5RUZGV0tIS6/VjPlC6zrbRiIDvmd6G515cXGxLsXkurxOOxdnzcE73eXkPzZPT0AEcrlXvw614tfVcl4C/V0LlQ1u2bPl00OO+7dy584sSi8dIaHQHWqTB1FFUICgz6DAz38MeTE1HARs2bDKbN281W7Zss8pBMfp5x46dtiYhMjLKKio2Ns6WWx06FG/X1uWVKuYDB6LtPjwWByrfssX5vypdj7lu3QbPIlkKMkyWevbKZG7F0+sxe5mZWazsvUvu+dmgwDbJJLxXFPeHiYlJNlJwRwvamzR8dAOCRtfJEfRAxhY2bdriAQSC4lAk7/ltOmE/N4h4v3HjZns8PHnYAB+Fnq5ZO/e16Wd18DSpg1N7+PDh2q1btz69bdu2JwMan2aTBvobofBG6V2jGjG4/QS3r6BOFY0OCDATrF3AexqeWBxQ6CLX0Dbitt1qv/V7HDoykkzFwgnlPLr8mjMB03Hi9Dr0mvheFQ/V6yCO2Ple8VPCNm7c9IGAdme5rV+/4YmQkF3/IBSdJw5gPxEDokDwxQwoQc0Hn3XyCqDQlTNhCy2wcMfj9GZMi+5LGZZOvFCQcW5VuvZ2BYPSPM4dM3jT0tIxK7W7d+8JWbdu/ecCGp3ntnHjxt8WRvhSWFjYWxJntymtqtPoZgelX+2RKqoo/azOJUp35yDcIPI+ln5W4Ol53b2deD45+VhTaGhoiVD9tzdt2vSpgAYXuEl8/PSOHTt+l/cbNqx//4YNG/9InLWNWVknxuhtNL43GNwRhZsppgKIL7C4lazH1NhdlY6JQQhRo6Oj6zdv3vztDRs2vE8UH7Dx/t7eeef/fUC89OfEq3/z2LHURAFE+enTZ1rPnTs/dOFCvqd3quJ8KdOXeP+emzuheOnlIydPnu4RZ/OanLMoOjo2VJzF7/zTP737+YBGlnmj5wUHB39WGOO/xMTErk9IOHJOHMk+vG966YQzWTglCMa/vy+2vF/ovFn+e0mcyAsSmaTExMSF7Y2IfDUkZM/zmzdv+XCgxVfwtm7dujXr16//kPgPnxPP+8uisGe2bNnyDNFFSEjI3+3Zs+dH4eERr+7bF7lXJFhA83P57lsS+z+7ffuOP5Z9Pyf/+bRQ+UflGL8jpuc316379XsCLRvYAltgC2yBLbAFtsAW2AJbYFv92/8HjvdLzWbjz7QAAAAASUVORK5CYII=\",\n+                    rmfp.getRoboX() * scale, rmfp.getRoboY() * scale);\n+        }\n+    }\n+\n+    private void drawCircle(Graphics2D g2d, float x, float y, float radius) {\n+        g2d.draw(new Ellipse2D.Double(x - radius, y - radius, 2.0 * radius, 2.0 * radius));\n+    }\n+\n+    private void drawCenteredImg(Graphics2D g2d, float scale, String imgData, float x, float y) {\n+        try {\n+            BufferedImage addImg = ImageIO.read(new ByteArrayInputStream(Base64.getDecoder().decode(imgData)));\n+            int xpos = Math.round(x - (addImg.getWidth() / 2 * scale));\n+            int ypos = Math.round(y - (addImg.getHeight() / 2 * scale));\n+            AffineTransform at = new AffineTransform();\n+            at.scale(scale, scale);\n+            AffineTransformOp scaleOp = new AffineTransformOp(at, AffineTransformOp.TYPE_BILINEAR);\n+            g2d.drawImage(addImg, scaleOp, xpos, ypos);\n+        } catch (IOException e) {\n+            // ignore\n+        }\n+    }\n+\n+    private void drawGoTo(Graphics2D g2d, float scale) {\n+        float x = rmfp.getGotoX() * scale;\n+        float y = rmfp.getGotoY() * scale;\n+        if (!(x == 0 && y == 0)) {\n+            g2d.setStroke(new BasicStroke());\n+            g2d.setColor(Color.YELLOW);\n+            int x3[] = { (int) x, (int) (x - 2 * scale), (int) (x + 2 * scale) };\n+            int y3[] = { (int) y, (int) (y - 5 * scale), (int) (y - 5 * scale) };\n+            g2d.fill(new Polygon(x3, y3, 3));\n+\n+        }\n+    }\n+\n+    private void drawOpenHabRocks(Graphics2D g2d, int width, int height, float scale) {\n+        // easter egg gift :\n+        int offset = 5;\n+        int textPos = 55;\n+        try {\n+            BufferedImage ohLogo = ImageIO.read(new ByteArrayInputStream(Base64.getDecoder().decode(\n+                    \"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\")));\n+            textPos = (int) (ohLogo.getWidth() * scale / 2 + offset);\n+            AffineTransform at = new AffineTransform();\n+            at.scale(scale / 2, scale / 2);\n+            AffineTransformOp scaleOp = new AffineTransformOp(at, AffineTransformOp.TYPE_BILINEAR);\n+            g2d.drawImage(ohLogo, scaleOp, offset, height - (int) (ohLogo.getHeight() * scale / 2) - offset);\n+        } catch (IOException e) {\n+            // no joy\n+        }\n+        Font font = new Font(\"TimesRoman\", Font.BOLD, 14);\n+        g2d.setFont(font);\n+        String message = \"Openhab rocks your Xiaomi vacuum!\";\n+        FontMetrics fontMetrics = g2d.getFontMetrics();\n+        int stringWidth = fontMetrics.stringWidth(message);\n+        if ((stringWidth + textPos) > rmfp.getImgWidth() * scale) {\n+            font = new Font(\"TimesRoman\", Font.BOLD,\n+                    (int) Math.floor(14 * (rmfp.getImgWidth() * scale - textPos - offset) / stringWidth));\n+            g2d.setFont(font);\n+        }\n+        int stringHeight = fontMetrics.getAscent();\n+        g2d.setPaint(Color.white);\n+        g2d.drawString(message, textPos, height - offset - stringHeight / 2);\n+    }\n+\n+    public BufferedImage getImage(float scale) {\n+        int width = (int) Math.floor(rmfp.getImgWidth() * scale);\n+        int height = (int) Math.floor(rmfp.getImgHeight() * scale);\n+        BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);\n+        Graphics2D g2d = bi.createGraphics();\n+        AffineTransform tx = AffineTransform.getScaleInstance(-1, -1);\n+        tx.translate(-width, -height);\n+        g2d.setTransform(tx);\n+        drawMap(g2d, scale);\n+        drawZones(g2d, scale);\n+        drawNoGo(g2d, scale);\n+        drawWalls(g2d, scale);\n+        drawPath(g2d, scale);\n+        drawRobo(g2d, scale);\n+        drawGoTo(g2d, scale);\n+        g2d = bi.createGraphics();\n+        drawOpenHabRocks(g2d, width, height, scale);\n+        return bi;\n+", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0MzQxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399943416", "bodyText": "There is a lot of string concatenation going on, can you use a StringBuilder instead?", "author": "cpmeister", "createdAt": "2020-03-30T05:59:10Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/robot/RRMapFileParser.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.robot;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RRMapFileParser} is used to parse the RR map file format created by Xiaomi / RockRobo vacuum\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RRMapFileParser {\n+    public static final int CHARGER = 1;\n+    public static final int IMAGE = 2;\n+    public static final int PATH = 3;\n+    public static final int GOTO_PATH = 4;\n+    public static final int GOTO_PREDICTED_PATH = 5;\n+    public static final int CURRENTLY_CLEANED_ZONES = 6;\n+    public static final int GOTO_TARGET = 7;\n+    public static final int ROBOT_POSITION = 8;\n+    public static final int NO_GO_AREAS = 9;\n+    public static final int VIRTUAL_WALLS = 10;\n+    public static final int BLOCKS = 11;\n+    public static final int MFBZS_AREA = 12;\n+    public static final int OBSTACLES = 13;\n+    public static final int DIGEST = 1024;\n+    public static final int HEADER = 0x7272;\n+\n+    public static final String PATH_POINT_LENGTH = \"pointLength\";\n+    public static final String PATH_POINT_SIZE = \"pointSize\";\n+    public static final String PATH_ANGLE = \"angle\";\n+\n+    private static final float MM = 50.0f;\n+\n+    private byte[] image = new byte[] { 0 };\n+    private int majorVersion;\n+    private int minorVersion;\n+    private int mapIndex;\n+    private int mapSequence;\n+    private boolean isValid;\n+\n+    private int imgHeight;\n+    private int imgWidth;\n+    private int imageSize;\n+    private int top;\n+    private int left;\n+    private int offset;\n+\n+    private int chargerX;\n+    private int chargerY;\n+    private int roboX;\n+    private int roboY;\n+    private int roboA;\n+    private float gotoX = 0;\n+    private float gotoY = 0;\n+    private Map<Integer, ArrayList<Float[]>> paths = new HashMap<>();\n+    private Map<Integer, Map<String, Integer>> pathsDetails = new HashMap<>();\n+    private Map<Integer, ArrayList<Float[]>> areas = new HashMap<>();\n+    private ArrayList<Float[]> walls = new ArrayList<Float[]>();\n+    private ArrayList<Float[]> zones = new ArrayList<Float[]>();\n+    private ArrayList<int[]> obstacles = new ArrayList<int[]>();\n+    private byte[] blocks = new byte[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(RRMapFileParser.class);\n+\n+    public RRMapFileParser(byte[] raw) {\n+        boolean printBlockDetails = false;\n+\n+        int mapHeaderLength = getUInt16(raw, 0x02);\n+        int mapDataLength = getUInt32LE(raw, 0x04);\n+\n+        this.majorVersion = getUInt16(raw, 0x08);\n+        this.minorVersion = getUInt16(raw, 0x0A);\n+        this.mapIndex = getUInt32LE(raw, 0x0C);\n+        this.mapSequence = getUInt32LE(raw, 0x10);\n+\n+        int blockStartPos = getUInt16(raw, 0x02); // main header length\n+        while (blockStartPos < raw.length) {\n+            int blockHeaderLength = getUInt16(raw, blockStartPos + 0x02);\n+            byte[] header = getBytes(raw, blockStartPos, blockHeaderLength);\n+            int blocktype = getUInt16(header, 0x00);\n+            int blockDataLength = getUInt32LE(header, 0x04);\n+            int blockDataStart = blockStartPos + blockHeaderLength;\n+            byte[] data = getBytes(raw, blockDataStart, blockDataLength);\n+\n+            switch (blocktype) {\n+                case CHARGER:\n+                    this.chargerX = getUInt32LE(raw, blockStartPos + 0x08);\n+                    this.chargerY = getUInt32LE(raw, blockStartPos + 0x0C);\n+                    break;\n+                case IMAGE:\n+                    this.imageSize = blockDataLength;// (getUInt32LE(raw, blockStartPos + 0x04));\n+                    if (blockHeaderLength > 0x1C) {\n+                        logger.debug(\"block 2 unknown value @pos 8: {}\", getUInt32LE(header, 0x08));\n+                    }\n+                    this.top = getUInt32LE(header, blockHeaderLength - 16);\n+                    this.left = getUInt32LE(header, blockHeaderLength - 12);\n+                    this.imgHeight = (getUInt32LE(header, blockHeaderLength - 8));\n+                    this.imgWidth = getUInt32LE(header, blockHeaderLength - 4);\n+                    this.offset = imgWidth + left;\n+                    this.image = data;\n+                    break;\n+                case ROBOT_POSITION:\n+                    this.roboX = getUInt32LE(data, 0x00);\n+                    this.roboY = getUInt32LE(data, 0x04);\n+                    if (blockDataLength > 8) { // model S6\n+                        this.roboA = getUInt32LE(data, 0x08);\n+                    }\n+                    break;\n+                case PATH:\n+                case GOTO_PATH:\n+                case GOTO_PREDICTED_PATH:\n+                    ArrayList<Float[]> path = new ArrayList<Float[]>();\n+                    Map<String, Integer> detail = new HashMap<String, Integer>();\n+                    int pairs = getUInt32LE(header, 0x04) / 4;\n+                    detail.put(PATH_POINT_LENGTH, getUInt32LE(header, 0x08));\n+                    detail.put(PATH_POINT_SIZE, getUInt32LE(header, 0x0C));\n+                    detail.put(PATH_ANGLE, getUInt32LE(header, 0x10));\n+                    for (int pathpair = 0; pathpair < pairs; pathpair++) {\n+                        Float x = offset - (getUInt16(getBytes(raw, blockDataStart + pathpair * 4, 2))) / MM;\n+                        Float y = getUInt16(getBytes(raw, blockDataStart + pathpair * 4 + 2, 2)) / MM - top;\n+                        path.add(new Float[] { x, y });\n+                    }\n+                    paths.put(blocktype, path);\n+                    pathsDetails.put(blocktype, detail);\n+                    break;\n+                case CURRENTLY_CLEANED_ZONES:\n+                    int zonePairs = getUInt16(header, 0x08);\n+                    for (int zonePair = 0; zonePair < zonePairs; zonePair++) {\n+                        Float x0 = offset - (getUInt16(raw, blockDataStart + zonePair * 8)) / MM;\n+                        Float y0 = getUInt16(raw, blockDataStart + zonePair * 8 + 2) / MM - top;\n+                        Float x1 = offset - (getUInt16(raw, blockDataStart + zonePair * 8 + 4)) / MM;\n+                        Float y1 = getUInt16(raw, blockDataStart + zonePair * 8 + 6) / MM - top;\n+                        zones.add(new Float[] { x0, y0, x1, y1 });\n+                    }\n+                    break;\n+                case GOTO_TARGET:\n+                    this.gotoX = offset - getUInt16(data, 0x00) / MM;\n+                    this.gotoY = getUInt16(data, 0x02) / MM - top;\n+                    break;\n+                case DIGEST:\n+                    isValid = Arrays.equals(data, sha1Hash(getBytes(raw, 0, mapHeaderLength + mapDataLength - 20)));\n+                    break;\n+                case VIRTUAL_WALLS:\n+                    int wallPairs = getUInt16(header, 0x08);\n+                    for (int wallPair = 0; wallPair < wallPairs; wallPair++) {\n+                        Float x0 = offset - (getUInt16(raw, blockDataStart + wallPair * 8)) / MM;\n+                        Float y0 = getUInt16(raw, blockDataStart + wallPair * 8 + 2) / MM - top;\n+                        Float x1 = offset - (getUInt16(raw, blockDataStart + wallPair * 8 + 4)) / MM;\n+                        Float y1 = getUInt16(raw, blockDataStart + wallPair * 8 + 6) / MM - top;\n+                        walls.add(new Float[] { x0, y0, x1, y1 });\n+                    }\n+                    break;\n+                case NO_GO_AREAS:\n+                case MFBZS_AREA:\n+                    int areaPairs = getUInt16(header, 0x08);\n+                    ArrayList<Float[]> area = new ArrayList<Float[]>();\n+                    for (int areaPair = 0; areaPair < areaPairs; areaPair++) {\n+                        Float x0 = offset - (getUInt16(raw, blockDataStart + areaPair * 16)) / MM;\n+                        Float y0 = getUInt16(raw, blockDataStart + areaPair * 16 + 2) / MM - top;\n+                        Float x1 = offset - (getUInt16(raw, blockDataStart + areaPair * 16 + 4)) / MM;\n+                        Float y1 = getUInt16(raw, blockDataStart + areaPair * 16 + 6) / MM - top;\n+                        Float x2 = offset - (getUInt16(raw, blockDataStart + areaPair * 16 + 8)) / MM;\n+                        Float y2 = getUInt16(raw, blockDataStart + areaPair * 16 + 10) / MM - top;\n+                        Float x3 = offset - (getUInt16(raw, blockDataStart + areaPair * 16 + 12)) / MM;\n+                        Float y3 = getUInt16(raw, blockDataStart + areaPair * 16 + 14) / MM - top;\n+                        area.add(new Float[] { x0, y0, x1, y1, x2, y2, x3, y3 });\n+                    }\n+                    areas.put(Integer.valueOf(blocktype & 0xFF), area);\n+                    break;\n+                case OBSTACLES:\n+                    int obstaclePairs = getUInt16(header, 0x08);\n+                    for (int obstaclePair = 0; obstaclePair < obstaclePairs; obstaclePair++) {\n+                        int x0 = getUInt16(data, obstaclePair * 5 + 0);\n+                        int y0 = getUInt16(data, obstaclePair * 5 + 2);\n+                        int u = data[obstaclePair * 5 + 0] & 0xFF;\n+                        obstacles.add(new int[] { x0, y0, u });\n+                    }\n+                    break;\n+                case BLOCKS:\n+                    int blocksPairs = getUInt16(header, 0x08);\n+                    blocks = getBytes(data, 0, blocksPairs);\n+                    break;\n+                default:\n+                    logger.info(\"Unknown blocktype (pls report to author)\");\n+                    printBlockDetails = true;\n+            }\n+            if (logger.isTraceEnabled() || printBlockDetails) {\n+                logger.info(\"Blocktype: {}\", Integer.toString(blocktype));\n+                logger.info(\"Header len: {}   data len: {} \", Integer.toString(blockHeaderLength),\n+                        Integer.toString(blockDataLength));\n+                logger.info(\"H: {}\", Utils.getSpacedHex(header));\n+                if (blockDataLength > 0) {\n+                    logger.info(\"D: {}\", (blockDataLength < 60 ? Utils.getSpacedHex(data)\n+                            : Utils.getSpacedHex(getBytes(data, 0, 60))));\n+                }\n+                printBlockDetails = false;\n+            }\n+            blockStartPos = blockStartPos + blockDataLength + (header[2] & 0xFF);\n+        }\n+    }\n+\n+    public static byte[] readRRMapFile(File file) throws IOException {\n+        return readRRMapFile(new FileInputStream(file));\n+    }\n+\n+    public static byte[] readRRMapFile(InputStream is) throws IOException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (GZIPInputStream in = new GZIPInputStream(is)) {\n+            int bufsize = 1024;\n+            byte[] buf = new byte[bufsize];\n+            int readbytes = 0;\n+            readbytes = in.read(buf);\n+            while (readbytes != -1) {\n+                baos.write(buf, 0, readbytes);\n+                readbytes = in.read(buf);\n+            }\n+            baos.flush();\n+            return baos.toByteArray();\n+        }\n+    }\n+\n+    private byte[] getBytes(byte[] raw, int pos, int len) {\n+        return java.util.Arrays.copyOfRange(raw, pos, pos + len);\n+    }\n+\n+    private int getUInt32LE(byte[] bytes, int pos) {\n+        int value = bytes[0 + pos] & 0xFF;\n+        value |= (bytes[1 + pos] << 8) & 0xFFFF;\n+        value |= (bytes[2 + pos] << 16) & 0xFFFFFF;\n+        value |= (bytes[3 + pos] << 24) & 0xFFFFFFFF;\n+        return value;\n+    }\n+\n+    private int getUInt16(byte[] bytes) {\n+        return getUInt16(bytes, 0);\n+    }\n+\n+    private int getUInt16(byte[] bytes, int pos) {\n+        int value = bytes[0 + pos] & 0xFF;\n+        value |= (bytes[1 + pos] << 8) & 0xFFFF;\n+        return value;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String s = \"RR Map:\\tMajor Version: \" + majorVersion + \" Minor version: \" + minorVersion + \" Map Index: \"", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0MzU3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399943571", "bodyText": "checking trace enabled but logging as info?", "author": "cpmeister", "createdAt": "2020-03-30T05:59:42Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/robot/RRMapFileParser.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.robot;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RRMapFileParser} is used to parse the RR map file format created by Xiaomi / RockRobo vacuum\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RRMapFileParser {\n+    public static final int CHARGER = 1;\n+    public static final int IMAGE = 2;\n+    public static final int PATH = 3;\n+    public static final int GOTO_PATH = 4;\n+    public static final int GOTO_PREDICTED_PATH = 5;\n+    public static final int CURRENTLY_CLEANED_ZONES = 6;\n+    public static final int GOTO_TARGET = 7;\n+    public static final int ROBOT_POSITION = 8;\n+    public static final int NO_GO_AREAS = 9;\n+    public static final int VIRTUAL_WALLS = 10;\n+    public static final int BLOCKS = 11;\n+    public static final int MFBZS_AREA = 12;\n+    public static final int OBSTACLES = 13;\n+    public static final int DIGEST = 1024;\n+    public static final int HEADER = 0x7272;\n+\n+    public static final String PATH_POINT_LENGTH = \"pointLength\";\n+    public static final String PATH_POINT_SIZE = \"pointSize\";\n+    public static final String PATH_ANGLE = \"angle\";\n+\n+    private static final float MM = 50.0f;\n+\n+    private byte[] image = new byte[] { 0 };\n+    private int majorVersion;\n+    private int minorVersion;\n+    private int mapIndex;\n+    private int mapSequence;\n+    private boolean isValid;\n+\n+    private int imgHeight;\n+    private int imgWidth;\n+    private int imageSize;\n+    private int top;\n+    private int left;\n+    private int offset;\n+\n+    private int chargerX;\n+    private int chargerY;\n+    private int roboX;\n+    private int roboY;\n+    private int roboA;\n+    private float gotoX = 0;\n+    private float gotoY = 0;\n+    private Map<Integer, ArrayList<Float[]>> paths = new HashMap<>();\n+    private Map<Integer, Map<String, Integer>> pathsDetails = new HashMap<>();\n+    private Map<Integer, ArrayList<Float[]>> areas = new HashMap<>();\n+    private ArrayList<Float[]> walls = new ArrayList<Float[]>();\n+    private ArrayList<Float[]> zones = new ArrayList<Float[]>();\n+    private ArrayList<int[]> obstacles = new ArrayList<int[]>();\n+    private byte[] blocks = new byte[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(RRMapFileParser.class);\n+\n+    public RRMapFileParser(byte[] raw) {\n+        boolean printBlockDetails = false;\n+\n+        int mapHeaderLength = getUInt16(raw, 0x02);\n+        int mapDataLength = getUInt32LE(raw, 0x04);\n+\n+        this.majorVersion = getUInt16(raw, 0x08);\n+        this.minorVersion = getUInt16(raw, 0x0A);\n+        this.mapIndex = getUInt32LE(raw, 0x0C);\n+        this.mapSequence = getUInt32LE(raw, 0x10);\n+\n+        int blockStartPos = getUInt16(raw, 0x02); // main header length\n+        while (blockStartPos < raw.length) {\n+            int blockHeaderLength = getUInt16(raw, blockStartPos + 0x02);\n+            byte[] header = getBytes(raw, blockStartPos, blockHeaderLength);\n+            int blocktype = getUInt16(header, 0x00);\n+            int blockDataLength = getUInt32LE(header, 0x04);\n+            int blockDataStart = blockStartPos + blockHeaderLength;\n+            byte[] data = getBytes(raw, blockDataStart, blockDataLength);\n+\n+            switch (blocktype) {\n+                case CHARGER:\n+                    this.chargerX = getUInt32LE(raw, blockStartPos + 0x08);\n+                    this.chargerY = getUInt32LE(raw, blockStartPos + 0x0C);\n+                    break;\n+                case IMAGE:\n+                    this.imageSize = blockDataLength;// (getUInt32LE(raw, blockStartPos + 0x04));\n+                    if (blockHeaderLength > 0x1C) {\n+                        logger.debug(\"block 2 unknown value @pos 8: {}\", getUInt32LE(header, 0x08));\n+                    }\n+                    this.top = getUInt32LE(header, blockHeaderLength - 16);\n+                    this.left = getUInt32LE(header, blockHeaderLength - 12);\n+                    this.imgHeight = (getUInt32LE(header, blockHeaderLength - 8));\n+                    this.imgWidth = getUInt32LE(header, blockHeaderLength - 4);\n+                    this.offset = imgWidth + left;\n+                    this.image = data;\n+                    break;\n+                case ROBOT_POSITION:\n+                    this.roboX = getUInt32LE(data, 0x00);\n+                    this.roboY = getUInt32LE(data, 0x04);\n+                    if (blockDataLength > 8) { // model S6\n+                        this.roboA = getUInt32LE(data, 0x08);\n+                    }\n+                    break;\n+                case PATH:\n+                case GOTO_PATH:\n+                case GOTO_PREDICTED_PATH:\n+                    ArrayList<Float[]> path = new ArrayList<Float[]>();\n+                    Map<String, Integer> detail = new HashMap<String, Integer>();\n+                    int pairs = getUInt32LE(header, 0x04) / 4;\n+                    detail.put(PATH_POINT_LENGTH, getUInt32LE(header, 0x08));\n+                    detail.put(PATH_POINT_SIZE, getUInt32LE(header, 0x0C));\n+                    detail.put(PATH_ANGLE, getUInt32LE(header, 0x10));\n+                    for (int pathpair = 0; pathpair < pairs; pathpair++) {\n+                        Float x = offset - (getUInt16(getBytes(raw, blockDataStart + pathpair * 4, 2))) / MM;\n+                        Float y = getUInt16(getBytes(raw, blockDataStart + pathpair * 4 + 2, 2)) / MM - top;\n+                        path.add(new Float[] { x, y });\n+                    }\n+                    paths.put(blocktype, path);\n+                    pathsDetails.put(blocktype, detail);\n+                    break;\n+                case CURRENTLY_CLEANED_ZONES:\n+                    int zonePairs = getUInt16(header, 0x08);\n+                    for (int zonePair = 0; zonePair < zonePairs; zonePair++) {\n+                        Float x0 = offset - (getUInt16(raw, blockDataStart + zonePair * 8)) / MM;\n+                        Float y0 = getUInt16(raw, blockDataStart + zonePair * 8 + 2) / MM - top;\n+                        Float x1 = offset - (getUInt16(raw, blockDataStart + zonePair * 8 + 4)) / MM;\n+                        Float y1 = getUInt16(raw, blockDataStart + zonePair * 8 + 6) / MM - top;\n+                        zones.add(new Float[] { x0, y0, x1, y1 });\n+                    }\n+                    break;\n+                case GOTO_TARGET:\n+                    this.gotoX = offset - getUInt16(data, 0x00) / MM;\n+                    this.gotoY = getUInt16(data, 0x02) / MM - top;\n+                    break;\n+                case DIGEST:\n+                    isValid = Arrays.equals(data, sha1Hash(getBytes(raw, 0, mapHeaderLength + mapDataLength - 20)));\n+                    break;\n+                case VIRTUAL_WALLS:\n+                    int wallPairs = getUInt16(header, 0x08);\n+                    for (int wallPair = 0; wallPair < wallPairs; wallPair++) {\n+                        Float x0 = offset - (getUInt16(raw, blockDataStart + wallPair * 8)) / MM;\n+                        Float y0 = getUInt16(raw, blockDataStart + wallPair * 8 + 2) / MM - top;\n+                        Float x1 = offset - (getUInt16(raw, blockDataStart + wallPair * 8 + 4)) / MM;\n+                        Float y1 = getUInt16(raw, blockDataStart + wallPair * 8 + 6) / MM - top;\n+                        walls.add(new Float[] { x0, y0, x1, y1 });\n+                    }\n+                    break;\n+                case NO_GO_AREAS:\n+                case MFBZS_AREA:\n+                    int areaPairs = getUInt16(header, 0x08);\n+                    ArrayList<Float[]> area = new ArrayList<Float[]>();\n+                    for (int areaPair = 0; areaPair < areaPairs; areaPair++) {\n+                        Float x0 = offset - (getUInt16(raw, blockDataStart + areaPair * 16)) / MM;\n+                        Float y0 = getUInt16(raw, blockDataStart + areaPair * 16 + 2) / MM - top;\n+                        Float x1 = offset - (getUInt16(raw, blockDataStart + areaPair * 16 + 4)) / MM;\n+                        Float y1 = getUInt16(raw, blockDataStart + areaPair * 16 + 6) / MM - top;\n+                        Float x2 = offset - (getUInt16(raw, blockDataStart + areaPair * 16 + 8)) / MM;\n+                        Float y2 = getUInt16(raw, blockDataStart + areaPair * 16 + 10) / MM - top;\n+                        Float x3 = offset - (getUInt16(raw, blockDataStart + areaPair * 16 + 12)) / MM;\n+                        Float y3 = getUInt16(raw, blockDataStart + areaPair * 16 + 14) / MM - top;\n+                        area.add(new Float[] { x0, y0, x1, y1, x2, y2, x3, y3 });\n+                    }\n+                    areas.put(Integer.valueOf(blocktype & 0xFF), area);\n+                    break;\n+                case OBSTACLES:\n+                    int obstaclePairs = getUInt16(header, 0x08);\n+                    for (int obstaclePair = 0; obstaclePair < obstaclePairs; obstaclePair++) {\n+                        int x0 = getUInt16(data, obstaclePair * 5 + 0);\n+                        int y0 = getUInt16(data, obstaclePair * 5 + 2);\n+                        int u = data[obstaclePair * 5 + 0] & 0xFF;\n+                        obstacles.add(new int[] { x0, y0, u });\n+                    }\n+                    break;\n+                case BLOCKS:\n+                    int blocksPairs = getUInt16(header, 0x08);\n+                    blocks = getBytes(data, 0, blocksPairs);\n+                    break;\n+                default:\n+                    logger.info(\"Unknown blocktype (pls report to author)\");\n+                    printBlockDetails = true;\n+            }\n+            if (logger.isTraceEnabled() || printBlockDetails) {\n+                logger.info(\"Blocktype: {}\", Integer.toString(blocktype));\n+                logger.info(\"Header len: {}   data len: {} \", Integer.toString(blockHeaderLength),\n+                        Integer.toString(blockDataLength));\n+                logger.info(\"H: {}\", Utils.getSpacedHex(header));\n+                if (blockDataLength > 0) {\n+                    logger.info(\"D: {}\", (blockDataLength < 60 ? Utils.getSpacedHex(data)\n+                            : Utils.getSpacedHex(getBytes(data, 0, 60))));\n+                }\n+                printBlockDetails = false;\n+            }", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIwMTA1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r401201055", "bodyText": "it is because of the || printBlockDetails \nIf trace is enabled, I want to see the full lock. If no trace, I only want to see the unknown blocktypes. (which currently should be none, but the format is sometimes extended.\nI'll change it to debug, to avoid excessive logging to INFO", "author": "marcelrv", "createdAt": "2020-03-31T20:40:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0MzU3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NDAwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399944008", "bodyText": "Why Float[] instead of float[]?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private ArrayList<Float[]> walls = new ArrayList<Float[]>();\n          \n          \n            \n                private ArrayList<Float[]> zones = new ArrayList<Float[]>();\n          \n          \n            \n                private ArrayList<Float[]> walls = new ArrayList<>();\n          \n          \n            \n                private ArrayList<Float[]> zones = new ArrayList<>();", "author": "cpmeister", "createdAt": "2020-03-30T06:01:05Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/robot/RRMapFileParser.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.robot;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RRMapFileParser} is used to parse the RR map file format created by Xiaomi / RockRobo vacuum\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RRMapFileParser {\n+    public static final int CHARGER = 1;\n+    public static final int IMAGE = 2;\n+    public static final int PATH = 3;\n+    public static final int GOTO_PATH = 4;\n+    public static final int GOTO_PREDICTED_PATH = 5;\n+    public static final int CURRENTLY_CLEANED_ZONES = 6;\n+    public static final int GOTO_TARGET = 7;\n+    public static final int ROBOT_POSITION = 8;\n+    public static final int NO_GO_AREAS = 9;\n+    public static final int VIRTUAL_WALLS = 10;\n+    public static final int BLOCKS = 11;\n+    public static final int MFBZS_AREA = 12;\n+    public static final int OBSTACLES = 13;\n+    public static final int DIGEST = 1024;\n+    public static final int HEADER = 0x7272;\n+\n+    public static final String PATH_POINT_LENGTH = \"pointLength\";\n+    public static final String PATH_POINT_SIZE = \"pointSize\";\n+    public static final String PATH_ANGLE = \"angle\";\n+\n+    private static final float MM = 50.0f;\n+\n+    private byte[] image = new byte[] { 0 };\n+    private int majorVersion;\n+    private int minorVersion;\n+    private int mapIndex;\n+    private int mapSequence;\n+    private boolean isValid;\n+\n+    private int imgHeight;\n+    private int imgWidth;\n+    private int imageSize;\n+    private int top;\n+    private int left;\n+    private int offset;\n+\n+    private int chargerX;\n+    private int chargerY;\n+    private int roboX;\n+    private int roboY;\n+    private int roboA;\n+    private float gotoX = 0;\n+    private float gotoY = 0;\n+    private Map<Integer, ArrayList<Float[]>> paths = new HashMap<>();\n+    private Map<Integer, Map<String, Integer>> pathsDetails = new HashMap<>();\n+    private Map<Integer, ArrayList<Float[]>> areas = new HashMap<>();\n+    private ArrayList<Float[]> walls = new ArrayList<Float[]>();\n+    private ArrayList<Float[]> zones = new ArrayList<Float[]>();", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NDEwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399944100", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private ArrayList<int[]> obstacles = new ArrayList<int[]>();\n          \n          \n            \n                private ArrayList<int[]> obstacles = new ArrayList<>();", "author": "cpmeister", "createdAt": "2020-03-30T06:01:28Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/robot/RRMapFileParser.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.robot;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RRMapFileParser} is used to parse the RR map file format created by Xiaomi / RockRobo vacuum\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RRMapFileParser {\n+    public static final int CHARGER = 1;\n+    public static final int IMAGE = 2;\n+    public static final int PATH = 3;\n+    public static final int GOTO_PATH = 4;\n+    public static final int GOTO_PREDICTED_PATH = 5;\n+    public static final int CURRENTLY_CLEANED_ZONES = 6;\n+    public static final int GOTO_TARGET = 7;\n+    public static final int ROBOT_POSITION = 8;\n+    public static final int NO_GO_AREAS = 9;\n+    public static final int VIRTUAL_WALLS = 10;\n+    public static final int BLOCKS = 11;\n+    public static final int MFBZS_AREA = 12;\n+    public static final int OBSTACLES = 13;\n+    public static final int DIGEST = 1024;\n+    public static final int HEADER = 0x7272;\n+\n+    public static final String PATH_POINT_LENGTH = \"pointLength\";\n+    public static final String PATH_POINT_SIZE = \"pointSize\";\n+    public static final String PATH_ANGLE = \"angle\";\n+\n+    private static final float MM = 50.0f;\n+\n+    private byte[] image = new byte[] { 0 };\n+    private int majorVersion;\n+    private int minorVersion;\n+    private int mapIndex;\n+    private int mapSequence;\n+    private boolean isValid;\n+\n+    private int imgHeight;\n+    private int imgWidth;\n+    private int imageSize;\n+    private int top;\n+    private int left;\n+    private int offset;\n+\n+    private int chargerX;\n+    private int chargerY;\n+    private int roboX;\n+    private int roboY;\n+    private int roboA;\n+    private float gotoX = 0;\n+    private float gotoY = 0;\n+    private Map<Integer, ArrayList<Float[]>> paths = new HashMap<>();\n+    private Map<Integer, Map<String, Integer>> pathsDetails = new HashMap<>();\n+    private Map<Integer, ArrayList<Float[]>> areas = new HashMap<>();\n+    private ArrayList<Float[]> walls = new ArrayList<Float[]>();\n+    private ArrayList<Float[]> zones = new ArrayList<Float[]>();\n+    private ArrayList<int[]> obstacles = new ArrayList<int[]>();", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NDI5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399944296", "bodyText": "blank line", "author": "cpmeister", "createdAt": "2020-03-30T06:02:09Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/MiCloudConnector.java", "diffHunk": "@@ -0,0 +1,468 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.io.IOException;\n+import java.net.CookieStore;\n+import java.net.HttpCookie;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpResponseException;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.FormContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.util.Fields;\n+import org.openhab.binding.miio.internal.MiIoCrypto;\n+import org.openhab.binding.miio.internal.MiIoCryptoException;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MiCloudConnector} class is used for connecting to the Xiaomi cloud access\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MiCloudConnector {\n+\n+    private static final int REQUEST_TIMEOUT_SECONDS = 10;\n+    private static final String UNEXPECTED = \"Unexpected :\";\n+    private static final String AGENT_ID = (new Random().ints(65, 70).limit(13)\n+            .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    private static final String USERAGENT = \"Android-7.1.1-1.0.0-ONEPLUS A3010-136-\" + AGENT_ID\n+            + \" APP/xiaomi.smarthome APPV/62830\";\n+    private final JsonParser parser = new JsonParser();\n+\n+    // String\n+    private String username;\n+    private String password;\n+\n+    private final String clientId;\n+    private String userId = \"\";\n+    private String serviceToken = \"\";\n+    private String ssecurity = \"\";\n+    int loginFailedCounter = 0;\n+\n+    private HttpClient httpClient;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MiCloudConnector.class);\n+\n+    public MiCloudConnector(String username, String password, HttpClient httpClient) throws MiCloudException {\n+        this.username = username;\n+        this.password = password;\n+        this.httpClient = httpClient;\n+        if (!checkCredentials()) {\n+            throw new MiCloudException(\"username or password can't be empty\");\n+        }\n+        clientId = (new Random().ints(97, 122 + 1).limit(6)\n+                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    }\n+\n+    void startClient() throws MiCloudException {\n+        if (!httpClient.isStarted()) {\n+            try {\n+                httpClient.start();\n+                // set default cookies\n+                CookieStore cookieStore = httpClient.getCookieStore();\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"mi.com\");\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"xiaomi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"mi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"xiaomi.com\");\n+            } catch (Exception e) {\n+                throw new MiCloudException(\"No http client cannot be started: \" + e.getMessage());\n+            }\n+        }\n+    }\n+\n+    public void stopClient() {\n+        try {\n+            this.httpClient.stop();\n+        } catch (Exception e) {\n+            logger.debug(\"Error stopping httpclient :{}\", e.getMessage());\n+        }\n+    }\n+\n+    private boolean checkCredentials() {\n+        if (username.trim().isEmpty() || password.trim().isEmpty()) {\n+            logger.info(\"Xiaomi Cloud: username or password missing.\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private String getApiUrl(String country) {\n+        return \"https://\" + (country.trim().equalsIgnoreCase(\"cn\") ? \"\" : country.trim().toLowerCase() + \".\")\n+                + \"api.io.mi.com/app\";\n+    }\n+\n+    public String getClientId() {\n+        return clientId;\n+    }\n+\n+    String parseJson(String data) {\n+        if (data.contains(\"&&&START&&&\")) {\n+            return data.replace(\"&&&START&&&\", \"\");\n+        } else {\n+            return UNEXPECTED.concat(data);\n+        }\n+    }\n+\n+    public String getMapUrl(String vacuumMap, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/getmapfileurl\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"obj_name\\\":\\\"\" + vacuumMap + \"\\\"}\");\n+        String mapResponse = request(url, map);\n+        logger.trace(\"response: {}\", mapResponse);\n+        String errorMsg = \"\";\n+        JsonElement response = parser.parse(mapResponse);\n+        if (response.isJsonObject()) {\n+            logger.debug(\"Received  JSON message {}\", response.toString());\n+            if (response.getAsJsonObject().has(\"result\") && response.getAsJsonObject().get(\"result\").isJsonObject()) {\n+                JsonObject jo = response.getAsJsonObject().get(\"result\").getAsJsonObject();\n+                if (jo.has(\"url\")) {\n+                    return jo.get(\"url\").getAsString();\n+                } else {\n+                    errorMsg = \"Could not get url\";\n+                }\n+            } else {\n+                errorMsg = \"Could not get result\";\n+            }\n+        } else {\n+            errorMsg = \"Received message is invalid JSON\";\n+        }\n+        logger.debug(\"{}: {}\", errorMsg, mapResponse);\n+        return \"\";\n+    }\n+\n+    public String getDeviceStatus(String device, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"dids\\\":[\\\"\" + device + \"\\\"]}\");\n+        logger.debug(\"response: {}\", request(url, map));\n+        return \"\";\n+    }\n+\n+    public String getLatest(String model, String country) {\n+        String url = getApiUrl(country) + \"/home/latest_version\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"model\\\":\\\"\" + model + \"\\\"}\");\n+        String resp;\n+        try {\n+            resp = request(url, map);\n+            logger.debug(\"Response: {}\", resp);\n+            // CloudUtil.printDevices(resp, logger);\n+            if (resp.length() > 2) {\n+                // CloudUtil.saveFile(resp, country, logger);\n+                return resp;\n+            }\n+        } catch (MiCloudException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+            return \"\";\n+        }\n+        return \"\";\n+    }\n+\n+    public String getDevices(String country) {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"getVirtualModel\\\":false,\\\"getHuamiDevices\\\":0}\");\n+        String resp;\n+        try {\n+            resp = request(url, map);\n+            logger.trace(\"Get devices response: {}\", resp);\n+            CloudUtil.printDevices(resp, country, logger);\n+            if (resp.length() > 2) {\n+                CloudUtil.saveFile(resp, country, logger);\n+                return resp;\n+            }\n+        } catch (MiCloudException e) {\n+            logger.info(\"{}\", e.getMessage());\n+        }\n+        return \"\";\n+    }\n+\n+    public String request(String urlPart, String country, Map<String, String> params) throws MiCloudException {\n+        String url = getApiUrl(country) + urlPart;\n+        String response = request(url, params);\n+        logger.debug(\"Request to {} server {}. Response: {}\", country, urlPart, response);\n+        return response;\n+    }\n+\n+    public String request(String url, Map<String, String> params) throws MiCloudException {\n+        if (this.serviceToken.isEmpty() || this.userId.isEmpty()) {\n+            throw new MiCloudException(\"Cannot execute request. service token or userId missing\");\n+        }\n+        try {\n+            startClient();\n+        } catch (Exception e) {\n+            throw new MiCloudException(\"Cannot Execute request. service token or userId missing\" + e.getMessage());\n+        }\n+        logger.debug(\"Send request: {} to {}\", params.get(\"data\"), url);\n+        Request request = httpClient.newRequest(url).timeout(REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        request.agent(USERAGENT);\n+        request.header(\"x-xiaomi-protocal-flag-cli\", \"PROTOCAL-HTTP2\");\n+        request.header(HttpHeader.CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n+        request.cookie(new HttpCookie(\"userId\", this.userId));\n+        request.cookie(new HttpCookie(\"yetAnotherServiceToken\", this.serviceToken));\n+        request.cookie(new HttpCookie(\"serviceToken\", this.serviceToken));\n+        request.cookie(new HttpCookie(\"locale\", \"uk_GB\"));\n+        request.cookie(new HttpCookie(\"timezone\", \"GMT%2B01%3A00\"));\n+        request.cookie(new HttpCookie(\"is_daylight\", \"1\"));\n+        request.cookie(new HttpCookie(\"dst_offset\", \"3600000\"));\n+        request.cookie(new HttpCookie(\"channel\", \"MI_APP_STORE\"));\n+\n+        for (HttpCookie cookie : request.getCookies()) {\n+            logger.trace(\"Cookie set for request ({}) : {} --> {}     (path: {})\", cookie.getDomain(), cookie.getName(),\n+                    cookie.getValue(), cookie.getPath());\n+        }\n+        String method = \"POST\";\n+        request.method(method);\n+\n+        try {\n+            String nonce = CloudUtil.generateNonce(System.currentTimeMillis());\n+            String signedNonce = CloudUtil.signedNonce(ssecurity, nonce);\n+            String signature = CloudUtil.generateSignature(url.replace(\"/app\", \"\"), signedNonce, nonce, params);\n+\n+            Fields fields = new Fields();\n+            fields.put(\"signature\", signature);\n+            fields.put(\"_nonce\", nonce);\n+            fields.put(\"data\", params.get(\"data\"));\n+            request.content(new FormContentProvider(fields));\n+\n+            logger.trace(\"fieldcontent: {}\", fields.toString());\n+            final ContentResponse response = request.send();\n+            return response.getContentAsString();\n+        } catch (HttpResponseException e) {\n+            serviceToken = \"\";\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (ExecutionException e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (IOException e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (MiIoCryptoException e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage(), e);\n+        } catch (Exception e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage(), e);\n+        }\n+        return \"\";\n+    }\n+\n+    private void addCookie(CookieStore cookieStore, String name, String value, String domain) {\n+        HttpCookie cookie = new HttpCookie(name, value);\n+        cookie.setDomain(\".\" + domain);\n+        cookie.setPath(\"/\");\n+        cookieStore.add(URI.create(\"https://\" + domain), cookie);\n+    }\n+\n+    // TODO: better way instead of blocking ?\n+    public synchronized boolean login() {\n+        if (!checkCredentials()) {\n+            return false;\n+        }\n+        if (!userId.isEmpty() && !serviceToken.isEmpty()) {\n+            return true;\n+        }\n+        logger.debug(\"Xiaomi cloud login with userid {}\", username);\n+        try {\n+            if (loginRequest()) {\n+                loginFailedCounter = 0;\n+            } else {\n+                loginFailedCounter++;\n+                logger.debug(\"Xiaomi cloud login attempt {}\", loginFailedCounter);\n+            }\n+        } catch (MiCloudException e) {\n+            logger.info(\"Error logging on to Xiaomi cloud ({}): {}\", loginFailedCounter, e.getMessage());\n+            loginFailedCounter++;\n+            serviceToken = \"\";\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    protected boolean loginRequest() throws MiCloudException {\n+        try {\n+            startClient();\n+            String sign = loginStep1();\n+            String location = loginStep2(sign);\n+            final ContentResponse responseStep3 = loginStep3(location);\n+\n+            switch (responseStep3.getStatus()) {\n+                case HttpStatus.FORBIDDEN_403:\n+                    throw new MiCloudException(\"Access denied. Did you set the correct api-key and/or username?\");\n+                case HttpStatus.OK_200:\n+                    return true;\n+                default:\n+                    logger.trace(\"request returned status '{}', reason: {}, content = {}\", responseStep3.getStatus(),\n+                            responseStep3.getReason(), responseStep3.getContentAsString());\n+                    throw new MiCloudException(responseStep3.getStatus() + responseStep3.getReason());\n+            }\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new MiCloudException(\"Cannot logon to Xiaomi cloud: \" + e.getMessage());\n+        } catch (MiIoCryptoException e) {\n+            throw new MiCloudException(\"Error decrypting. Cannot logon to Xiaomi cloud: \" + e.getMessage());\n+        } catch (MalformedURLException e) {\n+            throw new MiCloudException(\"Error getting logon URL. Cannot logon to Xiaomi cloud: \" + e.getMessage());\n+        }\n+", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NDQ3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399944470", "bodyText": "include cause exception", "author": "cpmeister", "createdAt": "2020-03-30T06:02:40Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/MiCloudConnector.java", "diffHunk": "@@ -0,0 +1,468 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.io.IOException;\n+import java.net.CookieStore;\n+import java.net.HttpCookie;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpResponseException;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.FormContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.util.Fields;\n+import org.openhab.binding.miio.internal.MiIoCrypto;\n+import org.openhab.binding.miio.internal.MiIoCryptoException;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MiCloudConnector} class is used for connecting to the Xiaomi cloud access\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MiCloudConnector {\n+\n+    private static final int REQUEST_TIMEOUT_SECONDS = 10;\n+    private static final String UNEXPECTED = \"Unexpected :\";\n+    private static final String AGENT_ID = (new Random().ints(65, 70).limit(13)\n+            .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    private static final String USERAGENT = \"Android-7.1.1-1.0.0-ONEPLUS A3010-136-\" + AGENT_ID\n+            + \" APP/xiaomi.smarthome APPV/62830\";\n+    private final JsonParser parser = new JsonParser();\n+\n+    // String\n+    private String username;\n+    private String password;\n+\n+    private final String clientId;\n+    private String userId = \"\";\n+    private String serviceToken = \"\";\n+    private String ssecurity = \"\";\n+    int loginFailedCounter = 0;\n+\n+    private HttpClient httpClient;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MiCloudConnector.class);\n+\n+    public MiCloudConnector(String username, String password, HttpClient httpClient) throws MiCloudException {\n+        this.username = username;\n+        this.password = password;\n+        this.httpClient = httpClient;\n+        if (!checkCredentials()) {\n+            throw new MiCloudException(\"username or password can't be empty\");\n+        }\n+        clientId = (new Random().ints(97, 122 + 1).limit(6)\n+                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    }\n+\n+    void startClient() throws MiCloudException {\n+        if (!httpClient.isStarted()) {\n+            try {\n+                httpClient.start();\n+                // set default cookies\n+                CookieStore cookieStore = httpClient.getCookieStore();\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"mi.com\");\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"xiaomi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"mi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"xiaomi.com\");\n+            } catch (Exception e) {\n+                throw new MiCloudException(\"No http client cannot be started: \" + e.getMessage());\n+            }\n+        }\n+    }\n+\n+    public void stopClient() {\n+        try {\n+            this.httpClient.stop();\n+        } catch (Exception e) {\n+            logger.debug(\"Error stopping httpclient :{}\", e.getMessage());\n+        }\n+    }\n+\n+    private boolean checkCredentials() {\n+        if (username.trim().isEmpty() || password.trim().isEmpty()) {\n+            logger.info(\"Xiaomi Cloud: username or password missing.\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private String getApiUrl(String country) {\n+        return \"https://\" + (country.trim().equalsIgnoreCase(\"cn\") ? \"\" : country.trim().toLowerCase() + \".\")\n+                + \"api.io.mi.com/app\";\n+    }\n+\n+    public String getClientId() {\n+        return clientId;\n+    }\n+\n+    String parseJson(String data) {\n+        if (data.contains(\"&&&START&&&\")) {\n+            return data.replace(\"&&&START&&&\", \"\");\n+        } else {\n+            return UNEXPECTED.concat(data);\n+        }\n+    }\n+\n+    public String getMapUrl(String vacuumMap, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/getmapfileurl\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"obj_name\\\":\\\"\" + vacuumMap + \"\\\"}\");\n+        String mapResponse = request(url, map);\n+        logger.trace(\"response: {}\", mapResponse);\n+        String errorMsg = \"\";\n+        JsonElement response = parser.parse(mapResponse);\n+        if (response.isJsonObject()) {\n+            logger.debug(\"Received  JSON message {}\", response.toString());\n+            if (response.getAsJsonObject().has(\"result\") && response.getAsJsonObject().get(\"result\").isJsonObject()) {\n+                JsonObject jo = response.getAsJsonObject().get(\"result\").getAsJsonObject();\n+                if (jo.has(\"url\")) {\n+                    return jo.get(\"url\").getAsString();\n+                } else {\n+                    errorMsg = \"Could not get url\";\n+                }\n+            } else {\n+                errorMsg = \"Could not get result\";\n+            }\n+        } else {\n+            errorMsg = \"Received message is invalid JSON\";\n+        }\n+        logger.debug(\"{}: {}\", errorMsg, mapResponse);\n+        return \"\";\n+    }\n+\n+    public String getDeviceStatus(String device, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"dids\\\":[\\\"\" + device + \"\\\"]}\");\n+        logger.debug(\"response: {}\", request(url, map));\n+        return \"\";\n+    }\n+\n+    public String getLatest(String model, String country) {\n+        String url = getApiUrl(country) + \"/home/latest_version\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"model\\\":\\\"\" + model + \"\\\"}\");\n+        String resp;\n+        try {\n+            resp = request(url, map);\n+            logger.debug(\"Response: {}\", resp);\n+            // CloudUtil.printDevices(resp, logger);\n+            if (resp.length() > 2) {\n+                // CloudUtil.saveFile(resp, country, logger);\n+                return resp;\n+            }\n+        } catch (MiCloudException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+            return \"\";\n+        }\n+        return \"\";\n+    }\n+\n+    public String getDevices(String country) {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"getVirtualModel\\\":false,\\\"getHuamiDevices\\\":0}\");\n+        String resp;\n+        try {\n+            resp = request(url, map);\n+            logger.trace(\"Get devices response: {}\", resp);\n+            CloudUtil.printDevices(resp, country, logger);\n+            if (resp.length() > 2) {\n+                CloudUtil.saveFile(resp, country, logger);\n+                return resp;\n+            }\n+        } catch (MiCloudException e) {\n+            logger.info(\"{}\", e.getMessage());\n+        }\n+        return \"\";\n+    }\n+\n+    public String request(String urlPart, String country, Map<String, String> params) throws MiCloudException {\n+        String url = getApiUrl(country) + urlPart;\n+        String response = request(url, params);\n+        logger.debug(\"Request to {} server {}. Response: {}\", country, urlPart, response);\n+        return response;\n+    }\n+\n+    public String request(String url, Map<String, String> params) throws MiCloudException {\n+        if (this.serviceToken.isEmpty() || this.userId.isEmpty()) {\n+            throw new MiCloudException(\"Cannot execute request. service token or userId missing\");\n+        }\n+        try {\n+            startClient();\n+        } catch (Exception e) {\n+            throw new MiCloudException(\"Cannot Execute request. service token or userId missing\" + e.getMessage());\n+        }\n+        logger.debug(\"Send request: {} to {}\", params.get(\"data\"), url);\n+        Request request = httpClient.newRequest(url).timeout(REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        request.agent(USERAGENT);\n+        request.header(\"x-xiaomi-protocal-flag-cli\", \"PROTOCAL-HTTP2\");\n+        request.header(HttpHeader.CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n+        request.cookie(new HttpCookie(\"userId\", this.userId));\n+        request.cookie(new HttpCookie(\"yetAnotherServiceToken\", this.serviceToken));\n+        request.cookie(new HttpCookie(\"serviceToken\", this.serviceToken));\n+        request.cookie(new HttpCookie(\"locale\", \"uk_GB\"));\n+        request.cookie(new HttpCookie(\"timezone\", \"GMT%2B01%3A00\"));\n+        request.cookie(new HttpCookie(\"is_daylight\", \"1\"));\n+        request.cookie(new HttpCookie(\"dst_offset\", \"3600000\"));\n+        request.cookie(new HttpCookie(\"channel\", \"MI_APP_STORE\"));\n+\n+        for (HttpCookie cookie : request.getCookies()) {\n+            logger.trace(\"Cookie set for request ({}) : {} --> {}     (path: {})\", cookie.getDomain(), cookie.getName(),\n+                    cookie.getValue(), cookie.getPath());\n+        }\n+        String method = \"POST\";\n+        request.method(method);\n+\n+        try {\n+            String nonce = CloudUtil.generateNonce(System.currentTimeMillis());\n+            String signedNonce = CloudUtil.signedNonce(ssecurity, nonce);\n+            String signature = CloudUtil.generateSignature(url.replace(\"/app\", \"\"), signedNonce, nonce, params);\n+\n+            Fields fields = new Fields();\n+            fields.put(\"signature\", signature);\n+            fields.put(\"_nonce\", nonce);\n+            fields.put(\"data\", params.get(\"data\"));\n+            request.content(new FormContentProvider(fields));\n+\n+            logger.trace(\"fieldcontent: {}\", fields.toString());\n+            final ContentResponse response = request.send();\n+            return response.getContentAsString();\n+        } catch (HttpResponseException e) {\n+            serviceToken = \"\";\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (ExecutionException e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (IOException e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (MiIoCryptoException e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage(), e);\n+        } catch (Exception e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage(), e);\n+        }\n+        return \"\";\n+    }\n+\n+    private void addCookie(CookieStore cookieStore, String name, String value, String domain) {\n+        HttpCookie cookie = new HttpCookie(name, value);\n+        cookie.setDomain(\".\" + domain);\n+        cookie.setPath(\"/\");\n+        cookieStore.add(URI.create(\"https://\" + domain), cookie);\n+    }\n+\n+    // TODO: better way instead of blocking ?\n+    public synchronized boolean login() {\n+        if (!checkCredentials()) {\n+            return false;\n+        }\n+        if (!userId.isEmpty() && !serviceToken.isEmpty()) {\n+            return true;\n+        }\n+        logger.debug(\"Xiaomi cloud login with userid {}\", username);\n+        try {\n+            if (loginRequest()) {\n+                loginFailedCounter = 0;\n+            } else {\n+                loginFailedCounter++;\n+                logger.debug(\"Xiaomi cloud login attempt {}\", loginFailedCounter);\n+            }\n+        } catch (MiCloudException e) {\n+            logger.info(\"Error logging on to Xiaomi cloud ({}): {}\", loginFailedCounter, e.getMessage());\n+            loginFailedCounter++;\n+            serviceToken = \"\";\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    protected boolean loginRequest() throws MiCloudException {\n+        try {\n+            startClient();\n+            String sign = loginStep1();\n+            String location = loginStep2(sign);\n+            final ContentResponse responseStep3 = loginStep3(location);\n+\n+            switch (responseStep3.getStatus()) {\n+                case HttpStatus.FORBIDDEN_403:\n+                    throw new MiCloudException(\"Access denied. Did you set the correct api-key and/or username?\");\n+                case HttpStatus.OK_200:\n+                    return true;\n+                default:\n+                    logger.trace(\"request returned status '{}', reason: {}, content = {}\", responseStep3.getStatus(),\n+                            responseStep3.getReason(), responseStep3.getContentAsString());\n+                    throw new MiCloudException(responseStep3.getStatus() + responseStep3.getReason());\n+            }\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new MiCloudException(\"Cannot logon to Xiaomi cloud: \" + e.getMessage());\n+        } catch (MiIoCryptoException e) {\n+            throw new MiCloudException(\"Error decrypting. Cannot logon to Xiaomi cloud: \" + e.getMessage());\n+        } catch (MalformedURLException e) {\n+            throw new MiCloudException(\"Error getting logon URL. Cannot logon to Xiaomi cloud: \" + e.getMessage());\n+        }\n+\n+    }\n+\n+    private String loginStep1() throws InterruptedException, TimeoutException, ExecutionException, MiCloudException {\n+        final ContentResponse responseStep1;\n+\n+        logger.trace(\"Xiaomi Login step 1\");\n+        String url = \"https://account.xiaomi.com/pass/serviceLogin?sid=xiaomiio&_json=true\";\n+        Request request = httpClient.newRequest(url).timeout(REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        request.agent(USERAGENT);\n+        request.header(HttpHeader.CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n+        request.cookie(new HttpCookie(\"userId\", this.userId.length() > 0 ? this.userId : this.username));\n+\n+        responseStep1 = request.send();\n+        final String content = responseStep1.getContentAsString();\n+        logger.trace(\"Xiaomi Login step 1 content response= {}\", content);\n+        logger.trace(\"Xiaomi Login step 1 response = {}\", responseStep1);\n+        try {\n+            JsonElement resp = new JsonParser().parse(parseJson(content));\n+            String sign = resp.getAsJsonObject().get(\"_sign\").getAsString();\n+            logger.trace(\"Xiaomi Login step 1 sign = {}\", sign);\n+            return sign;\n+        } catch (JsonSyntaxException e) {\n+            throw new MiCloudException(\"Error getting logon sign. Cannot parse response: \" + e.getMessage());", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NDU3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399944579", "bodyText": "include cause exception", "author": "cpmeister", "createdAt": "2020-03-30T06:03:00Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/MiCloudConnector.java", "diffHunk": "@@ -0,0 +1,468 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.io.IOException;\n+import java.net.CookieStore;\n+import java.net.HttpCookie;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpResponseException;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.FormContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.util.Fields;\n+import org.openhab.binding.miio.internal.MiIoCrypto;\n+import org.openhab.binding.miio.internal.MiIoCryptoException;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MiCloudConnector} class is used for connecting to the Xiaomi cloud access\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MiCloudConnector {\n+\n+    private static final int REQUEST_TIMEOUT_SECONDS = 10;\n+    private static final String UNEXPECTED = \"Unexpected :\";\n+    private static final String AGENT_ID = (new Random().ints(65, 70).limit(13)\n+            .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    private static final String USERAGENT = \"Android-7.1.1-1.0.0-ONEPLUS A3010-136-\" + AGENT_ID\n+            + \" APP/xiaomi.smarthome APPV/62830\";\n+    private final JsonParser parser = new JsonParser();\n+\n+    // String\n+    private String username;\n+    private String password;\n+\n+    private final String clientId;\n+    private String userId = \"\";\n+    private String serviceToken = \"\";\n+    private String ssecurity = \"\";\n+    int loginFailedCounter = 0;\n+\n+    private HttpClient httpClient;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MiCloudConnector.class);\n+\n+    public MiCloudConnector(String username, String password, HttpClient httpClient) throws MiCloudException {\n+        this.username = username;\n+        this.password = password;\n+        this.httpClient = httpClient;\n+        if (!checkCredentials()) {\n+            throw new MiCloudException(\"username or password can't be empty\");\n+        }\n+        clientId = (new Random().ints(97, 122 + 1).limit(6)\n+                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    }\n+\n+    void startClient() throws MiCloudException {\n+        if (!httpClient.isStarted()) {\n+            try {\n+                httpClient.start();\n+                // set default cookies\n+                CookieStore cookieStore = httpClient.getCookieStore();\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"mi.com\");\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"xiaomi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"mi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"xiaomi.com\");\n+            } catch (Exception e) {\n+                throw new MiCloudException(\"No http client cannot be started: \" + e.getMessage());\n+            }\n+        }\n+    }\n+\n+    public void stopClient() {\n+        try {\n+            this.httpClient.stop();\n+        } catch (Exception e) {\n+            logger.debug(\"Error stopping httpclient :{}\", e.getMessage());\n+        }\n+    }\n+\n+    private boolean checkCredentials() {\n+        if (username.trim().isEmpty() || password.trim().isEmpty()) {\n+            logger.info(\"Xiaomi Cloud: username or password missing.\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private String getApiUrl(String country) {\n+        return \"https://\" + (country.trim().equalsIgnoreCase(\"cn\") ? \"\" : country.trim().toLowerCase() + \".\")\n+                + \"api.io.mi.com/app\";\n+    }\n+\n+    public String getClientId() {\n+        return clientId;\n+    }\n+\n+    String parseJson(String data) {\n+        if (data.contains(\"&&&START&&&\")) {\n+            return data.replace(\"&&&START&&&\", \"\");\n+        } else {\n+            return UNEXPECTED.concat(data);\n+        }\n+    }\n+\n+    public String getMapUrl(String vacuumMap, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/getmapfileurl\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"obj_name\\\":\\\"\" + vacuumMap + \"\\\"}\");\n+        String mapResponse = request(url, map);\n+        logger.trace(\"response: {}\", mapResponse);\n+        String errorMsg = \"\";\n+        JsonElement response = parser.parse(mapResponse);\n+        if (response.isJsonObject()) {\n+            logger.debug(\"Received  JSON message {}\", response.toString());\n+            if (response.getAsJsonObject().has(\"result\") && response.getAsJsonObject().get(\"result\").isJsonObject()) {\n+                JsonObject jo = response.getAsJsonObject().get(\"result\").getAsJsonObject();\n+                if (jo.has(\"url\")) {\n+                    return jo.get(\"url\").getAsString();\n+                } else {\n+                    errorMsg = \"Could not get url\";\n+                }\n+            } else {\n+                errorMsg = \"Could not get result\";\n+            }\n+        } else {\n+            errorMsg = \"Received message is invalid JSON\";\n+        }\n+        logger.debug(\"{}: {}\", errorMsg, mapResponse);\n+        return \"\";\n+    }\n+\n+    public String getDeviceStatus(String device, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"dids\\\":[\\\"\" + device + \"\\\"]}\");\n+        logger.debug(\"response: {}\", request(url, map));\n+        return \"\";\n+    }\n+\n+    public String getLatest(String model, String country) {\n+        String url = getApiUrl(country) + \"/home/latest_version\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"model\\\":\\\"\" + model + \"\\\"}\");\n+        String resp;\n+        try {\n+            resp = request(url, map);\n+            logger.debug(\"Response: {}\", resp);\n+            // CloudUtil.printDevices(resp, logger);\n+            if (resp.length() > 2) {\n+                // CloudUtil.saveFile(resp, country, logger);\n+                return resp;\n+            }\n+        } catch (MiCloudException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+            return \"\";\n+        }\n+        return \"\";\n+    }\n+\n+    public String getDevices(String country) {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"getVirtualModel\\\":false,\\\"getHuamiDevices\\\":0}\");\n+        String resp;\n+        try {\n+            resp = request(url, map);\n+            logger.trace(\"Get devices response: {}\", resp);\n+            CloudUtil.printDevices(resp, country, logger);\n+            if (resp.length() > 2) {\n+                CloudUtil.saveFile(resp, country, logger);\n+                return resp;\n+            }\n+        } catch (MiCloudException e) {\n+            logger.info(\"{}\", e.getMessage());\n+        }\n+        return \"\";\n+    }\n+\n+    public String request(String urlPart, String country, Map<String, String> params) throws MiCloudException {\n+        String url = getApiUrl(country) + urlPart;\n+        String response = request(url, params);\n+        logger.debug(\"Request to {} server {}. Response: {}\", country, urlPart, response);\n+        return response;\n+    }\n+\n+    public String request(String url, Map<String, String> params) throws MiCloudException {\n+        if (this.serviceToken.isEmpty() || this.userId.isEmpty()) {\n+            throw new MiCloudException(\"Cannot execute request. service token or userId missing\");\n+        }\n+        try {\n+            startClient();\n+        } catch (Exception e) {\n+            throw new MiCloudException(\"Cannot Execute request. service token or userId missing\" + e.getMessage());", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NDczMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399944731", "bodyText": "use or lose", "author": "cpmeister", "createdAt": "2020-03-30T06:03:30Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/MiCloudConnector.java", "diffHunk": "@@ -0,0 +1,468 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.io.IOException;\n+import java.net.CookieStore;\n+import java.net.HttpCookie;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpResponseException;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.FormContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.util.Fields;\n+import org.openhab.binding.miio.internal.MiIoCrypto;\n+import org.openhab.binding.miio.internal.MiIoCryptoException;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MiCloudConnector} class is used for connecting to the Xiaomi cloud access\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MiCloudConnector {\n+\n+    private static final int REQUEST_TIMEOUT_SECONDS = 10;\n+    private static final String UNEXPECTED = \"Unexpected :\";\n+    private static final String AGENT_ID = (new Random().ints(65, 70).limit(13)\n+            .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    private static final String USERAGENT = \"Android-7.1.1-1.0.0-ONEPLUS A3010-136-\" + AGENT_ID\n+            + \" APP/xiaomi.smarthome APPV/62830\";\n+    private final JsonParser parser = new JsonParser();\n+\n+    // String\n+    private String username;\n+    private String password;\n+\n+    private final String clientId;\n+    private String userId = \"\";\n+    private String serviceToken = \"\";\n+    private String ssecurity = \"\";\n+    int loginFailedCounter = 0;\n+\n+    private HttpClient httpClient;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MiCloudConnector.class);\n+\n+    public MiCloudConnector(String username, String password, HttpClient httpClient) throws MiCloudException {\n+        this.username = username;\n+        this.password = password;\n+        this.httpClient = httpClient;\n+        if (!checkCredentials()) {\n+            throw new MiCloudException(\"username or password can't be empty\");\n+        }\n+        clientId = (new Random().ints(97, 122 + 1).limit(6)\n+                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    }\n+\n+    void startClient() throws MiCloudException {\n+        if (!httpClient.isStarted()) {\n+            try {\n+                httpClient.start();\n+                // set default cookies\n+                CookieStore cookieStore = httpClient.getCookieStore();\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"mi.com\");\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"xiaomi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"mi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"xiaomi.com\");\n+            } catch (Exception e) {\n+                throw new MiCloudException(\"No http client cannot be started: \" + e.getMessage());\n+            }\n+        }\n+    }\n+\n+    public void stopClient() {\n+        try {\n+            this.httpClient.stop();\n+        } catch (Exception e) {\n+            logger.debug(\"Error stopping httpclient :{}\", e.getMessage());\n+        }\n+    }\n+\n+    private boolean checkCredentials() {\n+        if (username.trim().isEmpty() || password.trim().isEmpty()) {\n+            logger.info(\"Xiaomi Cloud: username or password missing.\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private String getApiUrl(String country) {\n+        return \"https://\" + (country.trim().equalsIgnoreCase(\"cn\") ? \"\" : country.trim().toLowerCase() + \".\")\n+                + \"api.io.mi.com/app\";\n+    }\n+\n+    public String getClientId() {\n+        return clientId;\n+    }\n+\n+    String parseJson(String data) {\n+        if (data.contains(\"&&&START&&&\")) {\n+            return data.replace(\"&&&START&&&\", \"\");\n+        } else {\n+            return UNEXPECTED.concat(data);\n+        }\n+    }\n+\n+    public String getMapUrl(String vacuumMap, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/getmapfileurl\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"obj_name\\\":\\\"\" + vacuumMap + \"\\\"}\");\n+        String mapResponse = request(url, map);\n+        logger.trace(\"response: {}\", mapResponse);\n+        String errorMsg = \"\";\n+        JsonElement response = parser.parse(mapResponse);\n+        if (response.isJsonObject()) {\n+            logger.debug(\"Received  JSON message {}\", response.toString());\n+            if (response.getAsJsonObject().has(\"result\") && response.getAsJsonObject().get(\"result\").isJsonObject()) {\n+                JsonObject jo = response.getAsJsonObject().get(\"result\").getAsJsonObject();\n+                if (jo.has(\"url\")) {\n+                    return jo.get(\"url\").getAsString();\n+                } else {\n+                    errorMsg = \"Could not get url\";\n+                }\n+            } else {\n+                errorMsg = \"Could not get result\";\n+            }\n+        } else {\n+            errorMsg = \"Received message is invalid JSON\";\n+        }\n+        logger.debug(\"{}: {}\", errorMsg, mapResponse);\n+        return \"\";\n+    }\n+\n+    public String getDeviceStatus(String device, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"dids\\\":[\\\"\" + device + \"\\\"]}\");\n+        logger.debug(\"response: {}\", request(url, map));\n+        return \"\";\n+    }\n+\n+    public String getLatest(String model, String country) {\n+        String url = getApiUrl(country) + \"/home/latest_version\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"model\\\":\\\"\" + model + \"\\\"}\");\n+        String resp;\n+        try {\n+            resp = request(url, map);\n+            logger.debug(\"Response: {}\", resp);\n+            // CloudUtil.printDevices(resp, logger);", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NDc2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399944761", "bodyText": "use or lose", "author": "cpmeister", "createdAt": "2020-03-30T06:03:36Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/MiCloudConnector.java", "diffHunk": "@@ -0,0 +1,468 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.io.IOException;\n+import java.net.CookieStore;\n+import java.net.HttpCookie;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpResponseException;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.FormContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.util.Fields;\n+import org.openhab.binding.miio.internal.MiIoCrypto;\n+import org.openhab.binding.miio.internal.MiIoCryptoException;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MiCloudConnector} class is used for connecting to the Xiaomi cloud access\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MiCloudConnector {\n+\n+    private static final int REQUEST_TIMEOUT_SECONDS = 10;\n+    private static final String UNEXPECTED = \"Unexpected :\";\n+    private static final String AGENT_ID = (new Random().ints(65, 70).limit(13)\n+            .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    private static final String USERAGENT = \"Android-7.1.1-1.0.0-ONEPLUS A3010-136-\" + AGENT_ID\n+            + \" APP/xiaomi.smarthome APPV/62830\";\n+    private final JsonParser parser = new JsonParser();\n+\n+    // String\n+    private String username;\n+    private String password;\n+\n+    private final String clientId;\n+    private String userId = \"\";\n+    private String serviceToken = \"\";\n+    private String ssecurity = \"\";\n+    int loginFailedCounter = 0;\n+\n+    private HttpClient httpClient;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MiCloudConnector.class);\n+\n+    public MiCloudConnector(String username, String password, HttpClient httpClient) throws MiCloudException {\n+        this.username = username;\n+        this.password = password;\n+        this.httpClient = httpClient;\n+        if (!checkCredentials()) {\n+            throw new MiCloudException(\"username or password can't be empty\");\n+        }\n+        clientId = (new Random().ints(97, 122 + 1).limit(6)\n+                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    }\n+\n+    void startClient() throws MiCloudException {\n+        if (!httpClient.isStarted()) {\n+            try {\n+                httpClient.start();\n+                // set default cookies\n+                CookieStore cookieStore = httpClient.getCookieStore();\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"mi.com\");\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"xiaomi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"mi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"xiaomi.com\");\n+            } catch (Exception e) {\n+                throw new MiCloudException(\"No http client cannot be started: \" + e.getMessage());\n+            }\n+        }\n+    }\n+\n+    public void stopClient() {\n+        try {\n+            this.httpClient.stop();\n+        } catch (Exception e) {\n+            logger.debug(\"Error stopping httpclient :{}\", e.getMessage());\n+        }\n+    }\n+\n+    private boolean checkCredentials() {\n+        if (username.trim().isEmpty() || password.trim().isEmpty()) {\n+            logger.info(\"Xiaomi Cloud: username or password missing.\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private String getApiUrl(String country) {\n+        return \"https://\" + (country.trim().equalsIgnoreCase(\"cn\") ? \"\" : country.trim().toLowerCase() + \".\")\n+                + \"api.io.mi.com/app\";\n+    }\n+\n+    public String getClientId() {\n+        return clientId;\n+    }\n+\n+    String parseJson(String data) {\n+        if (data.contains(\"&&&START&&&\")) {\n+            return data.replace(\"&&&START&&&\", \"\");\n+        } else {\n+            return UNEXPECTED.concat(data);\n+        }\n+    }\n+\n+    public String getMapUrl(String vacuumMap, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/getmapfileurl\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"obj_name\\\":\\\"\" + vacuumMap + \"\\\"}\");\n+        String mapResponse = request(url, map);\n+        logger.trace(\"response: {}\", mapResponse);\n+        String errorMsg = \"\";\n+        JsonElement response = parser.parse(mapResponse);\n+        if (response.isJsonObject()) {\n+            logger.debug(\"Received  JSON message {}\", response.toString());\n+            if (response.getAsJsonObject().has(\"result\") && response.getAsJsonObject().get(\"result\").isJsonObject()) {\n+                JsonObject jo = response.getAsJsonObject().get(\"result\").getAsJsonObject();\n+                if (jo.has(\"url\")) {\n+                    return jo.get(\"url\").getAsString();\n+                } else {\n+                    errorMsg = \"Could not get url\";\n+                }\n+            } else {\n+                errorMsg = \"Could not get result\";\n+            }\n+        } else {\n+            errorMsg = \"Received message is invalid JSON\";\n+        }\n+        logger.debug(\"{}: {}\", errorMsg, mapResponse);\n+        return \"\";\n+    }\n+\n+    public String getDeviceStatus(String device, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"dids\\\":[\\\"\" + device + \"\\\"]}\");\n+        logger.debug(\"response: {}\", request(url, map));\n+        return \"\";\n+    }\n+\n+    public String getLatest(String model, String country) {\n+        String url = getApiUrl(country) + \"/home/latest_version\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"model\\\":\\\"\" + model + \"\\\"}\");\n+        String resp;\n+        try {\n+            resp = request(url, map);\n+            logger.debug(\"Response: {}\", resp);\n+            // CloudUtil.printDevices(resp, logger);\n+            if (resp.length() > 2) {\n+                // CloudUtil.saveFile(resp, country, logger);", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NTc1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399945751", "bodyText": "Always returns empty string?", "author": "cpmeister", "createdAt": "2020-03-30T06:06:50Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/MiCloudConnector.java", "diffHunk": "@@ -0,0 +1,468 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.io.IOException;\n+import java.net.CookieStore;\n+import java.net.HttpCookie;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpResponseException;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.FormContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.util.Fields;\n+import org.openhab.binding.miio.internal.MiIoCrypto;\n+import org.openhab.binding.miio.internal.MiIoCryptoException;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MiCloudConnector} class is used for connecting to the Xiaomi cloud access\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MiCloudConnector {\n+\n+    private static final int REQUEST_TIMEOUT_SECONDS = 10;\n+    private static final String UNEXPECTED = \"Unexpected :\";\n+    private static final String AGENT_ID = (new Random().ints(65, 70).limit(13)\n+            .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    private static final String USERAGENT = \"Android-7.1.1-1.0.0-ONEPLUS A3010-136-\" + AGENT_ID\n+            + \" APP/xiaomi.smarthome APPV/62830\";\n+    private final JsonParser parser = new JsonParser();\n+\n+    // String\n+    private String username;\n+    private String password;\n+\n+    private final String clientId;\n+    private String userId = \"\";\n+    private String serviceToken = \"\";\n+    private String ssecurity = \"\";\n+    int loginFailedCounter = 0;\n+\n+    private HttpClient httpClient;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MiCloudConnector.class);\n+\n+    public MiCloudConnector(String username, String password, HttpClient httpClient) throws MiCloudException {\n+        this.username = username;\n+        this.password = password;\n+        this.httpClient = httpClient;\n+        if (!checkCredentials()) {\n+            throw new MiCloudException(\"username or password can't be empty\");\n+        }\n+        clientId = (new Random().ints(97, 122 + 1).limit(6)\n+                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    }\n+\n+    void startClient() throws MiCloudException {\n+        if (!httpClient.isStarted()) {\n+            try {\n+                httpClient.start();\n+                // set default cookies\n+                CookieStore cookieStore = httpClient.getCookieStore();\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"mi.com\");\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"xiaomi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"mi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"xiaomi.com\");\n+            } catch (Exception e) {\n+                throw new MiCloudException(\"No http client cannot be started: \" + e.getMessage());\n+            }\n+        }\n+    }\n+\n+    public void stopClient() {\n+        try {\n+            this.httpClient.stop();\n+        } catch (Exception e) {\n+            logger.debug(\"Error stopping httpclient :{}\", e.getMessage());\n+        }\n+    }\n+\n+    private boolean checkCredentials() {\n+        if (username.trim().isEmpty() || password.trim().isEmpty()) {\n+            logger.info(\"Xiaomi Cloud: username or password missing.\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private String getApiUrl(String country) {\n+        return \"https://\" + (country.trim().equalsIgnoreCase(\"cn\") ? \"\" : country.trim().toLowerCase() + \".\")\n+                + \"api.io.mi.com/app\";\n+    }\n+\n+    public String getClientId() {\n+        return clientId;\n+    }\n+\n+    String parseJson(String data) {\n+        if (data.contains(\"&&&START&&&\")) {\n+            return data.replace(\"&&&START&&&\", \"\");\n+        } else {\n+            return UNEXPECTED.concat(data);\n+        }\n+    }\n+\n+    public String getMapUrl(String vacuumMap, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/getmapfileurl\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"obj_name\\\":\\\"\" + vacuumMap + \"\\\"}\");\n+        String mapResponse = request(url, map);\n+        logger.trace(\"response: {}\", mapResponse);\n+        String errorMsg = \"\";\n+        JsonElement response = parser.parse(mapResponse);\n+        if (response.isJsonObject()) {\n+            logger.debug(\"Received  JSON message {}\", response.toString());\n+            if (response.getAsJsonObject().has(\"result\") && response.getAsJsonObject().get(\"result\").isJsonObject()) {\n+                JsonObject jo = response.getAsJsonObject().get(\"result\").getAsJsonObject();\n+                if (jo.has(\"url\")) {\n+                    return jo.get(\"url\").getAsString();\n+                } else {\n+                    errorMsg = \"Could not get url\";\n+                }\n+            } else {\n+                errorMsg = \"Could not get result\";\n+            }\n+        } else {\n+            errorMsg = \"Received message is invalid JSON\";\n+        }\n+        logger.debug(\"{}: {}\", errorMsg, mapResponse);\n+        return \"\";\n+    }\n+\n+    public String getDeviceStatus(String device, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"dids\\\":[\\\"\" + device + \"\\\"]}\");\n+        logger.debug(\"response: {}\", request(url, map));\n+        return \"\";", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NjA0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399946045", "bodyText": "Why are you forcing the locale to UK?", "author": "cpmeister", "createdAt": "2020-03-30T06:07:48Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/MiCloudConnector.java", "diffHunk": "@@ -0,0 +1,468 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.io.IOException;\n+import java.net.CookieStore;\n+import java.net.HttpCookie;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpResponseException;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.FormContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.util.Fields;\n+import org.openhab.binding.miio.internal.MiIoCrypto;\n+import org.openhab.binding.miio.internal.MiIoCryptoException;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MiCloudConnector} class is used for connecting to the Xiaomi cloud access\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MiCloudConnector {\n+\n+    private static final int REQUEST_TIMEOUT_SECONDS = 10;\n+    private static final String UNEXPECTED = \"Unexpected :\";\n+    private static final String AGENT_ID = (new Random().ints(65, 70).limit(13)\n+            .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    private static final String USERAGENT = \"Android-7.1.1-1.0.0-ONEPLUS A3010-136-\" + AGENT_ID\n+            + \" APP/xiaomi.smarthome APPV/62830\";\n+    private final JsonParser parser = new JsonParser();\n+\n+    // String\n+    private String username;\n+    private String password;\n+\n+    private final String clientId;\n+    private String userId = \"\";\n+    private String serviceToken = \"\";\n+    private String ssecurity = \"\";\n+    int loginFailedCounter = 0;\n+\n+    private HttpClient httpClient;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MiCloudConnector.class);\n+\n+    public MiCloudConnector(String username, String password, HttpClient httpClient) throws MiCloudException {\n+        this.username = username;\n+        this.password = password;\n+        this.httpClient = httpClient;\n+        if (!checkCredentials()) {\n+            throw new MiCloudException(\"username or password can't be empty\");\n+        }\n+        clientId = (new Random().ints(97, 122 + 1).limit(6)\n+                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    }\n+\n+    void startClient() throws MiCloudException {\n+        if (!httpClient.isStarted()) {\n+            try {\n+                httpClient.start();\n+                // set default cookies\n+                CookieStore cookieStore = httpClient.getCookieStore();\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"mi.com\");\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"xiaomi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"mi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"xiaomi.com\");\n+            } catch (Exception e) {\n+                throw new MiCloudException(\"No http client cannot be started: \" + e.getMessage());\n+            }\n+        }\n+    }\n+\n+    public void stopClient() {\n+        try {\n+            this.httpClient.stop();\n+        } catch (Exception e) {\n+            logger.debug(\"Error stopping httpclient :{}\", e.getMessage());\n+        }\n+    }\n+\n+    private boolean checkCredentials() {\n+        if (username.trim().isEmpty() || password.trim().isEmpty()) {\n+            logger.info(\"Xiaomi Cloud: username or password missing.\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private String getApiUrl(String country) {\n+        return \"https://\" + (country.trim().equalsIgnoreCase(\"cn\") ? \"\" : country.trim().toLowerCase() + \".\")\n+                + \"api.io.mi.com/app\";\n+    }\n+\n+    public String getClientId() {\n+        return clientId;\n+    }\n+\n+    String parseJson(String data) {\n+        if (data.contains(\"&&&START&&&\")) {\n+            return data.replace(\"&&&START&&&\", \"\");\n+        } else {\n+            return UNEXPECTED.concat(data);\n+        }\n+    }\n+\n+    public String getMapUrl(String vacuumMap, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/getmapfileurl\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"obj_name\\\":\\\"\" + vacuumMap + \"\\\"}\");\n+        String mapResponse = request(url, map);\n+        logger.trace(\"response: {}\", mapResponse);\n+        String errorMsg = \"\";\n+        JsonElement response = parser.parse(mapResponse);\n+        if (response.isJsonObject()) {\n+            logger.debug(\"Received  JSON message {}\", response.toString());\n+            if (response.getAsJsonObject().has(\"result\") && response.getAsJsonObject().get(\"result\").isJsonObject()) {\n+                JsonObject jo = response.getAsJsonObject().get(\"result\").getAsJsonObject();\n+                if (jo.has(\"url\")) {\n+                    return jo.get(\"url\").getAsString();\n+                } else {\n+                    errorMsg = \"Could not get url\";\n+                }\n+            } else {\n+                errorMsg = \"Could not get result\";\n+            }\n+        } else {\n+            errorMsg = \"Received message is invalid JSON\";\n+        }\n+        logger.debug(\"{}: {}\", errorMsg, mapResponse);\n+        return \"\";\n+    }\n+\n+    public String getDeviceStatus(String device, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"dids\\\":[\\\"\" + device + \"\\\"]}\");\n+        logger.debug(\"response: {}\", request(url, map));\n+        return \"\";\n+    }\n+\n+    public String getLatest(String model, String country) {\n+        String url = getApiUrl(country) + \"/home/latest_version\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"model\\\":\\\"\" + model + \"\\\"}\");\n+        String resp;\n+        try {\n+            resp = request(url, map);\n+            logger.debug(\"Response: {}\", resp);\n+            // CloudUtil.printDevices(resp, logger);\n+            if (resp.length() > 2) {\n+                // CloudUtil.saveFile(resp, country, logger);\n+                return resp;\n+            }\n+        } catch (MiCloudException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+            return \"\";\n+        }\n+        return \"\";\n+    }\n+\n+    public String getDevices(String country) {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"getVirtualModel\\\":false,\\\"getHuamiDevices\\\":0}\");\n+        String resp;\n+        try {\n+            resp = request(url, map);\n+            logger.trace(\"Get devices response: {}\", resp);\n+            CloudUtil.printDevices(resp, country, logger);\n+            if (resp.length() > 2) {\n+                CloudUtil.saveFile(resp, country, logger);\n+                return resp;\n+            }\n+        } catch (MiCloudException e) {\n+            logger.info(\"{}\", e.getMessage());\n+        }\n+        return \"\";\n+    }\n+\n+    public String request(String urlPart, String country, Map<String, String> params) throws MiCloudException {\n+        String url = getApiUrl(country) + urlPart;\n+        String response = request(url, params);\n+        logger.debug(\"Request to {} server {}. Response: {}\", country, urlPart, response);\n+        return response;\n+    }\n+\n+    public String request(String url, Map<String, String> params) throws MiCloudException {\n+        if (this.serviceToken.isEmpty() || this.userId.isEmpty()) {\n+            throw new MiCloudException(\"Cannot execute request. service token or userId missing\");\n+        }\n+        try {\n+            startClient();\n+        } catch (Exception e) {\n+            throw new MiCloudException(\"Cannot Execute request. service token or userId missing\" + e.getMessage());\n+        }\n+        logger.debug(\"Send request: {} to {}\", params.get(\"data\"), url);\n+        Request request = httpClient.newRequest(url).timeout(REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        request.agent(USERAGENT);\n+        request.header(\"x-xiaomi-protocal-flag-cli\", \"PROTOCAL-HTTP2\");\n+        request.header(HttpHeader.CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n+        request.cookie(new HttpCookie(\"userId\", this.userId));\n+        request.cookie(new HttpCookie(\"yetAnotherServiceToken\", this.serviceToken));\n+        request.cookie(new HttpCookie(\"serviceToken\", this.serviceToken));\n+        request.cookie(new HttpCookie(\"locale\", \"uk_GB\"));", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NjI5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399946290", "bodyText": "Please use a multicatch", "author": "cpmeister", "createdAt": "2020-03-30T06:08:28Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/MiCloudConnector.java", "diffHunk": "@@ -0,0 +1,468 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.io.IOException;\n+import java.net.CookieStore;\n+import java.net.HttpCookie;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpResponseException;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.FormContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.util.Fields;\n+import org.openhab.binding.miio.internal.MiIoCrypto;\n+import org.openhab.binding.miio.internal.MiIoCryptoException;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MiCloudConnector} class is used for connecting to the Xiaomi cloud access\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MiCloudConnector {\n+\n+    private static final int REQUEST_TIMEOUT_SECONDS = 10;\n+    private static final String UNEXPECTED = \"Unexpected :\";\n+    private static final String AGENT_ID = (new Random().ints(65, 70).limit(13)\n+            .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    private static final String USERAGENT = \"Android-7.1.1-1.0.0-ONEPLUS A3010-136-\" + AGENT_ID\n+            + \" APP/xiaomi.smarthome APPV/62830\";\n+    private final JsonParser parser = new JsonParser();\n+\n+    // String\n+    private String username;\n+    private String password;\n+\n+    private final String clientId;\n+    private String userId = \"\";\n+    private String serviceToken = \"\";\n+    private String ssecurity = \"\";\n+    int loginFailedCounter = 0;\n+\n+    private HttpClient httpClient;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MiCloudConnector.class);\n+\n+    public MiCloudConnector(String username, String password, HttpClient httpClient) throws MiCloudException {\n+        this.username = username;\n+        this.password = password;\n+        this.httpClient = httpClient;\n+        if (!checkCredentials()) {\n+            throw new MiCloudException(\"username or password can't be empty\");\n+        }\n+        clientId = (new Random().ints(97, 122 + 1).limit(6)\n+                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    }\n+\n+    void startClient() throws MiCloudException {\n+        if (!httpClient.isStarted()) {\n+            try {\n+                httpClient.start();\n+                // set default cookies\n+                CookieStore cookieStore = httpClient.getCookieStore();\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"mi.com\");\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"xiaomi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"mi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"xiaomi.com\");\n+            } catch (Exception e) {\n+                throw new MiCloudException(\"No http client cannot be started: \" + e.getMessage());\n+            }\n+        }\n+    }\n+\n+    public void stopClient() {\n+        try {\n+            this.httpClient.stop();\n+        } catch (Exception e) {\n+            logger.debug(\"Error stopping httpclient :{}\", e.getMessage());\n+        }\n+    }\n+\n+    private boolean checkCredentials() {\n+        if (username.trim().isEmpty() || password.trim().isEmpty()) {\n+            logger.info(\"Xiaomi Cloud: username or password missing.\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private String getApiUrl(String country) {\n+        return \"https://\" + (country.trim().equalsIgnoreCase(\"cn\") ? \"\" : country.trim().toLowerCase() + \".\")\n+                + \"api.io.mi.com/app\";\n+    }\n+\n+    public String getClientId() {\n+        return clientId;\n+    }\n+\n+    String parseJson(String data) {\n+        if (data.contains(\"&&&START&&&\")) {\n+            return data.replace(\"&&&START&&&\", \"\");\n+        } else {\n+            return UNEXPECTED.concat(data);\n+        }\n+    }\n+\n+    public String getMapUrl(String vacuumMap, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/getmapfileurl\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"obj_name\\\":\\\"\" + vacuumMap + \"\\\"}\");\n+        String mapResponse = request(url, map);\n+        logger.trace(\"response: {}\", mapResponse);\n+        String errorMsg = \"\";\n+        JsonElement response = parser.parse(mapResponse);\n+        if (response.isJsonObject()) {\n+            logger.debug(\"Received  JSON message {}\", response.toString());\n+            if (response.getAsJsonObject().has(\"result\") && response.getAsJsonObject().get(\"result\").isJsonObject()) {\n+                JsonObject jo = response.getAsJsonObject().get(\"result\").getAsJsonObject();\n+                if (jo.has(\"url\")) {\n+                    return jo.get(\"url\").getAsString();\n+                } else {\n+                    errorMsg = \"Could not get url\";\n+                }\n+            } else {\n+                errorMsg = \"Could not get result\";\n+            }\n+        } else {\n+            errorMsg = \"Received message is invalid JSON\";\n+        }\n+        logger.debug(\"{}: {}\", errorMsg, mapResponse);\n+        return \"\";\n+    }\n+\n+    public String getDeviceStatus(String device, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"dids\\\":[\\\"\" + device + \"\\\"]}\");\n+        logger.debug(\"response: {}\", request(url, map));\n+        return \"\";\n+    }\n+\n+    public String getLatest(String model, String country) {\n+        String url = getApiUrl(country) + \"/home/latest_version\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"model\\\":\\\"\" + model + \"\\\"}\");\n+        String resp;\n+        try {\n+            resp = request(url, map);\n+            logger.debug(\"Response: {}\", resp);\n+            // CloudUtil.printDevices(resp, logger);\n+            if (resp.length() > 2) {\n+                // CloudUtil.saveFile(resp, country, logger);\n+                return resp;\n+            }\n+        } catch (MiCloudException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+            return \"\";\n+        }\n+        return \"\";\n+    }\n+\n+    public String getDevices(String country) {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"getVirtualModel\\\":false,\\\"getHuamiDevices\\\":0}\");\n+        String resp;\n+        try {\n+            resp = request(url, map);\n+            logger.trace(\"Get devices response: {}\", resp);\n+            CloudUtil.printDevices(resp, country, logger);\n+            if (resp.length() > 2) {\n+                CloudUtil.saveFile(resp, country, logger);\n+                return resp;\n+            }\n+        } catch (MiCloudException e) {\n+            logger.info(\"{}\", e.getMessage());\n+        }\n+        return \"\";\n+    }\n+\n+    public String request(String urlPart, String country, Map<String, String> params) throws MiCloudException {\n+        String url = getApiUrl(country) + urlPart;\n+        String response = request(url, params);\n+        logger.debug(\"Request to {} server {}. Response: {}\", country, urlPart, response);\n+        return response;\n+    }\n+\n+    public String request(String url, Map<String, String> params) throws MiCloudException {\n+        if (this.serviceToken.isEmpty() || this.userId.isEmpty()) {\n+            throw new MiCloudException(\"Cannot execute request. service token or userId missing\");\n+        }\n+        try {\n+            startClient();\n+        } catch (Exception e) {\n+            throw new MiCloudException(\"Cannot Execute request. service token or userId missing\" + e.getMessage());\n+        }\n+        logger.debug(\"Send request: {} to {}\", params.get(\"data\"), url);\n+        Request request = httpClient.newRequest(url).timeout(REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        request.agent(USERAGENT);\n+        request.header(\"x-xiaomi-protocal-flag-cli\", \"PROTOCAL-HTTP2\");\n+        request.header(HttpHeader.CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n+        request.cookie(new HttpCookie(\"userId\", this.userId));\n+        request.cookie(new HttpCookie(\"yetAnotherServiceToken\", this.serviceToken));\n+        request.cookie(new HttpCookie(\"serviceToken\", this.serviceToken));\n+        request.cookie(new HttpCookie(\"locale\", \"uk_GB\"));\n+        request.cookie(new HttpCookie(\"timezone\", \"GMT%2B01%3A00\"));\n+        request.cookie(new HttpCookie(\"is_daylight\", \"1\"));\n+        request.cookie(new HttpCookie(\"dst_offset\", \"3600000\"));\n+        request.cookie(new HttpCookie(\"channel\", \"MI_APP_STORE\"));\n+\n+        for (HttpCookie cookie : request.getCookies()) {\n+            logger.trace(\"Cookie set for request ({}) : {} --> {}     (path: {})\", cookie.getDomain(), cookie.getName(),\n+                    cookie.getValue(), cookie.getPath());\n+        }\n+        String method = \"POST\";\n+        request.method(method);\n+\n+        try {\n+            String nonce = CloudUtil.generateNonce(System.currentTimeMillis());\n+            String signedNonce = CloudUtil.signedNonce(ssecurity, nonce);\n+            String signature = CloudUtil.generateSignature(url.replace(\"/app\", \"\"), signedNonce, nonce, params);\n+\n+            Fields fields = new Fields();\n+            fields.put(\"signature\", signature);\n+            fields.put(\"_nonce\", nonce);\n+            fields.put(\"data\", params.get(\"data\"));\n+            request.content(new FormContentProvider(fields));\n+\n+            logger.trace(\"fieldcontent: {}\", fields.toString());\n+            final ContentResponse response = request.send();\n+            return response.getContentAsString();\n+        } catch (HttpResponseException e) {\n+            serviceToken = \"\";\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (ExecutionException e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (IOException e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0Njc2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399946765", "bodyText": "can most of these fields be made final?", "author": "cpmeister", "createdAt": "2020-03-30T06:09:59Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/robot/RRMapFileParser.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.robot;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RRMapFileParser} is used to parse the RR map file format created by Xiaomi / RockRobo vacuum\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RRMapFileParser {\n+    public static final int CHARGER = 1;\n+    public static final int IMAGE = 2;\n+    public static final int PATH = 3;\n+    public static final int GOTO_PATH = 4;\n+    public static final int GOTO_PREDICTED_PATH = 5;\n+    public static final int CURRENTLY_CLEANED_ZONES = 6;\n+    public static final int GOTO_TARGET = 7;\n+    public static final int ROBOT_POSITION = 8;\n+    public static final int NO_GO_AREAS = 9;\n+    public static final int VIRTUAL_WALLS = 10;\n+    public static final int BLOCKS = 11;\n+    public static final int MFBZS_AREA = 12;\n+    public static final int OBSTACLES = 13;\n+    public static final int DIGEST = 1024;\n+    public static final int HEADER = 0x7272;\n+\n+    public static final String PATH_POINT_LENGTH = \"pointLength\";\n+    public static final String PATH_POINT_SIZE = \"pointSize\";\n+    public static final String PATH_ANGLE = \"angle\";\n+\n+    private static final float MM = 50.0f;\n+\n+    private byte[] image = new byte[] { 0 };\n+    private int majorVersion;", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0Njk1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399946954", "bodyText": "Please put static variables above the constructors", "author": "cpmeister", "createdAt": "2020-03-30T06:10:34Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/MiCloudException.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Will be thrown for cloud errors\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MiCloudException extends Exception {\n+\n+    public MiCloudException() {\n+        super();\n+    }\n+\n+    public MiCloudException(String arg0) {\n+        super(arg0);\n+    }\n+\n+    /**\n+     * required variable to avoid IncorrectMultilineIndexException warning\n+     */\n+    private static final long serialVersionUID = -1280858607995252321L;", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NzE3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399947174", "bodyText": "Why not use Optional<String> instead?", "author": "cpmeister", "createdAt": "2020-03-30T06:11:10Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/MiCloudConnector.java", "diffHunk": "@@ -0,0 +1,468 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.io.IOException;\n+import java.net.CookieStore;\n+import java.net.HttpCookie;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpResponseException;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.FormContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.util.Fields;\n+import org.openhab.binding.miio.internal.MiIoCrypto;\n+import org.openhab.binding.miio.internal.MiIoCryptoException;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MiCloudConnector} class is used for connecting to the Xiaomi cloud access\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MiCloudConnector {\n+\n+    private static final int REQUEST_TIMEOUT_SECONDS = 10;\n+    private static final String UNEXPECTED = \"Unexpected :\";\n+    private static final String AGENT_ID = (new Random().ints(65, 70).limit(13)\n+            .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    private static final String USERAGENT = \"Android-7.1.1-1.0.0-ONEPLUS A3010-136-\" + AGENT_ID\n+            + \" APP/xiaomi.smarthome APPV/62830\";\n+    private final JsonParser parser = new JsonParser();\n+\n+    // String\n+    private String username;\n+    private String password;\n+\n+    private final String clientId;\n+    private String userId = \"\";\n+    private String serviceToken = \"\";", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI0MzU5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r401243595", "bodyText": "I did not know about this Optional way, is indeed useful.\nThough in this particular case I'm not clear what it will bring additionally as a empty string as servicetoken won't be helping me to logon. It would add test for isPresent() on top of the existing isempty ones", "author": "marcelrv", "createdAt": "2020-03-31T22:06:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NzE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NzU2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399947569", "bodyText": "Can you do the todo?", "author": "cpmeister", "createdAt": "2020-03-30T06:12:27Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/CloudConnector.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.jetbrains.annotations.NotNull;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link CloudConnector} is responsible for connecting OH to the Xiaomi cloud communication.\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class CloudConnector {\n+\n+    protected static final long CACHE_EXPIRY = TimeUnit.SECONDS.toMillis(60);\n+    private static final int FAILED = -1;\n+    private static final int STARTING = 0;\n+    private static final int REFRESHING = 1;\n+    private static final int AVAILABLE = 2;\n+    private int deviceListState = STARTING;\n+\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String country = \"ru,us,tw,sg,cn,de\";\n+\n+    private List<JsonObject> deviceList = new ArrayList<JsonObject>();\n+    private final JsonParser parser = new JsonParser();\n+    private boolean connected;\n+\n+    private @Nullable HttpClient httpClient;\n+\n+    private @Nullable MiCloudConnector cloudConnector;\n+    public static final CloudConnector CC_INSTANCE = new CloudConnector();\n+    private final Logger logger = LoggerFactory.getLogger(CloudConnector.class);\n+\n+    private ExpiringCache<Boolean> logonCache = new ExpiringCache<Boolean>(CACHE_EXPIRY, () -> {\n+        return logon();\n+    });\n+\n+    private ExpiringCache<String> refreshDeviceList = new ExpiringCache<String>(CACHE_EXPIRY, () -> {\n+        if (deviceListState == FAILED && !isConnected()) {\n+            return (\"Could not connect to Xiaomi cloud\");\n+        }\n+        final @Nullable MiCloudConnector cl = this.cloudConnector;\n+        if (cl == null) {\n+            return (\"Could not connect to Xiaomi cloud\");\n+        }\n+        deviceListState = REFRESHING;\n+        deviceList.clear();\n+        for (String server : country.split(\",\")) {\n+            try {\n+                JsonElement response = parser.parse(cl.getDevices(server));\n+                if (response.isJsonObject() && response.getAsJsonObject().has(\"result\")\n+                        && response.getAsJsonObject().get(\"result\").isJsonObject()) {\n+                    JsonObject result = response.getAsJsonObject().get(\"result\").getAsJsonObject();\n+                    result.addProperty(\"server\", server);\n+                    deviceList.add(result);\n+                }\n+            } catch (JsonParseException e) {\n+                logger.debug(\"Parsing error getting devices: {}\", e.getMessage());\n+            }\n+        }\n+        deviceListState = AVAILABLE;\n+        return \"done\";// deviceList;\n+    });\n+\n+    private CloudConnector() {\n+    }\n+\n+    public static CloudConnector getInstance() {\n+        return CC_INSTANCE;\n+    }\n+\n+    public boolean isConnected() {\n+        final MiCloudConnector cl = cloudConnector;\n+        if (cl != null && cl.hasLoginToken()) {\n+            return true;\n+        }\n+        final @Nullable Boolean c = logonCache.getValue();\n+        if (c != null && c.booleanValue()) {\n+            return true;\n+        }\n+        deviceListState = FAILED;\n+        return false;\n+    }\n+\n+    public byte[] getMap(String mapId, String country) throws MiCloudException {\n+        logger.info(\"Getting vacuum map {} from Xiaomi cloud server: {}\", mapId, country);\n+        String mapCountry;\n+        String mapUrl = \"\";\n+        final @Nullable MiCloudConnector cl = this.cloudConnector;\n+        if (cl == null || !isConnected()) {\n+            throw new MiCloudException(\"Cannot execute request. Cloudservice not available\");\n+        }\n+        if (country.isEmpty()) {\n+            // TODO: pick the right server in a more intelligent way", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NzY2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r399947665", "bodyText": "orphan semicolon", "author": "cpmeister", "createdAt": "2020-03-30T06:12:40Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/CloudConnector.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.jetbrains.annotations.NotNull;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link CloudConnector} is responsible for connecting OH to the Xiaomi cloud communication.\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class CloudConnector {\n+\n+    protected static final long CACHE_EXPIRY = TimeUnit.SECONDS.toMillis(60);\n+    private static final int FAILED = -1;\n+    private static final int STARTING = 0;\n+    private static final int REFRESHING = 1;\n+    private static final int AVAILABLE = 2;\n+    private int deviceListState = STARTING;\n+\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String country = \"ru,us,tw,sg,cn,de\";\n+\n+    private List<JsonObject> deviceList = new ArrayList<JsonObject>();\n+    private final JsonParser parser = new JsonParser();\n+    private boolean connected;\n+\n+    private @Nullable HttpClient httpClient;\n+\n+    private @Nullable MiCloudConnector cloudConnector;\n+    public static final CloudConnector CC_INSTANCE = new CloudConnector();\n+    private final Logger logger = LoggerFactory.getLogger(CloudConnector.class);\n+\n+    private ExpiringCache<Boolean> logonCache = new ExpiringCache<Boolean>(CACHE_EXPIRY, () -> {\n+        return logon();\n+    });\n+\n+    private ExpiringCache<String> refreshDeviceList = new ExpiringCache<String>(CACHE_EXPIRY, () -> {\n+        if (deviceListState == FAILED && !isConnected()) {\n+            return (\"Could not connect to Xiaomi cloud\");\n+        }\n+        final @Nullable MiCloudConnector cl = this.cloudConnector;\n+        if (cl == null) {\n+            return (\"Could not connect to Xiaomi cloud\");\n+        }\n+        deviceListState = REFRESHING;\n+        deviceList.clear();\n+        for (String server : country.split(\",\")) {\n+            try {\n+                JsonElement response = parser.parse(cl.getDevices(server));\n+                if (response.isJsonObject() && response.getAsJsonObject().has(\"result\")\n+                        && response.getAsJsonObject().get(\"result\").isJsonObject()) {\n+                    JsonObject result = response.getAsJsonObject().get(\"result\").getAsJsonObject();\n+                    result.addProperty(\"server\", server);\n+                    deviceList.add(result);\n+                }\n+            } catch (JsonParseException e) {\n+                logger.debug(\"Parsing error getting devices: {}\", e.getMessage());\n+            }\n+        }\n+        deviceListState = AVAILABLE;\n+        return \"done\";// deviceList;\n+    });\n+\n+    private CloudConnector() {\n+    }\n+\n+    public static CloudConnector getInstance() {\n+        return CC_INSTANCE;\n+    }\n+\n+    public boolean isConnected() {\n+        final MiCloudConnector cl = cloudConnector;\n+        if (cl != null && cl.hasLoginToken()) {\n+            return true;\n+        }\n+        final @Nullable Boolean c = logonCache.getValue();\n+        if (c != null && c.booleanValue()) {\n+            return true;\n+        }\n+        deviceListState = FAILED;\n+        return false;\n+    }\n+\n+    public byte[] getMap(String mapId, String country) throws MiCloudException {\n+        logger.info(\"Getting vacuum map {} from Xiaomi cloud server: {}\", mapId, country);\n+        String mapCountry;\n+        String mapUrl = \"\";\n+        final @Nullable MiCloudConnector cl = this.cloudConnector;\n+        if (cl == null || !isConnected()) {\n+            throw new MiCloudException(\"Cannot execute request. Cloudservice not available\");\n+        }\n+        if (country.isEmpty()) {\n+            // TODO: pick the right server in a more intelligent way\n+            logger.debug(\"Server not defined in thing. Trying servers: {}\", this.country);\n+            for (String mapCountryServer : this.country.split(\",\")) {\n+                ;", "originalCommit": "13976de829f08bc18d34b94c02768d9bae599f56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "84e113ad3098296f15290512d085c8df24e5080e", "url": "https://github.com/openhab/openhab-addons/commit/84e113ad3098296f15290512d085c8df24e5080e", "message": "[miio] fix updating basic devices (#7254)\n\nSigned-off-by: Marcel Verpaalen <marcel@verpaalen.com>", "committedDate": "2020-03-31T11:57:17Z", "type": "commit"}, {"oid": "07b902f80c2a8a02d39a874953396fe3cbc5f5af", "url": "https://github.com/openhab/openhab-addons/commit/07b902f80c2a8a02d39a874953396fe3cbc5f5af", "message": "Merge remote-tracking branch 'origin/2.5.x' into miio-cloudconnect", "committedDate": "2020-03-31T11:57:54Z", "type": "commit"}, {"oid": "75bcaf7c0723338514c62a4bdb7635e4cdb56cc2", "url": "https://github.com/openhab/openhab-addons/commit/75bcaf7c0723338514c62a4bdb7635e4cdb56cc2", "message": "[miio] improvements based on feedback\n\n* feedback improvements\n* token obfuscation for log sharing\n* basic handler cleanup and improvements\n\nSigned-off-by: Marcel Verpaalen <marcel@verpaalen.com>", "committedDate": "2020-04-01T14:46:53Z", "type": "commit"}, {"oid": "75bcaf7c0723338514c62a4bdb7635e4cdb56cc2", "url": "https://github.com/openhab/openhab-addons/commit/75bcaf7c0723338514c62a4bdb7635e4cdb56cc2", "message": "[miio] improvements based on feedback\n\n* feedback improvements\n* token obfuscation for log sharing\n* basic handler cleanup and improvements\n\nSigned-off-by: Marcel Verpaalen <marcel@verpaalen.com>", "committedDate": "2020-04-01T14:46:53Z", "type": "forcePushed"}, {"oid": "83ebc3dcf72e47036e7e79ebf136a04ed11ebe72", "url": "https://github.com/openhab/openhab-addons/commit/83ebc3dcf72e47036e7e79ebf136a04ed11ebe72", "message": "[miio] schedule login to avoid activation issues\n\nSigned-off-by: Marcel Verpaalen <marcel@verpaalen.com>", "committedDate": "2020-04-01T18:59:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM4MzAyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402383025", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private int deviceListState = STARTING;\n          \n          \n            \n                private volatile int deviceListState = STARTING;", "author": "cpmeister", "createdAt": "2020-04-02T15:00:39Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/CloudConnector.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import static org.openhab.binding.miio.internal.MiIoBindingConstants.BINDING_ID;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link CloudConnector} is responsible for connecting OH to the Xiaomi cloud communication.\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@Component(service = CloudConnector.class)\n+@NonNullByDefault\n+public class CloudConnector {\n+\n+    protected static final long CACHE_EXPIRY = TimeUnit.SECONDS.toMillis(60);\n+    private static final int FAILED = -1;\n+    private static final int STARTING = 0;\n+    private static final int REFRESHING = 1;\n+    private static final int AVAILABLE = 2;\n+    private int deviceListState = STARTING;", "originalCommit": "83ebc3dcf72e47036e7e79ebf136a04ed11ebe72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ0Nzc5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402447797", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    scheduler.schedule(() -> cloudConnector.setCredentials(username, password, country), 0, TimeUnit.SECONDS);\n          \n          \n            \n                    scheduler.submit(() -> cloudConnector.setCredentials(username, password, country));", "author": "cpmeister", "createdAt": "2020-04-02T16:29:56Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/MiIoHandlerFactory.java", "diffHunk": "@@ -39,12 +46,31 @@\n @Component(service = ThingHandlerFactory.class, configurationPid = \"binding.miio\")\n @NonNullByDefault\n public class MiIoHandlerFactory extends BaseThingHandlerFactory {\n+    private static final String THING_HANDLER_THREADPOOL_NAME = \"thingHandler\";\n+    protected final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(THING_HANDLER_THREADPOOL_NAME);\n \n     private MiIoDatabaseWatchService miIoDatabaseWatchService;\n+    private CloudConnector cloudConnector;\n \n     @Activate\n-    public MiIoHandlerFactory(@Reference MiIoDatabaseWatchService miIoDatabaseWatchService) {\n+    public MiIoHandlerFactory(@Reference MiIoDatabaseWatchService miIoDatabaseWatchService,\n+            @Reference CloudConnector cloudConnector) {\n         this.miIoDatabaseWatchService = miIoDatabaseWatchService;\n+        this.cloudConnector = cloudConnector;\n+    }\n+\n+    @Override\n+    protected void activate(ComponentContext componentContext) {\n+        super.activate(componentContext);\n+        Dictionary<String, Object> properties = componentContext.getProperties();\n+        @Nullable\n+        String username = (String) properties.get(\"username\");\n+        @Nullable\n+        String password = (String) properties.get(\"password\");\n+        @Nullable\n+        String country = (String) properties.get(\"country\");\n+        scheduler.schedule(() -> cloudConnector.setCredentials(username, password, country), 0, TimeUnit.SECONDS);", "originalCommit": "83ebc3dcf72e47036e7e79ebf136a04ed11ebe72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYxMDkwNg==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402610906", "bodyText": "I did not know this one yet. Thx!", "author": "marcelrv", "createdAt": "2020-04-02T21:37:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ0Nzc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1MzM4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402453384", "bodyText": "remove", "author": "cpmeister", "createdAt": "2020-04-02T16:38:23Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/MiCloudConnector.java", "diffHunk": "@@ -0,0 +1,433 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.io.IOException;\n+import java.net.CookieStore;\n+import java.net.HttpCookie;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpResponseException;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.FormContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.util.Fields;\n+import org.openhab.binding.miio.internal.MiIoCrypto;\n+import org.openhab.binding.miio.internal.MiIoCryptoException;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MiCloudConnector} class is used for connecting to the Xiaomi cloud access\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MiCloudConnector {\n+\n+    private static final int REQUEST_TIMEOUT_SECONDS = 10;\n+    private static final String UNEXPECTED = \"Unexpected :\";\n+    private static final String AGENT_ID = (new Random().ints(65, 70).limit(13)\n+            .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    private static final String USERAGENT = \"Android-7.1.1-1.0.0-ONEPLUS A3010-136-\" + AGENT_ID\n+            + \" APP/xiaomi.smarthome APPV/62830\";\n+    private static Locale locale = Locale.getDefault();\n+    private final JsonParser parser = new JsonParser();\n+    private final String clientId;\n+\n+    private String username;\n+    private String password;\n+    private String userId = \"\";\n+    private String serviceToken = \"\";\n+    private String ssecurity = \"\";\n+    private int loginFailedCounter = 0;\n+    private HttpClient httpClient;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MiCloudConnector.class);\n+\n+    public MiCloudConnector(String username, String password, HttpClient httpClient) throws MiCloudException {\n+        this.username = username;\n+        this.password = password;\n+        this.httpClient = httpClient;\n+        if (!checkCredentials()) {\n+            throw new MiCloudException(\"username or password can't be empty\");\n+        }\n+        clientId = (new Random().ints(97, 122 + 1).limit(6)\n+                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    }\n+\n+    void startClient() throws MiCloudException {\n+        if (!httpClient.isStarted()) {\n+            try {\n+                httpClient.start();\n+                // set default cookies\n+                CookieStore cookieStore = httpClient.getCookieStore();\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"mi.com\");\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"xiaomi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"mi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"xiaomi.com\");\n+            } catch (Exception e) {\n+                throw new MiCloudException(\"No http client cannot be started: \" + e.getMessage(), e);\n+            }\n+        }\n+    }\n+\n+    public void stopClient() {\n+        try {\n+            this.httpClient.stop();\n+        } catch (Exception e) {\n+            logger.debug(\"Error stopping httpclient :{}\", e.getMessage(), e);\n+        }\n+    }\n+\n+    private boolean checkCredentials() {\n+        if (username.trim().isEmpty() || password.trim().isEmpty()) {\n+            logger.info(\"Xiaomi Cloud: username or password missing.\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private String getApiUrl(String country) {\n+        return \"https://\" + (country.trim().equalsIgnoreCase(\"cn\") ? \"\" : country.trim().toLowerCase() + \".\")\n+                + \"api.io.mi.com/app\";\n+    }\n+\n+    public String getClientId() {\n+        return clientId;\n+    }\n+\n+    String parseJson(String data) {\n+        if (data.contains(\"&&&START&&&\")) {\n+            return data.replace(\"&&&START&&&\", \"\");\n+        } else {\n+            return UNEXPECTED.concat(data);\n+        }\n+    }\n+\n+    public String getMapUrl(String vacuumMap, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/getmapfileurl\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"obj_name\\\":\\\"\" + vacuumMap + \"\\\"}\");\n+        String mapResponse = request(url, map);\n+        logger.trace(\"response: {}\", mapResponse);\n+        String errorMsg = \"\";\n+        JsonElement response = parser.parse(mapResponse);\n+        if (response.isJsonObject()) {\n+            logger.debug(\"Received  JSON message {}\", response.toString());\n+            if (response.getAsJsonObject().has(\"result\") && response.getAsJsonObject().get(\"result\").isJsonObject()) {\n+                JsonObject jo = response.getAsJsonObject().get(\"result\").getAsJsonObject();\n+                if (jo.has(\"url\")) {\n+                    return jo.get(\"url\").getAsString();\n+                } else {\n+                    errorMsg = \"Could not get url\";\n+                }\n+            } else {\n+                errorMsg = \"Could not get result\";\n+            }\n+        } else {\n+            errorMsg = \"Received message is invalid JSON\";\n+        }\n+        logger.debug(\"{}: {}\", errorMsg, mapResponse);\n+        return \"\";\n+    }\n+\n+    public String getDeviceStatus(String device, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"dids\\\":[\\\"\" + device + \"\\\"]}\");\n+        final String response = request(url, map);\n+        logger.debug(\"response: {}\", response);\n+        return response;\n+    }\n+\n+    public String getDevices(String country) {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"getVirtualModel\\\":false,\\\"getHuamiDevices\\\":0}\");\n+        String resp;\n+        try {\n+            resp = request(url, map);\n+            logger.trace(\"Get devices response: {}\", resp);\n+            CloudUtil.printDevices(resp, country, logger);\n+            if (resp.length() > 2) {\n+                CloudUtil.saveFile(resp, country, logger);\n+                return resp;\n+            }\n+        } catch (MiCloudException e) {\n+            logger.info(\"{}\", e.getMessage());\n+        }\n+        return \"\";\n+    }\n+\n+    public String request(String urlPart, String country, Map<String, String> params) throws MiCloudException {\n+        String url = getApiUrl(country) + urlPart;\n+        String response = request(url, params);\n+        logger.debug(\"Request to {} server {}. Response: {}\", country, urlPart, response);\n+        return response;\n+    }\n+\n+    public String request(String url, Map<String, String> params) throws MiCloudException {\n+        if (this.serviceToken.isEmpty() || this.userId.isEmpty()) {\n+            throw new MiCloudException(\"Cannot execute request. service token or userId missing\");\n+        }\n+        startClient();\n+        logger.debug(\"Send request: {} to {}\", params.get(\"data\"), url);\n+        Request request = httpClient.newRequest(url).timeout(REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        request.agent(USERAGENT);\n+        request.header(\"x-xiaomi-protocal-flag-cli\", \"PROTOCAL-HTTP2\");\n+        request.header(HttpHeader.CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n+        request.cookie(new HttpCookie(\"userId\", this.userId));\n+        request.cookie(new HttpCookie(\"yetAnotherServiceToken\", this.serviceToken));\n+        request.cookie(new HttpCookie(\"serviceToken\", this.serviceToken));\n+        request.cookie(new HttpCookie(\"locale\", locale.toString()));\n+        request.cookie(new HttpCookie(\"timezone\", \"GMT%2B01%3A00\"));\n+        request.cookie(new HttpCookie(\"is_daylight\", \"1\"));\n+        request.cookie(new HttpCookie(\"dst_offset\", \"3600000\"));\n+        request.cookie(new HttpCookie(\"channel\", \"MI_APP_STORE\"));\n+\n+        for (HttpCookie cookie : request.getCookies()) {\n+            logger.trace(\"Cookie set for request ({}) : {} --> {}     (path: {})\", cookie.getDomain(), cookie.getName(),\n+                    cookie.getValue(), cookie.getPath());\n+        }\n+        String method = \"POST\";\n+        request.method(method);\n+\n+        try {\n+            String nonce = CloudUtil.generateNonce(System.currentTimeMillis());\n+            String signedNonce = CloudUtil.signedNonce(ssecurity, nonce);\n+            String signature = CloudUtil.generateSignature(url.replace(\"/app\", \"\"), signedNonce, nonce, params);\n+\n+            Fields fields = new Fields();\n+            fields.put(\"signature\", signature);\n+            fields.put(\"_nonce\", nonce);\n+            fields.put(\"data\", params.get(\"data\"));\n+            request.content(new FormContentProvider(fields));\n+\n+            logger.trace(\"fieldcontent: {}\", fields.toString());\n+            final ContentResponse response = request.send();\n+            return response.getContentAsString();\n+        } catch (HttpResponseException e) {\n+            serviceToken = \"\";\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (InterruptedException | TimeoutException | ExecutionException | IOException e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (MiIoCryptoException e) {\n+            logger.debug(\"Error while decrypting response of request to {} :{}\", url, e.getMessage(), e);\n+        }\n+        return \"\";\n+    }\n+\n+    private void addCookie(CookieStore cookieStore, String name, String value, String domain) {\n+        HttpCookie cookie = new HttpCookie(name, value);\n+        cookie.setDomain(\".\" + domain);\n+        cookie.setPath(\"/\");\n+        cookieStore.add(URI.create(\"https://\" + domain), cookie);\n+    }\n+\n+    public synchronized boolean login() {\n+        if (!checkCredentials()) {\n+            return false;\n+        }\n+        if (!userId.isEmpty() && !serviceToken.isEmpty()) {\n+            return true;\n+        }\n+        logger.debug(\"Xiaomi cloud login with userid {}\", username);\n+        try {\n+            if (loginRequest()) {\n+                loginFailedCounter = 0;\n+            } else {\n+                loginFailedCounter++;\n+                logger.debug(\"Xiaomi cloud login attempt {}\", loginFailedCounter);\n+            }\n+        } catch (MiCloudException e) {\n+            logger.info(\"Error logging on to Xiaomi cloud ({}): {}\", loginFailedCounter, e.getMessage());\n+            loginFailedCounter++;\n+            serviceToken = \"\";\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    protected boolean loginRequest() throws MiCloudException {\n+        try {\n+            startClient();\n+            String sign = loginStep1();\n+            String location = loginStep2(sign);\n+            final ContentResponse responseStep3 = loginStep3(location);\n+\n+            switch (responseStep3.getStatus()) {\n+                case HttpStatus.FORBIDDEN_403:\n+                    throw new MiCloudException(\"Access denied. Did you set the correct api-key and/or username?\");\n+                case HttpStatus.OK_200:\n+                    return true;\n+                default:\n+                    logger.trace(\"request returned status '{}', reason: {}, content = {}\", responseStep3.getStatus(),\n+                            responseStep3.getReason(), responseStep3.getContentAsString());\n+                    throw new MiCloudException(responseStep3.getStatus() + responseStep3.getReason());\n+            }\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new MiCloudException(\"Cannot logon to Xiaomi cloud: \" + e.getMessage(), e);\n+        } catch (MiIoCryptoException e) {\n+            throw new MiCloudException(\"Error decrypting. Cannot logon to Xiaomi cloud: \" + e.getMessage(), e);\n+        } catch (MalformedURLException e) {\n+            throw new MiCloudException(\"Error getting logon URL. Cannot logon to Xiaomi cloud: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    private String loginStep1() throws InterruptedException, TimeoutException, ExecutionException, MiCloudException {\n+        final ContentResponse responseStep1;\n+\n+        logger.trace(\"Xiaomi Login step 1\");\n+        String url = \"https://account.xiaomi.com/pass/serviceLogin?sid=xiaomiio&_json=true\";\n+        Request request = httpClient.newRequest(url).timeout(REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        request.agent(USERAGENT);\n+        request.header(HttpHeader.CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n+        request.cookie(new HttpCookie(\"userId\", this.userId.length() > 0 ? this.userId : this.username));\n+\n+        responseStep1 = request.send();\n+        final String content = responseStep1.getContentAsString();\n+        logger.trace(\"Xiaomi Login step 1 content response= {}\", content);\n+        logger.trace(\"Xiaomi Login step 1 response = {}\", responseStep1);\n+        try {\n+            JsonElement resp = new JsonParser().parse(parseJson(content));\n+            String sign = resp.getAsJsonObject().get(\"_sign\").getAsString();\n+            logger.trace(\"Xiaomi Login step 1 sign = {}\", sign);\n+            return sign;\n+        } catch (JsonSyntaxException | NullPointerException e) {\n+            throw new MiCloudException(\"Error getting logon sign. Cannot parse response: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    private String loginStep2(String sign)\n+            throws MiIoCryptoException, InterruptedException, TimeoutException, ExecutionException, MiCloudException {\n+        String passToken;\n+        String cUserId;\n+\n+        logger.trace(\"Xiaomi Login step 2\");\n+        String url = \"https://account.xiaomi.com/pass/serviceLoginAuth2\";\n+        Request request = httpClient.newRequest(url).timeout(REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        request.agent(USERAGENT);\n+        request.method(HttpMethod.POST);\n+        final ContentResponse responseStep2;\n+\n+        Fields fields = new Fields();\n+        fields.put(\"sid\", \"xiaomiio\");\n+        // fields.put(\"hash\", encodePassword(password));", "originalCommit": "83ebc3dcf72e47036e7e79ebf136a04ed11ebe72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1NDY4MA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402454680", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    scheduler.schedule(() -> updateState(CHANNEL_VACUUM_MAP, getMap(mapresponse)), 0,\n          \n          \n            \n                                            TimeUnit.MILLISECONDS);\n          \n          \n            \n                                    scheduler.submit(() -> updateState(CHANNEL_VACUUM_MAP, getMap(mapresponse)));", "author": "cpmeister", "createdAt": "2020-04-02T16:40:28Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/handler/MiIoVacuumHandler.java", "diffHunk": "@@ -395,11 +440,58 @@ public void onMessageReceived(MiIoSendCommand response) {\n                     logger.debug(\"Could not extract cleaning history record from: {}\", response);\n                 }\n                 break;\n+            case GET_MAP:\n+                if (response.getResult().isJsonArray()) {\n+                    String mapresponse = response.getResult().getAsJsonArray().get(0).getAsString();\n+                    if (!mapresponse.contentEquals(\"retry\") && !mapresponse.contentEquals(lastMap)) {\n+                        lastMap = mapresponse;\n+                        scheduler.schedule(() -> updateState(CHANNEL_VACUUM_MAP, getMap(mapresponse)), 0,\n+                                TimeUnit.MILLISECONDS);", "originalCommit": "83ebc3dcf72e47036e7e79ebf136a04ed11ebe72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1NTI5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402455296", "bodyText": "SimpleDateFormat instance should be static to allow for reuse.", "author": "cpmeister", "createdAt": "2020-04-02T16:41:22Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/handler/MiIoVacuumHandler.java", "diffHunk": "@@ -395,11 +440,58 @@ public void onMessageReceived(MiIoSendCommand response) {\n                     logger.debug(\"Could not extract cleaning history record from: {}\", response);\n                 }\n                 break;\n+            case GET_MAP:\n+                if (response.getResult().isJsonArray()) {\n+                    String mapresponse = response.getResult().getAsJsonArray().get(0).getAsString();\n+                    if (!mapresponse.contentEquals(\"retry\") && !mapresponse.contentEquals(lastMap)) {\n+                        lastMap = mapresponse;\n+                        scheduler.schedule(() -> updateState(CHANNEL_VACUUM_MAP, getMap(mapresponse)), 0,\n+                                TimeUnit.MILLISECONDS);\n+                    }\n+                }\n+                break;\n             case UNKNOWN:\n                 updateState(CHANNEL_COMMAND, new StringType(response.getResponse().toString()));\n                 break;\n             default:\n                 break;\n         }\n     }\n+\n+    private State getMap(String map) {\n+        final MiIoBindingConfiguration configuration = getConfigAs(MiIoBindingConfiguration.class);\n+        if (cloudConnector.isConnected()) {\n+            try {\n+                final @Nullable RawType mapDl = cloudConnector.getMap(map,\n+                        (configuration.cloudServer != null) ? configuration.cloudServer : \"\");\n+                if (mapDl != null) {\n+                    byte[] mapData = mapDl.getBytes();\n+                    RRMapDraw rrMap = RRMapDraw.loadImage(new ByteArrayInputStream(mapData));\n+                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+                    if (logger.isDebugEnabled()) {\n+                        String fn = ConfigConstants.getUserDataFolder() + File.separator + BINDING_ID + File.separator\n+                                + map;\n+                        CloudUtil.writeBytesToFileNio(mapData,\n+                                fn + (new SimpleDateFormat(\"yyyyMMdd-HHss\")).format(new Date()) + \".rrmap\");", "originalCommit": "83ebc3dcf72e47036e7e79ebf136a04ed11ebe72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1Njc0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402456745", "bodyText": "Why not save the configuration as a local field during initialization so that you don't need to recreated it every time this method is called?", "author": "cpmeister", "createdAt": "2020-04-02T16:43:35Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/handler/MiIoVacuumHandler.java", "diffHunk": "@@ -395,11 +440,58 @@ public void onMessageReceived(MiIoSendCommand response) {\n                     logger.debug(\"Could not extract cleaning history record from: {}\", response);\n                 }\n                 break;\n+            case GET_MAP:\n+                if (response.getResult().isJsonArray()) {\n+                    String mapresponse = response.getResult().getAsJsonArray().get(0).getAsString();\n+                    if (!mapresponse.contentEquals(\"retry\") && !mapresponse.contentEquals(lastMap)) {\n+                        lastMap = mapresponse;\n+                        scheduler.schedule(() -> updateState(CHANNEL_VACUUM_MAP, getMap(mapresponse)), 0,\n+                                TimeUnit.MILLISECONDS);\n+                    }\n+                }\n+                break;\n             case UNKNOWN:\n                 updateState(CHANNEL_COMMAND, new StringType(response.getResponse().toString()));\n                 break;\n             default:\n                 break;\n         }\n     }\n+\n+    private State getMap(String map) {\n+        final MiIoBindingConfiguration configuration = getConfigAs(MiIoBindingConfiguration.class);", "originalCommit": "83ebc3dcf72e47036e7e79ebf136a04ed11ebe72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUzMjgyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402532825", "bodyText": "Because of this comment :-)\n#7222 (comment)\nOr did I understand it wronly at that time", "author": "marcelrv", "createdAt": "2020-04-02T18:42:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1Njc0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUzNzg2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402537868", "bodyText": "well, by \"initialization\" I'm talking about getting and saving the configuration object from inside the initialize() method. That is the standard design pattern for bindings.", "author": "cpmeister", "createdAt": "2020-04-02T18:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1Njc0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYwMDg0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402600846", "bodyText": "got it... indeed I misunderstood it. Added it now to the initialize() in MiIoAbstractHandler", "author": "marcelrv", "createdAt": "2020-04-02T21:16:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1Njc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1OTMxMA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402459310", "bodyText": "why not make ConfigConstants.getUserDataFolder() + File.separator + BINDING_ID + File.separator a constant?", "author": "cpmeister", "createdAt": "2020-04-02T16:47:25Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/handler/MiIoVacuumHandler.java", "diffHunk": "@@ -395,11 +440,58 @@ public void onMessageReceived(MiIoSendCommand response) {\n                     logger.debug(\"Could not extract cleaning history record from: {}\", response);\n                 }\n                 break;\n+            case GET_MAP:\n+                if (response.getResult().isJsonArray()) {\n+                    String mapresponse = response.getResult().getAsJsonArray().get(0).getAsString();\n+                    if (!mapresponse.contentEquals(\"retry\") && !mapresponse.contentEquals(lastMap)) {\n+                        lastMap = mapresponse;\n+                        scheduler.schedule(() -> updateState(CHANNEL_VACUUM_MAP, getMap(mapresponse)), 0,\n+                                TimeUnit.MILLISECONDS);\n+                    }\n+                }\n+                break;\n             case UNKNOWN:\n                 updateState(CHANNEL_COMMAND, new StringType(response.getResponse().toString()));\n                 break;\n             default:\n                 break;\n         }\n     }\n+\n+    private State getMap(String map) {\n+        final MiIoBindingConfiguration configuration = getConfigAs(MiIoBindingConfiguration.class);\n+        if (cloudConnector.isConnected()) {\n+            try {\n+                final @Nullable RawType mapDl = cloudConnector.getMap(map,\n+                        (configuration.cloudServer != null) ? configuration.cloudServer : \"\");\n+                if (mapDl != null) {\n+                    byte[] mapData = mapDl.getBytes();\n+                    RRMapDraw rrMap = RRMapDraw.loadImage(new ByteArrayInputStream(mapData));\n+                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+                    if (logger.isDebugEnabled()) {\n+                        String fn = ConfigConstants.getUserDataFolder() + File.separator + BINDING_ID + File.separator", "originalCommit": "83ebc3dcf72e47036e7e79ebf136a04ed11ebe72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ2NTc1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402465752", "bodyText": "This code is fragile with regards to tokenText. If your original tokenText is too small everything breaks.", "author": "cpmeister", "createdAt": "2020-04-02T16:57:14Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/transport/MiIoAsyncCommunication.java", "diffHunk": "@@ -146,8 +146,12 @@ public int queueCommand(String command, String params)\n             MiIoSendCommand sendCmd = new MiIoSendCommand(cmdId, MiIoCommand.getCommand(command),\n                     fullCommand.toString());\n             concurrentLinkedQueue.add(sendCmd);\n+            String tokenText = Utils.getHex(token); // Obfuscate part of the token to allow sharing of the logfiles\n+            tokenText = tokenText.substring(0, 8)\n+                    .concat((tokenText.length() > 8) ? tokenText.substring(8, 24).replaceAll(\".\", \"X\") : \"\")\n+                    .concat((tokenText.length() > 24) ? tokenText.substring(24) : \"\");", "originalCommit": "83ebc3dcf72e47036e7e79ebf136a04ed11ebe72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYwNTc5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402605792", "bodyText": "It should not be smaller than 16 chars because of     private boolean tokenCheckPass(String tokenSting) in the initialize, but I'll change it so it won't fail on <8 len", "author": "marcelrv", "createdAt": "2020-04-02T21:26:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ2NTc1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ2Nzg3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402467873", "bodyText": "Instead of a StringBuilder, perhaps it would be better to use a StringWriter wrapped in a PrintWriter. That way you could use println and printf which would really make this code more readable and performant.\nThen again this code isn't all that critical so I'm ok with you not changing it if it is too much work.", "author": "cpmeister", "createdAt": "2020-04-02T17:00:24Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/robot/RRMapFileParser.java", "diffHunk": "@@ -0,0 +1,417 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.robot;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RRMapFileParser} is used to parse the RR map file format created by Xiaomi / RockRobo vacuum\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RRMapFileParser {\n+    public static final int CHARGER = 1;\n+    public static final int IMAGE = 2;\n+    public static final int PATH = 3;\n+    public static final int GOTO_PATH = 4;\n+    public static final int GOTO_PREDICTED_PATH = 5;\n+    public static final int CURRENTLY_CLEANED_ZONES = 6;\n+    public static final int GOTO_TARGET = 7;\n+    public static final int ROBOT_POSITION = 8;\n+    public static final int NO_GO_AREAS = 9;\n+    public static final int VIRTUAL_WALLS = 10;\n+    public static final int BLOCKS = 11;\n+    public static final int MFBZS_AREA = 12;\n+    public static final int OBSTACLES = 13;\n+    public static final int DIGEST = 1024;\n+    public static final int HEADER = 0x7272;\n+\n+    public static final String PATH_POINT_LENGTH = \"pointLength\";\n+    public static final String PATH_POINT_SIZE = \"pointSize\";\n+    public static final String PATH_ANGLE = \"angle\";\n+\n+    private static final float MM = 50.0f;\n+\n+    private byte[] image = new byte[] { 0 };\n+    private final int majorVersion;\n+    private final int minorVersion;\n+    private final int mapIndex;\n+    private final int mapSequence;\n+    private boolean isValid;\n+\n+    private int imgHeight;\n+    private int imgWidth;\n+    private int imageSize;\n+    private int top;\n+    private int left;\n+    private int offset;\n+\n+    private int chargerX;\n+    private int chargerY;\n+    private int roboX;\n+    private int roboY;\n+    private int roboA;\n+    private float gotoX = 0;\n+    private float gotoY = 0;\n+    private Map<Integer, ArrayList<float[]>> paths = new HashMap<>();\n+    private Map<Integer, Map<String, Integer>> pathsDetails = new HashMap<>();\n+    private Map<Integer, ArrayList<float[]>> areas = new HashMap<>();\n+    private ArrayList<float[]> walls = new ArrayList<>();\n+    private ArrayList<float[]> zones = new ArrayList<>();\n+    private ArrayList<int[]> obstacles = new ArrayList<>();\n+    private byte[] blocks = new byte[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(RRMapFileParser.class);\n+\n+    public RRMapFileParser(byte[] raw) {\n+        boolean printBlockDetails = false;\n+\n+        int mapHeaderLength = getUInt16(raw, 0x02);\n+        int mapDataLength = getUInt32LE(raw, 0x04);\n+\n+        this.majorVersion = getUInt16(raw, 0x08);\n+        this.minorVersion = getUInt16(raw, 0x0A);\n+        this.mapIndex = getUInt32LE(raw, 0x0C);\n+        this.mapSequence = getUInt32LE(raw, 0x10);\n+\n+        int blockStartPos = getUInt16(raw, 0x02); // main header length\n+        while (blockStartPos < raw.length) {\n+            int blockHeaderLength = getUInt16(raw, blockStartPos + 0x02);\n+            byte[] header = getBytes(raw, blockStartPos, blockHeaderLength);\n+            int blocktype = getUInt16(header, 0x00);\n+            int blockDataLength = getUInt32LE(header, 0x04);\n+            int blockDataStart = blockStartPos + blockHeaderLength;\n+            byte[] data = getBytes(raw, blockDataStart, blockDataLength);\n+\n+            switch (blocktype) {\n+                case CHARGER:\n+                    this.chargerX = getUInt32LE(raw, blockStartPos + 0x08);\n+                    this.chargerY = getUInt32LE(raw, blockStartPos + 0x0C);\n+                    break;\n+                case IMAGE:\n+                    this.imageSize = blockDataLength;// (getUInt32LE(raw, blockStartPos + 0x04));\n+                    if (blockHeaderLength > 0x1C) {\n+                        logger.debug(\"block 2 unknown value @pos 8: {}\", getUInt32LE(header, 0x08));\n+                    }\n+                    this.top = getUInt32LE(header, blockHeaderLength - 16);\n+                    this.left = getUInt32LE(header, blockHeaderLength - 12);\n+                    this.imgHeight = (getUInt32LE(header, blockHeaderLength - 8));\n+                    this.imgWidth = getUInt32LE(header, blockHeaderLength - 4);\n+                    this.offset = imgWidth + left;\n+                    this.image = data;\n+                    break;\n+                case ROBOT_POSITION:\n+                    this.roboX = getUInt32LE(data, 0x00);\n+                    this.roboY = getUInt32LE(data, 0x04);\n+                    if (blockDataLength > 8) { // model S6\n+                        this.roboA = getUInt32LE(data, 0x08);\n+                    }\n+                    break;\n+                case PATH:\n+                case GOTO_PATH:\n+                case GOTO_PREDICTED_PATH:\n+                    ArrayList<float[]> path = new ArrayList<float[]>();\n+                    Map<String, Integer> detail = new HashMap<String, Integer>();\n+                    int pairs = getUInt32LE(header, 0x04) / 4;\n+                    detail.put(PATH_POINT_LENGTH, getUInt32LE(header, 0x08));\n+                    detail.put(PATH_POINT_SIZE, getUInt32LE(header, 0x0C));\n+                    detail.put(PATH_ANGLE, getUInt32LE(header, 0x10));\n+                    for (int pathpair = 0; pathpair < pairs; pathpair++) {\n+                        float x = offset - (getUInt16(getBytes(raw, blockDataStart + pathpair * 4, 2))) / MM;\n+                        float y = getUInt16(getBytes(raw, blockDataStart + pathpair * 4 + 2, 2)) / MM - top;\n+                        path.add(new float[] { x, y });\n+                    }\n+                    paths.put(blocktype, path);\n+                    pathsDetails.put(blocktype, detail);\n+                    break;\n+                case CURRENTLY_CLEANED_ZONES:\n+                    int zonePairs = getUInt16(header, 0x08);\n+                    for (int zonePair = 0; zonePair < zonePairs; zonePair++) {\n+                        float x0 = offset - (getUInt16(raw, blockDataStart + zonePair * 8)) / MM;\n+                        float y0 = getUInt16(raw, blockDataStart + zonePair * 8 + 2) / MM - top;\n+                        float x1 = offset - (getUInt16(raw, blockDataStart + zonePair * 8 + 4)) / MM;\n+                        float y1 = getUInt16(raw, blockDataStart + zonePair * 8 + 6) / MM - top;\n+                        zones.add(new float[] { x0, y0, x1, y1 });\n+                    }\n+                    break;\n+                case GOTO_TARGET:\n+                    this.gotoX = offset - getUInt16(data, 0x00) / MM;\n+                    this.gotoY = getUInt16(data, 0x02) / MM - top;\n+                    break;\n+                case DIGEST:\n+                    isValid = Arrays.equals(data, sha1Hash(getBytes(raw, 0, mapHeaderLength + mapDataLength - 20)));\n+                    break;\n+                case VIRTUAL_WALLS:\n+                    int wallPairs = getUInt16(header, 0x08);\n+                    for (int wallPair = 0; wallPair < wallPairs; wallPair++) {\n+                        float x0 = offset - (getUInt16(raw, blockDataStart + wallPair * 8)) / MM;\n+                        float y0 = getUInt16(raw, blockDataStart + wallPair * 8 + 2) / MM - top;\n+                        float x1 = offset - (getUInt16(raw, blockDataStart + wallPair * 8 + 4)) / MM;\n+                        float y1 = getUInt16(raw, blockDataStart + wallPair * 8 + 6) / MM - top;\n+                        walls.add(new float[] { x0, y0, x1, y1 });\n+                    }\n+                    break;\n+                case NO_GO_AREAS:\n+                case MFBZS_AREA:\n+                    int areaPairs = getUInt16(header, 0x08);\n+                    ArrayList<float[]> area = new ArrayList<float[]>();\n+                    for (int areaPair = 0; areaPair < areaPairs; areaPair++) {\n+                        float x0 = offset - (getUInt16(raw, blockDataStart + areaPair * 16)) / MM;\n+                        float y0 = getUInt16(raw, blockDataStart + areaPair * 16 + 2) / MM - top;\n+                        float x1 = offset - (getUInt16(raw, blockDataStart + areaPair * 16 + 4)) / MM;\n+                        float y1 = getUInt16(raw, blockDataStart + areaPair * 16 + 6) / MM - top;\n+                        float x2 = offset - (getUInt16(raw, blockDataStart + areaPair * 16 + 8)) / MM;\n+                        float y2 = getUInt16(raw, blockDataStart + areaPair * 16 + 10) / MM - top;\n+                        float x3 = offset - (getUInt16(raw, blockDataStart + areaPair * 16 + 12)) / MM;\n+                        float y3 = getUInt16(raw, blockDataStart + areaPair * 16 + 14) / MM - top;\n+                        area.add(new float[] { x0, y0, x1, y1, x2, y2, x3, y3 });\n+                    }\n+                    areas.put(Integer.valueOf(blocktype & 0xFF), area);\n+                    break;\n+                case OBSTACLES:\n+                    int obstaclePairs = getUInt16(header, 0x08);\n+                    for (int obstaclePair = 0; obstaclePair < obstaclePairs; obstaclePair++) {\n+                        int x0 = getUInt16(data, obstaclePair * 5 + 0);\n+                        int y0 = getUInt16(data, obstaclePair * 5 + 2);\n+                        int u = data[obstaclePair * 5 + 0] & 0xFF;\n+                        obstacles.add(new int[] { x0, y0, u });\n+                    }\n+                    break;\n+                case BLOCKS:\n+                    int blocksPairs = getUInt16(header, 0x08);\n+                    blocks = getBytes(data, 0, blocksPairs);\n+                    break;\n+                default:\n+                    logger.info(\"Unknown blocktype (pls report to author)\");\n+                    printBlockDetails = true;\n+            }\n+            if (logger.isTraceEnabled() || printBlockDetails) {\n+                logger.debug(\"Blocktype: {}\", Integer.toString(blocktype));\n+                logger.debug(\"Header len: {}   data len: {} \", Integer.toString(blockHeaderLength),\n+                        Integer.toString(blockDataLength));\n+                logger.debug(\"H: {}\", Utils.getSpacedHex(header));\n+                if (blockDataLength > 0) {\n+                    logger.debug(\"D: {}\", (blockDataLength < 60 ? Utils.getSpacedHex(data)\n+                            : Utils.getSpacedHex(getBytes(data, 0, 60))));\n+                }\n+                printBlockDetails = false;\n+            }\n+            blockStartPos = blockStartPos + blockDataLength + (header[2] & 0xFF);\n+        }\n+    }\n+\n+    public static byte[] readRRMapFile(File file) throws IOException {\n+        return readRRMapFile(new FileInputStream(file));\n+    }\n+\n+    public static byte[] readRRMapFile(InputStream is) throws IOException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (GZIPInputStream in = new GZIPInputStream(is)) {\n+            int bufsize = 1024;\n+            byte[] buf = new byte[bufsize];\n+            int readbytes = 0;\n+            readbytes = in.read(buf);\n+            while (readbytes != -1) {\n+                baos.write(buf, 0, readbytes);\n+                readbytes = in.read(buf);\n+            }\n+            baos.flush();\n+            return baos.toByteArray();\n+        }\n+    }\n+\n+    private byte[] getBytes(byte[] raw, int pos, int len) {\n+        return java.util.Arrays.copyOfRange(raw, pos, pos + len);\n+    }\n+\n+    private int getUInt32LE(byte[] bytes, int pos) {\n+        int value = bytes[0 + pos] & 0xFF;\n+        value |= (bytes[1 + pos] << 8) & 0xFFFF;\n+        value |= (bytes[2 + pos] << 16) & 0xFFFFFF;\n+        value |= (bytes[3 + pos] << 24) & 0xFFFFFFFF;\n+        return value;\n+    }\n+\n+    private int getUInt16(byte[] bytes) {\n+        return getUInt16(bytes, 0);\n+    }\n+\n+    private int getUInt16(byte[] bytes, int pos) {\n+        int value = bytes[0 + pos] & 0xFF;\n+        value |= (bytes[1 + pos] << 8) & 0xFFFF;\n+        return value;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();", "originalCommit": "83ebc3dcf72e47036e7e79ebf136a04ed11ebe72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY0OTE1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402649152", "bodyText": "Done... I was searching for how to do it before but couldn't find it.", "author": "marcelrv", "createdAt": "2020-04-02T23:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ2Nzg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ4OTEyMg==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402489122", "bodyText": "This could refactored into a reusable method:\nprivate float[] readUInt16Block(byte[] raw, int blockStart, int blockSize){\n  float[] ret = new float[blockSize];\n  for(int i = 0; i < blockSize; i++){\n    if(i % 2 == 0){\n      ret[i] = offset - getUInt16(raw, blockStart + i * 2) / MM;\n    }else{\n      ret[i] = getUInt16(raw, blockStart + i * 2) / MM - top;\n    }\n  }\n  return ret;\n}", "author": "cpmeister", "createdAt": "2020-04-02T17:32:51Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/robot/RRMapFileParser.java", "diffHunk": "@@ -0,0 +1,417 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.robot;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RRMapFileParser} is used to parse the RR map file format created by Xiaomi / RockRobo vacuum\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RRMapFileParser {\n+    public static final int CHARGER = 1;\n+    public static final int IMAGE = 2;\n+    public static final int PATH = 3;\n+    public static final int GOTO_PATH = 4;\n+    public static final int GOTO_PREDICTED_PATH = 5;\n+    public static final int CURRENTLY_CLEANED_ZONES = 6;\n+    public static final int GOTO_TARGET = 7;\n+    public static final int ROBOT_POSITION = 8;\n+    public static final int NO_GO_AREAS = 9;\n+    public static final int VIRTUAL_WALLS = 10;\n+    public static final int BLOCKS = 11;\n+    public static final int MFBZS_AREA = 12;\n+    public static final int OBSTACLES = 13;\n+    public static final int DIGEST = 1024;\n+    public static final int HEADER = 0x7272;\n+\n+    public static final String PATH_POINT_LENGTH = \"pointLength\";\n+    public static final String PATH_POINT_SIZE = \"pointSize\";\n+    public static final String PATH_ANGLE = \"angle\";\n+\n+    private static final float MM = 50.0f;\n+\n+    private byte[] image = new byte[] { 0 };\n+    private final int majorVersion;\n+    private final int minorVersion;\n+    private final int mapIndex;\n+    private final int mapSequence;\n+    private boolean isValid;\n+\n+    private int imgHeight;\n+    private int imgWidth;\n+    private int imageSize;\n+    private int top;\n+    private int left;\n+    private int offset;\n+\n+    private int chargerX;\n+    private int chargerY;\n+    private int roboX;\n+    private int roboY;\n+    private int roboA;\n+    private float gotoX = 0;\n+    private float gotoY = 0;\n+    private Map<Integer, ArrayList<float[]>> paths = new HashMap<>();\n+    private Map<Integer, Map<String, Integer>> pathsDetails = new HashMap<>();\n+    private Map<Integer, ArrayList<float[]>> areas = new HashMap<>();\n+    private ArrayList<float[]> walls = new ArrayList<>();\n+    private ArrayList<float[]> zones = new ArrayList<>();\n+    private ArrayList<int[]> obstacles = new ArrayList<>();\n+    private byte[] blocks = new byte[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(RRMapFileParser.class);\n+\n+    public RRMapFileParser(byte[] raw) {\n+        boolean printBlockDetails = false;\n+\n+        int mapHeaderLength = getUInt16(raw, 0x02);\n+        int mapDataLength = getUInt32LE(raw, 0x04);\n+\n+        this.majorVersion = getUInt16(raw, 0x08);\n+        this.minorVersion = getUInt16(raw, 0x0A);\n+        this.mapIndex = getUInt32LE(raw, 0x0C);\n+        this.mapSequence = getUInt32LE(raw, 0x10);\n+\n+        int blockStartPos = getUInt16(raw, 0x02); // main header length\n+        while (blockStartPos < raw.length) {\n+            int blockHeaderLength = getUInt16(raw, blockStartPos + 0x02);\n+            byte[] header = getBytes(raw, blockStartPos, blockHeaderLength);\n+            int blocktype = getUInt16(header, 0x00);\n+            int blockDataLength = getUInt32LE(header, 0x04);\n+            int blockDataStart = blockStartPos + blockHeaderLength;\n+            byte[] data = getBytes(raw, blockDataStart, blockDataLength);\n+\n+            switch (blocktype) {\n+                case CHARGER:\n+                    this.chargerX = getUInt32LE(raw, blockStartPos + 0x08);\n+                    this.chargerY = getUInt32LE(raw, blockStartPos + 0x0C);\n+                    break;\n+                case IMAGE:\n+                    this.imageSize = blockDataLength;// (getUInt32LE(raw, blockStartPos + 0x04));\n+                    if (blockHeaderLength > 0x1C) {\n+                        logger.debug(\"block 2 unknown value @pos 8: {}\", getUInt32LE(header, 0x08));\n+                    }\n+                    this.top = getUInt32LE(header, blockHeaderLength - 16);\n+                    this.left = getUInt32LE(header, blockHeaderLength - 12);\n+                    this.imgHeight = (getUInt32LE(header, blockHeaderLength - 8));\n+                    this.imgWidth = getUInt32LE(header, blockHeaderLength - 4);\n+                    this.offset = imgWidth + left;\n+                    this.image = data;\n+                    break;\n+                case ROBOT_POSITION:\n+                    this.roboX = getUInt32LE(data, 0x00);\n+                    this.roboY = getUInt32LE(data, 0x04);\n+                    if (blockDataLength > 8) { // model S6\n+                        this.roboA = getUInt32LE(data, 0x08);\n+                    }\n+                    break;\n+                case PATH:\n+                case GOTO_PATH:\n+                case GOTO_PREDICTED_PATH:\n+                    ArrayList<float[]> path = new ArrayList<float[]>();\n+                    Map<String, Integer> detail = new HashMap<String, Integer>();\n+                    int pairs = getUInt32LE(header, 0x04) / 4;\n+                    detail.put(PATH_POINT_LENGTH, getUInt32LE(header, 0x08));\n+                    detail.put(PATH_POINT_SIZE, getUInt32LE(header, 0x0C));\n+                    detail.put(PATH_ANGLE, getUInt32LE(header, 0x10));\n+                    for (int pathpair = 0; pathpair < pairs; pathpair++) {\n+                        float x = offset - (getUInt16(getBytes(raw, blockDataStart + pathpair * 4, 2))) / MM;\n+                        float y = getUInt16(getBytes(raw, blockDataStart + pathpair * 4 + 2, 2)) / MM - top;\n+                        path.add(new float[] { x, y });\n+                    }\n+                    paths.put(blocktype, path);\n+                    pathsDetails.put(blocktype, detail);\n+                    break;\n+                case CURRENTLY_CLEANED_ZONES:\n+                    int zonePairs = getUInt16(header, 0x08);\n+                    for (int zonePair = 0; zonePair < zonePairs; zonePair++) {\n+                        float x0 = offset - (getUInt16(raw, blockDataStart + zonePair * 8)) / MM;\n+                        float y0 = getUInt16(raw, blockDataStart + zonePair * 8 + 2) / MM - top;\n+                        float x1 = offset - (getUInt16(raw, blockDataStart + zonePair * 8 + 4)) / MM;\n+                        float y1 = getUInt16(raw, blockDataStart + zonePair * 8 + 6) / MM - top;\n+                        zones.add(new float[] { x0, y0, x1, y1 });", "originalCommit": "83ebc3dcf72e47036e7e79ebf136a04ed11ebe72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3MDg3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r403770870", "bodyText": "yes, but as the format is not clear (it is reverse engineered) I like to keep it as descriptive as possible.", "author": "marcelrv", "createdAt": "2020-04-05T23:13:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ4OTEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3MjkzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r403772930", "bodyText": "descriptive is not an excuse for code duplication.\nAnd if by \"reverse-engineered\" you mean you decompiled the code from someplace, then it is even more reason to make sure it looks different!", "author": "cpmeister", "createdAt": "2020-04-05T23:31:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ4OTEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwMzE3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402503179", "bodyText": "It is possible to process the file as a stream or is there a bunch of random-access going on?", "author": "cpmeister", "createdAt": "2020-04-02T17:52:19Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/robot/RRMapFileParser.java", "diffHunk": "@@ -0,0 +1,417 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.robot;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.zip.GZIPInputStream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RRMapFileParser} is used to parse the RR map file format created by Xiaomi / RockRobo vacuum\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RRMapFileParser {\n+    public static final int CHARGER = 1;\n+    public static final int IMAGE = 2;\n+    public static final int PATH = 3;\n+    public static final int GOTO_PATH = 4;\n+    public static final int GOTO_PREDICTED_PATH = 5;\n+    public static final int CURRENTLY_CLEANED_ZONES = 6;\n+    public static final int GOTO_TARGET = 7;\n+    public static final int ROBOT_POSITION = 8;\n+    public static final int NO_GO_AREAS = 9;\n+    public static final int VIRTUAL_WALLS = 10;\n+    public static final int BLOCKS = 11;\n+    public static final int MFBZS_AREA = 12;\n+    public static final int OBSTACLES = 13;\n+    public static final int DIGEST = 1024;\n+    public static final int HEADER = 0x7272;\n+\n+    public static final String PATH_POINT_LENGTH = \"pointLength\";\n+    public static final String PATH_POINT_SIZE = \"pointSize\";\n+    public static final String PATH_ANGLE = \"angle\";\n+\n+    private static final float MM = 50.0f;\n+\n+    private byte[] image = new byte[] { 0 };\n+    private final int majorVersion;\n+    private final int minorVersion;\n+    private final int mapIndex;\n+    private final int mapSequence;\n+    private boolean isValid;\n+\n+    private int imgHeight;\n+    private int imgWidth;\n+    private int imageSize;\n+    private int top;\n+    private int left;\n+    private int offset;\n+\n+    private int chargerX;\n+    private int chargerY;\n+    private int roboX;\n+    private int roboY;\n+    private int roboA;\n+    private float gotoX = 0;\n+    private float gotoY = 0;\n+    private Map<Integer, ArrayList<float[]>> paths = new HashMap<>();\n+    private Map<Integer, Map<String, Integer>> pathsDetails = new HashMap<>();\n+    private Map<Integer, ArrayList<float[]>> areas = new HashMap<>();\n+    private ArrayList<float[]> walls = new ArrayList<>();\n+    private ArrayList<float[]> zones = new ArrayList<>();\n+    private ArrayList<int[]> obstacles = new ArrayList<>();\n+    private byte[] blocks = new byte[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(RRMapFileParser.class);\n+\n+    public RRMapFileParser(byte[] raw) {", "originalCommit": "83ebc3dcf72e47036e7e79ebf136a04ed11ebe72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3MTEwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r403771103", "bodyText": "I tried this but without success. I did not want to spend hours on it figuring out how to deal with the issues it created.", "author": "marcelrv", "createdAt": "2020-04-05T23:15:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwMzE3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3MzE1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r403773153", "bodyText": "understood", "author": "cpmeister", "createdAt": "2020-04-05T23:33:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwMzE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwNTEyMg==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402505122", "bodyText": "Can you make these constants so that the code is a bit easier to understand?", "author": "cpmeister", "createdAt": "2020-04-02T17:55:31Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/robot/RRMapDraw.java", "diffHunk": "@@ -0,0 +1,390 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.robot;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics2D;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Ellipse2D;\n+import java.awt.geom.Line2D;\n+import java.awt.geom.Path2D;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.image.AffineTransformOp;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+\n+import javax.imageio.ImageIO;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Draws the vacuum map file to an image\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RRMapDraw {\n+\n+    private static final Color COLOR_MAP_INSIDE = new Color(32, 115, 185);\n+    private static final Color COLOR_MAP_OUTSIDE = new Color(19, 87, 148);\n+    private static final Color COLOR_MAP_WALL = new Color(100, 196, 254);\n+    private static final Color COLOR_GREY_WALL = new Color(93, 109, 126);\n+    private static final Color COLOR_PATH = new Color(147, 194, 238);\n+    private static final Color COLOR_ZONES = new Color(0xAD, 0xD8, 0xFF, 0x8F);\n+    private static final Color COLOR_NO_GO_ZONES = new Color(255, 33, 55, 127);\n+    private static final Color COLOR_CHARGER_HALO = new Color(0x66, 0xfe, 0xda, 0x7f);\n+    private static final Color COLOR_ROBO = new Color(75, 235, 149);\n+    private static final Color COLOR_SCAN = new Color(0xDF, 0xDF, 0xDF);\n+    private static final Color ROOM1 = new Color(240, 178, 122);\n+    private static final Color ROOM2 = new Color(133, 193, 233);\n+    private static final Color ROOM3 = new Color(217, 136, 128);\n+    private static final Color ROOM4 = new Color(52, 152, 219);\n+    private static final Color ROOM5 = new Color(205, 97, 85);\n+    private static final Color ROOM6 = new Color(243, 156, 18);\n+    private static final Color ROOM7 = new Color(88, 214, 141);\n+    private static final Color ROOM8 = new Color(245, 176, 65);\n+    private static final Color ROOM9 = new Color(0xFc, 0xD4, 0x51);\n+    private static final Color ROOM10 = new Color(72, 201, 176);\n+    private static final Color ROOM11 = new Color(84, 153, 199);\n+    private static final Color ROOM12 = new Color(133, 193, 233);\n+    private static final Color ROOM13 = new Color(245, 176, 65);\n+    private static final Color ROOM14 = new Color(82, 190, 128);\n+    private static final Color ROOM15 = new Color(72, 201, 176);\n+    private static final Color ROOM16 = new Color(165, 105, 189);\n+    private static final Color[] ROOM_COLORS = { ROOM1, ROOM2, ROOM3, ROOM4, ROOM5, ROOM6, ROOM7, ROOM8, ROOM9, ROOM10,\n+            ROOM11, ROOM12, ROOM13, ROOM14, ROOM15, ROOM16 };\n+    private final @Nullable Bundle bundle = FrameworkUtil.getBundle(getClass());\n+    private boolean multicolor = false;\n+    private RRMapFileParser rmfp;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RRMapDraw.class);\n+\n+    public RRMapDraw(RRMapFileParser rmfp) {\n+        this.rmfp = rmfp;\n+    }\n+\n+    public void setRRFileDecoder(RRMapFileParser rmfp) {\n+        this.rmfp = rmfp;\n+    }\n+\n+    public int getWidth() {\n+        return rmfp.getImgWidth();\n+    }\n+\n+    public int getHeight() {\n+        return rmfp.getImgHeight();\n+    }\n+\n+    /**\n+     * load Gzipped RR inputstream\n+     *\n+     * @throws IOException\n+     */\n+    public static RRMapDraw loadImage(InputStream is) throws IOException {\n+        byte[] inputdata = RRMapFileParser.readRRMapFile(is);\n+        RRMapFileParser rf = new RRMapFileParser(inputdata);\n+        return new RRMapDraw(rf);\n+    }\n+\n+    /**\n+     * load Gzipped RR file\n+     *\n+     * @throws IOException\n+     */\n+    public static RRMapDraw loadImage(File file) throws IOException {\n+        return loadImage(new FileInputStream(file));\n+    }\n+\n+    /**\n+     * draws the map from the individual pixels\n+     */\n+    private void drawMap(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(1.1f * scale);\n+        g2d.setStroke(stroke);\n+        for (int y = 0; y < rmfp.getImgHeight() - 1; y++) {\n+            for (int x = 0; x < rmfp.getImgWidth() + 1; x++) {\n+                byte walltype = rmfp.getImage()[x + rmfp.getImgWidth() * y];\n+                switch (walltype & 0xFF) {\n+                    case 0x00:", "originalCommit": "83ebc3dcf72e47036e7e79ebf136a04ed11ebe72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwNTUzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402505535", "bodyText": "Can this be made final?", "author": "cpmeister", "createdAt": "2020-04-02T17:56:04Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/robot/RRMapDraw.java", "diffHunk": "@@ -0,0 +1,390 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.robot;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics2D;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Ellipse2D;\n+import java.awt.geom.Line2D;\n+import java.awt.geom.Path2D;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.image.AffineTransformOp;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+\n+import javax.imageio.ImageIO;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Draws the vacuum map file to an image\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RRMapDraw {\n+\n+    private static final Color COLOR_MAP_INSIDE = new Color(32, 115, 185);\n+    private static final Color COLOR_MAP_OUTSIDE = new Color(19, 87, 148);\n+    private static final Color COLOR_MAP_WALL = new Color(100, 196, 254);\n+    private static final Color COLOR_GREY_WALL = new Color(93, 109, 126);\n+    private static final Color COLOR_PATH = new Color(147, 194, 238);\n+    private static final Color COLOR_ZONES = new Color(0xAD, 0xD8, 0xFF, 0x8F);\n+    private static final Color COLOR_NO_GO_ZONES = new Color(255, 33, 55, 127);\n+    private static final Color COLOR_CHARGER_HALO = new Color(0x66, 0xfe, 0xda, 0x7f);\n+    private static final Color COLOR_ROBO = new Color(75, 235, 149);\n+    private static final Color COLOR_SCAN = new Color(0xDF, 0xDF, 0xDF);\n+    private static final Color ROOM1 = new Color(240, 178, 122);\n+    private static final Color ROOM2 = new Color(133, 193, 233);\n+    private static final Color ROOM3 = new Color(217, 136, 128);\n+    private static final Color ROOM4 = new Color(52, 152, 219);\n+    private static final Color ROOM5 = new Color(205, 97, 85);\n+    private static final Color ROOM6 = new Color(243, 156, 18);\n+    private static final Color ROOM7 = new Color(88, 214, 141);\n+    private static final Color ROOM8 = new Color(245, 176, 65);\n+    private static final Color ROOM9 = new Color(0xFc, 0xD4, 0x51);\n+    private static final Color ROOM10 = new Color(72, 201, 176);\n+    private static final Color ROOM11 = new Color(84, 153, 199);\n+    private static final Color ROOM12 = new Color(133, 193, 233);\n+    private static final Color ROOM13 = new Color(245, 176, 65);\n+    private static final Color ROOM14 = new Color(82, 190, 128);\n+    private static final Color ROOM15 = new Color(72, 201, 176);\n+    private static final Color ROOM16 = new Color(165, 105, 189);\n+    private static final Color[] ROOM_COLORS = { ROOM1, ROOM2, ROOM3, ROOM4, ROOM5, ROOM6, ROOM7, ROOM8, ROOM9, ROOM10,\n+            ROOM11, ROOM12, ROOM13, ROOM14, ROOM15, ROOM16 };\n+    private final @Nullable Bundle bundle = FrameworkUtil.getBundle(getClass());\n+    private boolean multicolor = false;\n+    private RRMapFileParser rmfp;", "originalCommit": "83ebc3dcf72e47036e7e79ebf136a04ed11ebe72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUxNTY1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402515655", "bodyText": "Since this method is only for logging purposes, there is no point in running it if nothing would get logged anyway.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    try {\n          \n          \n            \n                    if(!logger.isDebugEnabled()){\n          \n          \n            \n                        return;\n          \n          \n            \n                    }\n          \n          \n            \n                    try {", "author": "cpmeister", "createdAt": "2020-04-02T18:13:14Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/CloudUtil.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.openhab.binding.miio.internal.MiIoBindingConstants;\n+import org.openhab.binding.miio.internal.MiIoCryptoException;\n+import org.slf4j.Logger;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link CloudUtil} class is used for supporting functions for Xiaomi cloud access\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class CloudUtil {\n+\n+    private static final Random RANDOM = new Random();\n+\n+    public static String getElementString(JsonElement jsonElement, String element, Logger logger) {\n+        String value = \"\";\n+        try {\n+            value = jsonElement.getAsJsonObject().get(element).getAsString();\n+        } catch (IllegalStateException | ClassCastException e) {\n+            logger.debug(\"Json Element {} expected but missing\", element);\n+        }\n+        return value;\n+    }\n+\n+    public static void printDevices(String response, String country, Logger logger) {\n+        try {", "originalCommit": "83ebc3dcf72e47036e7e79ebf136a04ed11ebe72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyMzE3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402523174", "bodyText": "Shouldn't the timezone be the local timezone, or no?", "author": "cpmeister", "createdAt": "2020-04-02T18:26:23Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/MiCloudConnector.java", "diffHunk": "@@ -0,0 +1,433 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.io.IOException;\n+import java.net.CookieStore;\n+import java.net.HttpCookie;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpResponseException;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.FormContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.util.Fields;\n+import org.openhab.binding.miio.internal.MiIoCrypto;\n+import org.openhab.binding.miio.internal.MiIoCryptoException;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MiCloudConnector} class is used for connecting to the Xiaomi cloud access\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MiCloudConnector {\n+\n+    private static final int REQUEST_TIMEOUT_SECONDS = 10;\n+    private static final String UNEXPECTED = \"Unexpected :\";\n+    private static final String AGENT_ID = (new Random().ints(65, 70).limit(13)\n+            .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    private static final String USERAGENT = \"Android-7.1.1-1.0.0-ONEPLUS A3010-136-\" + AGENT_ID\n+            + \" APP/xiaomi.smarthome APPV/62830\";\n+    private static Locale locale = Locale.getDefault();\n+    private final JsonParser parser = new JsonParser();\n+    private final String clientId;\n+\n+    private String username;\n+    private String password;\n+    private String userId = \"\";\n+    private String serviceToken = \"\";\n+    private String ssecurity = \"\";\n+    private int loginFailedCounter = 0;\n+    private HttpClient httpClient;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MiCloudConnector.class);\n+\n+    public MiCloudConnector(String username, String password, HttpClient httpClient) throws MiCloudException {\n+        this.username = username;\n+        this.password = password;\n+        this.httpClient = httpClient;\n+        if (!checkCredentials()) {\n+            throw new MiCloudException(\"username or password can't be empty\");\n+        }\n+        clientId = (new Random().ints(97, 122 + 1).limit(6)\n+                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    }\n+\n+    void startClient() throws MiCloudException {\n+        if (!httpClient.isStarted()) {\n+            try {\n+                httpClient.start();\n+                // set default cookies\n+                CookieStore cookieStore = httpClient.getCookieStore();\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"mi.com\");\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"xiaomi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"mi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"xiaomi.com\");\n+            } catch (Exception e) {\n+                throw new MiCloudException(\"No http client cannot be started: \" + e.getMessage(), e);\n+            }\n+        }\n+    }\n+\n+    public void stopClient() {\n+        try {\n+            this.httpClient.stop();\n+        } catch (Exception e) {\n+            logger.debug(\"Error stopping httpclient :{}\", e.getMessage(), e);\n+        }\n+    }\n+\n+    private boolean checkCredentials() {\n+        if (username.trim().isEmpty() || password.trim().isEmpty()) {\n+            logger.info(\"Xiaomi Cloud: username or password missing.\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private String getApiUrl(String country) {\n+        return \"https://\" + (country.trim().equalsIgnoreCase(\"cn\") ? \"\" : country.trim().toLowerCase() + \".\")\n+                + \"api.io.mi.com/app\";\n+    }\n+\n+    public String getClientId() {\n+        return clientId;\n+    }\n+\n+    String parseJson(String data) {\n+        if (data.contains(\"&&&START&&&\")) {\n+            return data.replace(\"&&&START&&&\", \"\");\n+        } else {\n+            return UNEXPECTED.concat(data);\n+        }\n+    }\n+\n+    public String getMapUrl(String vacuumMap, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/getmapfileurl\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"obj_name\\\":\\\"\" + vacuumMap + \"\\\"}\");\n+        String mapResponse = request(url, map);\n+        logger.trace(\"response: {}\", mapResponse);\n+        String errorMsg = \"\";\n+        JsonElement response = parser.parse(mapResponse);\n+        if (response.isJsonObject()) {\n+            logger.debug(\"Received  JSON message {}\", response.toString());\n+            if (response.getAsJsonObject().has(\"result\") && response.getAsJsonObject().get(\"result\").isJsonObject()) {\n+                JsonObject jo = response.getAsJsonObject().get(\"result\").getAsJsonObject();\n+                if (jo.has(\"url\")) {\n+                    return jo.get(\"url\").getAsString();\n+                } else {\n+                    errorMsg = \"Could not get url\";\n+                }\n+            } else {\n+                errorMsg = \"Could not get result\";\n+            }\n+        } else {\n+            errorMsg = \"Received message is invalid JSON\";\n+        }\n+        logger.debug(\"{}: {}\", errorMsg, mapResponse);\n+        return \"\";\n+    }\n+\n+    public String getDeviceStatus(String device, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"dids\\\":[\\\"\" + device + \"\\\"]}\");\n+        final String response = request(url, map);\n+        logger.debug(\"response: {}\", response);\n+        return response;\n+    }\n+\n+    public String getDevices(String country) {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"getVirtualModel\\\":false,\\\"getHuamiDevices\\\":0}\");\n+        String resp;\n+        try {\n+            resp = request(url, map);\n+            logger.trace(\"Get devices response: {}\", resp);\n+            CloudUtil.printDevices(resp, country, logger);\n+            if (resp.length() > 2) {\n+                CloudUtil.saveFile(resp, country, logger);\n+                return resp;\n+            }\n+        } catch (MiCloudException e) {\n+            logger.info(\"{}\", e.getMessage());\n+        }\n+        return \"\";\n+    }\n+\n+    public String request(String urlPart, String country, Map<String, String> params) throws MiCloudException {\n+        String url = getApiUrl(country) + urlPart;\n+        String response = request(url, params);\n+        logger.debug(\"Request to {} server {}. Response: {}\", country, urlPart, response);\n+        return response;\n+    }\n+\n+    public String request(String url, Map<String, String> params) throws MiCloudException {\n+        if (this.serviceToken.isEmpty() || this.userId.isEmpty()) {\n+            throw new MiCloudException(\"Cannot execute request. service token or userId missing\");\n+        }\n+        startClient();\n+        logger.debug(\"Send request: {} to {}\", params.get(\"data\"), url);\n+        Request request = httpClient.newRequest(url).timeout(REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        request.agent(USERAGENT);\n+        request.header(\"x-xiaomi-protocal-flag-cli\", \"PROTOCAL-HTTP2\");\n+        request.header(HttpHeader.CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n+        request.cookie(new HttpCookie(\"userId\", this.userId));\n+        request.cookie(new HttpCookie(\"yetAnotherServiceToken\", this.serviceToken));\n+        request.cookie(new HttpCookie(\"serviceToken\", this.serviceToken));\n+        request.cookie(new HttpCookie(\"locale\", locale.toString()));\n+        request.cookie(new HttpCookie(\"timezone\", \"GMT%2B01%3A00\"));", "originalCommit": "83ebc3dcf72e47036e7e79ebf136a04ed11ebe72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUzNTgyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402535823", "bodyText": "Probable indeed... this stuff is mostly from reverse engineering and MITM logging of traffic from phone to the cloud. It is unclear what it actually is doing. I'll make it dynamic based on the OS setting", "author": "marcelrv", "createdAt": "2020-04-02T18:47:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyMzE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyMzQ4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402523486", "bodyText": "Doesn't this change? Why is this constant?", "author": "cpmeister", "createdAt": "2020-04-02T18:26:53Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/MiCloudConnector.java", "diffHunk": "@@ -0,0 +1,433 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.io.IOException;\n+import java.net.CookieStore;\n+import java.net.HttpCookie;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpResponseException;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.FormContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.util.Fields;\n+import org.openhab.binding.miio.internal.MiIoCrypto;\n+import org.openhab.binding.miio.internal.MiIoCryptoException;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MiCloudConnector} class is used for connecting to the Xiaomi cloud access\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MiCloudConnector {\n+\n+    private static final int REQUEST_TIMEOUT_SECONDS = 10;\n+    private static final String UNEXPECTED = \"Unexpected :\";\n+    private static final String AGENT_ID = (new Random().ints(65, 70).limit(13)\n+            .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    private static final String USERAGENT = \"Android-7.1.1-1.0.0-ONEPLUS A3010-136-\" + AGENT_ID\n+            + \" APP/xiaomi.smarthome APPV/62830\";\n+    private static Locale locale = Locale.getDefault();\n+    private final JsonParser parser = new JsonParser();\n+    private final String clientId;\n+\n+    private String username;\n+    private String password;\n+    private String userId = \"\";\n+    private String serviceToken = \"\";\n+    private String ssecurity = \"\";\n+    private int loginFailedCounter = 0;\n+    private HttpClient httpClient;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MiCloudConnector.class);\n+\n+    public MiCloudConnector(String username, String password, HttpClient httpClient) throws MiCloudException {\n+        this.username = username;\n+        this.password = password;\n+        this.httpClient = httpClient;\n+        if (!checkCredentials()) {\n+            throw new MiCloudException(\"username or password can't be empty\");\n+        }\n+        clientId = (new Random().ints(97, 122 + 1).limit(6)\n+                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    }\n+\n+    void startClient() throws MiCloudException {\n+        if (!httpClient.isStarted()) {\n+            try {\n+                httpClient.start();\n+                // set default cookies\n+                CookieStore cookieStore = httpClient.getCookieStore();\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"mi.com\");\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"xiaomi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"mi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"xiaomi.com\");\n+            } catch (Exception e) {\n+                throw new MiCloudException(\"No http client cannot be started: \" + e.getMessage(), e);\n+            }\n+        }\n+    }\n+\n+    public void stopClient() {\n+        try {\n+            this.httpClient.stop();\n+        } catch (Exception e) {\n+            logger.debug(\"Error stopping httpclient :{}\", e.getMessage(), e);\n+        }\n+    }\n+\n+    private boolean checkCredentials() {\n+        if (username.trim().isEmpty() || password.trim().isEmpty()) {\n+            logger.info(\"Xiaomi Cloud: username or password missing.\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private String getApiUrl(String country) {\n+        return \"https://\" + (country.trim().equalsIgnoreCase(\"cn\") ? \"\" : country.trim().toLowerCase() + \".\")\n+                + \"api.io.mi.com/app\";\n+    }\n+\n+    public String getClientId() {\n+        return clientId;\n+    }\n+\n+    String parseJson(String data) {\n+        if (data.contains(\"&&&START&&&\")) {\n+            return data.replace(\"&&&START&&&\", \"\");\n+        } else {\n+            return UNEXPECTED.concat(data);\n+        }\n+    }\n+\n+    public String getMapUrl(String vacuumMap, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/getmapfileurl\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"obj_name\\\":\\\"\" + vacuumMap + \"\\\"}\");\n+        String mapResponse = request(url, map);\n+        logger.trace(\"response: {}\", mapResponse);\n+        String errorMsg = \"\";\n+        JsonElement response = parser.parse(mapResponse);\n+        if (response.isJsonObject()) {\n+            logger.debug(\"Received  JSON message {}\", response.toString());\n+            if (response.getAsJsonObject().has(\"result\") && response.getAsJsonObject().get(\"result\").isJsonObject()) {\n+                JsonObject jo = response.getAsJsonObject().get(\"result\").getAsJsonObject();\n+                if (jo.has(\"url\")) {\n+                    return jo.get(\"url\").getAsString();\n+                } else {\n+                    errorMsg = \"Could not get url\";\n+                }\n+            } else {\n+                errorMsg = \"Could not get result\";\n+            }\n+        } else {\n+            errorMsg = \"Received message is invalid JSON\";\n+        }\n+        logger.debug(\"{}: {}\", errorMsg, mapResponse);\n+        return \"\";\n+    }\n+\n+    public String getDeviceStatus(String device, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"dids\\\":[\\\"\" + device + \"\\\"]}\");\n+        final String response = request(url, map);\n+        logger.debug(\"response: {}\", response);\n+        return response;\n+    }\n+\n+    public String getDevices(String country) {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"getVirtualModel\\\":false,\\\"getHuamiDevices\\\":0}\");\n+        String resp;\n+        try {\n+            resp = request(url, map);\n+            logger.trace(\"Get devices response: {}\", resp);\n+            CloudUtil.printDevices(resp, country, logger);\n+            if (resp.length() > 2) {\n+                CloudUtil.saveFile(resp, country, logger);\n+                return resp;\n+            }\n+        } catch (MiCloudException e) {\n+            logger.info(\"{}\", e.getMessage());\n+        }\n+        return \"\";\n+    }\n+\n+    public String request(String urlPart, String country, Map<String, String> params) throws MiCloudException {\n+        String url = getApiUrl(country) + urlPart;\n+        String response = request(url, params);\n+        logger.debug(\"Request to {} server {}. Response: {}\", country, urlPart, response);\n+        return response;\n+    }\n+\n+    public String request(String url, Map<String, String> params) throws MiCloudException {\n+        if (this.serviceToken.isEmpty() || this.userId.isEmpty()) {\n+            throw new MiCloudException(\"Cannot execute request. service token or userId missing\");\n+        }\n+        startClient();\n+        logger.debug(\"Send request: {} to {}\", params.get(\"data\"), url);\n+        Request request = httpClient.newRequest(url).timeout(REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        request.agent(USERAGENT);\n+        request.header(\"x-xiaomi-protocal-flag-cli\", \"PROTOCAL-HTTP2\");\n+        request.header(HttpHeader.CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n+        request.cookie(new HttpCookie(\"userId\", this.userId));\n+        request.cookie(new HttpCookie(\"yetAnotherServiceToken\", this.serviceToken));\n+        request.cookie(new HttpCookie(\"serviceToken\", this.serviceToken));\n+        request.cookie(new HttpCookie(\"locale\", locale.toString()));\n+        request.cookie(new HttpCookie(\"timezone\", \"GMT%2B01%3A00\"));\n+        request.cookie(new HttpCookie(\"is_daylight\", \"1\"));", "originalCommit": "83ebc3dcf72e47036e7e79ebf136a04ed11ebe72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyNDEwNg==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402524106", "bodyText": "Just minimizing cpu waste.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (HttpCookie cookie : request.getCookies()) {\n          \n          \n            \n                        logger.trace(\"Cookie set for request ({}) : {} --> {}     (path: {})\", cookie.getDomain(), cookie.getName(),\n          \n          \n            \n                                cookie.getValue(), cookie.getPath());\n          \n          \n            \n                    }\n          \n          \n            \n                    if(logger.isTraceEnabled){\n          \n          \n            \n                    for (HttpCookie cookie : request.getCookies()) {\n          \n          \n            \n                        logger.trace(\"Cookie set for request ({}) : {} --> {}     (path: {})\", cookie.getDomain(), cookie.getName(),\n          \n          \n            \n                                cookie.getValue(), cookie.getPath());\n          \n          \n            \n                    }\n          \n          \n            \n                    }", "author": "cpmeister", "createdAt": "2020-04-02T18:27:55Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/MiCloudConnector.java", "diffHunk": "@@ -0,0 +1,433 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.io.IOException;\n+import java.net.CookieStore;\n+import java.net.HttpCookie;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpResponseException;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.FormContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.util.Fields;\n+import org.openhab.binding.miio.internal.MiIoCrypto;\n+import org.openhab.binding.miio.internal.MiIoCryptoException;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MiCloudConnector} class is used for connecting to the Xiaomi cloud access\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MiCloudConnector {\n+\n+    private static final int REQUEST_TIMEOUT_SECONDS = 10;\n+    private static final String UNEXPECTED = \"Unexpected :\";\n+    private static final String AGENT_ID = (new Random().ints(65, 70).limit(13)\n+            .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    private static final String USERAGENT = \"Android-7.1.1-1.0.0-ONEPLUS A3010-136-\" + AGENT_ID\n+            + \" APP/xiaomi.smarthome APPV/62830\";\n+    private static Locale locale = Locale.getDefault();\n+    private final JsonParser parser = new JsonParser();\n+    private final String clientId;\n+\n+    private String username;\n+    private String password;\n+    private String userId = \"\";\n+    private String serviceToken = \"\";\n+    private String ssecurity = \"\";\n+    private int loginFailedCounter = 0;\n+    private HttpClient httpClient;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MiCloudConnector.class);\n+\n+    public MiCloudConnector(String username, String password, HttpClient httpClient) throws MiCloudException {\n+        this.username = username;\n+        this.password = password;\n+        this.httpClient = httpClient;\n+        if (!checkCredentials()) {\n+            throw new MiCloudException(\"username or password can't be empty\");\n+        }\n+        clientId = (new Random().ints(97, 122 + 1).limit(6)\n+                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    }\n+\n+    void startClient() throws MiCloudException {\n+        if (!httpClient.isStarted()) {\n+            try {\n+                httpClient.start();\n+                // set default cookies\n+                CookieStore cookieStore = httpClient.getCookieStore();\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"mi.com\");\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"xiaomi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"mi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"xiaomi.com\");\n+            } catch (Exception e) {\n+                throw new MiCloudException(\"No http client cannot be started: \" + e.getMessage(), e);\n+            }\n+        }\n+    }\n+\n+    public void stopClient() {\n+        try {\n+            this.httpClient.stop();\n+        } catch (Exception e) {\n+            logger.debug(\"Error stopping httpclient :{}\", e.getMessage(), e);\n+        }\n+    }\n+\n+    private boolean checkCredentials() {\n+        if (username.trim().isEmpty() || password.trim().isEmpty()) {\n+            logger.info(\"Xiaomi Cloud: username or password missing.\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private String getApiUrl(String country) {\n+        return \"https://\" + (country.trim().equalsIgnoreCase(\"cn\") ? \"\" : country.trim().toLowerCase() + \".\")\n+                + \"api.io.mi.com/app\";\n+    }\n+\n+    public String getClientId() {\n+        return clientId;\n+    }\n+\n+    String parseJson(String data) {\n+        if (data.contains(\"&&&START&&&\")) {\n+            return data.replace(\"&&&START&&&\", \"\");\n+        } else {\n+            return UNEXPECTED.concat(data);\n+        }\n+    }\n+\n+    public String getMapUrl(String vacuumMap, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/getmapfileurl\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"obj_name\\\":\\\"\" + vacuumMap + \"\\\"}\");\n+        String mapResponse = request(url, map);\n+        logger.trace(\"response: {}\", mapResponse);\n+        String errorMsg = \"\";\n+        JsonElement response = parser.parse(mapResponse);\n+        if (response.isJsonObject()) {\n+            logger.debug(\"Received  JSON message {}\", response.toString());\n+            if (response.getAsJsonObject().has(\"result\") && response.getAsJsonObject().get(\"result\").isJsonObject()) {\n+                JsonObject jo = response.getAsJsonObject().get(\"result\").getAsJsonObject();\n+                if (jo.has(\"url\")) {\n+                    return jo.get(\"url\").getAsString();\n+                } else {\n+                    errorMsg = \"Could not get url\";\n+                }\n+            } else {\n+                errorMsg = \"Could not get result\";\n+            }\n+        } else {\n+            errorMsg = \"Received message is invalid JSON\";\n+        }\n+        logger.debug(\"{}: {}\", errorMsg, mapResponse);\n+        return \"\";\n+    }\n+\n+    public String getDeviceStatus(String device, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"dids\\\":[\\\"\" + device + \"\\\"]}\");\n+        final String response = request(url, map);\n+        logger.debug(\"response: {}\", response);\n+        return response;\n+    }\n+\n+    public String getDevices(String country) {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"getVirtualModel\\\":false,\\\"getHuamiDevices\\\":0}\");\n+        String resp;\n+        try {\n+            resp = request(url, map);\n+            logger.trace(\"Get devices response: {}\", resp);\n+            CloudUtil.printDevices(resp, country, logger);\n+            if (resp.length() > 2) {\n+                CloudUtil.saveFile(resp, country, logger);\n+                return resp;\n+            }\n+        } catch (MiCloudException e) {\n+            logger.info(\"{}\", e.getMessage());\n+        }\n+        return \"\";\n+    }\n+\n+    public String request(String urlPart, String country, Map<String, String> params) throws MiCloudException {\n+        String url = getApiUrl(country) + urlPart;\n+        String response = request(url, params);\n+        logger.debug(\"Request to {} server {}. Response: {}\", country, urlPart, response);\n+        return response;\n+    }\n+\n+    public String request(String url, Map<String, String> params) throws MiCloudException {\n+        if (this.serviceToken.isEmpty() || this.userId.isEmpty()) {\n+            throw new MiCloudException(\"Cannot execute request. service token or userId missing\");\n+        }\n+        startClient();\n+        logger.debug(\"Send request: {} to {}\", params.get(\"data\"), url);\n+        Request request = httpClient.newRequest(url).timeout(REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        request.agent(USERAGENT);\n+        request.header(\"x-xiaomi-protocal-flag-cli\", \"PROTOCAL-HTTP2\");\n+        request.header(HttpHeader.CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n+        request.cookie(new HttpCookie(\"userId\", this.userId));\n+        request.cookie(new HttpCookie(\"yetAnotherServiceToken\", this.serviceToken));\n+        request.cookie(new HttpCookie(\"serviceToken\", this.serviceToken));\n+        request.cookie(new HttpCookie(\"locale\", locale.toString()));\n+        request.cookie(new HttpCookie(\"timezone\", \"GMT%2B01%3A00\"));\n+        request.cookie(new HttpCookie(\"is_daylight\", \"1\"));\n+        request.cookie(new HttpCookie(\"dst_offset\", \"3600000\"));\n+        request.cookie(new HttpCookie(\"channel\", \"MI_APP_STORE\"));\n+\n+        for (HttpCookie cookie : request.getCookies()) {\n+            logger.trace(\"Cookie set for request ({}) : {} --> {}     (path: {})\", cookie.getDomain(), cookie.getName(),\n+                    cookie.getValue(), cookie.getPath());\n+        }", "originalCommit": "83ebc3dcf72e47036e7e79ebf136a04ed11ebe72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyNjMyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402526325", "bodyText": "Instead of dealing with JsonElement, wouldn't it be better to parse json into a DTO instead?\nEdit: This is more of a suggestion than a requirement, feel free to refuse.", "author": "cpmeister", "createdAt": "2020-04-02T18:31:35Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/MiCloudConnector.java", "diffHunk": "@@ -0,0 +1,433 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.io.IOException;\n+import java.net.CookieStore;\n+import java.net.HttpCookie;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.HttpResponseException;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.FormContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.util.Fields;\n+import org.openhab.binding.miio.internal.MiIoCrypto;\n+import org.openhab.binding.miio.internal.MiIoCryptoException;\n+import org.openhab.binding.miio.internal.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MiCloudConnector} class is used for connecting to the Xiaomi cloud access\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MiCloudConnector {\n+\n+    private static final int REQUEST_TIMEOUT_SECONDS = 10;\n+    private static final String UNEXPECTED = \"Unexpected :\";\n+    private static final String AGENT_ID = (new Random().ints(65, 70).limit(13)\n+            .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    private static final String USERAGENT = \"Android-7.1.1-1.0.0-ONEPLUS A3010-136-\" + AGENT_ID\n+            + \" APP/xiaomi.smarthome APPV/62830\";\n+    private static Locale locale = Locale.getDefault();\n+    private final JsonParser parser = new JsonParser();\n+    private final String clientId;\n+\n+    private String username;\n+    private String password;\n+    private String userId = \"\";\n+    private String serviceToken = \"\";\n+    private String ssecurity = \"\";\n+    private int loginFailedCounter = 0;\n+    private HttpClient httpClient;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MiCloudConnector.class);\n+\n+    public MiCloudConnector(String username, String password, HttpClient httpClient) throws MiCloudException {\n+        this.username = username;\n+        this.password = password;\n+        this.httpClient = httpClient;\n+        if (!checkCredentials()) {\n+            throw new MiCloudException(\"username or password can't be empty\");\n+        }\n+        clientId = (new Random().ints(97, 122 + 1).limit(6)\n+                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString());\n+    }\n+\n+    void startClient() throws MiCloudException {\n+        if (!httpClient.isStarted()) {\n+            try {\n+                httpClient.start();\n+                // set default cookies\n+                CookieStore cookieStore = httpClient.getCookieStore();\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"mi.com\");\n+                addCookie(cookieStore, \"sdkVersion\", \"accountsdk-18.8.15\", \"xiaomi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"mi.com\");\n+                addCookie(cookieStore, \"deviceId\", this.clientId, \"xiaomi.com\");\n+            } catch (Exception e) {\n+                throw new MiCloudException(\"No http client cannot be started: \" + e.getMessage(), e);\n+            }\n+        }\n+    }\n+\n+    public void stopClient() {\n+        try {\n+            this.httpClient.stop();\n+        } catch (Exception e) {\n+            logger.debug(\"Error stopping httpclient :{}\", e.getMessage(), e);\n+        }\n+    }\n+\n+    private boolean checkCredentials() {\n+        if (username.trim().isEmpty() || password.trim().isEmpty()) {\n+            logger.info(\"Xiaomi Cloud: username or password missing.\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private String getApiUrl(String country) {\n+        return \"https://\" + (country.trim().equalsIgnoreCase(\"cn\") ? \"\" : country.trim().toLowerCase() + \".\")\n+                + \"api.io.mi.com/app\";\n+    }\n+\n+    public String getClientId() {\n+        return clientId;\n+    }\n+\n+    String parseJson(String data) {\n+        if (data.contains(\"&&&START&&&\")) {\n+            return data.replace(\"&&&START&&&\", \"\");\n+        } else {\n+            return UNEXPECTED.concat(data);\n+        }\n+    }\n+\n+    public String getMapUrl(String vacuumMap, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/getmapfileurl\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"obj_name\\\":\\\"\" + vacuumMap + \"\\\"}\");\n+        String mapResponse = request(url, map);\n+        logger.trace(\"response: {}\", mapResponse);\n+        String errorMsg = \"\";\n+        JsonElement response = parser.parse(mapResponse);\n+        if (response.isJsonObject()) {\n+            logger.debug(\"Received  JSON message {}\", response.toString());\n+            if (response.getAsJsonObject().has(\"result\") && response.getAsJsonObject().get(\"result\").isJsonObject()) {\n+                JsonObject jo = response.getAsJsonObject().get(\"result\").getAsJsonObject();\n+                if (jo.has(\"url\")) {\n+                    return jo.get(\"url\").getAsString();\n+                } else {\n+                    errorMsg = \"Could not get url\";\n+                }\n+            } else {\n+                errorMsg = \"Could not get result\";\n+            }\n+        } else {\n+            errorMsg = \"Received message is invalid JSON\";\n+        }\n+        logger.debug(\"{}: {}\", errorMsg, mapResponse);\n+        return \"\";\n+    }\n+\n+    public String getDeviceStatus(String device, String country) throws MiCloudException {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"dids\\\":[\\\"\" + device + \"\\\"]}\");\n+        final String response = request(url, map);\n+        logger.debug(\"response: {}\", response);\n+        return response;\n+    }\n+\n+    public String getDevices(String country) {\n+        String url = getApiUrl(country) + \"/home/device_list\";\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"data\", \"{\\\"getVirtualModel\\\":false,\\\"getHuamiDevices\\\":0}\");\n+        String resp;\n+        try {\n+            resp = request(url, map);\n+            logger.trace(\"Get devices response: {}\", resp);\n+            CloudUtil.printDevices(resp, country, logger);\n+            if (resp.length() > 2) {\n+                CloudUtil.saveFile(resp, country, logger);\n+                return resp;\n+            }\n+        } catch (MiCloudException e) {\n+            logger.info(\"{}\", e.getMessage());\n+        }\n+        return \"\";\n+    }\n+\n+    public String request(String urlPart, String country, Map<String, String> params) throws MiCloudException {\n+        String url = getApiUrl(country) + urlPart;\n+        String response = request(url, params);\n+        logger.debug(\"Request to {} server {}. Response: {}\", country, urlPart, response);\n+        return response;\n+    }\n+\n+    public String request(String url, Map<String, String> params) throws MiCloudException {\n+        if (this.serviceToken.isEmpty() || this.userId.isEmpty()) {\n+            throw new MiCloudException(\"Cannot execute request. service token or userId missing\");\n+        }\n+        startClient();\n+        logger.debug(\"Send request: {} to {}\", params.get(\"data\"), url);\n+        Request request = httpClient.newRequest(url).timeout(REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        request.agent(USERAGENT);\n+        request.header(\"x-xiaomi-protocal-flag-cli\", \"PROTOCAL-HTTP2\");\n+        request.header(HttpHeader.CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n+        request.cookie(new HttpCookie(\"userId\", this.userId));\n+        request.cookie(new HttpCookie(\"yetAnotherServiceToken\", this.serviceToken));\n+        request.cookie(new HttpCookie(\"serviceToken\", this.serviceToken));\n+        request.cookie(new HttpCookie(\"locale\", locale.toString()));\n+        request.cookie(new HttpCookie(\"timezone\", \"GMT%2B01%3A00\"));\n+        request.cookie(new HttpCookie(\"is_daylight\", \"1\"));\n+        request.cookie(new HttpCookie(\"dst_offset\", \"3600000\"));\n+        request.cookie(new HttpCookie(\"channel\", \"MI_APP_STORE\"));\n+\n+        for (HttpCookie cookie : request.getCookies()) {\n+            logger.trace(\"Cookie set for request ({}) : {} --> {}     (path: {})\", cookie.getDomain(), cookie.getName(),\n+                    cookie.getValue(), cookie.getPath());\n+        }\n+        String method = \"POST\";\n+        request.method(method);\n+\n+        try {\n+            String nonce = CloudUtil.generateNonce(System.currentTimeMillis());\n+            String signedNonce = CloudUtil.signedNonce(ssecurity, nonce);\n+            String signature = CloudUtil.generateSignature(url.replace(\"/app\", \"\"), signedNonce, nonce, params);\n+\n+            Fields fields = new Fields();\n+            fields.put(\"signature\", signature);\n+            fields.put(\"_nonce\", nonce);\n+            fields.put(\"data\", params.get(\"data\"));\n+            request.content(new FormContentProvider(fields));\n+\n+            logger.trace(\"fieldcontent: {}\", fields.toString());\n+            final ContentResponse response = request.send();\n+            return response.getContentAsString();\n+        } catch (HttpResponseException e) {\n+            serviceToken = \"\";\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (InterruptedException | TimeoutException | ExecutionException | IOException e) {\n+            logger.debug(\"Error while executing request to {} :{}\", url, e.getMessage());\n+        } catch (MiIoCryptoException e) {\n+            logger.debug(\"Error while decrypting response of request to {} :{}\", url, e.getMessage(), e);\n+        }\n+        return \"\";\n+    }\n+\n+    private void addCookie(CookieStore cookieStore, String name, String value, String domain) {\n+        HttpCookie cookie = new HttpCookie(name, value);\n+        cookie.setDomain(\".\" + domain);\n+        cookie.setPath(\"/\");\n+        cookieStore.add(URI.create(\"https://\" + domain), cookie);\n+    }\n+\n+    public synchronized boolean login() {\n+        if (!checkCredentials()) {\n+            return false;\n+        }\n+        if (!userId.isEmpty() && !serviceToken.isEmpty()) {\n+            return true;\n+        }\n+        logger.debug(\"Xiaomi cloud login with userid {}\", username);\n+        try {\n+            if (loginRequest()) {\n+                loginFailedCounter = 0;\n+            } else {\n+                loginFailedCounter++;\n+                logger.debug(\"Xiaomi cloud login attempt {}\", loginFailedCounter);\n+            }\n+        } catch (MiCloudException e) {\n+            logger.info(\"Error logging on to Xiaomi cloud ({}): {}\", loginFailedCounter, e.getMessage());\n+            loginFailedCounter++;\n+            serviceToken = \"\";\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    protected boolean loginRequest() throws MiCloudException {\n+        try {\n+            startClient();\n+            String sign = loginStep1();\n+            String location = loginStep2(sign);\n+            final ContentResponse responseStep3 = loginStep3(location);\n+\n+            switch (responseStep3.getStatus()) {\n+                case HttpStatus.FORBIDDEN_403:\n+                    throw new MiCloudException(\"Access denied. Did you set the correct api-key and/or username?\");\n+                case HttpStatus.OK_200:\n+                    return true;\n+                default:\n+                    logger.trace(\"request returned status '{}', reason: {}, content = {}\", responseStep3.getStatus(),\n+                            responseStep3.getReason(), responseStep3.getContentAsString());\n+                    throw new MiCloudException(responseStep3.getStatus() + responseStep3.getReason());\n+            }\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new MiCloudException(\"Cannot logon to Xiaomi cloud: \" + e.getMessage(), e);\n+        } catch (MiIoCryptoException e) {\n+            throw new MiCloudException(\"Error decrypting. Cannot logon to Xiaomi cloud: \" + e.getMessage(), e);\n+        } catch (MalformedURLException e) {\n+            throw new MiCloudException(\"Error getting logon URL. Cannot logon to Xiaomi cloud: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    private String loginStep1() throws InterruptedException, TimeoutException, ExecutionException, MiCloudException {\n+        final ContentResponse responseStep1;\n+\n+        logger.trace(\"Xiaomi Login step 1\");\n+        String url = \"https://account.xiaomi.com/pass/serviceLogin?sid=xiaomiio&_json=true\";\n+        Request request = httpClient.newRequest(url).timeout(REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        request.agent(USERAGENT);\n+        request.header(HttpHeader.CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n+        request.cookie(new HttpCookie(\"userId\", this.userId.length() > 0 ? this.userId : this.username));\n+\n+        responseStep1 = request.send();\n+        final String content = responseStep1.getContentAsString();\n+        logger.trace(\"Xiaomi Login step 1 content response= {}\", content);\n+        logger.trace(\"Xiaomi Login step 1 response = {}\", responseStep1);\n+        try {\n+            JsonElement resp = new JsonParser().parse(parseJson(content));\n+            String sign = resp.getAsJsonObject().get(\"_sign\").getAsString();\n+            logger.trace(\"Xiaomi Login step 1 sign = {}\", sign);\n+            return sign;\n+        } catch (JsonSyntaxException | NullPointerException e) {\n+            throw new MiCloudException(\"Error getting logon sign. Cannot parse response: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    private String loginStep2(String sign)\n+            throws MiIoCryptoException, InterruptedException, TimeoutException, ExecutionException, MiCloudException {\n+        String passToken;\n+        String cUserId;\n+\n+        logger.trace(\"Xiaomi Login step 2\");\n+        String url = \"https://account.xiaomi.com/pass/serviceLoginAuth2\";\n+        Request request = httpClient.newRequest(url).timeout(REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        request.agent(USERAGENT);\n+        request.method(HttpMethod.POST);\n+        final ContentResponse responseStep2;\n+\n+        Fields fields = new Fields();\n+        fields.put(\"sid\", \"xiaomiio\");\n+        // fields.put(\"hash\", encodePassword(password));\n+        fields.put(\"hash\", Utils.getHex(MiIoCrypto.md5(password.getBytes())));\n+        fields.put(\"callback\", \"https://sts.api.io.mi.com/sts\");\n+        fields.put(\"qs\", \"%3Fsid%3Dxiaomiio%26_json%3Dtrue\");\n+        fields.put(\"user\", username);\n+        fields.put(\"_sign\", sign);\n+        fields.put(\"_json\", \"true\");\n+\n+        request.content(new FormContentProvider(fields));\n+        responseStep2 = request.send();\n+\n+        final String content2 = responseStep2.getContentAsString();\n+        logger.trace(\"Xiaomi login step 2 response = {}\", responseStep2);\n+        logger.trace(\"Xiaomi login step 2 content = {}\", content2);\n+\n+        JsonElement resp2 = new JsonParser().parse(parseJson(content2));", "originalCommit": "83ebc3dcf72e47036e7e79ebf136a04ed11ebe72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc1ODQ0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r403758448", "bodyText": "Yes, did that, as well as with the device response. That actually improved the code in several places.", "author": "marcelrv", "createdAt": "2020-04-05T21:21:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyNjMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUzMDU2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r402530561", "bodyText": "You are still using TimesRoman here.", "author": "cpmeister", "createdAt": "2020-04-02T18:38:50Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/robot/RRMapDraw.java", "diffHunk": "@@ -302,32 +308,35 @@ private void drawGoTo(Graphics2D g2d, float scale) {\n             int x3[] = { (int) x, (int) (x - 2 * scale), (int) (x + 2 * scale) };\n             int y3[] = { (int) y, (int) (y - 5 * scale), (int) (y - 5 * scale) };\n             g2d.fill(new Polygon(x3, y3, 3));\n-\n         }\n     }\n \n     private void drawOpenHabRocks(Graphics2D g2d, int width, int height, float scale) {\n-        // easter egg gift :\n+        // easter egg gift\n         int offset = 5;\n         int textPos = 55;\n+        URL image = getImageUrl(\"ohlogo.png\");\n         try {\n-            BufferedImage ohLogo = ImageIO.read(new ByteArrayInputStream(Base64.getDecoder().decode(\n-                    \"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\")));\n-            textPos = (int) (ohLogo.getWidth() * scale / 2 + offset);\n-            AffineTransform at = new AffineTransform();\n-            at.scale(scale / 2, scale / 2);\n-            AffineTransformOp scaleOp = new AffineTransformOp(at, AffineTransformOp.TYPE_BILINEAR);\n-            g2d.drawImage(ohLogo, scaleOp, offset, height - (int) (ohLogo.getHeight() * scale / 2) - offset);\n+            if (image != null) {\n+                BufferedImage ohLogo = ImageIO.read(image);\n+                textPos = (int) (ohLogo.getWidth() * scale / 2 + offset);\n+                AffineTransform at = new AffineTransform();\n+                at.scale(scale / 2, scale / 2);\n+                AffineTransformOp scaleOp = new AffineTransformOp(at, AffineTransformOp.TYPE_BILINEAR);\n+                g2d.drawImage(ohLogo, scaleOp, offset, height - (int) (ohLogo.getHeight() * scale / 2) - offset);\n+            } else {\n+                logger.debug(\"Error loading image ohlogo.png: File not be found.\");\n+            }\n         } catch (IOException e) {\n-            // no joy\n+            logger.debug(\"Error loading image ohlogo.png:: {}\", e.getMessage());\n         }\n         Font font = new Font(\"TimesRoman\", Font.BOLD, 14);", "originalCommit": "75bcaf7c0723338514c62a4bdb7635e4cdb56cc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3MDU5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r403770590", "bodyText": "yes, I think something went wrong with the final save. Should be fixed now", "author": "marcelrv", "createdAt": "2020-04-05T23:11:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUzMDU2MQ=="}], "type": "inlineReview"}, {"oid": "c0c7db574febd608d2861ac23b50b19027171c57", "url": "https://github.com/openhab/openhab-addons/commit/c0c7db574febd608d2861ac23b50b19027171c57", "message": "[miio] updates based on feedback\n\nFix for re-logon\nmove to DTO\nUpdates based on review feedback\n\nSigned-off-by: Marcel Verpaalen <marcel@verpaalen.com>", "committedDate": "2020-04-05T22:03:10Z", "type": "commit"}, {"oid": "f59e3fe7d9931d936555cce3c2ecfdf1e21a863d", "url": "https://github.com/openhab/openhab-addons/commit/f59e3fe7d9931d936555cce3c2ecfdf1e21a863d", "message": "Merge remote-tracking branch 'origin/2.5.x' into miio-cloudconnect\n\nConflicts:\n\tbundles/org.openhab.binding.miio/README.md\n\tbundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/discovery/MiIoDiscovery.java", "committedDate": "2020-04-05T22:09:54Z", "type": "commit"}, {"oid": "98bbf1aeaf18438efcdd745fe15f67d20ca8dc13", "url": "https://github.com/openhab/openhab-addons/commit/98bbf1aeaf18438efcdd745fe15f67d20ca8dc13", "message": "[miio] update readme & small cleanup\n\nSigned-off-by: Marcel Verpaalen <marcel@verpaalen.com>", "committedDate": "2020-04-05T23:10:04Z", "type": "commit"}, {"oid": "fdf64d48c30163727a4ae882ecebdc43fbe21ab6", "url": "https://github.com/openhab/openhab-addons/commit/fdf64d48c30163727a4ae882ecebdc43fbe21ab6", "message": "[miio] small fix\n\nSigned-off-by: Marcel Verpaalen <marcel@verpaalen.com>", "committedDate": "2020-04-05T23:24:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3MzUyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r403773526", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public java.util.List<CloudDeviceDTO> getCloudDevices() {\n          \n          \n            \n                public List<CloudDeviceDTO> getCloudDevices() {", "author": "cpmeister", "createdAt": "2020-04-05T23:36:07Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/CloudDeviceListDTO.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.util.List;\n+\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * This DTO class wraps the device list info json structure\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+public class CloudDeviceListDTO {\n+\n+    @SerializedName(\"list\")\n+    @Expose\n+    private List<CloudDeviceDTO> cloudDevices = null;\n+\n+    public java.util.List<CloudDeviceDTO> getCloudDevices() {", "originalCommit": "c0c7db574febd608d2861ac23b50b19027171c57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3MzU1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r403773553", "bodyText": "Some of our build tools don't like EOF without a newline. So add a newline here.", "author": "cpmeister", "createdAt": "2020-04-05T23:36:29Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/CloudLoginDTO.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import org.jetbrains.annotations.NotNull;\n+\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * This DTO class wraps the login step 2 json structure\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+public class CloudLoginDTO {\n+\n+    @SerializedName(\"qs\")\n+    @Expose\n+    private String qs;\n+    @SerializedName(\"psecurity\")\n+    @Expose\n+    private String psecurity;\n+    @SerializedName(\"nonce\")\n+    @Expose\n+    private Integer nonce;\n+    @SerializedName(\"ssecurity\")\n+    @Expose\n+    private String ssecurity;\n+    @SerializedName(\"passToken\")\n+    @Expose\n+    private String passToken;\n+    @SerializedName(\"userId\")\n+    @Expose\n+    private String userId;\n+    @SerializedName(\"cUserId\")\n+    @Expose\n+    private String cUserId;\n+    @SerializedName(\"securityStatus\")\n+    @Expose\n+    private Integer securityStatus;\n+    @SerializedName(\"pwd\")\n+    @Expose\n+    private Integer pwd;\n+    @SerializedName(\"code\")\n+    @Expose\n+    private String code;\n+    @SerializedName(\"desc\")\n+    @Expose\n+    private String desc;\n+    @SerializedName(\"location\")\n+    @Expose\n+    private String location;\n+    @SerializedName(\"captchaUrl\")\n+    @Expose\n+    private Object captchaUrl;\n+\n+    public @NotNull String getSsecurity() {\n+        return ssecurity != null ? ssecurity : \"\";\n+    }\n+\n+    public @NotNull String getUserId() {\n+        return userId != null ? userId : \"\";\n+    }\n+\n+    public @NotNull String getcUserId() {\n+        return cUserId != null ? cUserId : \"\";\n+    }\n+\n+    public @NotNull String getPassToken() {\n+        return passToken != null ? passToken : \"\";\n+    }\n+\n+    public @NotNull String getLocation() {\n+        return location != null ? location : \"\";\n+    }\n+\n+    public String getCode() {\n+        return code;\n+    }\n+\n+    public String getQs() {\n+        return qs;\n+    }\n+\n+    public String getPsecurity() {\n+        return psecurity;\n+    }\n+\n+    public Integer getNonce() {\n+        return nonce;\n+    }\n+\n+    public String getCUserId() {\n+        return cUserId;\n+    }\n+\n+    public Integer getSecurityStatus() {\n+        return securityStatus;\n+    }\n+\n+    public Integer getPwd() {\n+        return pwd;\n+    }\n+\n+    public String getDesc() {\n+        return desc;\n+    }\n+\n+    public Object getCaptchaUrl() {\n+        return captchaUrl;\n+    }\n+\n+    public void setCaptchaUrl(Object captchaUrl) {\n+        this.captchaUrl = captchaUrl;\n+    }\n+}", "originalCommit": "c0c7db574febd608d2861ac23b50b19027171c57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3NDM4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r403774382", "bodyText": "You need two pings to go online?", "author": "cpmeister", "createdAt": "2020-04-05T23:43:27Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/transport/MiIoAsyncCommunication.java", "diffHunk": "@@ -310,7 +313,7 @@ private void pingSuccess() {\n         if (!connected) {\n             connected = true;\n             status = ThingStatusDetail.NONE;\n-            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE);", "originalCommit": "c0c7db574febd608d2861ac23b50b19027171c57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk0NjczMw==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r403946733", "bodyText": "this is one of the most confusing parts of the current binding behavior.\nIf the user has wrong token, currently the thing becomes online. As it responds to the ping, but does not respond to commands. This confuses everyone. Hence I want to make it more transparent for the users and only make the thing online if it actually responds to a command.\nPing only means that a Xiaomi device is there, but it does not mean online in the sense that it is working.\nThe annoying part of the devices is they simply don't respond at all if a wrong token is used, so not even a 'wrong token' sort of response.", "author": "marcelrv", "createdAt": "2020-04-06T09:21:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3NDM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3NjczOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r403776739", "bodyText": "Why do you need to logon here? Can it be done lazily?", "author": "cpmeister", "createdAt": "2020-04-06T00:02:13Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/CloudConnector.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import static org.openhab.binding.miio.internal.MiIoBindingConstants.BINDING_ID;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link CloudConnector} is responsible for connecting OH to the Xiaomi cloud communication.\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@Component(service = CloudConnector.class)\n+@NonNullByDefault\n+public class CloudConnector {\n+\n+    protected static final long CACHE_EXPIRY = TimeUnit.SECONDS.toMillis(60);\n+    private static final int FAILED = -1;\n+    private static final int STARTING = 0;\n+    private static final int REFRESHING = 1;\n+    private static final int AVAILABLE = 2;\n+    private volatile int deviceListState = STARTING;\n+\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String country = \"ru,us,tw,sg,cn,de\";\n+    private List<CloudDeviceDTO> deviceList = new ArrayList<>();\n+    private boolean connected;\n+    private final HttpClient httpClient;\n+    private @Nullable MiCloudConnector cloudConnector;\n+    private final Logger logger = LoggerFactory.getLogger(CloudConnector.class);\n+\n+    private ExpiringCache<Boolean> logonCache = new ExpiringCache<Boolean>(CACHE_EXPIRY, () -> {\n+        return logon();\n+    });\n+\n+    private ExpiringCache<String> refreshDeviceList = new ExpiringCache<String>(CACHE_EXPIRY, () -> {\n+        if (deviceListState == FAILED && !isConnected()) {\n+            return (\"Could not connect to Xiaomi cloud\");\n+        }\n+        final @Nullable MiCloudConnector cl = this.cloudConnector;\n+        if (cl == null) {\n+            return (\"Could not connect to Xiaomi cloud\");\n+        }\n+        deviceListState = REFRESHING;\n+        deviceList.clear();\n+        for (String server : country.split(\",\")) {\n+            try {\n+                deviceList.addAll(cl.getDevices(server));\n+            } catch (JsonParseException e) {\n+                logger.debug(\"Parsing error getting devices: {}\", e.getMessage());\n+            }\n+        }\n+        deviceListState = AVAILABLE;\n+        return \"done\";// deviceList;\n+    });\n+\n+    @Activate\n+    public CloudConnector(@Reference HttpClientFactory httpClientFactory) {\n+        this.httpClient = httpClientFactory.createHttpClient(BINDING_ID);\n+    }\n+\n+    @Deactivate\n+    public void dispose() {\n+        final MiCloudConnector cl = cloudConnector;\n+        if (cl != null) {\n+            cl.stopClient();\n+        }\n+        cloudConnector = null;\n+    }\n+\n+    public boolean isConnected() {\n+        final MiCloudConnector cl = cloudConnector;\n+        if (cl != null && cl.hasLoginToken()) {\n+            return true;\n+        }\n+        final @Nullable Boolean c = logonCache.getValue();\n+        if (c != null && c.booleanValue()) {\n+            return true;\n+        }\n+        deviceListState = FAILED;\n+        return false;\n+    }\n+\n+    public @Nullable RawType getMap(String mapId, String country) throws MiCloudException {\n+        logger.info(\"Getting vacuum map {} from Xiaomi cloud server: {}\", mapId, country);\n+        String mapCountry;\n+        String mapUrl = \"\";\n+        final @Nullable MiCloudConnector cl = this.cloudConnector;\n+        if (cl == null || !isConnected()) {\n+            throw new MiCloudException(\"Cannot execute request. Cloudservice not available\");\n+        }\n+        if (country.isEmpty()) {\n+            logger.debug(\"Server not defined in thing. Trying servers: {}\", this.country);\n+            for (String mapCountryServer : this.country.split(\",\")) {\n+                mapCountry = mapCountryServer.trim().toLowerCase();\n+                mapUrl = cl.getMapUrl(mapId, mapCountry);\n+                logger.debug(\"Map download from server {} returned {}\", mapCountry, mapUrl);\n+                if (!mapUrl.isEmpty()) {\n+                    break;\n+                }\n+            }\n+        } else {\n+            mapCountry = country.trim().toLowerCase();\n+            mapUrl = cl.getMapUrl(mapId, mapCountry);\n+        }\n+        @Nullable\n+        RawType mapData = HttpUtil.downloadData(mapUrl, null, false, -1);\n+        if (mapData != null) {\n+            return mapData;\n+        } else {\n+            logger.debug(\"Could not download '{}'\", mapUrl);\n+            return null;\n+        }\n+    }\n+\n+    public void setCredentials(@Nullable String username, @Nullable String password, @Nullable String country) {\n+        if (country != null) {\n+            this.country = country;\n+        }\n+        if (username != null && password != null) {\n+            this.username = username;\n+            this.password = password;\n+            logon();", "originalCommit": "fdf64d48c30163727a4ae882ecebdc43fbe21ab6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI1MDkwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r404250908", "bodyText": "yes, can. removed the logon", "author": "marcelrv", "createdAt": "2020-04-06T17:06:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3NjczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc4MzA1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r403783054", "bodyText": "might be cleaner if you made all these fields public, you could get rid of all the bloat of your getter methods.", "author": "cpmeister", "createdAt": "2020-04-06T00:50:05Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/CloudDeviceDTO.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * This DTO class wraps the device info json structure\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+public class CloudDeviceDTO {\n+\n+    @SerializedName(\"did\")\n+    @Expose\n+    private String did;\n+    @SerializedName(\"token\")\n+    @Expose\n+    private String token;\n+    @SerializedName(\"longitude\")\n+    @Expose\n+    private String longitude;\n+    @SerializedName(\"latitude\")\n+    @Expose\n+    private String latitude;\n+    @SerializedName(\"name\")\n+    @Expose\n+    private String name;\n+    @SerializedName(\"pid\")\n+    @Expose\n+    private String pid;\n+    @SerializedName(\"localip\")\n+    @Expose\n+    private String localip;\n+    @SerializedName(\"mac\")\n+    @Expose\n+    private String mac;\n+    @SerializedName(\"ssid\")\n+    @Expose\n+    private String ssid;\n+    @SerializedName(\"bssid\")\n+    @Expose\n+    private String bssid;\n+    @SerializedName(\"parent_id\")\n+    @Expose\n+    private String parentId;\n+    @SerializedName(\"parent_model\")\n+    @Expose\n+    private String parentModel;\n+    @SerializedName(\"show_mode\")\n+    @Expose\n+    private Integer showMode;\n+    @SerializedName(\"model\")\n+    @Expose\n+    private String model;\n+    @SerializedName(\"adminFlag\")\n+    @Expose\n+    private Integer adminFlag;\n+    @SerializedName(\"shareFlag\")\n+    @Expose\n+    private Integer shareFlag;\n+    @SerializedName(\"permitLevel\")\n+    @Expose\n+    private Integer permitLevel;\n+    @SerializedName(\"isOnline\")\n+    @Expose\n+    private Boolean isOnline;\n+    @SerializedName(\"desc\")\n+    @Expose\n+    private String desc;\n+    @SerializedName(\"uid\")\n+    @Expose\n+    private Integer uid;\n+    @SerializedName(\"pd_id\")\n+    @Expose\n+    private Integer pdId;\n+    @SerializedName(\"password\")\n+    @Expose\n+    private String password;\n+    @SerializedName(\"rssi\")\n+    @Expose\n+    private Integer rssi;\n+    @SerializedName(\"family_id\")\n+    @Expose\n+    private Integer familyId;\n+    private @NonNull String server = \"undefined\";", "originalCommit": "fdf64d48c30163727a4ae882ecebdc43fbe21ab6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkzMjg1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r403932857", "bodyText": "I actually did that first. But for the fields that I actually use I wanted to avoid null checks everywhere in the code, so I added those in the getters (only to the current relevant fields).\nIt did not seem very clean to have half of the fields in with public and the remaining with getters in private or have a public one that also has a getter", "author": "marcelrv", "createdAt": "2020-04-06T08:58:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc4MzA1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc4MzE1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r403783157", "bodyText": "Since you switched to DTOs, is this still used?", "author": "cpmeister", "createdAt": "2020-04-06T00:50:44Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/CloudUtil.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.openhab.binding.miio.internal.MiIoBindingConstants;\n+import org.openhab.binding.miio.internal.MiIoCryptoException;\n+import org.slf4j.Logger;\n+\n+import com.google.gson.JsonElement;\n+\n+/**\n+ * The {@link CloudUtil} class is used for supporting functions for Xiaomi cloud access\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class CloudUtil {\n+\n+    private static final Random RANDOM = new Random();\n+\n+    public static String getElementString(JsonElement jsonElement, String element, Logger logger) {", "originalCommit": "fdf64d48c30163727a4ae882ecebdc43fbe21ab6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI1NjA1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r404256056", "bodyText": "no, it it is no longer required. Removed now", "author": "marcelrv", "createdAt": "2020-04-06T17:14:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc4MzE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc4MzIwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r403783205", "bodyText": "The default charset varies from system to system so it is better to specify it yourself instead of using the default.", "author": "cpmeister", "createdAt": "2020-04-06T00:51:17Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/CloudUtil.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.openhab.binding.miio.internal.MiIoBindingConstants;\n+import org.openhab.binding.miio.internal.MiIoCryptoException;\n+import org.slf4j.Logger;\n+\n+import com.google.gson.JsonElement;\n+\n+/**\n+ * The {@link CloudUtil} class is used for supporting functions for Xiaomi cloud access\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class CloudUtil {\n+\n+    private static final Random RANDOM = new Random();\n+\n+    public static String getElementString(JsonElement jsonElement, String element, Logger logger) {\n+        String value = \"\";\n+        try {\n+            value = jsonElement.getAsJsonObject().get(element).getAsString();\n+        } catch (IllegalStateException | ClassCastException e) {\n+            logger.debug(\"Json Element {} expected but missing\", element);\n+        }\n+        return value;\n+    }\n+\n+    public static void saveFile(String data, String country, Logger logger) {\n+        String dbFolderName = ConfigConstants.getUserDataFolder() + File.separator + MiIoBindingConstants.BINDING_ID;\n+        File folder = new File(dbFolderName);\n+        if (!folder.exists()) {\n+            folder.mkdirs();\n+        }\n+        File dataFile = new File(dbFolderName + File.separator + \"miioTokens-\" + country + \".json\");\n+        try (FileWriter writer = new FileWriter(dataFile)) {\n+            writer.write(data);\n+            logger.debug(\"Devices token info saved to {}\", dataFile.getAbsolutePath());\n+        } catch (IOException e) {\n+            logger.debug(\"Failed to write token file '{}': {}\", dataFile.getName(), e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Generate signature for the request.\n+     *\n+     * @param method http request method. GET or POST\n+     * @param requestUrl the full request url. e.g.: http://api.xiaomi.com/getUser?id=123321\n+     * @param params request params. This should be a TreeMap because the\n+     *            parameters are required to be in lexicographic order.\n+     * @param signedNonce secret key for encryption.\n+     * @return hash value for the values provided\n+     * @throws MiIoCryptoException\n+     */\n+    public static String generateSignature(@Nullable String requestUrl, @Nullable String signedNonce, String nonce,\n+            @Nullable Map<String, String> params) throws MiIoCryptoException {\n+        if (signedNonce == null || signedNonce.length() == 0) {\n+            throw new MiIoCryptoException(\"key is not nullable\");\n+        }\n+        List<String> exps = new ArrayList<String>();\n+\n+        if (requestUrl != null) {\n+            URI uri = URI.create(requestUrl);\n+            exps.add(uri.getPath());\n+        }\n+        exps.add(signedNonce);\n+        exps.add(nonce);\n+\n+        if (params != null && !params.isEmpty()) {\n+            final TreeMap<String, String> sortedParams = new TreeMap<String, String>(params);\n+            Set<Map.Entry<String, String>> entries = sortedParams.entrySet();\n+            for (Map.Entry<String, String> entry : entries) {\n+                exps.add(String.format(\"%s=%s\", entry.getKey(), entry.getValue()));\n+            }\n+        }\n+        boolean first = true;\n+        StringBuilder sb = new StringBuilder();\n+        for (String s : exps) {\n+            if (!first) {\n+                sb.append('&');\n+            } else {\n+                first = false;\n+            }\n+            sb.append(s);\n+        }\n+        return CloudCrypto.hMacSha256Encode(Base64.getDecoder().decode(signedNonce), sb.toString().getBytes());", "originalCommit": "fdf64d48c30163727a4ae882ecebdc43fbe21ab6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc4NDgxMg==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r403784812", "bodyText": "is this correct?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        int y3[] = { (int) y, (int) (y - 5 * scale), (int) (y - 5 * scale) };\n          \n          \n            \n                        int y3[] = { (int) y, (int) (y - 5 * scale), (int) (y + 5 * scale) };", "author": "cpmeister", "createdAt": "2020-04-06T01:02:44Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/robot/RRMapDraw.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.robot;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics2D;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Ellipse2D;\n+import java.awt.geom.Line2D;\n+import java.awt.geom.Path2D;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.image.AffineTransformOp;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+\n+import javax.imageio.ImageIO;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Draws the vacuum map file to an image\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RRMapDraw {\n+\n+    private static final int MAP_OUTSIDE = 0x00;\n+    private static final int MAP_WALL = 0x01;\n+    private static final int MAP_INSIDE = 0xFF;\n+    private static final int MAP_SCAN = 0x07;\n+    private static final Color COLOR_MAP_INSIDE = new Color(32, 115, 185);\n+    private static final Color COLOR_MAP_OUTSIDE = new Color(19, 87, 148);\n+    private static final Color COLOR_MAP_WALL = new Color(100, 196, 254);\n+    private static final Color COLOR_GREY_WALL = new Color(93, 109, 126);\n+    private static final Color COLOR_PATH = new Color(147, 194, 238);\n+    private static final Color COLOR_ZONES = new Color(0xAD, 0xD8, 0xFF, 0x8F);\n+    private static final Color COLOR_NO_GO_ZONES = new Color(255, 33, 55, 127);\n+    private static final Color COLOR_CHARGER_HALO = new Color(0x66, 0xfe, 0xda, 0x7f);\n+    private static final Color COLOR_ROBO = new Color(75, 235, 149);\n+    private static final Color COLOR_SCAN = new Color(0xDF, 0xDF, 0xDF);\n+    private static final Color ROOM1 = new Color(240, 178, 122);\n+    private static final Color ROOM2 = new Color(133, 193, 233);\n+    private static final Color ROOM3 = new Color(217, 136, 128);\n+    private static final Color ROOM4 = new Color(52, 152, 219);\n+    private static final Color ROOM5 = new Color(205, 97, 85);\n+    private static final Color ROOM6 = new Color(243, 156, 18);\n+    private static final Color ROOM7 = new Color(88, 214, 141);\n+    private static final Color ROOM8 = new Color(245, 176, 65);\n+    private static final Color ROOM9 = new Color(0xFc, 0xD4, 0x51);\n+    private static final Color ROOM10 = new Color(72, 201, 176);\n+    private static final Color ROOM11 = new Color(84, 153, 199);\n+    private static final Color ROOM12 = new Color(133, 193, 233);\n+    private static final Color ROOM13 = new Color(245, 176, 65);\n+    private static final Color ROOM14 = new Color(82, 190, 128);\n+    private static final Color ROOM15 = new Color(72, 201, 176);\n+    private static final Color ROOM16 = new Color(165, 105, 189);\n+    private static final Color[] ROOM_COLORS = { ROOM1, ROOM2, ROOM3, ROOM4, ROOM5, ROOM6, ROOM7, ROOM8, ROOM9, ROOM10,\n+            ROOM11, ROOM12, ROOM13, ROOM14, ROOM15, ROOM16 };\n+    private final @Nullable Bundle bundle = FrameworkUtil.getBundle(getClass());\n+    private boolean multicolor = false;\n+    private final RRMapFileParser rmfp;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RRMapDraw.class);\n+\n+    public RRMapDraw(RRMapFileParser rmfp) {\n+        this.rmfp = rmfp;\n+    }\n+\n+    public int getWidth() {\n+        return rmfp.getImgWidth();\n+    }\n+\n+    public int getHeight() {\n+        return rmfp.getImgHeight();\n+    }\n+\n+    /**\n+     * load Gzipped RR inputstream\n+     *\n+     * @throws IOException\n+     */\n+    public static RRMapDraw loadImage(InputStream is) throws IOException {\n+        byte[] inputdata = RRMapFileParser.readRRMapFile(is);\n+        RRMapFileParser rf = new RRMapFileParser(inputdata);\n+        return new RRMapDraw(rf);\n+    }\n+\n+    /**\n+     * load Gzipped RR file\n+     *\n+     * @throws IOException\n+     */\n+    public static RRMapDraw loadImage(File file) throws IOException {\n+        return loadImage(new FileInputStream(file));\n+    }\n+\n+    /**\n+     * draws the map from the individual pixels\n+     */\n+    private void drawMap(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(1.1f * scale);\n+        g2d.setStroke(stroke);\n+        for (int y = 0; y < rmfp.getImgHeight() - 1; y++) {\n+            for (int x = 0; x < rmfp.getImgWidth() + 1; x++) {\n+                byte walltype = rmfp.getImage()[x + rmfp.getImgWidth() * y];\n+                switch (walltype & 0xFF) {\n+                    case MAP_OUTSIDE:\n+                        g2d.setColor(COLOR_MAP_OUTSIDE);\n+                        break;\n+                    case MAP_WALL:\n+                        g2d.setColor(COLOR_MAP_WALL);\n+                        break;\n+                    case MAP_INSIDE:\n+                        g2d.setColor(COLOR_MAP_INSIDE);\n+                        break;\n+                    case MAP_SCAN:\n+                        g2d.setColor(COLOR_SCAN);\n+                        break;\n+                    default:\n+                        int obstacle = (walltype & 0x07);\n+                        int mapId = (walltype & 0xFF) >>> 3;\n+                        switch (obstacle) {\n+                            case 0:\n+                                g2d.setColor(COLOR_GREY_WALL);\n+                                break;\n+                            case 1:\n+                                g2d.setColor(Color.BLACK);\n+                                break;\n+                            case 7:\n+                                g2d.setColor(ROOM_COLORS[Math.round(mapId / 2)]);\n+                                multicolor = true;\n+                                break;\n+                            default:\n+                                g2d.setColor(Color.WHITE);\n+                                break;\n+                        }\n+                }\n+                float xPos = scale * (rmfp.getImgWidth() - x);\n+                float yP = scale * y;\n+                g2d.draw(new Line2D.Float(xPos, yP, xPos, yP));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * draws the vacuum path\n+     *\n+     * @param scale\n+     */\n+    private void drawPath(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(0.5f * scale);\n+        g2d.setStroke(stroke);\n+        for (Integer pathType : rmfp.getPaths().keySet()) {\n+            switch (pathType) {\n+                case RRMapFileParser.PATH:\n+                    if (!multicolor) {\n+                        g2d.setColor(COLOR_PATH);\n+                    } else {\n+                        g2d.setColor(Color.WHITE);\n+                    }\n+                    break;\n+                case RRMapFileParser.GOTO_PATH:\n+                    g2d.setColor(Color.GREEN);\n+                    break;\n+                case RRMapFileParser.GOTO_PREDICTED_PATH:\n+                    g2d.setColor(Color.YELLOW);\n+                    break;\n+                default:\n+                    g2d.setColor(Color.CYAN);\n+            }\n+            float prvX = 0;\n+            float prvY = 0;\n+            for (float[] point : rmfp.getPaths().get(pathType)) {\n+                float x = point[0] * scale;\n+                float y = point[1] * scale;\n+                if (prvX > 1) {\n+                    g2d.draw(new Line2D.Float(prvX, prvY, x, y));\n+                }\n+                prvX = x;\n+                prvY = y;\n+            }\n+        }\n+    }\n+\n+    private void drawZones(Graphics2D g2d, float scale) {\n+        for (float[] point : rmfp.getZones()) {\n+            float x = point[0] * scale;\n+            float y = point[1] * scale;\n+            float x1 = point[2] * scale;\n+            float y1 = point[3] * scale;\n+            float sx = Math.min(x, x1);\n+            float w = Math.max(x, x1) - sx;\n+            float sy = Math.min(y, y1);\n+            float h = Math.max(y, y1) - sy;\n+            g2d.setColor(COLOR_ZONES);\n+            g2d.fill(new Rectangle2D.Float(sx, sy, w, h));\n+        }\n+    }\n+\n+    private void drawNoGo(Graphics2D g2d, float scale) {\n+        for (Integer area : rmfp.getAreas().keySet()) {\n+            for (float[] point : rmfp.getAreas().get(area)) {\n+                float x = point[0] * scale;\n+                float y = point[1] * scale;\n+                float x1 = point[2] * scale;\n+                float y1 = point[3] * scale;\n+                float x2 = point[4] * scale;\n+                float y2 = point[5] * scale;\n+                float x3 = point[6] * scale;\n+                float y3 = point[7] * scale;\n+                Path2D noGo = new Path2D.Float();\n+                noGo.moveTo(x, y);\n+                noGo.lineTo(x1, y1);\n+                noGo.lineTo(x2, y2);\n+                noGo.lineTo(x3, y3);\n+                noGo.lineTo(x, y);\n+                g2d.setColor(COLOR_NO_GO_ZONES);\n+                g2d.fill(noGo);\n+                g2d.setColor(area == 9 ? Color.RED : Color.WHITE);\n+                g2d.draw(noGo);\n+            }\n+        }\n+    }\n+\n+    private void drawWalls(Graphics2D g2d, float scale) {\n+        Stroke stroke = new BasicStroke(3 * scale);\n+        g2d.setStroke(stroke);\n+        for (float[] point : rmfp.getWalls()) {\n+            float x = point[0] * scale;\n+            float y = point[1] * scale;\n+            float x1 = point[2] * scale;\n+            float y1 = point[3] * scale;\n+            g2d.setColor(Color.RED);\n+            g2d.draw(new Line2D.Float(x, y, x1, y1));\n+        }\n+    }\n+\n+    private void drawRobo(Graphics2D g2d, float scale) {\n+        float radius = 3 * scale;\n+        Stroke stroke = new BasicStroke(2 * scale);\n+        g2d.setStroke(stroke);\n+        g2d.setColor(COLOR_CHARGER_HALO);\n+        drawCircle(g2d, rmfp.getChargerX() * scale, rmfp.getChargerY() * scale, radius);\n+        drawCenteredImg(g2d, scale / 8, \"charger.png\", rmfp.getChargerX() * scale, rmfp.getChargerY() * scale);\n+        radius = 3 * scale;\n+        g2d.setColor(COLOR_ROBO);\n+        drawCircle(g2d, rmfp.getRoboX() * scale, rmfp.getRoboY() * scale, radius);\n+        if (scale > 1.5) {\n+            drawCenteredImg(g2d, scale / 15, \"robo.png\", rmfp.getRoboX() * scale, rmfp.getRoboY() * scale);\n+        }\n+    }\n+\n+    private void drawCircle(Graphics2D g2d, float x, float y, float radius) {\n+        g2d.draw(new Ellipse2D.Double(x - radius, y - radius, 2.0 * radius, 2.0 * radius));\n+    }\n+\n+    private void drawCenteredImg(Graphics2D g2d, float scale, String imgFile, float x, float y) {\n+        URL image = getImageUrl(imgFile);\n+        try {\n+            if (image != null) {\n+                BufferedImage addImg = ImageIO.read(image);\n+                int xpos = Math.round(x - (addImg.getWidth() / 2 * scale));\n+                int ypos = Math.round(y - (addImg.getHeight() / 2 * scale));\n+                AffineTransform at = new AffineTransform();\n+                at.scale(scale, scale);\n+                AffineTransformOp scaleOp = new AffineTransformOp(at, AffineTransformOp.TYPE_BILINEAR);\n+                g2d.drawImage(addImg, scaleOp, xpos, ypos);\n+            } else {\n+                logger.debug(\"Error loading image {}: File not be found.\", imgFile);\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error loading image {}: {}\", image, e.getMessage());\n+        }\n+    }\n+\n+    private void drawGoTo(Graphics2D g2d, float scale) {\n+        float x = rmfp.getGotoX() * scale;\n+        float y = rmfp.getGotoY() * scale;\n+        if (!(x == 0 && y == 0)) {\n+            g2d.setStroke(new BasicStroke());\n+            g2d.setColor(Color.YELLOW);\n+            int x3[] = { (int) x, (int) (x - 2 * scale), (int) (x + 2 * scale) };\n+            int y3[] = { (int) y, (int) (y - 5 * scale), (int) (y - 5 * scale) };", "originalCommit": "fdf64d48c30163727a4ae882ecebdc43fbe21ab6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkzOTA0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r403939042", "bodyText": "It is suppose to draw a triangle. Bottom of the triangle at the xy", "author": "marcelrv", "createdAt": "2020-04-06T09:08:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc4NDgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc4NjY3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r403786674", "bodyText": "Can you make this an enum instead?", "author": "cpmeister", "createdAt": "2020-04-06T01:14:32Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/CloudConnector.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.miio.internal.cloud;\n+\n+import static org.openhab.binding.miio.internal.MiIoBindingConstants.BINDING_ID;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link CloudConnector} is responsible for connecting OH to the Xiaomi cloud communication.\n+ *\n+ * @author Marcel Verpaalen - Initial contribution\n+ */\n+@Component(service = CloudConnector.class)\n+@NonNullByDefault\n+public class CloudConnector {\n+\n+    protected static final long CACHE_EXPIRY = TimeUnit.SECONDS.toMillis(60);\n+    private static final int FAILED = -1;\n+    private static final int STARTING = 0;\n+    private static final int REFRESHING = 1;\n+    private static final int AVAILABLE = 2;\n+    private volatile int deviceListState = STARTING;", "originalCommit": "fdf64d48c30163727a4ae882ecebdc43fbe21ab6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c6dec0f194d2428d11d5081cb1f01e4ec2b23ddb", "url": "https://github.com/openhab/openhab-addons/commit/c6dec0f194d2428d11d5081cb1f01e4ec2b23ddb", "message": "Apply suggestions from code review\r\n\r\nSigned-off-by: Marcel Verpaalen marcel@verpaalen.com\n\nCo-Authored-By: cpmeister <mistercpp2000@gmail.com>", "committedDate": "2020-04-06T09:23:29Z", "type": "commit"}, {"oid": "2b100a328dc9c417b3c0cbe7a46e39842e874bb7", "url": "https://github.com/openhab/openhab-addons/commit/2b100a328dc9c417b3c0cbe7a46e39842e874bb7", "message": "[miio] updates based on feedback\n\nSigned-off-by: Marcel Verpaalen <marcel@verpaalen.com>", "committedDate": "2020-04-06T18:16:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQzMDI3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r404430279", "bodyText": "You already have the parent file, so might as well use it.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    File dataFile = new File(DB_FOLDER_NAME + File.separator + \"miioTokens-\" + country + \".json\");\n          \n          \n            \n                    File dataFile = new File(folder, \"miioTokens-\" + country + \".json\");", "author": "cpmeister", "createdAt": "2020-04-06T22:37:56Z", "path": "bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/CloudUtil.java", "diffHunk": "@@ -47,24 +46,22 @@\n public class CloudUtil {\n \n     private static final Random RANDOM = new Random();\n+    private static final String DB_FOLDER_NAME = ConfigConstants.getUserDataFolder() + File.separator\n+            + MiIoBindingConstants.BINDING_ID;\n \n-    public static String getElementString(JsonElement jsonElement, String element, Logger logger) {\n-        String value = \"\";\n-        try {\n-            value = jsonElement.getAsJsonObject().get(element).getAsString();\n-        } catch (IllegalStateException | ClassCastException e) {\n-            logger.debug(\"Json Element {} expected but missing\", element);\n-        }\n-        return value;\n-    }\n-\n-    public static void saveFile(String data, String country, Logger logger) {\n-        String dbFolderName = ConfigConstants.getUserDataFolder() + File.separator + MiIoBindingConstants.BINDING_ID;\n-        File folder = new File(dbFolderName);\n+    /**\n+     * Saves the Xiaomi cloud device info with tokens to file\n+     *\n+     * @param data file content\n+     * @param country county server\n+     * @param logger\n+     */\n+    public static void saveDeviceInfoFile(String data, String country, Logger logger) {\n+        File folder = new File(DB_FOLDER_NAME);\n         if (!folder.exists()) {\n             folder.mkdirs();\n         }\n-        File dataFile = new File(dbFolderName + File.separator + \"miioTokens-\" + country + \".json\");\n+        File dataFile = new File(DB_FOLDER_NAME + File.separator + \"miioTokens-\" + country + \".json\");", "originalCommit": "2b100a328dc9c417b3c0cbe7a46e39842e874bb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU2MDg4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7255#discussion_r404560881", "bodyText": "darn... I should drink more coffee in the evening :-)", "author": "marcelrv", "createdAt": "2020-04-07T06:19:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQzMDI3OQ=="}], "type": "inlineReview"}, {"oid": "da9657eb1f56b498ecd7b364701c52b7cd8aa2ad", "url": "https://github.com/openhab/openhab-addons/commit/da9657eb1f56b498ecd7b364701c52b7cd8aa2ad", "message": "Update bundles/org.openhab.binding.miio/src/main/java/org/openhab/binding/miio/internal/cloud/CloudUtil.java\r\n\r\nSigned-off-by: Marcel Verpaalen <marcel@verpaalen.com>\n\nCo-Authored-By: cpmeister <mistercpp2000@gmail.com>", "committedDate": "2020-04-07T06:18:37Z", "type": "commit"}]}