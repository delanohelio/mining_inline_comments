{"pr_number": 9075, "pr_title": "[mecmeter] Initial contribution of mecmeter binding", "pr_createdAt": "2020-11-19T21:17:27Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/9075", "timeline": [{"oid": "c5b243e8089a05d72dd5e90801953251e4768417", "url": "https://github.com/openhab/openhab-addons/commit/c5b243e8089a05d72dd5e90801953251e4768417", "message": "Introduced UoM and cleaned up code\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2021-03-13T09:45:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU0ODMyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600548329", "bodyText": "What is exactly the contribution of these authors? There don't seem to be any Also-by lines in your commits for them.", "author": "wborn", "createdAt": "2021-03-24T14:47:26Z", "path": "bundles/org.openhab.binding.mecmeter/src/main/java/org/openhab/binding/mecmeter/MecMeterDeviceConfiguration.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mecmeter;\n+\n+/**\n+ * The {@link MecMeterDeviceConfiguration} is the class used to match the\n+ * thing configuration.\n+ *\n+ * @author Florian Pazour - Initial contribution\n+ * @author Klaus Berger - Initial contribution", "originalCommit": "6b864586f55baf5f4e6c3c07835942750efb0573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDc0MTMzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600741331", "bodyText": "Missed to add them. Already got their e-mail addresses, I will squash the commits and add them to the sign-off.", "author": "kaikreuzer", "createdAt": "2021-03-24T18:15:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU0ODMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU0OTAzMg==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600549032", "bodyText": "Looks like you can add @NonNullByDefault on this class.", "author": "wborn", "createdAt": "2021-03-24T14:48:05Z", "path": "bundles/org.openhab.binding.mecmeter/src/main/java/org/openhab/binding/mecmeter/MecMeterDeviceConfiguration.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mecmeter;\n+\n+/**\n+ * The {@link MecMeterDeviceConfiguration} is the class used to match the\n+ * thing configuration.\n+ *\n+ * @author Florian Pazour - Initial contribution\n+ * @author Klaus Berger - Initial contribution\n+ */\n+public class MecMeterDeviceConfiguration {", "originalCommit": "6b864586f55baf5f4e6c3c07835942750efb0573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDc0NTEzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600745139", "bodyText": "done.", "author": "kaikreuzer", "createdAt": "2021-03-24T18:19:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU0OTAzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU0OTc0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600549745", "bodyText": "Can this default constructor implementation be removed?", "author": "wborn", "createdAt": "2021-03-24T14:48:46Z", "path": "bundles/org.openhab.binding.mecmeter/src/main/java/org/openhab/binding/mecmeter/MecMeterDeviceConfiguration.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mecmeter;\n+\n+/**\n+ * The {@link MecMeterDeviceConfiguration} is the class used to match the\n+ * thing configuration.\n+ *\n+ * @author Florian Pazour - Initial contribution\n+ * @author Klaus Berger - Initial contribution\n+ */\n+public class MecMeterDeviceConfiguration {\n+    public String ip = \"\";\n+    public String username = \"admin\";\n+    public String password = \"12345\";\n+    public int refreshInterval = 5;\n+\n+    public MecMeterDeviceConfiguration() {\n+        super();", "originalCommit": "6b864586f55baf5f4e6c3c07835942750efb0573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDc0NTIxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600745219", "bodyText": "done.", "author": "kaikreuzer", "createdAt": "2021-03-24T18:19:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU0OTc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU1MjEwMg==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600552102", "bodyText": "The username is commented in the thing-types.xml, whats up with that and do we still need this in this config?", "author": "wborn", "createdAt": "2021-03-24T14:51:14Z", "path": "bundles/org.openhab.binding.mecmeter/src/main/java/org/openhab/binding/mecmeter/MecMeterDeviceConfiguration.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mecmeter;\n+\n+/**\n+ * The {@link MecMeterDeviceConfiguration} is the class used to match the\n+ * thing configuration.\n+ *\n+ * @author Florian Pazour - Initial contribution\n+ * @author Klaus Berger - Initial contribution\n+ */\n+public class MecMeterDeviceConfiguration {\n+    public String ip = \"\";\n+    public String username = \"admin\";\n+    public String password = \"12345\";\n+    public int refreshInterval = 5;\n+\n+    public MecMeterDeviceConfiguration() {\n+        super();\n+    }\n+\n+    public String getIp() {\n+        return ip;\n+    }\n+\n+    public void setIp(String inetaddress) {\n+        ip = inetaddress;\n+    }\n+\n+    public String getUsername() {\n+        return username;\n+    }\n+\n+    public void setUsername(String user) {\n+        username = user;", "originalCommit": "6b864586f55baf5f4e6c3c07835942750efb0573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDc0NTMzOA==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600745338", "bodyText": "removed.", "author": "kaikreuzer", "createdAt": "2021-03-24T18:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU1MjEwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU1NjQ1NA==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600556454", "bodyText": "You should use .equals to compare the content of the actual string instead of checking if they are the same object instances. What is this magic IP address 192.168.255.1?  Will this cause issues when using different IP ranges in your network?", "author": "wborn", "createdAt": "2021-03-24T14:55:33Z", "path": "bundles/org.openhab.binding.mecmeter/src/main/java/org/openhab/binding/mecmeter/internal/discovery/MecMeterDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mecmeter.internal.discovery;\n+\n+import static org.openhab.binding.mecmeter.MecMeterBindingConstants.THING_TYPE_METER;\n+\n+import java.net.InetAddress;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MecMeterDiscoveryParticipant} is responsible for discovering devices, which are\n+ * sent to inbox.\n+ *\n+ * @author Florian Pazour - Initial contribution\n+ * @author Klaus Berger - Initial contribution\n+ * @author Kai Kreuzer - Refactoring for openHAB 3\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class)\n+public class MecMeterDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private Logger logger = LoggerFactory.getLogger(MecMeterDiscoveryParticipant.class);\n+    private static final String SERVICE_TYPE = \"_http._tcp.local.\";\n+\n+    /**\n+     * Match the serial number, vendor and model of the discovered PowerMeter.\n+     * Input is like \"vpmAA11BB33CC55\"\n+     */\n+    private static final Pattern MECMETER_PATTERN = Pattern\n+            .compile(\"^(vpm|mec)[A-F0-9]{12}\\\\._http\\\\._tcp\\\\.local\\\\.$\");\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return Collections.singleton(THING_TYPE_METER);\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return SERVICE_TYPE;\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        String qualifiedName = service.getQualifiedName();\n+        logger.debug(\"Device found: {}\", qualifiedName);\n+        ThingUID uid = getThingUID(service);\n+        if (uid == null) {\n+            return null;\n+        }\n+\n+        String serial = qualifiedName.substring(3, 15);\n+        String vendor = \"MEC\";\n+\n+        InetAddress ip = getIpAddress(service);\n+        if (ip == null) {\n+            return null;\n+        }\n+        String inetAddress = ip.toString().substring(1);\n+\n+        Map<String, Object> properties = new HashMap<>(2);\n+        properties.put(Thing.PROPERTY_SERIAL_NUMBER, serial);\n+        properties.put(Thing.PROPERTY_VENDOR, vendor);\n+        properties.put(\"ip\", inetAddress);\n+\n+        String label = \"MEC Power Meter\";\n+        DiscoveryResult result = DiscoveryResultBuilder.create(uid).withProperties(properties).withLabel(label)\n+                .withRepresentationProperty(Thing.PROPERTY_SERIAL_NUMBER).build();\n+        return result;\n+    }\n+\n+    private @Nullable InetAddress getIpAddress(ServiceInfo service) {\n+        InetAddress address = null;\n+        for (InetAddress addr : service.getInet4Addresses()) {\n+            if (addr.toString() != \"192.168.255.1\") {", "originalCommit": "6b864586f55baf5f4e6c3c07835942750efb0573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDc1MDM4MA==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600750380", "bodyText": "Looks like some old testing code. Removed it.", "author": "kaikreuzer", "createdAt": "2021-03-24T18:25:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU1NjQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU2MjI1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600562256", "bodyText": "This is a strange check. My IP could be 100.0.0.0 and it will be considered as not set.", "author": "wborn", "createdAt": "2021-03-24T14:58:39Z", "path": "bundles/org.openhab.binding.mecmeter/src/main/java/org/openhab/binding/mecmeter/MecMeterDeviceConfiguration.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mecmeter;\n+\n+/**\n+ * The {@link MecMeterDeviceConfiguration} is the class used to match the\n+ * thing configuration.\n+ *\n+ * @author Florian Pazour - Initial contribution\n+ * @author Klaus Berger - Initial contribution\n+ */\n+public class MecMeterDeviceConfiguration {\n+    public String ip = \"\";\n+    public String username = \"admin\";\n+    public String password = \"12345\";\n+    public int refreshInterval = 5;\n+\n+    public MecMeterDeviceConfiguration() {\n+        super();\n+    }\n+\n+    public String getIp() {\n+        return ip;\n+    }\n+\n+    public void setIp(String inetaddress) {\n+        ip = inetaddress;\n+    }\n+\n+    public String getUsername() {\n+        return username;\n+    }\n+\n+    public void setUsername(String user) {\n+        username = user;\n+    }\n+\n+    public String getPassword() {\n+        return password;\n+    }\n+\n+    public void setPassword(String pw) {\n+        password = pw;\n+    }\n+\n+    public int getRefreshInterval() {\n+        return refreshInterval;\n+    }\n+\n+    public void setRefreshInterval(int ri) {\n+        refreshInterval = ri;\n+    }\n+\n+    public String isValid() {\n+        if (ip == null || ip.isBlank()) {\n+            return \"Missing IP\";\n+        }\n+        if (ip.contains(\"0.0.0.0\")) {", "originalCommit": "6b864586f55baf5f4e6c3c07835942750efb0573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDc1MjAwMw==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600752003", "bodyText": "Indeed. As the IP is mandatory, I only left the blank check.", "author": "kaikreuzer", "createdAt": "2021-03-24T18:26:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU2MjI1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU2NTYwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600565609", "bodyText": "In Java 11 this can be more clear and shorter with:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_METER);\n          \n          \n            \n                private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Set.of(THING_TYPE_METER);\n          \n      \n    \n    \n  \n\nIf you move this to the MecMeterBindingConstants, then it can also be reused in the MecMeterDiscoveryParticipant.", "author": "wborn", "createdAt": "2021-03-24T15:01:23Z", "path": "bundles/org.openhab.binding.mecmeter/src/main/java/org/openhab/binding/mecmeter/internal/MecMeterHandlerFactory.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mecmeter.internal;\n+\n+import static org.openhab.binding.mecmeter.MecMeterBindingConstants.THING_TYPE_METER;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.mecmeter.handler.MecMeterHandler;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link MecMeterHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Florian Pazour - Initial contribution\n+ * @author Klaus Berger - Initial contribution\n+ * @author Kai Kreuzer - Refactoring for openHAB 3\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, configurationPid = \"binding.mecmeter\")\n+public class MecMeterHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_METER);", "originalCommit": "6b864586f55baf5f4e6c3c07835942750efb0573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDc1NTMwOA==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600755308", "bodyText": "done.", "author": "kaikreuzer", "createdAt": "2021-03-24T18:29:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU2NTYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU3Mzk0MA==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600573940", "bodyText": "Why use 2 if you add 3 entries?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Map<String, Object> properties = new HashMap<>(2);\n          \n          \n            \n                    Map<String, Object> properties = new HashMap<>(3);", "author": "wborn", "createdAt": "2021-03-24T15:09:01Z", "path": "bundles/org.openhab.binding.mecmeter/src/main/java/org/openhab/binding/mecmeter/internal/discovery/MecMeterDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mecmeter.internal.discovery;\n+\n+import static org.openhab.binding.mecmeter.MecMeterBindingConstants.THING_TYPE_METER;\n+\n+import java.net.InetAddress;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MecMeterDiscoveryParticipant} is responsible for discovering devices, which are\n+ * sent to inbox.\n+ *\n+ * @author Florian Pazour - Initial contribution\n+ * @author Klaus Berger - Initial contribution\n+ * @author Kai Kreuzer - Refactoring for openHAB 3\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class)\n+public class MecMeterDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private Logger logger = LoggerFactory.getLogger(MecMeterDiscoveryParticipant.class);\n+    private static final String SERVICE_TYPE = \"_http._tcp.local.\";\n+\n+    /**\n+     * Match the serial number, vendor and model of the discovered PowerMeter.\n+     * Input is like \"vpmAA11BB33CC55\"\n+     */\n+    private static final Pattern MECMETER_PATTERN = Pattern\n+            .compile(\"^(vpm|mec)[A-F0-9]{12}\\\\._http\\\\._tcp\\\\.local\\\\.$\");\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return Collections.singleton(THING_TYPE_METER);\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return SERVICE_TYPE;\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        String qualifiedName = service.getQualifiedName();\n+        logger.debug(\"Device found: {}\", qualifiedName);\n+        ThingUID uid = getThingUID(service);\n+        if (uid == null) {\n+            return null;\n+        }\n+\n+        String serial = qualifiedName.substring(3, 15);\n+        String vendor = \"MEC\";\n+\n+        InetAddress ip = getIpAddress(service);\n+        if (ip == null) {\n+            return null;\n+        }\n+        String inetAddress = ip.toString().substring(1);\n+\n+        Map<String, Object> properties = new HashMap<>(2);", "originalCommit": "6b864586f55baf5f4e6c3c07835942750efb0573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDc1NjU2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600756569", "bodyText": "fixed.", "author": "kaikreuzer", "createdAt": "2021-03-24T18:30:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU3Mzk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU3NzA3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600577079", "bodyText": "SAT warnings about missing @NonNullByDefault can be prevented by moving it to another package:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            package org.openhab.binding.mecmeter.internal.api;\n          \n          \n            \n            package org.openhab.binding.mecmeter.internal.dto;", "author": "wborn", "createdAt": "2021-03-24T15:12:06Z", "path": "bundles/org.openhab.binding.mecmeter/src/main/java/org/openhab/binding/mecmeter/internal/api/MecMeterResponse.java", "diffHunk": "@@ -0,0 +1,856 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mecmeter.internal.api;", "originalCommit": "6b864586f55baf5f4e6c3c07835942750efb0573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDc1NzM1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600757355", "bodyText": "Didn't know, thanks. Moved.", "author": "kaikreuzer", "createdAt": "2021-03-24T18:31:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU3NzA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU3Nzk0OA==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600577948", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* Konstanten */\n          \n          \n            \n                /* Constants */", "author": "wborn", "createdAt": "2021-03-24T15:13:02Z", "path": "bundles/org.openhab.binding.mecmeter/src/main/java/org/openhab/binding/mecmeter/internal/api/MecMeterResponse.java", "diffHunk": "@@ -0,0 +1,856 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mecmeter.internal.api;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * The {@link MecMeterResponse} is responsible for storing\n+ * the \"data\" node of the JSON response\n+ *\n+ * @author Florian Pazour - Initial contribution\n+ * @author Klaus Berger - Initial contribution\n+ * @author Kai Kreuzer - Refactoring for openHAB 3\n+ */\n+public class MecMeterResponse {\n+    /* General */\n+    @SerializedName(\"F\")\n+    private float frequency;\n+    @SerializedName(\"T\")\n+    private float temperature;\n+    @SerializedName(\"TIME\")\n+    private long operationalTime;\n+\n+    /* Voltage */\n+    @SerializedName(\"VA\")\n+    private float voltagePhase1;\n+    @SerializedName(\"VB\")\n+    private float voltagePhase2;\n+    @SerializedName(\"VC\")\n+    private float voltagePhase3;\n+    @SerializedName(\"VCB\")\n+    private float voltagePhase3ToPhase2;\n+    @SerializedName(\"VBA\")\n+    private float voltagePhase2ToPhase1;\n+    @SerializedName(\"VAC\")\n+    private float voltagePhase1ToPhase3;\n+    @SerializedName(\"VPT\")\n+    private float averageVoltagePhaseToPhase;\n+    @SerializedName(\"VT\")\n+    private float averageVoltageNeutralToPhase;\n+\n+    /* Current */\n+    @SerializedName(\"IA\")\n+    private float currentPhase1;\n+    @SerializedName(\"IB\")\n+    private float currentPhase2;\n+    @SerializedName(\"IC\")\n+    private float currentPhase3;\n+    @SerializedName(\"IN\")\n+    private float currentSum;\n+\n+    /* Angles */\n+    @SerializedName(\"IAA\")\n+    private float phaseAngleCurrentToVoltagePhase1;\n+    @SerializedName(\"IAB\")\n+    private float phaseAngleCurrentToVoltagePhase2;\n+    @SerializedName(\"IAC\")\n+    private float phaseAngleCurrentToVoltagePhase3;\n+    @SerializedName(\"UAA\")\n+    private float phaseAnglePhase1To3;\n+    @SerializedName(\"UAB\")\n+    private float phaseAnglePhase2To3;\n+\n+    /* Power */\n+    @SerializedName(\"PA\")\n+    private float activePowerPhase1;\n+    @SerializedName(\"PB\")\n+    private float activePowerPhase2;\n+    @SerializedName(\"PC\")\n+    private float activePowerPhase3;\n+    @SerializedName(\"PT\")\n+    private float activePowerSum;\n+\n+    @SerializedName(\"PAF\")\n+    private float activeFundamentalPowerPhase1;\n+    @SerializedName(\"PBF\")\n+    private float activeFundamentalPowerPhase2;\n+    @SerializedName(\"PCF\")\n+    private float activeFundamentalPowerPhase3;\n+    @SerializedName(\"PTF\")\n+    private float activeFundamentalPowerSum;\n+\n+    @SerializedName(\"PFA\")\n+    private float powerFactorPhase1;\n+    @SerializedName(\"PFB\")\n+    private float powerFactorPhase2;\n+    @SerializedName(\"PFC\")\n+    private float powerFactorPhase3;\n+    @SerializedName(\"PFT\")\n+    private float powerFactorSum;\n+\n+    @SerializedName(\"PAH\")\n+    private float activeHarmonicPowerPhase1;\n+    @SerializedName(\"PBH\")\n+    private float activeHarmonicPowerPhase2;\n+    @SerializedName(\"PCH\")\n+    private float activeHarmonicPowerPhase3;\n+    @SerializedName(\"PTH\")\n+    private float activeHarmonicPowerSum;\n+\n+    @SerializedName(\"QA\")\n+    private float reactivePowerPhase1;\n+    @SerializedName(\"QB\")\n+    private float reactivePowerPhase2;\n+    @SerializedName(\"QC\")\n+    private float reactivePowerPhase3;\n+    @SerializedName(\"QT\")\n+    private float reactivePowerSum;\n+\n+    @SerializedName(\"SA\")\n+    private float apparentPowerPhase1;\n+    @SerializedName(\"SB\")\n+    private float apparentPowerPhase2;\n+    @SerializedName(\"SC\")\n+    private float apparentPowerPhase3;\n+    @SerializedName(\"ST\")\n+    private float apparentPowerSum;\n+\n+    /* Forward Energy */\n+    @SerializedName(\"EFAA\")\n+    private float forwardActiveEnergyPhase1;\n+    @SerializedName(\"EFAB\")\n+    private float forwardActiveEnergyPhase2;\n+    @SerializedName(\"EFAC\")\n+    private float forwardActiveEnergyPhase3;\n+    @SerializedName(\"EFAT\")\n+    private float forwardActiveEnergySum;\n+\n+    @SerializedName(\"EFAF\")\n+    private float forwardActiveFundamentalEnergyPhase1;\n+    @SerializedName(\"EFBF\")\n+    private float forwardActiveFundamentalEnergyPhase2;\n+    @SerializedName(\"EFCF\")\n+    private float forwardActiveFundamentalEnergyPhase3;\n+    @SerializedName(\"EFTF\")\n+    private float forwardActiveFundamentalEnergySum;\n+\n+    @SerializedName(\"EFAH\")\n+    private float forwardActiveHarmonicEnergyPhase1;\n+    @SerializedName(\"EFBH\")\n+    private float forwardActiveHarmonicEnergyPhase2;\n+    @SerializedName(\"EFCH\")\n+    private float forwardActiveHarmonicEnergyPhase3;\n+    @SerializedName(\"EFTH\")\n+    private float forwardActiveHarmonicEnergySum;\n+\n+    @SerializedName(\"EFRA\")\n+    private float forwardReactiveEnergyPhase1;\n+    @SerializedName(\"EFRB\")\n+    private float forwardReactiveEnergyPhase2;\n+    @SerializedName(\"EFRC\")\n+    private float forwardReactiveEnergyPhase3;\n+    @SerializedName(\"EFRT\")\n+    private float forwardReactiveEnergySum;\n+\n+    /* Reverse Energy */\n+    @SerializedName(\"ERAA\")\n+    private float reverseActiveEnergyPhase1;\n+    @SerializedName(\"ERAB\")\n+    private float reverseActiveEnergyPhase2;\n+    @SerializedName(\"ERAC\")\n+    private float reverseActiveEnergyPhase3;\n+    @SerializedName(\"ERAT\")\n+    private float reverseActiveEnergySum;\n+\n+    @SerializedName(\"ERAF\")\n+    private float reverseActiveFundamentalEnergyPhase1;\n+    @SerializedName(\"ERBF\")\n+    private float reverseActiveFundamentalEnergyPhase2;\n+    @SerializedName(\"ERCF\")\n+    private float reverseActiveFundamentalEnergyPhase3;\n+    @SerializedName(\"ERTF\")\n+    private float reverseActiveFundamentalEnergySum;\n+\n+    @SerializedName(\"ERAH\")\n+    private float reverseActiveHarmonicEnergyPhase1;\n+    @SerializedName(\"ERBH\")\n+    private float reverseActiveHarmonicEnergyPhase2;\n+    @SerializedName(\"ERCH\")\n+    private float reverseActiveHarmonicEnergyPhase3;\n+    @SerializedName(\"ERTH\")\n+    private float reverseActiveHarmonicEnergySum;\n+\n+    @SerializedName(\"ERRA\")\n+    private float reverseReactiveEnergyPhase1;\n+    @SerializedName(\"ERRB\")\n+    private float reverseReactiveEnergyPhase2;\n+    @SerializedName(\"ERRC\")\n+    private float reverseReactiveEnergyPhase3;\n+    @SerializedName(\"ERRT\")\n+    private float reverseReactiveEnergySum;\n+\n+    /* apparent Energy */\n+    @SerializedName(\"ESA\")\n+    private float apparentEnergyConsumptionPhase1;\n+    @SerializedName(\"ESB\")\n+    private float apparentEnergyConsumptionPhase2;\n+    @SerializedName(\"ESC\")\n+    private float apparentEnergyConsumptionPhase3;\n+    @SerializedName(\"EST\")\n+    private float apparentEnergyConsumptionSum;\n+\n+    /* Konstanten */", "originalCommit": "6b864586f55baf5f4e6c3c07835942750efb0573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDc1Nzc4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600757781", "bodyText": "fixed.", "author": "kaikreuzer", "createdAt": "2021-03-24T18:32:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU3Nzk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU3OTQ2NA==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600579464", "bodyText": "Useless assignment:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    DiscoveryResult result = DiscoveryResultBuilder.create(uid).withProperties(properties).withLabel(label)\n          \n          \n            \n                            .withRepresentationProperty(Thing.PROPERTY_SERIAL_NUMBER).build();\n          \n          \n            \n                    return result;\n          \n          \n            \n                    return DiscoveryResultBuilder.create(uid).withProperties(properties).withLabel(label)\n          \n          \n            \n                            .withRepresentationProperty(Thing.PROPERTY_SERIAL_NUMBER).build();", "author": "wborn", "createdAt": "2021-03-24T15:14:46Z", "path": "bundles/org.openhab.binding.mecmeter/src/main/java/org/openhab/binding/mecmeter/internal/discovery/MecMeterDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mecmeter.internal.discovery;\n+\n+import static org.openhab.binding.mecmeter.MecMeterBindingConstants.THING_TYPE_METER;\n+\n+import java.net.InetAddress;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MecMeterDiscoveryParticipant} is responsible for discovering devices, which are\n+ * sent to inbox.\n+ *\n+ * @author Florian Pazour - Initial contribution\n+ * @author Klaus Berger - Initial contribution\n+ * @author Kai Kreuzer - Refactoring for openHAB 3\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class)\n+public class MecMeterDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private Logger logger = LoggerFactory.getLogger(MecMeterDiscoveryParticipant.class);\n+    private static final String SERVICE_TYPE = \"_http._tcp.local.\";\n+\n+    /**\n+     * Match the serial number, vendor and model of the discovered PowerMeter.\n+     * Input is like \"vpmAA11BB33CC55\"\n+     */\n+    private static final Pattern MECMETER_PATTERN = Pattern\n+            .compile(\"^(vpm|mec)[A-F0-9]{12}\\\\._http\\\\._tcp\\\\.local\\\\.$\");\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return Collections.singleton(THING_TYPE_METER);\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return SERVICE_TYPE;\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        String qualifiedName = service.getQualifiedName();\n+        logger.debug(\"Device found: {}\", qualifiedName);\n+        ThingUID uid = getThingUID(service);\n+        if (uid == null) {\n+            return null;\n+        }\n+\n+        String serial = qualifiedName.substring(3, 15);\n+        String vendor = \"MEC\";\n+\n+        InetAddress ip = getIpAddress(service);\n+        if (ip == null) {\n+            return null;\n+        }\n+        String inetAddress = ip.toString().substring(1);\n+\n+        Map<String, Object> properties = new HashMap<>(2);\n+        properties.put(Thing.PROPERTY_SERIAL_NUMBER, serial);\n+        properties.put(Thing.PROPERTY_VENDOR, vendor);\n+        properties.put(\"ip\", inetAddress);\n+\n+        String label = \"MEC Power Meter\";\n+        DiscoveryResult result = DiscoveryResultBuilder.create(uid).withProperties(properties).withLabel(label)\n+                .withRepresentationProperty(Thing.PROPERTY_SERIAL_NUMBER).build();\n+        return result;", "originalCommit": "6b864586f55baf5f4e6c3c07835942750efb0573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDc1ODUzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600758531", "bodyText": "fixed.", "author": "kaikreuzer", "createdAt": "2021-03-24T18:32:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU3OTQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU5MDIxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600590214", "bodyText": "The password is required so it cannot be null.", "author": "wborn", "createdAt": "2021-03-24T15:26:19Z", "path": "bundles/org.openhab.binding.mecmeter/src/main/java/org/openhab/binding/mecmeter/MecMeterDeviceConfiguration.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mecmeter;\n+\n+/**\n+ * The {@link MecMeterDeviceConfiguration} is the class used to match the\n+ * thing configuration.\n+ *\n+ * @author Florian Pazour - Initial contribution\n+ * @author Klaus Berger - Initial contribution\n+ */\n+public class MecMeterDeviceConfiguration {\n+    public String ip = \"\";\n+    public String username = \"admin\";\n+    public String password = \"12345\";\n+    public int refreshInterval = 5;\n+\n+    public MecMeterDeviceConfiguration() {\n+        super();\n+    }\n+\n+    public String getIp() {\n+        return ip;\n+    }\n+\n+    public void setIp(String inetaddress) {\n+        ip = inetaddress;\n+    }\n+\n+    public String getUsername() {\n+        return username;\n+    }\n+\n+    public void setUsername(String user) {\n+        username = user;\n+    }\n+\n+    public String getPassword() {\n+        return password;\n+    }\n+\n+    public void setPassword(String pw) {\n+        password = pw;\n+    }\n+\n+    public int getRefreshInterval() {\n+        return refreshInterval;\n+    }\n+\n+    public void setRefreshInterval(int ri) {\n+        refreshInterval = ri;\n+    }\n+\n+    public String isValid() {\n+        if (ip == null || ip.isBlank()) {\n+            return \"Missing IP\";\n+        }\n+        if (ip.contains(\"0.0.0.0\")) {\n+            return \"IP not set\";\n+        }\n+        if (username == null || username.isBlank()) {\n+            return \"username is missing\";\n+        }\n+        if (password == null || password.isBlank()) {", "originalCommit": "6b864586f55baf5f4e6c3c07835942750efb0573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDY0OTk4NA==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600649984", "bodyText": "What happens if the user forgets to specify the parameter in textual configuration?", "author": "fwolter", "createdAt": "2021-03-24T16:26:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU5MDIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDc1OTYwNw==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600759607", "bodyText": "@fwolter The Thing won't be initialized, if some mandatory parameter is missing.", "author": "kaikreuzer", "createdAt": "2021-03-24T18:33:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU5MDIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU5MDkzOA==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600590938", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private ScheduledFuture<?> pollFuture;\n          \n          \n            \n                private @Nullable ScheduledFuture<?> pollFuture;", "author": "wborn", "createdAt": "2021-03-24T15:27:03Z", "path": "bundles/org.openhab.binding.mecmeter/src/main/java/org/openhab/binding/mecmeter/handler/MecMeterHandler.java", "diffHunk": "@@ -0,0 +1,412 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mecmeter.handler;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Base64;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.openhab.binding.mecmeter.MecMeterBindingConstants;\n+import org.openhab.binding.mecmeter.MecMeterDeviceConfiguration;\n+import org.openhab.binding.mecmeter.internal.api.MecMeterResponse;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MecMeterHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Florian Pazour - Initial contribution\n+ * @author Klaus Berger - Initial contribution\n+ * @author Kai Kreuzer - Refactoring for openHAB 3\n+ */\n+@NonNullByDefault\n+public class MecMeterHandler extends BaseThingHandler {\n+\n+    private static final int API_TIMEOUT = 5000; // set on 5000ms - not specified in datasheet\n+\n+    private final Logger logger = LoggerFactory.getLogger(MecMeterHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    private final HttpClient httpClient;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollFuture;", "originalCommit": "6b864586f55baf5f4e6c3c07835942750efb0573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDc2MDA5OA==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600760098", "bodyText": "fixed.", "author": "kaikreuzer", "createdAt": "2021-03-24T18:34:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU5MDkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU5MTIzMw==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600591233", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private MecMeterResponse powerMeterResponse;\n          \n          \n            \n                private @Nullable MecMeterResponse powerMeterResponse;", "author": "wborn", "createdAt": "2021-03-24T15:27:18Z", "path": "bundles/org.openhab.binding.mecmeter/src/main/java/org/openhab/binding/mecmeter/handler/MecMeterHandler.java", "diffHunk": "@@ -0,0 +1,412 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mecmeter.handler;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Base64;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.openhab.binding.mecmeter.MecMeterBindingConstants;\n+import org.openhab.binding.mecmeter.MecMeterDeviceConfiguration;\n+import org.openhab.binding.mecmeter.internal.api.MecMeterResponse;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MecMeterHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Florian Pazour - Initial contribution\n+ * @author Klaus Berger - Initial contribution\n+ * @author Kai Kreuzer - Refactoring for openHAB 3\n+ */\n+@NonNullByDefault\n+public class MecMeterHandler extends BaseThingHandler {\n+\n+    private static final int API_TIMEOUT = 5000; // set on 5000ms - not specified in datasheet\n+\n+    private final Logger logger = LoggerFactory.getLogger(MecMeterHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    private final HttpClient httpClient;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollFuture;\n+\n+    @Nullable\n+    private MecMeterResponse powerMeterResponse;", "originalCommit": "6b864586f55baf5f4e6c3c07835942750efb0573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDc2MDMzNA==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600760334", "bodyText": "fixed.", "author": "kaikreuzer", "createdAt": "2021-03-24T18:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU5MTIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU5MjMyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600592329", "bodyText": "There is no such parameter.", "author": "wborn", "createdAt": "2021-03-24T15:28:24Z", "path": "bundles/org.openhab.binding.mecmeter/src/main/java/org/openhab/binding/mecmeter/handler/MecMeterHandler.java", "diffHunk": "@@ -0,0 +1,412 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mecmeter.handler;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Base64;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.openhab.binding.mecmeter.MecMeterBindingConstants;\n+import org.openhab.binding.mecmeter.MecMeterDeviceConfiguration;\n+import org.openhab.binding.mecmeter.internal.api.MecMeterResponse;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MecMeterHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Florian Pazour - Initial contribution\n+ * @author Klaus Berger - Initial contribution\n+ * @author Kai Kreuzer - Refactoring for openHAB 3\n+ */\n+@NonNullByDefault\n+public class MecMeterHandler extends BaseThingHandler {\n+\n+    private static final int API_TIMEOUT = 5000; // set on 5000ms - not specified in datasheet\n+\n+    private final Logger logger = LoggerFactory.getLogger(MecMeterHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    private final HttpClient httpClient;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollFuture;\n+\n+    @Nullable\n+    private MecMeterResponse powerMeterResponse;\n+\n+    public MecMeterHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId());\n+        } else {\n+            logger.debug(\"Received unsupported command {}.\", command);\n+        }\n+    }\n+\n+    /**\n+     * function which is called to refresh the data\n+     */\n+    public void refresh() {\n+        updateData();\n+        updateChannels();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        logger.debug(\"removing thing..\");\n+        if (pollFuture != null) {\n+            pollFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MecMeterDeviceConfiguration config = getConfig().as(MecMeterDeviceConfiguration.class);\n+        String configCheck = config.isValid();\n+\n+        if (configCheck != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configCheck);\n+            return;\n+        }\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        if (pollFuture != null) {\n+            pollFuture.cancel(false);\n+        }\n+        pollFuture = scheduler.scheduleWithFixedDelay(() -> {\n+            refresh();\n+        }, 0, config.refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Get new data\n+     * Function to save Response of the powermeter\n+     *\n+     * @param config powermeter config ( ip, user, pwd )", "originalCommit": "6b864586f55baf5f4e6c3c07835942750efb0573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDc2MDc0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600760747", "bodyText": "fixed.", "author": "kaikreuzer", "createdAt": "2021-03-24T18:35:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU5MjMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU5Mjc5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600592792", "bodyText": "There is no such parameter.", "author": "wborn", "createdAt": "2021-03-24T15:28:49Z", "path": "bundles/org.openhab.binding.mecmeter/src/main/java/org/openhab/binding/mecmeter/handler/MecMeterHandler.java", "diffHunk": "@@ -0,0 +1,412 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mecmeter.handler;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Base64;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.openhab.binding.mecmeter.MecMeterBindingConstants;\n+import org.openhab.binding.mecmeter.MecMeterDeviceConfiguration;\n+import org.openhab.binding.mecmeter.internal.api.MecMeterResponse;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MecMeterHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Florian Pazour - Initial contribution\n+ * @author Klaus Berger - Initial contribution\n+ * @author Kai Kreuzer - Refactoring for openHAB 3\n+ */\n+@NonNullByDefault\n+public class MecMeterHandler extends BaseThingHandler {\n+\n+    private static final int API_TIMEOUT = 5000; // set on 5000ms - not specified in datasheet\n+\n+    private final Logger logger = LoggerFactory.getLogger(MecMeterHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    private final HttpClient httpClient;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollFuture;\n+\n+    @Nullable\n+    private MecMeterResponse powerMeterResponse;\n+\n+    public MecMeterHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId());\n+        } else {\n+            logger.debug(\"Received unsupported command {}.\", command);\n+        }\n+    }\n+\n+    /**\n+     * function which is called to refresh the data\n+     */\n+    public void refresh() {\n+        updateData();\n+        updateChannels();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        logger.debug(\"removing thing..\");\n+        if (pollFuture != null) {\n+            pollFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MecMeterDeviceConfiguration config = getConfig().as(MecMeterDeviceConfiguration.class);\n+        String configCheck = config.isValid();\n+\n+        if (configCheck != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configCheck);\n+            return;\n+        }\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        if (pollFuture != null) {\n+            pollFuture.cancel(false);\n+        }\n+        pollFuture = scheduler.scheduleWithFixedDelay(() -> {\n+            refresh();\n+        }, 0, config.refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Get new data\n+     * Function to save Response of the powermeter\n+     *\n+     * @param config powermeter config ( ip, user, pwd )\n+     */\n+    private void updateData() {\n+        powerMeterResponse = getRealtimeData();\n+    }\n+\n+    /**\n+     * Get new realtime data over the network\n+     *\n+     * @param config powermeter config ( ip, user, pwd )", "originalCommit": "6b864586f55baf5f4e6c3c07835942750efb0573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDc2MTAzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600761031", "bodyText": "fixed.", "author": "kaikreuzer", "createdAt": "2021-03-24T18:35:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU5Mjc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU5NTcyMA==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600595720", "bodyText": "This can be done without Jetty utility classes:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                new String(config.username + \":\" + config.password).getBytes(StringUtil.__ISO_8859_1));\n          \n          \n            \n                                new String(config.username + \":\" + config.password).getBytes(StandardCharsets.ISO_8859_1));", "author": "wborn", "createdAt": "2021-03-24T15:31:53Z", "path": "bundles/org.openhab.binding.mecmeter/src/main/java/org/openhab/binding/mecmeter/handler/MecMeterHandler.java", "diffHunk": "@@ -0,0 +1,412 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mecmeter.handler;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Base64;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.openhab.binding.mecmeter.MecMeterBindingConstants;\n+import org.openhab.binding.mecmeter.MecMeterDeviceConfiguration;\n+import org.openhab.binding.mecmeter.internal.api.MecMeterResponse;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MecMeterHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Florian Pazour - Initial contribution\n+ * @author Klaus Berger - Initial contribution\n+ * @author Kai Kreuzer - Refactoring for openHAB 3\n+ */\n+@NonNullByDefault\n+public class MecMeterHandler extends BaseThingHandler {\n+\n+    private static final int API_TIMEOUT = 5000; // set on 5000ms - not specified in datasheet\n+\n+    private final Logger logger = LoggerFactory.getLogger(MecMeterHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    private final HttpClient httpClient;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollFuture;\n+\n+    @Nullable\n+    private MecMeterResponse powerMeterResponse;\n+\n+    public MecMeterHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId());\n+        } else {\n+            logger.debug(\"Received unsupported command {}.\", command);\n+        }\n+    }\n+\n+    /**\n+     * function which is called to refresh the data\n+     */\n+    public void refresh() {\n+        updateData();\n+        updateChannels();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        logger.debug(\"removing thing..\");\n+        if (pollFuture != null) {\n+            pollFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MecMeterDeviceConfiguration config = getConfig().as(MecMeterDeviceConfiguration.class);\n+        String configCheck = config.isValid();\n+\n+        if (configCheck != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configCheck);\n+            return;\n+        }\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        if (pollFuture != null) {\n+            pollFuture.cancel(false);\n+        }\n+        pollFuture = scheduler.scheduleWithFixedDelay(() -> {\n+            refresh();\n+        }, 0, config.refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Get new data\n+     * Function to save Response of the powermeter\n+     *\n+     * @param config powermeter config ( ip, user, pwd )\n+     */\n+    private void updateData() {\n+        powerMeterResponse = getRealtimeData();\n+    }\n+\n+    /**\n+     * Get new realtime data over the network\n+     *\n+     * @param config powermeter config ( ip, user, pwd )\n+     * @return PowerMeterResponse class where json values \"are saved\"\n+     */\n+    private @Nullable MecMeterResponse getRealtimeData() {\n+        MecMeterResponse result = null;\n+        boolean resultOk = false;\n+        String errorMsg = null;\n+\n+        MecMeterDeviceConfiguration config = getConfig().as(MecMeterDeviceConfiguration.class);\n+\n+        try {\n+            String basicAuthentication = \"Basic \" + Base64.getEncoder().encodeToString(\n+                    new String(config.username + \":\" + config.password).getBytes(StringUtil.__ISO_8859_1));", "originalCommit": "6b864586f55baf5f4e6c3c07835942750efb0573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDc2MTU0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600761547", "bodyText": "Indeed. Fixed.", "author": "kaikreuzer", "createdAt": "2021-03-24T18:35:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU5NTcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU5NTgyMA==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600595820", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return PowerMeterResponse class where json values \"are saved\"\n          \n          \n            \n                 * @return MecMeterResponse class where json values \"are saved\"", "author": "wborn", "createdAt": "2021-03-24T15:32:01Z", "path": "bundles/org.openhab.binding.mecmeter/src/main/java/org/openhab/binding/mecmeter/handler/MecMeterHandler.java", "diffHunk": "@@ -0,0 +1,412 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mecmeter.handler;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Base64;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.openhab.binding.mecmeter.MecMeterBindingConstants;\n+import org.openhab.binding.mecmeter.MecMeterDeviceConfiguration;\n+import org.openhab.binding.mecmeter.internal.api.MecMeterResponse;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MecMeterHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Florian Pazour - Initial contribution\n+ * @author Klaus Berger - Initial contribution\n+ * @author Kai Kreuzer - Refactoring for openHAB 3\n+ */\n+@NonNullByDefault\n+public class MecMeterHandler extends BaseThingHandler {\n+\n+    private static final int API_TIMEOUT = 5000; // set on 5000ms - not specified in datasheet\n+\n+    private final Logger logger = LoggerFactory.getLogger(MecMeterHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    private final HttpClient httpClient;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollFuture;\n+\n+    @Nullable\n+    private MecMeterResponse powerMeterResponse;\n+\n+    public MecMeterHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId());\n+        } else {\n+            logger.debug(\"Received unsupported command {}.\", command);\n+        }\n+    }\n+\n+    /**\n+     * function which is called to refresh the data\n+     */\n+    public void refresh() {\n+        updateData();\n+        updateChannels();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        logger.debug(\"removing thing..\");\n+        if (pollFuture != null) {\n+            pollFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MecMeterDeviceConfiguration config = getConfig().as(MecMeterDeviceConfiguration.class);\n+        String configCheck = config.isValid();\n+\n+        if (configCheck != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configCheck);\n+            return;\n+        }\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        if (pollFuture != null) {\n+            pollFuture.cancel(false);\n+        }\n+        pollFuture = scheduler.scheduleWithFixedDelay(() -> {\n+            refresh();\n+        }, 0, config.refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Get new data\n+     * Function to save Response of the powermeter\n+     *\n+     * @param config powermeter config ( ip, user, pwd )\n+     */\n+    private void updateData() {\n+        powerMeterResponse = getRealtimeData();\n+    }\n+\n+    /**\n+     * Get new realtime data over the network\n+     *\n+     * @param config powermeter config ( ip, user, pwd )\n+     * @return PowerMeterResponse class where json values \"are saved\"", "originalCommit": "6b864586f55baf5f4e6c3c07835942750efb0573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDc2MjQyMA==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600762420", "bodyText": "fixed.", "author": "kaikreuzer", "createdAt": "2021-03-24T18:36:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU5NTgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU5NjEzOA==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600596138", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            errorMsg = \"Reading meter did not succeeed: \" + response.getReason();\n          \n          \n            \n                            errorMsg = \"Reading meter did not succeed: \" + response.getReason();", "author": "wborn", "createdAt": "2021-03-24T15:32:23Z", "path": "bundles/org.openhab.binding.mecmeter/src/main/java/org/openhab/binding/mecmeter/handler/MecMeterHandler.java", "diffHunk": "@@ -0,0 +1,412 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mecmeter.handler;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Base64;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.openhab.binding.mecmeter.MecMeterBindingConstants;\n+import org.openhab.binding.mecmeter.MecMeterDeviceConfiguration;\n+import org.openhab.binding.mecmeter.internal.api.MecMeterResponse;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MecMeterHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Florian Pazour - Initial contribution\n+ * @author Klaus Berger - Initial contribution\n+ * @author Kai Kreuzer - Refactoring for openHAB 3\n+ */\n+@NonNullByDefault\n+public class MecMeterHandler extends BaseThingHandler {\n+\n+    private static final int API_TIMEOUT = 5000; // set on 5000ms - not specified in datasheet\n+\n+    private final Logger logger = LoggerFactory.getLogger(MecMeterHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    private final HttpClient httpClient;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollFuture;\n+\n+    @Nullable\n+    private MecMeterResponse powerMeterResponse;\n+\n+    public MecMeterHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId());\n+        } else {\n+            logger.debug(\"Received unsupported command {}.\", command);\n+        }\n+    }\n+\n+    /**\n+     * function which is called to refresh the data\n+     */\n+    public void refresh() {\n+        updateData();\n+        updateChannels();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        logger.debug(\"removing thing..\");\n+        if (pollFuture != null) {\n+            pollFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MecMeterDeviceConfiguration config = getConfig().as(MecMeterDeviceConfiguration.class);\n+        String configCheck = config.isValid();\n+\n+        if (configCheck != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configCheck);\n+            return;\n+        }\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        if (pollFuture != null) {\n+            pollFuture.cancel(false);\n+        }\n+        pollFuture = scheduler.scheduleWithFixedDelay(() -> {\n+            refresh();\n+        }, 0, config.refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Get new data\n+     * Function to save Response of the powermeter\n+     *\n+     * @param config powermeter config ( ip, user, pwd )\n+     */\n+    private void updateData() {\n+        powerMeterResponse = getRealtimeData();\n+    }\n+\n+    /**\n+     * Get new realtime data over the network\n+     *\n+     * @param config powermeter config ( ip, user, pwd )\n+     * @return PowerMeterResponse class where json values \"are saved\"\n+     */\n+    private @Nullable MecMeterResponse getRealtimeData() {\n+        MecMeterResponse result = null;\n+        boolean resultOk = false;\n+        String errorMsg = null;\n+\n+        MecMeterDeviceConfiguration config = getConfig().as(MecMeterDeviceConfiguration.class);\n+\n+        try {\n+            String basicAuthentication = \"Basic \" + Base64.getEncoder().encodeToString(\n+                    new String(config.username + \":\" + config.password).getBytes(StringUtil.__ISO_8859_1));\n+\n+            String location = MecMeterBindingConstants.POWERMETER_DATA_URL.replace(\"%IP%\", config.ip.strip());\n+\n+            ContentResponse response = httpClient.newRequest(location).method(HttpMethod.GET)\n+                    .header(HttpHeader.AUTHORIZATION, basicAuthentication).timeout(API_TIMEOUT, TimeUnit.MILLISECONDS)\n+                    .send();\n+            if (response.getStatus() != 200) {\n+                errorMsg = \"Reading meter did not succeeed: \" + response.getReason();", "originalCommit": "6b864586f55baf5f4e6c3c07835942750efb0573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDc2MjkzNw==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600762937", "bodyText": "Well, it was VERY successful ;-). Fixed.", "author": "kaikreuzer", "createdAt": "2021-03-24T18:37:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU5NjEzOA=="}], "type": "inlineReview"}, {"oid": "84ff064da612a2fd792d3ecb109823fd0aed3bee", "url": "https://github.com/openhab/openhab-addons/commit/84ff064da612a2fd792d3ecb109823fd0aed3bee", "message": "Initial contribution of mecmeter binding\n\nAlso-by: Klaus Berger <klaus.berger@verbund.com>\nAlso-by: Florian Pazour <florian.pazour@verbund.com>\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2021-03-24T18:40:10Z", "type": "commit"}, {"oid": "84ff064da612a2fd792d3ecb109823fd0aed3bee", "url": "https://github.com/openhab/openhab-addons/commit/84ff064da612a2fd792d3ecb109823fd0aed3bee", "message": "Initial contribution of mecmeter binding\n\nAlso-by: Klaus Berger <klaus.berger@verbund.com>\nAlso-by: Florian Pazour <florian.pazour@verbund.com>\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2021-03-24T18:40:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDg4OTY5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600889692", "bodyText": "The error log level used in this method seems a bit too severe. The debug/error logging in this method also isn't that useful. That's because a very similar errorMsg is always used to update the Thing status. So it might be better to remove all the debug/error logging. WDYT?", "author": "wborn", "createdAt": "2021-03-24T21:35:05Z", "path": "bundles/org.openhab.binding.mecmeter/src/main/java/org/openhab/binding/mecmeter/handler/MecMeterHandler.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mecmeter.handler;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.binding.mecmeter.MecMeterBindingConstants;\n+import org.openhab.binding.mecmeter.MecMeterDeviceConfiguration;\n+import org.openhab.binding.mecmeter.internal.dto.MecMeterResponse;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MecMeterHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Florian Pazour - Initial contribution\n+ * @author Klaus Berger - Initial contribution\n+ * @author Kai Kreuzer - Refactoring for openHAB 3\n+ */\n+@NonNullByDefault\n+public class MecMeterHandler extends BaseThingHandler {\n+\n+    private static final int API_TIMEOUT = 5000; // set on 5000ms - not specified in datasheet\n+\n+    private static final String USERNAME = \"admin\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MecMeterHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    private final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+\n+    private @Nullable MecMeterResponse powerMeterResponse;\n+\n+    public MecMeterHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId());\n+        } else {\n+            logger.debug(\"Received unsupported command {}.\", command);\n+        }\n+    }\n+\n+    /**\n+     * function which is called to refresh the data\n+     */\n+    public void refresh() {\n+        updateData();\n+        updateChannels();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        logger.debug(\"removing thing..\");\n+        if (pollFuture != null) {\n+            pollFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MecMeterDeviceConfiguration config = getConfig().as(MecMeterDeviceConfiguration.class);\n+        String configCheck = config.isValid();\n+\n+        if (configCheck != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configCheck);\n+            return;\n+        }\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        if (pollFuture != null) {\n+            pollFuture.cancel(false);\n+        }\n+        pollFuture = scheduler.scheduleWithFixedDelay(() -> {\n+            refresh();\n+        }, 0, config.refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Get new data\n+     * Function to save Response of the powermeter\n+     */\n+    private void updateData() {\n+        powerMeterResponse = getRealtimeData();\n+    }\n+\n+    /**\n+     * Get new realtime data over the network\n+     *\n+     * @return MecMeterResponse class where json values \"are saved\"\n+     */\n+    private @Nullable MecMeterResponse getRealtimeData() {\n+        MecMeterResponse result = null;\n+        boolean resultOk = false;\n+        String errorMsg = null;\n+\n+        MecMeterDeviceConfiguration config = getConfig().as(MecMeterDeviceConfiguration.class);\n+\n+        try {\n+            String basicAuthentication = \"Basic \" + Base64.getEncoder()\n+                    .encodeToString(new String(USERNAME + \":\" + config.password).getBytes(StandardCharsets.ISO_8859_1));\n+\n+            String location = MecMeterBindingConstants.POWERMETER_DATA_URL.replace(\"%IP%\", config.ip.strip());\n+\n+            ContentResponse response = httpClient.newRequest(location).method(HttpMethod.GET)\n+                    .header(HttpHeader.AUTHORIZATION, basicAuthentication).timeout(API_TIMEOUT, TimeUnit.MILLISECONDS)\n+                    .send();\n+            if (response.getStatus() != 200) {\n+                errorMsg = \"Reading meter did not succeed: \" + response.getReason();\n+                logger.error(\"Request to meter failed: HTTP {}: {}\", response.getStatus(), response.getReason());\n+            } else {\n+                result = gson.fromJson(response.getContentAsString(), MecMeterResponse.class);\n+                if (result == null) {\n+                    errorMsg = \"no data returned\";\n+                    logger.error(\"no data returned from meter at {}\", location);\n+                } else {\n+                    resultOk = true;\n+                }\n+            }\n+        } catch (JsonSyntaxException e) {\n+            errorMsg = \"Configuration is incorrect\";\n+            logger.error(\"Error running power meter request: {}\", e.getMessage());\n+        } catch (IllegalStateException e) {\n+            errorMsg = \"Connection failed\";\n+            logger.error(\"Error running powermeter request: {}\", e.getMessage());", "originalCommit": "84ff064da612a2fd792d3ecb109823fd0aed3bee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDkxNjExNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600916115", "bodyText": "No, these cases should indeed only happen if there's a bug in the binding - therefore an error is logged, so that people will report the bug.", "author": "kaikreuzer", "createdAt": "2021-03-24T22:29:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDg4OTY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDkyMTgwMg==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r600921802", "bodyText": "If they are real bugs than we need to keep them indeed. :-)", "author": "wborn", "createdAt": "2021-03-24T22:43:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDg4OTY5Mg=="}], "type": "inlineReview"}, {"oid": "bdf7e9aa659ad8410e527db9476859e6d10a46ae", "url": "https://github.com/openhab/openhab-addons/commit/bdf7e9aa659ad8410e527db9476859e6d10a46ae", "message": "addressed review feedback\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2021-03-24T22:30:07Z", "type": "commit"}, {"oid": "717fa514782235a9ceaceeefbcfb3e340ac4a903", "url": "https://github.com/openhab/openhab-addons/commit/717fa514782235a9ceaceeefbcfb3e340ac4a903", "message": "added codeowners entry\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2021-03-25T12:04:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjcyNjIxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r602726218", "bodyText": "I think this should be warn, if the remote fails.", "author": "fwolter", "createdAt": "2021-03-27T14:32:13Z", "path": "bundles/org.openhab.binding.mecmeter/src/main/java/org/openhab/binding/mecmeter/handler/MecMeterHandler.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mecmeter.handler;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.binding.mecmeter.MecMeterBindingConstants;\n+import org.openhab.binding.mecmeter.MecMeterDeviceConfiguration;\n+import org.openhab.binding.mecmeter.internal.dto.MecMeterResponse;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MecMeterHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Florian Pazour - Initial contribution\n+ * @author Klaus Berger - Initial contribution\n+ * @author Kai Kreuzer - Refactoring for openHAB 3\n+ */\n+@NonNullByDefault\n+public class MecMeterHandler extends BaseThingHandler {\n+\n+    private static final int API_TIMEOUT = 5000; // set on 5000ms - not specified in datasheet\n+\n+    private static final String USERNAME = \"admin\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MecMeterHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    private final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+\n+    private @Nullable MecMeterResponse powerMeterResponse;\n+\n+    public MecMeterHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId());\n+        } else {\n+            logger.debug(\"Received unsupported command {}.\", command);\n+        }\n+    }\n+\n+    /**\n+     * function which is called to refresh the data\n+     */\n+    public void refresh() {\n+        updateData();\n+        updateChannels();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        logger.debug(\"removing thing..\");\n+        if (pollFuture != null) {\n+            pollFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MecMeterDeviceConfiguration config = getConfig().as(MecMeterDeviceConfiguration.class);\n+        String configCheck = config.isValid();\n+\n+        if (configCheck != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configCheck);\n+            return;\n+        }\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        if (pollFuture != null) {\n+            pollFuture.cancel(false);\n+        }\n+        pollFuture = scheduler.scheduleWithFixedDelay(() -> {\n+            refresh();\n+        }, 0, config.refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Get new data\n+     * Function to save Response of the powermeter\n+     */\n+    private void updateData() {\n+        powerMeterResponse = getRealtimeData();\n+    }\n+\n+    /**\n+     * Get new realtime data over the network\n+     *\n+     * @return MecMeterResponse class where json values \"are saved\"\n+     */\n+    private @Nullable MecMeterResponse getRealtimeData() {\n+        MecMeterResponse result = null;\n+        boolean resultOk = false;\n+        String errorMsg = null;\n+\n+        MecMeterDeviceConfiguration config = getConfig().as(MecMeterDeviceConfiguration.class);\n+\n+        try {\n+            String basicAuthentication = \"Basic \" + Base64.getEncoder()\n+                    .encodeToString(new String(USERNAME + \":\" + config.password).getBytes(StandardCharsets.ISO_8859_1));\n+\n+            String location = MecMeterBindingConstants.POWERMETER_DATA_URL.replace(\"%IP%\", config.ip.strip());\n+\n+            ContentResponse response = httpClient.newRequest(location).method(HttpMethod.GET)\n+                    .header(HttpHeader.AUTHORIZATION, basicAuthentication).timeout(API_TIMEOUT, TimeUnit.MILLISECONDS)\n+                    .send();\n+            if (response.getStatus() != 200) {\n+                errorMsg = \"Reading meter did not succeed: \" + response.getReason();\n+                logger.error(\"Request to meter failed: HTTP {}: {}\", response.getStatus(), response.getReason());", "originalCommit": "717fa514782235a9ceaceeefbcfb3e340ac4a903", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjc3NTI5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r602775295", "bodyText": "https://www.openhab.org/docs/developer/guidelines.html#f-logging says:\n\nerror logging should only be used\n\nin case some code fails irrecoverably and the user should report it as a severe bug.\n\n\nIf we get a response, which is not a HTTP 200 here, I think we have a severe bug here, which should be reported as we seem to be doing invalid requests that make the binding disfunctional.", "author": "kaikreuzer", "createdAt": "2021-03-27T18:15:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjcyNjIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjcyNjQ1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r602726458", "bodyText": "Are you sure these are Energy? The names sound dimensionless.", "author": "fwolter", "createdAt": "2021-03-27T14:35:03Z", "path": "bundles/org.openhab.binding.mecmeter/src/main/java/org/openhab/binding/mecmeter/handler/MecMeterHandler.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mecmeter.handler;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.binding.mecmeter.MecMeterBindingConstants;\n+import org.openhab.binding.mecmeter.MecMeterDeviceConfiguration;\n+import org.openhab.binding.mecmeter.internal.dto.MecMeterResponse;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link MecMeterHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Florian Pazour - Initial contribution\n+ * @author Klaus Berger - Initial contribution\n+ * @author Kai Kreuzer - Refactoring for openHAB 3\n+ */\n+@NonNullByDefault\n+public class MecMeterHandler extends BaseThingHandler {\n+\n+    private static final int API_TIMEOUT = 5000; // set on 5000ms - not specified in datasheet\n+\n+    private static final String USERNAME = \"admin\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MecMeterHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    private final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> pollFuture;\n+\n+    private @Nullable MecMeterResponse powerMeterResponse;\n+\n+    public MecMeterHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId());\n+        } else {\n+            logger.debug(\"Received unsupported command {}.\", command);\n+        }\n+    }\n+\n+    /**\n+     * function which is called to refresh the data\n+     */\n+    public void refresh() {\n+        updateData();\n+        updateChannels();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        logger.debug(\"removing thing..\");\n+        if (pollFuture != null) {\n+            pollFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MecMeterDeviceConfiguration config = getConfig().as(MecMeterDeviceConfiguration.class);\n+        String configCheck = config.isValid();\n+\n+        if (configCheck != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configCheck);\n+            return;\n+        }\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        if (pollFuture != null) {\n+            pollFuture.cancel(false);\n+        }\n+        pollFuture = scheduler.scheduleWithFixedDelay(() -> {\n+            refresh();\n+        }, 0, config.refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Get new data\n+     * Function to save Response of the powermeter\n+     */\n+    private void updateData() {\n+        powerMeterResponse = getRealtimeData();\n+    }\n+\n+    /**\n+     * Get new realtime data over the network\n+     *\n+     * @return MecMeterResponse class where json values \"are saved\"\n+     */\n+    private @Nullable MecMeterResponse getRealtimeData() {\n+        MecMeterResponse result = null;\n+        boolean resultOk = false;\n+        String errorMsg = null;\n+\n+        MecMeterDeviceConfiguration config = getConfig().as(MecMeterDeviceConfiguration.class);\n+\n+        try {\n+            String basicAuthentication = \"Basic \" + Base64.getEncoder()\n+                    .encodeToString(new String(USERNAME + \":\" + config.password).getBytes(StandardCharsets.ISO_8859_1));\n+\n+            String location = MecMeterBindingConstants.POWERMETER_DATA_URL.replace(\"%IP%\", config.ip.strip());\n+\n+            ContentResponse response = httpClient.newRequest(location).method(HttpMethod.GET)\n+                    .header(HttpHeader.AUTHORIZATION, basicAuthentication).timeout(API_TIMEOUT, TimeUnit.MILLISECONDS)\n+                    .send();\n+            if (response.getStatus() != 200) {\n+                errorMsg = \"Reading meter did not succeed: \" + response.getReason();\n+                logger.error(\"Request to meter failed: HTTP {}: {}\", response.getStatus(), response.getReason());\n+            } else {\n+                result = gson.fromJson(response.getContentAsString(), MecMeterResponse.class);\n+                if (result == null) {\n+                    errorMsg = \"no data returned\";\n+                    logger.error(\"no data returned from meter at {}\", location);\n+                } else {\n+                    resultOk = true;\n+                }\n+            }\n+        } catch (JsonSyntaxException e) {\n+            errorMsg = \"Configuration is incorrect\";\n+            logger.error(\"Error running power meter request: {}\", e.getMessage());\n+        } catch (IllegalStateException e) {\n+            errorMsg = \"Connection failed\";\n+            logger.error(\"Error running powermeter request: {}\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Http request has been interrupted: {}\", e.getMessage());\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Http request ran into a timeout: {}\", e.getMessage());\n+            errorMsg = \"Connection to power meter timed out.\";\n+        } catch (ExecutionException e) {\n+            logger.debug(\"Http request did not succeed: {}\", e.getMessage());\n+            errorMsg = \"Connection problem: \" + e.getMessage();\n+        }\n+\n+        // Update the thing status\n+        if (resultOk) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, errorMsg);\n+        }\n+\n+        return resultOk ? result : null;\n+    }\n+\n+    /**\n+     * Update all Channels\n+     */\n+    protected void updateChannels() {\n+        for (Channel channel : getThing().getChannels()) {\n+            updateChannel(channel.getUID().getId());\n+        }\n+    }\n+\n+    /**\n+     * Update the channel state\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    protected void updateChannel(String channelId) {\n+        if (!isLinked(channelId)) {\n+            return;\n+        }\n+        State state = getState(channelId);\n+        if (state != null) {\n+            updateState(channelId, state);\n+        }\n+    }\n+\n+    /**\n+     * Get the state of a given channel\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     * @return state of the channel\n+     */\n+    protected @Nullable State getState(String channelId) {\n+        MecMeterResponse response = powerMeterResponse;\n+        if (response == null) {\n+            return null;\n+        } else {\n+            switch (channelId) {\n+                /* General */\n+                case MecMeterBindingConstants.FREQUENCY:\n+                    return new QuantityType<>(response.getFrequency(), Units.HERTZ);\n+                case MecMeterBindingConstants.TEMPERATURE:\n+                    return new QuantityType<>(response.getTemperature(), SIUnits.CELSIUS);\n+                case MecMeterBindingConstants.OPERATIONAL_TIME:\n+                    return new QuantityType<>(response.getOperationalTime() / 1000, Units.SECOND);\n+\n+                /* Voltage */\n+                case MecMeterBindingConstants.VOLTAGE_PHASE_1:\n+                    return new QuantityType<>(response.getVoltagePhase1(), Units.VOLT);\n+                case MecMeterBindingConstants.VOLTAGE_PHASE_2:\n+                    return new QuantityType<>(response.getVoltagePhase2(), Units.VOLT);\n+                case MecMeterBindingConstants.VOLTAGE_PHASE_3:\n+                    return new QuantityType<>(response.getVoltagePhase3(), Units.VOLT);\n+                case MecMeterBindingConstants.VOLTAGE_PHASE_3_TO_PHASE_2:\n+                    return new QuantityType<>(response.getVoltagePhase3ToPhase2(), Units.VOLT);\n+                case MecMeterBindingConstants.VOLTAGE_PHASE_2_TO_PHASE_1:\n+                    return new QuantityType<>(response.getVoltagePhase2ToPhase1(), Units.VOLT);\n+                case MecMeterBindingConstants.VOLTAGE_PHASE_1_TO_PHASE_3:\n+                    return new QuantityType<>(response.getVoltagePhase1ToPhase3(), Units.VOLT);\n+                case MecMeterBindingConstants.AVERAGE_VOLTAGE_PHASE_2_PHASE:\n+                    return new QuantityType<>(response.getAverageVoltagePhaseToPhase(), Units.VOLT);\n+                case MecMeterBindingConstants.AVERAGE_VOLTAGE_NEUTRAL_2_PHASE:\n+                    return new QuantityType<>(response.getAverageVoltageNeutralToPhase(), Units.VOLT);\n+\n+                /* Current */\n+                case MecMeterBindingConstants.CURRENT_PHASE_1:\n+                    return new QuantityType<>(response.getCurrentPhase1(), Units.AMPERE);\n+                case MecMeterBindingConstants.CURRENT_PHASE_2:\n+                    return new QuantityType<>(response.getCurrentPhase2(), Units.AMPERE);\n+                case MecMeterBindingConstants.CURRENT_PHASE_3:\n+                    return new QuantityType<>(response.getCurrentPhase3(), Units.AMPERE);\n+                case MecMeterBindingConstants.CURRENT_SUM:\n+                    return new QuantityType<>(response.getCurrentSum(), Units.AMPERE);\n+\n+                /* Angles */\n+                case MecMeterBindingConstants.PHASE_ANGLE_TO_CURRENT_PHASE_1:\n+                    return new QuantityType<>(response.getPhaseAngleCurrentToVoltagePhase1(), Units.DEGREE_ANGLE);\n+                case MecMeterBindingConstants.PHASE_ANGLE_TO_CURRENT_PHASE_2:\n+                    return new QuantityType<>(response.getPhaseAngleCurrentToVoltagePhase2(), Units.DEGREE_ANGLE);\n+                case MecMeterBindingConstants.PHASE_ANGLE_TO_CURRENT_PHASE_3:\n+                    return new QuantityType<>(response.getPhaseAngleCurrentToVoltagePhase3(), Units.DEGREE_ANGLE);\n+                case MecMeterBindingConstants.PHASE_ANGLE_PHASE_1_3:\n+                    return new QuantityType<>(response.getPhaseAnglePhase1To3(), Units.DEGREE_ANGLE);\n+                case MecMeterBindingConstants.PHASE_ANGLE_PHASE_2_3:\n+                    return new QuantityType<>(response.getPhaseAnglePhase2To3(), Units.DEGREE_ANGLE);\n+\n+                /* Power */\n+                case MecMeterBindingConstants.ACTIVE_POWER_PHASE_1:\n+                    return new QuantityType<>(response.getActivePowerPhase1(), Units.WATT);\n+                case MecMeterBindingConstants.ACTIVE_POWER_PHASE_2:\n+                    return new QuantityType<>(response.getActivePowerPhase2(), Units.WATT);\n+                case MecMeterBindingConstants.ACTIVE_POWER_PHASE_3:\n+                    return new QuantityType<>(response.getActivePowerPhase3(), Units.WATT);\n+                case MecMeterBindingConstants.ACTIVE_POWER_SUM:\n+                    return new QuantityType<>(response.getActivePowerSum(), Units.WATT);\n+                case MecMeterBindingConstants.ACTIVE_FUND_POWER_PHASE_1:\n+                    return new QuantityType<>(response.getActiveFundamentalPowerPhase1(), Units.WATT);\n+                case MecMeterBindingConstants.ACTIVE_FUND_POWER_PHASE_2:\n+                    return new QuantityType<>(response.getActiveFundamentalPowerPhase2(), Units.WATT);\n+                case MecMeterBindingConstants.ACTIVE_FUND_POWER_PHASE_3:\n+                    return new QuantityType<>(response.getActiveFundamentalPowerPhase3(), Units.WATT);\n+                case MecMeterBindingConstants.ACTIVE_FUND_POWER_ALL:\n+                    return new QuantityType<>(response.getActiveFundamentalPowerSum(), Units.WATT);\n+                case MecMeterBindingConstants.ACTIVE_HARM_POWER_PHASE_1:\n+                    return new QuantityType<>(response.getActiveHarmonicPowerPhase1(), Units.WATT);\n+                case MecMeterBindingConstants.ACTIVE_HARM_POWER_PHASE_2:\n+                    return new QuantityType<>(response.getActiveHarmonicPowerPhase2(), Units.WATT);\n+                case MecMeterBindingConstants.ACTIVE_HARM_POWER_PHASE_3:\n+                    return new QuantityType<>(response.getActiveHarmonicPowerPhase3(), Units.WATT);\n+                case MecMeterBindingConstants.ACTIVE_HARM_POWER_ALL:\n+                    return new QuantityType<>(response.getActiveHarmonicPowerSum(), Units.WATT);\n+                case MecMeterBindingConstants.REACTIVE_POWER_PHASE_1:\n+                    return new QuantityType<>(response.getReactivePowerPhase1(), Units.VAR);\n+                case MecMeterBindingConstants.REACTIVE_POWER_PHASE_2:\n+                    return new QuantityType<>(response.getReactivePowerPhase2(), Units.VAR);\n+                case MecMeterBindingConstants.REACTIVE_POWER_PHASE_3:\n+                    return new QuantityType<>(response.getReactivePowerPhase3(), Units.VAR);\n+                case MecMeterBindingConstants.REACTIVE_POWER_ALL:\n+                    return new QuantityType<>(response.getReactivePowerSum(), Units.VAR);\n+                case MecMeterBindingConstants.APP_POWER_PHASE_1:\n+                    return new QuantityType<>(response.getApparentPowerPhase1(), Units.VOLT_AMPERE);\n+                case MecMeterBindingConstants.APP_POWER_PHASE_2:\n+                    return new QuantityType<>(response.getApparentPowerPhase2(), Units.VOLT_AMPERE);\n+                case MecMeterBindingConstants.APP_POWER_PHASE_3:\n+                    return new QuantityType<>(response.getApparentPowerPhase3(), Units.VOLT_AMPERE);\n+                case MecMeterBindingConstants.APP_POWER_ALL:\n+                    return new QuantityType<>(response.getApparentPowerSum(), Units.VOLT_AMPERE);\n+\n+                /* Forward Energy */\n+                case MecMeterBindingConstants.FORWARD_ACTIVE_ENERGY_PHASE_1:\n+                    return new QuantityType<>(response.getForwardActiveEnergyPhase1(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.FORWARD_ACTIVE_ENERGY_PHASE_2:\n+                    return new QuantityType<>(response.getForwardActiveEnergyPhase2(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.FORWARD_ACTIVE_ENERGY_PHASE_3:\n+                    return new QuantityType<>(response.getForwardActiveEnergyPhase3(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.FORWARD_ACTIVE_ENERGY_ALL:\n+                    return new QuantityType<>(response.getForwardActiveEnergySum(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.FORWARD_ACTIVE_FUND_ENERGY_PHASE_1:\n+                    return new QuantityType<>(response.getForwardActiveFundamentalEnergyPhase1(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.FORWARD_ACTIVE_FUND_ENERGY_PHASE_2:\n+                    return new QuantityType<>(response.getForwardActiveFundamentalEnergyPhase2(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.FORWARD_ACTIVE_FUND_ENERGY_PHASE_3:\n+                    return new QuantityType<>(response.getForwardActiveFundamentalEnergyPhase3(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.FORWARD_ACTIVE_FUND_ENERGY_ALL:\n+                    return new QuantityType<>(response.getForwardActiveFundamentalEnergySum(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.FORWARD_ACTIVE_HARM_ENERGY_PHASE_1:\n+                    return new QuantityType<>(response.getForwardActiveHarmonicEnergyPhase1(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.FORWARD_ACTIVE_HARM_ENERGY_PHASE_2:\n+                    return new QuantityType<>(response.getForwardActiveHarmonicEnergyPhase2(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.FORWARD_ACTIVE_HARM_ENERGY_PHASE_3:\n+                    return new QuantityType<>(response.getForwardActiveHarmonicEnergyPhase3(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.FORWARD_ACTIVE_HARM_ENERGY_ALL:\n+                    return new QuantityType<>(response.getForwardActiveHarmonicEnergySum(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.FORWARD_REACTIVE_ENERGY_PHASE_1:\n+                    return new QuantityType<>(response.getForwardReactiveEnergyPhase1(), Units.VAR_HOUR);\n+                case MecMeterBindingConstants.FORWARD_REACTIVE_ENERGY_PHASE_2:\n+                    return new QuantityType<>(response.getForwardReactiveEnergyPhase2(), Units.VAR_HOUR);\n+                case MecMeterBindingConstants.FORWARD_REACTIVE_ENERGY_PHASE_3:\n+                    return new QuantityType<>(response.getForwardReactiveEnergyPhase3(), Units.VAR_HOUR);\n+                case MecMeterBindingConstants.FORWARD_REACTIVE_ENERGY_ALL:\n+                    return new QuantityType<>(response.getForwardReactiveEnergySum(), Units.VAR_HOUR);\n+\n+                /* Reverse Energy */\n+                case MecMeterBindingConstants.REVERSE_ACTIVE_ENERGY_PHASE_1:\n+                    return new QuantityType<>(response.getReverseActiveEnergyPhase1(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.REVERSE_ACTIVE_ENERGY_PHASE_2:\n+                    return new QuantityType<>(response.getReverseActiveEnergyPhase2(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.REVERSE_ACTIVE_ENERGY_PHASE_3:\n+                    return new QuantityType<>(response.getReverseActiveEnergyPhase3(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.REVERSE_ACTIVE_ENERGY_ALL:\n+                    return new QuantityType<>(response.getReverseActiveEnergySum(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.REVERSE_ACTIVE_FUND_ENERGY_PHASE_1:\n+                    return new QuantityType<>(response.getReverseActiveFundamentalEnergyPhase1(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.REVERSE_ACTIVE_FUND_ENERGY_PHASE_2:\n+                    return new QuantityType<>(response.getReverseActiveFundamentalEnergyPhase2(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.REVERSE_ACTIVE_FUND_ENERGY_PHASE_3:\n+                    return new QuantityType<>(response.getReverseActiveFundamentalEnergyPhase3(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.REVERSE_ACTIVE_FUND_ENERGY_ALL:\n+                    return new QuantityType<>(response.getReverseActiveFundamentalEnergySum(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.REVERSE_ACTIVE_HARM_ENERGY_PHASE_1:\n+                    return new QuantityType<>(response.getReverseActiveHarmonicEnergyPhase1(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.REVERSE_ACTIVE_HARM_ENERGY_PHASE_2:\n+                    return new QuantityType<>(response.getReverseActiveHarmonicEnergyPhase2(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.REVERSE_ACTIVE_HARM_ENERGY_PHASE_3:\n+                    return new QuantityType<>(response.getReverseActiveHarmonicEnergyPhase3(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.REVERSE_ACTIVE_HARM_ENERGY_ALL:\n+                    return new QuantityType<>(response.getReverseActiveHarmonicEnergySum(), Units.KILOWATT_HOUR);\n+                case MecMeterBindingConstants.REVERSE_REACTIVE_ENERGY_PHASE_1:\n+                    return new QuantityType<>(response.getReverseReactiveEnergyPhase1(), Units.VAR_HOUR);\n+                case MecMeterBindingConstants.REVERSE_REACTIVE_ENERGY_PHASE_2:\n+                    return new QuantityType<>(response.getReverseReactiveEnergyPhase2(), Units.VAR_HOUR);\n+                case MecMeterBindingConstants.REVERSE_REACTIVE_ENERGY_PHASE_3:\n+                    return new QuantityType<>(response.getReverseReactiveEnergyPhase3(), Units.VAR_HOUR);\n+                case MecMeterBindingConstants.REVERSE_REACTIVE_ENERGY_ALL:\n+                    return new QuantityType<>(response.getReverseReactiveEnergySum(), Units.VAR_HOUR);\n+\n+                /* Apparent Energy */\n+                case MecMeterBindingConstants.APP_ENERGY_PHASE_1:\n+                    return new QuantityType<>(response.getApparentEnergyConsumptionPhase1(), Units.VOLT_AMPERE_HOUR);\n+                case MecMeterBindingConstants.APP_ENERGY_PHASE_2:\n+                    return new QuantityType<>(response.getApparentEnergyConsumptionPhase2(), Units.VOLT_AMPERE_HOUR);\n+                case MecMeterBindingConstants.APP_ENERGY_PHASE_3:\n+                    return new QuantityType<>(response.getApparentEnergyConsumptionPhase3(), Units.VOLT_AMPERE_HOUR);\n+                case MecMeterBindingConstants.APP_ENERGY_ALL:\n+                    return new QuantityType<>(response.getApparentEnergyConsumptionSum(), Units.VOLT_AMPERE_HOUR);\n+\n+                /* Power Factor */\n+                case MecMeterBindingConstants.POWER_FACTOR_PHASE_1:\n+                    return new QuantityType<>(response.getPowerFactorPhase1(), Units.VOLT_AMPERE_HOUR);\n+                case MecMeterBindingConstants.POWER_FACTOR_PHASE_2:\n+                    return new QuantityType<>(response.getPowerFactorPhase2(), Units.VOLT_AMPERE_HOUR);\n+                case MecMeterBindingConstants.POWER_FACTOR_PHASE_3:\n+                    return new QuantityType<>(response.getPowerFactorPhase3(), Units.VOLT_AMPERE_HOUR);\n+                case MecMeterBindingConstants.POWER_FACTOR_ALL:\n+                    return new QuantityType<>(response.getPowerFactorSum(), Units.VOLT_AMPERE_HOUR);", "originalCommit": "717fa514782235a9ceaceeefbcfb3e340ac4a903", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjc3Nzc1NA==", "url": "https://github.com/openhab/openhab-addons/pull/9075#discussion_r602777754", "bodyText": "Good point. It was in the original code with a unit, but I agree with you that it does not make sense. Have changed it to dimensionless.", "author": "kaikreuzer", "createdAt": "2021-03-27T18:38:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjcyNjQ1OA=="}], "type": "inlineReview"}, {"oid": "4582144ea02befc3db8224ffc83ee45b43f583d6", "url": "https://github.com/openhab/openhab-addons/commit/4582144ea02befc3db8224ffc83ee45b43f583d6", "message": "addressed review comments\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2021-03-27T18:37:37Z", "type": "commit"}]}