{"pr_number": 6824, "pr_title": "[telegram] proxy support (SOCKS5 and HTTP)", "pr_createdAt": "2020-01-12T21:36:38Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/6824", "timeline": [{"oid": "746c44e15109e564dc71a5e7863db199c222ebd5", "url": "https://github.com/openhab/openhab-addons/commit/746c44e15109e564dc71a5e7863db199c222ebd5", "message": "Update to 3.0 version\n\nSigned-off-by: Eugene Horohorin <genixoid@gmail.com>", "committedDate": "2020-01-08T16:23:14Z", "type": "commit"}, {"oid": "8a6d8325c7e9fbd86b61c70734d7f4044ea9a3f5", "url": "https://github.com/openhab/openhab-addons/commit/8a6d8325c7e9fbd86b61c70734d7f4044ea9a3f5", "message": "Merge branch 'telegram' into 2.5.x", "committedDate": "2020-01-12T18:39:19Z", "type": "commit"}, {"oid": "97738ad534fcf63e7c12e054028298f35601e489", "url": "https://github.com/openhab/openhab-addons/commit/97738ad534fcf63e7c12e054028298f35601e489", "message": "updated files\n\nSigned-off-by: Eugene Horohorin <genixoid@gmail.com>", "committedDate": "2020-01-12T19:05:17Z", "type": "commit"}, {"oid": "fe3526d543740a462351be5424240ce8830ee608", "url": "https://github.com/openhab/openhab-addons/commit/fe3526d543740a462351be5424240ce8830ee608", "message": "Merge branch 'telegram' into 2.5.x", "committedDate": "2020-01-12T19:05:53Z", "type": "commit"}, {"oid": "fbeb33096b7a2fe12b7969b3678101b8f70eba20", "url": "https://github.com/openhab/openhab-addons/commit/fbeb33096b7a2fe12b7969b3678101b8f70eba20", "message": "Merge branch '2.5.x' into 2.5.x", "committedDate": "2020-01-13T22:03:02Z", "type": "commit"}, {"oid": "275ef934f0a36d38e1ad745ecd3dcfa81e737072", "url": "https://github.com/openhab/openhab-addons/commit/275ef934f0a36d38e1ad745ecd3dcfa81e737072", "message": "mvn spotless:apply\n\nSigned-off-by: Eugene Horohorin <genixoid@gmail.com>", "committedDate": "2020-01-14T08:52:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ0NTkzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6824#discussion_r367445931", "bodyText": "This null check is not needed, the benefit of putting the literal on the left is that you can skip it :-)", "author": "martinvw", "createdAt": "2020-01-16T14:26:41Z", "path": "bundles/org.openhab.binding.telegram/src/main/java/org/openhab/binding/telegram/internal/TelegramHandler.java", "diffHunk": "@@ -1,314 +1,337 @@\n-/**\r\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n- *\r\n- * See the NOTICE file(s) distributed with this work for additional\r\n- * information.\r\n- *\r\n- * This program and the accompanying materials are made available under the\r\n- * terms of the Eclipse Public License 2.0 which is available at\r\n- * http://www.eclipse.org/legal/epl-2.0\r\n- *\r\n- * SPDX-License-Identifier: EPL-2.0\r\n- */\r\n-package org.openhab.binding.telegram.internal;\r\n-\r\n-import static org.openhab.binding.telegram.internal.TelegramBindingConstants.*;\r\n-\r\n-import java.time.Instant;\r\n-import java.time.ZoneOffset;\r\n-import java.time.ZonedDateTime;\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.Objects;\r\n-import java.util.concurrent.ScheduledFuture;\r\n-import java.util.concurrent.TimeUnit;\r\n-\r\n-import org.eclipse.jdt.annotation.NonNullByDefault;\r\n-import org.eclipse.jdt.annotation.Nullable;\r\n-import org.eclipse.jetty.client.HttpClient;\r\n-import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n-import org.eclipse.smarthome.core.library.types.StringType;\r\n-import org.eclipse.smarthome.core.thing.ChannelUID;\r\n-import org.eclipse.smarthome.core.thing.Thing;\r\n-import org.eclipse.smarthome.core.thing.ThingStatus;\r\n-import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n-import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n-import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\r\n-import org.eclipse.smarthome.core.types.Command;\r\n-import org.eclipse.smarthome.core.types.State;\r\n-import org.eclipse.smarthome.core.types.UnDefType;\r\n-import org.openhab.binding.telegram.bot.TelegramActions;\r\n-import org.slf4j.Logger;\r\n-import org.slf4j.LoggerFactory;\r\n-\r\n-import com.pengrad.telegrambot.TelegramBot;\r\n-import com.pengrad.telegrambot.UpdatesListener;\r\n-import com.pengrad.telegrambot.model.Message;\r\n-import com.pengrad.telegrambot.model.Update;\r\n-import com.pengrad.telegrambot.model.request.ParseMode;\r\n-import com.pengrad.telegrambot.request.BaseRequest;\r\n-import com.pengrad.telegrambot.response.BaseResponse;\r\n-\r\n-import okhttp3.OkHttpClient;\r\n-\r\n-/**\r\n- * The {@link TelegramHandler} is responsible for handling commands, which are\r\n- * sent to one of the channels.\r\n- *\r\n- * @author Jens Runge - Initial contribution\r\n- * @author Alexander Krasnogolowy - using Telegram library from pengrad\r\n- */\r\n-@NonNullByDefault\r\n-public class TelegramHandler extends BaseThingHandler {\r\n-\r\n-    @NonNullByDefault\r\n-    private class ReplyKey {\r\n-\r\n-        final Long chatId;\r\n-        final String replyId;\r\n-\r\n-        public ReplyKey(Long chatId, String replyId) {\r\n-            this.chatId = chatId;\r\n-            this.replyId = replyId;\r\n-        }\r\n-\r\n-        @Override\r\n-        public int hashCode() {\r\n-            return Objects.hash(chatId, replyId);\r\n-        }\r\n-\r\n-        @Override\r\n-        public boolean equals(@Nullable Object obj) {\r\n-            if (this == obj) {\r\n-                return true;\r\n-            }\r\n-            if (obj == null) {\r\n-                return false;\r\n-            }\r\n-            if (getClass() != obj.getClass()) {\r\n-                return false;\r\n-            }\r\n-            ReplyKey other = (ReplyKey) obj;\r\n-            return Objects.equals(chatId, other.chatId) && Objects.equals(replyId, other.replyId);\r\n-        }\r\n-    }\r\n-\r\n-    private final List<Long> chatIds = new ArrayList<Long>();\r\n-    private final Logger logger = LoggerFactory.getLogger(TelegramHandler.class);\r\n-    private @Nullable ScheduledFuture<?> thingOnlineStatusJob;\r\n-\r\n-    // Keep track of the callback id created by Telegram. This must be sent back in\r\n-    // the answerCallbackQuery\r\n-    // to stop the progress bar in the Telegram client\r\n-    private final Map<ReplyKey, String> replyIdToCallbackId = new HashMap<>();\r\n-    // Keep track of message id sent with reply markup because we want to remove the\r\n-    // markup after the user provided an\r\n-    // answer and need the id of the original message\r\n-    private final Map<ReplyKey, Integer> replyIdToMessageId = new HashMap<>();\r\n-\r\n-    private @Nullable TelegramBot bot;\r\n-    private @Nullable OkHttpClient botLibClient;\r\n-    private @Nullable HttpClient downloadDataClient;\r\n-    private @Nullable ParseMode parseMode;\r\n-\r\n-    public TelegramHandler(Thing thing, @Nullable HttpClient httpClient) {\r\n-        super(thing);\r\n-        downloadDataClient = httpClient;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void handleCommand(ChannelUID channelUID, Command command) {\r\n-        // no commands to handle\r\n-    }\r\n-\r\n-    @Override\r\n-    public void initialize() {\r\n-        TelegramConfiguration config = getConfigAs(TelegramConfiguration.class);\r\n-\r\n-        String botToken = config.getBotToken();\r\n-        chatIds.clear();\r\n-        for (String chatIdStr : config.getChatIds()) {\r\n-            try {\r\n-                chatIds.add(Long.valueOf(chatIdStr));\r\n-            } catch (NumberFormatException e) {\r\n-                logger.warn(\"The chat id {} is not a number and will be ignored\", chatIdStr);\r\n-            }\r\n-        }\r\n-        if (config.getParseMode() != null) {\r\n-            try {\r\n-                parseMode = ParseMode.valueOf(config.getParseMode());\r\n-            } catch (IllegalArgumentException e) {\r\n-                logger.warn(\"parseMode is invalid and will be ignored. Only Markdown or HTML are allowed values\");\r\n-            }\r\n-        }\r\n-\r\n-        botLibClient = new OkHttpClient.Builder().connectTimeout(75, TimeUnit.SECONDS).readTimeout(75, TimeUnit.SECONDS)\r\n-                .build();\r\n-        updateStatus(ThingStatus.UNKNOWN);\r\n-        delayThingOnlineStatus();\r\n-        TelegramBot localBot = bot = new TelegramBot.Builder(botToken).okHttpClient(botLibClient).build();\r\n-        localBot.setUpdatesListener(updates -> {\r\n-            cancelThingOnlineStatusJob();\r\n-            updateStatus(ThingStatus.ONLINE);\r\n-            for (Update update : updates) {\r\n-                String lastMessageText = null;\r\n-                Integer lastMessageDate = null;\r\n-                String lastMessageFirstName = null;\r\n-                String lastMessageLastName = null;\r\n-                String lastMessageUsername = null;\r\n-                Long chatId = null;\r\n-                String replyId = null;\r\n-                if (update.message() != null && update.message().text() != null) {\r\n-                    Message message = update.message();\r\n-                    chatId = message.chat().id();\r\n-                    if (!chatIds.contains(chatId)) {\r\n-                        logger.warn(\r\n-                                \"Ignored message from unknown chat id {}. If you know the sender of that chat, add it to the list of chat ids in the thing configuration to authorize it\",\r\n-                                chatId);\r\n-                        continue; // this is very important regarding security to avoid commands from an unknown\r\n-                                  // chat\r\n-                    }\r\n-\r\n-                    lastMessageText = message.text();\r\n-                    lastMessageDate = message.date();\r\n-                    lastMessageFirstName = message.from().firstName();\r\n-                    lastMessageLastName = message.from().lastName();\r\n-                    lastMessageUsername = message.from().username();\r\n-                } else if (update.callbackQuery() != null && update.callbackQuery().message() != null\r\n-                        && update.callbackQuery().message().text() != null) {\r\n-                    String[] callbackData = update.callbackQuery().data().split(\" \", 2);\r\n-\r\n-                    if (callbackData.length == 2) {\r\n-                        replyId = callbackData[0];\r\n-                        lastMessageText = callbackData[1];\r\n-                        lastMessageDate = update.callbackQuery().message().date();\r\n-                        lastMessageFirstName = update.callbackQuery().from().firstName();\r\n-                        lastMessageLastName = update.callbackQuery().from().lastName();\r\n-                        lastMessageUsername = update.callbackQuery().from().username();\r\n-                        chatId = update.callbackQuery().message().chat().id();\r\n-                        replyIdToCallbackId.put(new ReplyKey(chatId, replyId), update.callbackQuery().id());\r\n-                        logger.debug(\"Received callbackId {} for chatId {} and replyId {}\", update.callbackQuery().id(),\r\n-                                chatId, replyId);\r\n-                    } else {\r\n-                        logger.warn(\r\n-                                \"The received callback query {} has not the right format (must be seperated by spaces)\",\r\n-                                update.callbackQuery().data());\r\n-                    }\r\n-                }\r\n-                updateChannel(LASTMESSAGETEXT,\r\n-                        lastMessageText != null ? new StringType(lastMessageText) : UnDefType.NULL);\r\n-                updateChannel(LASTMESSAGEDATE,\r\n-                        lastMessageDate != null\r\n-                                ? new DateTimeType(ZonedDateTime\r\n-                                        .ofInstant(Instant.ofEpochSecond(lastMessageDate.intValue()), ZoneOffset.UTC))\r\n-                                : UnDefType.NULL);\r\n-                updateChannel(LASTMESSAGENAME, (lastMessageFirstName != null || lastMessageLastName != null)\r\n-                        ? new StringType((lastMessageFirstName != null ? lastMessageFirstName + \" \" : \"\")\r\n-                                + (lastMessageLastName != null ? lastMessageLastName : \"\"))\r\n-                        : UnDefType.NULL);\r\n-                updateChannel(LASTMESSAGEUSERNAME,\r\n-                        lastMessageUsername != null ? new StringType(lastMessageUsername) : UnDefType.NULL);\r\n-                updateChannel(CHATID, chatId != null ? new StringType(chatId.toString()) : UnDefType.NULL);\r\n-                updateChannel(REPLYID, replyId != null ? new StringType(replyId) : UnDefType.NULL);\r\n-            }\r\n-            return UpdatesListener.CONFIRMED_UPDATES_ALL;\r\n-        }, exception -> {\r\n-            if (exception != null) {\r\n-                if (exception.response() != null) {\r\n-                    BaseResponse localResponse = exception.response();\r\n-                    if (localResponse.errorCode() == 401) { // unauthorized\r\n-                        cancelThingOnlineStatusJob();\r\n-                        localBot.removeGetUpdatesListener();\r\n-                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n-                                \"Unauthorized attempt to connect to the Telegram server, please check if the bot token is valid\");\r\n-                        return;\r\n-                    }\r\n-                }\r\n-                if (exception.getCause() != null) { // cause is only non-null in case of an IOException\r\n-                    cancelThingOnlineStatusJob();\r\n-                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, exception.getMessage());\r\n-                    delayThingOnlineStatus();\r\n-                    return;\r\n-                }\r\n-                logger.warn(\"Telegram exception: {}\", exception.getMessage());\r\n-            }\r\n-        });\r\n-    }\r\n-\r\n-    private synchronized void delayThingOnlineStatus() {\r\n-        thingOnlineStatusJob = scheduler.schedule(() -> {\r\n-            // if no error was returned within 10s, we assume the initialization went well\r\n-            updateStatus(ThingStatus.ONLINE);\r\n-        }, 10, TimeUnit.SECONDS);\r\n-    }\r\n-\r\n-    private synchronized void cancelThingOnlineStatusJob() {\r\n-        if (thingOnlineStatusJob != null) {\r\n-            thingOnlineStatusJob.cancel(true);\r\n-            thingOnlineStatusJob = null;\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void dispose() {\r\n-        logger.debug(\"Trying to dispose Telegram client\");\r\n-        cancelThingOnlineStatusJob();\r\n-        OkHttpClient localClient = botLibClient;\r\n-        TelegramBot localBot = bot;\r\n-        if (localClient != null && localBot != null) {\r\n-            localBot.removeGetUpdatesListener();\r\n-            localClient.dispatcher().executorService().shutdown();\r\n-            localClient.connectionPool().evictAll();\r\n-            logger.debug(\"Telegram client closed\");\r\n-        }\r\n-        super.dispose();\r\n-    }\r\n-\r\n-    public void updateChannel(String channelName, State state) {\r\n-        updateState(new ChannelUID(getThing().getUID(), channelName), state);\r\n-    }\r\n-\r\n-    @Override\r\n-    public Collection<Class<? extends ThingHandlerService>> getServices() {\r\n-        return Collections.singleton(TelegramActions.class);\r\n-    }\r\n-\r\n-    public List<Long> getChatIds() {\r\n-        return chatIds;\r\n-    }\r\n-\r\n-    public void addMessageId(Long chatId, String replyId, Integer messageId) {\r\n-        replyIdToMessageId.put(new ReplyKey(chatId, replyId), messageId);\r\n-    }\r\n-\r\n-    @Nullable\r\n-    public String getCallbackId(Long chatId, String replyId) {\r\n-        return replyIdToCallbackId.get(new ReplyKey(chatId, replyId));\r\n-    }\r\n-\r\n-    public Integer removeMessageId(Long chatId, String replyId) {\r\n-        return replyIdToMessageId.remove(new ReplyKey(chatId, replyId));\r\n-    }\r\n-\r\n-    @Nullable\r\n-    public ParseMode getParseMode() {\r\n-        return parseMode;\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"rawtypes\")\r\n-    @Nullable\r\n-    public <T extends BaseRequest, R extends BaseResponse> R execute(BaseRequest<T, R> request) {\r\n-        TelegramBot localBot = bot;\r\n-        return localBot != null ? localBot.execute(request) : null;\r\n-    }\r\n-\r\n-    @Nullable\r\n-    public HttpClient getClient() {\r\n-        return downloadDataClient;\r\n-    }\r\n-\r\n-}\r\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.telegram.internal;\n+\n+import static org.openhab.binding.telegram.internal.TelegramBindingConstants.*;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.telegram.bot.TelegramActions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.pengrad.telegrambot.TelegramBot;\n+import com.pengrad.telegrambot.UpdatesListener;\n+import com.pengrad.telegrambot.model.Message;\n+import com.pengrad.telegrambot.model.Update;\n+import com.pengrad.telegrambot.model.request.ParseMode;\n+import com.pengrad.telegrambot.request.BaseRequest;\n+import com.pengrad.telegrambot.response.BaseResponse;\n+\n+import okhttp3.OkHttpClient;\n+\n+/**\n+ * The {@link TelegramHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jens Runge - Initial contribution\n+ * @author Alexander Krasnogolowy - using Telegram library from pengrad\n+ */\n+@NonNullByDefault\n+public class TelegramHandler extends BaseThingHandler {\n+\n+    @NonNullByDefault\n+    private class ReplyKey {\n+\n+        final Long chatId;\n+        final String replyId;\n+\n+        public ReplyKey(Long chatId, String replyId) {\n+            this.chatId = chatId;\n+            this.replyId = replyId;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(chatId, replyId);\n+        }\n+\n+        @Override\n+        public boolean equals(@Nullable Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            ReplyKey other = (ReplyKey) obj;\n+            return Objects.equals(chatId, other.chatId) && Objects.equals(replyId, other.replyId);\n+        }\n+    }\n+\n+    private final List<Long> chatIds = new ArrayList<Long>();\n+    private final Logger logger = LoggerFactory.getLogger(TelegramHandler.class);\n+    private @Nullable ScheduledFuture<?> thingOnlineStatusJob;\n+\n+    // Keep track of the callback id created by Telegram. This must be sent back in\n+    // the answerCallbackQuery\n+    // to stop the progress bar in the Telegram client\n+    private final Map<ReplyKey, String> replyIdToCallbackId = new HashMap<>();\n+    // Keep track of message id sent with reply markup because we want to remove the\n+    // markup after the user provided an\n+    // answer and need the id of the original message\n+    private final Map<ReplyKey, Integer> replyIdToMessageId = new HashMap<>();\n+\n+    private @Nullable TelegramBot bot;\n+    private @Nullable OkHttpClient botLibClient;\n+    private @Nullable HttpClient downloadDataClient;\n+    private @Nullable ParseMode parseMode;\n+\n+    public TelegramHandler(Thing thing, @Nullable HttpClient httpClient) {\n+        super(thing);\n+        downloadDataClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands to handle\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        TelegramConfiguration config = getConfigAs(TelegramConfiguration.class);\n+\n+        String botToken = config.getBotToken();\n+        chatIds.clear();\n+        for (String chatIdStr : config.getChatIds()) {\n+            try {\n+                chatIds.add(Long.valueOf(chatIdStr));\n+            } catch (NumberFormatException e) {\n+                logger.warn(\"The chat id {} is not a number and will be ignored\", chatIdStr);\n+            }\n+        }\n+        if (config.getParseMode() != null) {\n+            try {\n+                parseMode = ParseMode.valueOf(config.getParseMode());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"parseMode is invalid and will be ignored. Only Markdown or HTML are allowed values\");\n+            }\n+        }\n+\n+        OkHttpClient.Builder prepareConnection = new OkHttpClient.Builder().connectTimeout(75, TimeUnit.SECONDS)\n+                .readTimeout(75, TimeUnit.SECONDS);\n+\n+        String proxyHost = config.getProxyHost();\n+        String proxyPort = config.getProxyPort();\n+        String proxyType = config.getProxyType();\n+\n+        if (proxyHost != null && proxyPort != null) {\n+            InetSocketAddress proxyAddr = new InetSocketAddress(proxyHost, Integer.parseInt(proxyPort));\n+\n+            Proxy.Type proxyTypeParam = Proxy.Type.SOCKS;\n+\n+            if (proxyType != null && \"HTTP\".equals(proxyType)) {", "originalCommit": "275ef934f0a36d38e1ad745ecd3dcfa81e737072", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "10141fcaa3f96eceaf759db6a4d4a7af961068d7", "url": "https://github.com/openhab/openhab-addons/commit/10141fcaa3f96eceaf759db6a4d4a7af961068d7", "message": "Merge branch '2.5.x' of https://github.com/openhab/openhab-addons into 2.5.x", "committedDate": "2020-01-20T11:16:21Z", "type": "commit"}, {"oid": "5be82fb66ea69105eac042ee21010d50eb491e62", "url": "https://github.com/openhab/openhab-addons/commit/5be82fb66ea69105eac042ee21010d50eb491e62", "message": "code cleanup\n\nSigned-off-by: Eugene Horohorin <genixoid@gmail.com>", "committedDate": "2020-01-20T13:21:00Z", "type": "commit"}, {"oid": "f286914ac56e72551e3abddac1013e39c98fd915", "url": "https://github.com/openhab/openhab-addons/commit/f286914ac56e72551e3abddac1013e39c98fd915", "message": "Merge branch '2.5.x' of https://github.com/openhab/openhab-addons into 2.5.x", "committedDate": "2020-01-24T06:41:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI4NDExNA==", "url": "https://github.com/openhab/openhab-addons/pull/6824#discussion_r385284114", "bodyText": "Why did you change the parameter name?", "author": "J-N-K", "createdAt": "2020-02-27T18:14:21Z", "path": "bundles/org.openhab.binding.telegram/src/main/java/org/openhab/binding/telegram/bot/TelegramActions.java", "diffHunk": "@@ -1,507 +1,507 @@\n-/**\r\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n- *\r\n- * See the NOTICE file(s) distributed with this work for additional\r\n- * information.\r\n- *\r\n- * This program and the accompanying materials are made available under the\r\n- * terms of the Eclipse Public License 2.0 which is available at\r\n- * http://www.eclipse.org/legal/epl-2.0\r\n- *\r\n- * SPDX-License-Identifier: EPL-2.0\r\n- */\r\n-package org.openhab.binding.telegram.bot;\r\n-\r\n-import java.io.ByteArrayInputStream;\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.net.MalformedURLException;\r\n-import java.net.URI;\r\n-import java.net.URL;\r\n-import java.nio.charset.StandardCharsets;\r\n-import java.nio.file.Paths;\r\n-import java.util.Base64;\r\n-import java.util.concurrent.ExecutionException;\r\n-import java.util.concurrent.TimeUnit;\r\n-import java.util.concurrent.TimeoutException;\r\n-\r\n-import org.apache.commons.io.IOUtils;\r\n-import org.eclipse.jdt.annotation.NonNullByDefault;\r\n-import org.eclipse.jdt.annotation.Nullable;\r\n-import org.eclipse.jetty.client.HttpClient;\r\n-import org.eclipse.jetty.client.api.Authentication;\r\n-import org.eclipse.jetty.client.api.AuthenticationStore;\r\n-import org.eclipse.jetty.client.api.ContentResponse;\r\n-import org.eclipse.jetty.client.api.Request;\r\n-import org.eclipse.jetty.http.HttpHeader;\r\n-import org.eclipse.jetty.http.HttpMethod;\r\n-import org.eclipse.jetty.util.B64Code;\r\n-import org.eclipse.smarthome.core.thing.binding.ThingActions;\r\n-import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\r\n-import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n-import org.openhab.binding.telegram.internal.TelegramHandler;\r\n-import org.openhab.core.automation.annotation.ActionInput;\r\n-import org.openhab.core.automation.annotation.RuleAction;\r\n-import org.slf4j.Logger;\r\n-import org.slf4j.LoggerFactory;\r\n-\r\n-import com.pengrad.telegrambot.model.request.InlineKeyboardButton;\r\n-import com.pengrad.telegrambot.model.request.InlineKeyboardMarkup;\r\n-import com.pengrad.telegrambot.request.AnswerCallbackQuery;\r\n-import com.pengrad.telegrambot.request.EditMessageReplyMarkup;\r\n-import com.pengrad.telegrambot.request.SendMessage;\r\n-import com.pengrad.telegrambot.request.SendPhoto;\r\n-import com.pengrad.telegrambot.response.BaseResponse;\r\n-import com.pengrad.telegrambot.response.SendResponse;\r\n-\r\n-/**\r\n- * Provides the actions for the Telegram API.\r\n- *\r\n- * @author Alexander Krasnogolowy - Initial contribution\r\n- *\r\n- */\r\n-@ThingActionsScope(name = \"telegram\")\r\n-@NonNullByDefault\r\n-public class TelegramActions implements ThingActions {\r\n-    private final Logger logger = LoggerFactory.getLogger(TelegramActions.class);\r\n-    private @Nullable TelegramHandler handler;\r\n-\r\n-    private boolean evaluateResponse(@Nullable BaseResponse response) {\r\n-        if (response != null && !response.isOk()) {\r\n-            logger.warn(\"Failed to send telegram message: {}\", response.description());\r\n-            return false;\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @NonNullByDefault\r\n-    private static class BasicResult implements Authentication.Result {\r\n-\r\n-        private final HttpHeader header;\r\n-        private final URI uri;\r\n-        private final String value;\r\n-\r\n-        public BasicResult(HttpHeader header, URI uri, String value) {\r\n-            this.header = header;\r\n-            this.uri = uri;\r\n-            this.value = value;\r\n-        }\r\n-\r\n-        @Override\r\n-        public URI getURI() {\r\n-            return this.uri;\r\n-        }\r\n-\r\n-        @Override\r\n-        public void apply(@Nullable Request request) {\r\n-            if (request != null) {\r\n-                request.header(this.header, this.value);\r\n-            }\r\n-        }\r\n-\r\n-        public String toString() {\r\n-            return String.format(\"Basic authentication result for %s\", this.uri);\r\n-        }\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram answer\", description = \"Sends a Telegram answer via Telegram API\")\r\n-    public boolean sendTelegramAnswer(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"replyId\") @Nullable String replyId,\r\n-            @ActionInput(name = \"message\") @Nullable String message) {\r\n-        if (replyId == null) {\r\n-            logger.warn(\"ReplyId not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-        if (chatId == null) {\r\n-            logger.warn(\"chatId not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            String callbackId = localHandler.getCallbackId(chatId, replyId);\r\n-            if (callbackId != null) {\r\n-                AnswerCallbackQuery answerCallbackQuery = new AnswerCallbackQuery(\r\n-                        localHandler.getCallbackId(chatId, replyId));\r\n-                logger.debug(\"AnswerCallbackQuery for chatId {} and replyId {} is the callbackId {}\", chatId, replyId,\r\n-                        localHandler.getCallbackId(chatId, replyId));\r\n-                // we could directly set the text here, but this\r\n-                // doesn't result in a real message only in a\r\n-                // little popup or in an alert, so the only purpose\r\n-                // is to stop the progress bar on client side\r\n-                if (!evaluateResponse(localHandler.execute(answerCallbackQuery))) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-            Integer messageId = localHandler.removeMessageId(chatId, replyId);\r\n-            logger.debug(\"remove messageId {} for chatId {} and replyId {}\", messageId, chatId, replyId);\r\n-\r\n-            EditMessageReplyMarkup editReplyMarkup = new EditMessageReplyMarkup(chatId, messageId.intValue())\r\n-                    .replyMarkup(new InlineKeyboardMarkup(new InlineKeyboardButton[0]));// remove reply markup from\r\n-                                                                                        // old message\r\n-            if (!evaluateResponse(localHandler.execute(editReplyMarkup))) {\r\n-                return false;\r\n-            }\r\n-            return message != null ? sendTelegram(chatId, message) : true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram answer\", description = \"Sends a Telegram answer via Telegram API\")\r\n-    public boolean sendTelegramAnswer(@ActionInput(name = \"replyId\") @Nullable String replyId,\r\n-            @ActionInput(name = \"message\") @Nullable String message) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegramAnswer(chatId, replyId, message)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegram(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"message\") @Nullable String message) {\r\n-        return sendTelegramGeneral(chatId, message, (String) null);\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegram(@ActionInput(name = \"message\") @Nullable String message) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegram(chatId, message)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegramQuery(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"message\") @Nullable String message,\r\n-            @ActionInput(name = \"replyId\") @Nullable String replyId,\r\n-            @ActionInput(name = \"buttons\") @Nullable String... buttons) {\r\n-        return sendTelegramGeneral(chatId, message, replyId, buttons);\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegramQuery(@ActionInput(name = \"message\") @Nullable String message,\r\n-            @ActionInput(name = \"replyId\") @Nullable String replyId,\r\n-            @ActionInput(name = \"buttons\") @Nullable String... buttons) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegramQuery(chatId, message, replyId, buttons)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    private boolean sendTelegramGeneral(@ActionInput(name = \"chatId\") @Nullable Long chatId, @Nullable String message,\r\n-            @Nullable String replyId, @Nullable String... buttons) {\r\n-        if (message == null) {\r\n-            logger.warn(\"Message not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-        if (chatId == null) {\r\n-            logger.warn(\"chatId not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            SendMessage sendMessage = new SendMessage(chatId, message);\r\n-            if (localHandler.getParseMode() != null) {\r\n-                sendMessage.parseMode(localHandler.getParseMode());\r\n-            }\r\n-            if (replyId != null) {\r\n-                if (!replyId.contains(\" \")) {\r\n-                    if (buttons.length > 0) {\r\n-                        InlineKeyboardButton[][] keyboard2D = new InlineKeyboardButton[1][];\r\n-                        InlineKeyboardButton[] keyboard = new InlineKeyboardButton[buttons.length];\r\n-                        keyboard2D[0] = keyboard;\r\n-                        for (int i = 0; i < buttons.length; i++) {\r\n-                            keyboard[i] = new InlineKeyboardButton(buttons[i]).callbackData(replyId + \" \" + buttons[i]);\r\n-                        }\r\n-                        InlineKeyboardMarkup keyBoardMarkup = new InlineKeyboardMarkup(keyboard2D);\r\n-                        sendMessage.replyMarkup(keyBoardMarkup);\r\n-                    } else {\r\n-                        logger.warn(\r\n-                                \"The replyId {} for message {} is given, but no buttons are defined. ReplyMarkup will be ignored.\",\r\n-                                replyId, message);\r\n-                    }\r\n-                } else {\r\n-                    logger.warn(\"replyId {} must not contain spaces. ReplyMarkup will be ignored.\", replyId);\r\n-                }\r\n-            }\r\n-            SendResponse retMessage = localHandler.execute(sendMessage);\r\n-            if (!evaluateResponse(retMessage)) {\r\n-                return false;\r\n-            }\r\n-            if (replyId != null && retMessage != null) {\r\n-                logger.debug(\"Adding chatId {}, replyId {} and messageId {}\", chatId, replyId,\r\n-                        retMessage.message().messageId());\r\n-                localHandler.addMessageId(chatId, replyId, retMessage.message().messageId());\r\n-            }\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegram(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"message\") @Nullable String message,\r\n-            @ActionInput(name = \"args\") @Nullable Object... args) {\r\n-        return sendTelegram(chatId, args == null || args.length == 0 ? message : String.format(message, args));\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegram(@ActionInput(name = \"message\") @Nullable String message,\r\n-            @ActionInput(name = \"args\") @Nullable Object... args) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegram(chatId, message, args)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram photo\", description = \"Sends a Picture via Telegram API\")\r\n-    public boolean sendTelegramPhoto(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"photoURL\") @Nullable String photoURL,\r\n-            @ActionInput(name = \"caption\") @Nullable String caption) {\r\n-        return sendTelegramPhoto(chatId, photoURL, caption, null, null);\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram photo\", description = \"Sends a Picture via Telegram API\")\r\n-    public boolean sendTelegramPhoto(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"photoURL\") @Nullable String photoURL,\r\n-            @ActionInput(name = \"caption\") @Nullable String caption,\r\n-            @ActionInput(name = \"username\") @Nullable String username,\r\n-            @ActionInput(name = \"password\") @Nullable String password) {\r\n-        if (photoURL == null) {\r\n-            logger.warn(\"Photo URL not defined; unable to retrieve photo for sending.\");\r\n-            return false;\r\n-        }\r\n-        if (chatId == null) {\r\n-            logger.warn(\"chatId not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            final SendPhoto sendPhoto;\r\n-\r\n-            if (photoURL.toLowerCase().startsWith(\"http\")) {\r\n-                // load image from url\r\n-                logger.debug(\"Photo URL provided.\");\r\n-                HttpClient client = localHandler.getClient();\r\n-                if (client == null) {\r\n-                    return false;\r\n-                }\r\n-                Request request = client.newRequest(photoURL).method(HttpMethod.GET).timeout(30, TimeUnit.SECONDS);\r\n-                if (username != null && password != null) {\r\n-                    AuthenticationStore auth = client.getAuthenticationStore();\r\n-                    URI uri = URI.create(photoURL);\r\n-                    auth.addAuthenticationResult(new BasicResult(HttpHeader.AUTHORIZATION, uri,\r\n-                            \"Basic \" + B64Code.encode(username + \":\" + password, StandardCharsets.ISO_8859_1)));\r\n-                }\r\n-                try {\r\n-                    ContentResponse contentResponse = request.send();\r\n-                    if (contentResponse.getStatus() == 200) {\r\n-                        byte[] fileContent = contentResponse.getContent();\r\n-                        sendPhoto = new SendPhoto(chatId, fileContent);\r\n-                    } else {\r\n-                        logger.warn(\"Download from {} failed with status: {}\", photoURL, contentResponse.getStatus());\r\n-                        return false;\r\n-                    }\r\n-                } catch (InterruptedException | TimeoutException | ExecutionException e) {\r\n-                    logger.warn(\"Download from {} failed with exception: {}\", photoURL, e.getMessage());\r\n-                    return false;\r\n-                }\r\n-            } else if (photoURL.toLowerCase().startsWith(\"file\")) {\r\n-                // Load image from local file system\r\n-                logger.debug(\"Read file from local file system: {}\", photoURL);\r\n-                try {\r\n-                    URL url = new URL(photoURL);\r\n-                    sendPhoto = new SendPhoto(chatId, Paths.get(url.getPath()).toFile());\r\n-                } catch (MalformedURLException e) {\r\n-                    logger.warn(\"Malformed URL: {}\", photoURL);\r\n-                    return false;\r\n-                }\r\n-            } else {\r\n-                // Load image from provided base64 image\r\n-                logger.debug(\"Photo base64 provided; converting to binary.\");\r\n-                final String photoB64Data;\r\n-                if (photoURL.startsWith(\"data:\")) { // support data URI scheme\r\n-                    String[] photoURLParts = photoURL.split(\",\");\r\n-                    if (photoURLParts.length > 1) {\r\n-                        photoB64Data = photoURLParts[1];\r\n-                    } else {\r\n-                        logger.warn(\"The provided base64 string is not a valid data URI scheme\");\r\n-                        return false;\r\n-                    }\r\n-                } else {\r\n-                    photoB64Data = photoURL;\r\n-                }\r\n-                InputStream is = Base64.getDecoder()\r\n-                        .wrap(new ByteArrayInputStream(photoB64Data.getBytes(StandardCharsets.UTF_8)));\r\n-                try {\r\n-                    byte[] photoBytes = IOUtils.toByteArray(is);\r\n-                    sendPhoto = new SendPhoto(chatId, photoBytes);\r\n-                } catch (IOException e) {\r\n-                    logger.warn(\"Malformed base64 string: {}\", e.getMessage());\r\n-                    return false;\r\n-                }\r\n-            }\r\n-            sendPhoto.caption(caption);\r\n-            if (localHandler.getParseMode() != null) {\r\n-                sendPhoto.parseMode(localHandler.getParseMode());\r\n-            }\r\n-            return evaluateResponse(localHandler.execute(sendPhoto));\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram photo\", description = \"Sends a Picture via Telegram API\")\r\n-    public boolean sendTelegramPhoto(@ActionInput(name = \"photoURL\") @Nullable String photoURL,\r\n-            @ActionInput(name = \"caption\") @Nullable String caption,\r\n-            @ActionInput(name = \"username\") @Nullable String username,\r\n-            @ActionInput(name = \"password\") @Nullable String password) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegramPhoto(chatId, photoURL, caption, username, password)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram photo\", description = \"Sends a Picture via Telegram API\")\r\n-    public boolean sendTelegramPhoto(@ActionInput(name = \"photoURL\") @Nullable String photoURL,\r\n-            @ActionInput(name = \"caption\") @Nullable String caption) {\r\n-        return sendTelegramPhoto(photoURL, caption, null, null);\r\n-    }\r\n-\r\n-    // legacy delegate methods\r\n-    /* APIs without chatId parameter */\r\n-    public static boolean sendTelegram(@Nullable ThingActions actions, @Nullable String message,\r\n-            @Nullable Object... args) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegram(message, args);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramQuery(@Nullable ThingActions actions, @Nullable String message,\r\n-            @Nullable String replyId, @Nullable String... buttons) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramQuery(message, replyId, buttons);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramPhoto(@Nullable ThingActions actions, @Nullable String photoURL,\r\n-            @Nullable String caption) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramPhoto(photoURL, caption);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramPhoto(@Nullable ThingActions actions, @Nullable String photoURL,\r\n-            @Nullable String caption, @Nullable String username, @Nullable String password) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramPhoto(photoURL, caption, username, password);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramAnswer(@Nullable ThingActions actions, @Nullable String replyId,\r\n-            @Nullable String message) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramAnswer(replyId, message);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    /* APIs with chatId parameter */\r\n-\r\n-    public static boolean sendTelegram(@Nullable ThingActions actions, @Nullable Long chatId, @Nullable String message,\r\n-            @Nullable Object... args) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegram(chatId, message, args);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramQuery(@Nullable ThingActions actions, @Nullable Long chatId,\r\n-            @Nullable String message, @Nullable String replyId, @Nullable String... buttons) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramQuery(chatId, message, replyId, buttons);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramPhoto(@Nullable ThingActions actions, @Nullable Long chatId,\r\n-            @Nullable String photoURL, @Nullable String caption) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramPhoto(chatId, photoURL, caption);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramPhoto(@Nullable ThingActions actions, @Nullable Long chatId,\r\n-            @Nullable String photoURL, @Nullable String caption, @Nullable String username, @Nullable String password) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramPhoto(chatId, photoURL, caption, username, password);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramAnswer(@Nullable ThingActions actions, @Nullable Long chatId,\r\n-            @Nullable String replyId, @Nullable String message) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramAnswer(chatId, replyId, message);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramAnswer(@Nullable ThingActions actions, @Nullable String chatId,\r\n-            @Nullable String replyId, @Nullable String message) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramAnswer(Long.valueOf(chatId), replyId, message);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void setThingHandler(@Nullable ThingHandler handler) {\r\n-        this.handler = (TelegramHandler) handler;\r\n-    }\r\n-\r\n-    @Override\r\n-    public @Nullable ThingHandler getThingHandler() {\r\n-        return handler;\r\n-    }\r\n-}\r\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.telegram.bot;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Paths;\n+import java.util.Base64;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.telegram.internal.TelegramHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.pengrad.telegrambot.model.request.InlineKeyboardButton;\n+import com.pengrad.telegrambot.model.request.InlineKeyboardMarkup;\n+import com.pengrad.telegrambot.request.AnswerCallbackQuery;\n+import com.pengrad.telegrambot.request.EditMessageReplyMarkup;\n+import com.pengrad.telegrambot.request.SendMessage;\n+import com.pengrad.telegrambot.request.SendPhoto;\n+import com.pengrad.telegrambot.response.BaseResponse;\n+import com.pengrad.telegrambot.response.SendResponse;\n+\n+/**\n+ * Provides the actions for the Telegram API.\n+ *\n+ * @author Alexander Krasnogolowy - Initial contribution\n+ *\n+ */\n+@ThingActionsScope(name = \"telegram\")\n+@NonNullByDefault\n+public class TelegramActions implements ThingActions {\n+    private final Logger logger = LoggerFactory.getLogger(TelegramActions.class);\n+    private @Nullable TelegramHandler handler;\n+\n+    private boolean evaluateResponse(@Nullable BaseResponse response) {\n+        if (response != null && !response.isOk()) {\n+            logger.warn(\"Failed to send telegram message: {}\", response.description());\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @NonNullByDefault\n+    private static class BasicResult implements Authentication.Result {\n+\n+        private final HttpHeader header;\n+        private final URI uri;\n+        private final String value;\n+\n+        public BasicResult(HttpHeader header, URI uri, String value) {\n+            this.header = header;\n+            this.uri = uri;\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public URI getURI() {\n+            return this.uri;\n+        }\n+\n+        @Override\n+        public void apply(@Nullable Request request) {\n+            if (request != null) {\n+                request.header(this.header, this.value);\n+            }\n+        }\n+\n+        public String toString() {\n+            return String.format(\"Basic authentication result for %s\", this.uri);\n+        }\n+    }\n+\n+    @RuleAction(label = \"Telegram answer\", description = \"Sends a Telegram answer via Telegram API\")\n+    public boolean sendTelegramAnswer(@ActionInput(name = \"chatId\") @Nullable Long chatId,\n+            @ActionInput(name = \"replyId\") @Nullable String replyId,\n+            @ActionInput(name = \"message\") @Nullable String message) {\n+        if (replyId == null) {\n+            logger.warn(\"ReplyId not defined; action skipped.\");\n+            return false;\n+        }\n+        if (chatId == null) {\n+            logger.warn(\"chatId not defined; action skipped.\");\n+            return false;\n+        }\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            String callbackId = localHandler.getCallbackId(chatId, replyId);\n+            if (callbackId != null) {\n+                AnswerCallbackQuery answerCallbackQuery = new AnswerCallbackQuery(\n+                        localHandler.getCallbackId(chatId, replyId));\n+                logger.debug(\"AnswerCallbackQuery for chatId {} and replyId {} is the callbackId {}\", chatId, replyId,\n+                        localHandler.getCallbackId(chatId, replyId));\n+                // we could directly set the text here, but this\n+                // doesn't result in a real message only in a\n+                // little popup or in an alert, so the only purpose\n+                // is to stop the progress bar on client side\n+                if (!evaluateResponse(localHandler.execute(answerCallbackQuery))) {\n+                    return false;\n+                }\n+            }\n+            Integer messageId = localHandler.removeMessageId(chatId, replyId);\n+            logger.debug(\"remove messageId {} for chatId {} and replyId {}\", messageId, chatId, replyId);\n+\n+            EditMessageReplyMarkup editReplyMarkup = new EditMessageReplyMarkup(chatId, messageId.intValue())\n+                    .replyMarkup(new InlineKeyboardMarkup(new InlineKeyboardButton[0]));// remove reply markup from\n+                                                                                        // old message\n+            if (!evaluateResponse(localHandler.execute(editReplyMarkup))) {\n+                return false;\n+            }\n+            return message != null ? sendTelegram(chatId, message) : true;\n+        }\n+        return false;\n+    }\n+\n+    @RuleAction(label = \"Telegram answer\", description = \"Sends a Telegram answer via Telegram API\")\n+    public boolean sendTelegramAnswer(@ActionInput(name = \"replyId\") @Nullable String replyId,\n+            @ActionInput(name = \"message\") @Nullable String message) {\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            for (Long chatId : localHandler.getChatIds()) {\n+                if (!sendTelegramAnswer(chatId, replyId, message)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegram(@ActionInput(name = \"chatId\") @Nullable Long chatId,\n+            @ActionInput(name = \"message\") @Nullable String message) {\n+        return sendTelegramGeneral(chatId, message, (String) null);\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegram(@ActionInput(name = \"message\") @Nullable String message) {\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            for (Long chatId : localHandler.getChatIds()) {\n+                if (!sendTelegram(chatId, message)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegramQuery(@ActionInput(name = \"chatId\") @Nullable Long chatId,\n+            @ActionInput(name = \"message\") @Nullable String message,\n+            @ActionInput(name = \"replyId\") @Nullable String replyId,\n+            @ActionInput(name = \"buttons\") @Nullable String... buttons) {\n+        return sendTelegramGeneral(chatId, message, replyId, buttons);\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegramQuery(@ActionInput(name = \"message\") @Nullable String message,\n+            @ActionInput(name = \"replyId\") @Nullable String replyId,\n+            @ActionInput(name = \"buttons\") @Nullable String... buttons) {\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            for (Long chatId : localHandler.getChatIds()) {\n+                if (!sendTelegramQuery(chatId, message, replyId, buttons)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean sendTelegramGeneral(@ActionInput(name = \"chatId\") @Nullable Long chatId, @Nullable String message,\n+            @Nullable String replyId, @Nullable String... buttons) {\n+        if (message == null) {\n+            logger.warn(\"Message not defined; action skipped.\");\n+            return false;\n+        }\n+        if (chatId == null) {\n+            logger.warn(\"chatId not defined; action skipped.\");\n+            return false;\n+        }\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            SendMessage sendMessage = new SendMessage(chatId, message);\n+            if (localHandler.getParseMode() != null) {\n+                sendMessage.parseMode(localHandler.getParseMode());\n+            }\n+            if (replyId != null) {\n+                if (!replyId.contains(\" \")) {\n+                    if (buttons.length > 0) {\n+                        InlineKeyboardButton[][] keyboard2D = new InlineKeyboardButton[1][];\n+                        InlineKeyboardButton[] keyboard = new InlineKeyboardButton[buttons.length];\n+                        keyboard2D[0] = keyboard;\n+                        for (int i = 0; i < buttons.length; i++) {\n+                            keyboard[i] = new InlineKeyboardButton(buttons[i]).callbackData(replyId + \" \" + buttons[i]);\n+                        }\n+                        InlineKeyboardMarkup keyBoardMarkup = new InlineKeyboardMarkup(keyboard2D);\n+                        sendMessage.replyMarkup(keyBoardMarkup);\n+                    } else {\n+                        logger.warn(\n+                                \"The replyId {} for message {} is given, but no buttons are defined. ReplyMarkup will be ignored.\",\n+                                replyId, message);\n+                    }\n+                } else {\n+                    logger.warn(\"replyId {} must not contain spaces. ReplyMarkup will be ignored.\", replyId);\n+                }\n+            }\n+            SendResponse retMessage = localHandler.execute(sendMessage);\n+            if (!evaluateResponse(retMessage)) {\n+                return false;\n+            }\n+            if (replyId != null && retMessage != null) {\n+                logger.debug(\"Adding chatId {}, replyId {} and messageId {}\", chatId, replyId,\n+                        retMessage.message().messageId());\n+                localHandler.addMessageId(chatId, replyId, retMessage.message().messageId());\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegram(@ActionInput(name = \"chatId\") @Nullable Long chatId,\n+            @ActionInput(name = \"message\") @Nullable String format,", "originalCommit": "f286914ac56e72551e3abddac1013e39c98fd915", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyMDU4OA==", "url": "https://github.com/openhab/openhab-addons/pull/6824#discussion_r386620588", "bodyText": "Can you comment here? And why dod you remove the null-check for args?", "author": "J-N-K", "createdAt": "2020-03-02T20:05:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI4NDExNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc4ODQxOA==", "url": "https://github.com/openhab/openhab-addons/pull/6824#discussion_r386788418", "bodyText": "@J-N-K which parameter name was changed?", "author": "ehorohorin", "createdAt": "2020-03-03T04:03:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI4NDExNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgwOTM2MA==", "url": "https://github.com/openhab/openhab-addons/pull/6824#discussion_r386809360", "bodyText": "message to format. IMO this is not a good idea because\n\nif no arguments are given, it's the message\nthe ActionInput is still named message, this is confusing\n\nAnd please do not change the ActionInput name, this would be a breaking change and could not be merged to 2.5.x", "author": "J-N-K", "createdAt": "2020-03-03T05:42:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI4NDExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI4NTY0MA==", "url": "https://github.com/openhab/openhab-addons/pull/6824#discussion_r385285640", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (proxyHost != null) {\n          \n          \n            \n                    if (proxyHost != null && proxyPort !=null) {\n          \n      \n    \n    \n  \n\nthere is no guarantee that proxyPort is non-null when proxyHost is non-null. If it is null you'll get a NPE in l. 159.", "author": "J-N-K", "createdAt": "2020-02-27T18:17:15Z", "path": "bundles/org.openhab.binding.telegram/src/main/java/org/openhab/binding/telegram/internal/TelegramHandler.java", "diffHunk": "@@ -1,314 +1,337 @@\n-/**\r\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n- *\r\n- * See the NOTICE file(s) distributed with this work for additional\r\n- * information.\r\n- *\r\n- * This program and the accompanying materials are made available under the\r\n- * terms of the Eclipse Public License 2.0 which is available at\r\n- * http://www.eclipse.org/legal/epl-2.0\r\n- *\r\n- * SPDX-License-Identifier: EPL-2.0\r\n- */\r\n-package org.openhab.binding.telegram.internal;\r\n-\r\n-import static org.openhab.binding.telegram.internal.TelegramBindingConstants.*;\r\n-\r\n-import java.time.Instant;\r\n-import java.time.ZoneOffset;\r\n-import java.time.ZonedDateTime;\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.Objects;\r\n-import java.util.concurrent.ScheduledFuture;\r\n-import java.util.concurrent.TimeUnit;\r\n-\r\n-import org.eclipse.jdt.annotation.NonNullByDefault;\r\n-import org.eclipse.jdt.annotation.Nullable;\r\n-import org.eclipse.jetty.client.HttpClient;\r\n-import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n-import org.eclipse.smarthome.core.library.types.StringType;\r\n-import org.eclipse.smarthome.core.thing.ChannelUID;\r\n-import org.eclipse.smarthome.core.thing.Thing;\r\n-import org.eclipse.smarthome.core.thing.ThingStatus;\r\n-import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n-import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n-import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\r\n-import org.eclipse.smarthome.core.types.Command;\r\n-import org.eclipse.smarthome.core.types.State;\r\n-import org.eclipse.smarthome.core.types.UnDefType;\r\n-import org.openhab.binding.telegram.bot.TelegramActions;\r\n-import org.slf4j.Logger;\r\n-import org.slf4j.LoggerFactory;\r\n-\r\n-import com.pengrad.telegrambot.TelegramBot;\r\n-import com.pengrad.telegrambot.UpdatesListener;\r\n-import com.pengrad.telegrambot.model.Message;\r\n-import com.pengrad.telegrambot.model.Update;\r\n-import com.pengrad.telegrambot.model.request.ParseMode;\r\n-import com.pengrad.telegrambot.request.BaseRequest;\r\n-import com.pengrad.telegrambot.response.BaseResponse;\r\n-\r\n-import okhttp3.OkHttpClient;\r\n-\r\n-/**\r\n- * The {@link TelegramHandler} is responsible for handling commands, which are\r\n- * sent to one of the channels.\r\n- *\r\n- * @author Jens Runge - Initial contribution\r\n- * @author Alexander Krasnogolowy - using Telegram library from pengrad\r\n- */\r\n-@NonNullByDefault\r\n-public class TelegramHandler extends BaseThingHandler {\r\n-\r\n-    @NonNullByDefault\r\n-    private class ReplyKey {\r\n-\r\n-        final Long chatId;\r\n-        final String replyId;\r\n-\r\n-        public ReplyKey(Long chatId, String replyId) {\r\n-            this.chatId = chatId;\r\n-            this.replyId = replyId;\r\n-        }\r\n-\r\n-        @Override\r\n-        public int hashCode() {\r\n-            return Objects.hash(chatId, replyId);\r\n-        }\r\n-\r\n-        @Override\r\n-        public boolean equals(@Nullable Object obj) {\r\n-            if (this == obj) {\r\n-                return true;\r\n-            }\r\n-            if (obj == null) {\r\n-                return false;\r\n-            }\r\n-            if (getClass() != obj.getClass()) {\r\n-                return false;\r\n-            }\r\n-            ReplyKey other = (ReplyKey) obj;\r\n-            return Objects.equals(chatId, other.chatId) && Objects.equals(replyId, other.replyId);\r\n-        }\r\n-    }\r\n-\r\n-    private final List<Long> chatIds = new ArrayList<Long>();\r\n-    private final Logger logger = LoggerFactory.getLogger(TelegramHandler.class);\r\n-    private @Nullable ScheduledFuture<?> thingOnlineStatusJob;\r\n-\r\n-    // Keep track of the callback id created by Telegram. This must be sent back in\r\n-    // the answerCallbackQuery\r\n-    // to stop the progress bar in the Telegram client\r\n-    private final Map<ReplyKey, String> replyIdToCallbackId = new HashMap<>();\r\n-    // Keep track of message id sent with reply markup because we want to remove the\r\n-    // markup after the user provided an\r\n-    // answer and need the id of the original message\r\n-    private final Map<ReplyKey, Integer> replyIdToMessageId = new HashMap<>();\r\n-\r\n-    private @Nullable TelegramBot bot;\r\n-    private @Nullable OkHttpClient botLibClient;\r\n-    private @Nullable HttpClient downloadDataClient;\r\n-    private @Nullable ParseMode parseMode;\r\n-\r\n-    public TelegramHandler(Thing thing, @Nullable HttpClient httpClient) {\r\n-        super(thing);\r\n-        downloadDataClient = httpClient;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void handleCommand(ChannelUID channelUID, Command command) {\r\n-        // no commands to handle\r\n-    }\r\n-\r\n-    @Override\r\n-    public void initialize() {\r\n-        TelegramConfiguration config = getConfigAs(TelegramConfiguration.class);\r\n-\r\n-        String botToken = config.getBotToken();\r\n-        chatIds.clear();\r\n-        for (String chatIdStr : config.getChatIds()) {\r\n-            try {\r\n-                chatIds.add(Long.valueOf(chatIdStr));\r\n-            } catch (NumberFormatException e) {\r\n-                logger.warn(\"The chat id {} is not a number and will be ignored\", chatIdStr);\r\n-            }\r\n-        }\r\n-        if (config.getParseMode() != null) {\r\n-            try {\r\n-                parseMode = ParseMode.valueOf(config.getParseMode());\r\n-            } catch (IllegalArgumentException e) {\r\n-                logger.warn(\"parseMode is invalid and will be ignored. Only Markdown or HTML are allowed values\");\r\n-            }\r\n-        }\r\n-\r\n-        botLibClient = new OkHttpClient.Builder().connectTimeout(75, TimeUnit.SECONDS).readTimeout(75, TimeUnit.SECONDS)\r\n-                .build();\r\n-        updateStatus(ThingStatus.UNKNOWN);\r\n-        delayThingOnlineStatus();\r\n-        TelegramBot localBot = bot = new TelegramBot.Builder(botToken).okHttpClient(botLibClient).build();\r\n-        localBot.setUpdatesListener(updates -> {\r\n-            cancelThingOnlineStatusJob();\r\n-            updateStatus(ThingStatus.ONLINE);\r\n-            for (Update update : updates) {\r\n-                String lastMessageText = null;\r\n-                Integer lastMessageDate = null;\r\n-                String lastMessageFirstName = null;\r\n-                String lastMessageLastName = null;\r\n-                String lastMessageUsername = null;\r\n-                Long chatId = null;\r\n-                String replyId = null;\r\n-                if (update.message() != null && update.message().text() != null) {\r\n-                    Message message = update.message();\r\n-                    chatId = message.chat().id();\r\n-                    if (!chatIds.contains(chatId)) {\r\n-                        logger.warn(\r\n-                                \"Ignored message from unknown chat id {}. If you know the sender of that chat, add it to the list of chat ids in the thing configuration to authorize it\",\r\n-                                chatId);\r\n-                        continue; // this is very important regarding security to avoid commands from an unknown\r\n-                                  // chat\r\n-                    }\r\n-\r\n-                    lastMessageText = message.text();\r\n-                    lastMessageDate = message.date();\r\n-                    lastMessageFirstName = message.from().firstName();\r\n-                    lastMessageLastName = message.from().lastName();\r\n-                    lastMessageUsername = message.from().username();\r\n-                } else if (update.callbackQuery() != null && update.callbackQuery().message() != null\r\n-                        && update.callbackQuery().message().text() != null) {\r\n-                    String[] callbackData = update.callbackQuery().data().split(\" \", 2);\r\n-\r\n-                    if (callbackData.length == 2) {\r\n-                        replyId = callbackData[0];\r\n-                        lastMessageText = callbackData[1];\r\n-                        lastMessageDate = update.callbackQuery().message().date();\r\n-                        lastMessageFirstName = update.callbackQuery().from().firstName();\r\n-                        lastMessageLastName = update.callbackQuery().from().lastName();\r\n-                        lastMessageUsername = update.callbackQuery().from().username();\r\n-                        chatId = update.callbackQuery().message().chat().id();\r\n-                        replyIdToCallbackId.put(new ReplyKey(chatId, replyId), update.callbackQuery().id());\r\n-                        logger.debug(\"Received callbackId {} for chatId {} and replyId {}\", update.callbackQuery().id(),\r\n-                                chatId, replyId);\r\n-                    } else {\r\n-                        logger.warn(\r\n-                                \"The received callback query {} has not the right format (must be seperated by spaces)\",\r\n-                                update.callbackQuery().data());\r\n-                    }\r\n-                }\r\n-                updateChannel(LASTMESSAGETEXT,\r\n-                        lastMessageText != null ? new StringType(lastMessageText) : UnDefType.NULL);\r\n-                updateChannel(LASTMESSAGEDATE,\r\n-                        lastMessageDate != null\r\n-                                ? new DateTimeType(ZonedDateTime\r\n-                                        .ofInstant(Instant.ofEpochSecond(lastMessageDate.intValue()), ZoneOffset.UTC))\r\n-                                : UnDefType.NULL);\r\n-                updateChannel(LASTMESSAGENAME, (lastMessageFirstName != null || lastMessageLastName != null)\r\n-                        ? new StringType((lastMessageFirstName != null ? lastMessageFirstName + \" \" : \"\")\r\n-                                + (lastMessageLastName != null ? lastMessageLastName : \"\"))\r\n-                        : UnDefType.NULL);\r\n-                updateChannel(LASTMESSAGEUSERNAME,\r\n-                        lastMessageUsername != null ? new StringType(lastMessageUsername) : UnDefType.NULL);\r\n-                updateChannel(CHATID, chatId != null ? new StringType(chatId.toString()) : UnDefType.NULL);\r\n-                updateChannel(REPLYID, replyId != null ? new StringType(replyId) : UnDefType.NULL);\r\n-            }\r\n-            return UpdatesListener.CONFIRMED_UPDATES_ALL;\r\n-        }, exception -> {\r\n-            if (exception != null) {\r\n-                if (exception.response() != null) {\r\n-                    BaseResponse localResponse = exception.response();\r\n-                    if (localResponse.errorCode() == 401) { // unauthorized\r\n-                        cancelThingOnlineStatusJob();\r\n-                        localBot.removeGetUpdatesListener();\r\n-                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n-                                \"Unauthorized attempt to connect to the Telegram server, please check if the bot token is valid\");\r\n-                        return;\r\n-                    }\r\n-                }\r\n-                if (exception.getCause() != null) { // cause is only non-null in case of an IOException\r\n-                    cancelThingOnlineStatusJob();\r\n-                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, exception.getMessage());\r\n-                    delayThingOnlineStatus();\r\n-                    return;\r\n-                }\r\n-                logger.warn(\"Telegram exception: {}\", exception.getMessage());\r\n-            }\r\n-        });\r\n-    }\r\n-\r\n-    private synchronized void delayThingOnlineStatus() {\r\n-        thingOnlineStatusJob = scheduler.schedule(() -> {\r\n-            // if no error was returned within 10s, we assume the initialization went well\r\n-            updateStatus(ThingStatus.ONLINE);\r\n-        }, 10, TimeUnit.SECONDS);\r\n-    }\r\n-\r\n-    private synchronized void cancelThingOnlineStatusJob() {\r\n-        if (thingOnlineStatusJob != null) {\r\n-            thingOnlineStatusJob.cancel(true);\r\n-            thingOnlineStatusJob = null;\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void dispose() {\r\n-        logger.debug(\"Trying to dispose Telegram client\");\r\n-        cancelThingOnlineStatusJob();\r\n-        OkHttpClient localClient = botLibClient;\r\n-        TelegramBot localBot = bot;\r\n-        if (localClient != null && localBot != null) {\r\n-            localBot.removeGetUpdatesListener();\r\n-            localClient.dispatcher().executorService().shutdown();\r\n-            localClient.connectionPool().evictAll();\r\n-            logger.debug(\"Telegram client closed\");\r\n-        }\r\n-        super.dispose();\r\n-    }\r\n-\r\n-    public void updateChannel(String channelName, State state) {\r\n-        updateState(new ChannelUID(getThing().getUID(), channelName), state);\r\n-    }\r\n-\r\n-    @Override\r\n-    public Collection<Class<? extends ThingHandlerService>> getServices() {\r\n-        return Collections.singleton(TelegramActions.class);\r\n-    }\r\n-\r\n-    public List<Long> getChatIds() {\r\n-        return chatIds;\r\n-    }\r\n-\r\n-    public void addMessageId(Long chatId, String replyId, Integer messageId) {\r\n-        replyIdToMessageId.put(new ReplyKey(chatId, replyId), messageId);\r\n-    }\r\n-\r\n-    @Nullable\r\n-    public String getCallbackId(Long chatId, String replyId) {\r\n-        return replyIdToCallbackId.get(new ReplyKey(chatId, replyId));\r\n-    }\r\n-\r\n-    public Integer removeMessageId(Long chatId, String replyId) {\r\n-        return replyIdToMessageId.remove(new ReplyKey(chatId, replyId));\r\n-    }\r\n-\r\n-    @Nullable\r\n-    public ParseMode getParseMode() {\r\n-        return parseMode;\r\n-    }\r\n-\r\n-    @SuppressWarnings(\"rawtypes\")\r\n-    @Nullable\r\n-    public <T extends BaseRequest, R extends BaseResponse> R execute(BaseRequest<T, R> request) {\r\n-        TelegramBot localBot = bot;\r\n-        return localBot != null ? localBot.execute(request) : null;\r\n-    }\r\n-\r\n-    @Nullable\r\n-    public HttpClient getClient() {\r\n-        return downloadDataClient;\r\n-    }\r\n-\r\n-}\r\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.telegram.internal;\n+\n+import static org.openhab.binding.telegram.internal.TelegramBindingConstants.*;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.telegram.bot.TelegramActions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.pengrad.telegrambot.TelegramBot;\n+import com.pengrad.telegrambot.UpdatesListener;\n+import com.pengrad.telegrambot.model.Message;\n+import com.pengrad.telegrambot.model.Update;\n+import com.pengrad.telegrambot.model.request.ParseMode;\n+import com.pengrad.telegrambot.request.BaseRequest;\n+import com.pengrad.telegrambot.response.BaseResponse;\n+\n+import okhttp3.OkHttpClient;\n+\n+/**\n+ * The {@link TelegramHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jens Runge - Initial contribution\n+ * @author Alexander Krasnogolowy - using Telegram library from pengrad\n+ */\n+@NonNullByDefault\n+public class TelegramHandler extends BaseThingHandler {\n+\n+    @NonNullByDefault\n+    private class ReplyKey {\n+\n+        final Long chatId;\n+        final String replyId;\n+\n+        public ReplyKey(Long chatId, String replyId) {\n+            this.chatId = chatId;\n+            this.replyId = replyId;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(chatId, replyId);\n+        }\n+\n+        @Override\n+        public boolean equals(@Nullable Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            ReplyKey other = (ReplyKey) obj;\n+            return Objects.equals(chatId, other.chatId) && Objects.equals(replyId, other.replyId);\n+        }\n+    }\n+\n+    private final List<Long> chatIds = new ArrayList<Long>();\n+    private final Logger logger = LoggerFactory.getLogger(TelegramHandler.class);\n+    private @Nullable ScheduledFuture<?> thingOnlineStatusJob;\n+\n+    // Keep track of the callback id created by Telegram. This must be sent back in\n+    // the answerCallbackQuery\n+    // to stop the progress bar in the Telegram client\n+    private final Map<ReplyKey, String> replyIdToCallbackId = new HashMap<>();\n+    // Keep track of message id sent with reply markup because we want to remove the\n+    // markup after the user provided an\n+    // answer and need the id of the original message\n+    private final Map<ReplyKey, Integer> replyIdToMessageId = new HashMap<>();\n+\n+    private @Nullable TelegramBot bot;\n+    private @Nullable OkHttpClient botLibClient;\n+    private @Nullable HttpClient downloadDataClient;\n+    private @Nullable ParseMode parseMode;\n+\n+    public TelegramHandler(Thing thing, @Nullable HttpClient httpClient) {\n+        super(thing);\n+        downloadDataClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands to handle\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        TelegramConfiguration config = getConfigAs(TelegramConfiguration.class);\n+\n+        String botToken = config.getBotToken();\n+        chatIds.clear();\n+        for (String chatIdStr : config.getChatIds()) {\n+            try {\n+                chatIds.add(Long.valueOf(chatIdStr));\n+            } catch (NumberFormatException e) {\n+                logger.warn(\"The chat id {} is not a number and will be ignored\", chatIdStr);\n+            }\n+        }\n+        if (config.getParseMode() != null) {\n+            try {\n+                parseMode = ParseMode.valueOf(config.getParseMode());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"parseMode is invalid and will be ignored. Only Markdown or HTML are allowed values\");\n+            }\n+        }\n+\n+        OkHttpClient.Builder prepareConnection = new OkHttpClient.Builder().connectTimeout(75, TimeUnit.SECONDS)\n+                .readTimeout(75, TimeUnit.SECONDS);\n+\n+        String proxyHost = config.getProxyHost();\n+        Integer proxyPort = config.getProxyPort();\n+        String proxyType = config.getProxyType();\n+\n+        if (proxyHost != null) {", "originalCommit": "f286914ac56e72551e3abddac1013e39c98fd915", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e4b2372a4f455125408cb19dcd8ab2cf91662a62", "url": "https://github.com/openhab/openhab-addons/commit/e4b2372a4f455125408cb19dcd8ab2cf91662a62", "message": "Update bundles/org.openhab.binding.telegram/src/main/resources/ESH-INF/thing/thing-types.xml\n\nCo-Authored-By: J-N-K <J-N-K@users.noreply.github.com>", "committedDate": "2020-03-02T05:55:42Z", "type": "commit"}, {"oid": "0dda00cc13b4628e7b99cf5a460c3b858f2c8cba", "url": "https://github.com/openhab/openhab-addons/commit/0dda00cc13b4628e7b99cf5a460c3b858f2c8cba", "message": "Update bundles/org.openhab.binding.telegram/src/main/java/org/openhab/binding/telegram/internal/TelegramHandler.java\n\nCo-Authored-By: J-N-K <J-N-K@users.noreply.github.com>", "committedDate": "2020-03-02T05:56:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE2ODA3NA==", "url": "https://github.com/openhab/openhab-addons/pull/6824#discussion_r391168074", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        @ActionInput(name = \"message\") @Nullable String format,\n          \n          \n            \n                        @ActionInput(name = \"message\") @Nullable String message,", "author": "J-N-K", "createdAt": "2020-03-11T18:11:16Z", "path": "bundles/org.openhab.binding.telegram/src/main/java/org/openhab/binding/telegram/bot/TelegramActions.java", "diffHunk": "@@ -1,507 +1,507 @@\n-/**\r\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n- *\r\n- * See the NOTICE file(s) distributed with this work for additional\r\n- * information.\r\n- *\r\n- * This program and the accompanying materials are made available under the\r\n- * terms of the Eclipse Public License 2.0 which is available at\r\n- * http://www.eclipse.org/legal/epl-2.0\r\n- *\r\n- * SPDX-License-Identifier: EPL-2.0\r\n- */\r\n-package org.openhab.binding.telegram.bot;\r\n-\r\n-import java.io.ByteArrayInputStream;\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.net.MalformedURLException;\r\n-import java.net.URI;\r\n-import java.net.URL;\r\n-import java.nio.charset.StandardCharsets;\r\n-import java.nio.file.Paths;\r\n-import java.util.Base64;\r\n-import java.util.concurrent.ExecutionException;\r\n-import java.util.concurrent.TimeUnit;\r\n-import java.util.concurrent.TimeoutException;\r\n-\r\n-import org.apache.commons.io.IOUtils;\r\n-import org.eclipse.jdt.annotation.NonNullByDefault;\r\n-import org.eclipse.jdt.annotation.Nullable;\r\n-import org.eclipse.jetty.client.HttpClient;\r\n-import org.eclipse.jetty.client.api.Authentication;\r\n-import org.eclipse.jetty.client.api.AuthenticationStore;\r\n-import org.eclipse.jetty.client.api.ContentResponse;\r\n-import org.eclipse.jetty.client.api.Request;\r\n-import org.eclipse.jetty.http.HttpHeader;\r\n-import org.eclipse.jetty.http.HttpMethod;\r\n-import org.eclipse.jetty.util.B64Code;\r\n-import org.eclipse.smarthome.core.thing.binding.ThingActions;\r\n-import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\r\n-import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n-import org.openhab.binding.telegram.internal.TelegramHandler;\r\n-import org.openhab.core.automation.annotation.ActionInput;\r\n-import org.openhab.core.automation.annotation.RuleAction;\r\n-import org.slf4j.Logger;\r\n-import org.slf4j.LoggerFactory;\r\n-\r\n-import com.pengrad.telegrambot.model.request.InlineKeyboardButton;\r\n-import com.pengrad.telegrambot.model.request.InlineKeyboardMarkup;\r\n-import com.pengrad.telegrambot.request.AnswerCallbackQuery;\r\n-import com.pengrad.telegrambot.request.EditMessageReplyMarkup;\r\n-import com.pengrad.telegrambot.request.SendMessage;\r\n-import com.pengrad.telegrambot.request.SendPhoto;\r\n-import com.pengrad.telegrambot.response.BaseResponse;\r\n-import com.pengrad.telegrambot.response.SendResponse;\r\n-\r\n-/**\r\n- * Provides the actions for the Telegram API.\r\n- *\r\n- * @author Alexander Krasnogolowy - Initial contribution\r\n- *\r\n- */\r\n-@ThingActionsScope(name = \"telegram\")\r\n-@NonNullByDefault\r\n-public class TelegramActions implements ThingActions {\r\n-    private final Logger logger = LoggerFactory.getLogger(TelegramActions.class);\r\n-    private @Nullable TelegramHandler handler;\r\n-\r\n-    private boolean evaluateResponse(@Nullable BaseResponse response) {\r\n-        if (response != null && !response.isOk()) {\r\n-            logger.warn(\"Failed to send telegram message: {}\", response.description());\r\n-            return false;\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @NonNullByDefault\r\n-    private static class BasicResult implements Authentication.Result {\r\n-\r\n-        private final HttpHeader header;\r\n-        private final URI uri;\r\n-        private final String value;\r\n-\r\n-        public BasicResult(HttpHeader header, URI uri, String value) {\r\n-            this.header = header;\r\n-            this.uri = uri;\r\n-            this.value = value;\r\n-        }\r\n-\r\n-        @Override\r\n-        public URI getURI() {\r\n-            return this.uri;\r\n-        }\r\n-\r\n-        @Override\r\n-        public void apply(@Nullable Request request) {\r\n-            if (request != null) {\r\n-                request.header(this.header, this.value);\r\n-            }\r\n-        }\r\n-\r\n-        public String toString() {\r\n-            return String.format(\"Basic authentication result for %s\", this.uri);\r\n-        }\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram answer\", description = \"Sends a Telegram answer via Telegram API\")\r\n-    public boolean sendTelegramAnswer(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"replyId\") @Nullable String replyId,\r\n-            @ActionInput(name = \"message\") @Nullable String message) {\r\n-        if (replyId == null) {\r\n-            logger.warn(\"ReplyId not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-        if (chatId == null) {\r\n-            logger.warn(\"chatId not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            String callbackId = localHandler.getCallbackId(chatId, replyId);\r\n-            if (callbackId != null) {\r\n-                AnswerCallbackQuery answerCallbackQuery = new AnswerCallbackQuery(\r\n-                        localHandler.getCallbackId(chatId, replyId));\r\n-                logger.debug(\"AnswerCallbackQuery for chatId {} and replyId {} is the callbackId {}\", chatId, replyId,\r\n-                        localHandler.getCallbackId(chatId, replyId));\r\n-                // we could directly set the text here, but this\r\n-                // doesn't result in a real message only in a\r\n-                // little popup or in an alert, so the only purpose\r\n-                // is to stop the progress bar on client side\r\n-                if (!evaluateResponse(localHandler.execute(answerCallbackQuery))) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-            Integer messageId = localHandler.removeMessageId(chatId, replyId);\r\n-            logger.debug(\"remove messageId {} for chatId {} and replyId {}\", messageId, chatId, replyId);\r\n-\r\n-            EditMessageReplyMarkup editReplyMarkup = new EditMessageReplyMarkup(chatId, messageId.intValue())\r\n-                    .replyMarkup(new InlineKeyboardMarkup(new InlineKeyboardButton[0]));// remove reply markup from\r\n-                                                                                        // old message\r\n-            if (!evaluateResponse(localHandler.execute(editReplyMarkup))) {\r\n-                return false;\r\n-            }\r\n-            return message != null ? sendTelegram(chatId, message) : true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram answer\", description = \"Sends a Telegram answer via Telegram API\")\r\n-    public boolean sendTelegramAnswer(@ActionInput(name = \"replyId\") @Nullable String replyId,\r\n-            @ActionInput(name = \"message\") @Nullable String message) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegramAnswer(chatId, replyId, message)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegram(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"message\") @Nullable String message) {\r\n-        return sendTelegramGeneral(chatId, message, (String) null);\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegram(@ActionInput(name = \"message\") @Nullable String message) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegram(chatId, message)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegramQuery(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"message\") @Nullable String message,\r\n-            @ActionInput(name = \"replyId\") @Nullable String replyId,\r\n-            @ActionInput(name = \"buttons\") @Nullable String... buttons) {\r\n-        return sendTelegramGeneral(chatId, message, replyId, buttons);\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegramQuery(@ActionInput(name = \"message\") @Nullable String message,\r\n-            @ActionInput(name = \"replyId\") @Nullable String replyId,\r\n-            @ActionInput(name = \"buttons\") @Nullable String... buttons) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegramQuery(chatId, message, replyId, buttons)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    private boolean sendTelegramGeneral(@ActionInput(name = \"chatId\") @Nullable Long chatId, @Nullable String message,\r\n-            @Nullable String replyId, @Nullable String... buttons) {\r\n-        if (message == null) {\r\n-            logger.warn(\"Message not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-        if (chatId == null) {\r\n-            logger.warn(\"chatId not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            SendMessage sendMessage = new SendMessage(chatId, message);\r\n-            if (localHandler.getParseMode() != null) {\r\n-                sendMessage.parseMode(localHandler.getParseMode());\r\n-            }\r\n-            if (replyId != null) {\r\n-                if (!replyId.contains(\" \")) {\r\n-                    if (buttons.length > 0) {\r\n-                        InlineKeyboardButton[][] keyboard2D = new InlineKeyboardButton[1][];\r\n-                        InlineKeyboardButton[] keyboard = new InlineKeyboardButton[buttons.length];\r\n-                        keyboard2D[0] = keyboard;\r\n-                        for (int i = 0; i < buttons.length; i++) {\r\n-                            keyboard[i] = new InlineKeyboardButton(buttons[i]).callbackData(replyId + \" \" + buttons[i]);\r\n-                        }\r\n-                        InlineKeyboardMarkup keyBoardMarkup = new InlineKeyboardMarkup(keyboard2D);\r\n-                        sendMessage.replyMarkup(keyBoardMarkup);\r\n-                    } else {\r\n-                        logger.warn(\r\n-                                \"The replyId {} for message {} is given, but no buttons are defined. ReplyMarkup will be ignored.\",\r\n-                                replyId, message);\r\n-                    }\r\n-                } else {\r\n-                    logger.warn(\"replyId {} must not contain spaces. ReplyMarkup will be ignored.\", replyId);\r\n-                }\r\n-            }\r\n-            SendResponse retMessage = localHandler.execute(sendMessage);\r\n-            if (!evaluateResponse(retMessage)) {\r\n-                return false;\r\n-            }\r\n-            if (replyId != null && retMessage != null) {\r\n-                logger.debug(\"Adding chatId {}, replyId {} and messageId {}\", chatId, replyId,\r\n-                        retMessage.message().messageId());\r\n-                localHandler.addMessageId(chatId, replyId, retMessage.message().messageId());\r\n-            }\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegram(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"message\") @Nullable String message,\r\n-            @ActionInput(name = \"args\") @Nullable Object... args) {\r\n-        return sendTelegram(chatId, args == null || args.length == 0 ? message : String.format(message, args));\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegram(@ActionInput(name = \"message\") @Nullable String message,\r\n-            @ActionInput(name = \"args\") @Nullable Object... args) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegram(chatId, message, args)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram photo\", description = \"Sends a Picture via Telegram API\")\r\n-    public boolean sendTelegramPhoto(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"photoURL\") @Nullable String photoURL,\r\n-            @ActionInput(name = \"caption\") @Nullable String caption) {\r\n-        return sendTelegramPhoto(chatId, photoURL, caption, null, null);\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram photo\", description = \"Sends a Picture via Telegram API\")\r\n-    public boolean sendTelegramPhoto(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"photoURL\") @Nullable String photoURL,\r\n-            @ActionInput(name = \"caption\") @Nullable String caption,\r\n-            @ActionInput(name = \"username\") @Nullable String username,\r\n-            @ActionInput(name = \"password\") @Nullable String password) {\r\n-        if (photoURL == null) {\r\n-            logger.warn(\"Photo URL not defined; unable to retrieve photo for sending.\");\r\n-            return false;\r\n-        }\r\n-        if (chatId == null) {\r\n-            logger.warn(\"chatId not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            final SendPhoto sendPhoto;\r\n-\r\n-            if (photoURL.toLowerCase().startsWith(\"http\")) {\r\n-                // load image from url\r\n-                logger.debug(\"Photo URL provided.\");\r\n-                HttpClient client = localHandler.getClient();\r\n-                if (client == null) {\r\n-                    return false;\r\n-                }\r\n-                Request request = client.newRequest(photoURL).method(HttpMethod.GET).timeout(30, TimeUnit.SECONDS);\r\n-                if (username != null && password != null) {\r\n-                    AuthenticationStore auth = client.getAuthenticationStore();\r\n-                    URI uri = URI.create(photoURL);\r\n-                    auth.addAuthenticationResult(new BasicResult(HttpHeader.AUTHORIZATION, uri,\r\n-                            \"Basic \" + B64Code.encode(username + \":\" + password, StandardCharsets.ISO_8859_1)));\r\n-                }\r\n-                try {\r\n-                    ContentResponse contentResponse = request.send();\r\n-                    if (contentResponse.getStatus() == 200) {\r\n-                        byte[] fileContent = contentResponse.getContent();\r\n-                        sendPhoto = new SendPhoto(chatId, fileContent);\r\n-                    } else {\r\n-                        logger.warn(\"Download from {} failed with status: {}\", photoURL, contentResponse.getStatus());\r\n-                        return false;\r\n-                    }\r\n-                } catch (InterruptedException | TimeoutException | ExecutionException e) {\r\n-                    logger.warn(\"Download from {} failed with exception: {}\", photoURL, e.getMessage());\r\n-                    return false;\r\n-                }\r\n-            } else if (photoURL.toLowerCase().startsWith(\"file\")) {\r\n-                // Load image from local file system\r\n-                logger.debug(\"Read file from local file system: {}\", photoURL);\r\n-                try {\r\n-                    URL url = new URL(photoURL);\r\n-                    sendPhoto = new SendPhoto(chatId, Paths.get(url.getPath()).toFile());\r\n-                } catch (MalformedURLException e) {\r\n-                    logger.warn(\"Malformed URL: {}\", photoURL);\r\n-                    return false;\r\n-                }\r\n-            } else {\r\n-                // Load image from provided base64 image\r\n-                logger.debug(\"Photo base64 provided; converting to binary.\");\r\n-                final String photoB64Data;\r\n-                if (photoURL.startsWith(\"data:\")) { // support data URI scheme\r\n-                    String[] photoURLParts = photoURL.split(\",\");\r\n-                    if (photoURLParts.length > 1) {\r\n-                        photoB64Data = photoURLParts[1];\r\n-                    } else {\r\n-                        logger.warn(\"The provided base64 string is not a valid data URI scheme\");\r\n-                        return false;\r\n-                    }\r\n-                } else {\r\n-                    photoB64Data = photoURL;\r\n-                }\r\n-                InputStream is = Base64.getDecoder()\r\n-                        .wrap(new ByteArrayInputStream(photoB64Data.getBytes(StandardCharsets.UTF_8)));\r\n-                try {\r\n-                    byte[] photoBytes = IOUtils.toByteArray(is);\r\n-                    sendPhoto = new SendPhoto(chatId, photoBytes);\r\n-                } catch (IOException e) {\r\n-                    logger.warn(\"Malformed base64 string: {}\", e.getMessage());\r\n-                    return false;\r\n-                }\r\n-            }\r\n-            sendPhoto.caption(caption);\r\n-            if (localHandler.getParseMode() != null) {\r\n-                sendPhoto.parseMode(localHandler.getParseMode());\r\n-            }\r\n-            return evaluateResponse(localHandler.execute(sendPhoto));\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram photo\", description = \"Sends a Picture via Telegram API\")\r\n-    public boolean sendTelegramPhoto(@ActionInput(name = \"photoURL\") @Nullable String photoURL,\r\n-            @ActionInput(name = \"caption\") @Nullable String caption,\r\n-            @ActionInput(name = \"username\") @Nullable String username,\r\n-            @ActionInput(name = \"password\") @Nullable String password) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegramPhoto(chatId, photoURL, caption, username, password)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram photo\", description = \"Sends a Picture via Telegram API\")\r\n-    public boolean sendTelegramPhoto(@ActionInput(name = \"photoURL\") @Nullable String photoURL,\r\n-            @ActionInput(name = \"caption\") @Nullable String caption) {\r\n-        return sendTelegramPhoto(photoURL, caption, null, null);\r\n-    }\r\n-\r\n-    // legacy delegate methods\r\n-    /* APIs without chatId parameter */\r\n-    public static boolean sendTelegram(@Nullable ThingActions actions, @Nullable String message,\r\n-            @Nullable Object... args) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegram(message, args);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramQuery(@Nullable ThingActions actions, @Nullable String message,\r\n-            @Nullable String replyId, @Nullable String... buttons) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramQuery(message, replyId, buttons);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramPhoto(@Nullable ThingActions actions, @Nullable String photoURL,\r\n-            @Nullable String caption) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramPhoto(photoURL, caption);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramPhoto(@Nullable ThingActions actions, @Nullable String photoURL,\r\n-            @Nullable String caption, @Nullable String username, @Nullable String password) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramPhoto(photoURL, caption, username, password);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramAnswer(@Nullable ThingActions actions, @Nullable String replyId,\r\n-            @Nullable String message) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramAnswer(replyId, message);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    /* APIs with chatId parameter */\r\n-\r\n-    public static boolean sendTelegram(@Nullable ThingActions actions, @Nullable Long chatId, @Nullable String message,\r\n-            @Nullable Object... args) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegram(chatId, message, args);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramQuery(@Nullable ThingActions actions, @Nullable Long chatId,\r\n-            @Nullable String message, @Nullable String replyId, @Nullable String... buttons) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramQuery(chatId, message, replyId, buttons);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramPhoto(@Nullable ThingActions actions, @Nullable Long chatId,\r\n-            @Nullable String photoURL, @Nullable String caption) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramPhoto(chatId, photoURL, caption);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramPhoto(@Nullable ThingActions actions, @Nullable Long chatId,\r\n-            @Nullable String photoURL, @Nullable String caption, @Nullable String username, @Nullable String password) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramPhoto(chatId, photoURL, caption, username, password);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramAnswer(@Nullable ThingActions actions, @Nullable Long chatId,\r\n-            @Nullable String replyId, @Nullable String message) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramAnswer(chatId, replyId, message);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramAnswer(@Nullable ThingActions actions, @Nullable String chatId,\r\n-            @Nullable String replyId, @Nullable String message) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramAnswer(Long.valueOf(chatId), replyId, message);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void setThingHandler(@Nullable ThingHandler handler) {\r\n-        this.handler = (TelegramHandler) handler;\r\n-    }\r\n-\r\n-    @Override\r\n-    public @Nullable ThingHandler getThingHandler() {\r\n-        return handler;\r\n-    }\r\n-}\r\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.telegram.bot;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Paths;\n+import java.util.Base64;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.telegram.internal.TelegramHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.pengrad.telegrambot.model.request.InlineKeyboardButton;\n+import com.pengrad.telegrambot.model.request.InlineKeyboardMarkup;\n+import com.pengrad.telegrambot.request.AnswerCallbackQuery;\n+import com.pengrad.telegrambot.request.EditMessageReplyMarkup;\n+import com.pengrad.telegrambot.request.SendMessage;\n+import com.pengrad.telegrambot.request.SendPhoto;\n+import com.pengrad.telegrambot.response.BaseResponse;\n+import com.pengrad.telegrambot.response.SendResponse;\n+\n+/**\n+ * Provides the actions for the Telegram API.\n+ *\n+ * @author Alexander Krasnogolowy - Initial contribution\n+ *\n+ */\n+@ThingActionsScope(name = \"telegram\")\n+@NonNullByDefault\n+public class TelegramActions implements ThingActions {\n+    private final Logger logger = LoggerFactory.getLogger(TelegramActions.class);\n+    private @Nullable TelegramHandler handler;\n+\n+    private boolean evaluateResponse(@Nullable BaseResponse response) {\n+        if (response != null && !response.isOk()) {\n+            logger.warn(\"Failed to send telegram message: {}\", response.description());\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @NonNullByDefault\n+    private static class BasicResult implements Authentication.Result {\n+\n+        private final HttpHeader header;\n+        private final URI uri;\n+        private final String value;\n+\n+        public BasicResult(HttpHeader header, URI uri, String value) {\n+            this.header = header;\n+            this.uri = uri;\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public URI getURI() {\n+            return this.uri;\n+        }\n+\n+        @Override\n+        public void apply(@Nullable Request request) {\n+            if (request != null) {\n+                request.header(this.header, this.value);\n+            }\n+        }\n+\n+        public String toString() {\n+            return String.format(\"Basic authentication result for %s\", this.uri);\n+        }\n+    }\n+\n+    @RuleAction(label = \"Telegram answer\", description = \"Sends a Telegram answer via Telegram API\")\n+    public boolean sendTelegramAnswer(@ActionInput(name = \"chatId\") @Nullable Long chatId,\n+            @ActionInput(name = \"replyId\") @Nullable String replyId,\n+            @ActionInput(name = \"message\") @Nullable String message) {\n+        if (replyId == null) {\n+            logger.warn(\"ReplyId not defined; action skipped.\");\n+            return false;\n+        }\n+        if (chatId == null) {\n+            logger.warn(\"chatId not defined; action skipped.\");\n+            return false;\n+        }\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            String callbackId = localHandler.getCallbackId(chatId, replyId);\n+            if (callbackId != null) {\n+                AnswerCallbackQuery answerCallbackQuery = new AnswerCallbackQuery(\n+                        localHandler.getCallbackId(chatId, replyId));\n+                logger.debug(\"AnswerCallbackQuery for chatId {} and replyId {} is the callbackId {}\", chatId, replyId,\n+                        localHandler.getCallbackId(chatId, replyId));\n+                // we could directly set the text here, but this\n+                // doesn't result in a real message only in a\n+                // little popup or in an alert, so the only purpose\n+                // is to stop the progress bar on client side\n+                if (!evaluateResponse(localHandler.execute(answerCallbackQuery))) {\n+                    return false;\n+                }\n+            }\n+            Integer messageId = localHandler.removeMessageId(chatId, replyId);\n+            logger.debug(\"remove messageId {} for chatId {} and replyId {}\", messageId, chatId, replyId);\n+\n+            EditMessageReplyMarkup editReplyMarkup = new EditMessageReplyMarkup(chatId, messageId.intValue())\n+                    .replyMarkup(new InlineKeyboardMarkup(new InlineKeyboardButton[0]));// remove reply markup from\n+                                                                                        // old message\n+            if (!evaluateResponse(localHandler.execute(editReplyMarkup))) {\n+                return false;\n+            }\n+            return message != null ? sendTelegram(chatId, message) : true;\n+        }\n+        return false;\n+    }\n+\n+    @RuleAction(label = \"Telegram answer\", description = \"Sends a Telegram answer via Telegram API\")\n+    public boolean sendTelegramAnswer(@ActionInput(name = \"replyId\") @Nullable String replyId,\n+            @ActionInput(name = \"message\") @Nullable String message) {\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            for (Long chatId : localHandler.getChatIds()) {\n+                if (!sendTelegramAnswer(chatId, replyId, message)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegram(@ActionInput(name = \"chatId\") @Nullable Long chatId,\n+            @ActionInput(name = \"message\") @Nullable String message) {\n+        return sendTelegramGeneral(chatId, message, (String) null);\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegram(@ActionInput(name = \"message\") @Nullable String message) {\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            for (Long chatId : localHandler.getChatIds()) {\n+                if (!sendTelegram(chatId, message)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegramQuery(@ActionInput(name = \"chatId\") @Nullable Long chatId,\n+            @ActionInput(name = \"message\") @Nullable String message,\n+            @ActionInput(name = \"replyId\") @Nullable String replyId,\n+            @ActionInput(name = \"buttons\") @Nullable String... buttons) {\n+        return sendTelegramGeneral(chatId, message, replyId, buttons);\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegramQuery(@ActionInput(name = \"message\") @Nullable String message,\n+            @ActionInput(name = \"replyId\") @Nullable String replyId,\n+            @ActionInput(name = \"buttons\") @Nullable String... buttons) {\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            for (Long chatId : localHandler.getChatIds()) {\n+                if (!sendTelegramQuery(chatId, message, replyId, buttons)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean sendTelegramGeneral(@ActionInput(name = \"chatId\") @Nullable Long chatId, @Nullable String message,\n+            @Nullable String replyId, @Nullable String... buttons) {\n+        if (message == null) {\n+            logger.warn(\"Message not defined; action skipped.\");\n+            return false;\n+        }\n+        if (chatId == null) {\n+            logger.warn(\"chatId not defined; action skipped.\");\n+            return false;\n+        }\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            SendMessage sendMessage = new SendMessage(chatId, message);\n+            if (localHandler.getParseMode() != null) {\n+                sendMessage.parseMode(localHandler.getParseMode());\n+            }\n+            if (replyId != null) {\n+                if (!replyId.contains(\" \")) {\n+                    if (buttons.length > 0) {\n+                        InlineKeyboardButton[][] keyboard2D = new InlineKeyboardButton[1][];\n+                        InlineKeyboardButton[] keyboard = new InlineKeyboardButton[buttons.length];\n+                        keyboard2D[0] = keyboard;\n+                        for (int i = 0; i < buttons.length; i++) {\n+                            keyboard[i] = new InlineKeyboardButton(buttons[i]).callbackData(replyId + \" \" + buttons[i]);\n+                        }\n+                        InlineKeyboardMarkup keyBoardMarkup = new InlineKeyboardMarkup(keyboard2D);\n+                        sendMessage.replyMarkup(keyBoardMarkup);\n+                    } else {\n+                        logger.warn(\n+                                \"The replyId {} for message {} is given, but no buttons are defined. ReplyMarkup will be ignored.\",\n+                                replyId, message);\n+                    }\n+                } else {\n+                    logger.warn(\"replyId {} must not contain spaces. ReplyMarkup will be ignored.\", replyId);\n+                }\n+            }\n+            SendResponse retMessage = localHandler.execute(sendMessage);\n+            if (!evaluateResponse(retMessage)) {\n+                return false;\n+            }\n+            if (replyId != null && retMessage != null) {\n+                logger.debug(\"Adding chatId {}, replyId {} and messageId {}\", chatId, replyId,\n+                        retMessage.message().messageId());\n+                localHandler.addMessageId(chatId, replyId, retMessage.message().messageId());\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegram(@ActionInput(name = \"chatId\") @Nullable Long chatId,\n+            @ActionInput(name = \"message\") @Nullable String format,", "originalCommit": "f286914ac56e72551e3abddac1013e39c98fd915", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE2ODI4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6824#discussion_r391168289", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return sendTelegram(chatId, String.format(format, args));\n          \n          \n            \n                    return sendTelegram(chatId, String.format(message, args));", "author": "J-N-K", "createdAt": "2020-03-11T18:11:38Z", "path": "bundles/org.openhab.binding.telegram/src/main/java/org/openhab/binding/telegram/bot/TelegramActions.java", "diffHunk": "@@ -1,507 +1,507 @@\n-/**\r\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n- *\r\n- * See the NOTICE file(s) distributed with this work for additional\r\n- * information.\r\n- *\r\n- * This program and the accompanying materials are made available under the\r\n- * terms of the Eclipse Public License 2.0 which is available at\r\n- * http://www.eclipse.org/legal/epl-2.0\r\n- *\r\n- * SPDX-License-Identifier: EPL-2.0\r\n- */\r\n-package org.openhab.binding.telegram.bot;\r\n-\r\n-import java.io.ByteArrayInputStream;\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.net.MalformedURLException;\r\n-import java.net.URI;\r\n-import java.net.URL;\r\n-import java.nio.charset.StandardCharsets;\r\n-import java.nio.file.Paths;\r\n-import java.util.Base64;\r\n-import java.util.concurrent.ExecutionException;\r\n-import java.util.concurrent.TimeUnit;\r\n-import java.util.concurrent.TimeoutException;\r\n-\r\n-import org.apache.commons.io.IOUtils;\r\n-import org.eclipse.jdt.annotation.NonNullByDefault;\r\n-import org.eclipse.jdt.annotation.Nullable;\r\n-import org.eclipse.jetty.client.HttpClient;\r\n-import org.eclipse.jetty.client.api.Authentication;\r\n-import org.eclipse.jetty.client.api.AuthenticationStore;\r\n-import org.eclipse.jetty.client.api.ContentResponse;\r\n-import org.eclipse.jetty.client.api.Request;\r\n-import org.eclipse.jetty.http.HttpHeader;\r\n-import org.eclipse.jetty.http.HttpMethod;\r\n-import org.eclipse.jetty.util.B64Code;\r\n-import org.eclipse.smarthome.core.thing.binding.ThingActions;\r\n-import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\r\n-import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n-import org.openhab.binding.telegram.internal.TelegramHandler;\r\n-import org.openhab.core.automation.annotation.ActionInput;\r\n-import org.openhab.core.automation.annotation.RuleAction;\r\n-import org.slf4j.Logger;\r\n-import org.slf4j.LoggerFactory;\r\n-\r\n-import com.pengrad.telegrambot.model.request.InlineKeyboardButton;\r\n-import com.pengrad.telegrambot.model.request.InlineKeyboardMarkup;\r\n-import com.pengrad.telegrambot.request.AnswerCallbackQuery;\r\n-import com.pengrad.telegrambot.request.EditMessageReplyMarkup;\r\n-import com.pengrad.telegrambot.request.SendMessage;\r\n-import com.pengrad.telegrambot.request.SendPhoto;\r\n-import com.pengrad.telegrambot.response.BaseResponse;\r\n-import com.pengrad.telegrambot.response.SendResponse;\r\n-\r\n-/**\r\n- * Provides the actions for the Telegram API.\r\n- *\r\n- * @author Alexander Krasnogolowy - Initial contribution\r\n- *\r\n- */\r\n-@ThingActionsScope(name = \"telegram\")\r\n-@NonNullByDefault\r\n-public class TelegramActions implements ThingActions {\r\n-    private final Logger logger = LoggerFactory.getLogger(TelegramActions.class);\r\n-    private @Nullable TelegramHandler handler;\r\n-\r\n-    private boolean evaluateResponse(@Nullable BaseResponse response) {\r\n-        if (response != null && !response.isOk()) {\r\n-            logger.warn(\"Failed to send telegram message: {}\", response.description());\r\n-            return false;\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @NonNullByDefault\r\n-    private static class BasicResult implements Authentication.Result {\r\n-\r\n-        private final HttpHeader header;\r\n-        private final URI uri;\r\n-        private final String value;\r\n-\r\n-        public BasicResult(HttpHeader header, URI uri, String value) {\r\n-            this.header = header;\r\n-            this.uri = uri;\r\n-            this.value = value;\r\n-        }\r\n-\r\n-        @Override\r\n-        public URI getURI() {\r\n-            return this.uri;\r\n-        }\r\n-\r\n-        @Override\r\n-        public void apply(@Nullable Request request) {\r\n-            if (request != null) {\r\n-                request.header(this.header, this.value);\r\n-            }\r\n-        }\r\n-\r\n-        public String toString() {\r\n-            return String.format(\"Basic authentication result for %s\", this.uri);\r\n-        }\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram answer\", description = \"Sends a Telegram answer via Telegram API\")\r\n-    public boolean sendTelegramAnswer(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"replyId\") @Nullable String replyId,\r\n-            @ActionInput(name = \"message\") @Nullable String message) {\r\n-        if (replyId == null) {\r\n-            logger.warn(\"ReplyId not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-        if (chatId == null) {\r\n-            logger.warn(\"chatId not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            String callbackId = localHandler.getCallbackId(chatId, replyId);\r\n-            if (callbackId != null) {\r\n-                AnswerCallbackQuery answerCallbackQuery = new AnswerCallbackQuery(\r\n-                        localHandler.getCallbackId(chatId, replyId));\r\n-                logger.debug(\"AnswerCallbackQuery for chatId {} and replyId {} is the callbackId {}\", chatId, replyId,\r\n-                        localHandler.getCallbackId(chatId, replyId));\r\n-                // we could directly set the text here, but this\r\n-                // doesn't result in a real message only in a\r\n-                // little popup or in an alert, so the only purpose\r\n-                // is to stop the progress bar on client side\r\n-                if (!evaluateResponse(localHandler.execute(answerCallbackQuery))) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-            Integer messageId = localHandler.removeMessageId(chatId, replyId);\r\n-            logger.debug(\"remove messageId {} for chatId {} and replyId {}\", messageId, chatId, replyId);\r\n-\r\n-            EditMessageReplyMarkup editReplyMarkup = new EditMessageReplyMarkup(chatId, messageId.intValue())\r\n-                    .replyMarkup(new InlineKeyboardMarkup(new InlineKeyboardButton[0]));// remove reply markup from\r\n-                                                                                        // old message\r\n-            if (!evaluateResponse(localHandler.execute(editReplyMarkup))) {\r\n-                return false;\r\n-            }\r\n-            return message != null ? sendTelegram(chatId, message) : true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram answer\", description = \"Sends a Telegram answer via Telegram API\")\r\n-    public boolean sendTelegramAnswer(@ActionInput(name = \"replyId\") @Nullable String replyId,\r\n-            @ActionInput(name = \"message\") @Nullable String message) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegramAnswer(chatId, replyId, message)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegram(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"message\") @Nullable String message) {\r\n-        return sendTelegramGeneral(chatId, message, (String) null);\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegram(@ActionInput(name = \"message\") @Nullable String message) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegram(chatId, message)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegramQuery(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"message\") @Nullable String message,\r\n-            @ActionInput(name = \"replyId\") @Nullable String replyId,\r\n-            @ActionInput(name = \"buttons\") @Nullable String... buttons) {\r\n-        return sendTelegramGeneral(chatId, message, replyId, buttons);\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegramQuery(@ActionInput(name = \"message\") @Nullable String message,\r\n-            @ActionInput(name = \"replyId\") @Nullable String replyId,\r\n-            @ActionInput(name = \"buttons\") @Nullable String... buttons) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegramQuery(chatId, message, replyId, buttons)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    private boolean sendTelegramGeneral(@ActionInput(name = \"chatId\") @Nullable Long chatId, @Nullable String message,\r\n-            @Nullable String replyId, @Nullable String... buttons) {\r\n-        if (message == null) {\r\n-            logger.warn(\"Message not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-        if (chatId == null) {\r\n-            logger.warn(\"chatId not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            SendMessage sendMessage = new SendMessage(chatId, message);\r\n-            if (localHandler.getParseMode() != null) {\r\n-                sendMessage.parseMode(localHandler.getParseMode());\r\n-            }\r\n-            if (replyId != null) {\r\n-                if (!replyId.contains(\" \")) {\r\n-                    if (buttons.length > 0) {\r\n-                        InlineKeyboardButton[][] keyboard2D = new InlineKeyboardButton[1][];\r\n-                        InlineKeyboardButton[] keyboard = new InlineKeyboardButton[buttons.length];\r\n-                        keyboard2D[0] = keyboard;\r\n-                        for (int i = 0; i < buttons.length; i++) {\r\n-                            keyboard[i] = new InlineKeyboardButton(buttons[i]).callbackData(replyId + \" \" + buttons[i]);\r\n-                        }\r\n-                        InlineKeyboardMarkup keyBoardMarkup = new InlineKeyboardMarkup(keyboard2D);\r\n-                        sendMessage.replyMarkup(keyBoardMarkup);\r\n-                    } else {\r\n-                        logger.warn(\r\n-                                \"The replyId {} for message {} is given, but no buttons are defined. ReplyMarkup will be ignored.\",\r\n-                                replyId, message);\r\n-                    }\r\n-                } else {\r\n-                    logger.warn(\"replyId {} must not contain spaces. ReplyMarkup will be ignored.\", replyId);\r\n-                }\r\n-            }\r\n-            SendResponse retMessage = localHandler.execute(sendMessage);\r\n-            if (!evaluateResponse(retMessage)) {\r\n-                return false;\r\n-            }\r\n-            if (replyId != null && retMessage != null) {\r\n-                logger.debug(\"Adding chatId {}, replyId {} and messageId {}\", chatId, replyId,\r\n-                        retMessage.message().messageId());\r\n-                localHandler.addMessageId(chatId, replyId, retMessage.message().messageId());\r\n-            }\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegram(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"message\") @Nullable String message,\r\n-            @ActionInput(name = \"args\") @Nullable Object... args) {\r\n-        return sendTelegram(chatId, args == null || args.length == 0 ? message : String.format(message, args));\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegram(@ActionInput(name = \"message\") @Nullable String message,\r\n-            @ActionInput(name = \"args\") @Nullable Object... args) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegram(chatId, message, args)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram photo\", description = \"Sends a Picture via Telegram API\")\r\n-    public boolean sendTelegramPhoto(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"photoURL\") @Nullable String photoURL,\r\n-            @ActionInput(name = \"caption\") @Nullable String caption) {\r\n-        return sendTelegramPhoto(chatId, photoURL, caption, null, null);\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram photo\", description = \"Sends a Picture via Telegram API\")\r\n-    public boolean sendTelegramPhoto(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"photoURL\") @Nullable String photoURL,\r\n-            @ActionInput(name = \"caption\") @Nullable String caption,\r\n-            @ActionInput(name = \"username\") @Nullable String username,\r\n-            @ActionInput(name = \"password\") @Nullable String password) {\r\n-        if (photoURL == null) {\r\n-            logger.warn(\"Photo URL not defined; unable to retrieve photo for sending.\");\r\n-            return false;\r\n-        }\r\n-        if (chatId == null) {\r\n-            logger.warn(\"chatId not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            final SendPhoto sendPhoto;\r\n-\r\n-            if (photoURL.toLowerCase().startsWith(\"http\")) {\r\n-                // load image from url\r\n-                logger.debug(\"Photo URL provided.\");\r\n-                HttpClient client = localHandler.getClient();\r\n-                if (client == null) {\r\n-                    return false;\r\n-                }\r\n-                Request request = client.newRequest(photoURL).method(HttpMethod.GET).timeout(30, TimeUnit.SECONDS);\r\n-                if (username != null && password != null) {\r\n-                    AuthenticationStore auth = client.getAuthenticationStore();\r\n-                    URI uri = URI.create(photoURL);\r\n-                    auth.addAuthenticationResult(new BasicResult(HttpHeader.AUTHORIZATION, uri,\r\n-                            \"Basic \" + B64Code.encode(username + \":\" + password, StandardCharsets.ISO_8859_1)));\r\n-                }\r\n-                try {\r\n-                    ContentResponse contentResponse = request.send();\r\n-                    if (contentResponse.getStatus() == 200) {\r\n-                        byte[] fileContent = contentResponse.getContent();\r\n-                        sendPhoto = new SendPhoto(chatId, fileContent);\r\n-                    } else {\r\n-                        logger.warn(\"Download from {} failed with status: {}\", photoURL, contentResponse.getStatus());\r\n-                        return false;\r\n-                    }\r\n-                } catch (InterruptedException | TimeoutException | ExecutionException e) {\r\n-                    logger.warn(\"Download from {} failed with exception: {}\", photoURL, e.getMessage());\r\n-                    return false;\r\n-                }\r\n-            } else if (photoURL.toLowerCase().startsWith(\"file\")) {\r\n-                // Load image from local file system\r\n-                logger.debug(\"Read file from local file system: {}\", photoURL);\r\n-                try {\r\n-                    URL url = new URL(photoURL);\r\n-                    sendPhoto = new SendPhoto(chatId, Paths.get(url.getPath()).toFile());\r\n-                } catch (MalformedURLException e) {\r\n-                    logger.warn(\"Malformed URL: {}\", photoURL);\r\n-                    return false;\r\n-                }\r\n-            } else {\r\n-                // Load image from provided base64 image\r\n-                logger.debug(\"Photo base64 provided; converting to binary.\");\r\n-                final String photoB64Data;\r\n-                if (photoURL.startsWith(\"data:\")) { // support data URI scheme\r\n-                    String[] photoURLParts = photoURL.split(\",\");\r\n-                    if (photoURLParts.length > 1) {\r\n-                        photoB64Data = photoURLParts[1];\r\n-                    } else {\r\n-                        logger.warn(\"The provided base64 string is not a valid data URI scheme\");\r\n-                        return false;\r\n-                    }\r\n-                } else {\r\n-                    photoB64Data = photoURL;\r\n-                }\r\n-                InputStream is = Base64.getDecoder()\r\n-                        .wrap(new ByteArrayInputStream(photoB64Data.getBytes(StandardCharsets.UTF_8)));\r\n-                try {\r\n-                    byte[] photoBytes = IOUtils.toByteArray(is);\r\n-                    sendPhoto = new SendPhoto(chatId, photoBytes);\r\n-                } catch (IOException e) {\r\n-                    logger.warn(\"Malformed base64 string: {}\", e.getMessage());\r\n-                    return false;\r\n-                }\r\n-            }\r\n-            sendPhoto.caption(caption);\r\n-            if (localHandler.getParseMode() != null) {\r\n-                sendPhoto.parseMode(localHandler.getParseMode());\r\n-            }\r\n-            return evaluateResponse(localHandler.execute(sendPhoto));\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram photo\", description = \"Sends a Picture via Telegram API\")\r\n-    public boolean sendTelegramPhoto(@ActionInput(name = \"photoURL\") @Nullable String photoURL,\r\n-            @ActionInput(name = \"caption\") @Nullable String caption,\r\n-            @ActionInput(name = \"username\") @Nullable String username,\r\n-            @ActionInput(name = \"password\") @Nullable String password) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegramPhoto(chatId, photoURL, caption, username, password)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram photo\", description = \"Sends a Picture via Telegram API\")\r\n-    public boolean sendTelegramPhoto(@ActionInput(name = \"photoURL\") @Nullable String photoURL,\r\n-            @ActionInput(name = \"caption\") @Nullable String caption) {\r\n-        return sendTelegramPhoto(photoURL, caption, null, null);\r\n-    }\r\n-\r\n-    // legacy delegate methods\r\n-    /* APIs without chatId parameter */\r\n-    public static boolean sendTelegram(@Nullable ThingActions actions, @Nullable String message,\r\n-            @Nullable Object... args) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegram(message, args);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramQuery(@Nullable ThingActions actions, @Nullable String message,\r\n-            @Nullable String replyId, @Nullable String... buttons) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramQuery(message, replyId, buttons);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramPhoto(@Nullable ThingActions actions, @Nullable String photoURL,\r\n-            @Nullable String caption) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramPhoto(photoURL, caption);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramPhoto(@Nullable ThingActions actions, @Nullable String photoURL,\r\n-            @Nullable String caption, @Nullable String username, @Nullable String password) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramPhoto(photoURL, caption, username, password);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramAnswer(@Nullable ThingActions actions, @Nullable String replyId,\r\n-            @Nullable String message) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramAnswer(replyId, message);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    /* APIs with chatId parameter */\r\n-\r\n-    public static boolean sendTelegram(@Nullable ThingActions actions, @Nullable Long chatId, @Nullable String message,\r\n-            @Nullable Object... args) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegram(chatId, message, args);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramQuery(@Nullable ThingActions actions, @Nullable Long chatId,\r\n-            @Nullable String message, @Nullable String replyId, @Nullable String... buttons) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramQuery(chatId, message, replyId, buttons);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramPhoto(@Nullable ThingActions actions, @Nullable Long chatId,\r\n-            @Nullable String photoURL, @Nullable String caption) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramPhoto(chatId, photoURL, caption);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramPhoto(@Nullable ThingActions actions, @Nullable Long chatId,\r\n-            @Nullable String photoURL, @Nullable String caption, @Nullable String username, @Nullable String password) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramPhoto(chatId, photoURL, caption, username, password);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramAnswer(@Nullable ThingActions actions, @Nullable Long chatId,\r\n-            @Nullable String replyId, @Nullable String message) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramAnswer(chatId, replyId, message);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramAnswer(@Nullable ThingActions actions, @Nullable String chatId,\r\n-            @Nullable String replyId, @Nullable String message) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramAnswer(Long.valueOf(chatId), replyId, message);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void setThingHandler(@Nullable ThingHandler handler) {\r\n-        this.handler = (TelegramHandler) handler;\r\n-    }\r\n-\r\n-    @Override\r\n-    public @Nullable ThingHandler getThingHandler() {\r\n-        return handler;\r\n-    }\r\n-}\r\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.telegram.bot;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Paths;\n+import java.util.Base64;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.telegram.internal.TelegramHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.pengrad.telegrambot.model.request.InlineKeyboardButton;\n+import com.pengrad.telegrambot.model.request.InlineKeyboardMarkup;\n+import com.pengrad.telegrambot.request.AnswerCallbackQuery;\n+import com.pengrad.telegrambot.request.EditMessageReplyMarkup;\n+import com.pengrad.telegrambot.request.SendMessage;\n+import com.pengrad.telegrambot.request.SendPhoto;\n+import com.pengrad.telegrambot.response.BaseResponse;\n+import com.pengrad.telegrambot.response.SendResponse;\n+\n+/**\n+ * Provides the actions for the Telegram API.\n+ *\n+ * @author Alexander Krasnogolowy - Initial contribution\n+ *\n+ */\n+@ThingActionsScope(name = \"telegram\")\n+@NonNullByDefault\n+public class TelegramActions implements ThingActions {\n+    private final Logger logger = LoggerFactory.getLogger(TelegramActions.class);\n+    private @Nullable TelegramHandler handler;\n+\n+    private boolean evaluateResponse(@Nullable BaseResponse response) {\n+        if (response != null && !response.isOk()) {\n+            logger.warn(\"Failed to send telegram message: {}\", response.description());\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @NonNullByDefault\n+    private static class BasicResult implements Authentication.Result {\n+\n+        private final HttpHeader header;\n+        private final URI uri;\n+        private final String value;\n+\n+        public BasicResult(HttpHeader header, URI uri, String value) {\n+            this.header = header;\n+            this.uri = uri;\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public URI getURI() {\n+            return this.uri;\n+        }\n+\n+        @Override\n+        public void apply(@Nullable Request request) {\n+            if (request != null) {\n+                request.header(this.header, this.value);\n+            }\n+        }\n+\n+        public String toString() {\n+            return String.format(\"Basic authentication result for %s\", this.uri);\n+        }\n+    }\n+\n+    @RuleAction(label = \"Telegram answer\", description = \"Sends a Telegram answer via Telegram API\")\n+    public boolean sendTelegramAnswer(@ActionInput(name = \"chatId\") @Nullable Long chatId,\n+            @ActionInput(name = \"replyId\") @Nullable String replyId,\n+            @ActionInput(name = \"message\") @Nullable String message) {\n+        if (replyId == null) {\n+            logger.warn(\"ReplyId not defined; action skipped.\");\n+            return false;\n+        }\n+        if (chatId == null) {\n+            logger.warn(\"chatId not defined; action skipped.\");\n+            return false;\n+        }\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            String callbackId = localHandler.getCallbackId(chatId, replyId);\n+            if (callbackId != null) {\n+                AnswerCallbackQuery answerCallbackQuery = new AnswerCallbackQuery(\n+                        localHandler.getCallbackId(chatId, replyId));\n+                logger.debug(\"AnswerCallbackQuery for chatId {} and replyId {} is the callbackId {}\", chatId, replyId,\n+                        localHandler.getCallbackId(chatId, replyId));\n+                // we could directly set the text here, but this\n+                // doesn't result in a real message only in a\n+                // little popup or in an alert, so the only purpose\n+                // is to stop the progress bar on client side\n+                if (!evaluateResponse(localHandler.execute(answerCallbackQuery))) {\n+                    return false;\n+                }\n+            }\n+            Integer messageId = localHandler.removeMessageId(chatId, replyId);\n+            logger.debug(\"remove messageId {} for chatId {} and replyId {}\", messageId, chatId, replyId);\n+\n+            EditMessageReplyMarkup editReplyMarkup = new EditMessageReplyMarkup(chatId, messageId.intValue())\n+                    .replyMarkup(new InlineKeyboardMarkup(new InlineKeyboardButton[0]));// remove reply markup from\n+                                                                                        // old message\n+            if (!evaluateResponse(localHandler.execute(editReplyMarkup))) {\n+                return false;\n+            }\n+            return message != null ? sendTelegram(chatId, message) : true;\n+        }\n+        return false;\n+    }\n+\n+    @RuleAction(label = \"Telegram answer\", description = \"Sends a Telegram answer via Telegram API\")\n+    public boolean sendTelegramAnswer(@ActionInput(name = \"replyId\") @Nullable String replyId,\n+            @ActionInput(name = \"message\") @Nullable String message) {\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            for (Long chatId : localHandler.getChatIds()) {\n+                if (!sendTelegramAnswer(chatId, replyId, message)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegram(@ActionInput(name = \"chatId\") @Nullable Long chatId,\n+            @ActionInput(name = \"message\") @Nullable String message) {\n+        return sendTelegramGeneral(chatId, message, (String) null);\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegram(@ActionInput(name = \"message\") @Nullable String message) {\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            for (Long chatId : localHandler.getChatIds()) {\n+                if (!sendTelegram(chatId, message)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegramQuery(@ActionInput(name = \"chatId\") @Nullable Long chatId,\n+            @ActionInput(name = \"message\") @Nullable String message,\n+            @ActionInput(name = \"replyId\") @Nullable String replyId,\n+            @ActionInput(name = \"buttons\") @Nullable String... buttons) {\n+        return sendTelegramGeneral(chatId, message, replyId, buttons);\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegramQuery(@ActionInput(name = \"message\") @Nullable String message,\n+            @ActionInput(name = \"replyId\") @Nullable String replyId,\n+            @ActionInput(name = \"buttons\") @Nullable String... buttons) {\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            for (Long chatId : localHandler.getChatIds()) {\n+                if (!sendTelegramQuery(chatId, message, replyId, buttons)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean sendTelegramGeneral(@ActionInput(name = \"chatId\") @Nullable Long chatId, @Nullable String message,\n+            @Nullable String replyId, @Nullable String... buttons) {\n+        if (message == null) {\n+            logger.warn(\"Message not defined; action skipped.\");\n+            return false;\n+        }\n+        if (chatId == null) {\n+            logger.warn(\"chatId not defined; action skipped.\");\n+            return false;\n+        }\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            SendMessage sendMessage = new SendMessage(chatId, message);\n+            if (localHandler.getParseMode() != null) {\n+                sendMessage.parseMode(localHandler.getParseMode());\n+            }\n+            if (replyId != null) {\n+                if (!replyId.contains(\" \")) {\n+                    if (buttons.length > 0) {\n+                        InlineKeyboardButton[][] keyboard2D = new InlineKeyboardButton[1][];\n+                        InlineKeyboardButton[] keyboard = new InlineKeyboardButton[buttons.length];\n+                        keyboard2D[0] = keyboard;\n+                        for (int i = 0; i < buttons.length; i++) {\n+                            keyboard[i] = new InlineKeyboardButton(buttons[i]).callbackData(replyId + \" \" + buttons[i]);\n+                        }\n+                        InlineKeyboardMarkup keyBoardMarkup = new InlineKeyboardMarkup(keyboard2D);\n+                        sendMessage.replyMarkup(keyBoardMarkup);\n+                    } else {\n+                        logger.warn(\n+                                \"The replyId {} for message {} is given, but no buttons are defined. ReplyMarkup will be ignored.\",\n+                                replyId, message);\n+                    }\n+                } else {\n+                    logger.warn(\"replyId {} must not contain spaces. ReplyMarkup will be ignored.\", replyId);\n+                }\n+            }\n+            SendResponse retMessage = localHandler.execute(sendMessage);\n+            if (!evaluateResponse(retMessage)) {\n+                return false;\n+            }\n+            if (replyId != null && retMessage != null) {\n+                logger.debug(\"Adding chatId {}, replyId {} and messageId {}\", chatId, replyId,\n+                        retMessage.message().messageId());\n+                localHandler.addMessageId(chatId, replyId, retMessage.message().messageId());\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegram(@ActionInput(name = \"chatId\") @Nullable Long chatId,\n+            @ActionInput(name = \"message\") @Nullable String format,\n+            @ActionInput(name = \"args\") @Nullable Object... args) {\n+        return sendTelegram(chatId, String.format(format, args));", "originalCommit": "f286914ac56e72551e3abddac1013e39c98fd915", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE2ODUzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6824#discussion_r391168535", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean sendTelegram(@ActionInput(name = \"message\") @Nullable String format,\n          \n          \n            \n                public boolean sendTelegram(@ActionInput(name = \"message\") @Nullable String message,", "author": "J-N-K", "createdAt": "2020-03-11T18:12:04Z", "path": "bundles/org.openhab.binding.telegram/src/main/java/org/openhab/binding/telegram/bot/TelegramActions.java", "diffHunk": "@@ -1,507 +1,507 @@\n-/**\r\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n- *\r\n- * See the NOTICE file(s) distributed with this work for additional\r\n- * information.\r\n- *\r\n- * This program and the accompanying materials are made available under the\r\n- * terms of the Eclipse Public License 2.0 which is available at\r\n- * http://www.eclipse.org/legal/epl-2.0\r\n- *\r\n- * SPDX-License-Identifier: EPL-2.0\r\n- */\r\n-package org.openhab.binding.telegram.bot;\r\n-\r\n-import java.io.ByteArrayInputStream;\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.net.MalformedURLException;\r\n-import java.net.URI;\r\n-import java.net.URL;\r\n-import java.nio.charset.StandardCharsets;\r\n-import java.nio.file.Paths;\r\n-import java.util.Base64;\r\n-import java.util.concurrent.ExecutionException;\r\n-import java.util.concurrent.TimeUnit;\r\n-import java.util.concurrent.TimeoutException;\r\n-\r\n-import org.apache.commons.io.IOUtils;\r\n-import org.eclipse.jdt.annotation.NonNullByDefault;\r\n-import org.eclipse.jdt.annotation.Nullable;\r\n-import org.eclipse.jetty.client.HttpClient;\r\n-import org.eclipse.jetty.client.api.Authentication;\r\n-import org.eclipse.jetty.client.api.AuthenticationStore;\r\n-import org.eclipse.jetty.client.api.ContentResponse;\r\n-import org.eclipse.jetty.client.api.Request;\r\n-import org.eclipse.jetty.http.HttpHeader;\r\n-import org.eclipse.jetty.http.HttpMethod;\r\n-import org.eclipse.jetty.util.B64Code;\r\n-import org.eclipse.smarthome.core.thing.binding.ThingActions;\r\n-import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\r\n-import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n-import org.openhab.binding.telegram.internal.TelegramHandler;\r\n-import org.openhab.core.automation.annotation.ActionInput;\r\n-import org.openhab.core.automation.annotation.RuleAction;\r\n-import org.slf4j.Logger;\r\n-import org.slf4j.LoggerFactory;\r\n-\r\n-import com.pengrad.telegrambot.model.request.InlineKeyboardButton;\r\n-import com.pengrad.telegrambot.model.request.InlineKeyboardMarkup;\r\n-import com.pengrad.telegrambot.request.AnswerCallbackQuery;\r\n-import com.pengrad.telegrambot.request.EditMessageReplyMarkup;\r\n-import com.pengrad.telegrambot.request.SendMessage;\r\n-import com.pengrad.telegrambot.request.SendPhoto;\r\n-import com.pengrad.telegrambot.response.BaseResponse;\r\n-import com.pengrad.telegrambot.response.SendResponse;\r\n-\r\n-/**\r\n- * Provides the actions for the Telegram API.\r\n- *\r\n- * @author Alexander Krasnogolowy - Initial contribution\r\n- *\r\n- */\r\n-@ThingActionsScope(name = \"telegram\")\r\n-@NonNullByDefault\r\n-public class TelegramActions implements ThingActions {\r\n-    private final Logger logger = LoggerFactory.getLogger(TelegramActions.class);\r\n-    private @Nullable TelegramHandler handler;\r\n-\r\n-    private boolean evaluateResponse(@Nullable BaseResponse response) {\r\n-        if (response != null && !response.isOk()) {\r\n-            logger.warn(\"Failed to send telegram message: {}\", response.description());\r\n-            return false;\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @NonNullByDefault\r\n-    private static class BasicResult implements Authentication.Result {\r\n-\r\n-        private final HttpHeader header;\r\n-        private final URI uri;\r\n-        private final String value;\r\n-\r\n-        public BasicResult(HttpHeader header, URI uri, String value) {\r\n-            this.header = header;\r\n-            this.uri = uri;\r\n-            this.value = value;\r\n-        }\r\n-\r\n-        @Override\r\n-        public URI getURI() {\r\n-            return this.uri;\r\n-        }\r\n-\r\n-        @Override\r\n-        public void apply(@Nullable Request request) {\r\n-            if (request != null) {\r\n-                request.header(this.header, this.value);\r\n-            }\r\n-        }\r\n-\r\n-        public String toString() {\r\n-            return String.format(\"Basic authentication result for %s\", this.uri);\r\n-        }\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram answer\", description = \"Sends a Telegram answer via Telegram API\")\r\n-    public boolean sendTelegramAnswer(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"replyId\") @Nullable String replyId,\r\n-            @ActionInput(name = \"message\") @Nullable String message) {\r\n-        if (replyId == null) {\r\n-            logger.warn(\"ReplyId not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-        if (chatId == null) {\r\n-            logger.warn(\"chatId not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            String callbackId = localHandler.getCallbackId(chatId, replyId);\r\n-            if (callbackId != null) {\r\n-                AnswerCallbackQuery answerCallbackQuery = new AnswerCallbackQuery(\r\n-                        localHandler.getCallbackId(chatId, replyId));\r\n-                logger.debug(\"AnswerCallbackQuery for chatId {} and replyId {} is the callbackId {}\", chatId, replyId,\r\n-                        localHandler.getCallbackId(chatId, replyId));\r\n-                // we could directly set the text here, but this\r\n-                // doesn't result in a real message only in a\r\n-                // little popup or in an alert, so the only purpose\r\n-                // is to stop the progress bar on client side\r\n-                if (!evaluateResponse(localHandler.execute(answerCallbackQuery))) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-            Integer messageId = localHandler.removeMessageId(chatId, replyId);\r\n-            logger.debug(\"remove messageId {} for chatId {} and replyId {}\", messageId, chatId, replyId);\r\n-\r\n-            EditMessageReplyMarkup editReplyMarkup = new EditMessageReplyMarkup(chatId, messageId.intValue())\r\n-                    .replyMarkup(new InlineKeyboardMarkup(new InlineKeyboardButton[0]));// remove reply markup from\r\n-                                                                                        // old message\r\n-            if (!evaluateResponse(localHandler.execute(editReplyMarkup))) {\r\n-                return false;\r\n-            }\r\n-            return message != null ? sendTelegram(chatId, message) : true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram answer\", description = \"Sends a Telegram answer via Telegram API\")\r\n-    public boolean sendTelegramAnswer(@ActionInput(name = \"replyId\") @Nullable String replyId,\r\n-            @ActionInput(name = \"message\") @Nullable String message) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegramAnswer(chatId, replyId, message)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegram(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"message\") @Nullable String message) {\r\n-        return sendTelegramGeneral(chatId, message, (String) null);\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegram(@ActionInput(name = \"message\") @Nullable String message) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegram(chatId, message)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegramQuery(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"message\") @Nullable String message,\r\n-            @ActionInput(name = \"replyId\") @Nullable String replyId,\r\n-            @ActionInput(name = \"buttons\") @Nullable String... buttons) {\r\n-        return sendTelegramGeneral(chatId, message, replyId, buttons);\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegramQuery(@ActionInput(name = \"message\") @Nullable String message,\r\n-            @ActionInput(name = \"replyId\") @Nullable String replyId,\r\n-            @ActionInput(name = \"buttons\") @Nullable String... buttons) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegramQuery(chatId, message, replyId, buttons)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    private boolean sendTelegramGeneral(@ActionInput(name = \"chatId\") @Nullable Long chatId, @Nullable String message,\r\n-            @Nullable String replyId, @Nullable String... buttons) {\r\n-        if (message == null) {\r\n-            logger.warn(\"Message not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-        if (chatId == null) {\r\n-            logger.warn(\"chatId not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            SendMessage sendMessage = new SendMessage(chatId, message);\r\n-            if (localHandler.getParseMode() != null) {\r\n-                sendMessage.parseMode(localHandler.getParseMode());\r\n-            }\r\n-            if (replyId != null) {\r\n-                if (!replyId.contains(\" \")) {\r\n-                    if (buttons.length > 0) {\r\n-                        InlineKeyboardButton[][] keyboard2D = new InlineKeyboardButton[1][];\r\n-                        InlineKeyboardButton[] keyboard = new InlineKeyboardButton[buttons.length];\r\n-                        keyboard2D[0] = keyboard;\r\n-                        for (int i = 0; i < buttons.length; i++) {\r\n-                            keyboard[i] = new InlineKeyboardButton(buttons[i]).callbackData(replyId + \" \" + buttons[i]);\r\n-                        }\r\n-                        InlineKeyboardMarkup keyBoardMarkup = new InlineKeyboardMarkup(keyboard2D);\r\n-                        sendMessage.replyMarkup(keyBoardMarkup);\r\n-                    } else {\r\n-                        logger.warn(\r\n-                                \"The replyId {} for message {} is given, but no buttons are defined. ReplyMarkup will be ignored.\",\r\n-                                replyId, message);\r\n-                    }\r\n-                } else {\r\n-                    logger.warn(\"replyId {} must not contain spaces. ReplyMarkup will be ignored.\", replyId);\r\n-                }\r\n-            }\r\n-            SendResponse retMessage = localHandler.execute(sendMessage);\r\n-            if (!evaluateResponse(retMessage)) {\r\n-                return false;\r\n-            }\r\n-            if (replyId != null && retMessage != null) {\r\n-                logger.debug(\"Adding chatId {}, replyId {} and messageId {}\", chatId, replyId,\r\n-                        retMessage.message().messageId());\r\n-                localHandler.addMessageId(chatId, replyId, retMessage.message().messageId());\r\n-            }\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegram(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"message\") @Nullable String message,\r\n-            @ActionInput(name = \"args\") @Nullable Object... args) {\r\n-        return sendTelegram(chatId, args == null || args.length == 0 ? message : String.format(message, args));\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegram(@ActionInput(name = \"message\") @Nullable String message,\r\n-            @ActionInput(name = \"args\") @Nullable Object... args) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegram(chatId, message, args)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram photo\", description = \"Sends a Picture via Telegram API\")\r\n-    public boolean sendTelegramPhoto(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"photoURL\") @Nullable String photoURL,\r\n-            @ActionInput(name = \"caption\") @Nullable String caption) {\r\n-        return sendTelegramPhoto(chatId, photoURL, caption, null, null);\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram photo\", description = \"Sends a Picture via Telegram API\")\r\n-    public boolean sendTelegramPhoto(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"photoURL\") @Nullable String photoURL,\r\n-            @ActionInput(name = \"caption\") @Nullable String caption,\r\n-            @ActionInput(name = \"username\") @Nullable String username,\r\n-            @ActionInput(name = \"password\") @Nullable String password) {\r\n-        if (photoURL == null) {\r\n-            logger.warn(\"Photo URL not defined; unable to retrieve photo for sending.\");\r\n-            return false;\r\n-        }\r\n-        if (chatId == null) {\r\n-            logger.warn(\"chatId not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            final SendPhoto sendPhoto;\r\n-\r\n-            if (photoURL.toLowerCase().startsWith(\"http\")) {\r\n-                // load image from url\r\n-                logger.debug(\"Photo URL provided.\");\r\n-                HttpClient client = localHandler.getClient();\r\n-                if (client == null) {\r\n-                    return false;\r\n-                }\r\n-                Request request = client.newRequest(photoURL).method(HttpMethod.GET).timeout(30, TimeUnit.SECONDS);\r\n-                if (username != null && password != null) {\r\n-                    AuthenticationStore auth = client.getAuthenticationStore();\r\n-                    URI uri = URI.create(photoURL);\r\n-                    auth.addAuthenticationResult(new BasicResult(HttpHeader.AUTHORIZATION, uri,\r\n-                            \"Basic \" + B64Code.encode(username + \":\" + password, StandardCharsets.ISO_8859_1)));\r\n-                }\r\n-                try {\r\n-                    ContentResponse contentResponse = request.send();\r\n-                    if (contentResponse.getStatus() == 200) {\r\n-                        byte[] fileContent = contentResponse.getContent();\r\n-                        sendPhoto = new SendPhoto(chatId, fileContent);\r\n-                    } else {\r\n-                        logger.warn(\"Download from {} failed with status: {}\", photoURL, contentResponse.getStatus());\r\n-                        return false;\r\n-                    }\r\n-                } catch (InterruptedException | TimeoutException | ExecutionException e) {\r\n-                    logger.warn(\"Download from {} failed with exception: {}\", photoURL, e.getMessage());\r\n-                    return false;\r\n-                }\r\n-            } else if (photoURL.toLowerCase().startsWith(\"file\")) {\r\n-                // Load image from local file system\r\n-                logger.debug(\"Read file from local file system: {}\", photoURL);\r\n-                try {\r\n-                    URL url = new URL(photoURL);\r\n-                    sendPhoto = new SendPhoto(chatId, Paths.get(url.getPath()).toFile());\r\n-                } catch (MalformedURLException e) {\r\n-                    logger.warn(\"Malformed URL: {}\", photoURL);\r\n-                    return false;\r\n-                }\r\n-            } else {\r\n-                // Load image from provided base64 image\r\n-                logger.debug(\"Photo base64 provided; converting to binary.\");\r\n-                final String photoB64Data;\r\n-                if (photoURL.startsWith(\"data:\")) { // support data URI scheme\r\n-                    String[] photoURLParts = photoURL.split(\",\");\r\n-                    if (photoURLParts.length > 1) {\r\n-                        photoB64Data = photoURLParts[1];\r\n-                    } else {\r\n-                        logger.warn(\"The provided base64 string is not a valid data URI scheme\");\r\n-                        return false;\r\n-                    }\r\n-                } else {\r\n-                    photoB64Data = photoURL;\r\n-                }\r\n-                InputStream is = Base64.getDecoder()\r\n-                        .wrap(new ByteArrayInputStream(photoB64Data.getBytes(StandardCharsets.UTF_8)));\r\n-                try {\r\n-                    byte[] photoBytes = IOUtils.toByteArray(is);\r\n-                    sendPhoto = new SendPhoto(chatId, photoBytes);\r\n-                } catch (IOException e) {\r\n-                    logger.warn(\"Malformed base64 string: {}\", e.getMessage());\r\n-                    return false;\r\n-                }\r\n-            }\r\n-            sendPhoto.caption(caption);\r\n-            if (localHandler.getParseMode() != null) {\r\n-                sendPhoto.parseMode(localHandler.getParseMode());\r\n-            }\r\n-            return evaluateResponse(localHandler.execute(sendPhoto));\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram photo\", description = \"Sends a Picture via Telegram API\")\r\n-    public boolean sendTelegramPhoto(@ActionInput(name = \"photoURL\") @Nullable String photoURL,\r\n-            @ActionInput(name = \"caption\") @Nullable String caption,\r\n-            @ActionInput(name = \"username\") @Nullable String username,\r\n-            @ActionInput(name = \"password\") @Nullable String password) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegramPhoto(chatId, photoURL, caption, username, password)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram photo\", description = \"Sends a Picture via Telegram API\")\r\n-    public boolean sendTelegramPhoto(@ActionInput(name = \"photoURL\") @Nullable String photoURL,\r\n-            @ActionInput(name = \"caption\") @Nullable String caption) {\r\n-        return sendTelegramPhoto(photoURL, caption, null, null);\r\n-    }\r\n-\r\n-    // legacy delegate methods\r\n-    /* APIs without chatId parameter */\r\n-    public static boolean sendTelegram(@Nullable ThingActions actions, @Nullable String message,\r\n-            @Nullable Object... args) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegram(message, args);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramQuery(@Nullable ThingActions actions, @Nullable String message,\r\n-            @Nullable String replyId, @Nullable String... buttons) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramQuery(message, replyId, buttons);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramPhoto(@Nullable ThingActions actions, @Nullable String photoURL,\r\n-            @Nullable String caption) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramPhoto(photoURL, caption);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramPhoto(@Nullable ThingActions actions, @Nullable String photoURL,\r\n-            @Nullable String caption, @Nullable String username, @Nullable String password) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramPhoto(photoURL, caption, username, password);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramAnswer(@Nullable ThingActions actions, @Nullable String replyId,\r\n-            @Nullable String message) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramAnswer(replyId, message);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    /* APIs with chatId parameter */\r\n-\r\n-    public static boolean sendTelegram(@Nullable ThingActions actions, @Nullable Long chatId, @Nullable String message,\r\n-            @Nullable Object... args) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegram(chatId, message, args);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramQuery(@Nullable ThingActions actions, @Nullable Long chatId,\r\n-            @Nullable String message, @Nullable String replyId, @Nullable String... buttons) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramQuery(chatId, message, replyId, buttons);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramPhoto(@Nullable ThingActions actions, @Nullable Long chatId,\r\n-            @Nullable String photoURL, @Nullable String caption) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramPhoto(chatId, photoURL, caption);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramPhoto(@Nullable ThingActions actions, @Nullable Long chatId,\r\n-            @Nullable String photoURL, @Nullable String caption, @Nullable String username, @Nullable String password) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramPhoto(chatId, photoURL, caption, username, password);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramAnswer(@Nullable ThingActions actions, @Nullable Long chatId,\r\n-            @Nullable String replyId, @Nullable String message) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramAnswer(chatId, replyId, message);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramAnswer(@Nullable ThingActions actions, @Nullable String chatId,\r\n-            @Nullable String replyId, @Nullable String message) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramAnswer(Long.valueOf(chatId), replyId, message);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void setThingHandler(@Nullable ThingHandler handler) {\r\n-        this.handler = (TelegramHandler) handler;\r\n-    }\r\n-\r\n-    @Override\r\n-    public @Nullable ThingHandler getThingHandler() {\r\n-        return handler;\r\n-    }\r\n-}\r\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.telegram.bot;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Paths;\n+import java.util.Base64;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.telegram.internal.TelegramHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.pengrad.telegrambot.model.request.InlineKeyboardButton;\n+import com.pengrad.telegrambot.model.request.InlineKeyboardMarkup;\n+import com.pengrad.telegrambot.request.AnswerCallbackQuery;\n+import com.pengrad.telegrambot.request.EditMessageReplyMarkup;\n+import com.pengrad.telegrambot.request.SendMessage;\n+import com.pengrad.telegrambot.request.SendPhoto;\n+import com.pengrad.telegrambot.response.BaseResponse;\n+import com.pengrad.telegrambot.response.SendResponse;\n+\n+/**\n+ * Provides the actions for the Telegram API.\n+ *\n+ * @author Alexander Krasnogolowy - Initial contribution\n+ *\n+ */\n+@ThingActionsScope(name = \"telegram\")\n+@NonNullByDefault\n+public class TelegramActions implements ThingActions {\n+    private final Logger logger = LoggerFactory.getLogger(TelegramActions.class);\n+    private @Nullable TelegramHandler handler;\n+\n+    private boolean evaluateResponse(@Nullable BaseResponse response) {\n+        if (response != null && !response.isOk()) {\n+            logger.warn(\"Failed to send telegram message: {}\", response.description());\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @NonNullByDefault\n+    private static class BasicResult implements Authentication.Result {\n+\n+        private final HttpHeader header;\n+        private final URI uri;\n+        private final String value;\n+\n+        public BasicResult(HttpHeader header, URI uri, String value) {\n+            this.header = header;\n+            this.uri = uri;\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public URI getURI() {\n+            return this.uri;\n+        }\n+\n+        @Override\n+        public void apply(@Nullable Request request) {\n+            if (request != null) {\n+                request.header(this.header, this.value);\n+            }\n+        }\n+\n+        public String toString() {\n+            return String.format(\"Basic authentication result for %s\", this.uri);\n+        }\n+    }\n+\n+    @RuleAction(label = \"Telegram answer\", description = \"Sends a Telegram answer via Telegram API\")\n+    public boolean sendTelegramAnswer(@ActionInput(name = \"chatId\") @Nullable Long chatId,\n+            @ActionInput(name = \"replyId\") @Nullable String replyId,\n+            @ActionInput(name = \"message\") @Nullable String message) {\n+        if (replyId == null) {\n+            logger.warn(\"ReplyId not defined; action skipped.\");\n+            return false;\n+        }\n+        if (chatId == null) {\n+            logger.warn(\"chatId not defined; action skipped.\");\n+            return false;\n+        }\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            String callbackId = localHandler.getCallbackId(chatId, replyId);\n+            if (callbackId != null) {\n+                AnswerCallbackQuery answerCallbackQuery = new AnswerCallbackQuery(\n+                        localHandler.getCallbackId(chatId, replyId));\n+                logger.debug(\"AnswerCallbackQuery for chatId {} and replyId {} is the callbackId {}\", chatId, replyId,\n+                        localHandler.getCallbackId(chatId, replyId));\n+                // we could directly set the text here, but this\n+                // doesn't result in a real message only in a\n+                // little popup or in an alert, so the only purpose\n+                // is to stop the progress bar on client side\n+                if (!evaluateResponse(localHandler.execute(answerCallbackQuery))) {\n+                    return false;\n+                }\n+            }\n+            Integer messageId = localHandler.removeMessageId(chatId, replyId);\n+            logger.debug(\"remove messageId {} for chatId {} and replyId {}\", messageId, chatId, replyId);\n+\n+            EditMessageReplyMarkup editReplyMarkup = new EditMessageReplyMarkup(chatId, messageId.intValue())\n+                    .replyMarkup(new InlineKeyboardMarkup(new InlineKeyboardButton[0]));// remove reply markup from\n+                                                                                        // old message\n+            if (!evaluateResponse(localHandler.execute(editReplyMarkup))) {\n+                return false;\n+            }\n+            return message != null ? sendTelegram(chatId, message) : true;\n+        }\n+        return false;\n+    }\n+\n+    @RuleAction(label = \"Telegram answer\", description = \"Sends a Telegram answer via Telegram API\")\n+    public boolean sendTelegramAnswer(@ActionInput(name = \"replyId\") @Nullable String replyId,\n+            @ActionInput(name = \"message\") @Nullable String message) {\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            for (Long chatId : localHandler.getChatIds()) {\n+                if (!sendTelegramAnswer(chatId, replyId, message)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegram(@ActionInput(name = \"chatId\") @Nullable Long chatId,\n+            @ActionInput(name = \"message\") @Nullable String message) {\n+        return sendTelegramGeneral(chatId, message, (String) null);\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegram(@ActionInput(name = \"message\") @Nullable String message) {\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            for (Long chatId : localHandler.getChatIds()) {\n+                if (!sendTelegram(chatId, message)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegramQuery(@ActionInput(name = \"chatId\") @Nullable Long chatId,\n+            @ActionInput(name = \"message\") @Nullable String message,\n+            @ActionInput(name = \"replyId\") @Nullable String replyId,\n+            @ActionInput(name = \"buttons\") @Nullable String... buttons) {\n+        return sendTelegramGeneral(chatId, message, replyId, buttons);\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegramQuery(@ActionInput(name = \"message\") @Nullable String message,\n+            @ActionInput(name = \"replyId\") @Nullable String replyId,\n+            @ActionInput(name = \"buttons\") @Nullable String... buttons) {\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            for (Long chatId : localHandler.getChatIds()) {\n+                if (!sendTelegramQuery(chatId, message, replyId, buttons)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean sendTelegramGeneral(@ActionInput(name = \"chatId\") @Nullable Long chatId, @Nullable String message,\n+            @Nullable String replyId, @Nullable String... buttons) {\n+        if (message == null) {\n+            logger.warn(\"Message not defined; action skipped.\");\n+            return false;\n+        }\n+        if (chatId == null) {\n+            logger.warn(\"chatId not defined; action skipped.\");\n+            return false;\n+        }\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            SendMessage sendMessage = new SendMessage(chatId, message);\n+            if (localHandler.getParseMode() != null) {\n+                sendMessage.parseMode(localHandler.getParseMode());\n+            }\n+            if (replyId != null) {\n+                if (!replyId.contains(\" \")) {\n+                    if (buttons.length > 0) {\n+                        InlineKeyboardButton[][] keyboard2D = new InlineKeyboardButton[1][];\n+                        InlineKeyboardButton[] keyboard = new InlineKeyboardButton[buttons.length];\n+                        keyboard2D[0] = keyboard;\n+                        for (int i = 0; i < buttons.length; i++) {\n+                            keyboard[i] = new InlineKeyboardButton(buttons[i]).callbackData(replyId + \" \" + buttons[i]);\n+                        }\n+                        InlineKeyboardMarkup keyBoardMarkup = new InlineKeyboardMarkup(keyboard2D);\n+                        sendMessage.replyMarkup(keyBoardMarkup);\n+                    } else {\n+                        logger.warn(\n+                                \"The replyId {} for message {} is given, but no buttons are defined. ReplyMarkup will be ignored.\",\n+                                replyId, message);\n+                    }\n+                } else {\n+                    logger.warn(\"replyId {} must not contain spaces. ReplyMarkup will be ignored.\", replyId);\n+                }\n+            }\n+            SendResponse retMessage = localHandler.execute(sendMessage);\n+            if (!evaluateResponse(retMessage)) {\n+                return false;\n+            }\n+            if (replyId != null && retMessage != null) {\n+                logger.debug(\"Adding chatId {}, replyId {} and messageId {}\", chatId, replyId,\n+                        retMessage.message().messageId());\n+                localHandler.addMessageId(chatId, replyId, retMessage.message().messageId());\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegram(@ActionInput(name = \"chatId\") @Nullable Long chatId,\n+            @ActionInput(name = \"message\") @Nullable String format,\n+            @ActionInput(name = \"args\") @Nullable Object... args) {\n+        return sendTelegram(chatId, String.format(format, args));\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegram(@ActionInput(name = \"message\") @Nullable String format,", "originalCommit": "f286914ac56e72551e3abddac1013e39c98fd915", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE2ODY2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6824#discussion_r391168667", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (!sendTelegram(chatId, format, args)) {\n          \n          \n            \n                            if (!sendTelegram(chatId, message, args)) {", "author": "J-N-K", "createdAt": "2020-03-11T18:12:18Z", "path": "bundles/org.openhab.binding.telegram/src/main/java/org/openhab/binding/telegram/bot/TelegramActions.java", "diffHunk": "@@ -1,507 +1,507 @@\n-/**\r\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n- *\r\n- * See the NOTICE file(s) distributed with this work for additional\r\n- * information.\r\n- *\r\n- * This program and the accompanying materials are made available under the\r\n- * terms of the Eclipse Public License 2.0 which is available at\r\n- * http://www.eclipse.org/legal/epl-2.0\r\n- *\r\n- * SPDX-License-Identifier: EPL-2.0\r\n- */\r\n-package org.openhab.binding.telegram.bot;\r\n-\r\n-import java.io.ByteArrayInputStream;\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.net.MalformedURLException;\r\n-import java.net.URI;\r\n-import java.net.URL;\r\n-import java.nio.charset.StandardCharsets;\r\n-import java.nio.file.Paths;\r\n-import java.util.Base64;\r\n-import java.util.concurrent.ExecutionException;\r\n-import java.util.concurrent.TimeUnit;\r\n-import java.util.concurrent.TimeoutException;\r\n-\r\n-import org.apache.commons.io.IOUtils;\r\n-import org.eclipse.jdt.annotation.NonNullByDefault;\r\n-import org.eclipse.jdt.annotation.Nullable;\r\n-import org.eclipse.jetty.client.HttpClient;\r\n-import org.eclipse.jetty.client.api.Authentication;\r\n-import org.eclipse.jetty.client.api.AuthenticationStore;\r\n-import org.eclipse.jetty.client.api.ContentResponse;\r\n-import org.eclipse.jetty.client.api.Request;\r\n-import org.eclipse.jetty.http.HttpHeader;\r\n-import org.eclipse.jetty.http.HttpMethod;\r\n-import org.eclipse.jetty.util.B64Code;\r\n-import org.eclipse.smarthome.core.thing.binding.ThingActions;\r\n-import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\r\n-import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n-import org.openhab.binding.telegram.internal.TelegramHandler;\r\n-import org.openhab.core.automation.annotation.ActionInput;\r\n-import org.openhab.core.automation.annotation.RuleAction;\r\n-import org.slf4j.Logger;\r\n-import org.slf4j.LoggerFactory;\r\n-\r\n-import com.pengrad.telegrambot.model.request.InlineKeyboardButton;\r\n-import com.pengrad.telegrambot.model.request.InlineKeyboardMarkup;\r\n-import com.pengrad.telegrambot.request.AnswerCallbackQuery;\r\n-import com.pengrad.telegrambot.request.EditMessageReplyMarkup;\r\n-import com.pengrad.telegrambot.request.SendMessage;\r\n-import com.pengrad.telegrambot.request.SendPhoto;\r\n-import com.pengrad.telegrambot.response.BaseResponse;\r\n-import com.pengrad.telegrambot.response.SendResponse;\r\n-\r\n-/**\r\n- * Provides the actions for the Telegram API.\r\n- *\r\n- * @author Alexander Krasnogolowy - Initial contribution\r\n- *\r\n- */\r\n-@ThingActionsScope(name = \"telegram\")\r\n-@NonNullByDefault\r\n-public class TelegramActions implements ThingActions {\r\n-    private final Logger logger = LoggerFactory.getLogger(TelegramActions.class);\r\n-    private @Nullable TelegramHandler handler;\r\n-\r\n-    private boolean evaluateResponse(@Nullable BaseResponse response) {\r\n-        if (response != null && !response.isOk()) {\r\n-            logger.warn(\"Failed to send telegram message: {}\", response.description());\r\n-            return false;\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @NonNullByDefault\r\n-    private static class BasicResult implements Authentication.Result {\r\n-\r\n-        private final HttpHeader header;\r\n-        private final URI uri;\r\n-        private final String value;\r\n-\r\n-        public BasicResult(HttpHeader header, URI uri, String value) {\r\n-            this.header = header;\r\n-            this.uri = uri;\r\n-            this.value = value;\r\n-        }\r\n-\r\n-        @Override\r\n-        public URI getURI() {\r\n-            return this.uri;\r\n-        }\r\n-\r\n-        @Override\r\n-        public void apply(@Nullable Request request) {\r\n-            if (request != null) {\r\n-                request.header(this.header, this.value);\r\n-            }\r\n-        }\r\n-\r\n-        public String toString() {\r\n-            return String.format(\"Basic authentication result for %s\", this.uri);\r\n-        }\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram answer\", description = \"Sends a Telegram answer via Telegram API\")\r\n-    public boolean sendTelegramAnswer(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"replyId\") @Nullable String replyId,\r\n-            @ActionInput(name = \"message\") @Nullable String message) {\r\n-        if (replyId == null) {\r\n-            logger.warn(\"ReplyId not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-        if (chatId == null) {\r\n-            logger.warn(\"chatId not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            String callbackId = localHandler.getCallbackId(chatId, replyId);\r\n-            if (callbackId != null) {\r\n-                AnswerCallbackQuery answerCallbackQuery = new AnswerCallbackQuery(\r\n-                        localHandler.getCallbackId(chatId, replyId));\r\n-                logger.debug(\"AnswerCallbackQuery for chatId {} and replyId {} is the callbackId {}\", chatId, replyId,\r\n-                        localHandler.getCallbackId(chatId, replyId));\r\n-                // we could directly set the text here, but this\r\n-                // doesn't result in a real message only in a\r\n-                // little popup or in an alert, so the only purpose\r\n-                // is to stop the progress bar on client side\r\n-                if (!evaluateResponse(localHandler.execute(answerCallbackQuery))) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-            Integer messageId = localHandler.removeMessageId(chatId, replyId);\r\n-            logger.debug(\"remove messageId {} for chatId {} and replyId {}\", messageId, chatId, replyId);\r\n-\r\n-            EditMessageReplyMarkup editReplyMarkup = new EditMessageReplyMarkup(chatId, messageId.intValue())\r\n-                    .replyMarkup(new InlineKeyboardMarkup(new InlineKeyboardButton[0]));// remove reply markup from\r\n-                                                                                        // old message\r\n-            if (!evaluateResponse(localHandler.execute(editReplyMarkup))) {\r\n-                return false;\r\n-            }\r\n-            return message != null ? sendTelegram(chatId, message) : true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram answer\", description = \"Sends a Telegram answer via Telegram API\")\r\n-    public boolean sendTelegramAnswer(@ActionInput(name = \"replyId\") @Nullable String replyId,\r\n-            @ActionInput(name = \"message\") @Nullable String message) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegramAnswer(chatId, replyId, message)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegram(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"message\") @Nullable String message) {\r\n-        return sendTelegramGeneral(chatId, message, (String) null);\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegram(@ActionInput(name = \"message\") @Nullable String message) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegram(chatId, message)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegramQuery(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"message\") @Nullable String message,\r\n-            @ActionInput(name = \"replyId\") @Nullable String replyId,\r\n-            @ActionInput(name = \"buttons\") @Nullable String... buttons) {\r\n-        return sendTelegramGeneral(chatId, message, replyId, buttons);\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegramQuery(@ActionInput(name = \"message\") @Nullable String message,\r\n-            @ActionInput(name = \"replyId\") @Nullable String replyId,\r\n-            @ActionInput(name = \"buttons\") @Nullable String... buttons) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegramQuery(chatId, message, replyId, buttons)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    private boolean sendTelegramGeneral(@ActionInput(name = \"chatId\") @Nullable Long chatId, @Nullable String message,\r\n-            @Nullable String replyId, @Nullable String... buttons) {\r\n-        if (message == null) {\r\n-            logger.warn(\"Message not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-        if (chatId == null) {\r\n-            logger.warn(\"chatId not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            SendMessage sendMessage = new SendMessage(chatId, message);\r\n-            if (localHandler.getParseMode() != null) {\r\n-                sendMessage.parseMode(localHandler.getParseMode());\r\n-            }\r\n-            if (replyId != null) {\r\n-                if (!replyId.contains(\" \")) {\r\n-                    if (buttons.length > 0) {\r\n-                        InlineKeyboardButton[][] keyboard2D = new InlineKeyboardButton[1][];\r\n-                        InlineKeyboardButton[] keyboard = new InlineKeyboardButton[buttons.length];\r\n-                        keyboard2D[0] = keyboard;\r\n-                        for (int i = 0; i < buttons.length; i++) {\r\n-                            keyboard[i] = new InlineKeyboardButton(buttons[i]).callbackData(replyId + \" \" + buttons[i]);\r\n-                        }\r\n-                        InlineKeyboardMarkup keyBoardMarkup = new InlineKeyboardMarkup(keyboard2D);\r\n-                        sendMessage.replyMarkup(keyBoardMarkup);\r\n-                    } else {\r\n-                        logger.warn(\r\n-                                \"The replyId {} for message {} is given, but no buttons are defined. ReplyMarkup will be ignored.\",\r\n-                                replyId, message);\r\n-                    }\r\n-                } else {\r\n-                    logger.warn(\"replyId {} must not contain spaces. ReplyMarkup will be ignored.\", replyId);\r\n-                }\r\n-            }\r\n-            SendResponse retMessage = localHandler.execute(sendMessage);\r\n-            if (!evaluateResponse(retMessage)) {\r\n-                return false;\r\n-            }\r\n-            if (replyId != null && retMessage != null) {\r\n-                logger.debug(\"Adding chatId {}, replyId {} and messageId {}\", chatId, replyId,\r\n-                        retMessage.message().messageId());\r\n-                localHandler.addMessageId(chatId, replyId, retMessage.message().messageId());\r\n-            }\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegram(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"message\") @Nullable String message,\r\n-            @ActionInput(name = \"args\") @Nullable Object... args) {\r\n-        return sendTelegram(chatId, args == null || args.length == 0 ? message : String.format(message, args));\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\r\n-    public boolean sendTelegram(@ActionInput(name = \"message\") @Nullable String message,\r\n-            @ActionInput(name = \"args\") @Nullable Object... args) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegram(chatId, message, args)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram photo\", description = \"Sends a Picture via Telegram API\")\r\n-    public boolean sendTelegramPhoto(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"photoURL\") @Nullable String photoURL,\r\n-            @ActionInput(name = \"caption\") @Nullable String caption) {\r\n-        return sendTelegramPhoto(chatId, photoURL, caption, null, null);\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram photo\", description = \"Sends a Picture via Telegram API\")\r\n-    public boolean sendTelegramPhoto(@ActionInput(name = \"chatId\") @Nullable Long chatId,\r\n-            @ActionInput(name = \"photoURL\") @Nullable String photoURL,\r\n-            @ActionInput(name = \"caption\") @Nullable String caption,\r\n-            @ActionInput(name = \"username\") @Nullable String username,\r\n-            @ActionInput(name = \"password\") @Nullable String password) {\r\n-        if (photoURL == null) {\r\n-            logger.warn(\"Photo URL not defined; unable to retrieve photo for sending.\");\r\n-            return false;\r\n-        }\r\n-        if (chatId == null) {\r\n-            logger.warn(\"chatId not defined; action skipped.\");\r\n-            return false;\r\n-        }\r\n-\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            final SendPhoto sendPhoto;\r\n-\r\n-            if (photoURL.toLowerCase().startsWith(\"http\")) {\r\n-                // load image from url\r\n-                logger.debug(\"Photo URL provided.\");\r\n-                HttpClient client = localHandler.getClient();\r\n-                if (client == null) {\r\n-                    return false;\r\n-                }\r\n-                Request request = client.newRequest(photoURL).method(HttpMethod.GET).timeout(30, TimeUnit.SECONDS);\r\n-                if (username != null && password != null) {\r\n-                    AuthenticationStore auth = client.getAuthenticationStore();\r\n-                    URI uri = URI.create(photoURL);\r\n-                    auth.addAuthenticationResult(new BasicResult(HttpHeader.AUTHORIZATION, uri,\r\n-                            \"Basic \" + B64Code.encode(username + \":\" + password, StandardCharsets.ISO_8859_1)));\r\n-                }\r\n-                try {\r\n-                    ContentResponse contentResponse = request.send();\r\n-                    if (contentResponse.getStatus() == 200) {\r\n-                        byte[] fileContent = contentResponse.getContent();\r\n-                        sendPhoto = new SendPhoto(chatId, fileContent);\r\n-                    } else {\r\n-                        logger.warn(\"Download from {} failed with status: {}\", photoURL, contentResponse.getStatus());\r\n-                        return false;\r\n-                    }\r\n-                } catch (InterruptedException | TimeoutException | ExecutionException e) {\r\n-                    logger.warn(\"Download from {} failed with exception: {}\", photoURL, e.getMessage());\r\n-                    return false;\r\n-                }\r\n-            } else if (photoURL.toLowerCase().startsWith(\"file\")) {\r\n-                // Load image from local file system\r\n-                logger.debug(\"Read file from local file system: {}\", photoURL);\r\n-                try {\r\n-                    URL url = new URL(photoURL);\r\n-                    sendPhoto = new SendPhoto(chatId, Paths.get(url.getPath()).toFile());\r\n-                } catch (MalformedURLException e) {\r\n-                    logger.warn(\"Malformed URL: {}\", photoURL);\r\n-                    return false;\r\n-                }\r\n-            } else {\r\n-                // Load image from provided base64 image\r\n-                logger.debug(\"Photo base64 provided; converting to binary.\");\r\n-                final String photoB64Data;\r\n-                if (photoURL.startsWith(\"data:\")) { // support data URI scheme\r\n-                    String[] photoURLParts = photoURL.split(\",\");\r\n-                    if (photoURLParts.length > 1) {\r\n-                        photoB64Data = photoURLParts[1];\r\n-                    } else {\r\n-                        logger.warn(\"The provided base64 string is not a valid data URI scheme\");\r\n-                        return false;\r\n-                    }\r\n-                } else {\r\n-                    photoB64Data = photoURL;\r\n-                }\r\n-                InputStream is = Base64.getDecoder()\r\n-                        .wrap(new ByteArrayInputStream(photoB64Data.getBytes(StandardCharsets.UTF_8)));\r\n-                try {\r\n-                    byte[] photoBytes = IOUtils.toByteArray(is);\r\n-                    sendPhoto = new SendPhoto(chatId, photoBytes);\r\n-                } catch (IOException e) {\r\n-                    logger.warn(\"Malformed base64 string: {}\", e.getMessage());\r\n-                    return false;\r\n-                }\r\n-            }\r\n-            sendPhoto.caption(caption);\r\n-            if (localHandler.getParseMode() != null) {\r\n-                sendPhoto.parseMode(localHandler.getParseMode());\r\n-            }\r\n-            return evaluateResponse(localHandler.execute(sendPhoto));\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram photo\", description = \"Sends a Picture via Telegram API\")\r\n-    public boolean sendTelegramPhoto(@ActionInput(name = \"photoURL\") @Nullable String photoURL,\r\n-            @ActionInput(name = \"caption\") @Nullable String caption,\r\n-            @ActionInput(name = \"username\") @Nullable String username,\r\n-            @ActionInput(name = \"password\") @Nullable String password) {\r\n-        TelegramHandler localHandler = handler;\r\n-        if (localHandler != null) {\r\n-            for (Long chatId : localHandler.getChatIds()) {\r\n-                if (!sendTelegramPhoto(chatId, photoURL, caption, username, password)) {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    @RuleAction(label = \"Telegram photo\", description = \"Sends a Picture via Telegram API\")\r\n-    public boolean sendTelegramPhoto(@ActionInput(name = \"photoURL\") @Nullable String photoURL,\r\n-            @ActionInput(name = \"caption\") @Nullable String caption) {\r\n-        return sendTelegramPhoto(photoURL, caption, null, null);\r\n-    }\r\n-\r\n-    // legacy delegate methods\r\n-    /* APIs without chatId parameter */\r\n-    public static boolean sendTelegram(@Nullable ThingActions actions, @Nullable String message,\r\n-            @Nullable Object... args) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegram(message, args);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramQuery(@Nullable ThingActions actions, @Nullable String message,\r\n-            @Nullable String replyId, @Nullable String... buttons) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramQuery(message, replyId, buttons);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramPhoto(@Nullable ThingActions actions, @Nullable String photoURL,\r\n-            @Nullable String caption) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramPhoto(photoURL, caption);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramPhoto(@Nullable ThingActions actions, @Nullable String photoURL,\r\n-            @Nullable String caption, @Nullable String username, @Nullable String password) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramPhoto(photoURL, caption, username, password);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramAnswer(@Nullable ThingActions actions, @Nullable String replyId,\r\n-            @Nullable String message) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramAnswer(replyId, message);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    /* APIs with chatId parameter */\r\n-\r\n-    public static boolean sendTelegram(@Nullable ThingActions actions, @Nullable Long chatId, @Nullable String message,\r\n-            @Nullable Object... args) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegram(chatId, message, args);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramQuery(@Nullable ThingActions actions, @Nullable Long chatId,\r\n-            @Nullable String message, @Nullable String replyId, @Nullable String... buttons) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramQuery(chatId, message, replyId, buttons);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramPhoto(@Nullable ThingActions actions, @Nullable Long chatId,\r\n-            @Nullable String photoURL, @Nullable String caption) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramPhoto(chatId, photoURL, caption);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramPhoto(@Nullable ThingActions actions, @Nullable Long chatId,\r\n-            @Nullable String photoURL, @Nullable String caption, @Nullable String username, @Nullable String password) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramPhoto(chatId, photoURL, caption, username, password);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramAnswer(@Nullable ThingActions actions, @Nullable Long chatId,\r\n-            @Nullable String replyId, @Nullable String message) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramAnswer(chatId, replyId, message);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean sendTelegramAnswer(@Nullable ThingActions actions, @Nullable String chatId,\r\n-            @Nullable String replyId, @Nullable String message) {\r\n-        if (actions instanceof TelegramActions) {\r\n-            return ((TelegramActions) actions).sendTelegramAnswer(Long.valueOf(chatId), replyId, message);\r\n-        } else {\r\n-            throw new IllegalArgumentException(\"Instance is not a TelegramActions class.\");\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void setThingHandler(@Nullable ThingHandler handler) {\r\n-        this.handler = (TelegramHandler) handler;\r\n-    }\r\n-\r\n-    @Override\r\n-    public @Nullable ThingHandler getThingHandler() {\r\n-        return handler;\r\n-    }\r\n-}\r\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.telegram.bot;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Paths;\n+import java.util.Base64;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.telegram.internal.TelegramHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.pengrad.telegrambot.model.request.InlineKeyboardButton;\n+import com.pengrad.telegrambot.model.request.InlineKeyboardMarkup;\n+import com.pengrad.telegrambot.request.AnswerCallbackQuery;\n+import com.pengrad.telegrambot.request.EditMessageReplyMarkup;\n+import com.pengrad.telegrambot.request.SendMessage;\n+import com.pengrad.telegrambot.request.SendPhoto;\n+import com.pengrad.telegrambot.response.BaseResponse;\n+import com.pengrad.telegrambot.response.SendResponse;\n+\n+/**\n+ * Provides the actions for the Telegram API.\n+ *\n+ * @author Alexander Krasnogolowy - Initial contribution\n+ *\n+ */\n+@ThingActionsScope(name = \"telegram\")\n+@NonNullByDefault\n+public class TelegramActions implements ThingActions {\n+    private final Logger logger = LoggerFactory.getLogger(TelegramActions.class);\n+    private @Nullable TelegramHandler handler;\n+\n+    private boolean evaluateResponse(@Nullable BaseResponse response) {\n+        if (response != null && !response.isOk()) {\n+            logger.warn(\"Failed to send telegram message: {}\", response.description());\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @NonNullByDefault\n+    private static class BasicResult implements Authentication.Result {\n+\n+        private final HttpHeader header;\n+        private final URI uri;\n+        private final String value;\n+\n+        public BasicResult(HttpHeader header, URI uri, String value) {\n+            this.header = header;\n+            this.uri = uri;\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public URI getURI() {\n+            return this.uri;\n+        }\n+\n+        @Override\n+        public void apply(@Nullable Request request) {\n+            if (request != null) {\n+                request.header(this.header, this.value);\n+            }\n+        }\n+\n+        public String toString() {\n+            return String.format(\"Basic authentication result for %s\", this.uri);\n+        }\n+    }\n+\n+    @RuleAction(label = \"Telegram answer\", description = \"Sends a Telegram answer via Telegram API\")\n+    public boolean sendTelegramAnswer(@ActionInput(name = \"chatId\") @Nullable Long chatId,\n+            @ActionInput(name = \"replyId\") @Nullable String replyId,\n+            @ActionInput(name = \"message\") @Nullable String message) {\n+        if (replyId == null) {\n+            logger.warn(\"ReplyId not defined; action skipped.\");\n+            return false;\n+        }\n+        if (chatId == null) {\n+            logger.warn(\"chatId not defined; action skipped.\");\n+            return false;\n+        }\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            String callbackId = localHandler.getCallbackId(chatId, replyId);\n+            if (callbackId != null) {\n+                AnswerCallbackQuery answerCallbackQuery = new AnswerCallbackQuery(\n+                        localHandler.getCallbackId(chatId, replyId));\n+                logger.debug(\"AnswerCallbackQuery for chatId {} and replyId {} is the callbackId {}\", chatId, replyId,\n+                        localHandler.getCallbackId(chatId, replyId));\n+                // we could directly set the text here, but this\n+                // doesn't result in a real message only in a\n+                // little popup or in an alert, so the only purpose\n+                // is to stop the progress bar on client side\n+                if (!evaluateResponse(localHandler.execute(answerCallbackQuery))) {\n+                    return false;\n+                }\n+            }\n+            Integer messageId = localHandler.removeMessageId(chatId, replyId);\n+            logger.debug(\"remove messageId {} for chatId {} and replyId {}\", messageId, chatId, replyId);\n+\n+            EditMessageReplyMarkup editReplyMarkup = new EditMessageReplyMarkup(chatId, messageId.intValue())\n+                    .replyMarkup(new InlineKeyboardMarkup(new InlineKeyboardButton[0]));// remove reply markup from\n+                                                                                        // old message\n+            if (!evaluateResponse(localHandler.execute(editReplyMarkup))) {\n+                return false;\n+            }\n+            return message != null ? sendTelegram(chatId, message) : true;\n+        }\n+        return false;\n+    }\n+\n+    @RuleAction(label = \"Telegram answer\", description = \"Sends a Telegram answer via Telegram API\")\n+    public boolean sendTelegramAnswer(@ActionInput(name = \"replyId\") @Nullable String replyId,\n+            @ActionInput(name = \"message\") @Nullable String message) {\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            for (Long chatId : localHandler.getChatIds()) {\n+                if (!sendTelegramAnswer(chatId, replyId, message)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegram(@ActionInput(name = \"chatId\") @Nullable Long chatId,\n+            @ActionInput(name = \"message\") @Nullable String message) {\n+        return sendTelegramGeneral(chatId, message, (String) null);\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegram(@ActionInput(name = \"message\") @Nullable String message) {\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            for (Long chatId : localHandler.getChatIds()) {\n+                if (!sendTelegram(chatId, message)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegramQuery(@ActionInput(name = \"chatId\") @Nullable Long chatId,\n+            @ActionInput(name = \"message\") @Nullable String message,\n+            @ActionInput(name = \"replyId\") @Nullable String replyId,\n+            @ActionInput(name = \"buttons\") @Nullable String... buttons) {\n+        return sendTelegramGeneral(chatId, message, replyId, buttons);\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegramQuery(@ActionInput(name = \"message\") @Nullable String message,\n+            @ActionInput(name = \"replyId\") @Nullable String replyId,\n+            @ActionInput(name = \"buttons\") @Nullable String... buttons) {\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            for (Long chatId : localHandler.getChatIds()) {\n+                if (!sendTelegramQuery(chatId, message, replyId, buttons)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean sendTelegramGeneral(@ActionInput(name = \"chatId\") @Nullable Long chatId, @Nullable String message,\n+            @Nullable String replyId, @Nullable String... buttons) {\n+        if (message == null) {\n+            logger.warn(\"Message not defined; action skipped.\");\n+            return false;\n+        }\n+        if (chatId == null) {\n+            logger.warn(\"chatId not defined; action skipped.\");\n+            return false;\n+        }\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            SendMessage sendMessage = new SendMessage(chatId, message);\n+            if (localHandler.getParseMode() != null) {\n+                sendMessage.parseMode(localHandler.getParseMode());\n+            }\n+            if (replyId != null) {\n+                if (!replyId.contains(\" \")) {\n+                    if (buttons.length > 0) {\n+                        InlineKeyboardButton[][] keyboard2D = new InlineKeyboardButton[1][];\n+                        InlineKeyboardButton[] keyboard = new InlineKeyboardButton[buttons.length];\n+                        keyboard2D[0] = keyboard;\n+                        for (int i = 0; i < buttons.length; i++) {\n+                            keyboard[i] = new InlineKeyboardButton(buttons[i]).callbackData(replyId + \" \" + buttons[i]);\n+                        }\n+                        InlineKeyboardMarkup keyBoardMarkup = new InlineKeyboardMarkup(keyboard2D);\n+                        sendMessage.replyMarkup(keyBoardMarkup);\n+                    } else {\n+                        logger.warn(\n+                                \"The replyId {} for message {} is given, but no buttons are defined. ReplyMarkup will be ignored.\",\n+                                replyId, message);\n+                    }\n+                } else {\n+                    logger.warn(\"replyId {} must not contain spaces. ReplyMarkup will be ignored.\", replyId);\n+                }\n+            }\n+            SendResponse retMessage = localHandler.execute(sendMessage);\n+            if (!evaluateResponse(retMessage)) {\n+                return false;\n+            }\n+            if (replyId != null && retMessage != null) {\n+                logger.debug(\"Adding chatId {}, replyId {} and messageId {}\", chatId, replyId,\n+                        retMessage.message().messageId());\n+                localHandler.addMessageId(chatId, replyId, retMessage.message().messageId());\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegram(@ActionInput(name = \"chatId\") @Nullable Long chatId,\n+            @ActionInput(name = \"message\") @Nullable String format,\n+            @ActionInput(name = \"args\") @Nullable Object... args) {\n+        return sendTelegram(chatId, String.format(format, args));\n+    }\n+\n+    @RuleAction(label = \"Telegram message\", description = \"Sends a Telegram via Telegram API\")\n+    public boolean sendTelegram(@ActionInput(name = \"message\") @Nullable String format,\n+            @ActionInput(name = \"args\") @Nullable Object... args) {\n+        TelegramHandler localHandler = handler;\n+        if (localHandler != null) {\n+            for (Long chatId : localHandler.getChatIds()) {\n+                if (!sendTelegram(chatId, format, args)) {", "originalCommit": "f286914ac56e72551e3abddac1013e39c98fd915", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6f95451d837ff33fdb209d820f153181b551d312", "url": "https://github.com/openhab/openhab-addons/commit/6f95451d837ff33fdb209d820f153181b551d312", "message": "Update bundles/org.openhab.binding.telegram/src/main/java/org/openhab/binding/telegram/bot/TelegramActions.java", "committedDate": "2020-03-11T18:12:39Z", "type": "commit"}, {"oid": "ec38c4ba27d4aeda515668b9e22b7307d5895567", "url": "https://github.com/openhab/openhab-addons/commit/ec38c4ba27d4aeda515668b9e22b7307d5895567", "message": "Update bundles/org.openhab.binding.telegram/src/main/java/org/openhab/binding/telegram/bot/TelegramActions.java", "committedDate": "2020-03-11T18:12:48Z", "type": "commit"}, {"oid": "bcf3b1818363401d0c8c3e61e4805bf6b3809a86", "url": "https://github.com/openhab/openhab-addons/commit/bcf3b1818363401d0c8c3e61e4805bf6b3809a86", "message": "Update bundles/org.openhab.binding.telegram/src/main/java/org/openhab/binding/telegram/bot/TelegramActions.java", "committedDate": "2020-03-11T18:13:00Z", "type": "commit"}, {"oid": "34a8f4cf1f2ee1e13414ac066bf14d3c7e4d0b12", "url": "https://github.com/openhab/openhab-addons/commit/34a8f4cf1f2ee1e13414ac066bf14d3c7e4d0b12", "message": "Update bundles/org.openhab.binding.telegram/src/main/java/org/openhab/binding/telegram/bot/TelegramActions.java", "committedDate": "2020-03-11T18:13:10Z", "type": "commit"}]}