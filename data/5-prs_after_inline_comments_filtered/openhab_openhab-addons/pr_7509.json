{"pr_number": 7509, "pr_title": "[lcn] Add LCN binding", "pr_createdAt": "2020-04-30T17:35:09Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7509", "timeline": [{"oid": "ab44bd89cde49e0be33fe9716157a0f83d376328", "url": "https://github.com/openhab/openhab-addons/commit/ab44bd89cde49e0be33fe9716157a0f83d376328", "message": "[lcn] Add LCN binding\n\nMigrates the Local Control Network Binding from OH1 to OH2.\n\nCloses #108\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-05-31T21:34:35Z", "type": "commit"}, {"oid": "a0d78733a4c71137dc0e12ae39072904caf1ab6e", "url": "https://github.com/openhab/openhab-addons/commit/a0d78733a4c71137dc0e12ae39072904caf1ab6e", "message": "Minor improvements\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-05-31T21:34:50Z", "type": "commit"}, {"oid": "e30dc55c9fa422439f89c1222dba4b63aace3f9a", "url": "https://github.com/openhab/openhab-addons/commit/e30dc55c9fa422439f89c1222dba4b63aace3f9a", "message": "Improve discovery\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-05-31T21:34:50Z", "type": "commit"}, {"oid": "f6c8d4f8d969cbbfa051f03b747f630902ea29ab", "url": "https://github.com/openhab/openhab-addons/commit/f6c8d4f8d969cbbfa051f03b747f630902ea29ab", "message": "Fix formatting and improve LcnModuleHandler lifecycle\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-06-02T21:23:37Z", "type": "commit"}, {"oid": "dbe413f2f442645719b349fb40ffb7d2e2ca997e", "url": "https://github.com/openhab/openhab-addons/commit/dbe413f2f442645719b349fb40ffb7d2e2ca997e", "message": "Reviewed own code\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-06-06T13:23:08Z", "type": "commit"}, {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "url": "https://github.com/openhab/openhab-addons/commit/ce02f433e5d4071dbebb9ee68da0e22895887b6b", "message": "Remove test project\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-06-06T19:17:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NzA4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436397087", "bodyText": "What's the purpose of the NullScheduledFuture here? Couldn't you simply leave it uninitialized (null)?", "author": "kaikreuzer", "createdAt": "2020-06-07T20:05:38Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.NullScheduledFuture;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Scans all LCN segments for LCN modules.\n+ *\n+ * Scan approach:\n+ * 1. Send \"Leerkomando\" to the broadcast address with request for Ack set\n+ * 2. For every received Ack, send the following requests to the module:\n+ * - serial number request (SN)\n+ * - module's name first part request (NM1)\n+ * - module's name second part request (NM2)\n+ * 3. When all three messages have been received, fire thingDiscovered()\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleDiscoveryService.class);\n+    private static final Pattern NAME_PATTERN = Pattern\n+            .compile(\"=M(?<segId>\\\\d{3})(?<modId>\\\\d{3}).N(?<part>[1-2]{1})(?<name>.*)\");\n+    private static final int MODULE_NAME_PART_COUNT = 2;\n+    private static final int DISCOVERY_TIMEOUT_SEC = 90;\n+    private static final int ACK_TIMEOUT_MS = 1000;\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(LcnBindingConstants.THING_TYPE_MODULE).collect(Collectors.toSet()));\n+    private @Nullable PckGatewayHandler bridgeHandler;\n+    private Map<LcnAddrMod, Map<Integer, String>> moduleNames = Collections.synchronizedMap(new HashMap<>());\n+    private Map<LcnAddrMod, DiscoveryResultBuilder> discoveryResultBuilders = Collections\n+            .synchronizedMap(new HashMap<>());\n+    private List<LcnAddrMod> successfullyDiscovered = new LinkedList<>();\n+    private Queue<@Nullable LcnAddrMod> serialNumberRequestQueue = new ConcurrentLinkedQueue<>();\n+    private Queue<@Nullable LcnAddrMod> moduleNameRequestQueue = new ConcurrentLinkedQueue<>();\n+    private volatile ScheduledFuture<?> queueProcessor = NullScheduledFuture.getInstance();", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5NDQ1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r437794455", "bodyText": "I'm pretty sure the purpose is to allow the fields to be initialized to a non-null value so that he doesn't have to label it as @Nullable. Doing so allows him to not have to null check the field ever. I kinda like the solution but you could get the same result by just making the ScheduledFuture fields Future instead and then initialize them with a completed CompletableFuture.", "author": "cpmeister", "createdAt": "2020-06-10T00:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NzA4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxMzcxOA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438313718", "bodyText": "You're right. It saves some null checks. Since it seems a bit unusal, I replaced it by ordinary null checks for the sake of better code understanding. Anyhow, I like the hint with the CompletableFuture.", "author": "fwolter", "createdAt": "2020-06-10T18:04:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NzA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NzEwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436397104", "bodyText": "dito", "author": "kaikreuzer", "createdAt": "2020-06-07T20:05:43Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.NullScheduledFuture;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Scans all LCN segments for LCN modules.\n+ *\n+ * Scan approach:\n+ * 1. Send \"Leerkomando\" to the broadcast address with request for Ack set\n+ * 2. For every received Ack, send the following requests to the module:\n+ * - serial number request (SN)\n+ * - module's name first part request (NM1)\n+ * - module's name second part request (NM2)\n+ * 3. When all three messages have been received, fire thingDiscovered()\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleDiscoveryService.class);\n+    private static final Pattern NAME_PATTERN = Pattern\n+            .compile(\"=M(?<segId>\\\\d{3})(?<modId>\\\\d{3}).N(?<part>[1-2]{1})(?<name>.*)\");\n+    private static final int MODULE_NAME_PART_COUNT = 2;\n+    private static final int DISCOVERY_TIMEOUT_SEC = 90;\n+    private static final int ACK_TIMEOUT_MS = 1000;\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(LcnBindingConstants.THING_TYPE_MODULE).collect(Collectors.toSet()));\n+    private @Nullable PckGatewayHandler bridgeHandler;\n+    private Map<LcnAddrMod, Map<Integer, String>> moduleNames = Collections.synchronizedMap(new HashMap<>());\n+    private Map<LcnAddrMod, DiscoveryResultBuilder> discoveryResultBuilders = Collections\n+            .synchronizedMap(new HashMap<>());\n+    private List<LcnAddrMod> successfullyDiscovered = new LinkedList<>();\n+    private Queue<@Nullable LcnAddrMod> serialNumberRequestQueue = new ConcurrentLinkedQueue<>();\n+    private Queue<@Nullable LcnAddrMod> moduleNameRequestQueue = new ConcurrentLinkedQueue<>();\n+    private volatile ScheduledFuture<?> queueProcessor = NullScheduledFuture.getInstance();\n+    private ScheduledFuture<?> builderTask = NullScheduledFuture.getInstance();", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NzI1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436397256", "bodyText": "Can this be removed by adapting the code?", "author": "kaikreuzer", "createdAt": "2020-06-07T20:07:31Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.NullScheduledFuture;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Scans all LCN segments for LCN modules.\n+ *\n+ * Scan approach:\n+ * 1. Send \"Leerkomando\" to the broadcast address with request for Ack set\n+ * 2. For every received Ack, send the following requests to the module:\n+ * - serial number request (SN)\n+ * - module's name first part request (NM1)\n+ * - module's name second part request (NM2)\n+ * 3. When all three messages have been received, fire thingDiscovered()\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleDiscoveryService.class);\n+    private static final Pattern NAME_PATTERN = Pattern\n+            .compile(\"=M(?<segId>\\\\d{3})(?<modId>\\\\d{3}).N(?<part>[1-2]{1})(?<name>.*)\");\n+    private static final int MODULE_NAME_PART_COUNT = 2;\n+    private static final int DISCOVERY_TIMEOUT_SEC = 90;\n+    private static final int ACK_TIMEOUT_MS = 1000;\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(LcnBindingConstants.THING_TYPE_MODULE).collect(Collectors.toSet()));\n+    private @Nullable PckGatewayHandler bridgeHandler;\n+    private Map<LcnAddrMod, Map<Integer, String>> moduleNames = Collections.synchronizedMap(new HashMap<>());\n+    private Map<LcnAddrMod, DiscoveryResultBuilder> discoveryResultBuilders = Collections\n+            .synchronizedMap(new HashMap<>());\n+    private List<LcnAddrMod> successfullyDiscovered = new LinkedList<>();\n+    private Queue<@Nullable LcnAddrMod> serialNumberRequestQueue = new ConcurrentLinkedQueue<>();\n+    private Queue<@Nullable LcnAddrMod> moduleNameRequestQueue = new ConcurrentLinkedQueue<>();\n+    private volatile ScheduledFuture<?> queueProcessor = NullScheduledFuture.getInstance();\n+    private ScheduledFuture<?> builderTask = NullScheduledFuture.getInstance();\n+\n+    public LcnModuleDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_TIMEOUT_SEC, false);\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof PckGatewayHandler) {\n+            this.bridgeHandler = (PckGatewayHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        stopScan();\n+    }\n+\n+    @SuppressWarnings({ \"unused\", \"null\" })", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NzgzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436397836", "bodyText": "It isn't really a configuration error, i.e. some mistake of the user, is it?\nThose are rather severe software issues, so you could consider throwing an IllegalStateException here.", "author": "kaikreuzer", "createdAt": "2020-06-07T20:14:31Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleHandler.java", "diffHunk": "@@ -0,0 +1,411 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.ByteBuffer;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.openhab.binding.lcn.internal.converter.AbstractVariableValueConverter;\n+import org.openhab.binding.lcn.internal.converter.AngleConverter;\n+import org.openhab.binding.lcn.internal.converter.Co2Converter;\n+import org.openhab.binding.lcn.internal.converter.CurrentConverter;\n+import org.openhab.binding.lcn.internal.converter.EnergyConverter;\n+import org.openhab.binding.lcn.internal.converter.IdentityConverter;\n+import org.openhab.binding.lcn.internal.converter.LightConverter;\n+import org.openhab.binding.lcn.internal.converter.PowerConverter;\n+import org.openhab.binding.lcn.internal.converter.TemperatureConverter;\n+import org.openhab.binding.lcn.internal.converter.VoltageConverter;\n+import org.openhab.binding.lcn.internal.converter.WindspeedConverter;\n+import org.openhab.binding.lcn.internal.subhandler.AbstractLcnModuleSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LcnModuleHandler} is responsible for handling commands, which are\n+ * sent to or received from one of the channels.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleHandler.class);\n+    private @Nullable LcnAddrMod moduleAddress;\n+    private Map<LcnChannelGroup, @Nullable AbstractLcnModuleSubHandler> subHandlers;\n+    private List<AbstractLcnModuleSubHandler> metadataSubHandlers;\n+    private Map<ChannelUID, @Nullable AbstractVariableValueConverter> converters;\n+\n+    public LcnModuleHandler(Thing thing) {\n+        super(thing);\n+\n+        subHandlers = Collections.synchronizedMap(new HashMap<>());\n+        metadataSubHandlers = Collections.synchronizedList(new LinkedList<>());\n+        converters = Collections.synchronizedMap(new HashMap<>());\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        LcnModuleConfiguration localConfig = getConfigAs(LcnModuleConfiguration.class);\n+        LcnAddrMod localModuleAddress = moduleAddress = new LcnAddrMod(localConfig.segmentId, localConfig.moduleId);\n+\n+        try {\n+            // create sub handlers\n+            ModInfo info = getPckGatewayHandler().getModInfo(localModuleAddress);\n+            for (LcnChannelGroup type : LcnChannelGroup.values()) {\n+                AbstractLcnModuleSubHandler newHandler = type.getSubHandlerClass()\n+                        .getDeclaredConstructor(LcnModuleHandler.class, ModInfo.class).newInstance(this, info);\n+\n+                subHandlers.put(type, newHandler);\n+            }\n+\n+            // meta sub handlers, which are not assigned to a channel group\n+            metadataSubHandlers.add(new LcnModuleMetaAckSubHandler(this, info));\n+            metadataSubHandlers.add(new LcnModuleMetaFirmwareSubHandler(this, info));\n+\n+            // initialize variable value converters\n+            for (Channel channel : thing.getChannels()) {\n+                Object unitObject = channel.getConfiguration().get(\"unit\");\n+                Object parameterObject = channel.getConfiguration().get(\"parameter\");\n+\n+                if (unitObject instanceof String) {\n+                    switch ((String) unitObject) {\n+                        case \"temperature\":\n+                            converters.put(channel.getUID(), new TemperatureConverter());\n+                            break;\n+                        case \"light\":\n+                            converters.put(channel.getUID(), new LightConverter());\n+                            break;\n+                        case \"co2\":\n+                            converters.put(channel.getUID(), new Co2Converter());\n+                            break;\n+                        case \"power\":\n+                            converters.put(channel.getUID(), new PowerConverter(parameterObject));\n+                            break;\n+                        case \"energy\":\n+                            converters.put(channel.getUID(), new EnergyConverter(parameterObject));\n+                            break;\n+                        case \"current\":\n+                            converters.put(channel.getUID(), new CurrentConverter());\n+                            break;\n+                        case \"voltage\":\n+                            converters.put(channel.getUID(), new VoltageConverter());\n+                            break;\n+                        case \"angle\":\n+                            converters.put(channel.getUID(), new AngleConverter());\n+                            break;\n+                        case \"windspeed\":\n+                            converters.put(channel.getUID(), new WindspeedConverter());\n+                            break;\n+                    }\n+                }\n+            }\n+\n+            // module is assumed as online, when the corresponding Bridge (PckGatewayHandler) is online.\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (LcnException | InstantiationException | IllegalAccessException | IllegalArgumentException\n+                | InvocationTargetException | NoSuchMethodException | SecurityException e) {\n+            logger.warn(\"Failed to initialize handler: {}: {}: {}\", localModuleAddress, e.getClass().getSimpleName(),\n+                    e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NzkzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436397937", "bodyText": "why is this needed?", "author": "kaikreuzer", "createdAt": "2020-06-07T20:15:44Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleHandler.java", "diffHunk": "@@ -0,0 +1,411 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.ByteBuffer;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.openhab.binding.lcn.internal.converter.AbstractVariableValueConverter;\n+import org.openhab.binding.lcn.internal.converter.AngleConverter;\n+import org.openhab.binding.lcn.internal.converter.Co2Converter;\n+import org.openhab.binding.lcn.internal.converter.CurrentConverter;\n+import org.openhab.binding.lcn.internal.converter.EnergyConverter;\n+import org.openhab.binding.lcn.internal.converter.IdentityConverter;\n+import org.openhab.binding.lcn.internal.converter.LightConverter;\n+import org.openhab.binding.lcn.internal.converter.PowerConverter;\n+import org.openhab.binding.lcn.internal.converter.TemperatureConverter;\n+import org.openhab.binding.lcn.internal.converter.VoltageConverter;\n+import org.openhab.binding.lcn.internal.converter.WindspeedConverter;\n+import org.openhab.binding.lcn.internal.subhandler.AbstractLcnModuleSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LcnModuleHandler} is responsible for handling commands, which are\n+ * sent to or received from one of the channels.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleHandler.class);\n+    private @Nullable LcnAddrMod moduleAddress;\n+    private Map<LcnChannelGroup, @Nullable AbstractLcnModuleSubHandler> subHandlers;\n+    private List<AbstractLcnModuleSubHandler> metadataSubHandlers;\n+    private Map<ChannelUID, @Nullable AbstractVariableValueConverter> converters;\n+\n+    public LcnModuleHandler(Thing thing) {\n+        super(thing);\n+\n+        subHandlers = Collections.synchronizedMap(new HashMap<>());\n+        metadataSubHandlers = Collections.synchronizedList(new LinkedList<>());\n+        converters = Collections.synchronizedMap(new HashMap<>());\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        LcnModuleConfiguration localConfig = getConfigAs(LcnModuleConfiguration.class);\n+        LcnAddrMod localModuleAddress = moduleAddress = new LcnAddrMod(localConfig.segmentId, localConfig.moduleId);\n+\n+        try {\n+            // create sub handlers\n+            ModInfo info = getPckGatewayHandler().getModInfo(localModuleAddress);\n+            for (LcnChannelGroup type : LcnChannelGroup.values()) {\n+                AbstractLcnModuleSubHandler newHandler = type.getSubHandlerClass()\n+                        .getDeclaredConstructor(LcnModuleHandler.class, ModInfo.class).newInstance(this, info);\n+\n+                subHandlers.put(type, newHandler);\n+            }\n+\n+            // meta sub handlers, which are not assigned to a channel group\n+            metadataSubHandlers.add(new LcnModuleMetaAckSubHandler(this, info));\n+            metadataSubHandlers.add(new LcnModuleMetaFirmwareSubHandler(this, info));\n+\n+            // initialize variable value converters\n+            for (Channel channel : thing.getChannels()) {\n+                Object unitObject = channel.getConfiguration().get(\"unit\");\n+                Object parameterObject = channel.getConfiguration().get(\"parameter\");\n+\n+                if (unitObject instanceof String) {\n+                    switch ((String) unitObject) {\n+                        case \"temperature\":\n+                            converters.put(channel.getUID(), new TemperatureConverter());\n+                            break;\n+                        case \"light\":\n+                            converters.put(channel.getUID(), new LightConverter());\n+                            break;\n+                        case \"co2\":\n+                            converters.put(channel.getUID(), new Co2Converter());\n+                            break;\n+                        case \"power\":\n+                            converters.put(channel.getUID(), new PowerConverter(parameterObject));\n+                            break;\n+                        case \"energy\":\n+                            converters.put(channel.getUID(), new EnergyConverter(parameterObject));\n+                            break;\n+                        case \"current\":\n+                            converters.put(channel.getUID(), new CurrentConverter());\n+                            break;\n+                        case \"voltage\":\n+                            converters.put(channel.getUID(), new VoltageConverter());\n+                            break;\n+                        case \"angle\":\n+                            converters.put(channel.getUID(), new AngleConverter());\n+                            break;\n+                        case \"windspeed\":\n+                            converters.put(channel.getUID(), new WindspeedConverter());\n+                            break;\n+                    }\n+                }\n+            }\n+\n+            // module is assumed as online, when the corresponding Bridge (PckGatewayHandler) is online.\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (LcnException | InstantiationException | IllegalAccessException | IllegalArgumentException\n+                | InvocationTargetException | NoSuchMethodException | SecurityException e) {\n+            logger.warn(\"Failed to initialize handler: {}: {}: {}\", localModuleAddress, e.getClass().getSimpleName(),\n+                    e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUid, Command command) {\n+        try {\n+            String groupId = channelUid.getGroupId();\n+\n+            if (!channelUid.isInGroup()) {\n+                return;\n+            }\n+\n+            if (groupId == null) {\n+                throw new LcnException(\"Group ID is null\");\n+            }\n+\n+            LcnChannelGroup channelGroup = LcnChannelGroup.valueOf(groupId.toUpperCase());\n+            AbstractLcnModuleSubHandler subHandler = subHandlers.get(channelGroup);\n+\n+            if (subHandler == null) {\n+                throw new LcnException(\"Sub Handler not found for: \" + channelGroup);\n+            }\n+\n+            Optional<Integer> number = channelUidToChannelNumber(channelUid, channelGroup);\n+\n+            if (command instanceof RefreshType) {\n+                number.ifPresent(n -> subHandler.handleRefresh(channelGroup, n));\n+                subHandler.handleRefresh(channelUid.getIdWithoutGroup());\n+            } else if (command instanceof OnOffType) {\n+                subHandler.handleCommandOnOff(castCommand(command), channelGroup, number.get());\n+            } else if (command instanceof DimmerOutputCommand) {\n+                subHandler.handleCommandDimmerOutput(castCommand(command), number.get());\n+            } else if (command instanceof PercentType && number.isPresent()) {\n+                subHandler.handleCommandPercent(castCommand(command), channelGroup, number.get());\n+            } else if (command instanceof HSBType) {\n+                subHandler.handleCommandHsb(castCommand(command), channelUid.getIdWithoutGroup());\n+            } else if (command instanceof PercentType) {\n+                subHandler.handleCommandPercent(castCommand(command), channelGroup, channelUid.getIdWithoutGroup());\n+            } else if (command instanceof StringType) {\n+                subHandler.handleCommandString(castCommand(command), number.get());\n+            } else if (command instanceof DecimalType) {\n+                DecimalType decimalType = castCommand(command);\n+                DecimalType nativeValue = getConverter(channelUid).onCommandFromItem(decimalType.doubleValue());\n+                subHandler.handleCommandDecimal(nativeValue, channelGroup, number.get());\n+            } else if (command instanceof QuantityType) {\n+                QuantityType<?> quantityType = castCommand(command);\n+                DecimalType nativeValue = getConverter(channelUid).onCommandFromItem(quantityType);\n+                subHandler.handleCommandDecimal(nativeValue, channelGroup, number.get());\n+            } else if (command instanceof UpDownType) {\n+                subHandler.handleCommandUpDown(castCommand(command), channelGroup, number.get());\n+            } else if (command instanceof StopMoveType) {\n+                subHandler.handleCommandStopMove(castCommand(command), channelGroup, number.get());\n+            } else {\n+                throw new LcnException(\"Unsupported command type\");\n+            }\n+        } catch (IllegalArgumentException | NoSuchElementException | LcnException e) {\n+            logger.warn(\"{}: Failed to handle command {}: {}\", channelUid, command.getClass().getSimpleName(),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @NonNullByDefault({}) // getOrDefault()", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxNDczNw==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438314737", "bodyText": "Map.getOrDefault() returns Nullable, because of the Nullable declaration of the generic. Since the method never returns null, I disabled the null annotation.", "author": "fwolter", "createdAt": "2020-06-10T18:06:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NzkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5ODUzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436398533", "bodyText": "I'd think this helper class can be removed - see my comments above in the discovery service.", "author": "kaikreuzer", "createdAt": "2020-06-07T20:22:42Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/NullScheduledFuture.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Empty ScheduledFuture, used for initialization.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class NullScheduledFuture implements ScheduledFuture<Object> {", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5OTAwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436399002", "bodyText": "As this seems to be an optional parameter, it should be defined that a default of 1000 is used, if it is not provided and the logging here could just be debug level.", "author": "kaikreuzer", "createdAt": "2020-06-07T20:29:34Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/converter/AbstractS0Converter.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.converter;\n+\n+import java.math.BigDecimal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Base class for S0 counter value converters.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractS0Converter extends AbstractVariableValueConverter {\n+    private final Logger logger = LoggerFactory.getLogger(AbstractS0Converter.class);\n+    protected double pulsesPerKwh;\n+\n+    public AbstractS0Converter(@Nullable Object parameter) {\n+        if (parameter == null) {\n+            pulsesPerKwh = 1000;\n+            logger.info(\"Pulses per kWh not set. Assuming 1000 imp./kWh.\");", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MjkxMg==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436882912", "bodyText": "the other methods throw LcnException instead of a IllegalArgumentException. Why is this one different?", "author": "cpmeister", "createdAt": "2020-06-08T17:43:14Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/PckGenerator.java", "diffHunk": "@@ -0,0 +1,779 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Helpers to generate LCN-PCK commands.\n+ * <p>\n+ * LCN-PCK is the command-syntax used by LCN-PCHK to send and receive LCN commands.\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public final class PckGenerator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PckGenerator.class);\n+    /** Termination character after a PCK message */\n+    public static final String TERMINATION = \"\\n\";\n+\n+    /**\n+     * Generates a keep-alive.\n+     * LCN-PCHK will close the connection if it does not receive any commands from\n+     * an open {@link Connection} for a specific period (10 minutes by default).\n+     *\n+     * @param counter the current ping's id (optional, but \"best practice\"). Should start with 1\n+     * @return the PCK command as text\n+     */\n+    public static String ping(int counter) {\n+        return String.format(\"^ping%d\", counter);\n+    }\n+\n+    /**\n+     * Generates a PCK command that will set the LCN-PCHK connection's operation mode.\n+     * This influences how output-port commands and status are interpreted and must be\n+     * in sync with the LCN bus.\n+     *\n+     * @param dimMode see {@link LcnDefs.OutputPortDimMode}\n+     * @param statusMode see {@link LcnDefs.OutputPortStatusMode}\n+     * @return the PCK command as text\n+     */\n+    public static String setOperationMode(LcnDefs.OutputPortDimMode dimMode, LcnDefs.OutputPortStatusMode statusMode) {\n+        return \"!OM\" + (dimMode == LcnDefs.OutputPortDimMode.NATIVE200 ? \"1\" : \"0\")\n+                + (statusMode == LcnDefs.OutputPortStatusMode.PERCENT ? \"P\" : \"N\");\n+    }\n+\n+    /**\n+     * Generates a PCK address header.\n+     * Used for commands to LCN modules and groups.\n+     *\n+     * @param addr the target's address (module or group)\n+     * @param localSegId the local segment id where the physical bus connection is located\n+     * @param wantsAck true to claim an acknowledge / receipt from the target\n+     * @return the PCK address header as text\n+     */\n+    public static String generateAddressHeader(LcnAddr addr, int localSegId, boolean wantsAck) {\n+        return String.format(\">%s%03d%03d%s\", addr.isGroup() ? \"G\" : \"M\", addr.getPhysicalSegmentId(localSegId),\n+                addr.getId(), wantsAck ? \"!\" : \".\");\n+    }\n+\n+    /**\n+     * Generates a scan-command for LCN segment-couplers.\n+     * Used to detect the local segment (where the physical bus connection is located).\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String segmentCouplerScan() {\n+        return \"SK\";\n+    }\n+\n+    /**\n+     * Generates a firmware/serial-number request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestSn() {\n+        return \"SN\";\n+    }\n+\n+    /**\n+     * Generates a command to request a part of a name of a module.\n+     *\n+     * @param partNumber 0..1\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestModuleName(int partNumber) {\n+        return \"NMN\" + (partNumber + 1);\n+    }\n+\n+    /**\n+     * Generates an output-port status request.\n+     *\n+     * @param outputId 0..3\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String requestOutputStatus(int outputId) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"SMA%d\", outputId + 1);\n+    }\n+\n+    /**\n+     * Generates a dim command for a single output-port.\n+     *\n+     * @param outputId 0..3\n+     * @param percent 0..100\n+     * @param rampMs ramp in milliseconds\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String dimOutput(int outputId, double percent, int rampMs) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        int rampNative = PckGenerator.timeToRampValue(rampMs);\n+        int n = (int) Math.round(percent * 2);\n+        if ((n % 2) == 0) { // Use the percent command (supported by all LCN-PCHK versions)\n+            return String.format(\"A%dDI%03d%03d\", outputId + 1, n / 2, rampNative);\n+        } else { // We have a \".5\" value. Use the native command (supported since LCN-PCHK 2.3)\n+            return String.format(\"O%dDI%03d%03d\", outputId + 1, n, rampNative);\n+        }\n+    }\n+\n+    /**\n+     * Generates a dim command for all output-ports.\n+     *\n+     * Attention: This command is supported since module firmware version 180501 AND LCN-PCHK 2.61\n+     *\n+     * @param firstPercent dimmer value of the first output 0..100\n+     * @param secondPercent dimmer value of the first output 0..100\n+     * @param thirdPercent dimmer value of the first output 0..100\n+     * @param fourthPercent dimmer value of the first output 0..100\n+     * @param rampMs ramp in milliseconds\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String dimAllOutputs(double firstPercent, double secondPercent, double thirdPercent,\n+            double fourthPercent, int rampMs) {\n+        long n1 = Math.round(firstPercent * 2);\n+        long n2 = Math.round(secondPercent * 2);\n+        long n3 = Math.round(thirdPercent * 2);\n+        long n4 = Math.round(fourthPercent * 2);\n+\n+        return String.format(\"OY%03d%03d%03d%03d%03d\", n1, n2, n3, n4, timeToRampValue(rampMs));\n+    }\n+\n+    /**\n+     * Generates a control command for switching all outputs ON or OFF with a fixed ramp of 0.5s.\n+     *\n+     * @param percent 0..100\n+     * @returnthe PCK command (without address header) as text\n+     */\n+    public static String controlAllOutputs(double percent) {\n+        return String.format(\"AH%03d\", Math.round(percent));\n+    }\n+\n+    /**\n+     * Generates a control command for switching dimmer output 1 and 2 both ON or OFF with a fixed ramp of 0.5s or\n+     * without ramp.\n+     *\n+     * @param on true, if outputs shall be switched on\n+     * @param ramp true, if the ramp shall be 0.5s, else 0s\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String controlOutputs12(boolean on, boolean ramp) {\n+        int commandByte;\n+        if (on) {\n+            commandByte = ramp ? 0xC8 : 0xFD;\n+        } else {\n+            commandByte = ramp ? 0x00 : 0xFC;\n+        }\n+        return String.format(\"X2%03d%03d%03d\", 1, commandByte, commandByte);\n+    }\n+\n+    /**\n+     * Generates a dim command for setting the brightness of dimmer output 1 and 2 with a fixed ramp of 0.5s.\n+     *\n+     * @param percent brightness of both outputs 0..100\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String dimOutputs12(double percent) {\n+        long localPercent = Math.round(percent);\n+        return String.format(\"AY%03d%03d\", localPercent, localPercent);\n+    }\n+\n+    /**\n+     * Let an output flicker.\n+     *\n+     * @param outputId output id 0..3\n+     * @param depth flicker depth, the higher the deeper 0..2\n+     * @param ramp the flicker speed 0..2\n+     * @param count number of flashes 1..15\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException when the input values are out of range\n+     */\n+    public static String flickerOutput(int outputId, int depth, int ramp, int count) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException(\"Output number out of range\");\n+        }\n+        if (count < 1 || count > 15) {\n+            throw new LcnException(\"Number of flashes out of range\");\n+        }\n+        String depthString;\n+        switch (depth) {\n+            case 0:\n+                depthString = \"G\";\n+                break;\n+            case 1:\n+                depthString = \"M\";\n+                break;\n+            case 2:\n+                depthString = \"S\";\n+                break;\n+            default:\n+                throw new LcnException(\"Depth out of range\");\n+        }\n+        String rampString;\n+        switch (ramp) {\n+            case 0:\n+                rampString = \"L\";\n+                break;\n+            case 1:\n+                rampString = \"M\";\n+                break;\n+            case 2:\n+                rampString = \"S\";\n+                break;\n+            default:\n+                throw new LcnException(\"Ramp out of range\");\n+        }\n+        return String.format(\"A%dFL%s%s%02d\", outputId + 1, depthString, rampString, count);\n+    }\n+\n+    /**\n+     * Generates a command to change the value of an output-port.\n+     *\n+     * @param outputId 0..3\n+     * @param percent -100..100\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String relOutput(int outputId, double percent) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        int n = (int) Math.round(percent * 2);\n+        if ((n % 2) == 0) { // Use the percent command (supported by all LCN-PCHK versions)\n+            return String.format(\"A%d%s%03d\", outputId + 1, percent >= 0 ? \"AD\" : \"SB\", Math.abs(n / 2));\n+        } else { // We have a \".5\" value. Use the native command (supported since LCN-PCHK 2.3)\n+            return String.format(\"O%d%s%03d\", outputId + 1, percent >= 0 ? \"AD\" : \"SB\", Math.abs(n));\n+        }\n+    }\n+\n+    /**\n+     * Generates a command that toggles a single output-port (on->off, off->on).\n+     *\n+     * @param outputId 0..3\n+     * @param ramp see {@link PckGenerator#timeToRampValue(int)}\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String toggleOutput(int outputId, int ramp) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"A%dTA%03d\", outputId + 1, ramp);\n+    }\n+\n+    /**\n+     * Generates a command that toggles all output-ports (on->off, off->on).\n+     *\n+     * @param ramp see {@link PckGenerator#timeToRampValue(int)}\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String toggleAllOutputs(int ramp) {\n+        return String.format(\"AU%03d\", ramp);\n+    }\n+\n+    /**\n+     * Generates a relays-status request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestRelaysStatus() {\n+        return \"SMR\";\n+    }\n+\n+    /**\n+     * Generates a command to control relays.\n+     *\n+     * @param states the 8 modifiers for the relay states\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String controlRelays(LcnDefs.RelayStateModifier[] states) throws LcnException {\n+        if (states.length != 8) {\n+            throw new LcnException();\n+        }\n+        String ret = \"R8\";\n+        for (int i = 0; i < 8; ++i) {\n+            switch (states[i]) {\n+                case ON:\n+                    ret += \"1\";\n+                    break;\n+                case OFF:\n+                    ret += \"0\";\n+                    break;\n+                case TOGGLE:\n+                    ret += \"U\";\n+                    break;\n+                case NOCHANGE:\n+                    ret += \"-\";\n+                    break;\n+                default:\n+                    throw new LcnException();\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Generates a binary-sensors status request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestBinSensorsStatus() {\n+        return \"SMB\";\n+    }\n+\n+    /**\n+     * Generates a command that sets a variable absolute.\n+     *\n+     * @param number regulator number 0..1\n+     * @param value the absolute value to set\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException\n+     */\n+    public static String setSetpointAbsolute(int number, int value) {\n+        int internalValue = value;\n+        // Set absolute (not in PCK yet)\n+        int b1 = number << 6; // 01000000\n+        b1 |= 0x20; // xx10xxxx (set absolute)\n+        if (value < 1000) {\n+            internalValue = 1000 - internalValue;\n+            b1 |= 8;\n+        } else {\n+            internalValue -= 1000;\n+        }\n+        b1 |= (internalValue >> 8) & 0x0f; // xxxx1111\n+        int b2 = internalValue & 0xff;\n+        return String.format(\"X2%03d%03d%03d\", 30, b1, b2);\n+    }\n+\n+    /**\n+     * Generates a command to change the value of a variable.\n+     *\n+     * @param variable the target variable to change\n+     * @param type the reference-point\n+     * @param value the native LCN value to add/subtract (can be negative)\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if command is not supported\n+     */\n+    public static String setVariableRelative(Variable variable, LcnDefs.RelVarRef type, int value) {\n+        if (variable.getNumber() == 0) {\n+            // Old command for variable 1 / T-var (compatible with all modules)\n+            return String.format(\"Z%s%d\", value >= 0 ? \"A\" : \"S\", Math.abs(value));\n+        } else { // New command for variable 1-12 (compatible with all modules, since LCN-PCHK 2.8)\n+            return String.format(\"Z%s%03d%d\", value >= 0 ? \"+\" : \"-\", variable.getNumber() + 1, Math.abs(value));\n+        }\n+    }\n+\n+    /**\n+     * Generates a command the change the value of a regulator setpoint relative.\n+     *\n+     * @param number 0..1\n+     * @param type relative to the current or to the programmed value\n+     * @param value the relative value -4000..+4000\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String setSetpointRelative(int number, LcnDefs.RelVarRef type, int value) {\n+        return String.format(\"RE%sS%s%s%d\", number == 0 ? \"A\" : \"B\", type == LcnDefs.RelVarRef.CURRENT ? \"A\" : \"P\",\n+                value >= 0 ? \"+\" : \"-\", Math.abs(value));\n+    }\n+\n+    /**\n+     * Generates a command the change the value of a threshold relative.\n+     *\n+     * @param variable the threshold to change\n+     * @param type relative to the current or to the programmed value\n+     * @param value the relative value -4000..+4000\n+     * @param is2013 true, if the LCN module's firmware is equal to or newer than 2013\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String setThresholdRelative(Variable variable, LcnDefs.RelVarRef type, int value, boolean is2013)\n+            throws LcnException {\n+        if (is2013) { // New command for registers 1-4 (since 170206, LCN-PCHK 2.8)\n+            return String.format(\"SS%s%04d%sR%d%d\", type == LcnDefs.RelVarRef.CURRENT ? \"R\" : \"E\", Math.abs(value),\n+                    value >= 0 ? \"A\" : \"S\", variable.getNumber() + 1, variable.getThresholdNumber().get() + 1);\n+        } else if (variable.getNumber() == 0) { // Old command for register 1 (before 170206)\n+            return String.format(\"SS%s%04d%s%s%s%s%s%s\", type == LcnDefs.RelVarRef.CURRENT ? \"R\" : \"E\", Math.abs(value),\n+                    value >= 0 ? \"A\" : \"S\", variable.getThresholdNumber().get() == 0 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 1 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 2 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 3 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 4 ? \"1\" : \"0\");\n+        } else {\n+            throw new LcnException(\n+                    \"Module does not have threshold register \" + (variable.getThresholdNumber().get() + 1));\n+        }\n+    }\n+\n+    /**\n+     * Generates a variable value request.\n+     *\n+     * @param variable the variable to request\n+     * @param firmwareVersion the target module's firmware version\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if command is not supported\n+     */\n+    public static String requestVarStatus(Variable variable, int firmwareVersion) throws LcnException {\n+        if (firmwareVersion >= LcnBindingConstants.FIRMWARE_2013) {\n+            int id = variable.getNumber();\n+            switch (variable.getType()) {\n+                case UNKNOWN:\n+                    throw new LcnException(\"Variable unknown\");\n+                case VARIABLE:\n+                    return String.format(\"MWT%03d\", id + 1);\n+                case REGULATOR:\n+                    return String.format(\"MWS%03d\", id + 1);\n+                case THRESHOLD:\n+                    return String.format(\"SE%03d\", id + 1); // Whole register\n+                case S0INPUT:\n+                    return String.format(\"MWC%03d\", id + 1);\n+            }\n+            throw new LcnException(\"Unsupported variable type: \" + variable);\n+        } else {\n+            switch (variable) {\n+                case VARIABLE1:\n+                    return \"MWV\";\n+                case VARIABLE2:\n+                    return \"MWTA\";\n+                case VARIABLE3:\n+                    return \"MWTB\";\n+                case RVARSETPOINT1:\n+                    return \"MWSA\";\n+                case RVARSETPOINT2:\n+                    return \"MWSB\";\n+                case THRESHOLDREGISTER11:\n+                case THRESHOLDREGISTER12:\n+                case THRESHOLDREGISTER13:\n+                case THRESHOLDREGISTER14:\n+                case THRESHOLDREGISTER15:\n+                    return \"SL1\"; // Whole register\n+                default:\n+                    throw new LcnException(\"Unsupported variable type: \" + variable);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates a request for LED and logic-operations states.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestLedsAndLogicOpsStatus() {\n+        return \"SMT\";\n+    }\n+\n+    /**\n+     * Generates a command to the set the state of a single LED.\n+     *\n+     * @param ledId 0..11\n+     * @param state the state to set\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String controlLed(int ledId, LcnDefs.LedStatus state) throws LcnException {\n+        if (ledId < 0 || ledId > 11) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"LA%03d%s\", ledId + 1, state == LcnDefs.LedStatus.OFF ? \"A\"\n+                : state == LcnDefs.LedStatus.ON ? \"E\" : state == LcnDefs.LedStatus.BLINK ? \"B\" : \"F\");\n+    }\n+\n+    /**\n+     * Generates a command to send LCN keys.\n+     *\n+     * @param cmds the 4 concrete commands to send for the tables (A-D)\n+     * @param keys the tables' 8 key-states (true means \"send\")\n+     * @return the PCK command (without address header) as text\n+     * @throws IllegalArgumentException if out of range\n+     */\n+    public static String sendKeys(LcnDefs.SendKeyCommand[] cmds, boolean[] keys) throws LcnException {\n+        if (cmds.length != 4 || keys.length != 8) {\n+            throw new LcnException();\n+        }\n+        String ret = \"TS\";\n+        for (int i = 0; i < 4; ++i) {\n+            switch (cmds[i]) {\n+                case HIT:\n+                    ret += \"K\";\n+                    break;\n+                case MAKE:\n+                    ret += \"L\";\n+                    break;\n+                case BREAK:\n+                    ret += \"O\";\n+                    break;\n+                case DONTSEND:\n+                    // By skipping table D (if it is not used), we use the old command\n+                    // for table A-C which is compatible with older LCN modules\n+                    if (i < 3) {\n+                        ret += \"-\";\n+                    }\n+                    break;\n+                default:\n+                    throw new LcnException();\n+            }\n+        }\n+        for (int i = 0; i < 8; ++i) {\n+            ret += keys[i] ? \"1\" : \"0\";\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Generates a command to send LCN keys deferred / delayed.\n+     *\n+     * @param tableId 0(A)..3(D)\n+     * @param time the delay time\n+     * @param timeUnit the time unit\n+     * @param keys the key-states (true means \"send\")\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String sendKeysHitDefered(int tableId, int time, LcnDefs.TimeUnit timeUnit, boolean[] keys)\n+            throws LcnException {\n+        if (tableId < 0 || tableId > 3 || keys.length != 8) {\n+            throw new IllegalArgumentException();\n+        }\n+        String ret = \"TV\";\n+        switch (tableId) {\n+            case 0:\n+                ret += \"A\";\n+                break;\n+            case 1:\n+                ret += \"B\";\n+                break;\n+            case 2:\n+                ret += \"C\";\n+                break;\n+            case 3:\n+                ret += \"D\";\n+                break;\n+            default:\n+                throw new LcnException();\n+        }\n+        ret += String.format(\"%03d\", time);\n+        switch (timeUnit) {\n+            case SECONDS:\n+                if (time < 1 || time > 60) {\n+                    throw new LcnException();\n+                }\n+                ret += \"S\";\n+                break;\n+            case MINUTES:\n+                if (time < 1 || time > 90) {\n+                    throw new LcnException();\n+                }\n+                ret += \"M\";\n+                break;\n+            case HOURS:\n+                if (time < 1 || time > 50) {\n+                    throw new LcnException();\n+                }\n+                ret += \"H\";\n+                break;\n+            case DAYS:\n+                if (time < 1 || time > 45) {\n+                    throw new LcnException();\n+                }\n+                ret += \"D\";\n+                break;\n+            default:\n+                throw new LcnException();\n+        }\n+        for (int i = 0; i < 8; ++i) {\n+            ret += keys[i] ? \"1\" : \"0\";\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Generates a request for key-lock states.\n+     * Always requests table A-D. Supported since LCN-PCHK 2.8.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestKeyLocksStatus() {\n+        return \"STX\";\n+    }\n+\n+    /**\n+     * Generates a command to lock keys.\n+     *\n+     * @param tableId 0(A)..3(D)\n+     * @param states the 8 key-lock modifiers\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String lockKeys(int tableId, LcnDefs.KeyLockStateModifier[] states) throws LcnException {\n+        if (tableId < 0 || tableId > 3 || states.length != 8) {\n+            throw new LcnException();\n+        }\n+        String ret = String.format(\"TX%s\", tableId == 0 ? \"A\" : tableId == 1 ? \"B\" : tableId == 2 ? \"C\" : \"D\");\n+        for (int i = 0; i < 8; ++i) {\n+            switch (states[i]) {\n+                case ON:\n+                    ret += \"1\";\n+                    break;\n+                case OFF:\n+                    ret += \"0\";\n+                    break;\n+                case TOGGLE:\n+                    ret += \"U\";\n+                    break;\n+                case NOCHANGE:\n+                    ret += \"-\";\n+                    break;\n+                default:\n+                    throw new LcnException();\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Generates a command to lock keys for table A temporary.\n+     * There is no hardware-support for locking tables B-D.\n+     *\n+     * @param time the lock time\n+     * @param timeUnit the time unit\n+     * @param keys the 8 key-lock states (true means lock)\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String lockKeyTabATemporary(int time, LcnDefs.TimeUnit timeUnit, boolean[] keys) throws LcnException {\n+        if (keys.length != 8) {\n+            throw new IllegalArgumentException();", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4NjE4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436886185", "bodyText": "The java compiler can't optimize string concatenation in a loop so you should just use a StringBuilder directly here.", "author": "cpmeister", "createdAt": "2020-06-08T17:48:54Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/PckGenerator.java", "diffHunk": "@@ -0,0 +1,779 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Helpers to generate LCN-PCK commands.\n+ * <p>\n+ * LCN-PCK is the command-syntax used by LCN-PCHK to send and receive LCN commands.\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public final class PckGenerator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PckGenerator.class);\n+    /** Termination character after a PCK message */\n+    public static final String TERMINATION = \"\\n\";\n+\n+    /**\n+     * Generates a keep-alive.\n+     * LCN-PCHK will close the connection if it does not receive any commands from\n+     * an open {@link Connection} for a specific period (10 minutes by default).\n+     *\n+     * @param counter the current ping's id (optional, but \"best practice\"). Should start with 1\n+     * @return the PCK command as text\n+     */\n+    public static String ping(int counter) {\n+        return String.format(\"^ping%d\", counter);\n+    }\n+\n+    /**\n+     * Generates a PCK command that will set the LCN-PCHK connection's operation mode.\n+     * This influences how output-port commands and status are interpreted and must be\n+     * in sync with the LCN bus.\n+     *\n+     * @param dimMode see {@link LcnDefs.OutputPortDimMode}\n+     * @param statusMode see {@link LcnDefs.OutputPortStatusMode}\n+     * @return the PCK command as text\n+     */\n+    public static String setOperationMode(LcnDefs.OutputPortDimMode dimMode, LcnDefs.OutputPortStatusMode statusMode) {\n+        return \"!OM\" + (dimMode == LcnDefs.OutputPortDimMode.NATIVE200 ? \"1\" : \"0\")\n+                + (statusMode == LcnDefs.OutputPortStatusMode.PERCENT ? \"P\" : \"N\");\n+    }\n+\n+    /**\n+     * Generates a PCK address header.\n+     * Used for commands to LCN modules and groups.\n+     *\n+     * @param addr the target's address (module or group)\n+     * @param localSegId the local segment id where the physical bus connection is located\n+     * @param wantsAck true to claim an acknowledge / receipt from the target\n+     * @return the PCK address header as text\n+     */\n+    public static String generateAddressHeader(LcnAddr addr, int localSegId, boolean wantsAck) {\n+        return String.format(\">%s%03d%03d%s\", addr.isGroup() ? \"G\" : \"M\", addr.getPhysicalSegmentId(localSegId),\n+                addr.getId(), wantsAck ? \"!\" : \".\");\n+    }\n+\n+    /**\n+     * Generates a scan-command for LCN segment-couplers.\n+     * Used to detect the local segment (where the physical bus connection is located).\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String segmentCouplerScan() {\n+        return \"SK\";\n+    }\n+\n+    /**\n+     * Generates a firmware/serial-number request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestSn() {\n+        return \"SN\";\n+    }\n+\n+    /**\n+     * Generates a command to request a part of a name of a module.\n+     *\n+     * @param partNumber 0..1\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestModuleName(int partNumber) {\n+        return \"NMN\" + (partNumber + 1);\n+    }\n+\n+    /**\n+     * Generates an output-port status request.\n+     *\n+     * @param outputId 0..3\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String requestOutputStatus(int outputId) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"SMA%d\", outputId + 1);\n+    }\n+\n+    /**\n+     * Generates a dim command for a single output-port.\n+     *\n+     * @param outputId 0..3\n+     * @param percent 0..100\n+     * @param rampMs ramp in milliseconds\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String dimOutput(int outputId, double percent, int rampMs) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        int rampNative = PckGenerator.timeToRampValue(rampMs);\n+        int n = (int) Math.round(percent * 2);\n+        if ((n % 2) == 0) { // Use the percent command (supported by all LCN-PCHK versions)\n+            return String.format(\"A%dDI%03d%03d\", outputId + 1, n / 2, rampNative);\n+        } else { // We have a \".5\" value. Use the native command (supported since LCN-PCHK 2.3)\n+            return String.format(\"O%dDI%03d%03d\", outputId + 1, n, rampNative);\n+        }\n+    }\n+\n+    /**\n+     * Generates a dim command for all output-ports.\n+     *\n+     * Attention: This command is supported since module firmware version 180501 AND LCN-PCHK 2.61\n+     *\n+     * @param firstPercent dimmer value of the first output 0..100\n+     * @param secondPercent dimmer value of the first output 0..100\n+     * @param thirdPercent dimmer value of the first output 0..100\n+     * @param fourthPercent dimmer value of the first output 0..100\n+     * @param rampMs ramp in milliseconds\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String dimAllOutputs(double firstPercent, double secondPercent, double thirdPercent,\n+            double fourthPercent, int rampMs) {\n+        long n1 = Math.round(firstPercent * 2);\n+        long n2 = Math.round(secondPercent * 2);\n+        long n3 = Math.round(thirdPercent * 2);\n+        long n4 = Math.round(fourthPercent * 2);\n+\n+        return String.format(\"OY%03d%03d%03d%03d%03d\", n1, n2, n3, n4, timeToRampValue(rampMs));\n+    }\n+\n+    /**\n+     * Generates a control command for switching all outputs ON or OFF with a fixed ramp of 0.5s.\n+     *\n+     * @param percent 0..100\n+     * @returnthe PCK command (without address header) as text\n+     */\n+    public static String controlAllOutputs(double percent) {\n+        return String.format(\"AH%03d\", Math.round(percent));\n+    }\n+\n+    /**\n+     * Generates a control command for switching dimmer output 1 and 2 both ON or OFF with a fixed ramp of 0.5s or\n+     * without ramp.\n+     *\n+     * @param on true, if outputs shall be switched on\n+     * @param ramp true, if the ramp shall be 0.5s, else 0s\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String controlOutputs12(boolean on, boolean ramp) {\n+        int commandByte;\n+        if (on) {\n+            commandByte = ramp ? 0xC8 : 0xFD;\n+        } else {\n+            commandByte = ramp ? 0x00 : 0xFC;\n+        }\n+        return String.format(\"X2%03d%03d%03d\", 1, commandByte, commandByte);\n+    }\n+\n+    /**\n+     * Generates a dim command for setting the brightness of dimmer output 1 and 2 with a fixed ramp of 0.5s.\n+     *\n+     * @param percent brightness of both outputs 0..100\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String dimOutputs12(double percent) {\n+        long localPercent = Math.round(percent);\n+        return String.format(\"AY%03d%03d\", localPercent, localPercent);\n+    }\n+\n+    /**\n+     * Let an output flicker.\n+     *\n+     * @param outputId output id 0..3\n+     * @param depth flicker depth, the higher the deeper 0..2\n+     * @param ramp the flicker speed 0..2\n+     * @param count number of flashes 1..15\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException when the input values are out of range\n+     */\n+    public static String flickerOutput(int outputId, int depth, int ramp, int count) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException(\"Output number out of range\");\n+        }\n+        if (count < 1 || count > 15) {\n+            throw new LcnException(\"Number of flashes out of range\");\n+        }\n+        String depthString;\n+        switch (depth) {\n+            case 0:\n+                depthString = \"G\";\n+                break;\n+            case 1:\n+                depthString = \"M\";\n+                break;\n+            case 2:\n+                depthString = \"S\";\n+                break;\n+            default:\n+                throw new LcnException(\"Depth out of range\");\n+        }\n+        String rampString;\n+        switch (ramp) {\n+            case 0:\n+                rampString = \"L\";\n+                break;\n+            case 1:\n+                rampString = \"M\";\n+                break;\n+            case 2:\n+                rampString = \"S\";\n+                break;\n+            default:\n+                throw new LcnException(\"Ramp out of range\");\n+        }\n+        return String.format(\"A%dFL%s%s%02d\", outputId + 1, depthString, rampString, count);\n+    }\n+\n+    /**\n+     * Generates a command to change the value of an output-port.\n+     *\n+     * @param outputId 0..3\n+     * @param percent -100..100\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String relOutput(int outputId, double percent) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        int n = (int) Math.round(percent * 2);\n+        if ((n % 2) == 0) { // Use the percent command (supported by all LCN-PCHK versions)\n+            return String.format(\"A%d%s%03d\", outputId + 1, percent >= 0 ? \"AD\" : \"SB\", Math.abs(n / 2));\n+        } else { // We have a \".5\" value. Use the native command (supported since LCN-PCHK 2.3)\n+            return String.format(\"O%d%s%03d\", outputId + 1, percent >= 0 ? \"AD\" : \"SB\", Math.abs(n));\n+        }\n+    }\n+\n+    /**\n+     * Generates a command that toggles a single output-port (on->off, off->on).\n+     *\n+     * @param outputId 0..3\n+     * @param ramp see {@link PckGenerator#timeToRampValue(int)}\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String toggleOutput(int outputId, int ramp) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"A%dTA%03d\", outputId + 1, ramp);\n+    }\n+\n+    /**\n+     * Generates a command that toggles all output-ports (on->off, off->on).\n+     *\n+     * @param ramp see {@link PckGenerator#timeToRampValue(int)}\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String toggleAllOutputs(int ramp) {\n+        return String.format(\"AU%03d\", ramp);\n+    }\n+\n+    /**\n+     * Generates a relays-status request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestRelaysStatus() {\n+        return \"SMR\";\n+    }\n+\n+    /**\n+     * Generates a command to control relays.\n+     *\n+     * @param states the 8 modifiers for the relay states\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String controlRelays(LcnDefs.RelayStateModifier[] states) throws LcnException {\n+        if (states.length != 8) {\n+            throw new LcnException();\n+        }\n+        String ret = \"R8\";\n+        for (int i = 0; i < 8; ++i) {\n+            switch (states[i]) {\n+                case ON:\n+                    ret += \"1\";", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4NjQ4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436886489", "bodyText": "Use a StringBuilder here.", "author": "cpmeister", "createdAt": "2020-06-08T17:49:25Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/PckGenerator.java", "diffHunk": "@@ -0,0 +1,779 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Helpers to generate LCN-PCK commands.\n+ * <p>\n+ * LCN-PCK is the command-syntax used by LCN-PCHK to send and receive LCN commands.\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public final class PckGenerator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PckGenerator.class);\n+    /** Termination character after a PCK message */\n+    public static final String TERMINATION = \"\\n\";\n+\n+    /**\n+     * Generates a keep-alive.\n+     * LCN-PCHK will close the connection if it does not receive any commands from\n+     * an open {@link Connection} for a specific period (10 minutes by default).\n+     *\n+     * @param counter the current ping's id (optional, but \"best practice\"). Should start with 1\n+     * @return the PCK command as text\n+     */\n+    public static String ping(int counter) {\n+        return String.format(\"^ping%d\", counter);\n+    }\n+\n+    /**\n+     * Generates a PCK command that will set the LCN-PCHK connection's operation mode.\n+     * This influences how output-port commands and status are interpreted and must be\n+     * in sync with the LCN bus.\n+     *\n+     * @param dimMode see {@link LcnDefs.OutputPortDimMode}\n+     * @param statusMode see {@link LcnDefs.OutputPortStatusMode}\n+     * @return the PCK command as text\n+     */\n+    public static String setOperationMode(LcnDefs.OutputPortDimMode dimMode, LcnDefs.OutputPortStatusMode statusMode) {\n+        return \"!OM\" + (dimMode == LcnDefs.OutputPortDimMode.NATIVE200 ? \"1\" : \"0\")\n+                + (statusMode == LcnDefs.OutputPortStatusMode.PERCENT ? \"P\" : \"N\");\n+    }\n+\n+    /**\n+     * Generates a PCK address header.\n+     * Used for commands to LCN modules and groups.\n+     *\n+     * @param addr the target's address (module or group)\n+     * @param localSegId the local segment id where the physical bus connection is located\n+     * @param wantsAck true to claim an acknowledge / receipt from the target\n+     * @return the PCK address header as text\n+     */\n+    public static String generateAddressHeader(LcnAddr addr, int localSegId, boolean wantsAck) {\n+        return String.format(\">%s%03d%03d%s\", addr.isGroup() ? \"G\" : \"M\", addr.getPhysicalSegmentId(localSegId),\n+                addr.getId(), wantsAck ? \"!\" : \".\");\n+    }\n+\n+    /**\n+     * Generates a scan-command for LCN segment-couplers.\n+     * Used to detect the local segment (where the physical bus connection is located).\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String segmentCouplerScan() {\n+        return \"SK\";\n+    }\n+\n+    /**\n+     * Generates a firmware/serial-number request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestSn() {\n+        return \"SN\";\n+    }\n+\n+    /**\n+     * Generates a command to request a part of a name of a module.\n+     *\n+     * @param partNumber 0..1\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestModuleName(int partNumber) {\n+        return \"NMN\" + (partNumber + 1);\n+    }\n+\n+    /**\n+     * Generates an output-port status request.\n+     *\n+     * @param outputId 0..3\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String requestOutputStatus(int outputId) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"SMA%d\", outputId + 1);\n+    }\n+\n+    /**\n+     * Generates a dim command for a single output-port.\n+     *\n+     * @param outputId 0..3\n+     * @param percent 0..100\n+     * @param rampMs ramp in milliseconds\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String dimOutput(int outputId, double percent, int rampMs) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        int rampNative = PckGenerator.timeToRampValue(rampMs);\n+        int n = (int) Math.round(percent * 2);\n+        if ((n % 2) == 0) { // Use the percent command (supported by all LCN-PCHK versions)\n+            return String.format(\"A%dDI%03d%03d\", outputId + 1, n / 2, rampNative);\n+        } else { // We have a \".5\" value. Use the native command (supported since LCN-PCHK 2.3)\n+            return String.format(\"O%dDI%03d%03d\", outputId + 1, n, rampNative);\n+        }\n+    }\n+\n+    /**\n+     * Generates a dim command for all output-ports.\n+     *\n+     * Attention: This command is supported since module firmware version 180501 AND LCN-PCHK 2.61\n+     *\n+     * @param firstPercent dimmer value of the first output 0..100\n+     * @param secondPercent dimmer value of the first output 0..100\n+     * @param thirdPercent dimmer value of the first output 0..100\n+     * @param fourthPercent dimmer value of the first output 0..100\n+     * @param rampMs ramp in milliseconds\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String dimAllOutputs(double firstPercent, double secondPercent, double thirdPercent,\n+            double fourthPercent, int rampMs) {\n+        long n1 = Math.round(firstPercent * 2);\n+        long n2 = Math.round(secondPercent * 2);\n+        long n3 = Math.round(thirdPercent * 2);\n+        long n4 = Math.round(fourthPercent * 2);\n+\n+        return String.format(\"OY%03d%03d%03d%03d%03d\", n1, n2, n3, n4, timeToRampValue(rampMs));\n+    }\n+\n+    /**\n+     * Generates a control command for switching all outputs ON or OFF with a fixed ramp of 0.5s.\n+     *\n+     * @param percent 0..100\n+     * @returnthe PCK command (without address header) as text\n+     */\n+    public static String controlAllOutputs(double percent) {\n+        return String.format(\"AH%03d\", Math.round(percent));\n+    }\n+\n+    /**\n+     * Generates a control command for switching dimmer output 1 and 2 both ON or OFF with a fixed ramp of 0.5s or\n+     * without ramp.\n+     *\n+     * @param on true, if outputs shall be switched on\n+     * @param ramp true, if the ramp shall be 0.5s, else 0s\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String controlOutputs12(boolean on, boolean ramp) {\n+        int commandByte;\n+        if (on) {\n+            commandByte = ramp ? 0xC8 : 0xFD;\n+        } else {\n+            commandByte = ramp ? 0x00 : 0xFC;\n+        }\n+        return String.format(\"X2%03d%03d%03d\", 1, commandByte, commandByte);\n+    }\n+\n+    /**\n+     * Generates a dim command for setting the brightness of dimmer output 1 and 2 with a fixed ramp of 0.5s.\n+     *\n+     * @param percent brightness of both outputs 0..100\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String dimOutputs12(double percent) {\n+        long localPercent = Math.round(percent);\n+        return String.format(\"AY%03d%03d\", localPercent, localPercent);\n+    }\n+\n+    /**\n+     * Let an output flicker.\n+     *\n+     * @param outputId output id 0..3\n+     * @param depth flicker depth, the higher the deeper 0..2\n+     * @param ramp the flicker speed 0..2\n+     * @param count number of flashes 1..15\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException when the input values are out of range\n+     */\n+    public static String flickerOutput(int outputId, int depth, int ramp, int count) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException(\"Output number out of range\");\n+        }\n+        if (count < 1 || count > 15) {\n+            throw new LcnException(\"Number of flashes out of range\");\n+        }\n+        String depthString;\n+        switch (depth) {\n+            case 0:\n+                depthString = \"G\";\n+                break;\n+            case 1:\n+                depthString = \"M\";\n+                break;\n+            case 2:\n+                depthString = \"S\";\n+                break;\n+            default:\n+                throw new LcnException(\"Depth out of range\");\n+        }\n+        String rampString;\n+        switch (ramp) {\n+            case 0:\n+                rampString = \"L\";\n+                break;\n+            case 1:\n+                rampString = \"M\";\n+                break;\n+            case 2:\n+                rampString = \"S\";\n+                break;\n+            default:\n+                throw new LcnException(\"Ramp out of range\");\n+        }\n+        return String.format(\"A%dFL%s%s%02d\", outputId + 1, depthString, rampString, count);\n+    }\n+\n+    /**\n+     * Generates a command to change the value of an output-port.\n+     *\n+     * @param outputId 0..3\n+     * @param percent -100..100\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String relOutput(int outputId, double percent) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        int n = (int) Math.round(percent * 2);\n+        if ((n % 2) == 0) { // Use the percent command (supported by all LCN-PCHK versions)\n+            return String.format(\"A%d%s%03d\", outputId + 1, percent >= 0 ? \"AD\" : \"SB\", Math.abs(n / 2));\n+        } else { // We have a \".5\" value. Use the native command (supported since LCN-PCHK 2.3)\n+            return String.format(\"O%d%s%03d\", outputId + 1, percent >= 0 ? \"AD\" : \"SB\", Math.abs(n));\n+        }\n+    }\n+\n+    /**\n+     * Generates a command that toggles a single output-port (on->off, off->on).\n+     *\n+     * @param outputId 0..3\n+     * @param ramp see {@link PckGenerator#timeToRampValue(int)}\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String toggleOutput(int outputId, int ramp) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"A%dTA%03d\", outputId + 1, ramp);\n+    }\n+\n+    /**\n+     * Generates a command that toggles all output-ports (on->off, off->on).\n+     *\n+     * @param ramp see {@link PckGenerator#timeToRampValue(int)}\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String toggleAllOutputs(int ramp) {\n+        return String.format(\"AU%03d\", ramp);\n+    }\n+\n+    /**\n+     * Generates a relays-status request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestRelaysStatus() {\n+        return \"SMR\";\n+    }\n+\n+    /**\n+     * Generates a command to control relays.\n+     *\n+     * @param states the 8 modifiers for the relay states\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String controlRelays(LcnDefs.RelayStateModifier[] states) throws LcnException {\n+        if (states.length != 8) {\n+            throw new LcnException();\n+        }\n+        String ret = \"R8\";\n+        for (int i = 0; i < 8; ++i) {\n+            switch (states[i]) {\n+                case ON:\n+                    ret += \"1\";\n+                    break;\n+                case OFF:\n+                    ret += \"0\";\n+                    break;\n+                case TOGGLE:\n+                    ret += \"U\";\n+                    break;\n+                case NOCHANGE:\n+                    ret += \"-\";\n+                    break;\n+                default:\n+                    throw new LcnException();\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Generates a binary-sensors status request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestBinSensorsStatus() {\n+        return \"SMB\";\n+    }\n+\n+    /**\n+     * Generates a command that sets a variable absolute.\n+     *\n+     * @param number regulator number 0..1\n+     * @param value the absolute value to set\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException\n+     */\n+    public static String setSetpointAbsolute(int number, int value) {\n+        int internalValue = value;\n+        // Set absolute (not in PCK yet)\n+        int b1 = number << 6; // 01000000\n+        b1 |= 0x20; // xx10xxxx (set absolute)\n+        if (value < 1000) {\n+            internalValue = 1000 - internalValue;\n+            b1 |= 8;\n+        } else {\n+            internalValue -= 1000;\n+        }\n+        b1 |= (internalValue >> 8) & 0x0f; // xxxx1111\n+        int b2 = internalValue & 0xff;\n+        return String.format(\"X2%03d%03d%03d\", 30, b1, b2);\n+    }\n+\n+    /**\n+     * Generates a command to change the value of a variable.\n+     *\n+     * @param variable the target variable to change\n+     * @param type the reference-point\n+     * @param value the native LCN value to add/subtract (can be negative)\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if command is not supported\n+     */\n+    public static String setVariableRelative(Variable variable, LcnDefs.RelVarRef type, int value) {\n+        if (variable.getNumber() == 0) {\n+            // Old command for variable 1 / T-var (compatible with all modules)\n+            return String.format(\"Z%s%d\", value >= 0 ? \"A\" : \"S\", Math.abs(value));\n+        } else { // New command for variable 1-12 (compatible with all modules, since LCN-PCHK 2.8)\n+            return String.format(\"Z%s%03d%d\", value >= 0 ? \"+\" : \"-\", variable.getNumber() + 1, Math.abs(value));\n+        }\n+    }\n+\n+    /**\n+     * Generates a command the change the value of a regulator setpoint relative.\n+     *\n+     * @param number 0..1\n+     * @param type relative to the current or to the programmed value\n+     * @param value the relative value -4000..+4000\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String setSetpointRelative(int number, LcnDefs.RelVarRef type, int value) {\n+        return String.format(\"RE%sS%s%s%d\", number == 0 ? \"A\" : \"B\", type == LcnDefs.RelVarRef.CURRENT ? \"A\" : \"P\",\n+                value >= 0 ? \"+\" : \"-\", Math.abs(value));\n+    }\n+\n+    /**\n+     * Generates a command the change the value of a threshold relative.\n+     *\n+     * @param variable the threshold to change\n+     * @param type relative to the current or to the programmed value\n+     * @param value the relative value -4000..+4000\n+     * @param is2013 true, if the LCN module's firmware is equal to or newer than 2013\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String setThresholdRelative(Variable variable, LcnDefs.RelVarRef type, int value, boolean is2013)\n+            throws LcnException {\n+        if (is2013) { // New command for registers 1-4 (since 170206, LCN-PCHK 2.8)\n+            return String.format(\"SS%s%04d%sR%d%d\", type == LcnDefs.RelVarRef.CURRENT ? \"R\" : \"E\", Math.abs(value),\n+                    value >= 0 ? \"A\" : \"S\", variable.getNumber() + 1, variable.getThresholdNumber().get() + 1);\n+        } else if (variable.getNumber() == 0) { // Old command for register 1 (before 170206)\n+            return String.format(\"SS%s%04d%s%s%s%s%s%s\", type == LcnDefs.RelVarRef.CURRENT ? \"R\" : \"E\", Math.abs(value),\n+                    value >= 0 ? \"A\" : \"S\", variable.getThresholdNumber().get() == 0 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 1 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 2 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 3 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 4 ? \"1\" : \"0\");\n+        } else {\n+            throw new LcnException(\n+                    \"Module does not have threshold register \" + (variable.getThresholdNumber().get() + 1));\n+        }\n+    }\n+\n+    /**\n+     * Generates a variable value request.\n+     *\n+     * @param variable the variable to request\n+     * @param firmwareVersion the target module's firmware version\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if command is not supported\n+     */\n+    public static String requestVarStatus(Variable variable, int firmwareVersion) throws LcnException {\n+        if (firmwareVersion >= LcnBindingConstants.FIRMWARE_2013) {\n+            int id = variable.getNumber();\n+            switch (variable.getType()) {\n+                case UNKNOWN:\n+                    throw new LcnException(\"Variable unknown\");\n+                case VARIABLE:\n+                    return String.format(\"MWT%03d\", id + 1);\n+                case REGULATOR:\n+                    return String.format(\"MWS%03d\", id + 1);\n+                case THRESHOLD:\n+                    return String.format(\"SE%03d\", id + 1); // Whole register\n+                case S0INPUT:\n+                    return String.format(\"MWC%03d\", id + 1);\n+            }\n+            throw new LcnException(\"Unsupported variable type: \" + variable);\n+        } else {\n+            switch (variable) {\n+                case VARIABLE1:\n+                    return \"MWV\";\n+                case VARIABLE2:\n+                    return \"MWTA\";\n+                case VARIABLE3:\n+                    return \"MWTB\";\n+                case RVARSETPOINT1:\n+                    return \"MWSA\";\n+                case RVARSETPOINT2:\n+                    return \"MWSB\";\n+                case THRESHOLDREGISTER11:\n+                case THRESHOLDREGISTER12:\n+                case THRESHOLDREGISTER13:\n+                case THRESHOLDREGISTER14:\n+                case THRESHOLDREGISTER15:\n+                    return \"SL1\"; // Whole register\n+                default:\n+                    throw new LcnException(\"Unsupported variable type: \" + variable);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates a request for LED and logic-operations states.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestLedsAndLogicOpsStatus() {\n+        return \"SMT\";\n+    }\n+\n+    /**\n+     * Generates a command to the set the state of a single LED.\n+     *\n+     * @param ledId 0..11\n+     * @param state the state to set\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String controlLed(int ledId, LcnDefs.LedStatus state) throws LcnException {\n+        if (ledId < 0 || ledId > 11) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"LA%03d%s\", ledId + 1, state == LcnDefs.LedStatus.OFF ? \"A\"\n+                : state == LcnDefs.LedStatus.ON ? \"E\" : state == LcnDefs.LedStatus.BLINK ? \"B\" : \"F\");\n+    }\n+\n+    /**\n+     * Generates a command to send LCN keys.\n+     *\n+     * @param cmds the 4 concrete commands to send for the tables (A-D)\n+     * @param keys the tables' 8 key-states (true means \"send\")\n+     * @return the PCK command (without address header) as text\n+     * @throws IllegalArgumentException if out of range\n+     */\n+    public static String sendKeys(LcnDefs.SendKeyCommand[] cmds, boolean[] keys) throws LcnException {\n+        if (cmds.length != 4 || keys.length != 8) {\n+            throw new LcnException();\n+        }\n+        String ret = \"TS\";", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4ODM0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436888348", "bodyText": "here too", "author": "cpmeister", "createdAt": "2020-06-08T17:52:38Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/PckGenerator.java", "diffHunk": "@@ -0,0 +1,779 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Helpers to generate LCN-PCK commands.\n+ * <p>\n+ * LCN-PCK is the command-syntax used by LCN-PCHK to send and receive LCN commands.\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public final class PckGenerator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PckGenerator.class);\n+    /** Termination character after a PCK message */\n+    public static final String TERMINATION = \"\\n\";\n+\n+    /**\n+     * Generates a keep-alive.\n+     * LCN-PCHK will close the connection if it does not receive any commands from\n+     * an open {@link Connection} for a specific period (10 minutes by default).\n+     *\n+     * @param counter the current ping's id (optional, but \"best practice\"). Should start with 1\n+     * @return the PCK command as text\n+     */\n+    public static String ping(int counter) {\n+        return String.format(\"^ping%d\", counter);\n+    }\n+\n+    /**\n+     * Generates a PCK command that will set the LCN-PCHK connection's operation mode.\n+     * This influences how output-port commands and status are interpreted and must be\n+     * in sync with the LCN bus.\n+     *\n+     * @param dimMode see {@link LcnDefs.OutputPortDimMode}\n+     * @param statusMode see {@link LcnDefs.OutputPortStatusMode}\n+     * @return the PCK command as text\n+     */\n+    public static String setOperationMode(LcnDefs.OutputPortDimMode dimMode, LcnDefs.OutputPortStatusMode statusMode) {\n+        return \"!OM\" + (dimMode == LcnDefs.OutputPortDimMode.NATIVE200 ? \"1\" : \"0\")\n+                + (statusMode == LcnDefs.OutputPortStatusMode.PERCENT ? \"P\" : \"N\");\n+    }\n+\n+    /**\n+     * Generates a PCK address header.\n+     * Used for commands to LCN modules and groups.\n+     *\n+     * @param addr the target's address (module or group)\n+     * @param localSegId the local segment id where the physical bus connection is located\n+     * @param wantsAck true to claim an acknowledge / receipt from the target\n+     * @return the PCK address header as text\n+     */\n+    public static String generateAddressHeader(LcnAddr addr, int localSegId, boolean wantsAck) {\n+        return String.format(\">%s%03d%03d%s\", addr.isGroup() ? \"G\" : \"M\", addr.getPhysicalSegmentId(localSegId),\n+                addr.getId(), wantsAck ? \"!\" : \".\");\n+    }\n+\n+    /**\n+     * Generates a scan-command for LCN segment-couplers.\n+     * Used to detect the local segment (where the physical bus connection is located).\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String segmentCouplerScan() {\n+        return \"SK\";\n+    }\n+\n+    /**\n+     * Generates a firmware/serial-number request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestSn() {\n+        return \"SN\";\n+    }\n+\n+    /**\n+     * Generates a command to request a part of a name of a module.\n+     *\n+     * @param partNumber 0..1\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestModuleName(int partNumber) {\n+        return \"NMN\" + (partNumber + 1);\n+    }\n+\n+    /**\n+     * Generates an output-port status request.\n+     *\n+     * @param outputId 0..3\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String requestOutputStatus(int outputId) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"SMA%d\", outputId + 1);\n+    }\n+\n+    /**\n+     * Generates a dim command for a single output-port.\n+     *\n+     * @param outputId 0..3\n+     * @param percent 0..100\n+     * @param rampMs ramp in milliseconds\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String dimOutput(int outputId, double percent, int rampMs) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        int rampNative = PckGenerator.timeToRampValue(rampMs);\n+        int n = (int) Math.round(percent * 2);\n+        if ((n % 2) == 0) { // Use the percent command (supported by all LCN-PCHK versions)\n+            return String.format(\"A%dDI%03d%03d\", outputId + 1, n / 2, rampNative);\n+        } else { // We have a \".5\" value. Use the native command (supported since LCN-PCHK 2.3)\n+            return String.format(\"O%dDI%03d%03d\", outputId + 1, n, rampNative);\n+        }\n+    }\n+\n+    /**\n+     * Generates a dim command for all output-ports.\n+     *\n+     * Attention: This command is supported since module firmware version 180501 AND LCN-PCHK 2.61\n+     *\n+     * @param firstPercent dimmer value of the first output 0..100\n+     * @param secondPercent dimmer value of the first output 0..100\n+     * @param thirdPercent dimmer value of the first output 0..100\n+     * @param fourthPercent dimmer value of the first output 0..100\n+     * @param rampMs ramp in milliseconds\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String dimAllOutputs(double firstPercent, double secondPercent, double thirdPercent,\n+            double fourthPercent, int rampMs) {\n+        long n1 = Math.round(firstPercent * 2);\n+        long n2 = Math.round(secondPercent * 2);\n+        long n3 = Math.round(thirdPercent * 2);\n+        long n4 = Math.round(fourthPercent * 2);\n+\n+        return String.format(\"OY%03d%03d%03d%03d%03d\", n1, n2, n3, n4, timeToRampValue(rampMs));\n+    }\n+\n+    /**\n+     * Generates a control command for switching all outputs ON or OFF with a fixed ramp of 0.5s.\n+     *\n+     * @param percent 0..100\n+     * @returnthe PCK command (without address header) as text\n+     */\n+    public static String controlAllOutputs(double percent) {\n+        return String.format(\"AH%03d\", Math.round(percent));\n+    }\n+\n+    /**\n+     * Generates a control command for switching dimmer output 1 and 2 both ON or OFF with a fixed ramp of 0.5s or\n+     * without ramp.\n+     *\n+     * @param on true, if outputs shall be switched on\n+     * @param ramp true, if the ramp shall be 0.5s, else 0s\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String controlOutputs12(boolean on, boolean ramp) {\n+        int commandByte;\n+        if (on) {\n+            commandByte = ramp ? 0xC8 : 0xFD;\n+        } else {\n+            commandByte = ramp ? 0x00 : 0xFC;\n+        }\n+        return String.format(\"X2%03d%03d%03d\", 1, commandByte, commandByte);\n+    }\n+\n+    /**\n+     * Generates a dim command for setting the brightness of dimmer output 1 and 2 with a fixed ramp of 0.5s.\n+     *\n+     * @param percent brightness of both outputs 0..100\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String dimOutputs12(double percent) {\n+        long localPercent = Math.round(percent);\n+        return String.format(\"AY%03d%03d\", localPercent, localPercent);\n+    }\n+\n+    /**\n+     * Let an output flicker.\n+     *\n+     * @param outputId output id 0..3\n+     * @param depth flicker depth, the higher the deeper 0..2\n+     * @param ramp the flicker speed 0..2\n+     * @param count number of flashes 1..15\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException when the input values are out of range\n+     */\n+    public static String flickerOutput(int outputId, int depth, int ramp, int count) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException(\"Output number out of range\");\n+        }\n+        if (count < 1 || count > 15) {\n+            throw new LcnException(\"Number of flashes out of range\");\n+        }\n+        String depthString;\n+        switch (depth) {\n+            case 0:\n+                depthString = \"G\";\n+                break;\n+            case 1:\n+                depthString = \"M\";\n+                break;\n+            case 2:\n+                depthString = \"S\";\n+                break;\n+            default:\n+                throw new LcnException(\"Depth out of range\");\n+        }\n+        String rampString;\n+        switch (ramp) {\n+            case 0:\n+                rampString = \"L\";\n+                break;\n+            case 1:\n+                rampString = \"M\";\n+                break;\n+            case 2:\n+                rampString = \"S\";\n+                break;\n+            default:\n+                throw new LcnException(\"Ramp out of range\");\n+        }\n+        return String.format(\"A%dFL%s%s%02d\", outputId + 1, depthString, rampString, count);\n+    }\n+\n+    /**\n+     * Generates a command to change the value of an output-port.\n+     *\n+     * @param outputId 0..3\n+     * @param percent -100..100\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String relOutput(int outputId, double percent) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        int n = (int) Math.round(percent * 2);\n+        if ((n % 2) == 0) { // Use the percent command (supported by all LCN-PCHK versions)\n+            return String.format(\"A%d%s%03d\", outputId + 1, percent >= 0 ? \"AD\" : \"SB\", Math.abs(n / 2));\n+        } else { // We have a \".5\" value. Use the native command (supported since LCN-PCHK 2.3)\n+            return String.format(\"O%d%s%03d\", outputId + 1, percent >= 0 ? \"AD\" : \"SB\", Math.abs(n));\n+        }\n+    }\n+\n+    /**\n+     * Generates a command that toggles a single output-port (on->off, off->on).\n+     *\n+     * @param outputId 0..3\n+     * @param ramp see {@link PckGenerator#timeToRampValue(int)}\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String toggleOutput(int outputId, int ramp) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"A%dTA%03d\", outputId + 1, ramp);\n+    }\n+\n+    /**\n+     * Generates a command that toggles all output-ports (on->off, off->on).\n+     *\n+     * @param ramp see {@link PckGenerator#timeToRampValue(int)}\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String toggleAllOutputs(int ramp) {\n+        return String.format(\"AU%03d\", ramp);\n+    }\n+\n+    /**\n+     * Generates a relays-status request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestRelaysStatus() {\n+        return \"SMR\";\n+    }\n+\n+    /**\n+     * Generates a command to control relays.\n+     *\n+     * @param states the 8 modifiers for the relay states\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String controlRelays(LcnDefs.RelayStateModifier[] states) throws LcnException {\n+        if (states.length != 8) {\n+            throw new LcnException();\n+        }\n+        String ret = \"R8\";\n+        for (int i = 0; i < 8; ++i) {\n+            switch (states[i]) {\n+                case ON:\n+                    ret += \"1\";\n+                    break;\n+                case OFF:\n+                    ret += \"0\";\n+                    break;\n+                case TOGGLE:\n+                    ret += \"U\";\n+                    break;\n+                case NOCHANGE:\n+                    ret += \"-\";\n+                    break;\n+                default:\n+                    throw new LcnException();\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Generates a binary-sensors status request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestBinSensorsStatus() {\n+        return \"SMB\";\n+    }\n+\n+    /**\n+     * Generates a command that sets a variable absolute.\n+     *\n+     * @param number regulator number 0..1\n+     * @param value the absolute value to set\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException\n+     */\n+    public static String setSetpointAbsolute(int number, int value) {\n+        int internalValue = value;\n+        // Set absolute (not in PCK yet)\n+        int b1 = number << 6; // 01000000\n+        b1 |= 0x20; // xx10xxxx (set absolute)\n+        if (value < 1000) {\n+            internalValue = 1000 - internalValue;\n+            b1 |= 8;\n+        } else {\n+            internalValue -= 1000;\n+        }\n+        b1 |= (internalValue >> 8) & 0x0f; // xxxx1111\n+        int b2 = internalValue & 0xff;\n+        return String.format(\"X2%03d%03d%03d\", 30, b1, b2);\n+    }\n+\n+    /**\n+     * Generates a command to change the value of a variable.\n+     *\n+     * @param variable the target variable to change\n+     * @param type the reference-point\n+     * @param value the native LCN value to add/subtract (can be negative)\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if command is not supported\n+     */\n+    public static String setVariableRelative(Variable variable, LcnDefs.RelVarRef type, int value) {\n+        if (variable.getNumber() == 0) {\n+            // Old command for variable 1 / T-var (compatible with all modules)\n+            return String.format(\"Z%s%d\", value >= 0 ? \"A\" : \"S\", Math.abs(value));\n+        } else { // New command for variable 1-12 (compatible with all modules, since LCN-PCHK 2.8)\n+            return String.format(\"Z%s%03d%d\", value >= 0 ? \"+\" : \"-\", variable.getNumber() + 1, Math.abs(value));\n+        }\n+    }\n+\n+    /**\n+     * Generates a command the change the value of a regulator setpoint relative.\n+     *\n+     * @param number 0..1\n+     * @param type relative to the current or to the programmed value\n+     * @param value the relative value -4000..+4000\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String setSetpointRelative(int number, LcnDefs.RelVarRef type, int value) {\n+        return String.format(\"RE%sS%s%s%d\", number == 0 ? \"A\" : \"B\", type == LcnDefs.RelVarRef.CURRENT ? \"A\" : \"P\",\n+                value >= 0 ? \"+\" : \"-\", Math.abs(value));\n+    }\n+\n+    /**\n+     * Generates a command the change the value of a threshold relative.\n+     *\n+     * @param variable the threshold to change\n+     * @param type relative to the current or to the programmed value\n+     * @param value the relative value -4000..+4000\n+     * @param is2013 true, if the LCN module's firmware is equal to or newer than 2013\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String setThresholdRelative(Variable variable, LcnDefs.RelVarRef type, int value, boolean is2013)\n+            throws LcnException {\n+        if (is2013) { // New command for registers 1-4 (since 170206, LCN-PCHK 2.8)\n+            return String.format(\"SS%s%04d%sR%d%d\", type == LcnDefs.RelVarRef.CURRENT ? \"R\" : \"E\", Math.abs(value),\n+                    value >= 0 ? \"A\" : \"S\", variable.getNumber() + 1, variable.getThresholdNumber().get() + 1);\n+        } else if (variable.getNumber() == 0) { // Old command for register 1 (before 170206)\n+            return String.format(\"SS%s%04d%s%s%s%s%s%s\", type == LcnDefs.RelVarRef.CURRENT ? \"R\" : \"E\", Math.abs(value),\n+                    value >= 0 ? \"A\" : \"S\", variable.getThresholdNumber().get() == 0 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 1 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 2 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 3 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 4 ? \"1\" : \"0\");\n+        } else {\n+            throw new LcnException(\n+                    \"Module does not have threshold register \" + (variable.getThresholdNumber().get() + 1));\n+        }\n+    }\n+\n+    /**\n+     * Generates a variable value request.\n+     *\n+     * @param variable the variable to request\n+     * @param firmwareVersion the target module's firmware version\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if command is not supported\n+     */\n+    public static String requestVarStatus(Variable variable, int firmwareVersion) throws LcnException {\n+        if (firmwareVersion >= LcnBindingConstants.FIRMWARE_2013) {\n+            int id = variable.getNumber();\n+            switch (variable.getType()) {\n+                case UNKNOWN:\n+                    throw new LcnException(\"Variable unknown\");\n+                case VARIABLE:\n+                    return String.format(\"MWT%03d\", id + 1);\n+                case REGULATOR:\n+                    return String.format(\"MWS%03d\", id + 1);\n+                case THRESHOLD:\n+                    return String.format(\"SE%03d\", id + 1); // Whole register\n+                case S0INPUT:\n+                    return String.format(\"MWC%03d\", id + 1);\n+            }\n+            throw new LcnException(\"Unsupported variable type: \" + variable);\n+        } else {\n+            switch (variable) {\n+                case VARIABLE1:\n+                    return \"MWV\";\n+                case VARIABLE2:\n+                    return \"MWTA\";\n+                case VARIABLE3:\n+                    return \"MWTB\";\n+                case RVARSETPOINT1:\n+                    return \"MWSA\";\n+                case RVARSETPOINT2:\n+                    return \"MWSB\";\n+                case THRESHOLDREGISTER11:\n+                case THRESHOLDREGISTER12:\n+                case THRESHOLDREGISTER13:\n+                case THRESHOLDREGISTER14:\n+                case THRESHOLDREGISTER15:\n+                    return \"SL1\"; // Whole register\n+                default:\n+                    throw new LcnException(\"Unsupported variable type: \" + variable);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates a request for LED and logic-operations states.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestLedsAndLogicOpsStatus() {\n+        return \"SMT\";\n+    }\n+\n+    /**\n+     * Generates a command to the set the state of a single LED.\n+     *\n+     * @param ledId 0..11\n+     * @param state the state to set\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String controlLed(int ledId, LcnDefs.LedStatus state) throws LcnException {\n+        if (ledId < 0 || ledId > 11) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"LA%03d%s\", ledId + 1, state == LcnDefs.LedStatus.OFF ? \"A\"\n+                : state == LcnDefs.LedStatus.ON ? \"E\" : state == LcnDefs.LedStatus.BLINK ? \"B\" : \"F\");\n+    }\n+\n+    /**\n+     * Generates a command to send LCN keys.\n+     *\n+     * @param cmds the 4 concrete commands to send for the tables (A-D)\n+     * @param keys the tables' 8 key-states (true means \"send\")\n+     * @return the PCK command (without address header) as text\n+     * @throws IllegalArgumentException if out of range\n+     */\n+    public static String sendKeys(LcnDefs.SendKeyCommand[] cmds, boolean[] keys) throws LcnException {\n+        if (cmds.length != 4 || keys.length != 8) {\n+            throw new LcnException();\n+        }\n+        String ret = \"TS\";\n+        for (int i = 0; i < 4; ++i) {\n+            switch (cmds[i]) {\n+                case HIT:\n+                    ret += \"K\";\n+                    break;\n+                case MAKE:\n+                    ret += \"L\";\n+                    break;\n+                case BREAK:\n+                    ret += \"O\";\n+                    break;\n+                case DONTSEND:\n+                    // By skipping table D (if it is not used), we use the old command\n+                    // for table A-C which is compatible with older LCN modules\n+                    if (i < 3) {\n+                        ret += \"-\";\n+                    }\n+                    break;\n+                default:\n+                    throw new LcnException();\n+            }\n+        }\n+        for (int i = 0; i < 8; ++i) {\n+            ret += keys[i] ? \"1\" : \"0\";\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Generates a command to send LCN keys deferred / delayed.\n+     *\n+     * @param tableId 0(A)..3(D)\n+     * @param time the delay time\n+     * @param timeUnit the time unit\n+     * @param keys the key-states (true means \"send\")\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String sendKeysHitDefered(int tableId, int time, LcnDefs.TimeUnit timeUnit, boolean[] keys)\n+            throws LcnException {\n+        if (tableId < 0 || tableId > 3 || keys.length != 8) {\n+            throw new IllegalArgumentException();\n+        }\n+        String ret = \"TV\";\n+        switch (tableId) {\n+            case 0:\n+                ret += \"A\";\n+                break;\n+            case 1:\n+                ret += \"B\";\n+                break;\n+            case 2:\n+                ret += \"C\";\n+                break;\n+            case 3:\n+                ret += \"D\";\n+                break;\n+            default:\n+                throw new LcnException();\n+        }\n+        ret += String.format(\"%03d\", time);\n+        switch (timeUnit) {\n+            case SECONDS:\n+                if (time < 1 || time > 60) {\n+                    throw new LcnException();\n+                }\n+                ret += \"S\";\n+                break;\n+            case MINUTES:\n+                if (time < 1 || time > 90) {\n+                    throw new LcnException();\n+                }\n+                ret += \"M\";\n+                break;\n+            case HOURS:\n+                if (time < 1 || time > 50) {\n+                    throw new LcnException();\n+                }\n+                ret += \"H\";\n+                break;\n+            case DAYS:\n+                if (time < 1 || time > 45) {\n+                    throw new LcnException();\n+                }\n+                ret += \"D\";\n+                break;\n+            default:\n+                throw new LcnException();\n+        }\n+        for (int i = 0; i < 8; ++i) {\n+            ret += keys[i] ? \"1\" : \"0\";\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Generates a request for key-lock states.\n+     * Always requests table A-D. Supported since LCN-PCHK 2.8.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestKeyLocksStatus() {\n+        return \"STX\";\n+    }\n+\n+    /**\n+     * Generates a command to lock keys.\n+     *\n+     * @param tableId 0(A)..3(D)\n+     * @param states the 8 key-lock modifiers\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String lockKeys(int tableId, LcnDefs.KeyLockStateModifier[] states) throws LcnException {\n+        if (tableId < 0 || tableId > 3 || states.length != 8) {\n+            throw new LcnException();\n+        }\n+        String ret = String.format(\"TX%s\", tableId == 0 ? \"A\" : tableId == 1 ? \"B\" : tableId == 2 ? \"C\" : \"D\");\n+        for (int i = 0; i < 8; ++i) {\n+            switch (states[i]) {\n+                case ON:\n+                    ret += \"1\";", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4ODU5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436888596", "bodyText": "and here", "author": "cpmeister", "createdAt": "2020-06-08T17:53:05Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/PckGenerator.java", "diffHunk": "@@ -0,0 +1,779 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Helpers to generate LCN-PCK commands.\n+ * <p>\n+ * LCN-PCK is the command-syntax used by LCN-PCHK to send and receive LCN commands.\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public final class PckGenerator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PckGenerator.class);\n+    /** Termination character after a PCK message */\n+    public static final String TERMINATION = \"\\n\";\n+\n+    /**\n+     * Generates a keep-alive.\n+     * LCN-PCHK will close the connection if it does not receive any commands from\n+     * an open {@link Connection} for a specific period (10 minutes by default).\n+     *\n+     * @param counter the current ping's id (optional, but \"best practice\"). Should start with 1\n+     * @return the PCK command as text\n+     */\n+    public static String ping(int counter) {\n+        return String.format(\"^ping%d\", counter);\n+    }\n+\n+    /**\n+     * Generates a PCK command that will set the LCN-PCHK connection's operation mode.\n+     * This influences how output-port commands and status are interpreted and must be\n+     * in sync with the LCN bus.\n+     *\n+     * @param dimMode see {@link LcnDefs.OutputPortDimMode}\n+     * @param statusMode see {@link LcnDefs.OutputPortStatusMode}\n+     * @return the PCK command as text\n+     */\n+    public static String setOperationMode(LcnDefs.OutputPortDimMode dimMode, LcnDefs.OutputPortStatusMode statusMode) {\n+        return \"!OM\" + (dimMode == LcnDefs.OutputPortDimMode.NATIVE200 ? \"1\" : \"0\")\n+                + (statusMode == LcnDefs.OutputPortStatusMode.PERCENT ? \"P\" : \"N\");\n+    }\n+\n+    /**\n+     * Generates a PCK address header.\n+     * Used for commands to LCN modules and groups.\n+     *\n+     * @param addr the target's address (module or group)\n+     * @param localSegId the local segment id where the physical bus connection is located\n+     * @param wantsAck true to claim an acknowledge / receipt from the target\n+     * @return the PCK address header as text\n+     */\n+    public static String generateAddressHeader(LcnAddr addr, int localSegId, boolean wantsAck) {\n+        return String.format(\">%s%03d%03d%s\", addr.isGroup() ? \"G\" : \"M\", addr.getPhysicalSegmentId(localSegId),\n+                addr.getId(), wantsAck ? \"!\" : \".\");\n+    }\n+\n+    /**\n+     * Generates a scan-command for LCN segment-couplers.\n+     * Used to detect the local segment (where the physical bus connection is located).\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String segmentCouplerScan() {\n+        return \"SK\";\n+    }\n+\n+    /**\n+     * Generates a firmware/serial-number request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestSn() {\n+        return \"SN\";\n+    }\n+\n+    /**\n+     * Generates a command to request a part of a name of a module.\n+     *\n+     * @param partNumber 0..1\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestModuleName(int partNumber) {\n+        return \"NMN\" + (partNumber + 1);\n+    }\n+\n+    /**\n+     * Generates an output-port status request.\n+     *\n+     * @param outputId 0..3\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String requestOutputStatus(int outputId) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"SMA%d\", outputId + 1);\n+    }\n+\n+    /**\n+     * Generates a dim command for a single output-port.\n+     *\n+     * @param outputId 0..3\n+     * @param percent 0..100\n+     * @param rampMs ramp in milliseconds\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String dimOutput(int outputId, double percent, int rampMs) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        int rampNative = PckGenerator.timeToRampValue(rampMs);\n+        int n = (int) Math.round(percent * 2);\n+        if ((n % 2) == 0) { // Use the percent command (supported by all LCN-PCHK versions)\n+            return String.format(\"A%dDI%03d%03d\", outputId + 1, n / 2, rampNative);\n+        } else { // We have a \".5\" value. Use the native command (supported since LCN-PCHK 2.3)\n+            return String.format(\"O%dDI%03d%03d\", outputId + 1, n, rampNative);\n+        }\n+    }\n+\n+    /**\n+     * Generates a dim command for all output-ports.\n+     *\n+     * Attention: This command is supported since module firmware version 180501 AND LCN-PCHK 2.61\n+     *\n+     * @param firstPercent dimmer value of the first output 0..100\n+     * @param secondPercent dimmer value of the first output 0..100\n+     * @param thirdPercent dimmer value of the first output 0..100\n+     * @param fourthPercent dimmer value of the first output 0..100\n+     * @param rampMs ramp in milliseconds\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String dimAllOutputs(double firstPercent, double secondPercent, double thirdPercent,\n+            double fourthPercent, int rampMs) {\n+        long n1 = Math.round(firstPercent * 2);\n+        long n2 = Math.round(secondPercent * 2);\n+        long n3 = Math.round(thirdPercent * 2);\n+        long n4 = Math.round(fourthPercent * 2);\n+\n+        return String.format(\"OY%03d%03d%03d%03d%03d\", n1, n2, n3, n4, timeToRampValue(rampMs));\n+    }\n+\n+    /**\n+     * Generates a control command for switching all outputs ON or OFF with a fixed ramp of 0.5s.\n+     *\n+     * @param percent 0..100\n+     * @returnthe PCK command (without address header) as text\n+     */\n+    public static String controlAllOutputs(double percent) {\n+        return String.format(\"AH%03d\", Math.round(percent));\n+    }\n+\n+    /**\n+     * Generates a control command for switching dimmer output 1 and 2 both ON or OFF with a fixed ramp of 0.5s or\n+     * without ramp.\n+     *\n+     * @param on true, if outputs shall be switched on\n+     * @param ramp true, if the ramp shall be 0.5s, else 0s\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String controlOutputs12(boolean on, boolean ramp) {\n+        int commandByte;\n+        if (on) {\n+            commandByte = ramp ? 0xC8 : 0xFD;\n+        } else {\n+            commandByte = ramp ? 0x00 : 0xFC;\n+        }\n+        return String.format(\"X2%03d%03d%03d\", 1, commandByte, commandByte);\n+    }\n+\n+    /**\n+     * Generates a dim command for setting the brightness of dimmer output 1 and 2 with a fixed ramp of 0.5s.\n+     *\n+     * @param percent brightness of both outputs 0..100\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String dimOutputs12(double percent) {\n+        long localPercent = Math.round(percent);\n+        return String.format(\"AY%03d%03d\", localPercent, localPercent);\n+    }\n+\n+    /**\n+     * Let an output flicker.\n+     *\n+     * @param outputId output id 0..3\n+     * @param depth flicker depth, the higher the deeper 0..2\n+     * @param ramp the flicker speed 0..2\n+     * @param count number of flashes 1..15\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException when the input values are out of range\n+     */\n+    public static String flickerOutput(int outputId, int depth, int ramp, int count) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException(\"Output number out of range\");\n+        }\n+        if (count < 1 || count > 15) {\n+            throw new LcnException(\"Number of flashes out of range\");\n+        }\n+        String depthString;\n+        switch (depth) {\n+            case 0:\n+                depthString = \"G\";\n+                break;\n+            case 1:\n+                depthString = \"M\";\n+                break;\n+            case 2:\n+                depthString = \"S\";\n+                break;\n+            default:\n+                throw new LcnException(\"Depth out of range\");\n+        }\n+        String rampString;\n+        switch (ramp) {\n+            case 0:\n+                rampString = \"L\";\n+                break;\n+            case 1:\n+                rampString = \"M\";\n+                break;\n+            case 2:\n+                rampString = \"S\";\n+                break;\n+            default:\n+                throw new LcnException(\"Ramp out of range\");\n+        }\n+        return String.format(\"A%dFL%s%s%02d\", outputId + 1, depthString, rampString, count);\n+    }\n+\n+    /**\n+     * Generates a command to change the value of an output-port.\n+     *\n+     * @param outputId 0..3\n+     * @param percent -100..100\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String relOutput(int outputId, double percent) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        int n = (int) Math.round(percent * 2);\n+        if ((n % 2) == 0) { // Use the percent command (supported by all LCN-PCHK versions)\n+            return String.format(\"A%d%s%03d\", outputId + 1, percent >= 0 ? \"AD\" : \"SB\", Math.abs(n / 2));\n+        } else { // We have a \".5\" value. Use the native command (supported since LCN-PCHK 2.3)\n+            return String.format(\"O%d%s%03d\", outputId + 1, percent >= 0 ? \"AD\" : \"SB\", Math.abs(n));\n+        }\n+    }\n+\n+    /**\n+     * Generates a command that toggles a single output-port (on->off, off->on).\n+     *\n+     * @param outputId 0..3\n+     * @param ramp see {@link PckGenerator#timeToRampValue(int)}\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String toggleOutput(int outputId, int ramp) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"A%dTA%03d\", outputId + 1, ramp);\n+    }\n+\n+    /**\n+     * Generates a command that toggles all output-ports (on->off, off->on).\n+     *\n+     * @param ramp see {@link PckGenerator#timeToRampValue(int)}\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String toggleAllOutputs(int ramp) {\n+        return String.format(\"AU%03d\", ramp);\n+    }\n+\n+    /**\n+     * Generates a relays-status request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestRelaysStatus() {\n+        return \"SMR\";\n+    }\n+\n+    /**\n+     * Generates a command to control relays.\n+     *\n+     * @param states the 8 modifiers for the relay states\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String controlRelays(LcnDefs.RelayStateModifier[] states) throws LcnException {\n+        if (states.length != 8) {\n+            throw new LcnException();\n+        }\n+        String ret = \"R8\";\n+        for (int i = 0; i < 8; ++i) {\n+            switch (states[i]) {\n+                case ON:\n+                    ret += \"1\";\n+                    break;\n+                case OFF:\n+                    ret += \"0\";\n+                    break;\n+                case TOGGLE:\n+                    ret += \"U\";\n+                    break;\n+                case NOCHANGE:\n+                    ret += \"-\";\n+                    break;\n+                default:\n+                    throw new LcnException();\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Generates a binary-sensors status request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestBinSensorsStatus() {\n+        return \"SMB\";\n+    }\n+\n+    /**\n+     * Generates a command that sets a variable absolute.\n+     *\n+     * @param number regulator number 0..1\n+     * @param value the absolute value to set\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException\n+     */\n+    public static String setSetpointAbsolute(int number, int value) {\n+        int internalValue = value;\n+        // Set absolute (not in PCK yet)\n+        int b1 = number << 6; // 01000000\n+        b1 |= 0x20; // xx10xxxx (set absolute)\n+        if (value < 1000) {\n+            internalValue = 1000 - internalValue;\n+            b1 |= 8;\n+        } else {\n+            internalValue -= 1000;\n+        }\n+        b1 |= (internalValue >> 8) & 0x0f; // xxxx1111\n+        int b2 = internalValue & 0xff;\n+        return String.format(\"X2%03d%03d%03d\", 30, b1, b2);\n+    }\n+\n+    /**\n+     * Generates a command to change the value of a variable.\n+     *\n+     * @param variable the target variable to change\n+     * @param type the reference-point\n+     * @param value the native LCN value to add/subtract (can be negative)\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if command is not supported\n+     */\n+    public static String setVariableRelative(Variable variable, LcnDefs.RelVarRef type, int value) {\n+        if (variable.getNumber() == 0) {\n+            // Old command for variable 1 / T-var (compatible with all modules)\n+            return String.format(\"Z%s%d\", value >= 0 ? \"A\" : \"S\", Math.abs(value));\n+        } else { // New command for variable 1-12 (compatible with all modules, since LCN-PCHK 2.8)\n+            return String.format(\"Z%s%03d%d\", value >= 0 ? \"+\" : \"-\", variable.getNumber() + 1, Math.abs(value));\n+        }\n+    }\n+\n+    /**\n+     * Generates a command the change the value of a regulator setpoint relative.\n+     *\n+     * @param number 0..1\n+     * @param type relative to the current or to the programmed value\n+     * @param value the relative value -4000..+4000\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String setSetpointRelative(int number, LcnDefs.RelVarRef type, int value) {\n+        return String.format(\"RE%sS%s%s%d\", number == 0 ? \"A\" : \"B\", type == LcnDefs.RelVarRef.CURRENT ? \"A\" : \"P\",\n+                value >= 0 ? \"+\" : \"-\", Math.abs(value));\n+    }\n+\n+    /**\n+     * Generates a command the change the value of a threshold relative.\n+     *\n+     * @param variable the threshold to change\n+     * @param type relative to the current or to the programmed value\n+     * @param value the relative value -4000..+4000\n+     * @param is2013 true, if the LCN module's firmware is equal to or newer than 2013\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String setThresholdRelative(Variable variable, LcnDefs.RelVarRef type, int value, boolean is2013)\n+            throws LcnException {\n+        if (is2013) { // New command for registers 1-4 (since 170206, LCN-PCHK 2.8)\n+            return String.format(\"SS%s%04d%sR%d%d\", type == LcnDefs.RelVarRef.CURRENT ? \"R\" : \"E\", Math.abs(value),\n+                    value >= 0 ? \"A\" : \"S\", variable.getNumber() + 1, variable.getThresholdNumber().get() + 1);\n+        } else if (variable.getNumber() == 0) { // Old command for register 1 (before 170206)\n+            return String.format(\"SS%s%04d%s%s%s%s%s%s\", type == LcnDefs.RelVarRef.CURRENT ? \"R\" : \"E\", Math.abs(value),\n+                    value >= 0 ? \"A\" : \"S\", variable.getThresholdNumber().get() == 0 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 1 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 2 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 3 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 4 ? \"1\" : \"0\");\n+        } else {\n+            throw new LcnException(\n+                    \"Module does not have threshold register \" + (variable.getThresholdNumber().get() + 1));\n+        }\n+    }\n+\n+    /**\n+     * Generates a variable value request.\n+     *\n+     * @param variable the variable to request\n+     * @param firmwareVersion the target module's firmware version\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if command is not supported\n+     */\n+    public static String requestVarStatus(Variable variable, int firmwareVersion) throws LcnException {\n+        if (firmwareVersion >= LcnBindingConstants.FIRMWARE_2013) {\n+            int id = variable.getNumber();\n+            switch (variable.getType()) {\n+                case UNKNOWN:\n+                    throw new LcnException(\"Variable unknown\");\n+                case VARIABLE:\n+                    return String.format(\"MWT%03d\", id + 1);\n+                case REGULATOR:\n+                    return String.format(\"MWS%03d\", id + 1);\n+                case THRESHOLD:\n+                    return String.format(\"SE%03d\", id + 1); // Whole register\n+                case S0INPUT:\n+                    return String.format(\"MWC%03d\", id + 1);\n+            }\n+            throw new LcnException(\"Unsupported variable type: \" + variable);\n+        } else {\n+            switch (variable) {\n+                case VARIABLE1:\n+                    return \"MWV\";\n+                case VARIABLE2:\n+                    return \"MWTA\";\n+                case VARIABLE3:\n+                    return \"MWTB\";\n+                case RVARSETPOINT1:\n+                    return \"MWSA\";\n+                case RVARSETPOINT2:\n+                    return \"MWSB\";\n+                case THRESHOLDREGISTER11:\n+                case THRESHOLDREGISTER12:\n+                case THRESHOLDREGISTER13:\n+                case THRESHOLDREGISTER14:\n+                case THRESHOLDREGISTER15:\n+                    return \"SL1\"; // Whole register\n+                default:\n+                    throw new LcnException(\"Unsupported variable type: \" + variable);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates a request for LED and logic-operations states.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestLedsAndLogicOpsStatus() {\n+        return \"SMT\";\n+    }\n+\n+    /**\n+     * Generates a command to the set the state of a single LED.\n+     *\n+     * @param ledId 0..11\n+     * @param state the state to set\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String controlLed(int ledId, LcnDefs.LedStatus state) throws LcnException {\n+        if (ledId < 0 || ledId > 11) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"LA%03d%s\", ledId + 1, state == LcnDefs.LedStatus.OFF ? \"A\"\n+                : state == LcnDefs.LedStatus.ON ? \"E\" : state == LcnDefs.LedStatus.BLINK ? \"B\" : \"F\");\n+    }\n+\n+    /**\n+     * Generates a command to send LCN keys.\n+     *\n+     * @param cmds the 4 concrete commands to send for the tables (A-D)\n+     * @param keys the tables' 8 key-states (true means \"send\")\n+     * @return the PCK command (without address header) as text\n+     * @throws IllegalArgumentException if out of range\n+     */\n+    public static String sendKeys(LcnDefs.SendKeyCommand[] cmds, boolean[] keys) throws LcnException {\n+        if (cmds.length != 4 || keys.length != 8) {\n+            throw new LcnException();\n+        }\n+        String ret = \"TS\";\n+        for (int i = 0; i < 4; ++i) {\n+            switch (cmds[i]) {\n+                case HIT:\n+                    ret += \"K\";\n+                    break;\n+                case MAKE:\n+                    ret += \"L\";\n+                    break;\n+                case BREAK:\n+                    ret += \"O\";\n+                    break;\n+                case DONTSEND:\n+                    // By skipping table D (if it is not used), we use the old command\n+                    // for table A-C which is compatible with older LCN modules\n+                    if (i < 3) {\n+                        ret += \"-\";\n+                    }\n+                    break;\n+                default:\n+                    throw new LcnException();\n+            }\n+        }\n+        for (int i = 0; i < 8; ++i) {\n+            ret += keys[i] ? \"1\" : \"0\";\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Generates a command to send LCN keys deferred / delayed.\n+     *\n+     * @param tableId 0(A)..3(D)\n+     * @param time the delay time\n+     * @param timeUnit the time unit\n+     * @param keys the key-states (true means \"send\")\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String sendKeysHitDefered(int tableId, int time, LcnDefs.TimeUnit timeUnit, boolean[] keys)\n+            throws LcnException {\n+        if (tableId < 0 || tableId > 3 || keys.length != 8) {\n+            throw new IllegalArgumentException();\n+        }\n+        String ret = \"TV\";\n+        switch (tableId) {\n+            case 0:\n+                ret += \"A\";\n+                break;\n+            case 1:\n+                ret += \"B\";\n+                break;\n+            case 2:\n+                ret += \"C\";\n+                break;\n+            case 3:\n+                ret += \"D\";\n+                break;\n+            default:\n+                throw new LcnException();\n+        }\n+        ret += String.format(\"%03d\", time);\n+        switch (timeUnit) {\n+            case SECONDS:\n+                if (time < 1 || time > 60) {\n+                    throw new LcnException();\n+                }\n+                ret += \"S\";\n+                break;\n+            case MINUTES:\n+                if (time < 1 || time > 90) {\n+                    throw new LcnException();\n+                }\n+                ret += \"M\";\n+                break;\n+            case HOURS:\n+                if (time < 1 || time > 50) {\n+                    throw new LcnException();\n+                }\n+                ret += \"H\";\n+                break;\n+            case DAYS:\n+                if (time < 1 || time > 45) {\n+                    throw new LcnException();\n+                }\n+                ret += \"D\";\n+                break;\n+            default:\n+                throw new LcnException();\n+        }\n+        for (int i = 0; i < 8; ++i) {\n+            ret += keys[i] ? \"1\" : \"0\";", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4OTI4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436889284", "bodyText": "how come you include an invalid argument message for some of these LcnExceptions but not all?", "author": "cpmeister", "createdAt": "2020-06-08T17:54:14Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/PckGenerator.java", "diffHunk": "@@ -0,0 +1,779 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Helpers to generate LCN-PCK commands.\n+ * <p>\n+ * LCN-PCK is the command-syntax used by LCN-PCHK to send and receive LCN commands.\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public final class PckGenerator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PckGenerator.class);\n+    /** Termination character after a PCK message */\n+    public static final String TERMINATION = \"\\n\";\n+\n+    /**\n+     * Generates a keep-alive.\n+     * LCN-PCHK will close the connection if it does not receive any commands from\n+     * an open {@link Connection} for a specific period (10 minutes by default).\n+     *\n+     * @param counter the current ping's id (optional, but \"best practice\"). Should start with 1\n+     * @return the PCK command as text\n+     */\n+    public static String ping(int counter) {\n+        return String.format(\"^ping%d\", counter);\n+    }\n+\n+    /**\n+     * Generates a PCK command that will set the LCN-PCHK connection's operation mode.\n+     * This influences how output-port commands and status are interpreted and must be\n+     * in sync with the LCN bus.\n+     *\n+     * @param dimMode see {@link LcnDefs.OutputPortDimMode}\n+     * @param statusMode see {@link LcnDefs.OutputPortStatusMode}\n+     * @return the PCK command as text\n+     */\n+    public static String setOperationMode(LcnDefs.OutputPortDimMode dimMode, LcnDefs.OutputPortStatusMode statusMode) {\n+        return \"!OM\" + (dimMode == LcnDefs.OutputPortDimMode.NATIVE200 ? \"1\" : \"0\")\n+                + (statusMode == LcnDefs.OutputPortStatusMode.PERCENT ? \"P\" : \"N\");\n+    }\n+\n+    /**\n+     * Generates a PCK address header.\n+     * Used for commands to LCN modules and groups.\n+     *\n+     * @param addr the target's address (module or group)\n+     * @param localSegId the local segment id where the physical bus connection is located\n+     * @param wantsAck true to claim an acknowledge / receipt from the target\n+     * @return the PCK address header as text\n+     */\n+    public static String generateAddressHeader(LcnAddr addr, int localSegId, boolean wantsAck) {\n+        return String.format(\">%s%03d%03d%s\", addr.isGroup() ? \"G\" : \"M\", addr.getPhysicalSegmentId(localSegId),\n+                addr.getId(), wantsAck ? \"!\" : \".\");\n+    }\n+\n+    /**\n+     * Generates a scan-command for LCN segment-couplers.\n+     * Used to detect the local segment (where the physical bus connection is located).\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String segmentCouplerScan() {\n+        return \"SK\";\n+    }\n+\n+    /**\n+     * Generates a firmware/serial-number request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestSn() {\n+        return \"SN\";\n+    }\n+\n+    /**\n+     * Generates a command to request a part of a name of a module.\n+     *\n+     * @param partNumber 0..1\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestModuleName(int partNumber) {\n+        return \"NMN\" + (partNumber + 1);\n+    }\n+\n+    /**\n+     * Generates an output-port status request.\n+     *\n+     * @param outputId 0..3\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String requestOutputStatus(int outputId) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"SMA%d\", outputId + 1);\n+    }\n+\n+    /**\n+     * Generates a dim command for a single output-port.\n+     *\n+     * @param outputId 0..3\n+     * @param percent 0..100\n+     * @param rampMs ramp in milliseconds\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String dimOutput(int outputId, double percent, int rampMs) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg5MTAwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436891008", "bodyText": "make these final", "author": "cpmeister", "createdAt": "2020-06-08T17:56:59Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/Variable.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+\n+/**\n+ * LCN variable types.\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public enum Variable {\n+    UNKNOWN(0, Type.UNKNOWN, LcnChannelGroup.VARIABLE), // Used if the real type is not known (yet)\n+    VARIABLE1(0, Type.VARIABLE, LcnChannelGroup.VARIABLE), // or TVar\n+    VARIABLE2(1, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE3(2, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE4(3, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE5(4, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE6(5, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE7(6, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE8(7, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE9(8, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE10(9, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE11(10, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE12(11, Type.VARIABLE, LcnChannelGroup.VARIABLE), // Since 170206\n+    RVARSETPOINT1(0, Type.REGULATOR, LcnChannelGroup.RVARSETPOINT),\n+    RVARSETPOINT2(1, Type.REGULATOR, LcnChannelGroup.RVARSETPOINT), // Set-points for regulators\n+    THRESHOLDREGISTER11(0, 0, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER1),\n+    THRESHOLDREGISTER12(0, 1, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER1),\n+    THRESHOLDREGISTER13(0, 2, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER1),\n+    THRESHOLDREGISTER14(0, 3, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER1),\n+    // Register 1 (THRESHOLDREGISTER15 only before 170206)\n+    THRESHOLDREGISTER15(0, 4, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER1),\n+    THRESHOLDREGISTER21(1, 0, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER2),\n+    THRESHOLDREGISTER22(1, 1, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER2),\n+    THRESHOLDREGISTER23(1, 2, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER2),\n+    THRESHOLDREGISTER24(1, 3, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER2), // Register 2 (since 2012)\n+    THRESHOLDREGISTER31(2, 0, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER3),\n+    THRESHOLDREGISTER32(2, 1, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER3),\n+    THRESHOLDREGISTER33(2, 2, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER3),\n+    THRESHOLDREGISTER34(2, 3, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER3), // Register 3 (since 2012)\n+    THRESHOLDREGISTER41(3, 0, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER4),\n+    THRESHOLDREGISTER42(3, 1, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER4),\n+    THRESHOLDREGISTER43(3, 2, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER4),\n+    THRESHOLDREGISTER44(3, 3, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER4), // Register 4 (since 2012)\n+    S0INPUT1(0, Type.S0INPUT, LcnChannelGroup.S0INPUT),\n+    S0INPUT2(1, Type.S0INPUT, LcnChannelGroup.S0INPUT),\n+    S0INPUT3(2, Type.S0INPUT, LcnChannelGroup.S0INPUT),\n+    S0INPUT4(3, Type.S0INPUT, LcnChannelGroup.S0INPUT); // LCN-BU4L\n+\n+    private int number;\n+    private Optional<Integer> thresholdNumber = Optional.empty();\n+    private Type type;\n+    private LcnChannelGroup channelGroup;", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg5MTgzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436891839", "bodyText": "Can you make these final?", "author": "cpmeister", "createdAt": "2020-06-08T17:58:25Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/AbstractConnectionState.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channel;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+\n+/**\n+ * Base class for representing LCN-PCK gateway connection states\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractConnectionState extends AbstractState {\n+    /** The PCK gateway's Connection */\n+    protected Connection connection;\n+    /** An openHAB scheduler */\n+    protected ScheduledExecutorService scheduler;", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg5Mjg4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436892888", "bodyText": "make these final", "author": "cpmeister", "createdAt": "2020-06-08T18:00:06Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/AbstractState.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Base class for usage for states with {@link StateMachine}.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractState {\n+    private List<ScheduledFuture<?>> usedTimers = Collections.synchronizedList(new ArrayList<>());\n+    protected StateContext context;", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg5NDU4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436894584", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        ModInfo data = this.modData.get(addr);\n          \n          \n            \n                        if (data == null) {\n          \n          \n            \n                            data = new ModInfo(addr);\n          \n          \n            \n                            this.modData.put(addr, data);\n          \n          \n            \n                        }\n          \n          \n            \n                        return data;\n          \n          \n            \n                        return this.modData.computeIfAbsent(ModInfo::new);", "author": "cpmeister", "createdAt": "2020-06-08T18:03:06Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/Connection.java", "diffHunk": "@@ -0,0 +1,505 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.AsynchronousSocketChannel;\n+import java.nio.channels.Channel;\n+import java.nio.channels.CompletionHandler;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrGrp;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class represents a configured connection to one LCN-PCHK.\n+ * It uses a {@link AsynchronousSocketChannel} to connect to LCN-PCHK.\n+ * Included logic:\n+ * <ul>\n+ * <li>Reconnection on connection loss\n+ * <li>Segment scan (to detect the local segment ID)\n+ * <li>Acknowledge handling\n+ * <li>Periodic value requests\n+ * <li>Caching of runtime data about the underlying LCN bus\n+ * </ul>\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class Connection {\n+    private final Logger logger = LoggerFactory.getLogger(Connection.class);\n+    /** Max. lengths of a PCK string including address and line feed. Currently dynamic text (GTDT) */\n+    private static final int MAX_PCK_STRING_LENGTH = 34;\n+    private static final int BROADCAST_MODULE_ID = 3;\n+    private static final int BROADCAST_SEGMENT_ID = 3;\n+    private final ConnectionSettings settings;\n+    private final ConnectionCallback callback;\n+    @Nullable\n+    private AsynchronousSocketChannel channel;\n+    /** The local segment id. -1 means \"unknown\". */\n+    private int localSegId;\n+    private final ByteBuffer readBuffer = ByteBuffer.allocate(1024);\n+    private final ByteBuffer sendBuffer = ByteBuffer.allocate(MAX_PCK_STRING_LENGTH);\n+    private final Queue<@Nullable SendData> sendQueue = new LinkedBlockingQueue<>();\n+    private final Queue<@Nullable PckQueueItem> offlineSendQueue = new LinkedBlockingQueue<>();\n+    private final Map<LcnAddr, @Nullable ModInfo> modData = Collections.synchronizedMap(new HashMap<>());\n+    private volatile boolean writeInProgress;\n+    private ScheduledExecutorService scheduler;\n+    private StateMachine stateMachine;\n+\n+    /**\n+     * Constructs a clean (disconnected) connection with the given settings.\n+     * This does not start the actual connection process.\n+     *\n+     * @param sets the settings to use for the new connection\n+     * @param callback the callback to the owner\n+     * @throws IOException\n+     */\n+    public Connection(ConnectionSettings sets, ScheduledExecutorService scheduler, ConnectionCallback callback) {\n+        this.settings = sets;\n+        this.callback = callback;\n+        this.scheduler = scheduler;\n+        this.clearRuntimeData();\n+\n+        stateMachine = new StateMachine(this, scheduler);\n+        stateMachine.startWorking();\n+    }\n+\n+    /** Clears all runtime data. */\n+    void clearRuntimeData() {\n+        this.channel = null;\n+        this.localSegId = -1;\n+        this.readBuffer.clear();\n+        this.sendQueue.clear();\n+        this.sendBuffer.clear();\n+    }\n+\n+    /**\n+     * Retrieves the settings for this connection (never changed).\n+     *\n+     * @return the settings\n+     */\n+    public ConnectionSettings getSettings() {\n+        return this.settings;\n+    }\n+\n+    private boolean isSocketConnected() {\n+        try {\n+            AsynchronousSocketChannel localChannel = channel;\n+            return localChannel != null && localChannel.getRemoteAddress() != null;\n+        } catch (IOException e) {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Sets the local segment id.\n+     *\n+     * @param localSegId the new local segment id\n+     */\n+    public void setLocalSegId(int localSegId) {\n+        this.localSegId = localSegId;\n+    }\n+\n+    /**\n+     * Called whenever an acknowledge is received.\n+     *\n+     * @param addr the source LCN module\n+     * @param code the LCN internal code (-1 = \"positive\")\n+     */\n+    public void onAck(LcnAddrMod addr, int code) {\n+        ModInfo info = this.modData.get(addr);\n+        if (info != null) {\n+            info.onAck(code, this, this.settings.getTimeout(), System.nanoTime());\n+        }\n+    }\n+\n+    /**\n+     * Creates and/or returns cached data for the given LCN module.\n+     *\n+     * @param addr the module's address\n+     * @return the data (never null)\n+     */\n+    public ModInfo updateModuleData(LcnAddrMod addr) {\n+        synchronized (modData) {\n+            ModInfo data = this.modData.get(addr);\n+            if (data == null) {\n+                data = new ModInfo(addr);\n+                this.modData.put(addr, data);\n+            }\n+            return data;", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg5NTYxMA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436895610", "bodyText": "Every single info will be update with a different System.nanoTime() result. Is that what you want? Or should they all be the same?", "author": "cpmeister", "createdAt": "2020-06-08T18:04:53Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/Connection.java", "diffHunk": "@@ -0,0 +1,505 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.AsynchronousSocketChannel;\n+import java.nio.channels.Channel;\n+import java.nio.channels.CompletionHandler;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrGrp;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class represents a configured connection to one LCN-PCHK.\n+ * It uses a {@link AsynchronousSocketChannel} to connect to LCN-PCHK.\n+ * Included logic:\n+ * <ul>\n+ * <li>Reconnection on connection loss\n+ * <li>Segment scan (to detect the local segment ID)\n+ * <li>Acknowledge handling\n+ * <li>Periodic value requests\n+ * <li>Caching of runtime data about the underlying LCN bus\n+ * </ul>\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class Connection {\n+    private final Logger logger = LoggerFactory.getLogger(Connection.class);\n+    /** Max. lengths of a PCK string including address and line feed. Currently dynamic text (GTDT) */\n+    private static final int MAX_PCK_STRING_LENGTH = 34;\n+    private static final int BROADCAST_MODULE_ID = 3;\n+    private static final int BROADCAST_SEGMENT_ID = 3;\n+    private final ConnectionSettings settings;\n+    private final ConnectionCallback callback;\n+    @Nullable\n+    private AsynchronousSocketChannel channel;\n+    /** The local segment id. -1 means \"unknown\". */\n+    private int localSegId;\n+    private final ByteBuffer readBuffer = ByteBuffer.allocate(1024);\n+    private final ByteBuffer sendBuffer = ByteBuffer.allocate(MAX_PCK_STRING_LENGTH);\n+    private final Queue<@Nullable SendData> sendQueue = new LinkedBlockingQueue<>();\n+    private final Queue<@Nullable PckQueueItem> offlineSendQueue = new LinkedBlockingQueue<>();\n+    private final Map<LcnAddr, @Nullable ModInfo> modData = Collections.synchronizedMap(new HashMap<>());\n+    private volatile boolean writeInProgress;\n+    private ScheduledExecutorService scheduler;\n+    private StateMachine stateMachine;\n+\n+    /**\n+     * Constructs a clean (disconnected) connection with the given settings.\n+     * This does not start the actual connection process.\n+     *\n+     * @param sets the settings to use for the new connection\n+     * @param callback the callback to the owner\n+     * @throws IOException\n+     */\n+    public Connection(ConnectionSettings sets, ScheduledExecutorService scheduler, ConnectionCallback callback) {\n+        this.settings = sets;\n+        this.callback = callback;\n+        this.scheduler = scheduler;\n+        this.clearRuntimeData();\n+\n+        stateMachine = new StateMachine(this, scheduler);\n+        stateMachine.startWorking();\n+    }\n+\n+    /** Clears all runtime data. */\n+    void clearRuntimeData() {\n+        this.channel = null;\n+        this.localSegId = -1;\n+        this.readBuffer.clear();\n+        this.sendQueue.clear();\n+        this.sendBuffer.clear();\n+    }\n+\n+    /**\n+     * Retrieves the settings for this connection (never changed).\n+     *\n+     * @return the settings\n+     */\n+    public ConnectionSettings getSettings() {\n+        return this.settings;\n+    }\n+\n+    private boolean isSocketConnected() {\n+        try {\n+            AsynchronousSocketChannel localChannel = channel;\n+            return localChannel != null && localChannel.getRemoteAddress() != null;\n+        } catch (IOException e) {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Sets the local segment id.\n+     *\n+     * @param localSegId the new local segment id\n+     */\n+    public void setLocalSegId(int localSegId) {\n+        this.localSegId = localSegId;\n+    }\n+\n+    /**\n+     * Called whenever an acknowledge is received.\n+     *\n+     * @param addr the source LCN module\n+     * @param code the LCN internal code (-1 = \"positive\")\n+     */\n+    public void onAck(LcnAddrMod addr, int code) {\n+        ModInfo info = this.modData.get(addr);\n+        if (info != null) {\n+            info.onAck(code, this, this.settings.getTimeout(), System.nanoTime());\n+        }\n+    }\n+\n+    /**\n+     * Creates and/or returns cached data for the given LCN module.\n+     *\n+     * @param addr the module's address\n+     * @return the data (never null)\n+     */\n+    public ModInfo updateModuleData(LcnAddrMod addr) {\n+        synchronized (modData) {\n+            ModInfo data = this.modData.get(addr);\n+            if (data == null) {\n+                data = new ModInfo(addr);\n+                this.modData.put(addr, data);\n+            }\n+            return data;\n+        }\n+    }\n+\n+    /**\n+     * Reads and processes input from the underlying channel.\n+     * Fragmented input is kept in {@link #readBuffer} and will be processed with the next call.\n+     *\n+     * @throws IOException if connection was closed or a generic channel error occurred\n+     */\n+    void readAndProcess() {\n+        AsynchronousSocketChannel localChannel = channel;\n+        if (localChannel != null && isSocketConnected()) {\n+            localChannel.read(readBuffer, null, new CompletionHandler<@Nullable Integer, @Nullable Void>() {\n+                @Override\n+                public void completed(@Nullable Integer transmittedByteCount, @Nullable Void attachment) {\n+                    synchronized (Connection.this) {\n+                        if (transmittedByteCount == null || transmittedByteCount == -1) {\n+                            String msg = \"Connection was closed by foreign host.\";\n+                            stateMachine.handleConnectionFailed(new LcnException(msg));\n+                        } else {\n+                            try {\n+                                // read data chunks from socket and separate frames\n+                                readBuffer.flip();\n+                                int aPos = readBuffer.position(); // 0\n+                                String s = new String(readBuffer.array(), aPos, transmittedByteCount,\n+                                        LcnDefs.LCN_ENCODING);\n+                                int pos1 = 0, pos2 = s.indexOf(PckGenerator.TERMINATION, pos1);\n+                                while (pos2 != -1) {\n+                                    String data = s.substring(pos1, pos2);\n+                                    if (logger.isTraceEnabled()) {\n+                                        logger.trace(\"Received: '{}'\", data);\n+                                    }\n+                                    scheduler.submit(() -> {\n+                                        stateMachine.onInputReceived(data);\n+                                        callback.onPckMessageReceived(data);\n+                                    });\n+                                    // Seek position in input array\n+                                    aPos += s.substring(pos1, pos2 + 1).getBytes(LcnDefs.LCN_ENCODING).length;\n+                                    // Next input\n+                                    pos1 = pos2 + 1;\n+                                    pos2 = s.indexOf(PckGenerator.TERMINATION, pos1);\n+                                }\n+                                readBuffer.limit(readBuffer.capacity());\n+                                readBuffer.position(transmittedByteCount - aPos); // Keeps fragments for the next call\n+                            } catch (UnsupportedEncodingException ex) {\n+                                logger.warn(\"Unable to decode input from channel \\\"{}\\\": {}\", settings.getId(),\n+                                        ex.getMessage());\n+                            }\n+\n+                            if (isSocketConnected()) {\n+                                readAndProcess();\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void failed(@Nullable Throwable e, @Nullable Void attachment) {\n+                    logger.debug(\"Lost connection\");\n+                    stateMachine.handleConnectionFailed(e);\n+                }\n+            });\n+        } else {\n+            stateMachine.handleConnectionFailed(new LcnException(\"Socket not open\"));\n+        }\n+    }\n+\n+    /**\n+     * Writes all queued data.\n+     * Will try to write all data at once to reduce overhead.\n+     */\n+    public synchronized void triggerWriteToSocket() {\n+        AsynchronousSocketChannel localChannel = channel;\n+        if (localChannel == null || !isSocketConnected() || writeInProgress) {\n+            return;\n+        }\n+        sendBuffer.clear();\n+        SendData item = sendQueue.poll();\n+\n+        if (item != null) {\n+            try {\n+                if (!item.write(sendBuffer, localSegId)) {\n+                    logger.warn(\"Data loss: Could not write packet into send buffer\");\n+                }\n+\n+                writeInProgress = true;\n+                sendBuffer.flip();\n+                localChannel.write(sendBuffer, null, new CompletionHandler<@Nullable Integer, @Nullable Void>() {\n+                    @Override\n+                    public void completed(@Nullable Integer result, @Nullable Void attachment) {\n+                        synchronized (Connection.this) {\n+                            if (result != sendBuffer.limit()) {\n+                                logger.warn(\"Data loss while writing to channel: {}\", settings.getAddress());\n+                            } else {\n+                                if (logger.isTraceEnabled()) {\n+                                    logger.trace(\"Sent: {}\", new String(sendBuffer.array(), 0, sendBuffer.limit()));\n+                                }\n+                            }\n+\n+                            writeInProgress = false;\n+\n+                            if (sendQueue.size() > 0) {\n+                                /**\n+                                 * This could lead to stack overflows, since the CompletionHandler may run in the same\n+                                 * Thread as triggerWriteToSocket() is invoked (see\n+                                 * {@link AsynchronousChannelGroup}/Threading), but we do not expect as much data\n+                                 * in one chunk here, that the stack can be filled in a critical way.\n+                                 */\n+                                triggerWriteToSocket();\n+                            }\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void failed(@Nullable Throwable exc, @Nullable Void attachment) {\n+                        synchronized (Connection.this) {\n+                            if (exc != null) {\n+                                logger.warn(\"Writing to channel \\\"{}\\\" failed: {}\", settings.getAddress(),\n+                                        exc.getMessage());\n+                            }\n+                            writeInProgress = false;\n+                            stateMachine.handleConnectionFailed(new LcnException(\"write() failed\"));\n+                        }\n+                    }\n+                });\n+            } catch (UnsupportedEncodingException | BufferOverflowException e) {\n+                logger.warn(\"Sending failed: {}: {}: {}\", item, e.getClass().getSimpleName(), e.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Queues plain text to be sent to LCN-PCHK.\n+     * Sending will be done the next time {@link #triggerWriteToSocket()} is called.\n+     *\n+     * @param plainText the text\n+     */\n+    public void queueDirectlyPlainText(String plainText) {\n+        this.queueAndSend(new SendDataPlainText(plainText));\n+    }\n+\n+    /**\n+     * Queues a PCK command to be sent.\n+     *\n+     * @param addr the target LCN address\n+     * @param wantsAck true to wait for acknowledge on receipt (should be false for group addresses)\n+     * @param pck the pure PCK command (without address header)\n+     */\n+    void queueDirectly(LcnAddr addr, boolean wantsAck, String pck) {\n+        try {\n+            this.queueDirectly(addr, wantsAck, ByteBuffer.wrap(pck.getBytes(LcnDefs.LCN_ENCODING)));\n+        } catch (UnsupportedEncodingException ex) {\n+            logger.error(\"Failed to encode PCK command: {}\", pck);\n+        }\n+    }\n+\n+    /**\n+     * Queues a PCK command for immediate sending, regardless of the Connection state. The PCK command is automatically\n+     * re-sent if the destination is not a group, an Ack is requested and the module did not answer within the expected\n+     * time.\n+     *\n+     * @param addr the target LCN address\n+     * @param wantsAck true to wait for acknowledge on receipt (should be false for group addresses)\n+     * @param data the pure PCK command (without address header)\n+     */\n+    void queueDirectly(LcnAddr addr, boolean wantsAck, ByteBuffer data) {\n+        if (!addr.isGroup() && wantsAck) {\n+            this.updateModuleData((LcnAddrMod) addr).queuePckCommandWithAck(data, this, this.settings.getTimeout(),\n+                    System.nanoTime());\n+        } else {\n+            this.queueAndSend(new SendDataPck(addr, false, data));\n+        }\n+    }\n+\n+    /**\n+     * Enqueues a raw PCK command and triggers the socket to start sending, if it does not already. Does not take care\n+     * of any Acks.\n+     *\n+     * @param data raw PCK command\n+     */\n+    synchronized void queueAndSend(SendData data) {\n+        this.sendQueue.add(data);\n+\n+        triggerWriteToSocket();\n+    }\n+\n+    /**\n+     * Enqueues a PCK command to the offline queue. Data will be sent when the Connection state will enter\n+     * {@link ConnectionStateConnected}.\n+     *\n+     * @param addr LCN module address\n+     * @param wantsAck true, if the LCN module shall respond with an Ack on successful processing\n+     * @param data the pure PCK command (without address header)\n+     */\n+    void queueOffline(LcnAddr addr, boolean wantsAck, ByteBuffer data) {\n+        offlineSendQueue.add(new PckQueueItem(addr, wantsAck, data));\n+    }\n+\n+    /**\n+     * Enqueues a PCK command for sending. Takes care of the Connection state and buffers the command for a specific\n+     * time if the Connection is not ready. If an Ack is requested, the PCK command is automatically\n+     * re-sent, if the module did not answer in the expected time.\n+     *\n+     * @param addr LCN module address\n+     * @param wantsAck true, if the LCN module shall respond with an Ack on successful processing\n+     * @param pck the pure PCK command (without address header)\n+     */\n+    public void queue(LcnAddr addr, boolean wantsAck, String pck) {\n+        try {\n+            this.queue(addr, wantsAck, ByteBuffer.wrap(pck.getBytes(LcnDefs.LCN_ENCODING)));\n+        } catch (UnsupportedEncodingException ex) {\n+            logger.warn(\"Failed to encode PCK command: {}\", pck);\n+        }\n+    }\n+\n+    /**\n+     * Enqueues a PCK command for sending. Takes care of the Connection state and buffers the command for a specific\n+     * time if the Connection is not ready. If an Ack is requested, the PCK command is automatically\n+     * re-sent, if the module did not answer in the expected time.\n+     *\n+     * @param addr LCN module address\n+     * @param wantsAck true, if the LCN module shall respond with an Ack on successful processing\n+     * @param pck the pure PCK command (without address header)\n+     */\n+    public void queue(LcnAddr addr, boolean wantsAck, ByteBuffer pck) {\n+        stateMachine.queue(addr, wantsAck, pck);\n+    }\n+\n+    /**\n+     * Process the offline PCK command queue. Does only send recently enqueued PCK commands, the rest is discarded.\n+     */\n+    void sendOfflineQueue() {\n+        // don't use forEach(), because elements can be added during iteration\n+        while (!offlineSendQueue.isEmpty()) {\n+            PckQueueItem item = offlineSendQueue.poll();\n+\n+            if (item == null) {\n+                break;\n+            }\n+\n+            // only send messages that were enqueued recently, discard older messages\n+            long timeout = settings.getTimeout();\n+            if (item.getEnqueued().isAfter(Instant.now().minus(timeout * 4, ChronoUnit.MILLIS))) {\n+                queueDirectly(item.getAddr(), item.isWantsAck(), item.getData());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Gets the Connection's callback.\n+     *\n+     * @return the callback\n+     */\n+    public ConnectionCallback getCallback() {\n+        return callback;\n+    }\n+\n+    /**\n+     * Sets the SocketChannel of this Connection\n+     *\n+     * @param channel the new Channel\n+     */\n+    public void setSocketChannel(AsynchronousSocketChannel channel) {\n+        this.channel = channel;\n+    }\n+\n+    /**\n+     * Gets the SocketChannel of the Connection.\n+     *\n+     * @returnthe socket channel\n+     */\n+    @Nullable\n+    public Channel getSocketChannel() {\n+        return channel;\n+    }\n+\n+    /**\n+     * Gets the local segment ID. When no segments are used, the local segment ID is 0.\n+     *\n+     * @return the local segment ID\n+     */\n+    public int getLocalSegId() {\n+        return localSegId;\n+    }\n+\n+    /**\n+     * Runs the periodic updates on all ModInfos.\n+     */\n+    public void updateModInfos() {\n+        synchronized (modData) {\n+            for (ModInfo info : modData.values()) {\n+                if (info != null) {\n+                    info.update(this, settings.getTimeout(), System.nanoTime());", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxNzY1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438317651", "bodyText": "Using the same or slightly different System.nanoTime() doesn't care. I left it.", "author": "fwolter", "createdAt": "2020-06-10T18:11:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg5NTYxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg5Njk5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436896990", "bodyText": "Why are you using a byte buffer here instead of a byte array?", "author": "cpmeister", "createdAt": "2020-06-08T18:07:24Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/SendDataPck.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+\n+/**\n+ * A PCK command to be send to LCN-PCHK.\n+ * It is already encoded as bytes to allow different text-encodings (ANSI, UTF-8).\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+class SendDataPck extends SendData {\n+    /** The target LCN address. */\n+    private final LcnAddr addr;\n+\n+    /** true to acknowledge the command on receipt. */\n+    private final boolean wantsAck;\n+\n+    /** PCK command (without address header) encoded as bytes. */\n+    private final ByteBuffer data;", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg5ODc0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436898741", "bodyText": "taking a byte buffer as an argument for a write operation is inherently risky since it cannot grow in size and makes it very easy to implementors to write in excess of the buffer's size. I think a DataOutputStream would be more appropriate here.", "author": "cpmeister", "createdAt": "2020-06-08T18:10:36Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/SendData.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Base class for a packet to be send to LCN-PCHK.\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public abstract class SendData {\n+    /**\n+     * Writes the packet's data into the given buffer.\n+     * Called right before the packet is actually sent to LCN-PCHK.\n+     *\n+     * @param buffer the target buffer\n+     * @param localSegId the local segment id\n+     * @return true if everything was set-up correctly and data was written\n+     * @throws UnsupportedEncodingException if text could not be encoded for LCN-PCHK\n+     * @throws BufferOverflowException if target buffer has not enough space left (buffer will not be altered)\n+     */\n+    abstract boolean write(ByteBuffer buffer, int localSegId)", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxODI5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438318291", "bodyText": "You are totally right. Changed to a ByteBufferOutputStream.", "author": "fwolter", "createdAt": "2020-06-10T18:12:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg5ODc0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwMTI3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436901279", "bodyText": "If you made an implementation of AbstractVariableValueConverter that takes a Unit and scaling constructor parameters then you could probably get rid of this class and a few others.", "author": "cpmeister", "createdAt": "2020-06-08T18:15:21Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/converter/AngleConverter.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.converter;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+\n+/**\n+ * Converts the native LCN value of LCN-WIH to the sun azimuth/elevation values.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class AngleConverter extends AbstractVariableValueConverter {", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxODU5OA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438318598", "bodyText": "Great idea! Refactored.", "author": "fwolter", "createdAt": "2020-06-10T18:13:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwMTI3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwMzYxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436903619", "bodyText": "I'm not sure that lazy initialization of the singleton instance really matters for stateless singletons.", "author": "cpmeister", "createdAt": "2020-06-08T18:19:31Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/converter/IdentityConverter.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.converter;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+\n+/**\n+ * Converts the value 1:1.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class IdentityConverter extends AbstractVariableValueConverter {\n+    private IdentityConverter() {\n+        // nothing\n+    }\n+\n+    @NonNullByDefault({})\n+    private static class LazyHolder {\n+        static final IdentityConverter INSTANCE = new IdentityConverter();\n+    }\n+\n+    public static IdentityConverter getInstance() {\n+        return LazyHolder.INSTANCE;", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxOTc5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438319796", "bodyText": "I used the Initialization-on-demand holder idiom to achieve synchronization at low cost. The classes where I used it have been removed during refactoring.", "author": "fwolter", "createdAt": "2020-06-10T18:15:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwMzYxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMjc5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436912796", "bodyText": "why not make this a byte array?", "author": "cpmeister", "createdAt": "2020-06-08T18:36:08Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/PckQueueItem.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+\n+/**\n+ * Holds data of one PCK command with the target address and the date when the item has been enqueued.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class PckQueueItem {\n+    private Instant enqueued;\n+    private LcnAddr addr;\n+    private boolean wantsAck;\n+    private ByteBuffer data;", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMzcxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436913715", "bodyText": "Just letting you know in case you are not aware, but there is a current outstanding bug regarding actions that currently requires a workaround.\nopenhab/openhab-core#1265\nIf you feel like implementing the workaround you can use this as a example:\nhttps://github.com/openhab/openhab-addons/blob/2.5.x/bundles/org.openhab.binding.ecobee/src/main/java/org/openhab/binding/ecobee/action/EcobeeActions.java#L89", "author": "cpmeister", "createdAt": "2020-06-08T18:37:47Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleActions.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnDefs.KeyTable;\n+import org.openhab.binding.lcn.internal.common.LcnDefs.SendKeyCommand;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handles actions requested to be sent to an LCN module.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@ThingActionsScope(name = \"lcn\")\n+@NonNullByDefault\n+public class LcnModuleActions implements ThingActions {", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMyMDEwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438320100", "bodyText": "Thanks for the hint! I wasn't aware of this bug. Implemented.", "author": "fwolter", "createdAt": "2020-06-10T18:15:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMzcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNTAxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436915011", "bodyText": "Why is this a synchronized HashMap instead of a ConcurrentHashMap?", "author": "cpmeister", "createdAt": "2020-06-08T18:40:20Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.NullScheduledFuture;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Scans all LCN segments for LCN modules.\n+ *\n+ * Scan approach:\n+ * 1. Send \"Leerkomando\" to the broadcast address with request for Ack set\n+ * 2. For every received Ack, send the following requests to the module:\n+ * - serial number request (SN)\n+ * - module's name first part request (NM1)\n+ * - module's name second part request (NM2)\n+ * 3. When all three messages have been received, fire thingDiscovered()\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleDiscoveryService.class);\n+    private static final Pattern NAME_PATTERN = Pattern\n+            .compile(\"=M(?<segId>\\\\d{3})(?<modId>\\\\d{3}).N(?<part>[1-2]{1})(?<name>.*)\");\n+    private static final int MODULE_NAME_PART_COUNT = 2;\n+    private static final int DISCOVERY_TIMEOUT_SEC = 90;\n+    private static final int ACK_TIMEOUT_MS = 1000;\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(LcnBindingConstants.THING_TYPE_MODULE).collect(Collectors.toSet()));\n+    private @Nullable PckGatewayHandler bridgeHandler;\n+    private Map<LcnAddrMod, Map<Integer, String>> moduleNames = Collections.synchronizedMap(new HashMap<>());\n+    private Map<LcnAddrMod, DiscoveryResultBuilder> discoveryResultBuilders = Collections\n+            .synchronizedMap(new HashMap<>());", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMyMDg5OA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438320898", "bodyText": "I didn't know the difference between synchronized and ConcurrentHashMap. Thanks for enlightening me! Changed.", "author": "fwolter", "createdAt": "2020-06-10T18:17:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNTAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNTYyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436915624", "bodyText": "Why does this need to be a synchronized map if all access to it is already synchronized around LcnModuleDiscoveryService?", "author": "cpmeister", "createdAt": "2020-06-08T18:41:21Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.NullScheduledFuture;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Scans all LCN segments for LCN modules.\n+ *\n+ * Scan approach:\n+ * 1. Send \"Leerkomando\" to the broadcast address with request for Ack set\n+ * 2. For every received Ack, send the following requests to the module:\n+ * - serial number request (SN)\n+ * - module's name first part request (NM1)\n+ * - module's name second part request (NM2)\n+ * 3. When all three messages have been received, fire thingDiscovered()\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleDiscoveryService.class);\n+    private static final Pattern NAME_PATTERN = Pattern\n+            .compile(\"=M(?<segId>\\\\d{3})(?<modId>\\\\d{3}).N(?<part>[1-2]{1})(?<name>.*)\");\n+    private static final int MODULE_NAME_PART_COUNT = 2;\n+    private static final int DISCOVERY_TIMEOUT_SEC = 90;\n+    private static final int ACK_TIMEOUT_MS = 1000;\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(LcnBindingConstants.THING_TYPE_MODULE).collect(Collectors.toSet()));\n+    private @Nullable PckGatewayHandler bridgeHandler;\n+    private Map<LcnAddrMod, Map<Integer, String>> moduleNames = Collections.synchronizedMap(new HashMap<>());", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNjcxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436916713", "bodyText": "Is it possible to specify the representation property as well?", "author": "cpmeister", "createdAt": "2020-06-08T18:43:21Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.NullScheduledFuture;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Scans all LCN segments for LCN modules.\n+ *\n+ * Scan approach:\n+ * 1. Send \"Leerkomando\" to the broadcast address with request for Ack set\n+ * 2. For every received Ack, send the following requests to the module:\n+ * - serial number request (SN)\n+ * - module's name first part request (NM1)\n+ * - module's name second part request (NM2)\n+ * 3. When all three messages have been received, fire thingDiscovered()\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleDiscoveryService.class);\n+    private static final Pattern NAME_PATTERN = Pattern\n+            .compile(\"=M(?<segId>\\\\d{3})(?<modId>\\\\d{3}).N(?<part>[1-2]{1})(?<name>.*)\");\n+    private static final int MODULE_NAME_PART_COUNT = 2;\n+    private static final int DISCOVERY_TIMEOUT_SEC = 90;\n+    private static final int ACK_TIMEOUT_MS = 1000;\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(LcnBindingConstants.THING_TYPE_MODULE).collect(Collectors.toSet()));\n+    private @Nullable PckGatewayHandler bridgeHandler;\n+    private Map<LcnAddrMod, Map<Integer, String>> moduleNames = Collections.synchronizedMap(new HashMap<>());\n+    private Map<LcnAddrMod, DiscoveryResultBuilder> discoveryResultBuilders = Collections\n+            .synchronizedMap(new HashMap<>());\n+    private List<LcnAddrMod> successfullyDiscovered = new LinkedList<>();\n+    private Queue<@Nullable LcnAddrMod> serialNumberRequestQueue = new ConcurrentLinkedQueue<>();\n+    private Queue<@Nullable LcnAddrMod> moduleNameRequestQueue = new ConcurrentLinkedQueue<>();\n+    private volatile ScheduledFuture<?> queueProcessor = NullScheduledFuture.getInstance();\n+    private ScheduledFuture<?> builderTask = NullScheduledFuture.getInstance();\n+\n+    public LcnModuleDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_TIMEOUT_SEC, false);\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof PckGatewayHandler) {\n+            this.bridgeHandler = (PckGatewayHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        stopScan();\n+    }\n+\n+    @SuppressWarnings({ \"unused\", \"null\" })\n+    @Override\n+    protected void startScan() {\n+        synchronized (this) {\n+            PckGatewayHandler localBridgeHandler = bridgeHandler;\n+            if (localBridgeHandler == null) {\n+                logger.warn(\"Bridge handler not set\");\n+                return;\n+            }\n+\n+            if (localBridgeHandler.getConnection() == null) {\n+                builderTask.cancel(true);\n+            }\n+\n+            localBridgeHandler.registerPckListener(data -> {\n+                Matcher matcher;\n+\n+                if ((matcher = LcnModuleMetaAckSubHandler.PATTERN_POS.matcher(data)).matches()\n+                        || (matcher = LcnModuleMetaFirmwareSubHandler.PATTERN.matcher(data)).matches()\n+                        || (matcher = NAME_PATTERN.matcher(data)).matches()) {\n+                    synchronized (LcnModuleDiscoveryService.this) {\n+                        Connection connection = localBridgeHandler.getConnection();\n+\n+                        if (connection == null) {\n+                            return;\n+                        }\n+\n+                        LcnAddrMod addr = new LcnAddrMod(\n+                                localBridgeHandler.toLogicalSegmentId(Integer.parseInt(matcher.group(\"segId\"))),\n+                                Integer.parseInt(matcher.group(\"modId\")));\n+\n+                        if (matcher.pattern() == LcnModuleMetaAckSubHandler.PATTERN_POS) {\n+                            // Received an ACK frame\n+\n+                            // The module could send an Ack with a response to another command. So, ignore the Ack, when\n+                            // we received our data already.\n+                            if (!discoveryResultBuilders.containsKey(addr)) {\n+                                serialNumberRequestQueue.add(addr);\n+                                rescheduleQueueProcessor(); // delay request of serial until all modules finished ACKing\n+                            }\n+\n+                            if (!moduleNames.containsKey(addr)\n+                                    || moduleNames.get(addr).size() != MODULE_NAME_PART_COUNT) {\n+                                moduleNameRequestQueue.add(addr);\n+                                rescheduleQueueProcessor(); // delay request of names until all modules finished ACKing\n+                            }\n+                        } else if (matcher.pattern() == LcnModuleMetaFirmwareSubHandler.PATTERN) {\n+                            // Received a firmware version info frame\n+\n+                            Map<String, Object> properties = new HashMap<>(5);\n+                            properties.put(\"segmentId\", addr.getSegmentId());\n+                            properties.put(\"moduleId\", addr.getModuleId());\n+\n+                            ThingUID bridgeUid = localBridgeHandler.getThing().getUID();\n+                            String thingId = matcher.group(\"sn\");\n+                            ThingUID thingUid = new ThingUID(LcnBindingConstants.THING_TYPE_MODULE, bridgeUid, thingId);\n+\n+                            DiscoveryResultBuilder discoveryResult = DiscoveryResultBuilder.create(thingUid)\n+                                    .withProperties(properties).withBridge(bridgeUid);", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMyMjAzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438322037", "bodyText": "I would choose the module's serial number for that. But the serial number is already used as the thingID. Does it make any difference specifying it, then?", "author": "fwolter", "createdAt": "2020-06-10T18:19:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNjcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2ODk3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438368977", "bodyText": "The ThingID can be anything and the user must not assume any semantics from it (e.g. for a manually created Thing through the Paper UI, it won't be the serial number - likewise for Things defined in a things-file as the user can freely choose the ids there).\nSo in short: Yes, it makes sense to specify the representation property. This serves as a hint to the UI what to show to the user, so that he can easily tell two things of the same type in his inbox apart.", "author": "kaikreuzer", "createdAt": "2020-06-10T19:48:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNjcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxODA1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436918058", "bodyText": "please cache config.getMode() in a local variable so it can be reused", "author": "cpmeister", "createdAt": "2020-06-08T18:45:40Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/PckGatewayHandler.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnDefs.OutputPortDimMode;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.connection.ConnectionCallback;\n+import org.openhab.binding.lcn.internal.connection.ConnectionSettings;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PckGatewayHandler} is responsible for the communication via a PCK gateway.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PckGatewayHandler extends BaseBridgeHandler {\n+    private final Logger logger = LoggerFactory.getLogger(PckGatewayHandler.class);\n+    private @Nullable Connection connection;\n+    private Optional<Consumer<String>> pckListener = Optional.empty();\n+\n+    public PckGatewayHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // nothing\n+    }\n+\n+    @Override\n+    public synchronized void initialize() {\n+        PckGatewayConfiguration config = getConfigAs(PckGatewayConfiguration.class);\n+\n+        String errorMessage = \"Could not connect to LCN-PCHK/PKE: \" + config.getHostname() + \": \";\n+\n+        try {\n+            OutputPortDimMode dimMode;\n+            if (LcnDefs.OutputPortDimMode.NATIVE50.name().equalsIgnoreCase(config.getMode())) {", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxODY5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436918699", "bodyText": "make these final", "author": "cpmeister", "createdAt": "2020-06-08T18:46:50Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/DimmerOutputCommand.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import java.math.BigDecimal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+\n+/**\n+ * Holds the information to control dimmer outputs of an LCN module. Used when the user configured an \"output\" profile.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class DimmerOutputCommand extends PercentType {\n+    private static final long serialVersionUID = 8147502412107723798L;\n+    private boolean controlAllOutputs;\n+    private boolean controlOutputs12;\n+    private int rampMs;", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkyMDc0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436920742", "bodyText": "Would it be possible to allow the results to be null so you don't have to call new Object() for your get methods?\nWould something like this work?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             */\n          \n          \n            \n            @NonNullByDefault\n          \n          \n            \n            public class NullScheduledFuture implements ScheduledFuture<Object> {\n          \n          \n            \n             */\n          \n          \n            \n            @NonNullByDefault\n          \n          \n            \n            public class NullScheduledFuture implements ScheduledFuture<@Nullable Object> {\n          \n      \n    \n    \n  \n\nThen you should be able to return null instead of creating a new object.\nI'm not sure if this would cause issues with the existing code that uses this but I suspect it should be fine since you mostly use wildcards in your fields.", "author": "cpmeister", "createdAt": "2020-06-08T18:50:37Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/NullScheduledFuture.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Empty ScheduledFuture, used for initialization.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class NullScheduledFuture implements ScheduledFuture<Object> {", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkyMjc2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436922769", "bodyText": "I don't think there is much benefit to do lazy initialization here. I suggest keeping it simple.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @NonNullByDefault({})\n          \n          \n            \n                private static class LazyHolder {\n          \n          \n            \n                    static final NullScheduledFuture INSTANCE = new NullScheduledFuture();\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private NullScheduledFuture() {\n          \n          \n            \n                    // nothing\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                /** Gets the instance of this singleton. */\n          \n          \n            \n                public static NullScheduledFuture getInstance() {\n          \n          \n            \n                    return LazyHolder.INSTANCE;\n          \n          \n            \n                }\n          \n          \n            \n                \n          \n          \n            \n                /** Gets the instance of this singleton. */\n          \n          \n            \n                public static final NullScheduledFuture INSTANCE = new NullScheduledFuture();\n          \n          \n            \n            \n          \n          \n            \n                private NullScheduledFuture() {\n          \n          \n            \n                    // nothing\n          \n          \n            \n                }", "author": "cpmeister", "createdAt": "2020-06-08T18:54:23Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/NullScheduledFuture.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Empty ScheduledFuture, used for initialization.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class NullScheduledFuture implements ScheduledFuture<Object> {\n+    @NonNullByDefault({})\n+    private static class LazyHolder {\n+        static final NullScheduledFuture INSTANCE = new NullScheduledFuture();\n+    }\n+\n+    private NullScheduledFuture() {\n+        // nothing\n+    }\n+\n+    /** Gets the instance of this singleton. */\n+    public static NullScheduledFuture getInstance() {\n+        return LazyHolder.INSTANCE;\n+    }", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkyNDUzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436924531", "bodyText": "Are you sure you want to exit here instead of capping the percent value?", "author": "cpmeister", "createdAt": "2020-06-08T18:57:46Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/subhandler/LcnModuleOutputSubHandler.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.subhandler;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.openhab.binding.lcn.internal.LcnModuleHandler;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handles Commands and State changes of dimmer outputs of an LCN module.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleOutputSubHandler extends AbstractLcnModuleSubHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleOutputSubHandler.class);\n+    private static final int COLOR_RAMP_MS = 1000;\n+    private static final String OUTPUT_COLOR = \"color\";\n+    private static final Pattern PERCENT_PATTERN;\n+    private static final Pattern NATIVE_PATTERN;\n+    private volatile HSBType currentColor = new HSBType();\n+    private volatile PercentType output4 = new PercentType();\n+\n+    public LcnModuleOutputSubHandler(LcnModuleHandler handler, ModInfo info) {\n+        super(handler, info);\n+    }\n+\n+    static {\n+        PERCENT_PATTERN = Pattern.compile(LcnBindingConstants.ADDRESS_REGEX + \"A(?<outputId>\\\\d)(?<percent>\\\\d+)\");\n+        NATIVE_PATTERN = Pattern.compile(LcnBindingConstants.ADDRESS_REGEX + \"O(?<outputId>\\\\d)(?<value>\\\\d+)\");\n+    }\n+\n+    @Override\n+    public Collection<Pattern> getPckStatusMessagePatterns() {\n+        return Arrays.asList(NATIVE_PATTERN, PERCENT_PATTERN);\n+    }\n+\n+    @Override\n+    public void handleRefresh(LcnChannelGroup channelGroup, int number) {\n+        info.refreshOutput(number);\n+    }\n+\n+    @Override\n+    public void handleRefresh(String groupId) {\n+        if (OUTPUT_COLOR.equals(groupId)) {\n+            info.refreshAllOutputs();\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommandOnOff(OnOffType command, LcnChannelGroup channelGroup, int number) throws LcnException {\n+        // don't use OnOffType.as() here, because it returns @Nullable\n+        handler.sendPck(PckGenerator.dimOutput(number, command == OnOffType.ON ? 100 : 0, 0));\n+    }\n+\n+    @Override\n+    public void handleCommandPercent(PercentType command, LcnChannelGroup channelGroup, int number)\n+            throws LcnException {\n+        handler.sendPck(PckGenerator.dimOutput(number, command.doubleValue(), 0));\n+    }\n+\n+    @Override\n+    public void handleCommandPercent(PercentType command, LcnChannelGroup channelGroup, String idWithoutGroup)\n+            throws LcnException {\n+        if (!OUTPUT_COLOR.equals(idWithoutGroup)) {\n+            throw new LcnException(\"Unknown group ID: \" + idWithoutGroup);\n+        }\n+        updateAndSendColor(new HSBType(currentColor.getHue(), currentColor.getSaturation(), command));\n+    }\n+\n+    @Override\n+    public void handleCommandHsb(HSBType command, String groupId) throws LcnException {\n+        if (!OUTPUT_COLOR.equals(groupId)) {\n+            throw new LcnException(\"Unknown group ID: \" + groupId);\n+        }\n+        updateAndSendColor(command);\n+    }\n+\n+    private synchronized void updateAndSendColor(HSBType hsbType) throws LcnException {\n+        currentColor = hsbType;\n+        handler.updateChannel(LcnChannelGroup.OUTPUT, OUTPUT_COLOR, currentColor);\n+\n+        if (info.getFirmwareVersion() >= LcnBindingConstants.FIRMWARE_2014) {\n+            handler.sendPck(PckGenerator.dimAllOutputs(currentColor.getRed().doubleValue(),\n+                    currentColor.getGreen().doubleValue(), currentColor.getBlue().doubleValue(), output4.doubleValue(),\n+                    COLOR_RAMP_MS));\n+        } else {\n+            handler.sendPck(PckGenerator.dimOutput(0, currentColor.getRed().doubleValue(), COLOR_RAMP_MS));\n+            handler.sendPck(PckGenerator.dimOutput(1, currentColor.getGreen().doubleValue(), COLOR_RAMP_MS));\n+            handler.sendPck(PckGenerator.dimOutput(2, currentColor.getBlue().doubleValue(), COLOR_RAMP_MS));\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommandDimmerOutput(DimmerOutputCommand command, int number) throws LcnException {\n+        int rampMs = command.getRampMs();\n+        if (command.isControlAllOutputs()) { // control all dimmer outputs\n+            if (rampMs == LcnDefs.FIXED_RAMP_MS) {\n+                // compatibility command\n+                handler.sendPck(PckGenerator.controlAllOutputs(command.intValue()));\n+            } else {\n+                // command since firmware 180501\n+                handler.sendPck(PckGenerator.dimAllOutputs(command.doubleValue(), command.doubleValue(),\n+                        command.doubleValue(), command.doubleValue(), rampMs));\n+            }\n+        } else if (command.isControlOutputs12()) { // control dimmer outputs 1+2\n+            if (command.intValue() == 0 || command.intValue() == 100) {\n+                handler.sendPck(PckGenerator.controlOutputs12(command.intValue() > 0, rampMs >= LcnDefs.FIXED_RAMP_MS));\n+            } else {\n+                // ignore ramp when dimming\n+                handler.sendPck(PckGenerator.dimOutputs12(command.doubleValue()));\n+            }\n+        } else {\n+            handler.sendPck(PckGenerator.dimOutput(number, command.doubleValue(), rampMs));\n+        }\n+    }\n+\n+    @Override\n+    public void handleStatusMessage(Matcher matcher) {\n+        int outputId = Integer.parseInt(matcher.group(\"outputId\")) - 1;\n+\n+        if (!LcnChannelGroup.OUTPUT.isValidId(outputId)) {\n+            logger.warn(\"outputId out of range: {}\", outputId);\n+            return;\n+        }\n+        double percent;\n+        if (matcher.pattern() == PERCENT_PATTERN) {\n+            percent = Integer.parseInt(matcher.group(\"percent\"));\n+        } else if (matcher.pattern() == NATIVE_PATTERN) {\n+            percent = (double) Integer.parseInt(matcher.group(\"value\")) / 2;\n+        } else {\n+            logger.warn(\"Unexpected pattern: {}\", matcher.pattern());\n+            return;\n+        }\n+        if (percent < 0 || percent > 100) {\n+            logger.warn(\"Output value out of range: {}\", percent);\n+            return;", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkyNTgwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436925809", "bodyText": "This synchronization doesn't do anything.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        synchronized (this) {\n          \n          \n            \n                            output4 = percentType;\n          \n          \n            \n                        }\n          \n          \n            \n                        output4 = percentType;", "author": "cpmeister", "createdAt": "2020-06-08T19:00:09Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/subhandler/LcnModuleOutputSubHandler.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.subhandler;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.openhab.binding.lcn.internal.LcnModuleHandler;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handles Commands and State changes of dimmer outputs of an LCN module.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleOutputSubHandler extends AbstractLcnModuleSubHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleOutputSubHandler.class);\n+    private static final int COLOR_RAMP_MS = 1000;\n+    private static final String OUTPUT_COLOR = \"color\";\n+    private static final Pattern PERCENT_PATTERN;\n+    private static final Pattern NATIVE_PATTERN;\n+    private volatile HSBType currentColor = new HSBType();\n+    private volatile PercentType output4 = new PercentType();\n+\n+    public LcnModuleOutputSubHandler(LcnModuleHandler handler, ModInfo info) {\n+        super(handler, info);\n+    }\n+\n+    static {\n+        PERCENT_PATTERN = Pattern.compile(LcnBindingConstants.ADDRESS_REGEX + \"A(?<outputId>\\\\d)(?<percent>\\\\d+)\");\n+        NATIVE_PATTERN = Pattern.compile(LcnBindingConstants.ADDRESS_REGEX + \"O(?<outputId>\\\\d)(?<value>\\\\d+)\");\n+    }\n+\n+    @Override\n+    public Collection<Pattern> getPckStatusMessagePatterns() {\n+        return Arrays.asList(NATIVE_PATTERN, PERCENT_PATTERN);\n+    }\n+\n+    @Override\n+    public void handleRefresh(LcnChannelGroup channelGroup, int number) {\n+        info.refreshOutput(number);\n+    }\n+\n+    @Override\n+    public void handleRefresh(String groupId) {\n+        if (OUTPUT_COLOR.equals(groupId)) {\n+            info.refreshAllOutputs();\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommandOnOff(OnOffType command, LcnChannelGroup channelGroup, int number) throws LcnException {\n+        // don't use OnOffType.as() here, because it returns @Nullable\n+        handler.sendPck(PckGenerator.dimOutput(number, command == OnOffType.ON ? 100 : 0, 0));\n+    }\n+\n+    @Override\n+    public void handleCommandPercent(PercentType command, LcnChannelGroup channelGroup, int number)\n+            throws LcnException {\n+        handler.sendPck(PckGenerator.dimOutput(number, command.doubleValue(), 0));\n+    }\n+\n+    @Override\n+    public void handleCommandPercent(PercentType command, LcnChannelGroup channelGroup, String idWithoutGroup)\n+            throws LcnException {\n+        if (!OUTPUT_COLOR.equals(idWithoutGroup)) {\n+            throw new LcnException(\"Unknown group ID: \" + idWithoutGroup);\n+        }\n+        updateAndSendColor(new HSBType(currentColor.getHue(), currentColor.getSaturation(), command));\n+    }\n+\n+    @Override\n+    public void handleCommandHsb(HSBType command, String groupId) throws LcnException {\n+        if (!OUTPUT_COLOR.equals(groupId)) {\n+            throw new LcnException(\"Unknown group ID: \" + groupId);\n+        }\n+        updateAndSendColor(command);\n+    }\n+\n+    private synchronized void updateAndSendColor(HSBType hsbType) throws LcnException {\n+        currentColor = hsbType;\n+        handler.updateChannel(LcnChannelGroup.OUTPUT, OUTPUT_COLOR, currentColor);\n+\n+        if (info.getFirmwareVersion() >= LcnBindingConstants.FIRMWARE_2014) {\n+            handler.sendPck(PckGenerator.dimAllOutputs(currentColor.getRed().doubleValue(),\n+                    currentColor.getGreen().doubleValue(), currentColor.getBlue().doubleValue(), output4.doubleValue(),\n+                    COLOR_RAMP_MS));\n+        } else {\n+            handler.sendPck(PckGenerator.dimOutput(0, currentColor.getRed().doubleValue(), COLOR_RAMP_MS));\n+            handler.sendPck(PckGenerator.dimOutput(1, currentColor.getGreen().doubleValue(), COLOR_RAMP_MS));\n+            handler.sendPck(PckGenerator.dimOutput(2, currentColor.getBlue().doubleValue(), COLOR_RAMP_MS));\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommandDimmerOutput(DimmerOutputCommand command, int number) throws LcnException {\n+        int rampMs = command.getRampMs();\n+        if (command.isControlAllOutputs()) { // control all dimmer outputs\n+            if (rampMs == LcnDefs.FIXED_RAMP_MS) {\n+                // compatibility command\n+                handler.sendPck(PckGenerator.controlAllOutputs(command.intValue()));\n+            } else {\n+                // command since firmware 180501\n+                handler.sendPck(PckGenerator.dimAllOutputs(command.doubleValue(), command.doubleValue(),\n+                        command.doubleValue(), command.doubleValue(), rampMs));\n+            }\n+        } else if (command.isControlOutputs12()) { // control dimmer outputs 1+2\n+            if (command.intValue() == 0 || command.intValue() == 100) {\n+                handler.sendPck(PckGenerator.controlOutputs12(command.intValue() > 0, rampMs >= LcnDefs.FIXED_RAMP_MS));\n+            } else {\n+                // ignore ramp when dimming\n+                handler.sendPck(PckGenerator.dimOutputs12(command.doubleValue()));\n+            }\n+        } else {\n+            handler.sendPck(PckGenerator.dimOutput(number, command.doubleValue(), rampMs));\n+        }\n+    }\n+\n+    @Override\n+    public void handleStatusMessage(Matcher matcher) {\n+        int outputId = Integer.parseInt(matcher.group(\"outputId\")) - 1;\n+\n+        if (!LcnChannelGroup.OUTPUT.isValidId(outputId)) {\n+            logger.warn(\"outputId out of range: {}\", outputId);\n+            return;\n+        }\n+        double percent;\n+        if (matcher.pattern() == PERCENT_PATTERN) {\n+            percent = Integer.parseInt(matcher.group(\"percent\"));\n+        } else if (matcher.pattern() == NATIVE_PATTERN) {\n+            percent = (double) Integer.parseInt(matcher.group(\"value\")) / 2;\n+        } else {\n+            logger.warn(\"Unexpected pattern: {}\", matcher.pattern());\n+            return;\n+        }\n+        if (percent < 0 || percent > 100) {\n+            logger.warn(\"Output value out of range: {}\", percent);\n+            return;\n+        }\n+        info.onOutputResponseReceived(outputId);\n+\n+        PercentType percentType = new PercentType((int) Math.round(percent));\n+        fireUpdate(LcnChannelGroup.OUTPUT, outputId, percentType);\n+\n+        if (outputId == 3) {\n+            synchronized (this) {\n+                output4 = percentType;\n+            }", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkzMjY0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436932648", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            fireUpdateAndReset(matcher, groupSuffix.orElse(i + \"\"), Variable.thrsIdToVar(registerNumber, i));\n          \n          \n            \n                            fireUpdateAndReset(matcher, groupSuffix.orElse(String.valueOf(i)), Variable.thrsIdToVar(registerNumber, i));", "author": "cpmeister", "createdAt": "2020-06-08T19:08:05Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/subhandler/LcnModuleThresholdSubHandler.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.subhandler;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.IntStream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.openhab.binding.lcn.internal.LcnModuleHandler;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+import org.openhab.binding.lcn.internal.common.Variable;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handles Commands and State changes of thresholds of an LCN module.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleThresholdSubHandler extends AbstractLcnModuleVariableSubHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleThresholdSubHandler.class);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(LcnBindingConstants.ADDRESS_REGEX + \"\\\\.T(?<registerId>\\\\d)(?<thresholdId>\\\\d)(?<value>\\\\d+)\");\n+    private static final Pattern PATTERN_BEFORE_2013 = Pattern.compile(LcnBindingConstants.ADDRESS_REGEX\n+            + \"\\\\.S1(?<value0>\\\\d{5})(?<value1>\\\\d{5})(?<value2>\\\\d{5})(?<value3>\\\\d{5})(?<value4>\\\\d{5})(?<hyst>\\\\d{5})\");\n+\n+    public LcnModuleThresholdSubHandler(LcnModuleHandler handler, ModInfo info) {\n+        super(handler, info);\n+    }\n+\n+    @Override\n+    public void handleCommandDecimal(DecimalType command, LcnChannelGroup channelGroup, int number)\n+            throws LcnException {\n+        Variable variable = getVariable(channelGroup, number);\n+        try {\n+            int relativeChange = getRelativeChange(command, variable);\n+            handler.sendPck(PckGenerator.setThresholdRelative(variable, LcnDefs.RelVarRef.CURRENT, relativeChange,\n+                    info.hasExtendedMeasurementProcessing()));\n+\n+            // request new value, if the module doesn't send it on itself\n+            if (variable.shouldPollStatusAfterCommand(info.getFirmwareVersion())) {\n+                info.refreshVariable(variable);\n+            }\n+        } catch (LcnException e) {\n+            // current value unknown for some reason, refresh it in case we come again here\n+            info.refreshVariable(variable);\n+            throw e;\n+        }\n+    }\n+\n+    @Override\n+    public void handleStatusMessage(Matcher matcher) {\n+        IntStream stream;\n+        Optional<String> groupSuffix;\n+        int registerNumber;\n+        if (matcher.pattern() == PATTERN) {\n+            int thresholdId = Integer.parseInt(matcher.group(\"thresholdId\")) - 1;\n+            registerNumber = Integer.parseInt(matcher.group(\"registerId\")) - 1;\n+            stream = IntStream.rangeClosed(thresholdId, thresholdId);\n+            groupSuffix = Optional.of(\"\");\n+        } else if (matcher.pattern() == PATTERN_BEFORE_2013) {\n+            stream = IntStream.range(0, LcnDefs.THRESHOLD_COUNT_BEFORE_2013);\n+            groupSuffix = Optional.empty();\n+            registerNumber = 0;\n+        } else {\n+            logger.warn(\"Unexpected pattern: {}\", matcher.pattern());\n+            return;\n+        }\n+\n+        stream.forEach(i -> {\n+            try {\n+                fireUpdateAndReset(matcher, groupSuffix.orElse(i + \"\"), Variable.thrsIdToVar(registerNumber, i));", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0NTUwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436945508", "bodyText": "You should also give a clue as to which AbstractLcnModuleSubHandler subclass this is since there isn't anyway for the user to know which handler this error refers to at the moment.", "author": "cpmeister", "createdAt": "2020-06-08T19:20:29Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/subhandler/AbstractLcnModuleSubHandler.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.subhandler;\n+\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.lcn.internal.LcnModuleHandler;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnDefs.RelayStateModifier;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.Variable;\n+import org.openhab.binding.lcn.internal.common.VariableValue;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Base class for LCN module Thing sub handlers.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractLcnModuleSubHandler implements ILcnModuleSubHandler {\n+    private final Logger logger = LoggerFactory.getLogger(AbstractLcnModuleSubHandler.class);\n+    protected LcnModuleHandler handler;\n+    protected ModInfo info;\n+\n+    public AbstractLcnModuleSubHandler(LcnModuleHandler handler, ModInfo info) {\n+        this.handler = handler;\n+        this.info = info;\n+    }\n+\n+    @Override\n+    public void handleRefresh(String groupId) {\n+        // can be overwritten by subclasses.\n+    }\n+\n+    @Override\n+    public void handleCommandOnOff(OnOffType command, LcnChannelGroup channelGroup, int number) throws LcnException {\n+        unsupportedCommand(command);\n+    }\n+\n+    @Override\n+    public void handleCommandPercent(PercentType command, LcnChannelGroup channelGroup, int number)\n+            throws LcnException {\n+        unsupportedCommand(command);\n+    }\n+\n+    @Override\n+    public void handleCommandPercent(PercentType command, LcnChannelGroup channelGroup, String idWithoutGroup)\n+            throws LcnException {\n+        unsupportedCommand(command);\n+    }\n+\n+    @Override\n+    public void handleCommandDecimal(DecimalType command, LcnChannelGroup channelGroup, int number)\n+            throws LcnException {\n+        unsupportedCommand(command);\n+    }\n+\n+    @Override\n+    public void handleCommandDimmerOutput(DimmerOutputCommand command, int number) throws LcnException {\n+        unsupportedCommand(command);\n+    }\n+\n+    @Override\n+    public void handleCommandString(StringType command, int number) throws LcnException {\n+        unsupportedCommand(command);\n+    }\n+\n+    @Override\n+    public void handleCommandUpDown(UpDownType command, LcnChannelGroup channelGroup, int number) throws LcnException {\n+        unsupportedCommand(command);\n+    }\n+\n+    @Override\n+    public void handleCommandStopMove(StopMoveType command, LcnChannelGroup channelGroup, int number)\n+            throws LcnException {\n+        unsupportedCommand(command);\n+    }\n+\n+    @Override\n+    public void handleCommandHsb(HSBType command, String groupId) throws LcnException {\n+        unsupportedCommand(command);\n+    }\n+\n+    private void unsupportedCommand(Command command) {\n+        logger.warn(\"Unsupported command: {}\", command.getClass().getSimpleName());", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0NTc2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436945762", "bodyText": "Can you make these final?", "author": "cpmeister", "createdAt": "2020-06-08T19:20:58Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/subhandler/AbstractLcnModuleSubHandler.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.subhandler;\n+\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.lcn.internal.LcnModuleHandler;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnDefs.RelayStateModifier;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.Variable;\n+import org.openhab.binding.lcn.internal.common.VariableValue;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Base class for LCN module Thing sub handlers.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractLcnModuleSubHandler implements ILcnModuleSubHandler {\n+    private final Logger logger = LoggerFactory.getLogger(AbstractLcnModuleSubHandler.class);\n+    protected LcnModuleHandler handler;\n+    protected ModInfo info;", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0NjcwNg==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436946706", "bodyText": "Can you make these final?", "author": "cpmeister", "createdAt": "2020-06-08T19:22:49Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/StateMachine.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implements a state machine for managing the connection to the LCN-PCK gateway. Setting states is thread-safe.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class StateMachine implements StateContext {\n+    private final Logger logger = LoggerFactory.getLogger(StateMachine.class);\n+    /** The StateMachine's current state */\n+    protected volatile AbstractConnectionState state;\n+    private Connection connection;\n+    private ScheduledExecutorService scheduler;", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0OTg2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436949868", "bodyText": "Since this is supposed to be a fixed sized list, perhaps an array would be more appropriate.", "author": "cpmeister", "createdAt": "2020-06-08T19:28:35Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/ModInfo.java", "diffHunk": "@@ -0,0 +1,500 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+import org.openhab.binding.lcn.internal.common.Variable;\n+import org.openhab.binding.lcn.internal.common.VariableValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Holds data of an LCN module.\n+ * <ul>\n+ * <li>Stores the module's firmware version (if requested)\n+ * <li>Manages the scheduling of status-requests\n+ * <li>Manages the scheduling of acknowledged commands\n+ * </ul>\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public class ModInfo {\n+    private final Logger logger = LoggerFactory.getLogger(ModInfo.class);\n+    /** Total number of request to sent before going into failed-state. */\n+    private static final int NUM_TRIES = 3;\n+\n+    /** Poll interval for status values that automatically send their values on change. */\n+    private static final int MAX_STATUS_EVENTBASED_VALUEAGE_MSEC = 600000;\n+\n+    /** Poll interval for status values that do not send their values on change (always polled). */\n+    private static final int MAX_STATUS_POLLED_VALUEAGE_MSEC = 30000;\n+\n+    /** Status request delay after a command has been send which potentially changed that status. */\n+    private static final int STATUS_REQUEST_DELAY_AFTER_COMMAND_MSEC = 2000;\n+\n+    /** The LCN module's address. */\n+    private final LcnAddrMod addr;\n+\n+    /** Firmware date of the LCN module. -1 means \"unknown\". */\n+    private int firmwareVersion = -1;\n+\n+    /** Firmware version request status. */\n+    private final RequestStatus requestFirmwareVersion = new RequestStatus(-1, NUM_TRIES, \"Firmware Version\");\n+\n+    /** Output-port request status (0..3). */\n+    private final ArrayList<RequestStatus> requestStatusOutputs = new ArrayList<>();", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1MDgwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436950802", "bodyText": "I suggest turning this into a utility function since it gets used so much.", "author": "cpmeister", "createdAt": "2020-06-08T19:30:16Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/ModInfo.java", "diffHunk": "@@ -0,0 +1,500 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+import org.openhab.binding.lcn.internal.common.Variable;\n+import org.openhab.binding.lcn.internal.common.VariableValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Holds data of an LCN module.\n+ * <ul>\n+ * <li>Stores the module's firmware version (if requested)\n+ * <li>Manages the scheduling of status-requests\n+ * <li>Manages the scheduling of acknowledged commands\n+ * </ul>\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public class ModInfo {\n+    private final Logger logger = LoggerFactory.getLogger(ModInfo.class);\n+    /** Total number of request to sent before going into failed-state. */\n+    private static final int NUM_TRIES = 3;\n+\n+    /** Poll interval for status values that automatically send their values on change. */\n+    private static final int MAX_STATUS_EVENTBASED_VALUEAGE_MSEC = 600000;\n+\n+    /** Poll interval for status values that do not send their values on change (always polled). */\n+    private static final int MAX_STATUS_POLLED_VALUEAGE_MSEC = 30000;\n+\n+    /** Status request delay after a command has been send which potentially changed that status. */\n+    private static final int STATUS_REQUEST_DELAY_AFTER_COMMAND_MSEC = 2000;\n+\n+    /** The LCN module's address. */\n+    private final LcnAddrMod addr;\n+\n+    /** Firmware date of the LCN module. -1 means \"unknown\". */\n+    private int firmwareVersion = -1;\n+\n+    /** Firmware version request status. */\n+    private final RequestStatus requestFirmwareVersion = new RequestStatus(-1, NUM_TRIES, \"Firmware Version\");\n+\n+    /** Output-port request status (0..3). */\n+    private final ArrayList<RequestStatus> requestStatusOutputs = new ArrayList<>();\n+\n+    /** Relays request status (all 8). */\n+    private final RequestStatus requestStatusRelays = new RequestStatus(MAX_STATUS_EVENTBASED_VALUEAGE_MSEC, NUM_TRIES,\n+            \"Relays\");\n+\n+    /** Binary-sensors request status (all 8). */\n+    private final RequestStatus requestStatusBinSensors = new RequestStatus(MAX_STATUS_EVENTBASED_VALUEAGE_MSEC,\n+            NUM_TRIES, \"Binary Sensors\");\n+\n+    /**\n+     * Variables request status.\n+     * Lazy initialization: Will be filled once the firmware version is known.\n+     */\n+    private final Map<Variable, RequestStatus> requestStatusVars = new TreeMap<>();\n+\n+    /**\n+     * Caches the values of the variables, needed for changing the values.\n+     */\n+    private final Map<Variable, VariableValue> variableValue = new TreeMap<>();\n+\n+    /** LEDs and logic-operations request status (all 12+4). */\n+    private final RequestStatus requestStatusLedsAndLogicOps = new RequestStatus(MAX_STATUS_POLLED_VALUEAGE_MSEC,\n+            NUM_TRIES, \"LEDs and Logic\");\n+\n+    /** Key lock-states request status (all tables, A-D). */\n+    private final RequestStatus requestStatusLockedKeys = new RequestStatus(MAX_STATUS_POLLED_VALUEAGE_MSEC, NUM_TRIES,\n+            \"Key Locks\");\n+\n+    /**\n+     * Holds the last LCN variable requested whose response will not contain the variable's type.\n+     * {@link Variable#UNKNOWN} means there is currently no such request.\n+     */\n+    private Variable lastRequestedVarWithoutTypeInResponse = Variable.UNKNOWN;\n+\n+    /**\n+     * List of queued PCK commands to be acknowledged by the LCN module.\n+     * Commands are always without address header.\n+     * Note that the first one might currently be \"in progress\".\n+     */\n+    private final LinkedList<@Nullable ByteBuffer> pckCommandsWithAck = new LinkedList<>();\n+\n+    /** Status data for the currently processed {@link PckCommandWithAck}. */\n+    private final RequestStatus requestCurrentPckCommandWithAck = new RequestStatus(-1, NUM_TRIES, \"Commands with Ack\");\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param addr the module's address\n+     */\n+    public ModInfo(LcnAddrMod addr) {\n+        this.addr = addr;\n+        for (int i = 0; i < LcnChannelGroup.OUTPUT.getCount(); ++i) {\n+            this.requestStatusOutputs\n+                    .add(new RequestStatus(MAX_STATUS_EVENTBASED_VALUEAGE_MSEC, NUM_TRIES, \"Output \" + (i + 1)));\n+        }\n+\n+        for (Variable var : Variable.values()) {\n+            if (var != Variable.UNKNOWN) {\n+                this.requestStatusVars.put(var, new RequestStatus(MAX_STATUS_POLLED_VALUEAGE_MSEC, NUM_TRIES,\n+                        var.getType() + \" \" + (var.getNumber() + 1)));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Gets the last requested variable whose response will not contain the variables type.\n+     *\n+     * @return the \"typeless\" variable\n+     */\n+    public Variable getLastRequestedVarWithoutTypeInResponse() {\n+        return this.lastRequestedVarWithoutTypeInResponse;\n+    }\n+\n+    /**\n+     * Sets the last requested variable whose response will not contain the variables type.\n+     *\n+     * @param var the \"typeless\" variable\n+     */\n+    public void setLastRequestedVarWithoutTypeInResponse(Variable var) {\n+        this.lastRequestedVarWithoutTypeInResponse = var;\n+    }\n+\n+    /**\n+     * Queues a PCK command to be sent.\n+     * It will request an acknowledge from the LCN module on receipt.\n+     * If there is no response within the request timeout, the command is retried.\n+     *\n+     * @param data the PCK command to send (without address header)\n+     * @param timeoutMSec the time to wait for a response before retrying a request\n+     * @param currTime the current time stamp\n+     */\n+    public void queuePckCommandWithAck(ByteBuffer data, Connection conn, long timeoutMSec, long currTime) {\n+        this.pckCommandsWithAck.add(data);\n+        // Try to process the new acknowledged command. Will do nothing if another one is still in progress.\n+        this.tryProcessNextCommandWithAck(conn, timeoutMSec, currTime);\n+    }\n+\n+    /**\n+     * Called whenever an acknowledge is received from the LCN module.\n+     *\n+     * @param code the LCN internal code. -1 means \"positive\" acknowledge\n+     * @param timeoutMSec the time to wait for a response before retrying a request\n+     * @param currTime the current time stamp\n+     */\n+    public void onAck(int code, Connection conn, long timeoutMSec, long currTime) {\n+        if (this.requestCurrentPckCommandWithAck.isActive()) { // Check if we wait for an ack.\n+            this.pckCommandsWithAck.pollFirst();\n+            this.requestCurrentPckCommandWithAck.reset();\n+            // Try to process next acknowledged command\n+            this.tryProcessNextCommandWithAck(conn, timeoutMSec, currTime);\n+        }\n+    }\n+\n+    /**\n+     * Sends the next acknowledged command from the queue.\n+     *\n+     * @param conn the {@link Connection} belonging to this {@link ModInfo}\n+     * @param timeoutMSec the time to wait for a response before retrying a request\n+     * @param currTime the current time stamp\n+     * @return true if a new command was sent\n+     * @throws LcnException when a command response timed out\n+     */\n+    private boolean tryProcessNextCommandWithAck(Connection conn, long timeoutMSec, long currTime) {\n+        // Use the chance to remove a failed command first\n+        if (this.requestCurrentPckCommandWithAck.isFailed(timeoutMSec, currTime)) {\n+            ByteBuffer failedCommand = this.pckCommandsWithAck.pollFirst();\n+            this.requestCurrentPckCommandWithAck.reset();\n+\n+            if (failedCommand != null) {\n+                try {\n+                    logger.warn(\"{}: Module did not respond to command: {}\", addr,\n+                            new String(failedCommand.array(), LcnDefs.LCN_ENCODING));\n+                } catch (UnsupportedEncodingException e) {\n+                    // ignore\n+                }\n+            }\n+        }\n+        // Peek new command\n+        if (!this.pckCommandsWithAck.isEmpty() && !this.requestCurrentPckCommandWithAck.isActive()) {\n+            this.requestCurrentPckCommandWithAck.nextRequestIn(0, currTime);\n+        }\n+        ByteBuffer command = this.pckCommandsWithAck.peekFirst();\n+        if (command == null) {\n+            return false;\n+        }\n+        try {\n+            if (requestCurrentPckCommandWithAck.shouldSendNextRequest(timeoutMSec, currTime)) {\n+                conn.queueAndSend(new SendDataPck(addr, true, command));\n+                this.requestCurrentPckCommandWithAck.onRequestSent(currTime);\n+            }\n+        } catch (LcnException e) {\n+            try {\n+                logger.warn(\"{}: Could not send command: {}: {}\", addr,\n+                        new String(command.array(), LcnDefs.LCN_ENCODING), e.getMessage());\n+            } catch (UnsupportedEncodingException e1) {\n+                // ignore\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Triggers a request to retrieve the firmware version of the LCN module, if it is not known, yet.\n+     */\n+    public void requestFirmwareVersion() {\n+        if (firmwareVersion == -1) {\n+            requestFirmwareVersion.refresh();\n+        }\n+    }\n+\n+    /**\n+     * Used to check if the module has the measurement processing firmware (since Feb. 2013).\n+     *\n+     * @return if the module has at least 4 threshold registers and 12 variables\n+     */\n+    public boolean hasExtendedMeasurementProcessing() {\n+        if (firmwareVersion == -1) {\n+            logger.warn(\"LCN module firmware version unknown\");\n+            return false;\n+        }\n+        return firmwareVersion >= LcnBindingConstants.FIRMWARE_2013;\n+    }\n+\n+    /**\n+     * Keeps the request logic active.\n+     * Must be called periodically.\n+     *\n+     * @param conn the {@link Connection} belonging to this {@link ModInfo}\n+     * @param timeoutMSec the time to wait for a response before retrying a request\n+     * @param currTime the current time stamp\n+     */\n+    void update(Connection conn, long timeoutMSec, long currTime) {\n+        RequestStatus r;\n+        try {\n+            // Firmware request\n+            if ((r = this.requestFirmwareVersion).shouldSendNextRequest(timeoutMSec, currTime)) {\n+                conn.queue(this.addr, false, PckGenerator.requestSn());\n+                r.onRequestSent(currTime);\n+                return;\n+            }\n+            // Output-port requests\n+            for (int i = 0; i < 4; ++i) {\n+                if ((r = this.requestStatusOutputs.get(i)).shouldSendNextRequest(timeoutMSec, currTime)) {\n+                    conn.queue(this.addr, false, PckGenerator.requestOutputStatus(i));\n+                    r.onRequestSent(currTime);\n+                    return;\n+                }\n+            }\n+            // Relays request\n+            if ((r = this.requestStatusRelays).shouldSendNextRequest(timeoutMSec, currTime)) {\n+                conn.queue(this.addr, false, PckGenerator.requestRelaysStatus());\n+                r.onRequestSent(currTime);\n+                return;\n+            }\n+            // Binary-sensors request\n+            if ((r = this.requestStatusBinSensors).shouldSendNextRequest(timeoutMSec, currTime)) {\n+                conn.queue(this.addr, false, PckGenerator.requestBinSensorsStatus());\n+                r.onRequestSent(currTime);\n+                return;\n+            }\n+            // Variable requests\n+            if (this.firmwareVersion != -1) { // Firmware version is required\n+                // Use the chance to remove a failed \"typeless variable\" request\n+                if (this.lastRequestedVarWithoutTypeInResponse != Variable.UNKNOWN) {\n+                    if (this.requestStatusVars.get(this.lastRequestedVarWithoutTypeInResponse).isTimeout(timeoutMSec,\n+                            currTime)) {\n+                        this.lastRequestedVarWithoutTypeInResponse = Variable.UNKNOWN;\n+                    }\n+                }\n+                // Variables\n+                for (Map.Entry<Variable, RequestStatus> kv : this.requestStatusVars.entrySet()) {\n+                    if ((r = kv.getValue()).shouldSendNextRequest(timeoutMSec, currTime)) {\n+                        // Detect if we can send immediately or if we have to wait for a \"typeless\" request first\n+                        boolean hasTypeInResponse = kv.getKey().hasTypeInResponse(this.firmwareVersion);\n+                        if (hasTypeInResponse || this.lastRequestedVarWithoutTypeInResponse == Variable.UNKNOWN) {\n+                            try {\n+                                conn.queue(this.addr, false,\n+                                        PckGenerator.requestVarStatus(kv.getKey(), this.firmwareVersion));\n+                                r.onRequestSent(currTime);\n+                                if (!hasTypeInResponse) {\n+                                    this.lastRequestedVarWithoutTypeInResponse = kv.getKey();\n+                                }\n+                                return;\n+                            } catch (LcnException ex) {\n+                                r.reset();\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            // LEDs and logic-operations request\n+            if ((r = this.requestStatusLedsAndLogicOps).shouldSendNextRequest(timeoutMSec, currTime)) {\n+                conn.queue(this.addr, false, PckGenerator.requestLedsAndLogicOpsStatus());\n+                r.onRequestSent(currTime);\n+                return;\n+            }\n+            // Key-locks request\n+            if ((r = this.requestStatusLockedKeys).shouldSendNextRequest(timeoutMSec, currTime)) {\n+                conn.queue(this.addr, false, PckGenerator.requestKeyLocksStatus());\n+                r.onRequestSent(currTime);\n+                return;\n+            }", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1OTE1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436959152", "bodyText": "It would be better to use offlineSendQueue.drainTo here.", "author": "cpmeister", "createdAt": "2020-06-08T19:46:39Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/Connection.java", "diffHunk": "@@ -0,0 +1,505 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.AsynchronousSocketChannel;\n+import java.nio.channels.Channel;\n+import java.nio.channels.CompletionHandler;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrGrp;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class represents a configured connection to one LCN-PCHK.\n+ * It uses a {@link AsynchronousSocketChannel} to connect to LCN-PCHK.\n+ * Included logic:\n+ * <ul>\n+ * <li>Reconnection on connection loss\n+ * <li>Segment scan (to detect the local segment ID)\n+ * <li>Acknowledge handling\n+ * <li>Periodic value requests\n+ * <li>Caching of runtime data about the underlying LCN bus\n+ * </ul>\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class Connection {\n+    private final Logger logger = LoggerFactory.getLogger(Connection.class);\n+    /** Max. lengths of a PCK string including address and line feed. Currently dynamic text (GTDT) */\n+    private static final int MAX_PCK_STRING_LENGTH = 34;\n+    private static final int BROADCAST_MODULE_ID = 3;\n+    private static final int BROADCAST_SEGMENT_ID = 3;\n+    private final ConnectionSettings settings;\n+    private final ConnectionCallback callback;\n+    @Nullable\n+    private AsynchronousSocketChannel channel;\n+    /** The local segment id. -1 means \"unknown\". */\n+    private int localSegId;\n+    private final ByteBuffer readBuffer = ByteBuffer.allocate(1024);\n+    private final ByteBuffer sendBuffer = ByteBuffer.allocate(MAX_PCK_STRING_LENGTH);\n+    private final Queue<@Nullable SendData> sendQueue = new LinkedBlockingQueue<>();\n+    private final Queue<@Nullable PckQueueItem> offlineSendQueue = new LinkedBlockingQueue<>();\n+    private final Map<LcnAddr, @Nullable ModInfo> modData = Collections.synchronizedMap(new HashMap<>());\n+    private volatile boolean writeInProgress;\n+    private ScheduledExecutorService scheduler;\n+    private StateMachine stateMachine;\n+\n+    /**\n+     * Constructs a clean (disconnected) connection with the given settings.\n+     * This does not start the actual connection process.\n+     *\n+     * @param sets the settings to use for the new connection\n+     * @param callback the callback to the owner\n+     * @throws IOException\n+     */\n+    public Connection(ConnectionSettings sets, ScheduledExecutorService scheduler, ConnectionCallback callback) {\n+        this.settings = sets;\n+        this.callback = callback;\n+        this.scheduler = scheduler;\n+        this.clearRuntimeData();\n+\n+        stateMachine = new StateMachine(this, scheduler);\n+        stateMachine.startWorking();\n+    }\n+\n+    /** Clears all runtime data. */\n+    void clearRuntimeData() {\n+        this.channel = null;\n+        this.localSegId = -1;\n+        this.readBuffer.clear();\n+        this.sendQueue.clear();\n+        this.sendBuffer.clear();\n+    }\n+\n+    /**\n+     * Retrieves the settings for this connection (never changed).\n+     *\n+     * @return the settings\n+     */\n+    public ConnectionSettings getSettings() {\n+        return this.settings;\n+    }\n+\n+    private boolean isSocketConnected() {\n+        try {\n+            AsynchronousSocketChannel localChannel = channel;\n+            return localChannel != null && localChannel.getRemoteAddress() != null;\n+        } catch (IOException e) {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Sets the local segment id.\n+     *\n+     * @param localSegId the new local segment id\n+     */\n+    public void setLocalSegId(int localSegId) {\n+        this.localSegId = localSegId;\n+    }\n+\n+    /**\n+     * Called whenever an acknowledge is received.\n+     *\n+     * @param addr the source LCN module\n+     * @param code the LCN internal code (-1 = \"positive\")\n+     */\n+    public void onAck(LcnAddrMod addr, int code) {\n+        ModInfo info = this.modData.get(addr);\n+        if (info != null) {\n+            info.onAck(code, this, this.settings.getTimeout(), System.nanoTime());\n+        }\n+    }\n+\n+    /**\n+     * Creates and/or returns cached data for the given LCN module.\n+     *\n+     * @param addr the module's address\n+     * @return the data (never null)\n+     */\n+    public ModInfo updateModuleData(LcnAddrMod addr) {\n+        synchronized (modData) {\n+            ModInfo data = this.modData.get(addr);\n+            if (data == null) {\n+                data = new ModInfo(addr);\n+                this.modData.put(addr, data);\n+            }\n+            return data;\n+        }\n+    }\n+\n+    /**\n+     * Reads and processes input from the underlying channel.\n+     * Fragmented input is kept in {@link #readBuffer} and will be processed with the next call.\n+     *\n+     * @throws IOException if connection was closed or a generic channel error occurred\n+     */\n+    void readAndProcess() {\n+        AsynchronousSocketChannel localChannel = channel;\n+        if (localChannel != null && isSocketConnected()) {\n+            localChannel.read(readBuffer, null, new CompletionHandler<@Nullable Integer, @Nullable Void>() {\n+                @Override\n+                public void completed(@Nullable Integer transmittedByteCount, @Nullable Void attachment) {\n+                    synchronized (Connection.this) {\n+                        if (transmittedByteCount == null || transmittedByteCount == -1) {\n+                            String msg = \"Connection was closed by foreign host.\";\n+                            stateMachine.handleConnectionFailed(new LcnException(msg));\n+                        } else {\n+                            try {\n+                                // read data chunks from socket and separate frames\n+                                readBuffer.flip();\n+                                int aPos = readBuffer.position(); // 0\n+                                String s = new String(readBuffer.array(), aPos, transmittedByteCount,\n+                                        LcnDefs.LCN_ENCODING);\n+                                int pos1 = 0, pos2 = s.indexOf(PckGenerator.TERMINATION, pos1);\n+                                while (pos2 != -1) {\n+                                    String data = s.substring(pos1, pos2);\n+                                    if (logger.isTraceEnabled()) {\n+                                        logger.trace(\"Received: '{}'\", data);\n+                                    }\n+                                    scheduler.submit(() -> {\n+                                        stateMachine.onInputReceived(data);\n+                                        callback.onPckMessageReceived(data);\n+                                    });\n+                                    // Seek position in input array\n+                                    aPos += s.substring(pos1, pos2 + 1).getBytes(LcnDefs.LCN_ENCODING).length;\n+                                    // Next input\n+                                    pos1 = pos2 + 1;\n+                                    pos2 = s.indexOf(PckGenerator.TERMINATION, pos1);\n+                                }\n+                                readBuffer.limit(readBuffer.capacity());\n+                                readBuffer.position(transmittedByteCount - aPos); // Keeps fragments for the next call\n+                            } catch (UnsupportedEncodingException ex) {\n+                                logger.warn(\"Unable to decode input from channel \\\"{}\\\": {}\", settings.getId(),\n+                                        ex.getMessage());\n+                            }\n+\n+                            if (isSocketConnected()) {\n+                                readAndProcess();\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void failed(@Nullable Throwable e, @Nullable Void attachment) {\n+                    logger.debug(\"Lost connection\");\n+                    stateMachine.handleConnectionFailed(e);\n+                }\n+            });\n+        } else {\n+            stateMachine.handleConnectionFailed(new LcnException(\"Socket not open\"));\n+        }\n+    }\n+\n+    /**\n+     * Writes all queued data.\n+     * Will try to write all data at once to reduce overhead.\n+     */\n+    public synchronized void triggerWriteToSocket() {\n+        AsynchronousSocketChannel localChannel = channel;\n+        if (localChannel == null || !isSocketConnected() || writeInProgress) {\n+            return;\n+        }\n+        sendBuffer.clear();\n+        SendData item = sendQueue.poll();\n+\n+        if (item != null) {\n+            try {\n+                if (!item.write(sendBuffer, localSegId)) {\n+                    logger.warn(\"Data loss: Could not write packet into send buffer\");\n+                }\n+\n+                writeInProgress = true;\n+                sendBuffer.flip();\n+                localChannel.write(sendBuffer, null, new CompletionHandler<@Nullable Integer, @Nullable Void>() {\n+                    @Override\n+                    public void completed(@Nullable Integer result, @Nullable Void attachment) {\n+                        synchronized (Connection.this) {\n+                            if (result != sendBuffer.limit()) {\n+                                logger.warn(\"Data loss while writing to channel: {}\", settings.getAddress());\n+                            } else {\n+                                if (logger.isTraceEnabled()) {\n+                                    logger.trace(\"Sent: {}\", new String(sendBuffer.array(), 0, sendBuffer.limit()));\n+                                }\n+                            }\n+\n+                            writeInProgress = false;\n+\n+                            if (sendQueue.size() > 0) {\n+                                /**\n+                                 * This could lead to stack overflows, since the CompletionHandler may run in the same\n+                                 * Thread as triggerWriteToSocket() is invoked (see\n+                                 * {@link AsynchronousChannelGroup}/Threading), but we do not expect as much data\n+                                 * in one chunk here, that the stack can be filled in a critical way.\n+                                 */\n+                                triggerWriteToSocket();\n+                            }\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void failed(@Nullable Throwable exc, @Nullable Void attachment) {\n+                        synchronized (Connection.this) {\n+                            if (exc != null) {\n+                                logger.warn(\"Writing to channel \\\"{}\\\" failed: {}\", settings.getAddress(),\n+                                        exc.getMessage());\n+                            }\n+                            writeInProgress = false;\n+                            stateMachine.handleConnectionFailed(new LcnException(\"write() failed\"));\n+                        }\n+                    }\n+                });\n+            } catch (UnsupportedEncodingException | BufferOverflowException e) {\n+                logger.warn(\"Sending failed: {}: {}: {}\", item, e.getClass().getSimpleName(), e.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Queues plain text to be sent to LCN-PCHK.\n+     * Sending will be done the next time {@link #triggerWriteToSocket()} is called.\n+     *\n+     * @param plainText the text\n+     */\n+    public void queueDirectlyPlainText(String plainText) {\n+        this.queueAndSend(new SendDataPlainText(plainText));\n+    }\n+\n+    /**\n+     * Queues a PCK command to be sent.\n+     *\n+     * @param addr the target LCN address\n+     * @param wantsAck true to wait for acknowledge on receipt (should be false for group addresses)\n+     * @param pck the pure PCK command (without address header)\n+     */\n+    void queueDirectly(LcnAddr addr, boolean wantsAck, String pck) {\n+        try {\n+            this.queueDirectly(addr, wantsAck, ByteBuffer.wrap(pck.getBytes(LcnDefs.LCN_ENCODING)));\n+        } catch (UnsupportedEncodingException ex) {\n+            logger.error(\"Failed to encode PCK command: {}\", pck);\n+        }\n+    }\n+\n+    /**\n+     * Queues a PCK command for immediate sending, regardless of the Connection state. The PCK command is automatically\n+     * re-sent if the destination is not a group, an Ack is requested and the module did not answer within the expected\n+     * time.\n+     *\n+     * @param addr the target LCN address\n+     * @param wantsAck true to wait for acknowledge on receipt (should be false for group addresses)\n+     * @param data the pure PCK command (without address header)\n+     */\n+    void queueDirectly(LcnAddr addr, boolean wantsAck, ByteBuffer data) {\n+        if (!addr.isGroup() && wantsAck) {\n+            this.updateModuleData((LcnAddrMod) addr).queuePckCommandWithAck(data, this, this.settings.getTimeout(),\n+                    System.nanoTime());\n+        } else {\n+            this.queueAndSend(new SendDataPck(addr, false, data));\n+        }\n+    }\n+\n+    /**\n+     * Enqueues a raw PCK command and triggers the socket to start sending, if it does not already. Does not take care\n+     * of any Acks.\n+     *\n+     * @param data raw PCK command\n+     */\n+    synchronized void queueAndSend(SendData data) {\n+        this.sendQueue.add(data);\n+\n+        triggerWriteToSocket();\n+    }\n+\n+    /**\n+     * Enqueues a PCK command to the offline queue. Data will be sent when the Connection state will enter\n+     * {@link ConnectionStateConnected}.\n+     *\n+     * @param addr LCN module address\n+     * @param wantsAck true, if the LCN module shall respond with an Ack on successful processing\n+     * @param data the pure PCK command (without address header)\n+     */\n+    void queueOffline(LcnAddr addr, boolean wantsAck, ByteBuffer data) {\n+        offlineSendQueue.add(new PckQueueItem(addr, wantsAck, data));\n+    }\n+\n+    /**\n+     * Enqueues a PCK command for sending. Takes care of the Connection state and buffers the command for a specific\n+     * time if the Connection is not ready. If an Ack is requested, the PCK command is automatically\n+     * re-sent, if the module did not answer in the expected time.\n+     *\n+     * @param addr LCN module address\n+     * @param wantsAck true, if the LCN module shall respond with an Ack on successful processing\n+     * @param pck the pure PCK command (without address header)\n+     */\n+    public void queue(LcnAddr addr, boolean wantsAck, String pck) {\n+        try {\n+            this.queue(addr, wantsAck, ByteBuffer.wrap(pck.getBytes(LcnDefs.LCN_ENCODING)));\n+        } catch (UnsupportedEncodingException ex) {\n+            logger.warn(\"Failed to encode PCK command: {}\", pck);\n+        }\n+    }\n+\n+    /**\n+     * Enqueues a PCK command for sending. Takes care of the Connection state and buffers the command for a specific\n+     * time if the Connection is not ready. If an Ack is requested, the PCK command is automatically\n+     * re-sent, if the module did not answer in the expected time.\n+     *\n+     * @param addr LCN module address\n+     * @param wantsAck true, if the LCN module shall respond with an Ack on successful processing\n+     * @param pck the pure PCK command (without address header)\n+     */\n+    public void queue(LcnAddr addr, boolean wantsAck, ByteBuffer pck) {\n+        stateMachine.queue(addr, wantsAck, pck);\n+    }\n+\n+    /**\n+     * Process the offline PCK command queue. Does only send recently enqueued PCK commands, the rest is discarded.\n+     */\n+    void sendOfflineQueue() {\n+        // don't use forEach(), because elements can be added during iteration\n+        while (!offlineSendQueue.isEmpty()) {\n+            PckQueueItem item = offlineSendQueue.poll();", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk2NTEwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436965103", "bodyText": "Why not make this a CopyOnWriteArrayList instead?", "author": "cpmeister", "createdAt": "2020-06-08T19:58:11Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleHandler.java", "diffHunk": "@@ -0,0 +1,411 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.ByteBuffer;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.openhab.binding.lcn.internal.converter.AbstractVariableValueConverter;\n+import org.openhab.binding.lcn.internal.converter.AngleConverter;\n+import org.openhab.binding.lcn.internal.converter.Co2Converter;\n+import org.openhab.binding.lcn.internal.converter.CurrentConverter;\n+import org.openhab.binding.lcn.internal.converter.EnergyConverter;\n+import org.openhab.binding.lcn.internal.converter.IdentityConverter;\n+import org.openhab.binding.lcn.internal.converter.LightConverter;\n+import org.openhab.binding.lcn.internal.converter.PowerConverter;\n+import org.openhab.binding.lcn.internal.converter.TemperatureConverter;\n+import org.openhab.binding.lcn.internal.converter.VoltageConverter;\n+import org.openhab.binding.lcn.internal.converter.WindspeedConverter;\n+import org.openhab.binding.lcn.internal.subhandler.AbstractLcnModuleSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LcnModuleHandler} is responsible for handling commands, which are\n+ * sent to or received from one of the channels.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleHandler.class);\n+    private @Nullable LcnAddrMod moduleAddress;\n+    private Map<LcnChannelGroup, @Nullable AbstractLcnModuleSubHandler> subHandlers;\n+    private List<AbstractLcnModuleSubHandler> metadataSubHandlers;\n+    private Map<ChannelUID, @Nullable AbstractVariableValueConverter> converters;\n+\n+    public LcnModuleHandler(Thing thing) {\n+        super(thing);\n+\n+        subHandlers = Collections.synchronizedMap(new HashMap<>());\n+        metadataSubHandlers = Collections.synchronizedList(new LinkedList<>());", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk2NjIyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436966224", "bodyText": "It should be safe to leave this as a regular HashMap since you only perform read operations on it outside of initialize and dispose. But if you want to be extra safe use a ConcurrentHashMap instead.", "author": "cpmeister", "createdAt": "2020-06-08T20:00:21Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleHandler.java", "diffHunk": "@@ -0,0 +1,411 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.ByteBuffer;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.openhab.binding.lcn.internal.converter.AbstractVariableValueConverter;\n+import org.openhab.binding.lcn.internal.converter.AngleConverter;\n+import org.openhab.binding.lcn.internal.converter.Co2Converter;\n+import org.openhab.binding.lcn.internal.converter.CurrentConverter;\n+import org.openhab.binding.lcn.internal.converter.EnergyConverter;\n+import org.openhab.binding.lcn.internal.converter.IdentityConverter;\n+import org.openhab.binding.lcn.internal.converter.LightConverter;\n+import org.openhab.binding.lcn.internal.converter.PowerConverter;\n+import org.openhab.binding.lcn.internal.converter.TemperatureConverter;\n+import org.openhab.binding.lcn.internal.converter.VoltageConverter;\n+import org.openhab.binding.lcn.internal.converter.WindspeedConverter;\n+import org.openhab.binding.lcn.internal.subhandler.AbstractLcnModuleSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LcnModuleHandler} is responsible for handling commands, which are\n+ * sent to or received from one of the channels.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleHandler.class);\n+    private @Nullable LcnAddrMod moduleAddress;\n+    private Map<LcnChannelGroup, @Nullable AbstractLcnModuleSubHandler> subHandlers;\n+    private List<AbstractLcnModuleSubHandler> metadataSubHandlers;\n+    private Map<ChannelUID, @Nullable AbstractVariableValueConverter> converters;\n+\n+    public LcnModuleHandler(Thing thing) {\n+        super(thing);\n+\n+        subHandlers = Collections.synchronizedMap(new HashMap<>());\n+        metadataSubHandlers = Collections.synchronizedList(new LinkedList<>());\n+        converters = Collections.synchronizedMap(new HashMap<>());", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk2NjY2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436966662", "bodyText": "same here", "author": "cpmeister", "createdAt": "2020-06-08T20:01:10Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleHandler.java", "diffHunk": "@@ -0,0 +1,411 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.ByteBuffer;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.openhab.binding.lcn.internal.converter.AbstractVariableValueConverter;\n+import org.openhab.binding.lcn.internal.converter.AngleConverter;\n+import org.openhab.binding.lcn.internal.converter.Co2Converter;\n+import org.openhab.binding.lcn.internal.converter.CurrentConverter;\n+import org.openhab.binding.lcn.internal.converter.EnergyConverter;\n+import org.openhab.binding.lcn.internal.converter.IdentityConverter;\n+import org.openhab.binding.lcn.internal.converter.LightConverter;\n+import org.openhab.binding.lcn.internal.converter.PowerConverter;\n+import org.openhab.binding.lcn.internal.converter.TemperatureConverter;\n+import org.openhab.binding.lcn.internal.converter.VoltageConverter;\n+import org.openhab.binding.lcn.internal.converter.WindspeedConverter;\n+import org.openhab.binding.lcn.internal.subhandler.AbstractLcnModuleSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LcnModuleHandler} is responsible for handling commands, which are\n+ * sent to or received from one of the channels.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleHandler.class);\n+    private @Nullable LcnAddrMod moduleAddress;\n+    private Map<LcnChannelGroup, @Nullable AbstractLcnModuleSubHandler> subHandlers;\n+    private List<AbstractLcnModuleSubHandler> metadataSubHandlers;\n+    private Map<ChannelUID, @Nullable AbstractVariableValueConverter> converters;\n+\n+    public LcnModuleHandler(Thing thing) {\n+        super(thing);\n+\n+        subHandlers = Collections.synchronizedMap(new HashMap<>());", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk2ODQwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436968408", "bodyText": "Why not have each LcnChannelGroup enum instance include a AbstractLcnModuleSubHandler factory lambda method for creating class instances? That way you wouldn't need to use reflection here.", "author": "cpmeister", "createdAt": "2020-06-08T20:04:50Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleHandler.java", "diffHunk": "@@ -0,0 +1,411 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.ByteBuffer;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.openhab.binding.lcn.internal.converter.AbstractVariableValueConverter;\n+import org.openhab.binding.lcn.internal.converter.AngleConverter;\n+import org.openhab.binding.lcn.internal.converter.Co2Converter;\n+import org.openhab.binding.lcn.internal.converter.CurrentConverter;\n+import org.openhab.binding.lcn.internal.converter.EnergyConverter;\n+import org.openhab.binding.lcn.internal.converter.IdentityConverter;\n+import org.openhab.binding.lcn.internal.converter.LightConverter;\n+import org.openhab.binding.lcn.internal.converter.PowerConverter;\n+import org.openhab.binding.lcn.internal.converter.TemperatureConverter;\n+import org.openhab.binding.lcn.internal.converter.VoltageConverter;\n+import org.openhab.binding.lcn.internal.converter.WindspeedConverter;\n+import org.openhab.binding.lcn.internal.subhandler.AbstractLcnModuleSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LcnModuleHandler} is responsible for handling commands, which are\n+ * sent to or received from one of the channels.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleHandler.class);\n+    private @Nullable LcnAddrMod moduleAddress;\n+    private Map<LcnChannelGroup, @Nullable AbstractLcnModuleSubHandler> subHandlers;\n+    private List<AbstractLcnModuleSubHandler> metadataSubHandlers;\n+    private Map<ChannelUID, @Nullable AbstractVariableValueConverter> converters;\n+\n+    public LcnModuleHandler(Thing thing) {\n+        super(thing);\n+\n+        subHandlers = Collections.synchronizedMap(new HashMap<>());\n+        metadataSubHandlers = Collections.synchronizedList(new LinkedList<>());\n+        converters = Collections.synchronizedMap(new HashMap<>());\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        LcnModuleConfiguration localConfig = getConfigAs(LcnModuleConfiguration.class);\n+        LcnAddrMod localModuleAddress = moduleAddress = new LcnAddrMod(localConfig.segmentId, localConfig.moduleId);\n+\n+        try {\n+            // create sub handlers\n+            ModInfo info = getPckGatewayHandler().getModInfo(localModuleAddress);\n+            for (LcnChannelGroup type : LcnChannelGroup.values()) {\n+                AbstractLcnModuleSubHandler newHandler = type.getSubHandlerClass()\n+                        .getDeclaredConstructor(LcnModuleHandler.class, ModInfo.class).newInstance(this, info);", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMyMzQ2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438323468", "bodyText": "I really like this idea! Refactored.", "author": "fwolter", "createdAt": "2020-06-10T18:21:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk2ODQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk3MjE1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436972154", "bodyText": "Here is an example of what I mean:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                CODE(0, LcnModuleCodeSubHandler.class);\n          \n          \n            \n            \n          \n          \n            \n                private int count;\n          \n          \n            \n                private Class<? extends AbstractLcnModuleSubHandler> subHandlerClass;\n          \n          \n            \n            \n          \n          \n            \n                private LcnChannelGroup(int count, Class<? extends AbstractLcnModuleSubHandler> subHandlerClass) {\n          \n          \n            \n                    this.count = count;\n          \n          \n            \n                    this.subHandlerClass = subHandlerClass;\n          \n          \n            \n                }\n          \n          \n            \n                CODE(0, LcnModuleCodeSubHandler.class, LcnModuleCodeSubHandler::new);\n          \n          \n            \n            \n          \n          \n            \n                private final int count;\n          \n          \n            \n                private final Class<? extends AbstractLcnModuleSubHandler> subHandlerClass;\n          \n          \n            \n                private final BiFunction<LcnModuleHandler, ModInfo, ? extends AbstractLcnModuleSubHandler> handlerFactory;\n          \n          \n            \n            \n          \n          \n            \n                private <T extends AbstractLcnModuleSubHandler> LcnChannelGroup(int count, Class<T> subHandlerClass, \n          \n          \n            \n                    BiFunction<LcnModuleHandler, ModInfo, T> handlerFactory) {\n          \n          \n            \n                    this.count = count;\n          \n          \n            \n                    this.subHandlerClass = subHandlerClass;\n          \n          \n            \n                    this.handlerFactory = handlerFactory;\n          \n          \n            \n                }", "author": "cpmeister", "createdAt": "2020-06-08T20:12:19Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/LcnChannelGroup.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.subhandler.AbstractLcnModuleSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleBinarySensorSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleCodeSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleKeyLockTableSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleLedSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleLogicSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleOutputSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleRelaySubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleRollershutterOutputSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleRollershutterRelaySubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleRvarLockSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleRvarSetpointSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleS0CounterSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleThresholdSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleVariableSubHandler;\n+\n+/**\n+ * Defines the supported channels of an LCN module handler.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum LcnChannelGroup {\n+    OUTPUT(4, LcnModuleOutputSubHandler.class),\n+    ROLLERSHUTTEROUTPUT(1, LcnModuleRollershutterOutputSubHandler.class),\n+    RELAY(8, LcnModuleRelaySubHandler.class),\n+    ROLLERSHUTTERRELAY(4, LcnModuleRollershutterRelaySubHandler.class),\n+    LED(12, LcnModuleLedSubHandler.class),\n+    LOGIC(4, LcnModuleLogicSubHandler.class),\n+    BINARYSENSOR(8, LcnModuleBinarySensorSubHandler.class),\n+    VARIABLE(12, LcnModuleVariableSubHandler.class),\n+    RVARSETPOINT(2, LcnModuleRvarSetpointSubHandler.class),\n+    RVARLOCK(2, LcnModuleRvarLockSubHandler.class),\n+    THRESHOLDREGISTER1(5, LcnModuleThresholdSubHandler.class),\n+    THRESHOLDREGISTER2(4, LcnModuleThresholdSubHandler.class),\n+    THRESHOLDREGISTER3(4, LcnModuleThresholdSubHandler.class),\n+    THRESHOLDREGISTER4(4, LcnModuleThresholdSubHandler.class),\n+    S0INPUT(4, LcnModuleS0CounterSubHandler.class),\n+    KEYLOCKTABLEA(8, LcnModuleKeyLockTableSubHandler.class),\n+    KEYLOCKTABLEB(8, LcnModuleKeyLockTableSubHandler.class),\n+    KEYLOCKTABLEC(8, LcnModuleKeyLockTableSubHandler.class),\n+    KEYLOCKTABLED(8, LcnModuleKeyLockTableSubHandler.class),\n+    CODE(0, LcnModuleCodeSubHandler.class);\n+\n+    private int count;\n+    private Class<? extends AbstractLcnModuleSubHandler> subHandlerClass;\n+\n+    private LcnChannelGroup(int count, Class<? extends AbstractLcnModuleSubHandler> subHandlerClass) {\n+        this.count = count;\n+        this.subHandlerClass = subHandlerClass;\n+    }", "originalCommit": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f286ec5e63678277ee6c0c42b0e316ffb3997d38", "url": "https://github.com/openhab/openhab-addons/commit/f286ec5e63678277ee6c0c42b0e316ffb3997d38", "message": "Incorporate review feedback\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-06-10T13:09:34Z", "type": "commit"}, {"oid": "ec291ce4f40624263177049a28d70762a64e8c9c", "url": "https://github.com/openhab/openhab-addons/commit/ec291ce4f40624263177049a28d70762a64e8c9c", "message": "Fix DimmerOutputProfile\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-06-10T13:09:35Z", "type": "commit"}, {"oid": "aa746b45c1b7e84de15259f8d41ff931d670d355", "url": "https://github.com/openhab/openhab-addons/commit/aa746b45c1b7e84de15259f8d41ff931d670d355", "message": "Fix NPE\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-06-10T13:09:35Z", "type": "commit"}, {"oid": "7384be9252bcb0aeb89efeada0f9fa255c15f424", "url": "https://github.com/openhab/openhab-addons/commit/7384be9252bcb0aeb89efeada0f9fa255c15f424", "message": "Refactor\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-06-10T13:09:59Z", "type": "commit"}, {"oid": "9e249fde574174c45a06de38d391391f0c42920a", "url": "https://github.com/openhab/openhab-addons/commit/9e249fde574174c45a06de38d391391f0c42920a", "message": "Add representation property to Discovery Services\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-06-10T20:17:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxNzg2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438317866", "bodyText": "Standard java Proxys can only be interfaces, so you would need to make an interface that has all your action methods in it.", "author": "cpmeister", "createdAt": "2020-06-10T18:11:52Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleActions.java", "diffHunk": "@@ -145,42 +147,46 @@ public void sendDynamicText(\n                 command.put(PckGenerator.dynTextHeader(row - 1, part++).getBytes(LcnDefs.LCN_ENCODING));\n                 command.put(chunk);\n \n-                getHandler().sendPck(command);\n+                getHandler().sendPck(command.array());\n             }\n         } catch (UnsupportedEncodingException | IllegalArgumentException | LcnException e) {\n             logger.warn(\"Could not send dynamic text: {}\", e.getMessage());\n         }\n     }\n \n+    private static LcnModuleActions invokeMethodOf(@Nullable ThingActions actions) {\n+        if (actions == null) {\n+            throw new IllegalArgumentException(\"actions cannot be null\");\n+        }\n+        if (actions.getClass().getName().equals(LcnModuleActions.class.getName())) {\n+            if (actions instanceof LcnModuleActions) {\n+                return (LcnModuleActions) actions;\n+            } else {\n+                return (LcnModuleActions) Proxy.newProxyInstance(LcnModuleActions.class.getClassLoader(),", "originalCommit": "f286ec5e63678277ee6c0c42b0e316ffb3997d38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMzMzc4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438333786", "bodyText": "You should try to cache the configuration instances in your initialize() method since they are pretty costly to construct.", "author": "cpmeister", "createdAt": "2020-06-10T18:40:41Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/PckGatewayHandler.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnDefs.OutputPortDimMode;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.connection.ConnectionCallback;\n+import org.openhab.binding.lcn.internal.connection.ConnectionSettings;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PckGatewayHandler} is responsible for the communication via a PCK gateway.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PckGatewayHandler extends BaseBridgeHandler {\n+    private final Logger logger = LoggerFactory.getLogger(PckGatewayHandler.class);\n+    private @Nullable Connection connection;\n+    private Optional<Consumer<String>> pckListener = Optional.empty();\n+\n+    public PckGatewayHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // nothing\n+    }\n+\n+    @Override\n+    public synchronized void initialize() {\n+        PckGatewayConfiguration config = getConfigAs(PckGatewayConfiguration.class);\n+\n+        String errorMessage = \"Could not connect to LCN-PCHK/PKE: \" + config.getHostname() + \": \";\n+\n+        try {\n+            OutputPortDimMode dimMode;\n+            String mode = config.getMode();\n+            if (LcnDefs.OutputPortDimMode.NATIVE50.name().equalsIgnoreCase(mode)) {\n+                dimMode = LcnDefs.OutputPortDimMode.NATIVE50;\n+            } else if (LcnDefs.OutputPortDimMode.NATIVE200.name().equalsIgnoreCase(mode)) {\n+                dimMode = LcnDefs.OutputPortDimMode.NATIVE200;\n+            } else {\n+                throw new LcnException(\"DimMode \" + mode + \" is not supported\");\n+            }\n+\n+            ConnectionSettings settings = new ConnectionSettings(\"0\", config.getHostname(), config.getPort(),\n+                    config.getUsername(), config.getPassword(), dimMode, LcnDefs.OutputPortStatusMode.PERCENT,\n+                    config.getTimeoutMs());\n+\n+            connection = new Connection(settings, scheduler, new ConnectionCallback() {\n+                @Override\n+                public void onOnline() {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+\n+                @Override\n+                public void onOffline(@Nullable String errorMessage) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMessage + \".\");\n+                }\n+\n+                @Override\n+                public void onPckMessageReceived(String message) {\n+                    pckListener.ifPresent(l -> l.accept(message));\n+                    getThing().getThings().stream().filter(t -> t.getStatus() == ThingStatus.ONLINE).map(t -> {\n+                        LcnModuleHandler handler = (LcnModuleHandler) t.getHandler();\n+                        if (handler == null) {\n+                            logger.warn(\"Failed to process PCK message: Handler not set\");\n+                        }\n+                        return handler;\n+                    }).filter(h -> h != null).forEach(h -> h.handleStatusMessage(message));\n+                }\n+            });\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+        } catch (LcnException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMessage + e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(LcnModuleDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void childHandlerDisposed(ThingHandler childHandler, Thing childThing) {\n+        if (childThing.getThingTypeUID().equals(LcnBindingConstants.THING_TYPE_MODULE)\n+                || childThing.getThingTypeUID().equals(LcnBindingConstants.THING_TYPE_GROUP)) {\n+            try {\n+                LcnAddr addr = getLcnAddrFromThing(childThing);\n+                Connection localConnection = connection;\n+                if (localConnection != null) {\n+                    localConnection.removeLcnModule(addr);\n+                }\n+            } catch (LcnException e) {\n+                logger.warn(\"Failed to read configuration: {}\", e.getMessage());\n+            }\n+        }\n+    }\n+\n+    private LcnAddr getLcnAddrFromThing(Thing childThing) throws LcnException {\n+        LcnModuleHandler lcnModuleHandler = (LcnModuleHandler) childThing.getHandler();\n+        if (lcnModuleHandler != null) {\n+            return lcnModuleHandler.getCommandAddress();\n+        } else {\n+            throw new LcnException(\"Could not get module handler\");\n+        }\n+    }\n+\n+    /**\n+     * Enqueues a PCK (String) command to be sent to an LCN module.\n+     *\n+     * @param addr the modules address\n+     * @param wantsAck true, if the module shall send an ACK upon successful processing\n+     * @param pck the command to send\n+     */\n+    public void queue(LcnAddr addr, boolean wantsAck, String pck) {\n+        Connection localConnection = connection;\n+        if (localConnection != null) {\n+            localConnection.queue(addr, wantsAck, pck);\n+        } else {\n+            logger.warn(\"Dropped PCK command: {}\", pck);\n+        }\n+    }\n+\n+    /**\n+     * Enqueues a PCK (ByteBuffer) command to be sent to an LCN module.\n+     *\n+     * @param addr the modules address\n+     * @param wantsAck true, if the module shall send an ACK upon successful processing\n+     * @param pck the command to send\n+     */\n+    public void queue(LcnAddr addr, boolean wantsAck, byte[] pck) {\n+        Connection localConnection = connection;\n+        if (localConnection != null) {\n+            localConnection.queue(addr, wantsAck, pck);\n+        } else {\n+            logger.warn(\"Dropped PCK command of length: {}\", pck.length);\n+        }\n+    }\n+\n+    /**\n+     * Sends a broadcast message to all LCN modules: All LCN modules are requested to answer with an Ack.\n+     */\n+    void sendModuleDiscoveryCommand() {\n+        Connection localConnection = connection;\n+        if (localConnection != null) {\n+            localConnection.sendModuleDiscoveryCommand();\n+        }\n+    }\n+\n+    /**\n+     * Send a request to an LCN module to respond with its serial number and firmware version.\n+     *\n+     * @param addr the module's address\n+     */\n+    void sendSerialNumberRequest(LcnAddrMod addr) {\n+        Connection localConnection = connection;\n+        if (localConnection != null) {\n+            localConnection.sendSerialNumberRequest(addr);\n+        }\n+    }\n+\n+    /**\n+     * Send a request to an LCN module to respond with its configured name.\n+     *\n+     * @param addr the module's address\n+     */\n+    void sendModuleNameRequest(LcnAddrMod addr) {\n+        Connection localConnection = connection;\n+        if (localConnection != null) {\n+            localConnection.sendModuleNameRequest(addr);\n+        }\n+    }\n+\n+    /**\n+     * Returns the ModInfo to a given module. Will be created if it doesn't exist,yet.\n+     *\n+     * @param addr the module's address\n+     * @return the ModInfo\n+     * @throws LcnException when this handler is not initialized, yet\n+     */\n+    ModInfo getModInfo(LcnAddrMod addr) throws LcnException {\n+        Connection localConnection = connection;\n+        if (localConnection != null) {\n+            return localConnection.updateModuleData(addr);\n+        } else {\n+            throw new LcnException(\"Connection is null\");\n+        }\n+    }\n+\n+    /**\n+     * Registers a listener to receive all PCK messages from this PCK gateway.\n+     *\n+     * @param listener the listener to add\n+     */\n+    void registerPckListener(Consumer<String> listener) {\n+        this.pckListener = Optional.of(listener);\n+    }\n+\n+    /**\n+     * Removes all listeners for PCK messages from this PCK gateway.\n+     */\n+    void removeAllPckListeners() {\n+        this.pckListener = Optional.empty();\n+    }\n+\n+    /**\n+     * Gets the Connection for this handler.\n+     *\n+     * @return the Connection\n+     */\n+    @Nullable\n+    public Connection getConnection() {\n+        return connection;\n+    }\n+\n+    /**\n+     * Gets the local segment ID. When no segments are used, the value is 0.\n+     *\n+     * @return the local segment ID\n+     */\n+    public int getLocalSegmentId() {\n+        Connection localConnection = connection;\n+        if (localConnection != null) {\n+            return localConnection.getLocalSegId();\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Translates the given physical segment ID (0 or 4 if local segment) to the logical segment ID (local segment ID).\n+     *\n+     * @param physicalSegmentId the segment ID to convert\n+     * @return the converted segment ID\n+     */\n+    public int toLogicalSegmentId(int physicalSegmentId) {\n+        int localSegmentId = getLocalSegmentId();\n+        if ((physicalSegmentId == 0 || physicalSegmentId == 4) && localSegmentId != -1) {\n+            // PCK message came from local segment\n+            // physicalSegmentId == 0 => Module is programmed to send status messages to local segment only\n+            // physicalSegmentId == 4 => Module is programmed to send status messages globally (to all segments)\n+            // or segment coupler scan did not finish, yet (-1). Assume local segment, then.\n+            return localSegmentId;\n+        } else {\n+            return physicalSegmentId;\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        Connection localConnection = connection;\n+        if (localConnection != null) {\n+            localConnection.shutdown();\n+        }\n+    }\n+\n+    /**\n+     * Gets the configured connection timeout for the PCK gateway.\n+     *\n+     * @return the timeout in ms\n+     */\n+    public long getTimeoutMs() {\n+        return getConfigAs(PckGatewayConfiguration.class).getTimeoutMs();", "originalCommit": "7384be9252bcb0aeb89efeada0f9fa255c15f424", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM0Mjc0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438342741", "bodyText": "This should allow you to make thresholdNumber final.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final int number;\n          \n          \n            \n                private Optional<Integer> thresholdNumber = Optional.empty();\n          \n          \n            \n                private final Type type;\n          \n          \n            \n                private final LcnChannelGroup channelGroup;\n          \n          \n            \n            \n          \n          \n            \n                /**\n          \n          \n            \n                 * Defines the origin of an LCN variable.\n          \n          \n            \n                 */\n          \n          \n            \n                public enum Type {\n          \n          \n            \n                    UNKNOWN,\n          \n          \n            \n                    VARIABLE,\n          \n          \n            \n                    REGULATOR,\n          \n          \n            \n                    THRESHOLD,\n          \n          \n            \n                    S0INPUT\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                Variable(int number, Type type, LcnChannelGroup channelGroup) {\n          \n          \n            \n                    this.number = number;\n          \n          \n            \n                    this.type = type;\n          \n          \n            \n                    this.channelGroup = channelGroup;\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                Variable(int number, int thresholdNumber, Type type, LcnChannelGroup channelGroup) {\n          \n          \n            \n                    this(number, type, channelGroup);\n          \n          \n            \n                    this.thresholdNumber = Optional.of(thresholdNumber);\n          \n          \n            \n                }\n          \n          \n            \n                private final int number;\n          \n          \n            \n                private final Optional<Integer> thresholdNumber;\n          \n          \n            \n                private final Type type;\n          \n          \n            \n                private final LcnChannelGroup channelGroup;\n          \n          \n            \n            \n          \n          \n            \n                /**\n          \n          \n            \n                 * Defines the origin of an LCN variable.\n          \n          \n            \n                 */\n          \n          \n            \n                public enum Type {\n          \n          \n            \n                    UNKNOWN,\n          \n          \n            \n                    VARIABLE,\n          \n          \n            \n                    REGULATOR,\n          \n          \n            \n                    THRESHOLD,\n          \n          \n            \n                    S0INPUT\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                Variable(int number, Type type, LcnChannelGroup channelGroup) {\n          \n          \n            \n                    this(number, Optional.empty(), type, channelGroup);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                Variable(int number, int thresholdNumber, Type type, LcnChannelGroup channelGroup) {\n          \n          \n            \n                    this(number, Optional.of(thresholdNumber), type, channelGroup);\n          \n          \n            \n                }\n          \n          \n            \n                \n          \n          \n            \n                Variable(int number, Optional<Integer> thresholdNumber, Type type, LcnChannelGroup channelGroup) {\n          \n          \n            \n                    this.number = number;\n          \n          \n            \n                    this.type = type;\n          \n          \n            \n                    this.channelGroup = channelGroup;\n          \n          \n            \n                    this.thresholdNumber = thresholdNumber;\n          \n          \n            \n                }", "author": "cpmeister", "createdAt": "2020-06-10T18:57:22Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/Variable.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+\n+/**\n+ * LCN variable types.\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public enum Variable {\n+    UNKNOWN(0, Type.UNKNOWN, LcnChannelGroup.VARIABLE), // Used if the real type is not known (yet)\n+    VARIABLE1(0, Type.VARIABLE, LcnChannelGroup.VARIABLE), // or TVar\n+    VARIABLE2(1, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE3(2, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE4(3, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE5(4, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE6(5, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE7(6, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE8(7, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE9(8, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE10(9, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE11(10, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE12(11, Type.VARIABLE, LcnChannelGroup.VARIABLE), // Since 170206\n+    RVARSETPOINT1(0, Type.REGULATOR, LcnChannelGroup.RVARSETPOINT),\n+    RVARSETPOINT2(1, Type.REGULATOR, LcnChannelGroup.RVARSETPOINT), // Set-points for regulators\n+    THRESHOLDREGISTER11(0, 0, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER1),\n+    THRESHOLDREGISTER12(0, 1, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER1),\n+    THRESHOLDREGISTER13(0, 2, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER1),\n+    THRESHOLDREGISTER14(0, 3, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER1),\n+    // Register 1 (THRESHOLDREGISTER15 only before 170206)\n+    THRESHOLDREGISTER15(0, 4, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER1),\n+    THRESHOLDREGISTER21(1, 0, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER2),\n+    THRESHOLDREGISTER22(1, 1, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER2),\n+    THRESHOLDREGISTER23(1, 2, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER2),\n+    THRESHOLDREGISTER24(1, 3, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER2), // Register 2 (since 2012)\n+    THRESHOLDREGISTER31(2, 0, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER3),\n+    THRESHOLDREGISTER32(2, 1, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER3),\n+    THRESHOLDREGISTER33(2, 2, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER3),\n+    THRESHOLDREGISTER34(2, 3, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER3), // Register 3 (since 2012)\n+    THRESHOLDREGISTER41(3, 0, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER4),\n+    THRESHOLDREGISTER42(3, 1, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER4),\n+    THRESHOLDREGISTER43(3, 2, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER4),\n+    THRESHOLDREGISTER44(3, 3, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER4), // Register 4 (since 2012)\n+    S0INPUT1(0, Type.S0INPUT, LcnChannelGroup.S0INPUT),\n+    S0INPUT2(1, Type.S0INPUT, LcnChannelGroup.S0INPUT),\n+    S0INPUT3(2, Type.S0INPUT, LcnChannelGroup.S0INPUT),\n+    S0INPUT4(3, Type.S0INPUT, LcnChannelGroup.S0INPUT); // LCN-BU4L\n+\n+    private final int number;\n+    private Optional<Integer> thresholdNumber = Optional.empty();\n+    private final Type type;\n+    private final LcnChannelGroup channelGroup;\n+\n+    /**\n+     * Defines the origin of an LCN variable.\n+     */\n+    public enum Type {\n+        UNKNOWN,\n+        VARIABLE,\n+        REGULATOR,\n+        THRESHOLD,\n+        S0INPUT\n+    }\n+\n+    Variable(int number, Type type, LcnChannelGroup channelGroup) {\n+        this.number = number;\n+        this.type = type;\n+        this.channelGroup = channelGroup;\n+    }\n+\n+    Variable(int number, int thresholdNumber, Type type, LcnChannelGroup channelGroup) {\n+        this(number, type, channelGroup);\n+        this.thresholdNumber = Optional.of(thresholdNumber);\n+    }", "originalCommit": "7384be9252bcb0aeb89efeada0f9fa255c15f424", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4NjI1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438386257", "bodyText": "You should probably make this the default implementation of this method in AbstractConnectionState.", "author": "cpmeister", "createdAt": "2020-06-10T20:22:26Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/ConnectionStateSegmentScan.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrGrp;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This state discovers the LCN segment couplers.\n+ *\n+ * After the authorization against the LCN-PCK gateway was successful, the LCN segment couplers are discovery, to\n+ * retrieve the segment ID of the local segment. When no segment couplers were found, a timeout sets the local segment\n+ * ID to 0.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class ConnectionStateSegmentScan extends AbstractConnectionState {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectionStateSegmentScan.class);\n+    public static final Pattern PATTERN_SK_RESPONSE = Pattern\n+            .compile(\"=M(?<segId>\\\\d{3})(?<modId>\\\\d{3})\\\\.SK(?<id>\\\\d+)\");\n+    private final RequestStatus statusSegmentScan = new RequestStatus(-1, 3, \"Segment Scan\");\n+\n+    public ConnectionStateSegmentScan(StateContext context, ScheduledExecutorService scheduler) {\n+        super(context, scheduler);\n+    }\n+\n+    @Override\n+    public void startWorking() {\n+        statusSegmentScan.refresh();\n+        addTimer(scheduler.scheduleWithFixedDelay(this::update, 0, 500, TimeUnit.MILLISECONDS));\n+    }\n+\n+    private void update() {\n+        long currTime = System.nanoTime();\n+        try {\n+            if (statusSegmentScan.shouldSendNextRequest(connection.getSettings().getTimeout(), currTime)) {\n+                connection.queueDirectly(new LcnAddrGrp(3, 3), false, PckGenerator.segmentCouplerScan());\n+                statusSegmentScan.onRequestSent(currTime);\n+            }\n+        } catch (LcnException e) {\n+            // Give up. Probably no segments available.\n+            connection.setLocalSegId(0);\n+            logger.debug(\"No segment couplers detected\");\n+            nextState(ConnectionStateConnected.class);\n+        }\n+    }\n+\n+    @Override\n+    public void queue(LcnAddr addr, boolean wantsAck, byte[] data) {\n+        connection.queueOffline(addr, wantsAck, data);\n+    }", "originalCommit": "7384be9252bcb0aeb89efeada0f9fa255c15f424", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "55f98964ceda94d860f5904b336419ce182f88d8", "url": "https://github.com/openhab/openhab-addons/commit/55f98964ceda94d860f5904b336419ce182f88d8", "message": "Incorporate review feedback\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-06-10T21:02:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxMjU2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438412567", "bodyText": "I'm not sure that this works. To my knowledge the type check occurs in the caller, not around this generic cast.", "author": "cpmeister", "createdAt": "2020-06-10T21:15:20Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.openhab.binding.lcn.internal.converter.Converter;\n+import org.openhab.binding.lcn.internal.converter.Converters;\n+import org.openhab.binding.lcn.internal.converter.S0Converter;\n+import org.openhab.binding.lcn.internal.subhandler.AbstractLcnModuleSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LcnModuleHandler} is responsible for handling commands, which are\n+ * sent to or received from one of the channels.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleHandler.class);\n+    private static final Map<String, Converter> CONVERTERS = new HashMap<>();\n+    private @Nullable LcnAddrMod moduleAddress;\n+    private final Map<LcnChannelGroup, @Nullable AbstractLcnModuleSubHandler> subHandlers = new HashMap<>();\n+    private final List<AbstractLcnModuleSubHandler> metadataSubHandlers = new ArrayList<>();\n+    private final Map<ChannelUID, @Nullable Converter> converters = new HashMap<>();\n+\n+    static {\n+        CONVERTERS.put(\"temperature\", Converters.TEMPERATURE);\n+        CONVERTERS.put(\"light\", Converters.LIGHT);\n+        CONVERTERS.put(\"co2\", Converters.CO2);\n+        CONVERTERS.put(\"current\", Converters.CURRENT);\n+        CONVERTERS.put(\"voltage\", Converters.VOLTAGE);\n+        CONVERTERS.put(\"angle\", Converters.ANGLE);\n+        CONVERTERS.put(\"windspeed\", Converters.WINDSPEED);\n+    }\n+\n+    public LcnModuleHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        LcnModuleConfiguration localConfig = getConfigAs(LcnModuleConfiguration.class);\n+        LcnAddrMod localModuleAddress = moduleAddress = new LcnAddrMod(localConfig.segmentId, localConfig.moduleId);\n+\n+        try {\n+            // create sub handlers\n+            ModInfo info = getPckGatewayHandler().getModInfo(localModuleAddress);\n+            for (LcnChannelGroup type : LcnChannelGroup.values()) {\n+                subHandlers.put(type, type.createSubHandler(this, info));\n+            }\n+\n+            // meta sub handlers, which are not assigned to a channel group\n+            metadataSubHandlers.add(new LcnModuleMetaAckSubHandler(this, info));\n+            metadataSubHandlers.add(new LcnModuleMetaFirmwareSubHandler(this, info));\n+\n+            // initialize variable value converters\n+            for (Channel channel : thing.getChannels()) {\n+                Object unitObject = channel.getConfiguration().get(\"unit\");\n+                Object parameterObject = channel.getConfiguration().get(\"parameter\");\n+\n+                if (unitObject instanceof String) {\n+                    switch ((String) unitObject) {\n+                        case \"power\":\n+                        case \"energy\":\n+                            converters.put(channel.getUID(), new S0Converter(parameterObject));\n+                            break;\n+                        default:\n+                            if (CONVERTERS.containsKey(unitObject)) {\n+                                converters.put(channel.getUID(), CONVERTERS.get(unitObject));\n+                            }\n+                            break;\n+                    }\n+                }\n+            }\n+\n+            // module is assumed as online, when the corresponding Bridge (PckGatewayHandler) is online.\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (LcnException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUid, Command command) {\n+        try {\n+            String groupId = channelUid.getGroupId();\n+\n+            if (!channelUid.isInGroup()) {\n+                return;\n+            }\n+\n+            if (groupId == null) {\n+                throw new LcnException(\"Group ID is null\");\n+            }\n+\n+            LcnChannelGroup channelGroup = LcnChannelGroup.valueOf(groupId.toUpperCase());\n+            AbstractLcnModuleSubHandler subHandler = subHandlers.get(channelGroup);\n+\n+            if (subHandler == null) {\n+                throw new LcnException(\"Sub Handler not found for: \" + channelGroup);\n+            }\n+\n+            Optional<Integer> number = channelUidToChannelNumber(channelUid, channelGroup);\n+\n+            if (command instanceof RefreshType) {\n+                number.ifPresent(n -> subHandler.handleRefresh(channelGroup, n));\n+                subHandler.handleRefresh(channelUid.getIdWithoutGroup());\n+            } else if (command instanceof OnOffType) {\n+                subHandler.handleCommandOnOff(castCommand(command), channelGroup, number.get());\n+            } else if (command instanceof DimmerOutputCommand) {\n+                subHandler.handleCommandDimmerOutput(castCommand(command), number.get());\n+            } else if (command instanceof PercentType && number.isPresent()) {\n+                subHandler.handleCommandPercent(castCommand(command), channelGroup, number.get());\n+            } else if (command instanceof HSBType) {\n+                subHandler.handleCommandHsb(castCommand(command), channelUid.getIdWithoutGroup());\n+            } else if (command instanceof PercentType) {\n+                subHandler.handleCommandPercent(castCommand(command), channelGroup, channelUid.getIdWithoutGroup());\n+            } else if (command instanceof StringType) {\n+                subHandler.handleCommandString(castCommand(command), number.get());\n+            } else if (command instanceof DecimalType) {\n+                DecimalType decimalType = castCommand(command);\n+                DecimalType nativeValue = getConverter(channelUid).onCommandFromItem(decimalType.doubleValue());\n+                subHandler.handleCommandDecimal(nativeValue, channelGroup, number.get());\n+            } else if (command instanceof QuantityType) {\n+                QuantityType<?> quantityType = castCommand(command);\n+                DecimalType nativeValue = getConverter(channelUid).onCommandFromItem(quantityType);\n+                subHandler.handleCommandDecimal(nativeValue, channelGroup, number.get());\n+            } else if (command instanceof UpDownType) {\n+                subHandler.handleCommandUpDown(castCommand(command), channelGroup, number.get());\n+            } else if (command instanceof StopMoveType) {\n+                subHandler.handleCommandStopMove(castCommand(command), channelGroup, number.get());\n+            } else {\n+                throw new LcnException(\"Unsupported command type\");\n+            }\n+        } catch (IllegalArgumentException | NoSuchElementException | LcnException e) {\n+            logger.warn(\"{}: Failed to handle command {}: {}\", channelUid, command.getClass().getSimpleName(),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @NonNullByDefault({}) // getOrDefault()\n+    private Converter getConverter(ChannelUID channelUid) {\n+        return converters.getOrDefault(channelUid, Converters.IDENTITY);\n+    }\n+\n+    /**\n+     * Convenience method to cast a command.\n+     *\n+     * @param <T> the concrete type to be casted to\n+     * @param command the command to be casted\n+     * @return the concrete command\n+     * @throws LcnException when the command cannot be casted\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private <T extends Command> T castCommand(Command command) throws LcnException {\n+        try {\n+            return (T) command;\n+        } catch (ClassCastException e) {\n+            throw new LcnException(\"Unexpected command type\");\n+        }", "originalCommit": "55f98964ceda94d860f5904b336419ce182f88d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxOTcwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438419709", "bodyText": "Nice finding again! I replaced the method by conventional casts. Then, catching the exception isn't necessary at all.", "author": "fwolter", "createdAt": "2020-06-10T21:31:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxMjU2Nw=="}], "type": "inlineReview"}, {"oid": "8d692ad7724548be4563c7b5309e1215ed73ca83", "url": "https://github.com/openhab/openhab-addons/commit/8d692ad7724548be4563c7b5309e1215ed73ca83", "message": "Incorporate review feedback #3\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-06-10T21:27:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxNjEwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438416104", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private PckGatewayConfiguration config;\n          \n          \n            \n                private @Nullable PckGatewayConfiguration config;", "author": "cpmeister", "createdAt": "2020-06-10T21:23:18Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/PckGatewayHandler.java", "diffHunk": "@@ -50,6 +50,8 @@\n     private final Logger logger = LoggerFactory.getLogger(PckGatewayHandler.class);\n     private @Nullable Connection connection;\n     private Optional<Consumer<String>> pckListener = Optional.empty();\n+    @Nullable\n+    private PckGatewayConfiguration config;", "originalCommit": "55f98964ceda94d860f5904b336419ce182f88d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxNzQ3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438417475", "bodyText": "calling the super's destructor should usually be done last.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    super.deactivate();\n          \n          \n            \n                    stopScan();\n          \n          \n            \n                    stopScan();\n          \n          \n            \n                    super.deactivate();", "author": "cpmeister", "createdAt": "2020-06-10T21:26:14Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Scans all LCN segments for LCN modules.\n+ *\n+ * Scan approach:\n+ * 1. Send \"Leerkomando\" to the broadcast address with request for Ack set\n+ * 2. For every received Ack, send the following requests to the module:\n+ * - serial number request (SN)\n+ * - module's name first part request (NM1)\n+ * - module's name second part request (NM2)\n+ * 3. When all three messages have been received, fire thingDiscovered()\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleDiscoveryService.class);\n+    private static final Pattern NAME_PATTERN = Pattern\n+            .compile(\"=M(?<segId>\\\\d{3})(?<modId>\\\\d{3}).N(?<part>[1-2]{1})(?<name>.*)\");\n+    private static final String SEGMENT_ID = \"segmentId\";\n+    private static final String MODULE_ID = \"moduleId\";\n+    private static final String SERIAL_NUMBER = \"serialNumber\";\n+    private static final int MODULE_NAME_PART_COUNT = 2;\n+    private static final int DISCOVERY_TIMEOUT_SEC = 90;\n+    private static final int ACK_TIMEOUT_MS = 1000;\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(LcnBindingConstants.THING_TYPE_MODULE).collect(Collectors.toSet()));\n+    private @Nullable PckGatewayHandler bridgeHandler;\n+    private final Map<LcnAddrMod, @Nullable Map<Integer, String>> moduleNames = new HashMap<>();\n+    private final Map<LcnAddrMod, DiscoveryResultBuilder> discoveryResultBuilders = new ConcurrentHashMap<>();\n+    private final List<LcnAddrMod> successfullyDiscovered = new LinkedList<>();\n+    private final Queue<@Nullable LcnAddrMod> serialNumberRequestQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<@Nullable LcnAddrMod> moduleNameRequestQueue = new ConcurrentLinkedQueue<>();\n+    private @Nullable volatile ScheduledFuture<?> queueProcessor;\n+    private @Nullable ScheduledFuture<?> builderTask;\n+\n+    public LcnModuleDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_TIMEOUT_SEC, false);\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof PckGatewayHandler) {\n+            this.bridgeHandler = (PckGatewayHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        stopScan();", "originalCommit": "55f98964ceda94d860f5904b336419ce182f88d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxOTE1MA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438419150", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } else if (command instanceof PercentType && number.isPresent()) {\n          \n          \n            \n                            subHandler.handleCommandPercent(castCommand(command), channelGroup, number.get());\n          \n          \n            \n                        } else if (command instanceof HSBType) {\n          \n          \n            \n                            subHandler.handleCommandHsb(castCommand(command), channelUid.getIdWithoutGroup());\n          \n          \n            \n                        } else if (command instanceof PercentType) {\n          \n          \n            \n                            subHandler.handleCommandPercent(castCommand(command), channelGroup, channelUid.getIdWithoutGroup());\n          \n          \n            \n                        } else if (command instanceof PercentType && number.isPresent()) {\n          \n          \n            \n                            subHandler.handleCommandPercent(castCommand(command), channelGroup, number.orElse(channelUid.getIdWithoutGroup()));\n          \n          \n            \n                        } else if (command instanceof HSBType) {\n          \n          \n            \n                            subHandler.handleCommandHsb(castCommand(command), channelUid.getIdWithoutGroup());", "author": "cpmeister", "createdAt": "2020-06-10T21:30:01Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.openhab.binding.lcn.internal.converter.Converter;\n+import org.openhab.binding.lcn.internal.converter.Converters;\n+import org.openhab.binding.lcn.internal.converter.S0Converter;\n+import org.openhab.binding.lcn.internal.subhandler.AbstractLcnModuleSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LcnModuleHandler} is responsible for handling commands, which are\n+ * sent to or received from one of the channels.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleHandler.class);\n+    private static final Map<String, Converter> CONVERTERS = new HashMap<>();\n+    private @Nullable LcnAddrMod moduleAddress;\n+    private final Map<LcnChannelGroup, @Nullable AbstractLcnModuleSubHandler> subHandlers = new HashMap<>();\n+    private final List<AbstractLcnModuleSubHandler> metadataSubHandlers = new ArrayList<>();\n+    private final Map<ChannelUID, @Nullable Converter> converters = new HashMap<>();\n+\n+    static {\n+        CONVERTERS.put(\"temperature\", Converters.TEMPERATURE);\n+        CONVERTERS.put(\"light\", Converters.LIGHT);\n+        CONVERTERS.put(\"co2\", Converters.CO2);\n+        CONVERTERS.put(\"current\", Converters.CURRENT);\n+        CONVERTERS.put(\"voltage\", Converters.VOLTAGE);\n+        CONVERTERS.put(\"angle\", Converters.ANGLE);\n+        CONVERTERS.put(\"windspeed\", Converters.WINDSPEED);\n+    }\n+\n+    public LcnModuleHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        LcnModuleConfiguration localConfig = getConfigAs(LcnModuleConfiguration.class);\n+        LcnAddrMod localModuleAddress = moduleAddress = new LcnAddrMod(localConfig.segmentId, localConfig.moduleId);\n+\n+        try {\n+            // create sub handlers\n+            ModInfo info = getPckGatewayHandler().getModInfo(localModuleAddress);\n+            for (LcnChannelGroup type : LcnChannelGroup.values()) {\n+                subHandlers.put(type, type.createSubHandler(this, info));\n+            }\n+\n+            // meta sub handlers, which are not assigned to a channel group\n+            metadataSubHandlers.add(new LcnModuleMetaAckSubHandler(this, info));\n+            metadataSubHandlers.add(new LcnModuleMetaFirmwareSubHandler(this, info));\n+\n+            // initialize variable value converters\n+            for (Channel channel : thing.getChannels()) {\n+                Object unitObject = channel.getConfiguration().get(\"unit\");\n+                Object parameterObject = channel.getConfiguration().get(\"parameter\");\n+\n+                if (unitObject instanceof String) {\n+                    switch ((String) unitObject) {\n+                        case \"power\":\n+                        case \"energy\":\n+                            converters.put(channel.getUID(), new S0Converter(parameterObject));\n+                            break;\n+                        default:\n+                            if (CONVERTERS.containsKey(unitObject)) {\n+                                converters.put(channel.getUID(), CONVERTERS.get(unitObject));\n+                            }\n+                            break;\n+                    }\n+                }\n+            }\n+\n+            // module is assumed as online, when the corresponding Bridge (PckGatewayHandler) is online.\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (LcnException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUid, Command command) {\n+        try {\n+            String groupId = channelUid.getGroupId();\n+\n+            if (!channelUid.isInGroup()) {\n+                return;\n+            }\n+\n+            if (groupId == null) {\n+                throw new LcnException(\"Group ID is null\");\n+            }\n+\n+            LcnChannelGroup channelGroup = LcnChannelGroup.valueOf(groupId.toUpperCase());\n+            AbstractLcnModuleSubHandler subHandler = subHandlers.get(channelGroup);\n+\n+            if (subHandler == null) {\n+                throw new LcnException(\"Sub Handler not found for: \" + channelGroup);\n+            }\n+\n+            Optional<Integer> number = channelUidToChannelNumber(channelUid, channelGroup);\n+\n+            if (command instanceof RefreshType) {\n+                number.ifPresent(n -> subHandler.handleRefresh(channelGroup, n));\n+                subHandler.handleRefresh(channelUid.getIdWithoutGroup());\n+            } else if (command instanceof OnOffType) {\n+                subHandler.handleCommandOnOff(castCommand(command), channelGroup, number.get());\n+            } else if (command instanceof DimmerOutputCommand) {\n+                subHandler.handleCommandDimmerOutput(castCommand(command), number.get());\n+            } else if (command instanceof PercentType && number.isPresent()) {\n+                subHandler.handleCommandPercent(castCommand(command), channelGroup, number.get());\n+            } else if (command instanceof HSBType) {\n+                subHandler.handleCommandHsb(castCommand(command), channelUid.getIdWithoutGroup());\n+            } else if (command instanceof PercentType) {\n+                subHandler.handleCommandPercent(castCommand(command), channelGroup, channelUid.getIdWithoutGroup());", "originalCommit": "55f98964ceda94d860f5904b336419ce182f88d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQyNjYzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438426631", "bodyText": "Unfortunately this doesn't work, since handleCommandPercent() is overloaded with int/String. When it's not a number, it's \"color\".", "author": "fwolter", "createdAt": "2020-06-10T21:47:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxOTE1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQzMzQyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438433421", "bodyText": "ah, didn't notice that. oops", "author": "cpmeister", "createdAt": "2020-06-10T22:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxOTE1MA=="}], "type": "inlineReview"}, {"oid": "b66904ef02f89b7ecfb46e341c6a3aeb27e85c39", "url": "https://github.com/openhab/openhab-addons/commit/b66904ef02f89b7ecfb46e341c6a3aeb27e85c39", "message": "Incorporate review feedback No.4\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-06-10T21:44:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQyNTQ1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438425454", "bodyText": "Would a BufferOverflowException still be thrown in implementors?", "author": "cpmeister", "createdAt": "2020-06-10T21:44:10Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/SendData.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.BufferOverflowException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Base class for a packet to be send to LCN-PCHK.\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public abstract class SendData {\n+    /**\n+     * Writes the packet's data into the given buffer.\n+     * Called right before the packet is actually sent to LCN-PCHK.\n+     *\n+     * @param buffer the target buffer\n+     * @param localSegId the local segment id\n+     * @return true if everything was set-up correctly and data was written\n+     * @throws UnsupportedEncodingException if text could not be encoded for LCN-PCHK\n+     * @throws BufferOverflowException if target buffer has not enough space left (buffer will not be altered)\n+     * @throws IOException if an I/O error occurs\n+     */\n+    abstract boolean write(OutputStream buffer, int localSegId)\n+            throws UnsupportedEncodingException, BufferOverflowException, IOException;", "originalCommit": "8d692ad7724548be4563c7b5309e1215ed73ca83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQyNjkzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438426933", "bodyText": "Would it be possible to change this to a Charset? I think you can avoid a lot of UnsupportedEncodingException if you do that.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String LCN_ENCODING = \"UTF-8\";\n          \n          \n            \n                public static final Charset LCN_ENCODING = StandardCharsets.UTF_8;", "author": "cpmeister", "createdAt": "2020-06-10T21:47:41Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/LcnDefs.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Common definitions and helpers for the PCK protocol.\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public final class LcnDefs {\n+    /** Text encoding used by LCN-PCHK. */\n+    public static final String LCN_ENCODING = \"UTF-8\";", "originalCommit": "8d692ad7724548be4563c7b5309e1215ed73ca83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQyNzY2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438427662", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return \"Addr: \" + addr + \": \" + new String(data, 0, data.length);\n          \n          \n            \n                    return \"Addr: \" + addr + \": \" + new String(data);\n          \n      \n    \n    \n  \n\nYou could also include the charset here if you want.", "author": "cpmeister", "createdAt": "2020-06-10T21:49:33Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/SendDataPck.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.BufferOverflowException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+\n+/**\n+ * A PCK command to be send to LCN-PCHK.\n+ * It is already encoded as bytes to allow different text-encodings (ANSI, UTF-8).\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+class SendDataPck extends SendData {\n+    /** The target LCN address. */\n+    private final LcnAddr addr;\n+\n+    /** true to acknowledge the command on receipt. */\n+    private final boolean wantsAck;\n+\n+    /** PCK command (without address header) encoded as bytes. */\n+    private final byte[] data;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param addr the target LCN address\n+     * @param wantsAck true to claim receipt\n+     * @param data the PCK command encoded as bytes\n+     */\n+    SendDataPck(LcnAddr addr, boolean wantsAck, byte[] data) {\n+        this.addr = addr;\n+        this.wantsAck = wantsAck;\n+        this.data = data;\n+    }\n+\n+    /**\n+     * Gets the PCK command.\n+     *\n+     * @return the PCK command encoded as bytes\n+     */\n+    byte[] getData() {\n+        return this.data;\n+    }\n+\n+    @Override\n+    boolean write(OutputStream buffer, int localSegId) throws BufferOverflowException, IOException {\n+        buffer.write(PckGenerator.generateAddressHeader(this.addr, localSegId == -1 ? 0 : localSegId, this.wantsAck)\n+                .getBytes(LcnDefs.LCN_ENCODING));\n+        buffer.write(this.data);\n+        buffer.write(PckGenerator.TERMINATION.getBytes(LcnDefs.LCN_ENCODING));\n+        return true;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Addr: \" + addr + \": \" + new String(data, 0, data.length);", "originalCommit": "8d692ad7724548be4563c7b5309e1215ed73ca83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "67c50cbdbf636b589880d1f623187c9033c2d9e8", "url": "https://github.com/openhab/openhab-addons/commit/67c50cbdbf636b589880d1f623187c9033c2d9e8", "message": "Incorporate review feedback No.5\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-06-10T22:00:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQzOTQxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438439414", "bodyText": "It still bothers me that you are using reflection here. One option you can do is create an enum of state factories, similar to what I suggested earlier.\nAnother option is to just have each state construct the next state instance since they should already have all the data required to construct the next state anyway. Each state already has a reference to the StateContext field and the ScheduledExecutorService so it wouldn't be that difficult for each state to just pass those along when constructing the next state.", "author": "cpmeister", "createdAt": "2020-06-10T22:20:27Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/StateMachine.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implements a state machine for managing the connection to the LCN-PCK gateway. Setting states is thread-safe.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class StateMachine implements StateContext {\n+    private final Logger logger = LoggerFactory.getLogger(StateMachine.class);\n+    /** The StateMachine's current state */\n+    protected volatile AbstractConnectionState state;\n+    private final Connection connection;\n+    private final ScheduledExecutorService scheduler;\n+\n+    public StateMachine(Connection connection, ScheduledExecutorService scheduler) {\n+        this.connection = connection;\n+        this.scheduler = scheduler;\n+        this.state = new ConnectionStateInit(this, scheduler);\n+    }\n+\n+    @Override\n+    public synchronized void setState(Class<? extends AbstractConnectionState> newStateClass) {\n+        logger.debug(\"Changing state {} -> {}\", state.getClass().getSimpleName(), newStateClass.getSimpleName());\n+\n+        state.cancelAllTimers();\n+\n+        try {\n+            state = newStateClass.getDeclaredConstructor(StateContext.class, ScheduledExecutorService.class)\n+                    .newInstance(this, scheduler);", "originalCommit": "67c50cbdbf636b589880d1f623187c9033c2d9e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0MDIxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438440216", "bodyText": "charset should be specified here", "author": "cpmeister", "createdAt": "2020-06-10T22:22:42Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/pchkdiscovery/LcnPchkDiscoveryService.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.pchkdiscovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.thoughtworks.xstream.XStream;\n+import com.thoughtworks.xstream.io.xml.StaxDriver;\n+\n+/**\n+ * Discovers LCN-PCK gateways, such as LCN-PCHK.\n+ *\n+ * Scan approach:\n+ * 1. Determines all local network interfaces\n+ * 2. Send a multicast message on each interface to the PCHK multicast address 234.5.6.7 (not configurable by user).\n+ * 3. Evaluate multicast responses of PCK gateways in the network\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.lcn\")\n+public class LcnPchkDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(LcnPchkDiscoveryService.class);\n+    private static final String HOSTNAME = \"hostname\";\n+    private static final String PORT = \"port\";\n+    private static final String MAC_ADDRESS = \"macAddress\";\n+    private static final String PCHK_DISCOVERY_MULTICAST_ADDRESS = \"234.5.6.7\";\n+    private static final int PCHK_DISCOVERY_PORT = 4220;\n+    private static final int INTERFACE_TIMEOUT_SEC = 2;\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(LcnBindingConstants.THING_TYPE_PCK_GATEWAY).collect(Collectors.toSet()));\n+    private static final String DISCOVER_REQUEST = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><ServicesRequest xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:noNamespaceSchemaLocation=\\\"servicesrequest.xsd\\\"><Version major=\\\"1\\\" minor=\\\"0\\\" /><Requester requestId=\\\"1\\\" type=\\\"openHAB\\\" major=\\\"1\\\" minor=\\\"0\\\">openHAB</Requester><Requests><Request xsi:type=\\\"EnumServices\\\" major=\\\"1\\\" minor=\\\"0\\\" name=\\\"LcnPchkBus\\\" /></Requests></ServicesRequest>\";\n+\n+    public LcnPchkDiscoveryService() throws IllegalArgumentException {\n+        super(SUPPORTED_THING_TYPES_UIDS, 0, false);\n+    }\n+\n+    private List<InetAddress> getLocalAddresses() {\n+        List<InetAddress> result = new LinkedList<>();\n+        try {\n+            for (NetworkInterface networkInterface : Collections.list(NetworkInterface.getNetworkInterfaces())) {\n+                try {\n+                    if (networkInterface.isUp() && !networkInterface.isLoopback()\n+                            && !networkInterface.isPointToPoint()) {\n+                        result.addAll(Collections.list(networkInterface.getInetAddresses()));\n+                    }\n+                } catch (SocketException exception) {\n+                    // ignore\n+                }\n+            }\n+        } catch (SocketException exception) {\n+            return Collections.emptyList();\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        try {\n+            InetAddress multicastAddress = InetAddress.getByName(PCHK_DISCOVERY_MULTICAST_ADDRESS);\n+\n+            getLocalAddresses().forEach(localInterfaceAddress -> {\n+                logger.debug(\"Searching on {} ...\", localInterfaceAddress.getHostAddress());\n+                try (MulticastSocket socket = new MulticastSocket(PCHK_DISCOVERY_PORT)) {\n+                    socket.setInterface(localInterfaceAddress);\n+                    socket.setReuseAddress(true);\n+                    socket.setSoTimeout(INTERFACE_TIMEOUT_SEC * 1000);\n+                    socket.joinGroup(multicastAddress);\n+\n+                    byte[] requestData = DISCOVER_REQUEST.getBytes(\"UTF-8\");\n+                    DatagramPacket request = new DatagramPacket(requestData, requestData.length, multicastAddress,\n+                            PCHK_DISCOVERY_PORT);\n+                    socket.send(request);\n+\n+                    try {\n+                        do {\n+                            byte[] rxbuf = new byte[8192];\n+                            DatagramPacket packet = new DatagramPacket(rxbuf, rxbuf.length);\n+                            socket.receive(packet);\n+\n+                            InetAddress addr = packet.getAddress();\n+                            String response = new String(packet.getData());", "originalCommit": "67c50cbdbf636b589880d1f623187c9033c2d9e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0MDYxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438440615", "bodyText": "merge these two try-catch clauses into one.", "author": "cpmeister", "createdAt": "2020-06-10T22:23:53Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/pchkdiscovery/LcnPchkDiscoveryService.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.pchkdiscovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.thoughtworks.xstream.XStream;\n+import com.thoughtworks.xstream.io.xml.StaxDriver;\n+\n+/**\n+ * Discovers LCN-PCK gateways, such as LCN-PCHK.\n+ *\n+ * Scan approach:\n+ * 1. Determines all local network interfaces\n+ * 2. Send a multicast message on each interface to the PCHK multicast address 234.5.6.7 (not configurable by user).\n+ * 3. Evaluate multicast responses of PCK gateways in the network\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.lcn\")\n+public class LcnPchkDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(LcnPchkDiscoveryService.class);\n+    private static final String HOSTNAME = \"hostname\";\n+    private static final String PORT = \"port\";\n+    private static final String MAC_ADDRESS = \"macAddress\";\n+    private static final String PCHK_DISCOVERY_MULTICAST_ADDRESS = \"234.5.6.7\";\n+    private static final int PCHK_DISCOVERY_PORT = 4220;\n+    private static final int INTERFACE_TIMEOUT_SEC = 2;\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(LcnBindingConstants.THING_TYPE_PCK_GATEWAY).collect(Collectors.toSet()));\n+    private static final String DISCOVER_REQUEST = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><ServicesRequest xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:noNamespaceSchemaLocation=\\\"servicesrequest.xsd\\\"><Version major=\\\"1\\\" minor=\\\"0\\\" /><Requester requestId=\\\"1\\\" type=\\\"openHAB\\\" major=\\\"1\\\" minor=\\\"0\\\">openHAB</Requester><Requests><Request xsi:type=\\\"EnumServices\\\" major=\\\"1\\\" minor=\\\"0\\\" name=\\\"LcnPchkBus\\\" /></Requests></ServicesRequest>\";\n+\n+    public LcnPchkDiscoveryService() throws IllegalArgumentException {\n+        super(SUPPORTED_THING_TYPES_UIDS, 0, false);\n+    }\n+\n+    private List<InetAddress> getLocalAddresses() {\n+        List<InetAddress> result = new LinkedList<>();\n+        try {\n+            for (NetworkInterface networkInterface : Collections.list(NetworkInterface.getNetworkInterfaces())) {\n+                try {\n+                    if (networkInterface.isUp() && !networkInterface.isLoopback()\n+                            && !networkInterface.isPointToPoint()) {\n+                        result.addAll(Collections.list(networkInterface.getInetAddresses()));\n+                    }\n+                } catch (SocketException exception) {\n+                    // ignore\n+                }\n+            }\n+        } catch (SocketException exception) {\n+            return Collections.emptyList();\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        try {\n+            InetAddress multicastAddress = InetAddress.getByName(PCHK_DISCOVERY_MULTICAST_ADDRESS);\n+\n+            getLocalAddresses().forEach(localInterfaceAddress -> {\n+                logger.debug(\"Searching on {} ...\", localInterfaceAddress.getHostAddress());\n+                try (MulticastSocket socket = new MulticastSocket(PCHK_DISCOVERY_PORT)) {\n+                    socket.setInterface(localInterfaceAddress);\n+                    socket.setReuseAddress(true);\n+                    socket.setSoTimeout(INTERFACE_TIMEOUT_SEC * 1000);\n+                    socket.joinGroup(multicastAddress);\n+\n+                    byte[] requestData = DISCOVER_REQUEST.getBytes(\"UTF-8\");\n+                    DatagramPacket request = new DatagramPacket(requestData, requestData.length, multicastAddress,\n+                            PCHK_DISCOVERY_PORT);\n+                    socket.send(request);\n+\n+                    try {\n+                        do {\n+                            byte[] rxbuf = new byte[8192];\n+                            DatagramPacket packet = new DatagramPacket(rxbuf, rxbuf.length);\n+                            socket.receive(packet);\n+\n+                            InetAddress addr = packet.getAddress();\n+                            String response = new String(packet.getData());\n+\n+                            if (response.contains(\"ServicesRequest\")) {\n+                                continue;\n+                            }\n+\n+                            ServicesResponse deserialized = xmlToServiceResponse(response);\n+\n+                            String macAddress = deserialized.getServer().getMachineId().replace(\":\", \"\");\n+                            ThingUID thingUid = new ThingUID(LcnBindingConstants.THING_TYPE_PCK_GATEWAY, macAddress);\n+\n+                            Map<String, Object> properties = new HashMap<>(3);\n+                            properties.put(HOSTNAME, addr.getHostAddress());\n+                            properties.put(PORT, deserialized.getExtServices().getExtService().getLocalPort());\n+                            properties.put(MAC_ADDRESS, macAddress);\n+\n+                            DiscoveryResultBuilder discoveryResult = DiscoveryResultBuilder.create(thingUid)\n+                                    .withProperties(properties).withRepresentationProperty(MAC_ADDRESS)\n+                                    .withLabel(deserialized.getServer().getContent() + \" (\"\n+                                            + deserialized.getServer().getMachineName() + \")\");\n+\n+                            thingDiscovered(discoveryResult.build());\n+                        } while (true); // left by SocketTimeoutException\n+                    } catch (SocketTimeoutException e) {\n+                        // nothing\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Discovery failed for {}: {}\", localInterfaceAddress, e.getMessage());\n+                }", "originalCommit": "67c50cbdbf636b589880d1f623187c9033c2d9e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2024f87f82fafa8f69eb3e84fe885d3b062c1f32", "url": "https://github.com/openhab/openhab-addons/commit/2024f87f82fafa8f69eb3e84fe885d3b062c1f32", "message": "Incorporate review feedback No.6\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-06-13T18:51:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2NTAzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r439765030", "bodyText": "Is it necessary to add all these generics? Shouldn't the new state factory function just be a simple Function< AbstractStateMachine, AbstractState>?", "author": "cpmeister", "createdAt": "2020-06-13T19:57:44Z", "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/AbstractState.java", "diffHunk": "@@ -16,55 +16,61 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.concurrent.ScheduledFuture;\n+import java.util.function.Function;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n \n /**\n- * Base class for usage for states with {@link StateMachine}.\n+ * Base class for all states used with {@link AbstractStateMachine}.\n+ *\n+ * @param <T> type of the state machine implementation\n+ * @param <U> type of the state implementation\n  *\n  * @author Fabian Wolter - Initial Contribution\n  */\n @NonNullByDefault\n-public abstract class AbstractState {\n+public abstract class AbstractState<T extends AbstractStateMachine<T, U>, U extends AbstractState<T, U>> {", "originalCommit": "2024f87f82fafa8f69eb3e84fe885d3b062c1f32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgyOTI4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r439829288", "bodyText": "I tried several approaches, but couldn't get rid of the generics. Any suggestions?", "author": "fwolter", "createdAt": "2020-06-14T13:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2NTAzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg4MDQ3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r439880476", "bodyText": "Not sure what to say. As an example, this code compiles just fine:\n\n    public interface State {\n\n    }\n\n    public interface StateMachine {\n        public void nextState(Function<StateMachine, State> stateFactory);\n    }\n\n    public class StateImpl implements State {\n\n        private StateMachine context;\n\n        public StateImpl(StateMachine context) {\n            this.context = context;\n        }\n\n        public void changeState() {\n            context.nextState(StateImpl::new);\n        }\n    }", "author": "cpmeister", "createdAt": "2020-06-14T23:52:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2NTAzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM5NTk3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r440395979", "bodyText": "The problems arise when storing data in the context like the connection object. These data cannot be accessed from within StateImpl, because the reference to the context is of the interface's type. I used generics to be able to access the concrete type.\nThe state machine and state abstraction layer could be removed (and so the generics), but then the code wouldn't be reusable.\nAnother approach is to replace the generics by casts. If I see correctly only a single cast would be necessary.\nAs always, there are several solutions with their pros and cons. Maybe I hadn't the bright idea, yet.", "author": "fwolter", "createdAt": "2020-06-15T19:25:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2NTAzMA=="}], "type": "inlineReview"}]}