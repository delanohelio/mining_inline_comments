{"pr_number": 8586, "pr_title": "[pushover] Migration of Pushover OH1 action to OH3 binding", "pr_createdAt": "2020-09-26T18:27:53Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8586", "timeline": [{"oid": "b06a000703def9a230955953fc8c1b6250f09f7e", "url": "https://github.com/openhab/openhab-addons/commit/b06a000703def9a230955953fc8c1b6250f09f7e", "message": "Migration of Pushover OH1 action to OH3 binding\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>", "committedDate": "2020-09-27T09:30:09Z", "type": "forcePushed"}, {"oid": "8934592603a498a64ee49e60946cd5f9d7b2c212", "url": "https://github.com/openhab/openhab-addons/commit/8934592603a498a64ee49e60946cd5f9d7b2c212", "message": "Migration of Pushover OH1 action to OH3 binding\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>", "committedDate": "2020-10-21T12:47:26Z", "type": "forcePushed"}, {"oid": "4338b3324ac1eb7e5792ca4d84e901bf97131402", "url": "https://github.com/openhab/openhab-addons/commit/4338b3324ac1eb7e5792ca4d84e901bf97131402", "message": "Migration of Pushover OH1 action to OH3 binding\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>", "committedDate": "2020-10-29T07:46:39Z", "type": "forcePushed"}, {"oid": "51af453f8f0194a9824910750fc9e3f340337924", "url": "https://github.com/openhab/openhab-addons/commit/51af453f8f0194a9824910750fc9e3f340337924", "message": "Migration of Pushover OH1 action to OH3 binding\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>", "committedDate": "2020-11-21T15:11:40Z", "type": "commit"}, {"oid": "9a11f2c94a69353a49357f2b4b750ae2d6731a92", "url": "https://github.com/openhab/openhab-addons/commit/9a11f2c94a69353a49357f2b4b750ae2d6731a92", "message": "Finalized documentation\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>", "committedDate": "2020-11-21T15:17:17Z", "type": "commit"}, {"oid": "9a11f2c94a69353a49357f2b4b750ae2d6731a92", "url": "https://github.com/openhab/openhab-addons/commit/9a11f2c94a69353a49357f2b4b750ae2d6731a92", "message": "Finalized documentation\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>", "committedDate": "2020-11-21T15:17:17Z", "type": "forcePushed"}, {"oid": "ace20af50e86750ad0209089578f2350e058ce75", "url": "https://github.com/openhab/openhab-addons/commit/ace20af50e86750ad0209089578f2350e058ce75", "message": "Fixed ConfigOptionProvider for sounds\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>", "committedDate": "2020-11-21T16:26:16Z", "type": "commit"}, {"oid": "ace20af50e86750ad0209089578f2350e058ce75", "url": "https://github.com/openhab/openhab-addons/commit/ace20af50e86750ad0209089578f2350e058ce75", "message": "Fixed ConfigOptionProvider for sounds\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>", "committedDate": "2020-11-21T16:26:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5MDAyOA==", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r529190028", "bodyText": "Only call getCause() on the ExecutionException. The other exceptions don't have a cause.", "author": "cpmeister", "createdAt": "2020-11-24T04:11:22Z", "path": "bundles/org.openhab.binding.pushover/src/main/java/org/openhab/binding/pushover/internal/connection/PushoverAPIConnection.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.connection;\n+\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.pushover.internal.config.PushoverAccountConfiguration;\n+import org.openhab.binding.pushover.internal.dto.Sound;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link PushoverAPIConnection} is responsible for handling the connections to Pushover Messages API.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PushoverAPIConnection {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PushoverAPIConnection.class);\n+\n+    private static final String VALIDATE_URL = \"https://api.pushover.net/1/users/validate.json\";\n+    private static final String MESSAGE_URL = \"https://api.pushover.net/1/messages.json\";\n+    private static final String CANCEL_MESSAGE_URL = \"https://api.pushover.net/1/receipts/{receipt}/cancel.json\";\n+    private static final String SOUNDS_URL = \"https://api.pushover.net/1/sounds.json\";\n+\n+    private final HttpClient httpClient;\n+    private final PushoverAccountConfiguration config;\n+\n+    private final ExpiringCacheMap<String, String> cache = new ExpiringCacheMap<>(TimeUnit.DAYS.toMillis(1));\n+\n+    private final JsonParser parser = new JsonParser();\n+\n+    public PushoverAPIConnection(HttpClient httpClient, PushoverAccountConfiguration config) {\n+        this.httpClient = httpClient;\n+        this.config = config;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     * @throws PushoverCommunicationException\n+     * @throws PushoverConfigurationException\n+     */\n+    public boolean validateUser() throws PushoverCommunicationException, PushoverConfigurationException {\n+        return getMessageStatus(\n+                post(VALIDATE_URL, PushoverMessageBuilder.getInstance(config.apikey, config.user).build()));\n+    }\n+\n+    /**\n+     *\n+     * @param message\n+     * @return\n+     * @throws PushoverCommunicationException\n+     * @throws PushoverConfigurationException\n+     */\n+    public boolean sendMessage(PushoverMessageBuilder message)\n+            throws PushoverCommunicationException, PushoverConfigurationException {\n+        return getMessageStatus(post(MESSAGE_URL, message.build()));\n+    }\n+\n+    /**\n+     *\n+     * @param message\n+     * @return\n+     * @throws PushoverCommunicationException\n+     * @throws PushoverConfigurationException\n+     */\n+    public String sendPriorityMessage(PushoverMessageBuilder message)\n+            throws PushoverCommunicationException, PushoverConfigurationException {\n+        final JsonObject json = parser.parse(post(MESSAGE_URL, message.build())).getAsJsonObject();\n+        return getMessageStatus(json) && json.has(\"receipt\") ? json.get(\"receipt\").getAsString() : \"\";\n+    }\n+\n+    /**\n+     *\n+     * @param receipt\n+     * @return\n+     * @throws PushoverCommunicationException\n+     * @throws PushoverConfigurationException\n+     */\n+    public boolean cancelPriorityMessage(String receipt)\n+            throws PushoverCommunicationException, PushoverConfigurationException {\n+        return getMessageStatus(post(CANCEL_MESSAGE_URL.replace(\"{receipt}\", receipt),\n+                PushoverMessageBuilder.getInstance(config.apikey, config.user).build()));\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     * @throws PushoverCommunicationException\n+     * @throws PushoverConfigurationException\n+     */\n+    public List<Sound> getSounds() throws PushoverCommunicationException, PushoverConfigurationException {\n+        final String localApikey = config.apikey;\n+        if (localApikey == null || localApikey.isEmpty()) {\n+            throw new PushoverConfigurationException(\"@text/offline.conf-error-missing-apikey\");\n+        }\n+\n+        final Map<String, String> params = new HashMap<>(1);\n+        params.put(PushoverMessageBuilder.MESSAGE_KEY_TOKEN, localApikey);\n+\n+        // TODO do not cache the response, cache the parsed list of sounds\n+        final JsonObject json = parser.parse(getFromCache(buildURL(SOUNDS_URL, params))).getAsJsonObject();\n+        if (json.has(\"sounds\")) {\n+            final JsonObject sounds = json.get(\"sounds\").getAsJsonObject();\n+            if (sounds != null) {\n+                return Collections.unmodifiableList(sounds.entrySet().stream()\n+                        .map(entry -> new Sound(entry.getKey(), entry.getValue().getAsString()))\n+                        .collect(Collectors.toList()));\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    private String buildURL(String url, Map<String, String> requestParams) {\n+        return requestParams.keySet().stream().map(key -> key + \"=\" + encodeParam(requestParams.get(key)))\n+                .collect(Collectors.joining(\"&\", url + \"?\", \"\"));\n+    }\n+\n+    private String encodeParam(@Nullable String value) {\n+        return value == null ? \"\" : URLEncoder.encode(value, StandardCharsets.UTF_8);\n+    }\n+\n+    private @Nullable String getFromCache(String url) {\n+        return cache.putIfAbsentAndGet(url, () -> get(url));\n+    }\n+\n+    private String get(String url) throws PushoverCommunicationException, PushoverConfigurationException {\n+        return executeRequest(HttpMethod.GET, url, null);\n+    }\n+\n+    private String post(String url, ContentProvider body)\n+            throws PushoverCommunicationException, PushoverConfigurationException {\n+        return executeRequest(HttpMethod.POST, url, body);\n+    }\n+\n+    private String executeRequest(HttpMethod httpMethod, String url, @Nullable ContentProvider body)\n+            throws PushoverCommunicationException, PushoverConfigurationException {\n+        logger.trace(\"Pushover request: {} - URL = '{}'\", httpMethod, url);\n+        try {\n+            final Request request = httpClient.newRequest(url).method(httpMethod).timeout(10, TimeUnit.SECONDS);\n+\n+            if (body != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"Pushover request body: '{}'\", body);\n+                }\n+                request.content(body);\n+            }\n+\n+            final ContentResponse contentResponse = request.send();\n+\n+            final int httpStatus = contentResponse.getStatus();\n+            final String content = contentResponse.getContentAsString();\n+            logger.trace(\"Pushover response: status = {}, content = '{}'\", httpStatus, content);\n+            switch (httpStatus) {\n+                case HttpStatus.OK_200:\n+                    return content;\n+                case HttpStatus.BAD_REQUEST_400:\n+                    logger.debug(\"Pushover server responded with status code {}: {}\", httpStatus, content);\n+                    throw new PushoverConfigurationException(getMessageError(content));\n+                default:\n+                    logger.debug(\"Pushover server responded with status code {}: {}\", httpStatus, content);\n+                    throw new PushoverCommunicationException(content);\n+            }\n+        } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+            logger.debug(\"Exception occurred during execution: {}\", e.getLocalizedMessage(), e);\n+            throw new PushoverCommunicationException(e.getLocalizedMessage(), e.getCause());", "originalCommit": "ace20af50e86750ad0209089578f2350e058ce75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5MDQyMA==", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r529190420", "bodyText": "If you aren't going to fill out the javadocs, then feel free to remove them.", "author": "cpmeister", "createdAt": "2020-11-24T04:12:57Z", "path": "bundles/org.openhab.binding.pushover/src/main/java/org/openhab/binding/pushover/internal/connection/PushoverAPIConnection.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.connection;\n+\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.pushover.internal.config.PushoverAccountConfiguration;\n+import org.openhab.binding.pushover.internal.dto.Sound;\n+import org.openhab.core.cache.ExpiringCacheMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link PushoverAPIConnection} is responsible for handling the connections to Pushover Messages API.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PushoverAPIConnection {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PushoverAPIConnection.class);\n+\n+    private static final String VALIDATE_URL = \"https://api.pushover.net/1/users/validate.json\";\n+    private static final String MESSAGE_URL = \"https://api.pushover.net/1/messages.json\";\n+    private static final String CANCEL_MESSAGE_URL = \"https://api.pushover.net/1/receipts/{receipt}/cancel.json\";\n+    private static final String SOUNDS_URL = \"https://api.pushover.net/1/sounds.json\";\n+\n+    private final HttpClient httpClient;\n+    private final PushoverAccountConfiguration config;\n+\n+    private final ExpiringCacheMap<String, String> cache = new ExpiringCacheMap<>(TimeUnit.DAYS.toMillis(1));\n+\n+    private final JsonParser parser = new JsonParser();\n+\n+    public PushoverAPIConnection(HttpClient httpClient, PushoverAccountConfiguration config) {\n+        this.httpClient = httpClient;\n+        this.config = config;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     * @throws PushoverCommunicationException\n+     * @throws PushoverConfigurationException\n+     */\n+    public boolean validateUser() throws PushoverCommunicationException, PushoverConfigurationException {\n+        return getMessageStatus(\n+                post(VALIDATE_URL, PushoverMessageBuilder.getInstance(config.apikey, config.user).build()));\n+    }\n+\n+    /**\n+     *\n+     * @param message\n+     * @return\n+     * @throws PushoverCommunicationException\n+     * @throws PushoverConfigurationException\n+     */", "originalCommit": "ace20af50e86750ad0209089578f2350e058ce75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIxMDQ5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r529210491", "bodyText": "Can this TODO be done?", "author": "cpmeister", "createdAt": "2020-11-24T05:23:57Z", "path": "bundles/org.openhab.binding.pushover/src/main/java/org/openhab/binding/pushover/internal/connection/PushoverMessageBuilder.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.connection;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.util.MultiPartContentProvider;\n+import org.eclipse.jetty.client.util.PathContentProvider;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PushoverMessageBuilder} builds the body for Pushover Messages API requests.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PushoverMessageBuilder {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PushoverMessageBuilder.class);\n+\n+    public static final String MESSAGE_KEY_TOKEN = \"token\";\n+    private static final String MESSAGE_KEY_USER = \"user\";\n+    private static final String MESSAGE_KEY_MESSAGE = \"message\";\n+    private static final String MESSAGE_KEY_TITLE = \"title\";\n+    private static final String MESSAGE_KEY_DEVICE = \"device\";\n+    private static final String MESSAGE_KEY_PRIORITY = \"priority\";\n+    private static final String MESSAGE_KEY_RETRY = \"retry\";\n+    private static final String MESSAGE_KEY_EXPIRE = \"expire\";\n+    private static final String MESSAGE_KEY_URL = \"url\";\n+    private static final String MESSAGE_KEY_URL_TITLE = \"url_title\";\n+    private static final String MESSAGE_KEY_SOUND = \"sound\";\n+    private static final String MESSAGE_KEY_ATTACHMENT = \"attachment\";\n+    public static final String MESSAGE_KEY_HTML = \"html\";\n+    public static final String MESSAGE_KEY_MONOSPACE = \"monospace\";\n+\n+    private static final int MAX_MESSAGE_LENGTH = 1024;\n+    private static final int MAX_TITLE_LENGTH = 250;\n+    private static final int MAX_DEVICE_LENGTH = 25;\n+    private static final List<Integer> VALID_PRIORITY_LIST = Arrays.asList(-2, -1, 0, 1, 2);\n+    private static final int DEFAULT_PRIORITY = 0;\n+    public static final int EMERGENCY_PRIORITY = 2;\n+    private static final int MIN_RETRY_SECONDS = 30;\n+    private static final int MAX_EXPIRE_SECONDS = 10800;\n+    private static final int MAX_URL_LENGTH = 512;\n+    private static final int MAX_URL_TITLE_LENGTH = 100;\n+    public static final String DEFAULT_CONTENT_TYPE = \"image/jpeg\";\n+\n+    private final MultiPartContentProvider body = new MultiPartContentProvider();\n+\n+    private @Nullable String message;\n+    private @Nullable String title;\n+    private @Nullable String device;\n+    private int priority = DEFAULT_PRIORITY;\n+    private int retry = 300;\n+    private int expire = 3600;\n+    private @Nullable String url;\n+    private @Nullable String urlTitle;\n+    private @Nullable String sound;\n+    private @Nullable String attachment;\n+    private String contentType = DEFAULT_CONTENT_TYPE;\n+    private boolean html = false;\n+    private boolean monospace = false;\n+\n+    private PushoverMessageBuilder(String apikey, String user) throws PushoverConfigurationException {\n+        body.addFieldPart(MESSAGE_KEY_TOKEN, new StringContentProvider(apikey), null);\n+        body.addFieldPart(MESSAGE_KEY_USER, new StringContentProvider(user), null);\n+    }\n+\n+    public static PushoverMessageBuilder getInstance(@Nullable String apikey, @Nullable String user)\n+            throws PushoverConfigurationException {\n+        if (apikey == null || apikey.isEmpty()) {\n+            throw new PushoverConfigurationException(\"@text/offline.conf-error-missing-apikey\");\n+        }\n+\n+        if (user == null || user.isEmpty()) {\n+            throw new PushoverConfigurationException(\"@text/offline.conf-error-missing-user\");\n+        }\n+\n+        return new PushoverMessageBuilder(apikey, user);\n+    }\n+\n+    public PushoverMessageBuilder withMessage(String message) {\n+        this.message = message;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withTitle(String title) {\n+        this.title = title;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withDevice(String device) {\n+        this.device = device;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withPriority(int priority) {\n+        this.priority = priority;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withRetry(int retry) {\n+        this.retry = retry;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withExpire(int expire) {\n+        this.expire = expire;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withUrl(String url) {\n+        this.url = url;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withUrlTitle(String urlTitle) {\n+        this.urlTitle = urlTitle;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withSound(String sound) {\n+        this.sound = sound;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withAttachment(String attachment) {\n+        this.attachment = attachment;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withContentType(String contentType) {\n+        this.contentType = contentType;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withHtmlFormatting() {\n+        this.html = true;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withMonospaceFormatting() {\n+        this.monospace = true;\n+        return this;\n+    }\n+\n+    public ContentProvider build() {\n+        if (message != null) {\n+            if (message.length() > MAX_MESSAGE_LENGTH) {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Skip sending the message as 'message' is longer than %d characters.\", MAX_MESSAGE_LENGTH));\n+            }\n+            body.addFieldPart(MESSAGE_KEY_MESSAGE, new StringContentProvider(message), null);\n+        }\n+\n+        if (title != null) {\n+            if (title.length() > MAX_TITLE_LENGTH) {\n+                throw new IllegalArgumentException(String\n+                        .format(\"Skip sending the message as 'title' is longer than %d characters.\", MAX_TITLE_LENGTH));\n+            }\n+            body.addFieldPart(MESSAGE_KEY_TITLE, new StringContentProvider(title), null);\n+        }\n+\n+        if (device != null) {\n+            if (device.length() > MAX_DEVICE_LENGTH) {\n+                logger.warn(\"Skip 'device' as it is longer than {} characters. Got: {}.\", MAX_DEVICE_LENGTH, device);\n+            } else {\n+                // TODO [A-Za-z0-9_-]\n+                // TODO Messages may be addressed to multiple specific devices by joining them with a comma (such as\n+                // device=iphone,nexus5)", "originalCommit": "ace20af50e86750ad0209089578f2350e058ce75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY1OTU2MA==", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r529659560", "bodyText": "Not needed anymore. Can be passed by parameter directly.", "author": "cweitkamp", "createdAt": "2020-11-24T15:45:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIxMDQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIxMTExNA==", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r529211114", "bodyText": "A thing with no handler?", "author": "cpmeister", "createdAt": "2020-11-24T05:25:44Z", "path": "bundles/org.openhab.binding.pushover/src/main/java/org/openhab/binding/pushover/internal/factory/PushoverHandlerFactory.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.factory;\n+\n+import static org.openhab.binding.pushover.internal.PushoverBindingConstants.*;\n+\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.pushover.internal.handler.PushoverAccountHandler;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link PushoverHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@Component(configurationPid = \"binding.pushover\", service = ThingHandlerFactory.class)\n+@NonNullByDefault\n+public class PushoverHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Set.of(PUSHOVER_ACCOUNT, PUSHOVER_USER);\n+\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public PushoverHandlerFactory(final @Reference HttpClientFactory httpClientFactory) {\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        final ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (PUSHOVER_ACCOUNT.equals(thingTypeUID)) {\n+            return new PushoverAccountHandler(thing, httpClient);\n+        } else if (PUSHOVER_USER.equals(thingTypeUID)) {\n+            return null;", "originalCommit": "ace20af50e86750ad0209089578f2350e058ce75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIxMTc4MA==", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r529211780", "bodyText": "can this be done?", "author": "cpmeister", "createdAt": "2020-11-24T05:28:19Z", "path": "bundles/org.openhab.binding.pushover/src/main/java/org/openhab/binding/pushover/internal/connection/PushoverMessageBuilder.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.connection;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.util.MultiPartContentProvider;\n+import org.eclipse.jetty.client.util.PathContentProvider;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PushoverMessageBuilder} builds the body for Pushover Messages API requests.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PushoverMessageBuilder {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PushoverMessageBuilder.class);\n+\n+    public static final String MESSAGE_KEY_TOKEN = \"token\";\n+    private static final String MESSAGE_KEY_USER = \"user\";\n+    private static final String MESSAGE_KEY_MESSAGE = \"message\";\n+    private static final String MESSAGE_KEY_TITLE = \"title\";\n+    private static final String MESSAGE_KEY_DEVICE = \"device\";\n+    private static final String MESSAGE_KEY_PRIORITY = \"priority\";\n+    private static final String MESSAGE_KEY_RETRY = \"retry\";\n+    private static final String MESSAGE_KEY_EXPIRE = \"expire\";\n+    private static final String MESSAGE_KEY_URL = \"url\";\n+    private static final String MESSAGE_KEY_URL_TITLE = \"url_title\";\n+    private static final String MESSAGE_KEY_SOUND = \"sound\";\n+    private static final String MESSAGE_KEY_ATTACHMENT = \"attachment\";\n+    public static final String MESSAGE_KEY_HTML = \"html\";\n+    public static final String MESSAGE_KEY_MONOSPACE = \"monospace\";\n+\n+    private static final int MAX_MESSAGE_LENGTH = 1024;\n+    private static final int MAX_TITLE_LENGTH = 250;\n+    private static final int MAX_DEVICE_LENGTH = 25;\n+    private static final List<Integer> VALID_PRIORITY_LIST = Arrays.asList(-2, -1, 0, 1, 2);\n+    private static final int DEFAULT_PRIORITY = 0;\n+    public static final int EMERGENCY_PRIORITY = 2;\n+    private static final int MIN_RETRY_SECONDS = 30;\n+    private static final int MAX_EXPIRE_SECONDS = 10800;\n+    private static final int MAX_URL_LENGTH = 512;\n+    private static final int MAX_URL_TITLE_LENGTH = 100;\n+    public static final String DEFAULT_CONTENT_TYPE = \"image/jpeg\";\n+\n+    private final MultiPartContentProvider body = new MultiPartContentProvider();\n+\n+    private @Nullable String message;\n+    private @Nullable String title;\n+    private @Nullable String device;\n+    private int priority = DEFAULT_PRIORITY;\n+    private int retry = 300;\n+    private int expire = 3600;\n+    private @Nullable String url;\n+    private @Nullable String urlTitle;\n+    private @Nullable String sound;\n+    private @Nullable String attachment;\n+    private String contentType = DEFAULT_CONTENT_TYPE;\n+    private boolean html = false;\n+    private boolean monospace = false;\n+\n+    private PushoverMessageBuilder(String apikey, String user) throws PushoverConfigurationException {\n+        body.addFieldPart(MESSAGE_KEY_TOKEN, new StringContentProvider(apikey), null);\n+        body.addFieldPart(MESSAGE_KEY_USER, new StringContentProvider(user), null);\n+    }\n+\n+    public static PushoverMessageBuilder getInstance(@Nullable String apikey, @Nullable String user)\n+            throws PushoverConfigurationException {\n+        if (apikey == null || apikey.isEmpty()) {\n+            throw new PushoverConfigurationException(\"@text/offline.conf-error-missing-apikey\");\n+        }\n+\n+        if (user == null || user.isEmpty()) {\n+            throw new PushoverConfigurationException(\"@text/offline.conf-error-missing-user\");\n+        }\n+\n+        return new PushoverMessageBuilder(apikey, user);\n+    }\n+\n+    public PushoverMessageBuilder withMessage(String message) {\n+        this.message = message;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withTitle(String title) {\n+        this.title = title;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withDevice(String device) {\n+        this.device = device;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withPriority(int priority) {\n+        this.priority = priority;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withRetry(int retry) {\n+        this.retry = retry;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withExpire(int expire) {\n+        this.expire = expire;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withUrl(String url) {\n+        this.url = url;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withUrlTitle(String urlTitle) {\n+        this.urlTitle = urlTitle;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withSound(String sound) {\n+        this.sound = sound;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withAttachment(String attachment) {\n+        this.attachment = attachment;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withContentType(String contentType) {\n+        this.contentType = contentType;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withHtmlFormatting() {\n+        this.html = true;\n+        return this;\n+    }\n+\n+    public PushoverMessageBuilder withMonospaceFormatting() {\n+        this.monospace = true;\n+        return this;\n+    }\n+\n+    public ContentProvider build() {\n+        if (message != null) {\n+            if (message.length() > MAX_MESSAGE_LENGTH) {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Skip sending the message as 'message' is longer than %d characters.\", MAX_MESSAGE_LENGTH));\n+            }\n+            body.addFieldPart(MESSAGE_KEY_MESSAGE, new StringContentProvider(message), null);\n+        }\n+\n+        if (title != null) {\n+            if (title.length() > MAX_TITLE_LENGTH) {\n+                throw new IllegalArgumentException(String\n+                        .format(\"Skip sending the message as 'title' is longer than %d characters.\", MAX_TITLE_LENGTH));\n+            }\n+            body.addFieldPart(MESSAGE_KEY_TITLE, new StringContentProvider(title), null);\n+        }\n+\n+        if (device != null) {\n+            if (device.length() > MAX_DEVICE_LENGTH) {\n+                logger.warn(\"Skip 'device' as it is longer than {} characters. Got: {}.\", MAX_DEVICE_LENGTH, device);\n+            } else {\n+                // TODO [A-Za-z0-9_-]\n+                // TODO Messages may be addressed to multiple specific devices by joining them with a comma (such as\n+                // device=iphone,nexus5)\n+                body.addFieldPart(MESSAGE_KEY_DEVICE, new StringContentProvider(device), null);\n+            }\n+        }\n+\n+        if (priority != DEFAULT_PRIORITY) {\n+            if (VALID_PRIORITY_LIST.contains(priority)) {\n+                body.addFieldPart(MESSAGE_KEY_PRIORITY, new StringContentProvider(String.valueOf(priority)), null);\n+\n+                if (priority == EMERGENCY_PRIORITY) {\n+                    if (retry < MIN_RETRY_SECONDS) {\n+                        logger.warn(\"Retry value of {} is too small. Using default value of {}.\", retry,\n+                                MIN_RETRY_SECONDS);\n+                        body.addFieldPart(MESSAGE_KEY_RETRY,\n+                                new StringContentProvider(String.valueOf(MIN_RETRY_SECONDS)), null);\n+                    } else {\n+                        body.addFieldPart(MESSAGE_KEY_RETRY, new StringContentProvider(String.valueOf(retry)), null);\n+                    }\n+\n+                    if (0 < expire && expire <= MAX_EXPIRE_SECONDS) {\n+                        body.addFieldPart(MESSAGE_KEY_EXPIRE, new StringContentProvider(String.valueOf(expire)), null);\n+                    } else {\n+                        logger.warn(\"Expire value of {} is invalid. Using default value of {}.\", expire,\n+                                MAX_EXPIRE_SECONDS);\n+                        body.addFieldPart(MESSAGE_KEY_EXPIRE,\n+                                new StringContentProvider(String.valueOf(MAX_EXPIRE_SECONDS)), null);\n+                    }\n+                }\n+            } else {\n+                logger.warn(\"Invalid 'priority', skipping. Expected: {}. Got: {}.\",\n+                        VALID_PRIORITY_LIST.stream().map(i -> i.toString()).collect(Collectors.joining(\",\")), priority);\n+            }\n+        }\n+\n+        if (url != null) {\n+            if (url.length() > MAX_URL_LENGTH) {\n+                throw new IllegalArgumentException(String\n+                        .format(\"Skip sending the message as 'url' is longer than %d characters.\", MAX_URL_LENGTH));\n+            }\n+            body.addFieldPart(MESSAGE_KEY_URL, new StringContentProvider(url), null);\n+\n+            if (urlTitle != null) {\n+                if (urlTitle.length() > MAX_URL_TITLE_LENGTH) {\n+                    throw new IllegalArgumentException(\n+                            String.format(\"Skip sending the message as 'urlTitle' is longer than %d characters.\",\n+                                    MAX_URL_TITLE_LENGTH));\n+                }\n+                body.addFieldPart(MESSAGE_KEY_URL_TITLE, new StringContentProvider(urlTitle), null);\n+            }\n+        }\n+\n+        if (sound != null) {\n+            // TODO validate sound", "originalCommit": "ace20af50e86750ad0209089578f2350e058ce75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY1OTI2NA==", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r529659264", "bodyText": "Not needed anymore. Sounds are now provided by a ConfigOptionsProvider.", "author": "cweitkamp", "createdAt": "2020-11-24T15:45:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIxMTc4MA=="}], "type": "inlineReview"}, {"oid": "bb6ecd2d461d1c78bb2798dc4326ce72f09cb51f", "url": "https://github.com/openhab/openhab-addons/commit/bb6ecd2d461d1c78bb2798dc4326ce72f09cb51f", "message": "Incorporated comments from review\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>", "committedDate": "2020-11-24T15:44:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMzkxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r530613911", "bodyText": "please remove these if they aren't needed.", "author": "cpmeister", "createdAt": "2020-11-25T19:59:56Z", "path": "bundles/org.openhab.binding.pushover/src/test/java/org/openhab/binding/pushover/internal/actions/PushoverActionsTest.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.actions;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.junit.jupiter.MockitoSettings;\n+import org.mockito.quality.Strictness;\n+import org.openhab.binding.pushover.internal.connection.PushoverMessageBuilder;\n+import org.openhab.binding.pushover.internal.handler.PushoverAccountHandler;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * Unit tests for {@link PushoverActions}.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@MockitoSettings(strictness = Strictness.WARN)\n+public class PushoverActionsTest {\n+\n+    private static final String MESSAGE = \"My Message\";\n+    private static final String TITLE = \"My Title\";\n+    private static final String URL = \"https://www.test.com\";\n+    private static final String URL_TITLE = \"Some Link\";\n+    private static final String RECEIPT = \"12345\";\n+\n+    @NonNullByDefault\n+    private final ThingActions thingActionsStub = new ThingActions() {\n+        @Override\n+        public void setThingHandler(ThingHandler handler) {\n+        }\n+\n+        @Override\n+        public @Nullable ThingHandler getThingHandler() {\n+            return null;\n+        }\n+    };\n+\n+    private @Mock PushoverAccountHandler mockPushoverAccountHandler;\n+\n+    private PushoverActions pushoverThingActions;\n+\n+    @BeforeEach\n+    public void setUp() {\n+        pushoverThingActions = new PushoverActions();\n+\n+        when(mockPushoverAccountHandler.getDefaultPushoverMessageBuilder(any()))\n+                .thenReturn(PushoverMessageBuilder.getInstance(\"key\", \"user\"));\n+        when(mockPushoverAccountHandler.sendMessage(any())).thenReturn(Boolean.TRUE);\n+        when(mockPushoverAccountHandler.sendPriorityMessage(any())).thenReturn(RECEIPT);\n+        when(mockPushoverAccountHandler.cancelPriorityMessage(RECEIPT)).thenReturn(Boolean.TRUE);\n+    }\n+\n+    // sendMessage\n+    @Test\n+    public void testSendMessageThingActionsIsNotPushoverThingActions() {\n+        assertThrows(ClassCastException.class, () -> PushoverActions.sendMessage(thingActionsStub, MESSAGE, TITLE));\n+    }\n+\n+    @Test\n+    public void testSendMessageThingHandlerIsNull() {\n+        assertThrows(RuntimeException.class, () -> PushoverActions.sendMessage(pushoverThingActions, MESSAGE, TITLE));\n+    }\n+\n+    // @Test\n+    // public void testSendMessageWithoutMessage() {\n+    // Optional<String> message = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class,\n+    // () -> PushoverActions.sendMessage(pushoverThingActions, message.get(), TITLE));\n+    // }\n+\n+    @Test\n+    public void testSendMessageWithoutTitle() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendMessage(pushoverThingActions, MESSAGE, null);\n+        assertThat(sent, is(true));\n+    }\n+\n+    @Test\n+    public void testSendMessage() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendMessage(pushoverThingActions, MESSAGE, TITLE);\n+        assertThat(sent, is(true));\n+    }\n+\n+    // sendURLMessage\n+    @Test\n+    public void testSendURLMessageThingActionsIsNotPushoverThingActions() {\n+        assertThrows(ClassCastException.class,\n+                () -> PushoverActions.sendURLMessage(thingActionsStub, MESSAGE, TITLE, URL, URL_TITLE));\n+    }\n+\n+    @Test\n+    public void testSendURLMessageThingHandlerIsNull() {\n+        assertThrows(RuntimeException.class,\n+                () -> PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, TITLE, URL, URL_TITLE));\n+    }\n+\n+    // @Test\n+    // public void testSendURLMessageWithoutMessage() {\n+    // pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+    // Optional<String> message = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class,\n+    // () -> PushoverActions.sendURLMessage(pushoverThingActions, message.get(), TITLE, URL, URL_TITLE));\n+    // }\n+\n+    // @Test\n+    // public void testSendURLMessageWithoutURL() {\n+    // pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+    // Optional<String> url = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class,\n+    // () -> PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, TITLE, url.get(), URL_TITLE));\n+    // }", "originalCommit": "bb6ecd2d461d1c78bb2798dc4326ce72f09cb51f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMzk3OA==", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r530613978", "bodyText": "same here", "author": "cpmeister", "createdAt": "2020-11-25T20:00:03Z", "path": "bundles/org.openhab.binding.pushover/src/test/java/org/openhab/binding/pushover/internal/actions/PushoverActionsTest.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.actions;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.junit.jupiter.MockitoSettings;\n+import org.mockito.quality.Strictness;\n+import org.openhab.binding.pushover.internal.connection.PushoverMessageBuilder;\n+import org.openhab.binding.pushover.internal.handler.PushoverAccountHandler;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * Unit tests for {@link PushoverActions}.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@MockitoSettings(strictness = Strictness.WARN)\n+public class PushoverActionsTest {\n+\n+    private static final String MESSAGE = \"My Message\";\n+    private static final String TITLE = \"My Title\";\n+    private static final String URL = \"https://www.test.com\";\n+    private static final String URL_TITLE = \"Some Link\";\n+    private static final String RECEIPT = \"12345\";\n+\n+    @NonNullByDefault\n+    private final ThingActions thingActionsStub = new ThingActions() {\n+        @Override\n+        public void setThingHandler(ThingHandler handler) {\n+        }\n+\n+        @Override\n+        public @Nullable ThingHandler getThingHandler() {\n+            return null;\n+        }\n+    };\n+\n+    private @Mock PushoverAccountHandler mockPushoverAccountHandler;\n+\n+    private PushoverActions pushoverThingActions;\n+\n+    @BeforeEach\n+    public void setUp() {\n+        pushoverThingActions = new PushoverActions();\n+\n+        when(mockPushoverAccountHandler.getDefaultPushoverMessageBuilder(any()))\n+                .thenReturn(PushoverMessageBuilder.getInstance(\"key\", \"user\"));\n+        when(mockPushoverAccountHandler.sendMessage(any())).thenReturn(Boolean.TRUE);\n+        when(mockPushoverAccountHandler.sendPriorityMessage(any())).thenReturn(RECEIPT);\n+        when(mockPushoverAccountHandler.cancelPriorityMessage(RECEIPT)).thenReturn(Boolean.TRUE);\n+    }\n+\n+    // sendMessage\n+    @Test\n+    public void testSendMessageThingActionsIsNotPushoverThingActions() {\n+        assertThrows(ClassCastException.class, () -> PushoverActions.sendMessage(thingActionsStub, MESSAGE, TITLE));\n+    }\n+\n+    @Test\n+    public void testSendMessageThingHandlerIsNull() {\n+        assertThrows(RuntimeException.class, () -> PushoverActions.sendMessage(pushoverThingActions, MESSAGE, TITLE));\n+    }\n+\n+    // @Test\n+    // public void testSendMessageWithoutMessage() {\n+    // Optional<String> message = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class,\n+    // () -> PushoverActions.sendMessage(pushoverThingActions, message.get(), TITLE));\n+    // }\n+\n+    @Test\n+    public void testSendMessageWithoutTitle() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendMessage(pushoverThingActions, MESSAGE, null);\n+        assertThat(sent, is(true));\n+    }\n+\n+    @Test\n+    public void testSendMessage() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendMessage(pushoverThingActions, MESSAGE, TITLE);\n+        assertThat(sent, is(true));\n+    }\n+\n+    // sendURLMessage\n+    @Test\n+    public void testSendURLMessageThingActionsIsNotPushoverThingActions() {\n+        assertThrows(ClassCastException.class,\n+                () -> PushoverActions.sendURLMessage(thingActionsStub, MESSAGE, TITLE, URL, URL_TITLE));\n+    }\n+\n+    @Test\n+    public void testSendURLMessageThingHandlerIsNull() {\n+        assertThrows(RuntimeException.class,\n+                () -> PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, TITLE, URL, URL_TITLE));\n+    }\n+\n+    // @Test\n+    // public void testSendURLMessageWithoutMessage() {\n+    // pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+    // Optional<String> message = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class,\n+    // () -> PushoverActions.sendURLMessage(pushoverThingActions, message.get(), TITLE, URL, URL_TITLE));\n+    // }\n+\n+    // @Test\n+    // public void testSendURLMessageWithoutURL() {\n+    // pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+    // Optional<String> url = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class,\n+    // () -> PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, TITLE, url.get(), URL_TITLE));\n+    // }\n+\n+    @Test\n+    public void testSendURLMessageWithoutTitle() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, null, URL, URL_TITLE);\n+        assertThat(sent, is(true));\n+    }\n+\n+    @Test\n+    public void testSendURLMessageWithoutURLTitle() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, TITLE, URL, null);\n+        assertThat(sent, is(true));\n+    }\n+\n+    @Test\n+    public void testSendURLMessage() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, TITLE, URL, URL_TITLE);\n+        assertThat(sent, is(true));\n+    }\n+\n+    // sendPriorityMessage\n+    @Test\n+    public void testSendPriorityMessageThingActionsIsNotPushoverThingActions() {\n+        assertThrows(ClassCastException.class, () -> PushoverActions.sendPriorityMessage(thingActionsStub, MESSAGE,\n+                TITLE, PushoverMessageBuilder.EMERGENCY_PRIORITY));\n+    }\n+\n+    @Test\n+    public void testSendPriorityMessageThingHandlerIsNull() {\n+        assertThrows(RuntimeException.class, () -> PushoverActions.sendPriorityMessage(pushoverThingActions, MESSAGE,\n+                TITLE, PushoverMessageBuilder.EMERGENCY_PRIORITY));\n+    }\n+\n+    // @Test\n+    // public void testSendPriorityMessageWithoutMessage() {\n+    // pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+    // Optional<String> message = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class, () -> PushoverActions.sendPriorityMessage(pushoverThingActions,\n+    // message.get(), TITLE, PushoverMessageBuilder.EMERGENCY_PRIORITY));\n+    // }", "originalCommit": "bb6ecd2d461d1c78bb2798dc4326ce72f09cb51f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNDAzOA==", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r530614038", "bodyText": "and here", "author": "cpmeister", "createdAt": "2020-11-25T20:00:09Z", "path": "bundles/org.openhab.binding.pushover/src/test/java/org/openhab/binding/pushover/internal/actions/PushoverActionsTest.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.actions;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.junit.jupiter.MockitoSettings;\n+import org.mockito.quality.Strictness;\n+import org.openhab.binding.pushover.internal.connection.PushoverMessageBuilder;\n+import org.openhab.binding.pushover.internal.handler.PushoverAccountHandler;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * Unit tests for {@link PushoverActions}.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@MockitoSettings(strictness = Strictness.WARN)\n+public class PushoverActionsTest {\n+\n+    private static final String MESSAGE = \"My Message\";\n+    private static final String TITLE = \"My Title\";\n+    private static final String URL = \"https://www.test.com\";\n+    private static final String URL_TITLE = \"Some Link\";\n+    private static final String RECEIPT = \"12345\";\n+\n+    @NonNullByDefault\n+    private final ThingActions thingActionsStub = new ThingActions() {\n+        @Override\n+        public void setThingHandler(ThingHandler handler) {\n+        }\n+\n+        @Override\n+        public @Nullable ThingHandler getThingHandler() {\n+            return null;\n+        }\n+    };\n+\n+    private @Mock PushoverAccountHandler mockPushoverAccountHandler;\n+\n+    private PushoverActions pushoverThingActions;\n+\n+    @BeforeEach\n+    public void setUp() {\n+        pushoverThingActions = new PushoverActions();\n+\n+        when(mockPushoverAccountHandler.getDefaultPushoverMessageBuilder(any()))\n+                .thenReturn(PushoverMessageBuilder.getInstance(\"key\", \"user\"));\n+        when(mockPushoverAccountHandler.sendMessage(any())).thenReturn(Boolean.TRUE);\n+        when(mockPushoverAccountHandler.sendPriorityMessage(any())).thenReturn(RECEIPT);\n+        when(mockPushoverAccountHandler.cancelPriorityMessage(RECEIPT)).thenReturn(Boolean.TRUE);\n+    }\n+\n+    // sendMessage\n+    @Test\n+    public void testSendMessageThingActionsIsNotPushoverThingActions() {\n+        assertThrows(ClassCastException.class, () -> PushoverActions.sendMessage(thingActionsStub, MESSAGE, TITLE));\n+    }\n+\n+    @Test\n+    public void testSendMessageThingHandlerIsNull() {\n+        assertThrows(RuntimeException.class, () -> PushoverActions.sendMessage(pushoverThingActions, MESSAGE, TITLE));\n+    }\n+\n+    // @Test\n+    // public void testSendMessageWithoutMessage() {\n+    // Optional<String> message = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class,\n+    // () -> PushoverActions.sendMessage(pushoverThingActions, message.get(), TITLE));\n+    // }\n+\n+    @Test\n+    public void testSendMessageWithoutTitle() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendMessage(pushoverThingActions, MESSAGE, null);\n+        assertThat(sent, is(true));\n+    }\n+\n+    @Test\n+    public void testSendMessage() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendMessage(pushoverThingActions, MESSAGE, TITLE);\n+        assertThat(sent, is(true));\n+    }\n+\n+    // sendURLMessage\n+    @Test\n+    public void testSendURLMessageThingActionsIsNotPushoverThingActions() {\n+        assertThrows(ClassCastException.class,\n+                () -> PushoverActions.sendURLMessage(thingActionsStub, MESSAGE, TITLE, URL, URL_TITLE));\n+    }\n+\n+    @Test\n+    public void testSendURLMessageThingHandlerIsNull() {\n+        assertThrows(RuntimeException.class,\n+                () -> PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, TITLE, URL, URL_TITLE));\n+    }\n+\n+    // @Test\n+    // public void testSendURLMessageWithoutMessage() {\n+    // pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+    // Optional<String> message = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class,\n+    // () -> PushoverActions.sendURLMessage(pushoverThingActions, message.get(), TITLE, URL, URL_TITLE));\n+    // }\n+\n+    // @Test\n+    // public void testSendURLMessageWithoutURL() {\n+    // pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+    // Optional<String> url = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class,\n+    // () -> PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, TITLE, url.get(), URL_TITLE));\n+    // }\n+\n+    @Test\n+    public void testSendURLMessageWithoutTitle() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, null, URL, URL_TITLE);\n+        assertThat(sent, is(true));\n+    }\n+\n+    @Test\n+    public void testSendURLMessageWithoutURLTitle() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, TITLE, URL, null);\n+        assertThat(sent, is(true));\n+    }\n+\n+    @Test\n+    public void testSendURLMessage() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        boolean sent = PushoverActions.sendURLMessage(pushoverThingActions, MESSAGE, TITLE, URL, URL_TITLE);\n+        assertThat(sent, is(true));\n+    }\n+\n+    // sendPriorityMessage\n+    @Test\n+    public void testSendPriorityMessageThingActionsIsNotPushoverThingActions() {\n+        assertThrows(ClassCastException.class, () -> PushoverActions.sendPriorityMessage(thingActionsStub, MESSAGE,\n+                TITLE, PushoverMessageBuilder.EMERGENCY_PRIORITY));\n+    }\n+\n+    @Test\n+    public void testSendPriorityMessageThingHandlerIsNull() {\n+        assertThrows(RuntimeException.class, () -> PushoverActions.sendPriorityMessage(pushoverThingActions, MESSAGE,\n+                TITLE, PushoverMessageBuilder.EMERGENCY_PRIORITY));\n+    }\n+\n+    // @Test\n+    // public void testSendPriorityMessageWithoutMessage() {\n+    // pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+    // Optional<String> message = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class, () -> PushoverActions.sendPriorityMessage(pushoverThingActions,\n+    // message.get(), TITLE, PushoverMessageBuilder.EMERGENCY_PRIORITY));\n+    // }\n+\n+    @Test\n+    public void testSendPriorityMessageWithoutTitle() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        String receipt = PushoverActions.sendPriorityMessage(pushoverThingActions, MESSAGE, null,\n+                PushoverMessageBuilder.EMERGENCY_PRIORITY);\n+        assertThat(receipt, is(RECEIPT));\n+    }\n+\n+    @Test\n+    public void testSendPriorityMessage() {\n+        pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+        String receipt = PushoverActions.sendPriorityMessage(pushoverThingActions, MESSAGE, TITLE,\n+                PushoverMessageBuilder.EMERGENCY_PRIORITY);\n+        assertThat(receipt, is(RECEIPT));\n+    }\n+\n+    // cancelPriorityMessage\n+    @Test\n+    public void testCancelPriorityMessageThingActionsIsNotPushoverThingActions() {\n+        assertThrows(ClassCastException.class, () -> PushoverActions.cancelPriorityMessage(thingActionsStub, RECEIPT));\n+    }\n+\n+    @Test\n+    public void testCancelPriorityMessageThingHandlerIsNull() {\n+        assertThrows(RuntimeException.class,\n+                () -> PushoverActions.cancelPriorityMessage(pushoverThingActions, RECEIPT));\n+    }\n+\n+    // @Test\n+    // public void testCancelPriorityMessageWithoutReceipt() {\n+    // pushoverThingActions.setThingHandler(mockPushoverAccountHandler);\n+    // Optional<String> receipt = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class,\n+    // () -> PushoverActions.cancelPriorityMessage(pushoverThingActions, receipt.get()));\n+    // }\n+", "originalCommit": "bb6ecd2d461d1c78bb2798dc4326ce72f09cb51f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNDE3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r530614172", "bodyText": "and here", "author": "cpmeister", "createdAt": "2020-11-25T20:00:19Z", "path": "bundles/org.openhab.binding.pushover/src/test/java/org/openhab/binding/pushover/internal/actions/PushoverActionsTest.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.actions;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.junit.jupiter.MockitoSettings;\n+import org.mockito.quality.Strictness;\n+import org.openhab.binding.pushover.internal.connection.PushoverMessageBuilder;\n+import org.openhab.binding.pushover.internal.handler.PushoverAccountHandler;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * Unit tests for {@link PushoverActions}.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@MockitoSettings(strictness = Strictness.WARN)\n+public class PushoverActionsTest {\n+\n+    private static final String MESSAGE = \"My Message\";\n+    private static final String TITLE = \"My Title\";\n+    private static final String URL = \"https://www.test.com\";\n+    private static final String URL_TITLE = \"Some Link\";\n+    private static final String RECEIPT = \"12345\";\n+\n+    @NonNullByDefault\n+    private final ThingActions thingActionsStub = new ThingActions() {\n+        @Override\n+        public void setThingHandler(ThingHandler handler) {\n+        }\n+\n+        @Override\n+        public @Nullable ThingHandler getThingHandler() {\n+            return null;\n+        }\n+    };\n+\n+    private @Mock PushoverAccountHandler mockPushoverAccountHandler;\n+\n+    private PushoverActions pushoverThingActions;\n+\n+    @BeforeEach\n+    public void setUp() {\n+        pushoverThingActions = new PushoverActions();\n+\n+        when(mockPushoverAccountHandler.getDefaultPushoverMessageBuilder(any()))\n+                .thenReturn(PushoverMessageBuilder.getInstance(\"key\", \"user\"));\n+        when(mockPushoverAccountHandler.sendMessage(any())).thenReturn(Boolean.TRUE);\n+        when(mockPushoverAccountHandler.sendPriorityMessage(any())).thenReturn(RECEIPT);\n+        when(mockPushoverAccountHandler.cancelPriorityMessage(RECEIPT)).thenReturn(Boolean.TRUE);\n+    }\n+\n+    // sendMessage\n+    @Test\n+    public void testSendMessageThingActionsIsNotPushoverThingActions() {\n+        assertThrows(ClassCastException.class, () -> PushoverActions.sendMessage(thingActionsStub, MESSAGE, TITLE));\n+    }\n+\n+    @Test\n+    public void testSendMessageThingHandlerIsNull() {\n+        assertThrows(RuntimeException.class, () -> PushoverActions.sendMessage(pushoverThingActions, MESSAGE, TITLE));\n+    }\n+\n+    // @Test\n+    // public void testSendMessageWithoutMessage() {\n+    // Optional<String> message = Optional.of(null);\n+    // assertThrows(IllegalArgumentException.class,\n+    // () -> PushoverActions.sendMessage(pushoverThingActions, message.get(), TITLE));\n+    // }", "originalCommit": "bb6ecd2d461d1c78bb2798dc4326ce72f09cb51f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNTgzMg==", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r530615832", "bodyText": "connection.validateUser might be slow, so please make this code asynchronous so the initialize() method remains speedy.", "author": "cpmeister", "createdAt": "2020-11-25T20:03:57Z", "path": "bundles/org.openhab.binding.pushover/src/main/java/org/openhab/binding/pushover/internal/handler/PushoverAccountHandler.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.pushover.internal.handler;\n+\n+import static org.openhab.binding.pushover.internal.PushoverBindingConstants.DEFAULT_SOUND;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.pushover.internal.actions.PushoverActions;\n+import org.openhab.binding.pushover.internal.config.PushoverAccountConfiguration;\n+import org.openhab.binding.pushover.internal.config.PushoverConfigOptionProvider;\n+import org.openhab.binding.pushover.internal.connection.PushoverAPIConnection;\n+import org.openhab.binding.pushover.internal.connection.PushoverCommunicationException;\n+import org.openhab.binding.pushover.internal.connection.PushoverConfigurationException;\n+import org.openhab.binding.pushover.internal.connection.PushoverMessageBuilder;\n+import org.openhab.binding.pushover.internal.dto.Sound;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link PushoverAccountHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PushoverAccountHandler extends BaseThingHandler {\n+\n+    private static final Collection<Class<? extends ThingHandlerService>> SUPPORTED_THING_ACTIONS = Set\n+            .of(PushoverActions.class, PushoverConfigOptionProvider.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private @NonNullByDefault({}) PushoverAccountConfiguration config;\n+    private @Nullable PushoverAPIConnection connection;\n+\n+    public PushoverAccountHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // nothing\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(PushoverAccountConfiguration.class);\n+\n+        boolean configValid = true;\n+        final String apikey = config.apikey;\n+        if (apikey == null || apikey.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"@text/offline.conf-error-missing-apikey\");\n+            configValid = false;\n+        }\n+        final String user = config.user;\n+        if (user == null || user.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"@text/offline.conf-error-missing-user\");\n+            configValid = false;\n+        }\n+\n+        if (configValid) {\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            connection = new PushoverAPIConnection(httpClient, config);\n+            try {\n+                connection.validateUser();\n+                updateStatus(ThingStatus.ONLINE);\n+            } catch (PushoverCommunicationException | PushoverConfigurationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            }", "originalCommit": "bb6ecd2d461d1c78bb2798dc4326ce72f09cb51f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE5NTIyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8586#discussion_r531195229", "bodyText": "Good catch. I somehow had in my mind I planned to do that.", "author": "cweitkamp", "createdAt": "2020-11-26T19:13:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNTgzMg=="}], "type": "inlineReview"}, {"oid": "128709ef9aec022a9a11ded8f14f88c29ec85fbc", "url": "https://github.com/openhab/openhab-addons/commit/128709ef9aec022a9a11ded8f14f88c29ec85fbc", "message": "Incorporated comments from review\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>", "committedDate": "2020-11-26T19:12:59Z", "type": "commit"}]}