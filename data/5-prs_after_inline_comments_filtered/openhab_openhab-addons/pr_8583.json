{"pr_number": 8583, "pr_title": "[icalendar] EventFilter for existing calendars", "pr_createdAt": "2020-09-26T09:14:15Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8583", "timeline": [{"oid": "2532db960d521a71473d39787a3916be3f9b15c8", "url": "https://github.com/openhab/openhab-addons/commit/2532db960d521a71473d39787a3916be3f9b15c8", "message": "[icalendar] Added logic for filtered events\n\nSigned-off-by: Michael Wodniok <michi@noorganization.org>", "committedDate": "2020-09-26T08:12:08Z", "type": "commit"}, {"oid": "ea7f6be39791531cf23393eab872b85003bdd1c6", "url": "https://github.com/openhab/openhab-addons/commit/ea7f6be39791531cf23393eab872b85003bdd1c6", "message": "[icalendar] Implemented filter based events basically (WIP).\n\nSigned-off-by: Michael Wodniok <michi@noorganization.org>", "committedDate": "2020-09-26T08:20:09Z", "type": "commit"}, {"oid": "4f3d5a9e922697a2d12b2e22780c0dbcf12d0600", "url": "https://github.com/openhab/openhab-addons/commit/4f3d5a9e922697a2d12b2e22780c0dbcf12d0600", "message": "[icalendar] Synced upstream, ran spotless.\n\nSigned-off-by: Michael Wodniok <michi@noorganization.org>", "committedDate": "2020-09-26T08:20:15Z", "type": "commit"}, {"oid": "572c9e43b51e216bc2993172a76123155b022210", "url": "https://github.com/openhab/openhab-addons/commit/572c9e43b51e216bc2993172a76123155b022210", "message": "[icalendar] Added migration for old thing.\n\nSigned-off-by: Michael Wodniok <michi@noorganization.org>", "committedDate": "2020-09-26T08:23:07Z", "type": "commit"}, {"oid": "278cd110a80b1e652e26a8a3a4012be15af624cb", "url": "https://github.com/openhab/openhab-addons/commit/278cd110a80b1e652e26a8a3a4012be15af624cb", "message": "[icalendar] Added config for refresh interval, enhanced code quality\n\nSigned-off-by: Michael Wodniok <michi@noorganization.org>", "committedDate": "2020-09-26T08:25:50Z", "type": "commit"}, {"oid": "68518170ec6e23d6134773914a754d21e7097102", "url": "https://github.com/openhab/openhab-addons/commit/68518170ec6e23d6134773914a754d21e7097102", "message": "[icalendar] updated translation and text (a bit)\n\nSigned-off-by: Michael Wodniok <michi@noorganization.org>", "committedDate": "2020-09-26T08:25:53Z", "type": "commit"}, {"oid": "7f83451318d5e92a7e0361efbec5605e17f3ea5a", "url": "https://github.com/openhab/openhab-addons/commit/7f83451318d5e92a7e0361efbec5605e17f3ea5a", "message": "[icalendar] corrections after rebase on main\n\nThis commit fixes #8022.\n\nSigned-off-by: Michael Wodniok <michi@noorganization.org>", "committedDate": "2020-09-26T09:07:43Z", "type": "commit"}, {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036", "url": "https://github.com/openhab/openhab-addons/commit/8ce9198a9c41bf9b211d15609041e7d9be102036", "message": "[icalendar] Applied andrewfgs suggestions to README\n\nSigned-off-by: Michael Wodniok <michi@noorganization.org>", "committedDate": "2020-09-26T20:14:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzI1OA==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502837258", "bodyText": "The author tag should not be used on inner classes.", "author": "fwolter", "createdAt": "2020-10-10T22:06:30Z", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "diffHunk": "@@ -67,6 +84,61 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n         if (!supportsThingType(thingTypeUID)) {\n             return null;\n         }\n-        return new ICalendarHandler(thing, sharedHttpClient, eventPublisher);\n+        if (thingTypeUID.equals(THING_TYPE_CALENDAR)) {\n+            if (thing instanceof Bridge) {\n+                return new ICalendarHandler((Bridge) thing, sharedHttpClient, eventPublisher);\n+            } else {\n+                // Migration needs to be done asynchronously. Using thread pool for common things.\n+                ThingUID uidToCopy = thing.getUID();\n+                ExecutorService threadPool = ThreadPoolManager.getPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+                threadPool.execute(new ReregisterThingRunnable(uidToCopy));\n+                return null;\n+            }\n+        } else if (thingTypeUID.equals(THING_TYPE_FILTERED_EVENTS)) {\n+            return new EventFilterHandler(thing);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This Runnable \"upgrades\" the thing \"calendar\" to the bridge of same type. To make sure the thing isn't in use, a\n+     * sleep blocks before doing actual work.\n+     *\n+     * @author Michael Wodniok - Initial contribution", "originalCommit": "8ce9198a9c41bf9b211d15609041e7d9be102036", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg2OTE0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502869142", "bodyText": "Hm. Yes this was strange, i've added it as a maven plugin complained about the missing @author. However it now does not anymore. I'll remove.", "author": "daMihe", "createdAt": "2020-10-11T05:47:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzI3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502837276", "bodyText": "Logging to info should be used rarely. This could be debug. Same for below.", "author": "fwolter", "createdAt": "2020-10-10T22:06:47Z", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "diffHunk": "@@ -67,6 +84,61 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n         if (!supportsThingType(thingTypeUID)) {\n             return null;\n         }\n-        return new ICalendarHandler(thing, sharedHttpClient, eventPublisher);\n+        if (thingTypeUID.equals(THING_TYPE_CALENDAR)) {\n+            if (thing instanceof Bridge) {\n+                return new ICalendarHandler((Bridge) thing, sharedHttpClient, eventPublisher);\n+            } else {\n+                // Migration needs to be done asynchronously. Using thread pool for common things.\n+                ThingUID uidToCopy = thing.getUID();\n+                ExecutorService threadPool = ThreadPoolManager.getPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+                threadPool.execute(new ReregisterThingRunnable(uidToCopy));\n+                return null;\n+            }\n+        } else if (thingTypeUID.equals(THING_TYPE_FILTERED_EVENTS)) {\n+            return new EventFilterHandler(thing);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This Runnable \"upgrades\" the thing \"calendar\" to the bridge of same type. To make sure the thing isn't in use, a\n+     * sleep blocks before doing actual work.\n+     *\n+     * @author Michael Wodniok - Initial contribution\n+     */\n+    private class ReregisterThingRunnable implements Runnable {\n+        private final ThingUID thingUID;\n+\n+        public ReregisterThingRunnable(ThingUID uid) {\n+            thingUID = uid;\n+        }\n+\n+        @Override\n+        public void run() {\n+            logger.info(\"Converting Thing {} to Bridge. This will remove the item and readd it. Please stand by.\",", "originalCommit": "8ce9198a9c41bf9b211d15609041e7d9be102036", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg2OTUwNg==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502869506", "bodyText": "This is intentionally info as it changes the users configuration. This should happen exactly once, because the handler only converted once. In that time the item is shortly unusable. Should we really hide the change to users configuration? It could lead to confusion because something changes without any notification - this way a user may find out, why something in his configuration changed.", "author": "daMihe", "createdAt": "2020-10-11T05:51:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzMyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502837325", "bodyText": "Why is this delay necessary?", "author": "fwolter", "createdAt": "2020-10-10T22:07:26Z", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "diffHunk": "@@ -67,6 +84,61 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n         if (!supportsThingType(thingTypeUID)) {\n             return null;\n         }\n-        return new ICalendarHandler(thing, sharedHttpClient, eventPublisher);\n+        if (thingTypeUID.equals(THING_TYPE_CALENDAR)) {\n+            if (thing instanceof Bridge) {\n+                return new ICalendarHandler((Bridge) thing, sharedHttpClient, eventPublisher);\n+            } else {\n+                // Migration needs to be done asynchronously. Using thread pool for common things.\n+                ThingUID uidToCopy = thing.getUID();\n+                ExecutorService threadPool = ThreadPoolManager.getPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+                threadPool.execute(new ReregisterThingRunnable(uidToCopy));\n+                return null;\n+            }\n+        } else if (thingTypeUID.equals(THING_TYPE_FILTERED_EVENTS)) {\n+            return new EventFilterHandler(thing);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This Runnable \"upgrades\" the thing \"calendar\" to the bridge of same type. To make sure the thing isn't in use, a\n+     * sleep blocks before doing actual work.\n+     *\n+     * @author Michael Wodniok - Initial contribution\n+     */\n+    private class ReregisterThingRunnable implements Runnable {\n+        private final ThingUID thingUID;\n+\n+        public ReregisterThingRunnable(ThingUID uid) {\n+            thingUID = uid;\n+        }\n+\n+        @Override\n+        public void run() {\n+            logger.info(\"Converting Thing {} to Bridge. This will remove the item and readd it. Please stand by.\",\n+                    thingUID);\n+            try {\n+                Thread.sleep(20000);", "originalCommit": "8ce9198a9c41bf9b211d15609041e7d9be102036", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg3MDMyOA==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502870328", "bodyText": "OpenHAB does not provide hooks for upgrades AFAIK. It is as i need to be sure that the replacement is done asynchronous after the failed initialization. So createHandler(Thing) must return before i'm able to do the needed migration - which does not allow to use usual synchronization mechanisms. I'm pretty sure a 20 sec delay is enough to let the method return (it is just the next instruction after starting the thread containing the sleep).", "author": "daMihe", "createdAt": "2020-10-11T06:02:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk2NTM5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502965397", "bodyText": "What happens if you do it synchronously? Genuinely asking.", "author": "fwolter", "createdAt": "2020-10-11T21:01:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk2OTM2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502969361", "bodyText": "I've tried that first a long time ago. I couldn't add an item with same id as it collides with the existing one (that happens while migration). I think the removal has been not possible in the state \"initializing\" and the framework does not seem to remove the item in that time (all AFIAR!).", "author": "daMihe", "createdAt": "2020-10-11T21:41:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk3MTExNg==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502971116", "bodyText": "@openhab/add-ons-maintainers is there a pattern to migrate Things from one version to another? In this case a Thread is spawn in the ThingHandlerFactory and after some delay the Thing is removed and re-added. Is this a valid approach?", "author": "fwolter", "createdAt": "2020-10-11T21:59:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE2MjIyMA==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r504162220", "bodyText": "No, there is not. But this should definitely be done by the framework. We are looking for a solution for a long time (see eclipse-archived/smarthome#2555). There are already drafts for an implementation like openhab/openhab-core#1027 but unfortunately not THE result we are looking for.", "author": "cweitkamp", "createdAt": "2020-10-13T18:15:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk0NTYxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r506945615", "bodyText": "@cweitkamp The question is now: how to continue here?", "author": "daMihe", "createdAt": "2020-10-17T13:53:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk1NzY4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r506957686", "bodyText": "I'd clearly say: Remove any migration logic from the binding (I never accepted that in other bindings either).\nAs long as there is no solution in the core framework, add a note to the distro that there is a breaking change in the binding configuration and that Things have to be re-created by the user.", "author": "kaikreuzer", "createdAt": "2020-10-17T16:08:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk4MDM4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r506980382", "bodyText": "hmm... ok.", "author": "daMihe", "createdAt": "2020-10-17T20:22:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk4MTU3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r506981573", "bodyText": "I understand that this is not what you wanted to hear, sorry for that - but I always prefer general solutions to problems (even if they are in the future) instead of having 200 bindings trying to solve it on their own in different ways. So thanks for your understanding!", "author": "kaikreuzer", "createdAt": "2020-10-17T20:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzg2MA==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502837860", "bodyText": "Please add the NonNullByDefault annotation.", "author": "fwolter", "createdAt": "2020-10-10T22:13:50Z", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/config/EventFilterConfiguration.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.config;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * The EventFilterConfiguration holds configuration for the Event Filter Item Type.\n+ *\n+ * @author Michael Wodniok - Initial contribution\n+ */\n+public class EventFilterConfiguration {", "originalCommit": "8ce9198a9c41bf9b211d15609041e7d9be102036", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg3MjkzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502872931", "bodyText": "Is there a guarantee that required parameters are non-null?", "author": "daMihe", "createdAt": "2020-10-11T06:34:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk2NTU1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502965555", "bodyText": "No, not at all. If the user uses textual configuration, a field can be null if the user forgets to specify the parameter. You could declare the fields as Nullable or initialize them with a default value.", "author": "fwolter", "createdAt": "2020-10-11T21:03:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk4MDg1OA==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r506980858", "bodyText": "Do you think it's really better to annotate as @NonNullByDefault and after that marking all members as @Nullable? The configuration classes are classical DTO's.", "author": "daMihe", "createdAt": "2020-10-17T20:28:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE5Mjk2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r507192961", "bodyText": "I must admit it's a bit inconsistent to annotate the configuration and the other DTOs not. But to stay consistent with the other bindings it'd be better to annotate the configuration. Many bindings initialize the fields with default values, to avoid the Nullable declaration.", "author": "fwolter", "createdAt": "2020-10-18T17:57:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU5MzgyNg==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r508593826", "bodyText": "OK.", "author": "daMihe", "createdAt": "2020-10-20T15:11:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODAyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502838022", "bodyText": "Is there a reason why you chose BigDecimal instead of int?", "author": "fwolter", "createdAt": "2020-10-10T22:15:39Z", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/config/EventFilterConfiguration.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.config;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * The EventFilterConfiguration holds configuration for the Event Filter Item Type.\n+ *\n+ * @author Michael Wodniok - Initial contribution\n+ */\n+public class EventFilterConfiguration {\n+    public BigDecimal maxEvents;", "originalCommit": "8ce9198a9c41bf9b211d15609041e7d9be102036", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg3MDQ2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502870467", "bodyText": "The docs:\n\nAll configuration values will be mapped to properties of the class. The type of the property must match the type of the configuration. Only the following types are supported for configuration values: Boolean, String and BigDecimal.", "author": "daMihe", "createdAt": "2020-10-11T06:04:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODAyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk2NjExMw==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502966113", "bodyText": "That's interesting, as many bindings use int. You can leave it as-is.", "author": "fwolter", "createdAt": "2020-10-11T21:08:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODAyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODE0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502838143", "bodyText": "The compiler is more intelligent on local variables. This annotation could be removed.", "author": "fwolter", "createdAt": "2020-10-10T22:17:41Z", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable", "originalCommit": "8ce9198a9c41bf9b211d15609041e7d9be102036", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg3NTE1OA==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502875158", "bodyText": "OK, doing locally", "author": "daMihe", "createdAt": "2020-10-11T06:58:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODE0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODQ0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502838446", "bodyText": "I would set the ThingStatusDetail rather to CONFIGURATION_ERROR, as this error raises when the user forgot to configure the bridge. Also, the log message could be set as third argument to updateStatus(), so that it is displayed in the UI. The log message can be removed then, as it is already logged.", "author": "fwolter", "createdAt": "2020-10-10T22:20:58Z", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);", "originalCommit": "8ce9198a9c41bf9b211d15609041e7d9be102036", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA2NjQzNg==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r507066436", "bodyText": "OK", "author": "daMihe", "createdAt": "2020-10-18T09:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODY2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502838667", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n          \n          \n            \n                    if (config.maxEvents == null || config.maxEvents.compareTo(BigDecimal.ZERO) < 1) {", "author": "fwolter", "createdAt": "2020-10-10T22:24:10Z", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {", "originalCommit": "8ce9198a9c41bf9b211d15609041e7d9be102036", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODcyMw==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502838723", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        @Nullable", "author": "fwolter", "createdAt": "2020-10-10T22:24:57Z", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable", "originalCommit": "8ce9198a9c41bf9b211d15609041e7d9be102036", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg3NTE0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502875144", "bodyText": "OK, doing locally", "author": "daMihe", "createdAt": "2020-10-11T06:58:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODg5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502838891", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            @Nullable", "author": "fwolter", "createdAt": "2020-10-10T22:26:44Z", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable\n+            String currentGroupId = current.getUID().getGroupId();\n+            if (currentGroupId == null) {\n+                return true;\n+            }\n+            for (ResultChannelSet channelSet : resultChannels) {\n+                if (channelSet.resultGroup.getId().contentEquals(currentGroupId)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }).forEach((Channel toDelete) -> {\n+            thingBuilder.withoutChannel(toDelete.getUID());\n+        });\n+\n+        resultChannels.stream().filter((ResultChannelSet current) -> {\n+            return (getThing().getChannelsOfGroup(current.resultGroup.toString()).size() == 0);\n+        }).forEach((ResultChannelSet current) -> {\n+            for (ChannelBuilder builder : handlerCallback.createChannelBuilders(current.resultGroup, GROUP_TYPE_UID)) {\n+                Channel currentChannel = builder.build();\n+                @Nullable", "originalCommit": "8ce9198a9c41bf9b211d15609041e7d9be102036", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg3NTEzNA==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502875134", "bodyText": "OK, doing locally", "author": "daMihe", "createdAt": "2020-10-11T06:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTIyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502839222", "bodyText": "IllegalArgumentException is an unchecked exception, which are not meant to be cought. Is an exception needed at all here? Could you simply return and set the ThingStatus accordingly?", "author": "fwolter", "createdAt": "2020-10-10T22:30:36Z", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable\n+            String currentGroupId = current.getUID().getGroupId();\n+            if (currentGroupId == null) {\n+                return true;\n+            }\n+            for (ResultChannelSet channelSet : resultChannels) {\n+                if (channelSet.resultGroup.getId().contentEquals(currentGroupId)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }).forEach((Channel toDelete) -> {\n+            thingBuilder.withoutChannel(toDelete.getUID());\n+        });\n+\n+        resultChannels.stream().filter((ResultChannelSet current) -> {\n+            return (getThing().getChannelsOfGroup(current.resultGroup.toString()).size() == 0);\n+        }).forEach((ResultChannelSet current) -> {\n+            for (ChannelBuilder builder : handlerCallback.createChannelBuilders(current.resultGroup, GROUP_TYPE_UID)) {\n+                Channel currentChannel = builder.build();\n+                @Nullable\n+                Channel existingChannel = getThing().getChannel(currentChannel.getUID());\n+                if (existingChannel == null) {\n+                    thingBuilder.withChannel(currentChannel);\n+                }\n+            }\n+        });\n+\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    /**\n+     * Updates all states and channels.\n+     */\n+    private void updateStates() {\n+        final Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.debug(\"Bridge not instantiated!\");\n+            return;\n+        }\n+        final ICalendarHandler iCalendarHandler = (ICalendarHandler) iCalendarBridge.getHandler();\n+        if (iCalendarHandler == null) {\n+            logger.debug(\"ICalendarHandler not instantiated!\");\n+            return;\n+        }\n+        final EventFilterConfiguration config = configuration;\n+        if (config == null) {\n+            logger.debug(\"Configuration not instantiated!\");\n+            return;\n+        }\n+        @Nullable\n+        final AbstractPresentableCalendar cal = iCalendarHandler.getRuntimeCalendar();\n+        if (cal != null) {\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            String textFilterValue = config.textEventValue;\n+            EventTextFilter filter = null;\n+            if (textFilterValue != null) {\n+                try {\n+                    if (config.textEventField == null || config.textValueType == null) {\n+                        throw new IllegalArgumentException(\"Config is broken.\");", "originalCommit": "8ce9198a9c41bf9b211d15609041e7d9be102036", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg3NTQ3OA==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502875478", "bodyText": "I just did not want to reinvent the wheel and am catching the exception. Do you know a better one or should i create a own exception class for broken configs?", "author": "daMihe", "createdAt": "2020-10-11T07:01:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTIyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk2NjQ4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502966487", "bodyText": "Creating a custom exception would be a valid approach. But I'm wondering if an exception is needed at all here. Can't you simply return like in line 265? BTW you should set the ThingStatus accordingly in this line.", "author": "fwolter", "createdAt": "2020-10-11T21:12:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTIyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzAyNjMzOA==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r507026338", "bodyText": "OK", "author": "daMihe", "createdAt": "2020-10-18T06:54:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTIyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTI2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502839265", "bodyText": "See above. Remove logging and append the message to updateStatus().", "author": "fwolter", "createdAt": "2020-10-10T22:31:02Z", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable\n+            String currentGroupId = current.getUID().getGroupId();\n+            if (currentGroupId == null) {\n+                return true;\n+            }\n+            for (ResultChannelSet channelSet : resultChannels) {\n+                if (channelSet.resultGroup.getId().contentEquals(currentGroupId)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }).forEach((Channel toDelete) -> {\n+            thingBuilder.withoutChannel(toDelete.getUID());\n+        });\n+\n+        resultChannels.stream().filter((ResultChannelSet current) -> {\n+            return (getThing().getChannelsOfGroup(current.resultGroup.toString()).size() == 0);\n+        }).forEach((ResultChannelSet current) -> {\n+            for (ChannelBuilder builder : handlerCallback.createChannelBuilders(current.resultGroup, GROUP_TYPE_UID)) {\n+                Channel currentChannel = builder.build();\n+                @Nullable\n+                Channel existingChannel = getThing().getChannel(currentChannel.getUID());\n+                if (existingChannel == null) {\n+                    thingBuilder.withChannel(currentChannel);\n+                }\n+            }\n+        });\n+\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    /**\n+     * Updates all states and channels.\n+     */\n+    private void updateStates() {\n+        final Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.debug(\"Bridge not instantiated!\");\n+            return;\n+        }\n+        final ICalendarHandler iCalendarHandler = (ICalendarHandler) iCalendarBridge.getHandler();\n+        if (iCalendarHandler == null) {\n+            logger.debug(\"ICalendarHandler not instantiated!\");\n+            return;\n+        }\n+        final EventFilterConfiguration config = configuration;\n+        if (config == null) {\n+            logger.debug(\"Configuration not instantiated!\");\n+            return;\n+        }\n+        @Nullable\n+        final AbstractPresentableCalendar cal = iCalendarHandler.getRuntimeCalendar();\n+        if (cal != null) {\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            String textFilterValue = config.textEventValue;\n+            EventTextFilter filter = null;\n+            if (textFilterValue != null) {\n+                try {\n+                    if (config.textEventField == null || config.textValueType == null) {\n+                        throw new IllegalArgumentException(\"Config is broken.\");\n+                    }\n+                    EventTextFilter.Field textFilterField = EventTextFilter.Field.valueOf(config.textEventField);\n+                    EventTextFilter.Type textFilterType = EventTextFilter.Type.valueOf(config.textValueType);\n+\n+                    filter = new EventTextFilter(textFilterField, textFilterValue, textFilterType);\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"Text-filter settings are not set properly.\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);", "originalCommit": "8ce9198a9c41bf9b211d15609041e7d9be102036", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzAyNjQ0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r507026444", "bodyText": "OK", "author": "daMihe", "createdAt": "2020-10-18T06:55:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTI4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502839282", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-10-10T22:31:18Z", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable\n+            String currentGroupId = current.getUID().getGroupId();\n+            if (currentGroupId == null) {\n+                return true;\n+            }\n+            for (ResultChannelSet channelSet : resultChannels) {\n+                if (channelSet.resultGroup.getId().contentEquals(currentGroupId)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }).forEach((Channel toDelete) -> {\n+            thingBuilder.withoutChannel(toDelete.getUID());\n+        });\n+\n+        resultChannels.stream().filter((ResultChannelSet current) -> {\n+            return (getThing().getChannelsOfGroup(current.resultGroup.toString()).size() == 0);\n+        }).forEach((ResultChannelSet current) -> {\n+            for (ChannelBuilder builder : handlerCallback.createChannelBuilders(current.resultGroup, GROUP_TYPE_UID)) {\n+                Channel currentChannel = builder.build();\n+                @Nullable\n+                Channel existingChannel = getThing().getChannel(currentChannel.getUID());\n+                if (existingChannel == null) {\n+                    thingBuilder.withChannel(currentChannel);\n+                }\n+            }\n+        });\n+\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    /**\n+     * Updates all states and channels.\n+     */\n+    private void updateStates() {\n+        final Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.debug(\"Bridge not instantiated!\");\n+            return;\n+        }\n+        final ICalendarHandler iCalendarHandler = (ICalendarHandler) iCalendarBridge.getHandler();\n+        if (iCalendarHandler == null) {\n+            logger.debug(\"ICalendarHandler not instantiated!\");\n+            return;\n+        }\n+        final EventFilterConfiguration config = configuration;\n+        if (config == null) {\n+            logger.debug(\"Configuration not instantiated!\");\n+            return;\n+        }\n+        @Nullable\n+        final AbstractPresentableCalendar cal = iCalendarHandler.getRuntimeCalendar();\n+        if (cal != null) {\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            String textFilterValue = config.textEventValue;\n+            EventTextFilter filter = null;\n+            if (textFilterValue != null) {\n+                try {\n+                    if (config.textEventField == null || config.textValueType == null) {\n+                        throw new IllegalArgumentException(\"Config is broken.\");\n+                    }\n+                    EventTextFilter.Field textFilterField = EventTextFilter.Field.valueOf(config.textEventField);\n+                    EventTextFilter.Type textFilterType = EventTextFilter.Type.valueOf(config.textValueType);\n+\n+                    filter = new EventTextFilter(textFilterField, textFilterValue, textFilterType);\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"Text-filter settings are not set properly.\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+                    return;\n+                }\n+            }\n+\n+            Instant reference = Instant.now();\n+            TimeMultiplicator multiplicator;\n+\n+            try {\n+                if (config.datetimeUnit == null) {\n+                    throw new IllegalArgumentException(\"Config is broken.\");", "originalCommit": "8ce9198a9c41bf9b211d15609041e7d9be102036", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzAyNjM3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r507026373", "bodyText": "OK", "author": "daMihe", "createdAt": "2020-10-18T06:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTI4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTM5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502839390", "bodyText": "You could inject the TimeZoneProvider to retrieve the timezone configured within openHAB. This may differ from the system time zone.", "author": "fwolter", "createdAt": "2020-10-10T22:32:43Z", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable\n+            String currentGroupId = current.getUID().getGroupId();\n+            if (currentGroupId == null) {\n+                return true;\n+            }\n+            for (ResultChannelSet channelSet : resultChannels) {\n+                if (channelSet.resultGroup.getId().contentEquals(currentGroupId)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }).forEach((Channel toDelete) -> {\n+            thingBuilder.withoutChannel(toDelete.getUID());\n+        });\n+\n+        resultChannels.stream().filter((ResultChannelSet current) -> {\n+            return (getThing().getChannelsOfGroup(current.resultGroup.toString()).size() == 0);\n+        }).forEach((ResultChannelSet current) -> {\n+            for (ChannelBuilder builder : handlerCallback.createChannelBuilders(current.resultGroup, GROUP_TYPE_UID)) {\n+                Channel currentChannel = builder.build();\n+                @Nullable\n+                Channel existingChannel = getThing().getChannel(currentChannel.getUID());\n+                if (existingChannel == null) {\n+                    thingBuilder.withChannel(currentChannel);\n+                }\n+            }\n+        });\n+\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    /**\n+     * Updates all states and channels.\n+     */\n+    private void updateStates() {\n+        final Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.debug(\"Bridge not instantiated!\");\n+            return;\n+        }\n+        final ICalendarHandler iCalendarHandler = (ICalendarHandler) iCalendarBridge.getHandler();\n+        if (iCalendarHandler == null) {\n+            logger.debug(\"ICalendarHandler not instantiated!\");\n+            return;\n+        }\n+        final EventFilterConfiguration config = configuration;\n+        if (config == null) {\n+            logger.debug(\"Configuration not instantiated!\");\n+            return;\n+        }\n+        @Nullable\n+        final AbstractPresentableCalendar cal = iCalendarHandler.getRuntimeCalendar();\n+        if (cal != null) {\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            String textFilterValue = config.textEventValue;\n+            EventTextFilter filter = null;\n+            if (textFilterValue != null) {\n+                try {\n+                    if (config.textEventField == null || config.textValueType == null) {\n+                        throw new IllegalArgumentException(\"Config is broken.\");\n+                    }\n+                    EventTextFilter.Field textFilterField = EventTextFilter.Field.valueOf(config.textEventField);\n+                    EventTextFilter.Type textFilterType = EventTextFilter.Type.valueOf(config.textValueType);\n+\n+                    filter = new EventTextFilter(textFilterField, textFilterValue, textFilterType);\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"Text-filter settings are not set properly.\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+                    return;\n+                }\n+            }\n+\n+            Instant reference = Instant.now();\n+            TimeMultiplicator multiplicator;\n+\n+            try {\n+                if (config.datetimeUnit == null) {\n+                    throw new IllegalArgumentException(\"Config is broken.\");\n+                }\n+                multiplicator = TimeMultiplicator.valueOf(config.datetimeUnit);\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"Time-filter settings are not set properly.\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+                return;\n+            }\n+\n+            if (config.datetimeRound) {\n+                ZonedDateTime refDT = reference.atZone(ZoneId.systemDefault());", "originalCommit": "8ce9198a9c41bf9b211d15609041e7d9be102036", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg5NjExOA==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502896118", "bodyText": "OK.", "author": "daMihe", "createdAt": "2020-10-11T10:25:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTM5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTQ3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502839476", "bodyText": "Please add an appropriate error reason to give the user a hint when debugging.", "author": "fwolter", "createdAt": "2020-10-10T22:34:12Z", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable\n+            String currentGroupId = current.getUID().getGroupId();\n+            if (currentGroupId == null) {\n+                return true;\n+            }\n+            for (ResultChannelSet channelSet : resultChannels) {\n+                if (channelSet.resultGroup.getId().contentEquals(currentGroupId)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }).forEach((Channel toDelete) -> {\n+            thingBuilder.withoutChannel(toDelete.getUID());\n+        });\n+\n+        resultChannels.stream().filter((ResultChannelSet current) -> {\n+            return (getThing().getChannelsOfGroup(current.resultGroup.toString()).size() == 0);\n+        }).forEach((ResultChannelSet current) -> {\n+            for (ChannelBuilder builder : handlerCallback.createChannelBuilders(current.resultGroup, GROUP_TYPE_UID)) {\n+                Channel currentChannel = builder.build();\n+                @Nullable\n+                Channel existingChannel = getThing().getChannel(currentChannel.getUID());\n+                if (existingChannel == null) {\n+                    thingBuilder.withChannel(currentChannel);\n+                }\n+            }\n+        });\n+\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    /**\n+     * Updates all states and channels.\n+     */\n+    private void updateStates() {\n+        final Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.debug(\"Bridge not instantiated!\");\n+            return;\n+        }\n+        final ICalendarHandler iCalendarHandler = (ICalendarHandler) iCalendarBridge.getHandler();\n+        if (iCalendarHandler == null) {\n+            logger.debug(\"ICalendarHandler not instantiated!\");\n+            return;\n+        }\n+        final EventFilterConfiguration config = configuration;\n+        if (config == null) {\n+            logger.debug(\"Configuration not instantiated!\");\n+            return;\n+        }\n+        @Nullable\n+        final AbstractPresentableCalendar cal = iCalendarHandler.getRuntimeCalendar();\n+        if (cal != null) {\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            String textFilterValue = config.textEventValue;\n+            EventTextFilter filter = null;\n+            if (textFilterValue != null) {\n+                try {\n+                    if (config.textEventField == null || config.textValueType == null) {\n+                        throw new IllegalArgumentException(\"Config is broken.\");\n+                    }\n+                    EventTextFilter.Field textFilterField = EventTextFilter.Field.valueOf(config.textEventField);\n+                    EventTextFilter.Type textFilterType = EventTextFilter.Type.valueOf(config.textValueType);\n+\n+                    filter = new EventTextFilter(textFilterField, textFilterValue, textFilterType);\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"Text-filter settings are not set properly.\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+                    return;\n+                }\n+            }\n+\n+            Instant reference = Instant.now();\n+            TimeMultiplicator multiplicator;\n+\n+            try {\n+                if (config.datetimeUnit == null) {\n+                    throw new IllegalArgumentException(\"Config is broken.\");\n+                }\n+                multiplicator = TimeMultiplicator.valueOf(config.datetimeUnit);\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"Time-filter settings are not set properly.\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+                return;\n+            }\n+\n+            if (config.datetimeRound) {\n+                ZonedDateTime refDT = reference.atZone(ZoneId.systemDefault());\n+                switch (multiplicator) {\n+                    case WEEK:\n+                        refDT = refDT.with(ChronoField.DAY_OF_WEEK, 1);\n+                    case DAY:\n+                        refDT = refDT.with(ChronoField.HOUR_OF_DAY, 0);\n+                    case HOUR:\n+                        refDT = refDT.with(ChronoField.MINUTE_OF_HOUR, 0);\n+                    case MINUTE:\n+                        refDT = refDT.with(ChronoField.SECOND_OF_MINUTE, 0);\n+                }\n+                reference = refDT.toInstant();\n+            }\n+            Instant begin = Instant.EPOCH;\n+            Instant end = Instant.ofEpochMilli(Long.MAX_VALUE);\n+\n+            if (config.datetimeStart != null) {\n+                begin = reference.plusSeconds(config.datetimeStart.longValue() * multiplicator.getMultiplier());\n+            }\n+            if (config.datetimeEnd != null) {\n+                end = reference.plusSeconds(config.datetimeEnd.longValue() * multiplicator.getMultiplier());\n+            }\n+\n+            List<Event> results = cal.getFilteredEventsBetween(begin, end, filter, config.maxEvents.intValue());\n+            for (int position = 0; position < config.maxEvents.intValue(); position++) {\n+                ResultChannelSet channels = resultChannels.get(position);\n+                if (position < results.size()) {\n+                    Event result = results.get(position);\n+                    updateState(channels.titleChannel, new StringType(result.title));\n+                    updateState(channels.beginChannel, new DateTimeType(result.start.atZone(ZoneId.systemDefault())));\n+                    updateState(channels.endChannel, new DateTimeType(result.end.atZone(ZoneId.systemDefault())));\n+                } else {\n+                    updateState(channels.titleChannel, UnDefType.UNDEF);\n+                    updateState(channels.beginChannel, UnDefType.UNDEF);\n+                    updateState(channels.endChannel, UnDefType.UNDEF);\n+                }\n+            }\n+\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);", "originalCommit": "8ce9198a9c41bf9b211d15609041e7d9be102036", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzAzMjAyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r507032022", "bodyText": "OK", "author": "daMihe", "createdAt": "2020-10-18T07:50:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTU1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502839556", "bodyText": "Syntactical sugar\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    updateFuture = scheduler.scheduleWithFixedDelay(() -> {\n          \n          \n            \n                        updateStates();\n          \n          \n            \n                    }, refreshTime, refreshTime, TimeUnit.MINUTES);\n          \n          \n            \n                    updateFuture = scheduler.scheduleWithFixedDelay(this::updateStates, refreshTime, refreshTime, TimeUnit.MINUTES);", "author": "fwolter", "createdAt": "2020-10-10T22:34:56Z", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable\n+            String currentGroupId = current.getUID().getGroupId();\n+            if (currentGroupId == null) {\n+                return true;\n+            }\n+            for (ResultChannelSet channelSet : resultChannels) {\n+                if (channelSet.resultGroup.getId().contentEquals(currentGroupId)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }).forEach((Channel toDelete) -> {\n+            thingBuilder.withoutChannel(toDelete.getUID());\n+        });\n+\n+        resultChannels.stream().filter((ResultChannelSet current) -> {\n+            return (getThing().getChannelsOfGroup(current.resultGroup.toString()).size() == 0);\n+        }).forEach((ResultChannelSet current) -> {\n+            for (ChannelBuilder builder : handlerCallback.createChannelBuilders(current.resultGroup, GROUP_TYPE_UID)) {\n+                Channel currentChannel = builder.build();\n+                @Nullable\n+                Channel existingChannel = getThing().getChannel(currentChannel.getUID());\n+                if (existingChannel == null) {\n+                    thingBuilder.withChannel(currentChannel);\n+                }\n+            }\n+        });\n+\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    /**\n+     * Updates all states and channels.\n+     */\n+    private void updateStates() {\n+        final Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.debug(\"Bridge not instantiated!\");\n+            return;\n+        }\n+        final ICalendarHandler iCalendarHandler = (ICalendarHandler) iCalendarBridge.getHandler();\n+        if (iCalendarHandler == null) {\n+            logger.debug(\"ICalendarHandler not instantiated!\");\n+            return;\n+        }\n+        final EventFilterConfiguration config = configuration;\n+        if (config == null) {\n+            logger.debug(\"Configuration not instantiated!\");\n+            return;\n+        }\n+        @Nullable\n+        final AbstractPresentableCalendar cal = iCalendarHandler.getRuntimeCalendar();\n+        if (cal != null) {\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            String textFilterValue = config.textEventValue;\n+            EventTextFilter filter = null;\n+            if (textFilterValue != null) {\n+                try {\n+                    if (config.textEventField == null || config.textValueType == null) {\n+                        throw new IllegalArgumentException(\"Config is broken.\");\n+                    }\n+                    EventTextFilter.Field textFilterField = EventTextFilter.Field.valueOf(config.textEventField);\n+                    EventTextFilter.Type textFilterType = EventTextFilter.Type.valueOf(config.textValueType);\n+\n+                    filter = new EventTextFilter(textFilterField, textFilterValue, textFilterType);\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"Text-filter settings are not set properly.\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+                    return;\n+                }\n+            }\n+\n+            Instant reference = Instant.now();\n+            TimeMultiplicator multiplicator;\n+\n+            try {\n+                if (config.datetimeUnit == null) {\n+                    throw new IllegalArgumentException(\"Config is broken.\");\n+                }\n+                multiplicator = TimeMultiplicator.valueOf(config.datetimeUnit);\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"Time-filter settings are not set properly.\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+                return;\n+            }\n+\n+            if (config.datetimeRound) {\n+                ZonedDateTime refDT = reference.atZone(ZoneId.systemDefault());\n+                switch (multiplicator) {\n+                    case WEEK:\n+                        refDT = refDT.with(ChronoField.DAY_OF_WEEK, 1);\n+                    case DAY:\n+                        refDT = refDT.with(ChronoField.HOUR_OF_DAY, 0);\n+                    case HOUR:\n+                        refDT = refDT.with(ChronoField.MINUTE_OF_HOUR, 0);\n+                    case MINUTE:\n+                        refDT = refDT.with(ChronoField.SECOND_OF_MINUTE, 0);\n+                }\n+                reference = refDT.toInstant();\n+            }\n+            Instant begin = Instant.EPOCH;\n+            Instant end = Instant.ofEpochMilli(Long.MAX_VALUE);\n+\n+            if (config.datetimeStart != null) {\n+                begin = reference.plusSeconds(config.datetimeStart.longValue() * multiplicator.getMultiplier());\n+            }\n+            if (config.datetimeEnd != null) {\n+                end = reference.plusSeconds(config.datetimeEnd.longValue() * multiplicator.getMultiplier());\n+            }\n+\n+            List<Event> results = cal.getFilteredEventsBetween(begin, end, filter, config.maxEvents.intValue());\n+            for (int position = 0; position < config.maxEvents.intValue(); position++) {\n+                ResultChannelSet channels = resultChannels.get(position);\n+                if (position < results.size()) {\n+                    Event result = results.get(position);\n+                    updateState(channels.titleChannel, new StringType(result.title));\n+                    updateState(channels.beginChannel, new DateTimeType(result.start.atZone(ZoneId.systemDefault())));\n+                    updateState(channels.endChannel, new DateTimeType(result.end.atZone(ZoneId.systemDefault())));\n+                } else {\n+                    updateState(channels.titleChannel, UnDefType.UNDEF);\n+                    updateState(channels.beginChannel, UnDefType.UNDEF);\n+                    updateState(channels.endChannel, UnDefType.UNDEF);\n+                }\n+            }\n+\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+        }\n+\n+        int refreshTime = DEFAULT_FILTER_REFRESH;\n+        if (config.refreshTime != null) {\n+            refreshTime = config.refreshTime.intValue();\n+        }\n+        ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+        updateFuture = scheduler.scheduleWithFixedDelay(() -> {\n+            updateStates();\n+        }, refreshTime, refreshTime, TimeUnit.MINUTES);", "originalCommit": "8ce9198a9c41bf9b211d15609041e7d9be102036", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTYzNA==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502839634", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "author": "fwolter", "createdAt": "2020-10-10T22:35:51Z", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/ICalendarHandler.java", "diffHunk": "@@ -162,11 +164,29 @@ public void initialize() {\n     public void onCalendarUpdated() {\n         if (reloadCalendar()) {\n             updateStates();\n+            for (Thing childThing : getThing().getThings()) {\n+                ThingHandler handler = childThing.getHandler();\n+                if (handler instanceof CalendarUpdateListener) {\n+                    try {\n+                        ((CalendarUpdateListener) handler).onCalendarUpdated();\n+                    } catch (Exception e) {", "originalCommit": "8ce9198a9c41bf9b211d15609041e7d9be102036", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg3OTIzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502879231", "bodyText": "I can't. This catch clause was added for resiliency against failures in other classes inside the callback. Other callbacks should not be affected if a callback fails.", "author": "daMihe", "createdAt": "2020-10-11T07:42:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTYzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg0MDAxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502840019", "bodyText": "You could let Event implement Comparable and use Instant.compareTo(), instead of implementing your own compare method.", "author": "fwolter", "createdAt": "2020-10-10T22:40:50Z", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/logic/BiweeklyPresentableCalendar.java", "diffHunk": "@@ -167,6 +176,113 @@ public boolean isEventPresent(Instant instant) {\n         return (this.getCurrentComponentWPeriod(instant) != null);\n     }\n \n+    @Override\n+    public List<Event> getFilteredEventsBetween(Instant begin, Instant end, @Nullable EventTextFilter filter,\n+            int maximumCount) {\n+        List<VEventWPeriod> candidates = this.getVEventWPeriodsBetween(begin, end);\n+        final List<Event> results = new ArrayList<>(candidates.size());\n+\n+        if (filter != null) {\n+            Pattern filterPattern;\n+            if (filter.type == Type.TEXT) {\n+                filterPattern = Pattern.compile(\".*\" + Pattern.quote(filter.value) + \".*\",\n+                        Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n+            } else {\n+                filterPattern = Pattern.compile(filter.value);\n+            }\n+\n+            Class<? extends TextProperty> propertyClass;\n+            switch (filter.field) {\n+                case SUMMARY:\n+                    propertyClass = Summary.class;\n+                    break;\n+                case COMMENT:\n+                    propertyClass = Comment.class;\n+                    break;\n+                case CONTACT:\n+                    propertyClass = Contact.class;\n+                    break;\n+                case DESCRIPTION:\n+                    propertyClass = Description.class;\n+                    break;\n+                case LOCATION:\n+                    propertyClass = Location.class;\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown Property to filter for.\");\n+            }\n+\n+            List<VEventWPeriod> filteredCandidates = candidates.stream().filter(current -> {\n+                List<? extends TextProperty> properties = current.vEvent.getProperties(propertyClass);\n+                for (TextProperty prop : properties) {\n+                    if (filterPattern.matcher(prop.getValue()).matches()) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            }).collect(Collectors.toList());\n+            candidates = filteredCandidates;\n+        }\n+\n+        for (VEventWPeriod eventWPeriod : candidates) {\n+            results.add(eventWPeriod.toEvent());\n+        }\n+\n+        Collections.sort(results, (Event o1, Event o2) -> {\n+            if (o1.start.equals(o2.start)) {\n+                return 0;\n+            } else if (o1.start.isBefore(o2.start)) {\n+                return -1;\n+            } else {\n+                return 1;\n+            }\n+        });\n+", "originalCommit": "8ce9198a9c41bf9b211d15609041e7d9be102036", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg3OTYwOA==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502879608", "bodyText": "You are right in case the start of the event will stay the data events will be sorted after. I'm not sure, whether this case is enough for future.", "author": "daMihe", "createdAt": "2020-10-11T07:46:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg0MDAxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM2MDQwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r511360405", "bodyText": "Sorry, I don't understand your comment.", "author": "fwolter", "createdAt": "2020-10-24T09:24:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg0MDAxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ3NDYxNA==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r511474614", "bodyText": "I thought here into future, as maybe the sorting could also be different. But implementing things partly is bad design, so i'm making Event Comparable.", "author": "daMihe", "createdAt": "2020-10-24T14:41:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg0MDAxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg0MDE0MA==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502840140", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            @Nullable", "author": "fwolter", "createdAt": "2020-10-10T22:42:05Z", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/logic/BiweeklyPresentableCalendar.java", "diffHunk": "@@ -167,6 +176,113 @@ public boolean isEventPresent(Instant instant) {\n         return (this.getCurrentComponentWPeriod(instant) != null);\n     }\n \n+    @Override\n+    public List<Event> getFilteredEventsBetween(Instant begin, Instant end, @Nullable EventTextFilter filter,\n+            int maximumCount) {\n+        List<VEventWPeriod> candidates = this.getVEventWPeriodsBetween(begin, end);\n+        final List<Event> results = new ArrayList<>(candidates.size());\n+\n+        if (filter != null) {\n+            Pattern filterPattern;\n+            if (filter.type == Type.TEXT) {\n+                filterPattern = Pattern.compile(\".*\" + Pattern.quote(filter.value) + \".*\",\n+                        Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n+            } else {\n+                filterPattern = Pattern.compile(filter.value);\n+            }\n+\n+            Class<? extends TextProperty> propertyClass;\n+            switch (filter.field) {\n+                case SUMMARY:\n+                    propertyClass = Summary.class;\n+                    break;\n+                case COMMENT:\n+                    propertyClass = Comment.class;\n+                    break;\n+                case CONTACT:\n+                    propertyClass = Contact.class;\n+                    break;\n+                case DESCRIPTION:\n+                    propertyClass = Description.class;\n+                    break;\n+                case LOCATION:\n+                    propertyClass = Location.class;\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown Property to filter for.\");\n+            }\n+\n+            List<VEventWPeriod> filteredCandidates = candidates.stream().filter(current -> {\n+                List<? extends TextProperty> properties = current.vEvent.getProperties(propertyClass);\n+                for (TextProperty prop : properties) {\n+                    if (filterPattern.matcher(prop.getValue()).matches()) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            }).collect(Collectors.toList());\n+            candidates = filteredCandidates;\n+        }\n+\n+        for (VEventWPeriod eventWPeriod : candidates) {\n+            results.add(eventWPeriod.toEvent());\n+        }\n+\n+        Collections.sort(results, (Event o1, Event o2) -> {\n+            if (o1.start.equals(o2.start)) {\n+                return 0;\n+            } else if (o1.start.isBefore(o2.start)) {\n+                return -1;\n+            } else {\n+                return 1;\n+            }\n+        });\n+\n+        return results.subList(0, (maximumCount > results.size() ? results.size() : maximumCount));\n+    }\n+\n+    /**\n+     * Finds events which begin in the given frame.\n+     *\n+     * @param frameBegin Begin of the frame where to search events.\n+     * @param frameEnd End of the time frame where to search events.\n+     * @return All events which begin in the time frame.\n+     */\n+    private List<VEventWPeriod> getVEventWPeriodsBetween(Instant frameBegin, Instant frameEnd) {\n+        final List<VEvent> positiveEvents = new ArrayList<>();\n+        final List<VEvent> negativeEvents = new ArrayList<>();\n+        classifyEvents(positiveEvents, negativeEvents);\n+\n+        final List<VEventWPeriod> eventList = new ArrayList<>();\n+        for (final VEvent positiveEvent : positiveEvents) {\n+            final DateIterator positiveBeginDates = getRecurredEventDateIterator(positiveEvent);\n+            positiveBeginDates.advanceTo(Date.from(frameBegin));\n+            while (positiveBeginDates.hasNext()) {\n+                final Instant begInst = positiveBeginDates.next().toInstant();\n+                if (begInst.isAfter(frameEnd)) {\n+                    break;\n+                }\n+                Duration duration = getEventLength(positiveEvent);\n+                if (duration == null) {\n+                    duration = Duration.ZERO;\n+                }\n+\n+                final VEventWPeriod resultingVEWP = new VEventWPeriod(positiveEvent, begInst, begInst.plus(duration));\n+                @Nullable", "originalCommit": "8ce9198a9c41bf9b211d15609041e7d9be102036", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg3NTAyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502875022", "bodyText": "OK, doing locally", "author": "daMihe", "createdAt": "2020-10-11T06:57:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg0MDE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg0MDU2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502840566", "bodyText": "It's good practice to use one assert per test to see which test fails at the first view.", "author": "fwolter", "createdAt": "2020-10-10T22:47:15Z", "path": "bundles/org.openhab.binding.icalendar/src/test/java/org/openhab/binding/icalendar/internal/logic/BiweeklyPresentableCalendarTest.java", "diffHunk": "@@ -542,4 +542,47 @@ public void testCommandTagCode() {\n         assertNotNull(cmd7);\n         assertEquals(QuantityType.class, cmd7.getClass());\n     }\n+\n+    @SuppressWarnings(\"null\")\n+    @Test\n+    public void testGetFilteredEventsBetween() {\n+        Event[] expectedFilteredEvents1 = new Event[] {\n+                new Event(\"Test Series in UTC\", Instant.parse(\"2019-09-12T09:05:00Z\"),\n+                        Instant.parse(\"2019-09-12T09:10:00Z\"), \"\"),\n+                new Event(\"Test Event in UTC+2\", Instant.parse(\"2019-09-14T08:00:00Z\"),\n+                        Instant.parse(\"2019-09-14T09:00:00Z\"), \"\") };\n+        List<Event> realFilteredEvents1 = calendar.getFilteredEventsBetween(Instant.parse(\"2019-09-12T06:00:00Z\"),\n+                Instant.parse(\"2019-09-15T06:00:00Z\"), null, 3);\n+        assertArrayEquals(expectedFilteredEvents1, realFilteredEvents1.toArray(new Event[0]));", "originalCommit": "8ce9198a9c41bf9b211d15609041e7d9be102036", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg4MTAwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502881001", "bodyText": "I do not agree generally. The tests are built currently on each consecutively as we have more context after each assert - to create tests with one assert per test this is not practical, please look into testIsEventPresent() which shows what i mean. Doing this test in the same way is just consequent.", "author": "daMihe", "createdAt": "2020-10-11T07:59:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg0MDU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk2NzYwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502967605", "bodyText": "It looked for me that each expectedFilteredEvents* is independet from each other and the asserts could be invoked in arbitrary order. It was only a suggestion.", "author": "fwolter", "createdAt": "2020-10-11T21:23:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg0MDU2Ng=="}], "type": "inlineReview"}, {"oid": "9ca6833851b3980635823b57c7747012c1a46c40", "url": "https://github.com/openhab/openhab-addons/commit/9ca6833851b3980635823b57c7747012c1a46c40", "message": "[icalendar] Updated @Nullable and @author in several files\n\nas suggested by @fwolter\n\nSigned-off-by: Michael Wodniok <michi@noorganization.org>", "committedDate": "2020-10-11T06:51:06Z", "type": "commit"}, {"oid": "2064b199c29921c2d91251ab0fc7ede6e4482da9", "url": "https://github.com/openhab/openhab-addons/commit/2064b199c29921c2d91251ab0fc7ede6e4482da9", "message": "[icalendar] Fixed capitalization of labels\n\nAs suggested by @fwolter, described in https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions\n\nSigned-off-by: Michael Wodniok <michi@noorganization.org>", "committedDate": "2020-10-11T08:03:57Z", "type": "commit"}, {"oid": "035c9911003f8ce7e26a4f1388d2df014ca39931", "url": "https://github.com/openhab/openhab-addons/commit/035c9911003f8ce7e26a4f1388d2df014ca39931", "message": "[icalendar] Fixed some check-style warnings\n\nSigned-off-by: Michael Wodniok <michi@noorganization.org>", "committedDate": "2020-10-11T08:16:47Z", "type": "commit"}, {"oid": "153d68625b0d368ff67dc741d024b1a5c48f4765", "url": "https://github.com/openhab/openhab-addons/commit/153d68625b0d368ff67dc741d024b1a5c48f4765", "message": "[icalendar] reformatted code as suggested by @fwolter\n\nSigned-off-by: Michael Wodniok <michi@noorganization.org>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-10-11T08:28:20Z", "type": "commit"}, {"oid": "c6bda923dfca6e494afb9775aa2d51f540392c5e", "url": "https://github.com/openhab/openhab-addons/commit/c6bda923dfca6e494afb9775aa2d51f540392c5e", "message": "[icalendar] replaced dynamic zero with static\r\n\r\nSigned-off-by: Michael Wodniok <michi@noorganization.org>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-10-11T08:28:32Z", "type": "commit"}, {"oid": "c6bda923dfca6e494afb9775aa2d51f540392c5e", "url": "https://github.com/openhab/openhab-addons/commit/c6bda923dfca6e494afb9775aa2d51f540392c5e", "message": "[icalendar] replaced dynamic zero with static\r\n\r\nSigned-off-by: Michael Wodniok <michi@noorganization.org>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-10-11T08:28:32Z", "type": "forcePushed"}, {"oid": "85db33f6d0301588f9ec7b7ddada9e1ab6f5cd9f", "url": "https://github.com/openhab/openhab-addons/commit/85db33f6d0301588f9ec7b7ddada9e1ab6f5cd9f", "message": "[icalendar] reformatted optional/required parameters\r\n\r\nSigned-off-by: Michael Wodniok <michi@noorganization.org>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-10-11T09:47:24Z", "type": "commit"}, {"oid": "8c94e11dc58f0bce1f01c98c93384e23d0eac0d1", "url": "https://github.com/openhab/openhab-addons/commit/8c94e11dc58f0bce1f01c98c93384e23d0eac0d1", "message": "[icalendar] Replace ZoneId.systemDefault() with TimeZoneProviders equivalent\n\nAs suggested by @fwolter.\n\nSigned-off-by: Michael Wodniok <michi@noorganization.org>", "committedDate": "2020-10-11T10:25:42Z", "type": "commit"}, {"oid": "d06c7e19a2efd53826f8b5cc44be6e0f2d3d7bfc", "url": "https://github.com/openhab/openhab-addons/commit/d06c7e19a2efd53826f8b5cc44be6e0f2d3d7bfc", "message": "[icalendar] Removed upgrade logic as suggested by @kaikreuzer\n\nSigned-off-by: Michael Wodniok <michi@noorganization.org>", "committedDate": "2020-10-17T21:15:18Z", "type": "commit"}, {"oid": "d12772e7846b5910571c133ef6d82054280f9bc8", "url": "https://github.com/openhab/openhab-addons/commit/d12772e7846b5910571c133ef6d82054280f9bc8", "message": "[icalendar] Introduced ConfigBrokenException, added better input validation.\n\nSigned-off-by: Michael Wodniok <michi@noorganization.org>", "committedDate": "2020-10-18T07:21:18Z", "type": "commit"}, {"oid": "170913d11269b70e60cf34b1a96ac3991f9ca7bf", "url": "https://github.com/openhab/openhab-addons/commit/170913d11269b70e60cf34b1a96ac3991f9ca7bf", "message": "[icalendar] Added \"Breaking changes\" as suggested by @kaikreuzer\n\nSigned-off-by: Michael Wodniok <michi@noorganization.org>", "committedDate": "2020-10-18T08:58:24Z", "type": "commit"}, {"oid": "aeb6fc9ae3e5bde43a9073469648fc5e4aa3d6be", "url": "https://github.com/openhab/openhab-addons/commit/aeb6fc9ae3e5bde43a9073469648fc5e4aa3d6be", "message": "[icalendar] improved parameter checks\n\nSigned-off-by: Michael Wodniok <michi@noorganization.org>", "committedDate": "2020-10-18T09:46:31Z", "type": "commit"}, {"oid": "4b5c42538bdb01bcd05135cb016b450a51885f0c", "url": "https://github.com/openhab/openhab-addons/commit/4b5c42538bdb01bcd05135cb016b450a51885f0c", "message": "[icalendar] Marked configuration classes as NonNullByDefault and corrected checks for configuration\n\nSigned-off-by: Michael Wodniok <michi@noorganization.org>", "committedDate": "2020-10-20T15:13:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1NDQ1MA==", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r511354450", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            return null;", "author": "fwolter", "createdAt": "2020-10-24T09:10:42Z", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "diffHunk": "@@ -67,6 +80,17 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n         if (!supportsThingType(thingTypeUID)) {\n             return null;\n         }\n-        return new ICalendarHandler(thing, sharedHttpClient, eventPublisher);\n+        if (thingTypeUID.equals(THING_TYPE_CALENDAR)) {\n+            if (thing instanceof Bridge) {\n+                return new ICalendarHandler((Bridge) thing, sharedHttpClient, eventPublisher, tzProvider);\n+            } else {\n+                logger.warn(\n+                        \"The API of iCalendar has changed. You have to recreate the calendar according to the docs.\");\n+                return null;", "originalCommit": "4b5c42538bdb01bcd05135cb016b450a51885f0c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4f5a54d7083d297745fe2f8bf5fde31854513871", "url": "https://github.com/openhab/openhab-addons/commit/4f5a54d7083d297745fe2f8bf5fde31854513871", "message": "[icalendar] Apply suggestions from code review\r\n\r\nSigned-off-by: Michael Wodniok <michi@noorganization.org>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-10-24T13:59:35Z", "type": "commit"}, {"oid": "dbd63c1764d39b4ab1eb62a1c4a5495c8bab52e9", "url": "https://github.com/openhab/openhab-addons/commit/dbd63c1764d39b4ab1eb62a1c4a5495c8bab52e9", "message": "[icalendar] corrected defaults for filter settings\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Michael Wodniok <michi@noorganization.org>", "committedDate": "2020-10-24T14:16:41Z", "type": "commit"}, {"oid": "9ce7e2b8195b77a9620fd2e6fdf6aed65e3dbada", "url": "https://github.com/openhab/openhab-addons/commit/9ce7e2b8195b77a9620fd2e6fdf6aed65e3dbada", "message": "[icalendar] Implemented `Comparable` in Event\n\nSuggested by @fwolter. Currently the sorting by end is not implemented, will extract this when needed.\n\nSigned-off-by: Michael Wodniok <michi@noorganization.org>", "committedDate": "2020-10-24T14:24:44Z", "type": "commit"}, {"oid": "bda1ea6f9082bc1e413fccda1538f6915480f0f9", "url": "https://github.com/openhab/openhab-addons/commit/bda1ea6f9082bc1e413fccda1538f6915480f0f9", "message": "[icalendar] Fixed race condition of internal datastructure\n\nBridge could cause race condition by coming online while updating result channels.\n\nSigned-off-by: Michael Wodniok <michi@noorganization.org>", "committedDate": "2020-10-24T15:07:32Z", "type": "commit"}]}