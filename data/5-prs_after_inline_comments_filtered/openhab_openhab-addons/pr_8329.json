{"pr_number": 8329, "pr_title": "[IpCamera] New binding for cameras - Initial Contribution", "pr_createdAt": "2020-08-22T14:03:43Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8329", "timeline": [{"oid": "7336cd594df407240f11d6c0678f46f4500cd98a", "url": "https://github.com/openhab/openhab-addons/commit/7336cd594df407240f11d6c0678f46f4500cd98a", "message": "Create getXmlCache\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-18T10:46:25Z", "type": "commit"}, {"oid": "8c676b00192161353faf5592118a9a1f363d56d5", "url": "https://github.com/openhab/openhab-addons/commit/8c676b00192161353faf5592118a9a1f363d56d5", "message": "changeAlarmState(String thisAlarmsChannel, OnOffType state)\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-18T11:00:53Z", "type": "commit"}, {"oid": "4e41fb87e268a8237ad3fea21175918381516460", "url": "https://github.com/openhab/openhab-addons/commit/4e41fb87e268a8237ad3fea21175918381516460", "message": "Changed to using Map<String, ChannelTracking> channelTrackingMap = new\nConcurrentHashMap<>();\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-18T23:06:12Z", "type": "commit"}, {"oid": "7b82826b7fd5a842b537484fa2209dff404fa6a2", "url": "https://github.com/openhab/openhab-addons/commit/7b82826b7fd5a842b537484fa2209dff404fa6a2", "message": "Fix: ffmpegLocation may have a space in its path\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-19T02:48:42Z", "type": "commit"}, {"oid": "fdc443dee10da3ae0d1f54c10e5f94a231d8f926", "url": "https://github.com/openhab/openhab-addons/commit/fdc443dee10da3ae0d1f54c10e5f94a231d8f926", "message": "Move mp4 and gif to Action.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-19T07:52:54Z", "type": "commit"}, {"oid": "3da7aebd72c50cb658134384847115661bb42c1f", "url": "https://github.com/openhab/openhab-addons/commit/3da7aebd72c50cb658134384847115661bb42c1f", "message": "Merge branch '2.5.x' into ipcamera", "committedDate": "2020-09-19T08:43:39Z", "type": "commit"}, {"oid": "6a0b458078b27e2ba64e748c9f2e2b5c6297d505", "url": "https://github.com/openhab/openhab-addons/commit/6a0b458078b27e2ba64e748c9f2e2b5c6297d505", "message": "Fixup readme after Actions and channel changes.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-19T10:14:53Z", "type": "commit"}, {"oid": "2e56bed8acab46cd88fcde46fef2339335e12cca", "url": "https://github.com/openhab/openhab-addons/commit/2e56bed8acab46cd88fcde46fef2339335e12cca", "message": "remove restart()\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-19T10:33:39Z", "type": "commit"}, {"oid": "e9e103caf48b03cfdcb65380c80362001b4f50dc", "url": "https://github.com/openhab/openhab-addons/commit/e9e103caf48b03cfdcb65380c80362001b4f50dc", "message": "Removed left over traces of old channels after Action changes.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-19T10:43:21Z", "type": "commit"}, {"oid": "5c86e5fe75e5b9133cdde78af4ba7b8c690667d2", "url": "https://github.com/openhab/openhab-addons/commit/5c86e5fe75e5b9133cdde78af4ba7b8c690667d2", "message": "Remove un-needed vars.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-19T11:56:34Z", "type": "commit"}, {"oid": "0fd8f066eb4cf75056530d46cb53a108f61d7708", "url": "https://github.com/openhab/openhab-addons/commit/0fd8f066eb4cf75056530d46cb53a108f61d7708", "message": "Spotless fixes.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-19T12:14:48Z", "type": "commit"}, {"oid": "cee456f336ad40c2a27a52409dfee324a3d1521b", "url": "https://github.com/openhab/openhab-addons/commit/cee456f336ad40c2a27a52409dfee324a3d1521b", "message": "Fix a comment.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-01T07:38:35Z", "type": "commit"}, {"oid": "d168f2c73935075d4d089c07dd42143824ba4e21", "url": "https://github.com/openhab/openhab-addons/commit/d168f2c73935075d4d089c07dd42143824ba4e21", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: cpmeister <mistercpp2000@gmail.com>", "committedDate": "2020-09-01T07:42:50Z", "type": "commit"}, {"oid": "60f38f6714d62e4fff235cd9d0724dee3955eae5", "url": "https://github.com/openhab/openhab-addons/commit/60f38f6714d62e4fff235cd9d0724dee3955eae5", "message": "Use static final for authorizationHandler.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-01T07:54:23Z", "type": "commit"}, {"oid": "c54a54fe47f362472b39b8dc6b2cb25b9557eea4", "url": "https://github.com/openhab/openhab-addons/commit/c54a54fe47f362472b39b8dc6b2cb25b9557eea4", "message": "Move field to top of class and create constants for pipeline names.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-01T08:26:53Z", "type": "commit"}, {"oid": "0205b99d14006d2777bff5693372166856f73d68", "url": "https://github.com/openhab/openhab-addons/commit/0205b99d14006d2777bff5693372166856f73d68", "message": "Use enum instead of String for ffmpeg format.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-01T09:13:55Z", "type": "commit"}, {"oid": "284f72c0ef2a4301baaf9c1acf243e3f367ac06b", "url": "https://github.com/openhab/openhab-addons/commit/284f72c0ef2a4301baaf9c1acf243e3f367ac06b", "message": "Move duplicate functions into a Helper class.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-01T10:18:42Z", "type": "commit"}, {"oid": "1fbd801d123977715a30368d39905b52fec6f20f", "url": "https://github.com/openhab/openhab-addons/commit/1fbd801d123977715a30368d39905b52fec6f20f", "message": "Misc changes.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-01T11:23:05Z", "type": "commit"}, {"oid": "1d409de7a07b9c772ed5189ff4ca12bea5553f24", "url": "https://github.com/openhab/openhab-addons/commit/1d409de7a07b9c772ed5189ff4ca12bea5553f24", "message": "Used Helper class.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-01T11:35:37Z", "type": "commit"}, {"oid": "eb82a9ec969c659240a42496bd55e45896117422", "url": "https://github.com/openhab/openhab-addons/commit/eb82a9ec969c659240a42496bd55e45896117422", "message": "Remove log sections from readme.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-01T11:44:10Z", "type": "commit"}, {"oid": "6919718385dd7bc80749ad7100b3eace97394b55", "url": "https://github.com/openhab/openhab-addons/commit/6919718385dd7bc80749ad7100b3eace97394b55", "message": "Remove .valueOf(\"\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-01T11:57:42Z", "type": "commit"}, {"oid": "f08dc4edbf71af58e5e80f4a56520202c3743469", "url": "https://github.com/openhab/openhab-addons/commit/f08dc4edbf71af58e5e80f4a56520202c3743469", "message": "Remove commented out suppression.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-01T12:00:04Z", "type": "commit"}, {"oid": "0661d49b7e20067039d3002d4ff2e953b3ee31a4", "url": "https://github.com/openhab/openhab-addons/commit/0661d49b7e20067039d3002d4ff2e953b3ee31a4", "message": "Make SUPPORTED_THING_TYPES non static.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-01T12:04:13Z", "type": "commit"}, {"oid": "39ecbdbf6b593daf2ac0e7f4ae7c174fad5b704b", "url": "https://github.com/openhab/openhab-addons/commit/39ecbdbf6b593daf2ac0e7f4ae7c174fad5b704b", "message": "Reversed last commit.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-01T12:07:12Z", "type": "commit"}, {"oid": "328c8e3722b0aae2d927873e01c6f4f456508c30", "url": "https://github.com/openhab/openhab-addons/commit/328c8e3722b0aae2d927873e01c6f4f456508c30", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>", "committedDate": "2020-09-01T12:14:47Z", "type": "commit"}, {"oid": "d5110fe7288fd58f65b6c0694a802ee23f1e8a64", "url": "https://github.com/openhab/openhab-addons/commit/d5110fe7288fd58f65b6c0694a802ee23f1e8a64", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>", "committedDate": "2020-09-01T12:15:47Z", "type": "commit"}, {"oid": "9672ce0eb0cc7caae9e639551271c48e4447e585", "url": "https://github.com/openhab/openhab-addons/commit/9672ce0eb0cc7caae9e639551271c48e4447e585", "message": "Removed commented out log lines.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-01T12:16:04Z", "type": "commit"}, {"oid": "236ec38f02402d797a7b2e57b2bc5aaefd955101", "url": "https://github.com/openhab/openhab-addons/commit/236ec38f02402d797a7b2e57b2bc5aaefd955101", "message": "Merge branch 'ipcamera' of https://github.com/Skinah/openhab-addons.git into ipcamera", "committedDate": "2020-09-01T12:16:19Z", "type": "commit"}, {"oid": "428e437218ca725327997cde9367cccfeb6a4077", "url": "https://github.com/openhab/openhab-addons/commit/428e437218ca725327997cde9367cccfeb6a4077", "message": "Commit reversed due to large breaks in code.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-01T12:19:26Z", "type": "commit"}, {"oid": "6bed04ad98732e1208ead1518869bdf47227a39c", "url": "https://github.com/openhab/openhab-addons/commit/6bed04ad98732e1208ead1518869bdf47227a39c", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>", "committedDate": "2020-09-01T12:27:21Z", "type": "commit"}, {"oid": "4f67003fd05d5312acc8fb4bd81b92564cb7d687", "url": "https://github.com/openhab/openhab-addons/commit/4f67003fd05d5312acc8fb4bd81b92564cb7d687", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>", "committedDate": "2020-09-02T04:55:13Z", "type": "commit"}, {"oid": "382fcea7d2b533b0af4be4531392af239503fd84", "url": "https://github.com/openhab/openhab-addons/commit/382fcea7d2b533b0af4be4531392af239503fd84", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>", "committedDate": "2020-09-02T04:56:11Z", "type": "commit"}, {"oid": "7c4aeb8de3b913812237fb1aa4a4e23654dc9cf9", "url": "https://github.com/openhab/openhab-addons/commit/7c4aeb8de3b913812237fb1aa4a4e23654dc9cf9", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>", "committedDate": "2020-09-02T04:57:41Z", "type": "commit"}, {"oid": "619e9ea37a40636b0c65961175c02783edfa86af", "url": "https://github.com/openhab/openhab-addons/commit/619e9ea37a40636b0c65961175c02783edfa86af", "message": "Dont check for int overflowing in Java.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-02T08:05:06Z", "type": "commit"}, {"oid": "e9445369416b857c8ac7fe16b42ebe85490ba07d", "url": "https://github.com/openhab/openhab-addons/commit/e9445369416b857c8ac7fe16b42ebe85490ba07d", "message": "Merge branch 'ipcamera' of https://github.com/Skinah/openhab-addons.git into ipcamera", "committedDate": "2020-09-02T08:05:24Z", "type": "commit"}, {"oid": "c7cbfa6a9fda0f8412710eb41516ffe34ae23ea6", "url": "https://github.com/openhab/openhab-addons/commit/c7cbfa6a9fda0f8412710eb41516ffe34ae23ea6", "message": "Make ArrayList into List.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-02T08:59:05Z", "type": "commit"}, {"oid": "cfd5436b593c1ab82299e261de038f42b0164629", "url": "https://github.com/openhab/openhab-addons/commit/cfd5436b593c1ab82299e261de038f42b0164629", "message": "Change gotoPreset channel to String not Number.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-02T10:13:37Z", "type": "commit"}, {"oid": "c9b40ef8de103e2bb318d43d142bbb37020bcdf3", "url": "https://github.com/openhab/openhab-addons/commit/c9b40ef8de103e2bb318d43d142bbb37020bcdf3", "message": "Changed to this::pollCameraGroup\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-02T10:18:54Z", "type": "commit"}, {"oid": "9a177ab36951f1248d2466174fd1a1873ab58042", "url": "https://github.com/openhab/openhab-addons/commit/9a177ab36951f1248d2466174fd1a1873ab58042", "message": "change away from Runnable.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-02T10:49:21Z", "type": "commit"}, {"oid": "9c66904ed852c1f1ea9f8279c0dafaa7bfda9f0f", "url": "https://github.com/openhab/openhab-addons/commit/9c66904ed852c1f1ea9f8279c0dafaa7bfda9f0f", "message": "Moved SUPPORTED_THING_TYPES\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-02T12:06:49Z", "type": "commit"}, {"oid": "219abc3fab3deb70f3d0b09d986e3aaaa9c2116d", "url": "https://github.com/openhab/openhab-addons/commit/219abc3fab3deb70f3d0b09d986e3aaaa9c2116d", "message": "Readme improvements.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-02T12:47:40Z", "type": "commit"}, {"oid": "0403ef5e29914585ebc34fc6aa4112b819751e37", "url": "https://github.com/openhab/openhab-addons/commit/0403ef5e29914585ebc34fc6aa4112b819751e37", "message": "New class to track channels.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-04T11:14:03Z", "type": "commit"}, {"oid": "b6ec2e80c26503ecf0eeb3825db08e4dd97a0776", "url": "https://github.com/openhab/openhab-addons/commit/b6ec2e80c26503ecf0eeb3825db08e4dd97a0776", "message": "Change things and configs to camelCase.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-05T03:08:59Z", "type": "commit"}, {"oid": "9c6e38bcfd47928b0cf87b8ac1073651a29b8e02", "url": "https://github.com/openhab/openhab-addons/commit/9c6e38bcfd47928b0cf87b8ac1073651a29b8e02", "message": "Channel list started.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-05T03:37:03Z", "type": "commit"}, {"oid": "c4bedb10abb01bfdc6e2c616accadef9a3461f37", "url": "https://github.com/openhab/openhab-addons/commit/c4bedb10abb01bfdc6e2c616accadef9a3461f37", "message": "readme fixes.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-05T03:45:12Z", "type": "commit"}, {"oid": "a9fceab3a9c1e742341a6c5df351b410602d1a3d", "url": "https://github.com/openhab/openhab-addons/commit/a9fceab3a9c1e742341a6c5df351b410602d1a3d", "message": "Clean up channel table.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-05T03:54:56Z", "type": "commit"}, {"oid": "8c43e1efaacf2bd0bf41f0c9a39ed276a8c7b432", "url": "https://github.com/openhab/openhab-addons/commit/8c43e1efaacf2bd0bf41f0c9a39ed276a8c7b432", "message": "Added channel types to list.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-05T04:09:29Z", "type": "commit"}, {"oid": "a3750e3d9388593ad5730fc95c5f0624ecdb4bdc", "url": "https://github.com/openhab/openhab-addons/commit/a3750e3d9388593ad5730fc95c5f0624ecdb4bdc", "message": "Add all channels and types to list.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-05T07:25:48Z", "type": "commit"}, {"oid": "b97309351c62e3d9c46f541c864a64c265be96e1", "url": "https://github.com/openhab/openhab-addons/commit/b97309351c62e3d9c46f541c864a64c265be96e1", "message": "Channel descriptions added.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-05T09:29:50Z", "type": "commit"}, {"oid": "02e51bd143e8e475fd0306544a736c91e5078c58", "url": "https://github.com/openhab/openhab-addons/commit/02e51bd143e8e475fd0306544a736c91e5078c58", "message": "Readme updates.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-05T11:14:45Z", "type": "commit"}, {"oid": "8d3a07faa3b594168d7e276581b584ff6157be49", "url": "https://github.com/openhab/openhab-addons/commit/8d3a07faa3b594168d7e276581b584ff6157be49", "message": "Spotless checks applied.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-05T13:57:04Z", "type": "commit"}, {"oid": "e4215979bcecdd9c1ce5bac4e8b6c6a1cafea547", "url": "https://github.com/openhab/openhab-addons/commit/e4215979bcecdd9c1ce5bac4e8b6c6a1cafea547", "message": "Improvements to setup process.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-06T06:39:28Z", "type": "commit"}, {"oid": "bc57975066d8d71ec5f88933d1a5f358b7083be0", "url": "https://github.com/openhab/openhab-addons/commit/bc57975066d8d71ec5f88933d1a5f358b7083be0", "message": "New groupTracker and allow primary network address to follow UI\nselection.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-08T08:00:55Z", "type": "commit"}, {"oid": "9a015164d0caf5ce583655aa8cb232c272144fc7", "url": "https://github.com/openhab/openhab-addons/commit/9a015164d0caf5ce583655aa8cb232c272144fc7", "message": "Bug fix.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-08T09:16:42Z", "type": "commit"}, {"oid": "840b7d1421a1914e2a427cbeeb84ec0da79dc635", "url": "https://github.com/openhab/openhab-addons/commit/840b7d1421a1914e2a427cbeeb84ec0da79dc635", "message": "Change to use Config class and getConfigAs\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-08T12:42:02Z", "type": "commit"}, {"oid": "54c94a779b3e9c38f5ac74297d836baaa0b03423", "url": "https://github.com/openhab/openhab-addons/commit/54c94a779b3e9c38f5ac74297d836baaa0b03423", "message": "Correcly check for OnOffType\n\nSigned-off-by: Hilbrand Bouwkamp <hilbrand@h72.nl>", "committedDate": "2020-09-08T13:32:06Z", "type": "commit"}, {"oid": "291132ebe2e65e293e88963ec6620a7a23406e3e", "url": "https://github.com/openhab/openhab-addons/commit/291132ebe2e65e293e88963ec6620a7a23406e3e", "message": "Corrected checking for zero decimal value\n\nSigned-off-by: Hilbrand Bouwkamp <hilbrand@h72.nl>", "committedDate": "2020-09-08T13:32:10Z", "type": "commit"}, {"oid": "08530d9ecd36d700fde5371a7019338c3026eea6", "url": "https://github.com/openhab/openhab-addons/commit/08530d9ecd36d700fde5371a7019338c3026eea6", "message": "Use lambda notation iso runnable\n\nSigned-off-by: Hilbrand Bouwkamp <hilbrand@h72.nl>", "committedDate": "2020-09-08T13:32:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc4Njk0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r484786948", "bodyText": "Is this a typo?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (content.contains(\"table.AudioDetect[0].MutationThreold=\")) {\n          \n          \n            \n                        if (content.contains(\"table.AudioDetect[0].MutationThreshold=\")) {\n          \n      \n    \n    \n  \n\nAnd same on next line", "author": "Hilbrand", "createdAt": "2020-09-08T09:39:21Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/AmcrestHandler.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.util.ArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.ipcamera.handler.IpCameraHandler;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * The {@link AmcrestHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class AmcrestHandler extends ChannelDuplexHandler {\n+    private String requestUrl = \"Empty\";\n+    IpCameraHandler ipCameraHandler;\n+\n+    public AmcrestHandler(ThingHandler handler) {\n+        ipCameraHandler = (IpCameraHandler) handler;\n+    }\n+\n+    public void setURL(String url) {\n+        requestUrl = url;\n+    }\n+\n+    // This handles the incoming http replies back from the camera.\n+    @Override\n+    public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+        if (msg == null || ctx == null) {\n+            return;\n+        }\n+        try {\n+            String content = msg.toString();\n+\n+            if (!content.isEmpty()) {\n+                ipCameraHandler.logger.trace(\"HTTP Result back from camera is \\t:{}:\", content);\n+            }\n+            if (content.contains(\"Error: No Events\")) {\n+                if (\"/cgi-bin/eventManager.cgi?action=getEventIndexes&code=VideoMotion\".equals(requestUrl)) {\n+                    ipCameraHandler.noMotionDetected(CHANNEL_MOTION_ALARM);\n+                } else if (\"/cgi-bin/eventManager.cgi?action=getEventIndexes&code=AudioMutation\".equals(requestUrl)) {\n+                    ipCameraHandler.noAudioDetected();\n+                }\n+            } else if (content.contains(\"channels[0]=0\")) {\n+                if (\"/cgi-bin/eventManager.cgi?action=getEventIndexes&code=VideoMotion\".equals(requestUrl)) {\n+                    ipCameraHandler.motionDetected(CHANNEL_MOTION_ALARM);\n+                } else if (\"/cgi-bin/eventManager.cgi?action=getEventIndexes&code=AudioMutation\".equals(requestUrl)) {\n+                    ipCameraHandler.audioDetected();\n+                }\n+            }\n+\n+            if (content.contains(\"table.MotionDetect[0].Enable=false\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_MOTION_ALARM, OnOffType.OFF);\n+            } else if (content.contains(\"table.MotionDetect[0].Enable=true\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_MOTION_ALARM, OnOffType.ON);\n+            }\n+            // determine if the audio alarm is turned on or off.\n+            if (content.contains(\"table.AudioDetect[0].MutationDetect=true\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_AUDIO_ALARM, OnOffType.ON);\n+            } else if (content.contains(\"table.AudioDetect[0].MutationDetect=false\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_AUDIO_ALARM, OnOffType.OFF);\n+            }\n+            // Handle AudioMutationThreshold alarm\n+            if (content.contains(\"table.AudioDetect[0].MutationThreold=\")) {", "originalCommit": "9a015164d0caf5ce583655aa8cb232c272144fc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ0NzYyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r485447622", "bodyText": "Not a typo and not a bug. That is in the API and is what works with the camera so I wont be changing this.", "author": "Skinah", "createdAt": "2020-09-09T08:51:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc4Njk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkzNzY4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r484937686", "bodyText": "Why not use int?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                BigDecimal port = new BigDecimal(0);\n          \n          \n            \n                int port;\n          \n      \n    \n    \n  \n\nDefault is 0, so no = 0 needed.", "author": "Hilbrand", "createdAt": "2020-09-08T13:52:28Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/config/CameraConfig.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.ipcamera.config;\n+\n+import java.math.BigDecimal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link CameraConfig} handles the configuration of cameras.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class CameraConfig {\n+    String ipAddress = \"\";\n+    BigDecimal port = new BigDecimal(0);", "originalCommit": "840b7d1421a1914e2a427cbeeb84ec0da79dc635", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d4b70523f9300c403eb2697ba99c147fc1251134", "url": "https://github.com/openhab/openhab-addons/commit/d4b70523f9300c403eb2697ba99c147fc1251134", "message": "Moved cameraConfig init.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-09T08:42:05Z", "type": "commit"}, {"oid": "247405062594e95e3a4b490f4bc2e79c2549cba3", "url": "https://github.com/openhab/openhab-addons/commit/247405062594e95e3a4b490f4bc2e79c2549cba3", "message": "Merge branch 'ipcamera' of https://github.com/Skinah/openhab-addons.git into ipcamera", "committedDate": "2020-09-09T08:42:22Z", "type": "commit"}, {"oid": "fdf57085efb2dfa5dc85ba154c1509096078aac8", "url": "https://github.com/openhab/openhab-addons/commit/fdf57085efb2dfa5dc85ba154c1509096078aac8", "message": "Merge pull request #3 from Hilbrand/ipcamera\n\nImproved command type comparison/usage\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-09T08:42:57Z", "type": "commit"}, {"oid": "5e58b4e8ab1d2495c0f87349ec8637d856055762", "url": "https://github.com/openhab/openhab-addons/commit/5e58b4e8ab1d2495c0f87349ec8637d856055762", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/config/CameraConfig.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>", "committedDate": "2020-09-09T08:48:30Z", "type": "commit"}, {"oid": "93c8b959bac7d1e2f3397952785a361b8b6df426", "url": "https://github.com/openhab/openhab-addons/commit/93c8b959bac7d1e2f3397952785a361b8b6df426", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/resources/ESH-INF/thing/thing-types.xml\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>", "committedDate": "2020-09-09T08:52:33Z", "type": "commit"}, {"oid": "ecd21ef9b39d45a537dbd556124b5c4c476f10a3", "url": "https://github.com/openhab/openhab-addons/commit/ecd21ef9b39d45a537dbd556124b5c4c476f10a3", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/resources/ESH-INF/thing/thing-types.xml\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>", "committedDate": "2020-09-09T08:52:50Z", "type": "commit"}, {"oid": "2c76d5f54d4ae93e36968892d00516f478bad24e", "url": "https://github.com/openhab/openhab-addons/commit/2c76d5f54d4ae93e36968892d00516f478bad24e", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/resources/ESH-INF/thing/thing-types.xml\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>", "committedDate": "2020-09-09T08:53:15Z", "type": "commit"}, {"oid": "d8c5126be75ebd42a507e0468adff7a29d77b492", "url": "https://github.com/openhab/openhab-addons/commit/d8c5126be75ebd42a507e0468adff7a29d77b492", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/resources/ESH-INF/thing/thing-types.xml\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>", "committedDate": "2020-09-09T08:53:37Z", "type": "commit"}, {"oid": "ccc6a6cac26fdc21ad27e3a719b45c4ceeb106da", "url": "https://github.com/openhab/openhab-addons/commit/ccc6a6cac26fdc21ad27e3a719b45c4ceeb106da", "message": "Merge branch 'ipcamera' of https://github.com/Skinah/openhab-addons.git into ipcamera", "committedDate": "2020-09-09T08:51:15Z", "type": "commit"}, {"oid": "c54abcd3e8c89101677891be7f8dfaa36055aca1", "url": "https://github.com/openhab/openhab-addons/commit/c54abcd3e8c89101677891be7f8dfaa36055aca1", "message": "Give units to all pollTime.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-09T08:54:10Z", "type": "commit"}, {"oid": "d6db22f43f329d7a0e246343d892550f9ba563cf", "url": "https://github.com/openhab/openhab-addons/commit/d6db22f43f329d7a0e246343d892550f9ba563cf", "message": "Update labels\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-09T09:31:04Z", "type": "commit"}, {"oid": "4ec15cadcdf8091093435110ebd9409f8162097c", "url": "https://github.com/openhab/openhab-addons/commit/4ec15cadcdf8091093435110ebd9409f8162097c", "message": "Spotless changes.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-09T09:33:05Z", "type": "commit"}, {"oid": "b00196e4249e8ed137c70ee9b6b11a9258a76506", "url": "https://github.com/openhab/openhab-addons/commit/b00196e4249e8ed137c70ee9b6b11a9258a76506", "message": "Fix merge clash.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-09T09:36:14Z", "type": "commit"}, {"oid": "a1caae9c598863267b722ddf7373c35d21079c2c", "url": "https://github.com/openhab/openhab-addons/commit/a1caae9c598863267b722ddf7373c35d21079c2c", "message": "Multiple Improvements\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-09T10:44:32Z", "type": "commit"}, {"oid": "6cb60afae1921248eb54c9f01cd0ba6b7951ac62", "url": "https://github.com/openhab/openhab-addons/commit/6cb60afae1921248eb54c9f01cd0ba6b7951ac62", "message": "More minor fixes.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-09T11:00:09Z", "type": "commit"}, {"oid": "5f018d8507afeaca6aea31fdcf0f25cabc38e136", "url": "https://github.com/openhab/openhab-addons/commit/5f018d8507afeaca6aea31fdcf0f25cabc38e136", "message": "ONVIF compat improvement\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-10T11:51:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc2MDIxOA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r483760218", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        for (ChannelTracking channelTracking : channelTracker) {\n          \n          \n            \n                            logger.trace(\"Channel is open:{}, url is {}\", channelTracking.getChannel().isOpen(),\n          \n          \n            \n                                    channelTracking.getRequestUrl());\n          \n          \n            \n                            if (!channelTracking.getChannel().isOpen() && channelTracking.getReply().isEmpty()) {\n          \n          \n            \n                                localTracking = channelTracking;// Seems to create a deadlock if we remove whilst in loop\n          \n          \n            \n                                return;\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                    } finally {\n          \n          \n            \n                        if (localTracking != null) {\n          \n          \n            \n                            channelTracker.remove(localTracking);// clean up one closed channel.\n          \n          \n            \n                        }\n          \n          \n            \n                        for (ChannelTracking channelTracking : channelTracker) {\n          \n          \n            \n                            logger.trace(\"Channel is open:{}, url is {}\", channelTracking.getChannel().isOpen(),\n          \n          \n            \n                                    channelTracking.getRequestUrl());\n          \n          \n            \n                            if (!channelTracking.getChannel().isOpen() && channelTracking.getReply().isEmpty()) {\n          \n          \n            \n                                localTracking = channelTracking;// Seems to create a deadlock if we remove whilst in loop\n          \n          \n            \n                                break;\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                        if (localTracking != null) {\n          \n          \n            \n                            channelTracker.remove(localTracking);// clean up one closed channel.\n          \n          \n            \n                        }\n          \n          \n            \n                    } finally {", "author": "cpmeister", "createdAt": "2020-09-04T17:28:13Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -994,6 +835,56 @@ public void setupMjpegStreaming(boolean start, ChannelHandlerContext ctx) {\n         }\n     }\n \n+    void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (ChannelTracking channelTracking : channelTracker) {\n+                if (channelTracking.getRequestUrl().equals(url)) {\n+                    if (channelTracking.getChannel().isOpen()) {\n+                        channelTracking.getChannel().close();\n+                        return;\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    void cleanChannels() {\n+        ChannelTracking localTracking = null;\n+        lock.lock();\n+        try {\n+            for (ChannelTracking channelTracking : channelTracker) {\n+                logger.trace(\"Channel is open:{}, url is {}\", channelTracking.getChannel().isOpen(),\n+                        channelTracking.getRequestUrl());\n+                if (!channelTracking.getChannel().isOpen() && channelTracking.getReply().isEmpty()) {\n+                    localTracking = channelTracking;// Seems to create a deadlock if we remove whilst in loop\n+                    return;\n+                }\n+            }\n+        } finally {\n+            if (localTracking != null) {\n+                channelTracker.remove(localTracking);// clean up one closed channel.\n+            }", "originalCommit": "0403ef5e29914585ebc34fc6aa4112b819751e37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5MTkwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r487191901", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        for (Object incomingJpeg : fifoSnapshotBuffer) {\n          \n          \n            \n                            byte[] foo = (byte[]) incomingJpeg;\n          \n          \n            \n                        for (byte[] foo : fifoSnapshotBuffer) {", "author": "cpmeister", "createdAt": "2020-09-11T17:37:29Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,1797 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.config.CameraConfig;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.ChannelTracking;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.GroupTracker;\n+import org.openhab.binding.ipcamera.internal.Helper;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(4);\n+    private GroupTracker groupTracker;\n+    public CameraConfig cameraConfig;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup openChannels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private int nvrChannel;\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp;\n+    private String ffmpegOutputFolder = \"\";\n+    public ReentrantLock lock = new ReentrantLock();\n+    public List<ChannelTracking> channelTracker = new ArrayList<>(18);\n+    public List<String> lowPriorityRequests = new ArrayList<>(0);\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public static enum ffmpegFormat {\n+        HLS,\n+        GIF,\n+        RECORD,\n+        RTSPHELPER,\n+        MJPEG,\n+        SNAPSHOT\n+    }\n+\n+    // These methods handle the response from all camera brands, nothing specific to\n+    // any brand should be in here //\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                // logger.trace(\"{}\", msg.toString());\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                processSnapshot(incomingJpeg);\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    ctx.close();\n+                                } else {\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.isEmpty()) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause instanceof ArrayIndexOutOfBoundsException) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        String urlToKeepOpen = \"\";\n+                        switch (thing.getThingTypeUID().getId()) {\n+                            case DAHUA_THING:\n+                                urlToKeepOpen = \"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\";\n+                                break;\n+                            case HIKVISION_THING:\n+                                urlToKeepOpen = \"/ISAPI/Event/notification/alertStream\";\n+                                break;\n+                            case DOORBIRD_THING:\n+                                urlToKeepOpen = \"/bha-api/monitor.cgi?ring=doorbell,motionsensor\";\n+                                break;\n+                        }\n+\n+                        for (ChannelTracking channelTracking : channelTracker) {\n+                            if (channelTracking.getChannel().equals(ctx.channel())) {\n+                                if (channelTracking.getRequestUrl().equals(urlToKeepOpen)) {\n+                                    return; // don't auto close this as it is for the alarms.\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public IpCameraHandler(Thing thing, @Nullable String openhabIpAddress, GroupTracker groupTracker) {\n+        super(thing);\n+        cameraConfig = getConfigAs(CameraConfig.class);\n+        if (openhabIpAddress != null) {\n+            hostIp = openhabIpAddress;\n+        } else {\n+            hostIp = Helper.getLocalIpAddress();\n+        }\n+        this.groupTracker = groupTracker;\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.isEmpty()) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.isEmpty() && !password.isEmpty()) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return cameraConfig.getPort();\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null)//\n+    // The authHandler will generate a digest string and re-send using this same function when needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(AUTH_HANDLER,\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(COMMON_HANDLER, new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case AMCREST_THING:\n+                            socketChannel.pipeline().addLast(AMCREST_HANDLER, new AmcrestHandler(getHandle()));\n+                            break;\n+                        case DAHUA_THING:\n+                            socketChannel.pipeline().addLast(new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case DOORBIRD_THING:\n+                            socketChannel.pipeline().addLast(new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case FOSCAM_THING:\n+                            socketChannel.pipeline().addLast(new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case HIKVISION_THING:\n+                            socketChannel.pipeline().addLast(new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case INSTAR_THING:\n+                            socketChannel.pipeline().addLast(INSTAR_HANDLER, new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (!\"PUT\".equals(httpMethod) || (useDigestAuth && digestString == null)) {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        } else {\n+            request = putRequestWithBody;\n+        }\n+\n+        if (!basicAuth.isEmpty()) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    Channel ch = future.channel();\n+                    boolean chTracked = false;\n+                    openChannels.add(ch);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    try {\n+                        for (ChannelTracking channelTracking : channelTracker) {\n+                            if (channelTracking.getRequestUrl().equals(httpRequestURL)) {\n+                                channelTracking.setChannel(ch);\n+                                chTracked = true;\n+                                break;\n+                            }\n+                        }\n+                        if (!chTracked) {\n+                            channelTracker.add(new ChannelTracking(ch, httpRequestURL));\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(COMMON_HANDLER);\n+                    commonHandler.setURL(httpRequestURLFull);\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(AUTH_HANDLER);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case AMCREST_THING:\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(AMCREST_HANDLER);\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case INSTAR_THING:\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(INSTAR_HANDLER);\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+                    ch.writeAndFlush(request);\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot(byte[] incommingSnapshot) {\n+        lockCurrentSnapshot.lock();\n+        try {\n+            currentSnapshot = incommingSnapshot;\n+            if (preroll > 0) {\n+                fifoSnapshotBuffer.add(incommingSnapshot);\n+                if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                    fifoSnapshotBuffer.removeFirst();\n+                }\n+            }\n+        } finally {\n+            lockCurrentSnapshot.unlock();\n+        }\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(incommingSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(incommingSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                // only happens every 8 seconds as some browsers need a frame that often to keep stream alive.\n+                sendMjpegFrame(incommingSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 60, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.debug(\"File server for camera at {} has started on port {} for all NIC's.\", ipAddress,\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    cameraConfigError(\"Exception when starting server. Try changing the serverPort to another number.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setupSnapshotStreaming(boolean stream, ChannelHandlerContext ctx, boolean auto) {\n+        if (stream) {\n+            sendMjpegFirstPacket(ctx);\n+            if (auto) {\n+                autoSnapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                try {\n+                    sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                    // iOS uses a FIFO? and needs two frames to display a pic\n+                    sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                } finally {\n+                    lockCurrentSnapshot.unlock();\n+                }\n+                streamingAutoFps = true;\n+            } else {\n+                snapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                try {\n+                    sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+                } finally {\n+                    lockCurrentSnapshot.unlock();\n+                }\n+                streamingSnapshotMjpeg = true;\n+                startSnapshotPolling();\n+            }\n+        } else {\n+            snapshotMjpegChannelGroup.remove(ctx.channel());\n+            autoSnapshotMjpegChannelGroup.remove(ctx.channel());\n+            if (streamingSnapshotMjpeg && snapshotMjpegChannelGroup.isEmpty()) {\n+                streamingSnapshotMjpeg = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All snapshots.mjpeg streams have stopped.\");\n+            } else if (streamingAutoFps && autoSnapshotMjpegChannelGroup.isEmpty()) {\n+                streamingAutoFps = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All autofps.mjpeg streams have stopped.\");\n+            }\n+        }\n+    }\n+\n+    // If start is true the CTX is added to the list to stream video to, false stops\n+    // the stream.\n+    public void setupMjpegStreaming(boolean start, ChannelHandlerContext ctx) {\n+        if (start) {\n+            if (mjpegChannelGroup.isEmpty()) {// first stream being requested.\n+                mjpegChannelGroup.add(ctx.channel());\n+                if (mjpegUri.isEmpty() || mjpegUri.equals(\"ffmpeg\")) {\n+                    sendMjpegFirstPacket(ctx);\n+                    setupFfmpegFormat(ffmpegFormat.MJPEG);\n+                } else {\n+                    try {\n+                        // fix Dahua reboots when refreshing a mjpeg stream.\n+                        TimeUnit.MILLISECONDS.sleep(500);\n+                    } catch (InterruptedException e) {\n+                    }\n+                    sendHttpGET(mjpegUri);\n+                }\n+            } else if (ffmpegMjpeg != null) {// not first stream and we will use ffmpeg\n+                sendMjpegFirstPacket(ctx);\n+                mjpegChannelGroup.add(ctx.channel());\n+            } else {// not first stream and camera supplies the mjpeg source.\n+                ctx.channel().writeAndFlush(firstStreamedMsg);\n+                mjpegChannelGroup.add(ctx.channel());\n+            }\n+        } else {\n+            mjpegChannelGroup.remove(ctx.channel());\n+            if (mjpegChannelGroup.isEmpty()) {\n+                logger.debug(\"All ipcamera.mjpeg streams have stopped.\");\n+                if (mjpegUri.equals(\"ffmpeg\")) {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                } else if (!mjpegUri.isEmpty()) {\n+                    closeChannel(getTinyUrl(mjpegUri));\n+                } else {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (ChannelTracking channelTracking : channelTracker) {\n+                if (channelTracking.getRequestUrl().equals(url)) {\n+                    if (channelTracking.getChannel().isOpen()) {\n+                        channelTracking.getChannel().close();\n+                        return;\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    void cleanChannels() {\n+        ChannelTracking localTracking = null;\n+        lock.lock();\n+        try {\n+            for (ChannelTracking channelTracking : channelTracker) {\n+                logger.trace(\"Channel is open:{}, url is {}\", channelTracking.getChannel().isOpen(),\n+                        channelTracking.getRequestUrl());\n+                if (!channelTracking.getChannel().isOpen() && channelTracking.getReply().isEmpty()) {\n+                    localTracking = channelTracking;// Seems to create a deadlock if we remove whilst in loop\n+                    return;\n+                }\n+            }\n+        } finally {\n+            if (localTracking != null) {\n+                channelTracker.remove(localTracking);// clean up one closed channel.\n+            }\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void storeHttpReply(String url, String content) {\n+        lock.lock();\n+        try {\n+            for (ChannelTracking channelTracking : channelTracker) {\n+                if (channelTracking.getRequestUrl().equals(url)) {\n+                    channelTracking.setReply(content);\n+                    return;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    // sends direct to ctx so can be either snapshots.mjpeg or normal mjpeg stream\n+    public void sendMjpegFirstPacket(ChannelHandlerContext ctx) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        String contentType = \"multipart/x-mixed-replace; boundary=\" + BOUNDARY;\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+        ctx.channel().writeAndFlush(response);\n+    }\n+\n+    public void sendMjpegFrame(byte[] jpg, ChannelGroup channelGroup) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        ByteBuf imageByteBuf = Unpooled.copiedBuffer(jpg);\n+        int length = imageByteBuf.readableBytes();\n+        String header = \"--\" + BOUNDARY + \"\\r\\n\" + \"content-type: image/jpeg\" + \"\\r\\n\" + \"content-length: \" + length\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuf headerBbuf = Unpooled.copiedBuffer(header, 0, header.length(), StandardCharsets.UTF_8);\n+        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+        streamToGroup(headerBbuf, channelGroup, false);\n+        streamToGroup(imageByteBuf, channelGroup, false);\n+        streamToGroup(footerBbuf, channelGroup, true);\n+    }\n+\n+    public void streamToGroup(Object msg, ChannelGroup channelGroup, boolean flush) {\n+        channelGroup.write(msg);\n+        if (flush) {\n+            channelGroup.flush();\n+        }\n+    }\n+\n+    private void storeSnapshots() {\n+        int count = 0;\n+        // Need to lock as fifoSnapshotBuffer is not thread safe and new snapshots can be incoming.\n+        lockCurrentSnapshot.lock();\n+        try {\n+            for (Object incomingJpeg : fifoSnapshotBuffer) {\n+                byte[] foo = (byte[]) incomingJpeg;", "originalCommit": "5f018d8507afeaca6aea31fdcf0f25cabc38e136", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5Mzc4NA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r487193784", "bodyText": "It is safer to cache the handler instance in case something ends up changing in the camera order concurrently.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ipCameraGroupHandler.cameraOrder.get(ipCameraGroupHandler.cameraIndex).lockCurrentSnapshot.lock();\n          \n          \n            \n                    try {\n          \n          \n            \n                        ByteBuf snapshotData = Unpooled.copiedBuffer(\n          \n          \n            \n                                ipCameraGroupHandler.cameraOrder.get(ipCameraGroupHandler.cameraIndex).currentSnapshot);\n          \n          \n            \n                        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n          \n          \n            \n                        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n          \n          \n            \n                        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n          \n          \n            \n                        response.headers().add(HttpHeaderNames.CONTENT_LENGTH, snapshotData.readableBytes());\n          \n          \n            \n                        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n          \n          \n            \n                        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n          \n          \n            \n                        ctx.channel().write(response);\n          \n          \n            \n                        ctx.channel().write(snapshotData);\n          \n          \n            \n                        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n          \n          \n            \n                        ctx.channel().writeAndFlush(footerBbuf);\n          \n          \n            \n                    } finally {\n          \n          \n            \n                        ipCameraGroupHandler.cameraOrder.get(ipCameraGroupHandler.cameraIndex).lockCurrentSnapshot.unlock();\n          \n          \n            \n                    IpCameraHandler handler = ipCameraGroupHandler.cameraOrder.get(ipCameraGroupHandler.cameraIndex);\n          \n          \n            \n                    handler.lockCurrentSnapshot.lock();\n          \n          \n            \n                    try {\n          \n          \n            \n                        ByteBuf snapshotData = Unpooled.copiedBuffer(\n          \n          \n            \n                                handler.currentSnapshot);\n          \n          \n            \n                        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n          \n          \n            \n                        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n          \n          \n            \n                        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n          \n          \n            \n                        response.headers().add(HttpHeaderNames.CONTENT_LENGTH, snapshotData.readableBytes());\n          \n          \n            \n                        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n          \n          \n            \n                        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n          \n          \n            \n                        ctx.channel().write(response);\n          \n          \n            \n                        ctx.channel().write(snapshotData);\n          \n          \n            \n                        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n          \n          \n            \n                        ctx.channel().writeAndFlush(footerBbuf);\n          \n          \n            \n                    } finally {\n          \n          \n            \n                        handler.lockCurrentSnapshot.unlock();", "author": "cpmeister", "createdAt": "2020-09-11T17:41:04Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/StreamServerGroupHandler.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.CHANNEL_START_STREAM;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.openhab.binding.ipcamera.handler.IpCameraGroupHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.QueryStringDecoder;\n+import io.netty.handler.stream.ChunkedFile;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * The {@link StreamServerGroupHandler} class is responsible for handling streams and sending any requested files to\n+ * Openhabs\n+ * features for a group of cameras instead of individual cameras.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class StreamServerGroupHandler extends ChannelInboundHandlerAdapter {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private IpCameraGroupHandler ipCameraGroupHandler;\n+    String whiteList = \"\";\n+    int recievedBytes = 0;\n+    int count = 0;\n+    boolean updateSnapshot = false;\n+\n+    public StreamServerGroupHandler(IpCameraGroupHandler ipCameraGroupHandler) {\n+        this.ipCameraGroupHandler = ipCameraGroupHandler;\n+        whiteList = ipCameraGroupHandler.getWhiteList();\n+    }\n+\n+    @Override\n+    public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+    }\n+\n+    private String resolveIndexToPath(String uri) {\n+        if (!uri.substring(1, 2).equals(\"i\")) {\n+            return ipCameraGroupHandler.getOutputFolder(Integer.parseInt(uri.substring(1, 2)));\n+        }\n+        return \"notFound\";\n+        // example is /1ipcameraxx.ts\n+    }\n+\n+    @Override\n+    public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+        if (msg == null || ctx == null) {\n+            return;\n+        }\n+        try {\n+            if (msg instanceof HttpRequest) {\n+                HttpRequest httpRequest = (HttpRequest) msg;\n+                String requestIP = \"(\"\n+                        + ((InetSocketAddress) ctx.channel().remoteAddress()).getAddress().getHostAddress() + \")\";\n+                if (!whiteList.contains(requestIP) && !whiteList.equals(\"DISABLE\")) {\n+                    logger.warn(\"The request made from {} was not in the whitelist and will be ignored.\", requestIP);\n+                    return;\n+                } else if (\"GET\".equalsIgnoreCase(httpRequest.method().toString())) {\n+                    // Some browsers send a query string after the path when refreshing a picture.\n+                    QueryStringDecoder queryStringDecoder = new QueryStringDecoder(httpRequest.uri());\n+                    switch (queryStringDecoder.path()) {\n+                        case \"/ipcamera.m3u8\":\n+                            if (ipCameraGroupHandler.hlsTurnedOn) {\n+                                String debugMe = ipCameraGroupHandler.getPlayList();\n+                                logger.debug(\"playlist is:{}\", debugMe);\n+                                sendString(ctx, debugMe, \"application/x-mpegurl\");\n+                                return;\n+                            } else {\n+                                logger.warn(\n+                                        \"HLS requires the groups startStream channel to be turned on first. Just starting it now.\");\n+                                String channelPrefix = \"ipcamera:\" + ipCameraGroupHandler.getThing().getThingTypeUID()\n+                                        + \":\" + ipCameraGroupHandler.getThing().getUID().getId() + \":\";\n+                                ipCameraGroupHandler.handleCommand(new ChannelUID(channelPrefix + CHANNEL_START_STREAM),\n+                                        OnOffType.ON);\n+                            }\n+                            break;\n+                        case \"/ipcamera.jpg\":\n+                            sendSnapshotImage(ctx, \"image/jpg\");\n+                            return;\n+                        default:\n+                            if (httpRequest.uri().contains(\".ts\")) {\n+                                sendFile(ctx, resolveIndexToPath(httpRequest.uri()) + httpRequest.uri().substring(2),\n+                                        \"video/MP2T\");\n+                            } else if (httpRequest.uri().contains(\".jpg\")) {\n+                                sendFile(ctx, httpRequest.uri(), \"image/jpg\");\n+                            } else if (httpRequest.uri().contains(\".m4s\") || httpRequest.uri().contains(\".mp4\")) {\n+                                sendFile(ctx, httpRequest.uri(), \"video/mp4\");\n+                            }\n+                    }\n+                }\n+            }\n+        } finally {\n+            ReferenceCountUtil.release(msg);\n+        }\n+    }\n+\n+    private void sendSnapshotImage(ChannelHandlerContext ctx, String contentType) throws IOException {\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        if (ipCameraGroupHandler.cameraIndex >= ipCameraGroupHandler.cameraOrder.size()) {\n+            logger.debug(\"WARN: Openhab may still be starting, or all cameras in the group are OFFLINE.\");\n+            return;\n+        }\n+        ipCameraGroupHandler.cameraOrder.get(ipCameraGroupHandler.cameraIndex).lockCurrentSnapshot.lock();\n+        try {\n+            ByteBuf snapshotData = Unpooled.copiedBuffer(\n+                    ipCameraGroupHandler.cameraOrder.get(ipCameraGroupHandler.cameraIndex).currentSnapshot);\n+            response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+            response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+            response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+            response.headers().add(HttpHeaderNames.CONTENT_LENGTH, snapshotData.readableBytes());\n+            response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+            response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+            ctx.channel().write(response);\n+            ctx.channel().write(snapshotData);\n+            ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+            ctx.channel().writeAndFlush(footerBbuf);\n+        } finally {\n+            ipCameraGroupHandler.cameraOrder.get(ipCameraGroupHandler.cameraIndex).lockCurrentSnapshot.unlock();", "originalCommit": "5f018d8507afeaca6aea31fdcf0f25cabc38e136", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5NjE5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r487196196", "bodyText": "any reason these fields can't be private?", "author": "cpmeister", "createdAt": "2020-09-11T17:45:41Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/StreamServerHandler.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.ipcamera.handler.IpCameraHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.codec.http.QueryStringDecoder;\n+import io.netty.handler.stream.ChunkedFile;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * The {@link StreamServerHandler} class is responsible for handling streams and sending any requested files to openHABs\n+ * features.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class StreamServerHandler extends ChannelInboundHandlerAdapter {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private IpCameraHandler ipCameraHandler;\n+    private boolean handlingMjpeg = false; // used to remove ctx from group when handler is removed.\n+    private boolean handlingSnapshotStream = false; // used to remove ctx from group when handler is removed.\n+    private byte[] incomingJpeg = new byte[0];\n+    String whiteList = \"\";\n+    int recievedBytes = 0;\n+    int count = 0;\n+    boolean updateSnapshot = false;\n+    boolean onvifEvent = false;", "originalCommit": "5f018d8507afeaca6aea31fdcf0f25cabc38e136", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDM5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r487344399", "bodyText": "None, I just found Eclipse makes them private by default? Is this because other IDE's may handle it differently? Will make changes shortly.", "author": "Skinah", "createdAt": "2020-09-12T00:39:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5NjE5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTg4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r487345889", "bodyText": "Ah I see I understood wrongly now I am making the change.", "author": "Skinah", "createdAt": "2020-09-12T00:49:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5NjE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5NjY2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r487196667", "bodyText": "Can these be private?", "author": "cpmeister", "createdAt": "2020-09-11T17:46:41Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/onvif/OnvifCodec.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.onvif;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * The {@link OnvifCodec} is used by Netty to decode Onvif traffic into message Strings.\n+ *\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OnvifCodec extends ChannelDuplexHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    String incomingMessage = \"\";\n+    OnvifConnection onvifConnection;", "originalCommit": "5f018d8507afeaca6aea31fdcf0f25cabc38e136", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5NzAwMg==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r487197002", "bodyText": "Please make fields private where possible.", "author": "cpmeister", "createdAt": "2020-09-11T17:47:22Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/StreamServerGroupHandler.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.CHANNEL_START_STREAM;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.openhab.binding.ipcamera.handler.IpCameraGroupHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.QueryStringDecoder;\n+import io.netty.handler.stream.ChunkedFile;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * The {@link StreamServerGroupHandler} class is responsible for handling streams and sending any requested files to\n+ * Openhabs\n+ * features for a group of cameras instead of individual cameras.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class StreamServerGroupHandler extends ChannelInboundHandlerAdapter {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private IpCameraGroupHandler ipCameraGroupHandler;\n+    String whiteList = \"\";\n+    int recievedBytes = 0;\n+    int count = 0;\n+    boolean updateSnapshot = false;", "originalCommit": "5f018d8507afeaca6aea31fdcf0f25cabc38e136", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIwMDEwMw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r487200103", "bodyText": "No need to call toString if you don't have to.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            } else if (\"GET\".equalsIgnoreCase(httpRequest.method().toString())) {\n          \n          \n            \n                            } else if (HttpMethod.GET.equals(httpRequest.method())) {", "author": "cpmeister", "createdAt": "2020-09-11T17:53:52Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/StreamServerGroupHandler.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.CHANNEL_START_STREAM;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.openhab.binding.ipcamera.handler.IpCameraGroupHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.QueryStringDecoder;\n+import io.netty.handler.stream.ChunkedFile;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * The {@link StreamServerGroupHandler} class is responsible for handling streams and sending any requested files to\n+ * Openhabs\n+ * features for a group of cameras instead of individual cameras.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class StreamServerGroupHandler extends ChannelInboundHandlerAdapter {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private IpCameraGroupHandler ipCameraGroupHandler;\n+    String whiteList = \"\";\n+    int recievedBytes = 0;\n+    int count = 0;\n+    boolean updateSnapshot = false;\n+\n+    public StreamServerGroupHandler(IpCameraGroupHandler ipCameraGroupHandler) {\n+        this.ipCameraGroupHandler = ipCameraGroupHandler;\n+        whiteList = ipCameraGroupHandler.getWhiteList();\n+    }\n+\n+    @Override\n+    public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+    }\n+\n+    private String resolveIndexToPath(String uri) {\n+        if (!uri.substring(1, 2).equals(\"i\")) {\n+            return ipCameraGroupHandler.getOutputFolder(Integer.parseInt(uri.substring(1, 2)));\n+        }\n+        return \"notFound\";\n+        // example is /1ipcameraxx.ts\n+    }\n+\n+    @Override\n+    public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+        if (msg == null || ctx == null) {\n+            return;\n+        }\n+        try {\n+            if (msg instanceof HttpRequest) {\n+                HttpRequest httpRequest = (HttpRequest) msg;\n+                String requestIP = \"(\"\n+                        + ((InetSocketAddress) ctx.channel().remoteAddress()).getAddress().getHostAddress() + \")\";\n+                if (!whiteList.contains(requestIP) && !whiteList.equals(\"DISABLE\")) {\n+                    logger.warn(\"The request made from {} was not in the whitelist and will be ignored.\", requestIP);\n+                    return;\n+                } else if (\"GET\".equalsIgnoreCase(httpRequest.method().toString())) {", "originalCommit": "5f018d8507afeaca6aea31fdcf0f25cabc38e136", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIwMTI1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r487201259", "bodyText": "Should this session number be random instead?", "author": "cpmeister", "createdAt": "2020-09-11T17:55:58Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/RtspHandler.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import java.net.InetSocketAddress;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.http.DefaultHttpRequest;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.rtsp.RtspDecoder;\n+import io.netty.handler.codec.rtsp.RtspEncoder;\n+import io.netty.handler.codec.rtsp.RtspHeaderNames;\n+import io.netty.handler.codec.rtsp.RtspMethods;\n+import io.netty.handler.codec.rtsp.RtspVersions;\n+import io.netty.util.CharsetUtil;\n+\n+/**\n+ * The {@link RtspHandler} This class is a WIP and is currently not used. Can be used to check what format the stream is\n+ * in\n+ * mjpeg or H.264/5, check audio formats and frame rates.\n+ *\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class RtspHandler extends ChannelDuplexHandler {\n+    @Nullable\n+    private Bootstrap rtspBootstrap;\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private String ipAddress = \"todo\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    RtspHandler() {\n+        // todo may need to pass in IP of camera plus a few others to make this code\n+        // work again after it was moved to its own class.\n+    }\n+\n+    public HttpRequest getRTSPoptions(String rtspURL) {\n+        HttpRequest request = new DefaultHttpRequest(RtspVersions.RTSP_1_0, RtspMethods.OPTIONS, rtspURL);\n+        request.headers().add(RtspHeaderNames.CSEQ, \"1\");\n+        return request;\n+    }\n+\n+    public HttpRequest getRTSPdescribe(String rtspURL) {\n+        HttpRequest request = new DefaultHttpRequest(RtspVersions.RTSP_1_0, RtspMethods.DESCRIBE, rtspURL);\n+        request.headers().add(RtspHeaderNames.CSEQ, \"2\");\n+        return request;\n+    }\n+\n+    public HttpRequest getRTSPsetup(String rtspURL) {\n+        HttpRequest request = new DefaultHttpRequest(RtspVersions.RTSP_1_0, RtspMethods.SETUP, rtspURL);\n+        request.headers().add(RtspHeaderNames.CSEQ, \"3\");\n+        request.headers().add(RtspHeaderNames.TRANSPORT, \"RTP/AVP;unicast;client_port=5000-5001\");\n+        return request;\n+    }\n+\n+    public HttpRequest getRTSPplay(String rtspURL) {\n+        HttpRequest request = new DefaultHttpRequest(RtspVersions.RTSP_1_0, RtspMethods.PLAY, rtspURL);\n+        request.headers().add(RtspHeaderNames.CSEQ, \"4\");\n+        request.headers().add(RtspHeaderNames.SESSION, \"12345678\"); // need session number to match that of setup", "originalCommit": "5f018d8507afeaca6aea31fdcf0f25cabc38e136", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MjgyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r487342822", "bodyText": "Yes it should be random. This class is not used currently and is an area that I am developing as I have spare time. Its probably 80% done to where it can be used. Eventually it will be able to make automatic choices inside the binding based on what format the cameras streams are in, making life easier for people that don't understand the inner workings of cameras.", "author": "Skinah", "createdAt": "2020-09-12T00:28:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIwMTI1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM3NDYzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r487374631", "bodyText": "Reworked the class to a new one and made it closer to being ready to being used.", "author": "Skinah", "createdAt": "2020-09-12T06:14:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIwMTI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIwMzY5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r487203697", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                ipCameraHandler.motionThreshold = Double.valueOf(command.toString());\n          \n          \n            \n                                ipCameraHandler.motionThreshold = ipCameraHandler.motionThreshold / 10000;\n          \n          \n            \n                                ipCameraHandler.motionThreshold = Double.valueOf(command.toString()) / 10000;", "author": "cpmeister", "createdAt": "2020-09-11T18:00:34Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/DahuaHandler.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.util.ArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.ipcamera.handler.IpCameraHandler;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * The {@link DahuaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class DahuaHandler extends ChannelDuplexHandler {\n+    IpCameraHandler ipCameraHandler;\n+    int nvrChannel;\n+\n+    public DahuaHandler(IpCameraHandler handler, int nvrChannel) {\n+        ipCameraHandler = handler;\n+        this.nvrChannel = nvrChannel;\n+    }\n+\n+    // This handles the incoming http replies back from the camera.\n+    @Override\n+    public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+        if (msg == null || ctx == null) {\n+            return;\n+        }\n+        String content = msg.toString();\n+        try {\n+            if (!content.isEmpty()) {\n+                ipCameraHandler.logger.trace(\"HTTP Result back from camera is \\t:{}:\", content);\n+            }\n+            // determine if the motion detection is turned on or off.\n+            if (content.contains(\"table.MotionDetect[0].Enable=true\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_MOTION_ALARM, OnOffType.ON);\n+            } else if (content.contains(\"table.MotionDetect[\" + nvrChannel + \"].Enable=false\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_MOTION_ALARM, OnOffType.OFF);\n+            }\n+            // Handle motion alarm\n+            if (content.contains(\"Code=VideoMotion;action=Start;index=0\")) {\n+                ipCameraHandler.motionDetected(CHANNEL_MOTION_ALARM);\n+            } else if (content.contains(\"Code=VideoMotion;action=Stop;index=0\")) {\n+                ipCameraHandler.noMotionDetected(CHANNEL_MOTION_ALARM);\n+            }\n+            // Handle item taken alarm\n+            if (content.contains(\"Code=TakenAwayDetection;action=Start;index=0\")) {\n+                ipCameraHandler.motionDetected(CHANNEL_ITEM_TAKEN);\n+            } else if (content.contains(\"Code=TakenAwayDetection;action=Stop;index=0\")) {\n+                ipCameraHandler.noMotionDetected(CHANNEL_ITEM_TAKEN);\n+            }\n+            // Handle item left alarm\n+            if (content.contains(\"Code=LeftDetection;action=Start;index=0\")) {\n+                ipCameraHandler.motionDetected(CHANNEL_ITEM_LEFT);\n+            } else if (content.contains(\"Code=LeftDetection;action=Stop;index=0\")) {\n+                ipCameraHandler.noMotionDetected(CHANNEL_ITEM_LEFT);\n+            }\n+            // Handle CrossLineDetection alarm\n+            if (content.contains(\"Code=CrossLineDetection;action=Start;index=0\")) {\n+                ipCameraHandler.motionDetected(CHANNEL_LINE_CROSSING_ALARM);\n+            } else if (content.contains(\"Code=CrossLineDetection;action=Stop;index=0\")) {\n+                ipCameraHandler.noMotionDetected(CHANNEL_LINE_CROSSING_ALARM);\n+            }\n+            // determine if the audio alarm is turned on or off.\n+            if (content.contains(\"table.AudioDetect[0].MutationDetect=true\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_AUDIO_ALARM, OnOffType.ON);\n+            } else if (content.contains(\"table.AudioDetect[0].MutationDetect=false\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_AUDIO_ALARM, OnOffType.OFF);\n+            }\n+            // Handle AudioMutation alarm\n+            if (content.contains(\"Code=AudioMutation;action=Start;index=0\")) {\n+                ipCameraHandler.audioDetected();\n+            } else if (content.contains(\"Code=AudioMutation;action=Stop;index=0\")) {\n+                ipCameraHandler.noAudioDetected();\n+            }\n+            // Handle AudioMutationThreshold alarm\n+            if (content.contains(\"table.AudioDetect[0].MutationThreold=\")) {\n+                String value = ipCameraHandler.returnValueFromString(content, \"table.AudioDetect[0].MutationThreold=\");\n+                ipCameraHandler.setChannelState(CHANNEL_THRESHOLD_AUDIO_ALARM, PercentType.valueOf(value));\n+            }\n+            // Handle FaceDetection alarm\n+            if (content.contains(\"Code=FaceDetection;action=Start;index=0\")) {\n+                ipCameraHandler.motionDetected(CHANNEL_FACE_DETECTED);\n+            } else if (content.contains(\"Code=FaceDetection;action=Stop;index=0\")) {\n+                ipCameraHandler.noMotionDetected(CHANNEL_FACE_DETECTED);\n+            }\n+            // Handle ParkingDetection alarm\n+            if (content.contains(\"Code=ParkingDetection;action=Start;index=0\")) {\n+                ipCameraHandler.motionDetected(CHANNEL_PARKING_ALARM);\n+            } else if (content.contains(\"Code=ParkingDetection;action=Stop;index=0\")) {\n+                ipCameraHandler.noMotionDetected(CHANNEL_PARKING_ALARM);\n+            }\n+            // Handle CrossRegionDetection alarm\n+            if (content.contains(\"Code=CrossRegionDetection;action=Start;index=0\")) {\n+                ipCameraHandler.motionDetected(CHANNEL_FIELD_DETECTION_ALARM);\n+            } else if (content.contains(\"Code=CrossRegionDetection;action=Stop;index=0\")) {\n+                ipCameraHandler.noMotionDetected(CHANNEL_FIELD_DETECTION_ALARM);\n+            }\n+            // Handle External Input alarm\n+            if (content.contains(\"Code=AlarmLocal;action=Start;index=0\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_EXTERNAL_ALARM_INPUT, OnOffType.ON);\n+            } else if (content.contains(\"Code=AlarmLocal;action=Stop;index=0\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_EXTERNAL_ALARM_INPUT, OnOffType.OFF);\n+            }\n+            // Handle External Input alarm2\n+            if (content.contains(\"Code=AlarmLocal;action=Start;index=1\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_EXTERNAL_ALARM_INPUT2, OnOffType.ON);\n+            } else if (content.contains(\"Code=AlarmLocal;action=Stop;index=1\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_EXTERNAL_ALARM_INPUT2, OnOffType.OFF);\n+            }\n+            // CrossLineDetection alarm on/off\n+            if (content.contains(\"table.VideoAnalyseRule[0][1].Enable=true\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_LINE_CROSSING_ALARM, OnOffType.ON);\n+            } else if (content.contains(\"table.VideoAnalyseRule[0][1].Enable=false\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_LINE_CROSSING_ALARM, OnOffType.OFF);\n+            }\n+        } finally {\n+            ReferenceCountUtil.release(msg);\n+        }\n+    }\n+\n+    // This handles the commands that come from the Openhab event bus.\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_THRESHOLD_AUDIO_ALARM:\n+                    // ipCameraHandler.sendHttpGET(\"/cgi-bin/configManager.cgi?action=getConfig&name=AudioDetect[0]\");\n+                    return;\n+                case CHANNEL_ENABLE_AUDIO_ALARM:\n+                    ipCameraHandler.sendHttpGET(\"/cgi-bin/configManager.cgi?action=getConfig&name=AudioDetect[0]\");\n+                    return;\n+                case CHANNEL_ENABLE_LINE_CROSSING_ALARM:\n+                    ipCameraHandler.sendHttpGET(\"/cgi-bin/configManager.cgi?action=getConfig&name=VideoAnalyseRule\");\n+                    return;\n+                case CHANNEL_ENABLE_MOTION_ALARM:\n+                    ipCameraHandler.sendHttpGET(\"/cgi-bin/configManager.cgi?action=getConfig&name=MotionDetect[0]\");\n+                    return;\n+            }\n+            return; // Return as we have handled the refresh command above and don't need to\n+                    // continue further.\n+        } // end of \"REFRESH\"\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TEXT_OVERLAY:\n+                String text = Helper.encodeSpecialChars(command.toString());\n+                if (\"\".contentEquals(text)) {\n+                    ipCameraHandler.sendHttpGET(\n+                            \"/cgi-bin/configManager.cgi?action=setConfig&VideoWidget[0].CustomTitle[1].EncodeBlend=false\");\n+                } else {\n+                    ipCameraHandler.sendHttpGET(\n+                            \"/cgi-bin/configManager.cgi?action=setConfig&VideoWidget[0].CustomTitle[1].EncodeBlend=true&VideoWidget[0].CustomTitle[1].Text=\"\n+                                    + text);\n+                }\n+                return;\n+            case CHANNEL_ENABLE_LED:\n+                ipCameraHandler.setChannelState(CHANNEL_AUTO_LED, OnOffType.OFF);\n+                if (DecimalType.ZERO.equals(command) || OnOffType.OFF.equals(command)) {\n+                    ipCameraHandler.sendHttpGET(\"/cgi-bin/configManager.cgi?action=setConfig&Lighting[0][0].Mode=Off\");\n+                } else if (OnOffType.ON.equals(command)) {\n+                    ipCameraHandler\n+                            .sendHttpGET(\"/cgi-bin/configManager.cgi?action=setConfig&Lighting[0][0].Mode=Manual\");\n+                } else {\n+                    ipCameraHandler.sendHttpGET(\n+                            \"/cgi-bin/configManager.cgi?action=setConfig&Lighting[0][0].Mode=Manual&Lighting[0][0].MiddleLight[0].Light=\"\n+                                    + command.toString());\n+                }\n+                return;\n+            case CHANNEL_AUTO_LED:\n+                if (OnOffType.ON.equals(command)) {\n+                    ipCameraHandler.setChannelState(CHANNEL_ENABLE_LED, UnDefType.UNDEF);\n+                    ipCameraHandler.sendHttpGET(\"/cgi-bin/configManager.cgi?action=setConfig&Lighting[0][0].Mode=Auto\");\n+                }\n+                return;\n+            case CHANNEL_THRESHOLD_AUDIO_ALARM:\n+                int threshold = Math.round(Float.valueOf(command.toString()));\n+\n+                if (threshold == 0) {\n+                    ipCameraHandler.sendHttpGET(\n+                            \"/cgi-bin/configManager.cgi?action=setConfig&AudioDetect[0].MutationThreold=1\");\n+                } else {\n+                    ipCameraHandler.sendHttpGET(\n+                            \"/cgi-bin/configManager.cgi?action=setConfig&AudioDetect[0].MutationThreold=\" + threshold);\n+                }\n+                return;\n+            case CHANNEL_ENABLE_AUDIO_ALARM:\n+                if (OnOffType.ON.equals(command)) {\n+                    ipCameraHandler.sendHttpGET(\n+                            \"/cgi-bin/configManager.cgi?action=setConfig&AudioDetect[0].MutationDetect=true&AudioDetect[0].EventHandler.Dejitter=1\");\n+                } else {\n+                    ipCameraHandler.sendHttpGET(\n+                            \"/cgi-bin/configManager.cgi?action=setConfig&AudioDetect[0].MutationDetect=false\");\n+                }\n+                return;\n+            case CHANNEL_ENABLE_LINE_CROSSING_ALARM:\n+                if (OnOffType.ON.equals(command)) {\n+                    ipCameraHandler.sendHttpGET(\n+                            \"/cgi-bin/configManager.cgi?action=setConfig&VideoAnalyseRule[0][1].Enable=true\");\n+                } else {\n+                    ipCameraHandler.sendHttpGET(\n+                            \"/cgi-bin/configManager.cgi?action=setConfig&VideoAnalyseRule[0][1].Enable=false\");\n+                }\n+                return;\n+            case CHANNEL_ENABLE_MOTION_ALARM:\n+                if (OnOffType.ON.equals(command)) {\n+                    ipCameraHandler.sendHttpGET(\n+                            \"/cgi-bin/configManager.cgi?action=setConfig&MotionDetect[0].Enable=true&MotionDetect[0].EventHandler.Dejitter=1\");\n+                } else {\n+                    ipCameraHandler\n+                            .sendHttpGET(\"/cgi-bin/configManager.cgi?action=setConfig&MotionDetect[0].Enable=false\");\n+                }\n+                return;\n+            case CHANNEL_ACTIVATE_ALARM_OUTPUT:\n+                if (OnOffType.ON.equals(command)) {\n+                    ipCameraHandler.sendHttpGET(\"/cgi-bin/configManager.cgi?action=setConfig&AlarmOut[0].Mode=1\");\n+                } else {\n+                    ipCameraHandler.sendHttpGET(\"/cgi-bin/configManager.cgi?action=setConfig&AlarmOut[0].Mode=0\");\n+                }\n+                return;\n+            case CHANNEL_ACTIVATE_ALARM_OUTPUT2:\n+                if (OnOffType.ON.equals(command)) {\n+                    ipCameraHandler.sendHttpGET(\"/cgi-bin/configManager.cgi?action=setConfig&AlarmOut[1].Mode=1\");\n+                } else {\n+                    ipCameraHandler.sendHttpGET(\"/cgi-bin/configManager.cgi?action=setConfig&AlarmOut[1].Mode=0\");\n+                }\n+                return;\n+            case CHANNEL_FFMPEG_MOTION_CONTROL:\n+                if (OnOffType.ON.equals(command)) {\n+                    ipCameraHandler.motionAlarmEnabled = true;\n+                } else if (OnOffType.OFF.equals(command) || DecimalType.ZERO.equals(command)) {\n+                    ipCameraHandler.motionAlarmEnabled = false;\n+                    ipCameraHandler.noMotionDetected(CHANNEL_MOTION_ALARM);\n+                } else {\n+                    ipCameraHandler.motionAlarmEnabled = true;\n+                    ipCameraHandler.motionThreshold = Double.valueOf(command.toString());\n+                    ipCameraHandler.motionThreshold = ipCameraHandler.motionThreshold / 10000;", "originalCommit": "5f018d8507afeaca6aea31fdcf0f25cabc38e136", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a54a2b42ab38d4c3155459cb96c65dfebaa436e1", "url": "https://github.com/openhab/openhab-addons/commit/a54a2b42ab38d4c3155459cb96c65dfebaa436e1", "message": "refresh onvif presets added.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-12T00:13:53Z", "type": "commit"}, {"oid": "4470db328718bf3c52efedf43be7343694188f6f", "url": "https://github.com/openhab/openhab-addons/commit/4470db328718bf3c52efedf43be7343694188f6f", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/DahuaHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: cpmeister <mistercpp2000@gmail.com>", "committedDate": "2020-09-12T00:18:05Z", "type": "commit"}, {"oid": "04040cdc54f4bba6259df1f231cab92e4f148278", "url": "https://github.com/openhab/openhab-addons/commit/04040cdc54f4bba6259df1f231cab92e4f148278", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/StreamServerGroupHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: cpmeister <mistercpp2000@gmail.com>", "committedDate": "2020-09-12T00:18:58Z", "type": "commit"}, {"oid": "e9fe4608dda30b5d511014b70b5636c5960503d8", "url": "https://github.com/openhab/openhab-addons/commit/e9fe4608dda30b5d511014b70b5636c5960503d8", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/StreamServerGroupHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: cpmeister <mistercpp2000@gmail.com>", "committedDate": "2020-09-12T00:33:37Z", "type": "commit"}, {"oid": "18dd36c0fcf22cda64c09e6fe5aa4e6699a317f0", "url": "https://github.com/openhab/openhab-addons/commit/18dd36c0fcf22cda64c09e6fe5aa4e6699a317f0", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: cpmeister <mistercpp2000@gmail.com>", "committedDate": "2020-09-12T00:37:40Z", "type": "commit"}, {"oid": "ffc6888a393f041ecc61a9b7db34c38ff46e4850", "url": "https://github.com/openhab/openhab-addons/commit/ffc6888a393f041ecc61a9b7db34c38ff46e4850", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: cpmeister <mistercpp2000@gmail.com>", "committedDate": "2020-09-12T00:40:25Z", "type": "commit"}, {"oid": "b613626ab781821a6e9cbc14b7e9dc7e03bbc0eb", "url": "https://github.com/openhab/openhab-addons/commit/b613626ab781821a6e9cbc14b7e9dc7e03bbc0eb", "message": "Make all var private.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-12T01:04:39Z", "type": "commit"}, {"oid": "b59f24ad1d1d1a087b50c5a265de480e568f38b0", "url": "https://github.com/openhab/openhab-addons/commit/b59f24ad1d1d1a087b50c5a265de480e568f38b0", "message": "All packages moved to internal.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-12T01:39:10Z", "type": "commit"}, {"oid": "d17cf914402c5775e44541d76245f3f13d275da5", "url": "https://github.com/openhab/openhab-addons/commit/d17cf914402c5775e44541d76245f3f13d275da5", "message": "const moved to internal.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-12T01:44:35Z", "type": "commit"}, {"oid": "2250dbd98e7266fe2c53760d298070a7ed4f564b", "url": "https://github.com/openhab/openhab-addons/commit/2250dbd98e7266fe2c53760d298070a7ed4f564b", "message": "Update readme.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-12T02:44:13Z", "type": "commit"}, {"oid": "3ac729e4e1fc0e6edcc1ebfaaa67103f41118c67", "url": "https://github.com/openhab/openhab-addons/commit/3ac729e4e1fc0e6edcc1ebfaaa67103f41118c67", "message": "Use enum in more classes.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-12T03:04:53Z", "type": "commit"}, {"oid": "795f8c782a8f8a3a47949505764f483837cf2c6c", "url": "https://github.com/openhab/openhab-addons/commit/795f8c782a8f8a3a47949505764f483837cf2c6c", "message": "Fix build error.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-12T03:16:14Z", "type": "commit"}, {"oid": "feefb6a73dd038b99f3d97fbc645f996c4932517", "url": "https://github.com/openhab/openhab-addons/commit/feefb6a73dd038b99f3d97fbc645f996c4932517", "message": "Rework RTSP classes.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-12T06:09:39Z", "type": "commit"}, {"oid": "cd475e5ea5bab59e16fd0ce844c1f1fc0bc61965", "url": "https://github.com/openhab/openhab-addons/commit/cd475e5ea5bab59e16fd0ce844c1f1fc0bc61965", "message": "Misc changes.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-13T02:06:20Z", "type": "commit"}, {"oid": "1d63d3334a912dbad9f09e1d8c890e9ad226fe15", "url": "https://github.com/openhab/openhab-addons/commit/1d63d3334a912dbad9f09e1d8c890e9ad226fe15", "message": "Misc changes.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-15T10:34:35Z", "type": "commit"}, {"oid": "1d002ae956b7f74cadf0f1e62c7c403c7b580583", "url": "https://github.com/openhab/openhab-addons/commit/1d002ae956b7f74cadf0f1e62c7c403c7b580583", "message": "Align config names.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-15T13:08:08Z", "type": "commit"}, {"oid": "b076017deb702fd6612973e5490e4a92e0f990ad", "url": "https://github.com/openhab/openhab-addons/commit/b076017deb702fd6612973e5490e4a92e0f990ad", "message": "groupConfig added and new inputOptions config.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-16T10:53:24Z", "type": "commit"}, {"oid": "198a837ebc6bbe4b721293a391b326d2eb4d5436", "url": "https://github.com/openhab/openhab-addons/commit/198a837ebc6bbe4b721293a391b326d2eb4d5436", "message": "Fix caps in XML.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-16T11:06:26Z", "type": "commit"}, {"oid": "3b357d5173df62018a581c4bf798705ab30c1fac", "url": "https://github.com/openhab/openhab-addons/commit/3b357d5173df62018a581c4bf798705ab30c1fac", "message": "Add info on new ffmpegInputOptions.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-16T11:19:10Z", "type": "commit"}, {"oid": "8b6c85c2e3c680bfdc9386b22e725fabea6727f6", "url": "https://github.com/openhab/openhab-addons/commit/8b6c85c2e3c680bfdc9386b22e725fabea6727f6", "message": "Merge pull request #5 from openhab/2.5.x\n\ngrab changes from addons\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-16T12:12:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgwNTg2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r489805863", "bodyText": "This would fail if the ffmpegLocation has spaces in it.", "author": "cpmeister", "createdAt": "2020-09-16T23:20:23Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/Ffmpeg.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import static org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.ffmpegFormat;\n+import org.openhab.binding.ipcamera.internal.handler.IpCameraHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Ffmpeg} class is responsible for handling multiple ffmpeg conversions which are used for many tasks\n+ *\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class Ffmpeg {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private IpCameraHandler ipCameraHandler;\n+    private @Nullable Process process = null;\n+    private String ffmpegCommand = \"\";\n+    private ffmpegFormat format;\n+    private String[] commandArray;\n+    private StreamRunning streamRunning = new StreamRunning();\n+    private int keepAlive = 8;\n+    private boolean running = false;\n+\n+    public void setKeepAlive(int seconds) {\n+        if (seconds == -1) {\n+            keepAlive = -1;\n+        } else {// We now poll every 8 seconds due to mjpeg stream requirement.\n+            keepAlive = 8; // 64 seconds approx.\n+        }\n+    }\n+\n+    public void checkKeepAlive() {\n+        if (keepAlive <= -1) {\n+            return;\n+        } else if (keepAlive == 0) {\n+            stopConverting();\n+        } else {\n+            keepAlive--;\n+        }\n+        return;\n+    }\n+\n+    public Ffmpeg(IpCameraHandler handle, ffmpegFormat format, String ffmpegLocation, String inputArguments,\n+            String input, String outArguments, String output, String username, String password) {\n+        this.format = format;\n+        ipCameraHandler = handle;\n+        String altInput = input;\n+        // Input can be snapshots not just rtsp or http\n+        if (!password.isEmpty() && !input.contains(\"@\") && input.contains(\"rtsp\")) {\n+            String credentials = username + \":\" + password + \"@\";\n+            // will not work for https: but currently binding does not use https\n+            altInput = input.substring(0, 7) + credentials + input.substring(7);\n+        }\n+        if (inputArguments.isEmpty()) {\n+            ffmpegCommand = ffmpegLocation + \" -i \" + altInput + \" \" + outArguments + \" \" + output;\n+        } else {\n+            ffmpegCommand = ffmpegLocation + \" \" + inputArguments + \" -i \" + altInput + \" \" + outArguments + \" \"\n+                    + output;\n+        }\n+        commandArray = ffmpegCommand.trim().split(\"\\\\s+\");", "originalCommit": "8b6c85c2e3c680bfdc9386b22e725fabea6727f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI2MDE0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r491260148", "bodyText": "Fixed.", "author": "Skinah", "createdAt": "2020-09-19T02:54:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgwNTg2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgwNjk5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r489806999", "bodyText": "You should handle the NumberFormatException that gets thrown here.", "author": "cpmeister", "createdAt": "2020-09-16T23:24:11Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/HttpOnlyHandler.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import static org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.*;\n+\n+import java.util.ArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.ffmpegFormat;\n+import org.openhab.binding.ipcamera.internal.handler.IpCameraHandler;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * The {@link HttpOnlyHandler} is responsible for handling commands for httponly and Onvif thingtypes.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class HttpOnlyHandler extends ChannelDuplexHandler {\n+    private IpCameraHandler ipCameraHandler;\n+\n+    public HttpOnlyHandler(IpCameraHandler handler) {\n+        ipCameraHandler = handler;\n+    }\n+\n+    // This handles the incoming http replies back from the camera.\n+    @Override\n+    public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+        ReferenceCountUtil.release(msg);\n+    }\n+\n+    // This handles the commands that come from the Openhab event bus.\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_ENABLE_AUDIO_ALARM:\n+                    return;\n+            }\n+            return; // Return as we have handled the refresh command above and don't need to\n+                    // continue further.\n+        } // end of \"REFRESH\"\n+        switch (channelUID.getId()) {\n+            case CHANNEL_THRESHOLD_AUDIO_ALARM:\n+                if (OnOffType.ON.equals(command)) {\n+                    ipCameraHandler.audioAlarmEnabled = true;\n+                } else if (OnOffType.OFF.equals(command) || DecimalType.ZERO.equals(command)) {\n+                    ipCameraHandler.audioAlarmEnabled = false;\n+                } else {\n+                    ipCameraHandler.audioAlarmEnabled = true;\n+                    ipCameraHandler.audioThreshold = Integer.valueOf(command.toString());", "originalCommit": "8b6c85c2e3c680bfdc9386b22e725fabea6727f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA4MzgxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r490083819", "bodyText": "Done. Interested to know why eclipse did not warn of this one?", "author": "Skinah", "createdAt": "2020-09-17T08:57:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgwNjk5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI2NzY0MA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r491267640", "bodyText": "NumberFormatException is a RuntimeException, and isn't required to be caught with a try-catch. But in general if you are blindly converting a string to number you should make sure to try to catch that exception.", "author": "cpmeister", "createdAt": "2020-09-19T04:29:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgwNjk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgwNzE1OA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r489807158", "bodyText": "Since you return anyway, you don't need to check the channel here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        switch (channelUID.getId()) {\n          \n          \n            \n                            case CHANNEL_ENABLE_AUDIO_ALARM:\n          \n          \n            \n                                return;\n          \n          \n            \n                        }\n          \n          \n            \n                        return; // Return as we have handled the refresh command above and don't need to\n          \n          \n            \n                        return; // Return as we have handled the refresh command above and don't need to", "author": "cpmeister", "createdAt": "2020-09-16T23:24:41Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/HttpOnlyHandler.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import static org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.*;\n+\n+import java.util.ArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.ffmpegFormat;\n+import org.openhab.binding.ipcamera.internal.handler.IpCameraHandler;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * The {@link HttpOnlyHandler} is responsible for handling commands for httponly and Onvif thingtypes.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class HttpOnlyHandler extends ChannelDuplexHandler {\n+    private IpCameraHandler ipCameraHandler;\n+\n+    public HttpOnlyHandler(IpCameraHandler handler) {\n+        ipCameraHandler = handler;\n+    }\n+\n+    // This handles the incoming http replies back from the camera.\n+    @Override\n+    public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+        ReferenceCountUtil.release(msg);\n+    }\n+\n+    // This handles the commands that come from the Openhab event bus.\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_ENABLE_AUDIO_ALARM:\n+                    return;\n+            }\n+            return; // Return as we have handled the refresh command above and don't need to", "originalCommit": "8b6c85c2e3c680bfdc9386b22e725fabea6727f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgwNzQwNg==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r489807406", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    ipCameraHandler.setChannelState(CHANNEL_TEXT_OVERLAY, StringType.valueOf(\"\"));\n          \n          \n            \n                                    ipCameraHandler.setChannelState(CHANNEL_TEXT_OVERLAY, StringType.EMPTY);", "author": "cpmeister", "createdAt": "2020-09-16T23:25:19Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/InstarHandler.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import static org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.*;\n+\n+import java.util.ArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.ffmpegFormat;\n+import org.openhab.binding.ipcamera.internal.handler.IpCameraHandler;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * The {@link InstarHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class InstarHandler extends ChannelDuplexHandler {\n+    private IpCameraHandler ipCameraHandler;\n+    private String requestUrl = \"Empty\";\n+\n+    public InstarHandler(ThingHandler thingHandler) {\n+        ipCameraHandler = (IpCameraHandler) thingHandler;\n+    }\n+\n+    public void setURL(String url) {\n+        requestUrl = url;\n+    }\n+\n+    // This handles the incoming http replies back from the camera.\n+    @Override\n+    public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+        if (msg == null || ctx == null) {\n+            return;\n+        }\n+        String content = \"\";\n+        String value1 = \"\";\n+        try {\n+            content = msg.toString();\n+            if (content.isEmpty()) {\n+                return;\n+            }\n+            switch (requestUrl) {\n+                case \"/param.cgi?cmd=getinfrared\":\n+                    if (content.contains(\"var infraredstat=\\\"auto\")) {\n+                        ipCameraHandler.setChannelState(CHANNEL_AUTO_LED, OnOffType.ON);\n+                    } else {\n+                        ipCameraHandler.setChannelState(CHANNEL_AUTO_LED, OnOffType.OFF);\n+                    }\n+                    break;\n+                case \"/param.cgi?cmd=getoverlayattr&-region=1\":// Text Overlays\n+                    if (content.contains(\"var show_1=\\\"0\\\"\")) {\n+                        ipCameraHandler.setChannelState(CHANNEL_TEXT_OVERLAY, StringType.valueOf(\"\"));", "originalCommit": "8b6c85c2e3c680bfdc9386b22e725fabea6727f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgwODY3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r489808673", "bodyText": "All classes should start with a capital letter.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static enum ffmpegFormat {\n          \n          \n            \n                public static enum FFmpegFormat {", "author": "cpmeister", "createdAt": "2020-09-16T23:29:42Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/IpCameraBindingConstants.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link IpCameraBindingConstants} class defines common constants, which\n+ * are used across the whole binding.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IpCameraBindingConstants {\n+\n+    private static final String BINDING_ID = \"ipcamera\";\n+    public final static String AUTH_HANDLER = \"authorizationHandler\";\n+    public final static String AMCREST_HANDLER = \"amcrestHandler\";\n+    public final static String COMMON_HANDLER = \"commonHandler\";\n+    public final static String INSTAR_HANDLER = \"instarHandler\";\n+\n+    public static enum ffmpegFormat {", "originalCommit": "8b6c85c2e3c680bfdc9386b22e725fabea6727f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxMTQ5NA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r489811494", "bodyText": "You should avoid calling Thread.sleep on threads you aren't managing. In particular, this method might be getting called by the event dispatch thread used by the UI. Causing this to sleep would cause the UI to become unresponsive.\nAny long running task should be executed asynchronously from event threads.", "author": "cpmeister", "createdAt": "2020-09-16T23:38:36Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/Ffmpeg.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import static org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.ffmpegFormat;\n+import org.openhab.binding.ipcamera.internal.handler.IpCameraHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Ffmpeg} class is responsible for handling multiple ffmpeg conversions which are used for many tasks\n+ *\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class Ffmpeg {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private IpCameraHandler ipCameraHandler;\n+    private @Nullable Process process = null;\n+    private String ffmpegCommand = \"\";\n+    private ffmpegFormat format;\n+    private String[] commandArray;\n+    private StreamRunning streamRunning = new StreamRunning();\n+    private int keepAlive = 8;\n+    private boolean running = false;\n+\n+    public void setKeepAlive(int seconds) {\n+        if (seconds == -1) {\n+            keepAlive = -1;\n+        } else {// We now poll every 8 seconds due to mjpeg stream requirement.\n+            keepAlive = 8; // 64 seconds approx.\n+        }\n+    }\n+\n+    public void checkKeepAlive() {\n+        if (keepAlive <= -1) {\n+            return;\n+        } else if (keepAlive == 0) {\n+            stopConverting();\n+        } else {\n+            keepAlive--;\n+        }\n+        return;\n+    }\n+\n+    public Ffmpeg(IpCameraHandler handle, ffmpegFormat format, String ffmpegLocation, String inputArguments,\n+            String input, String outArguments, String output, String username, String password) {\n+        this.format = format;\n+        ipCameraHandler = handle;\n+        String altInput = input;\n+        // Input can be snapshots not just rtsp or http\n+        if (!password.isEmpty() && !input.contains(\"@\") && input.contains(\"rtsp\")) {\n+            String credentials = username + \":\" + password + \"@\";\n+            // will not work for https: but currently binding does not use https\n+            altInput = input.substring(0, 7) + credentials + input.substring(7);\n+        }\n+        if (inputArguments.isEmpty()) {\n+            ffmpegCommand = ffmpegLocation + \" -i \" + altInput + \" \" + outArguments + \" \" + output;\n+        } else {\n+            ffmpegCommand = ffmpegLocation + \" \" + inputArguments + \" -i \" + altInput + \" \" + outArguments + \" \"\n+                    + output;\n+        }\n+        commandArray = ffmpegCommand.trim().split(\"\\\\s+\");\n+    }\n+\n+    private class StreamRunning extends Thread {\n+        public int countOfMotions = 0;\n+\n+        @Override\n+        public void run() {\n+            try {\n+                process = Runtime.getRuntime().exec(commandArray);\n+                if (process != null) {\n+                    InputStream errorStream = process.getErrorStream();\n+                    InputStreamReader errorStreamReader = new InputStreamReader(errorStream);\n+                    BufferedReader bufferedReader = new BufferedReader(errorStreamReader);\n+                    String line = null;\n+                    while ((line = bufferedReader.readLine()) != null) {\n+                        if (format.equals(ffmpegFormat.RTSPHELPER)) {\n+                            logger.debug(\"{}\", line);\n+                            if (line.contains(\"lavfi.\")) {\n+                                if (countOfMotions == 4) {\n+                                    ipCameraHandler.motionDetected(CHANNEL_FFMPEG_MOTION_ALARM);\n+                                } else {\n+                                    countOfMotions++;\n+                                }\n+                            } else if (line.contains(\"speed=\")) {\n+                                if (countOfMotions > 0) {\n+                                    countOfMotions--;\n+                                    countOfMotions--;\n+                                    if (countOfMotions <= 0) {\n+                                        ipCameraHandler.noMotionDetected(CHANNEL_FFMPEG_MOTION_ALARM);\n+                                    }\n+                                }\n+                            } else if (line.contains(\"silence_start\")) {\n+                                ipCameraHandler.noAudioDetected();\n+                            } else if (line.contains(\"silence_end\")) {\n+                                ipCameraHandler.audioDetected();\n+                            }\n+                        } else {\n+                            logger.debug(\"{}\", line);\n+                        }\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"An error occured trying to process the messages from FFmpeg.\");\n+            } finally {\n+                switch (format) {\n+                    case GIF:\n+                        try {\n+                            // Without a small delay, Pushover sends no file 10% of time.\n+                            Thread.sleep(800);\n+                        } catch (InterruptedException e) {\n+                        }\n+                        logger.debug(\"Animated GIF has been created and is ready for use.\");\n+                        ipCameraHandler.setChannelState(CHANNEL_UPDATE_GIF, OnOffType.OFF);\n+                        ipCameraHandler.setChannelState(CHANNEL_GIF_HISTORY_LENGTH,\n+                                new DecimalType(++ipCameraHandler.gifHistoryLength));\n+                        break;\n+                    case RECORD:\n+                        try {\n+                            Thread.sleep(800);\n+                        } catch (InterruptedException e) {\n+                        }\n+                        logger.debug(\"MP4 has been created and is ready for use.\");\n+                        ipCameraHandler.setChannelState(CHANNEL_RECORD_MP4, DecimalType.ZERO);\n+                        ipCameraHandler.setChannelState(CHANNEL_MP4_HISTORY_LENGTH,\n+                                new DecimalType(++ipCameraHandler.mp4HistoryLength));\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    public void startConverting() {\n+        if (!streamRunning.isAlive()) {\n+            streamRunning = new StreamRunning();\n+            logger.debug(\"Starting ffmpeg with this command now:{}\", ffmpegCommand);\n+            streamRunning.start();\n+            running = true;\n+            if (format.equals(ffmpegFormat.HLS)) {\n+                ipCameraHandler.setChannelState(CHANNEL_START_STREAM, OnOffType.ON);\n+                if (keepAlive > -1) {\n+                    try {\n+                        Thread.sleep(4500); // Used for on demand HLS to give ffmpeg time to produce the files needed.", "originalCommit": "8b6c85c2e3c680bfdc9386b22e725fabea6727f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE3ODM1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r490178353", "bodyText": "Thanks for the info, helps me learn the why and what to be careful of in future. I have made a change and it would be good to see if this newer method is correct.", "author": "Skinah", "createdAt": "2020-09-17T11:44:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxMTQ5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxMjQ1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r489812459", "bodyText": "Same issue here.\nBut in addition, you should also properly handle any InterruptedException that occurs.\nSuch an exception usually indicates that the current thread should stop whatever activity it is doing and return as quickly as possible since interrupts are usually used as part of application shutdown.", "author": "cpmeister", "createdAt": "2020-09-16T23:41:37Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/Ffmpeg.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import static org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.ffmpegFormat;\n+import org.openhab.binding.ipcamera.internal.handler.IpCameraHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Ffmpeg} class is responsible for handling multiple ffmpeg conversions which are used for many tasks\n+ *\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class Ffmpeg {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private IpCameraHandler ipCameraHandler;\n+    private @Nullable Process process = null;\n+    private String ffmpegCommand = \"\";\n+    private ffmpegFormat format;\n+    private String[] commandArray;\n+    private StreamRunning streamRunning = new StreamRunning();\n+    private int keepAlive = 8;\n+    private boolean running = false;\n+\n+    public void setKeepAlive(int seconds) {\n+        if (seconds == -1) {\n+            keepAlive = -1;\n+        } else {// We now poll every 8 seconds due to mjpeg stream requirement.\n+            keepAlive = 8; // 64 seconds approx.\n+        }\n+    }\n+\n+    public void checkKeepAlive() {\n+        if (keepAlive <= -1) {\n+            return;\n+        } else if (keepAlive == 0) {\n+            stopConverting();\n+        } else {\n+            keepAlive--;\n+        }\n+        return;\n+    }\n+\n+    public Ffmpeg(IpCameraHandler handle, ffmpegFormat format, String ffmpegLocation, String inputArguments,\n+            String input, String outArguments, String output, String username, String password) {\n+        this.format = format;\n+        ipCameraHandler = handle;\n+        String altInput = input;\n+        // Input can be snapshots not just rtsp or http\n+        if (!password.isEmpty() && !input.contains(\"@\") && input.contains(\"rtsp\")) {\n+            String credentials = username + \":\" + password + \"@\";\n+            // will not work for https: but currently binding does not use https\n+            altInput = input.substring(0, 7) + credentials + input.substring(7);\n+        }\n+        if (inputArguments.isEmpty()) {\n+            ffmpegCommand = ffmpegLocation + \" -i \" + altInput + \" \" + outArguments + \" \" + output;\n+        } else {\n+            ffmpegCommand = ffmpegLocation + \" \" + inputArguments + \" -i \" + altInput + \" \" + outArguments + \" \"\n+                    + output;\n+        }\n+        commandArray = ffmpegCommand.trim().split(\"\\\\s+\");\n+    }\n+\n+    private class StreamRunning extends Thread {\n+        public int countOfMotions = 0;\n+\n+        @Override\n+        public void run() {\n+            try {\n+                process = Runtime.getRuntime().exec(commandArray);\n+                if (process != null) {\n+                    InputStream errorStream = process.getErrorStream();\n+                    InputStreamReader errorStreamReader = new InputStreamReader(errorStream);\n+                    BufferedReader bufferedReader = new BufferedReader(errorStreamReader);\n+                    String line = null;\n+                    while ((line = bufferedReader.readLine()) != null) {\n+                        if (format.equals(ffmpegFormat.RTSPHELPER)) {\n+                            logger.debug(\"{}\", line);\n+                            if (line.contains(\"lavfi.\")) {\n+                                if (countOfMotions == 4) {\n+                                    ipCameraHandler.motionDetected(CHANNEL_FFMPEG_MOTION_ALARM);\n+                                } else {\n+                                    countOfMotions++;\n+                                }\n+                            } else if (line.contains(\"speed=\")) {\n+                                if (countOfMotions > 0) {\n+                                    countOfMotions--;\n+                                    countOfMotions--;\n+                                    if (countOfMotions <= 0) {\n+                                        ipCameraHandler.noMotionDetected(CHANNEL_FFMPEG_MOTION_ALARM);\n+                                    }\n+                                }\n+                            } else if (line.contains(\"silence_start\")) {\n+                                ipCameraHandler.noAudioDetected();\n+                            } else if (line.contains(\"silence_end\")) {\n+                                ipCameraHandler.audioDetected();\n+                            }\n+                        } else {\n+                            logger.debug(\"{}\", line);\n+                        }\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"An error occured trying to process the messages from FFmpeg.\");\n+            } finally {\n+                switch (format) {\n+                    case GIF:\n+                        try {\n+                            // Without a small delay, Pushover sends no file 10% of time.\n+                            Thread.sleep(800);\n+                        } catch (InterruptedException e) {\n+                        }", "originalCommit": "8b6c85c2e3c680bfdc9386b22e725fabea6727f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE4MjYyNw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r490182627", "bodyText": "Noted and Fixed as above.", "author": "Skinah", "createdAt": "2020-09-17T11:51:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxMjQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxMjUyMA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r489812520", "bodyText": "same issue here.", "author": "cpmeister", "createdAt": "2020-09-16T23:41:49Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/Ffmpeg.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import static org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.ffmpegFormat;\n+import org.openhab.binding.ipcamera.internal.handler.IpCameraHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Ffmpeg} class is responsible for handling multiple ffmpeg conversions which are used for many tasks\n+ *\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class Ffmpeg {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private IpCameraHandler ipCameraHandler;\n+    private @Nullable Process process = null;\n+    private String ffmpegCommand = \"\";\n+    private ffmpegFormat format;\n+    private String[] commandArray;\n+    private StreamRunning streamRunning = new StreamRunning();\n+    private int keepAlive = 8;\n+    private boolean running = false;\n+\n+    public void setKeepAlive(int seconds) {\n+        if (seconds == -1) {\n+            keepAlive = -1;\n+        } else {// We now poll every 8 seconds due to mjpeg stream requirement.\n+            keepAlive = 8; // 64 seconds approx.\n+        }\n+    }\n+\n+    public void checkKeepAlive() {\n+        if (keepAlive <= -1) {\n+            return;\n+        } else if (keepAlive == 0) {\n+            stopConverting();\n+        } else {\n+            keepAlive--;\n+        }\n+        return;\n+    }\n+\n+    public Ffmpeg(IpCameraHandler handle, ffmpegFormat format, String ffmpegLocation, String inputArguments,\n+            String input, String outArguments, String output, String username, String password) {\n+        this.format = format;\n+        ipCameraHandler = handle;\n+        String altInput = input;\n+        // Input can be snapshots not just rtsp or http\n+        if (!password.isEmpty() && !input.contains(\"@\") && input.contains(\"rtsp\")) {\n+            String credentials = username + \":\" + password + \"@\";\n+            // will not work for https: but currently binding does not use https\n+            altInput = input.substring(0, 7) + credentials + input.substring(7);\n+        }\n+        if (inputArguments.isEmpty()) {\n+            ffmpegCommand = ffmpegLocation + \" -i \" + altInput + \" \" + outArguments + \" \" + output;\n+        } else {\n+            ffmpegCommand = ffmpegLocation + \" \" + inputArguments + \" -i \" + altInput + \" \" + outArguments + \" \"\n+                    + output;\n+        }\n+        commandArray = ffmpegCommand.trim().split(\"\\\\s+\");\n+    }\n+\n+    private class StreamRunning extends Thread {\n+        public int countOfMotions = 0;\n+\n+        @Override\n+        public void run() {\n+            try {\n+                process = Runtime.getRuntime().exec(commandArray);\n+                if (process != null) {\n+                    InputStream errorStream = process.getErrorStream();\n+                    InputStreamReader errorStreamReader = new InputStreamReader(errorStream);\n+                    BufferedReader bufferedReader = new BufferedReader(errorStreamReader);\n+                    String line = null;\n+                    while ((line = bufferedReader.readLine()) != null) {\n+                        if (format.equals(ffmpegFormat.RTSPHELPER)) {\n+                            logger.debug(\"{}\", line);\n+                            if (line.contains(\"lavfi.\")) {\n+                                if (countOfMotions == 4) {\n+                                    ipCameraHandler.motionDetected(CHANNEL_FFMPEG_MOTION_ALARM);\n+                                } else {\n+                                    countOfMotions++;\n+                                }\n+                            } else if (line.contains(\"speed=\")) {\n+                                if (countOfMotions > 0) {\n+                                    countOfMotions--;\n+                                    countOfMotions--;\n+                                    if (countOfMotions <= 0) {\n+                                        ipCameraHandler.noMotionDetected(CHANNEL_FFMPEG_MOTION_ALARM);\n+                                    }\n+                                }\n+                            } else if (line.contains(\"silence_start\")) {\n+                                ipCameraHandler.noAudioDetected();\n+                            } else if (line.contains(\"silence_end\")) {\n+                                ipCameraHandler.audioDetected();\n+                            }\n+                        } else {\n+                            logger.debug(\"{}\", line);\n+                        }\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"An error occured trying to process the messages from FFmpeg.\");\n+            } finally {\n+                switch (format) {\n+                    case GIF:\n+                        try {\n+                            // Without a small delay, Pushover sends no file 10% of time.\n+                            Thread.sleep(800);\n+                        } catch (InterruptedException e) {\n+                        }\n+                        logger.debug(\"Animated GIF has been created and is ready for use.\");\n+                        ipCameraHandler.setChannelState(CHANNEL_UPDATE_GIF, OnOffType.OFF);\n+                        ipCameraHandler.setChannelState(CHANNEL_GIF_HISTORY_LENGTH,\n+                                new DecimalType(++ipCameraHandler.gifHistoryLength));\n+                        break;\n+                    case RECORD:\n+                        try {\n+                            Thread.sleep(800);\n+                        } catch (InterruptedException e) {\n+                        }", "originalCommit": "8b6c85c2e3c680bfdc9386b22e725fabea6727f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE4Mjg2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r490182867", "bodyText": "Fixed as above.", "author": "Skinah", "createdAt": "2020-09-17T11:51:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxMjUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxMjk3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r489812979", "bodyText": "New thread instances should be given reasonable names so that they can be identified during debugging as belonging to this binding. Also, make sure to make the thread daemon.", "author": "cpmeister", "createdAt": "2020-09-16T23:43:30Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/Ffmpeg.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import static org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.ffmpegFormat;\n+import org.openhab.binding.ipcamera.internal.handler.IpCameraHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link Ffmpeg} class is responsible for handling multiple ffmpeg conversions which are used for many tasks\n+ *\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class Ffmpeg {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private IpCameraHandler ipCameraHandler;\n+    private @Nullable Process process = null;\n+    private String ffmpegCommand = \"\";\n+    private ffmpegFormat format;\n+    private String[] commandArray;\n+    private StreamRunning streamRunning = new StreamRunning();\n+    private int keepAlive = 8;\n+    private boolean running = false;\n+\n+    public void setKeepAlive(int seconds) {\n+        if (seconds == -1) {\n+            keepAlive = -1;\n+        } else {// We now poll every 8 seconds due to mjpeg stream requirement.\n+            keepAlive = 8; // 64 seconds approx.\n+        }\n+    }\n+\n+    public void checkKeepAlive() {\n+        if (keepAlive <= -1) {\n+            return;\n+        } else if (keepAlive == 0) {\n+            stopConverting();\n+        } else {\n+            keepAlive--;\n+        }\n+        return;\n+    }\n+\n+    public Ffmpeg(IpCameraHandler handle, ffmpegFormat format, String ffmpegLocation, String inputArguments,\n+            String input, String outArguments, String output, String username, String password) {\n+        this.format = format;\n+        ipCameraHandler = handle;\n+        String altInput = input;\n+        // Input can be snapshots not just rtsp or http\n+        if (!password.isEmpty() && !input.contains(\"@\") && input.contains(\"rtsp\")) {\n+            String credentials = username + \":\" + password + \"@\";\n+            // will not work for https: but currently binding does not use https\n+            altInput = input.substring(0, 7) + credentials + input.substring(7);\n+        }\n+        if (inputArguments.isEmpty()) {\n+            ffmpegCommand = ffmpegLocation + \" -i \" + altInput + \" \" + outArguments + \" \" + output;\n+        } else {\n+            ffmpegCommand = ffmpegLocation + \" \" + inputArguments + \" -i \" + altInput + \" \" + outArguments + \" \"\n+                    + output;\n+        }\n+        commandArray = ffmpegCommand.trim().split(\"\\\\s+\");\n+    }\n+\n+    private class StreamRunning extends Thread {", "originalCommit": "8b6c85c2e3c680bfdc9386b22e725fabea6727f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE4MzI3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r490183273", "bodyText": "Done, new name and daemon is true.", "author": "Skinah", "createdAt": "2020-09-17T11:52:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxMjk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxNDAwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r489814009", "bodyText": "You seem to be doing a lot of looping through a list to find a particular channel, why not use a Map<String, ChannelTracking>  where the keys are the requestUrl? This would make lookups a lot faster and simplify the code.", "author": "cpmeister", "createdAt": "2020-09-16T23:47:04Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,1795 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal.handler;\n+\n+import static org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.CameraConfig;\n+import org.openhab.binding.ipcamera.internal.ChannelTracking;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.GroupTracker;\n+import org.openhab.binding.ipcamera.internal.Helper;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.ffmpegFormat;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.internal.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(4);\n+    private GroupTracker groupTracker;\n+    public CameraConfig cameraConfig;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    private final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    private final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public final ChannelGroup openChannels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    public boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private int nvrChannel;\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    private int mp4RecordTime = 0;\n+    private int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp;\n+    private String ffmpegOutputFolder = \"\";\n+    public ReentrantLock lock = new ReentrantLock();\n+    public List<ChannelTracking> channelTracker = new ArrayList<>(18);\n+    public List<String> lowPriorityRequests = new ArrayList<>(0);\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useBasicAuth = false;\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageWhen = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    private boolean motionAlarmUpdateSnapshot = false;\n+    private boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    private boolean firstAudioAlarm = false;\n+    private boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    private boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    // These methods handle the response from all camera brands, nothing specific to 1 brand.\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                processSnapshot(incomingJpeg);\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    ctx.close();\n+                                } else {\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.isEmpty()) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause instanceof ArrayIndexOutOfBoundsException) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        String urlToKeepOpen = \"\";\n+                        switch (thing.getThingTypeUID().getId()) {\n+                            case DAHUA_THING:\n+                                urlToKeepOpen = \"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\";\n+                                break;\n+                            case HIKVISION_THING:\n+                                urlToKeepOpen = \"/ISAPI/Event/notification/alertStream\";\n+                                break;\n+                            case DOORBIRD_THING:\n+                                urlToKeepOpen = \"/bha-api/monitor.cgi?ring=doorbell,motionsensor\";\n+                                break;\n+                        }\n+\n+                        for (ChannelTracking channelTracking : channelTracker) {\n+                            if (channelTracking.getChannel().equals(ctx.channel())) {\n+                                if (channelTracking.getRequestUrl().equals(urlToKeepOpen)) {\n+                                    return; // don't auto close this as it is for the alarms.\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public IpCameraHandler(Thing thing, @Nullable String openhabIpAddress, GroupTracker groupTracker) {\n+        super(thing);\n+        cameraConfig = getConfigAs(CameraConfig.class);\n+        if (openhabIpAddress != null) {\n+            hostIp = openhabIpAddress;\n+        } else {\n+            hostIp = Helper.getLocalIpAddress();\n+        }\n+        this.groupTracker = groupTracker;\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.isEmpty()) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.isEmpty() && !password.isEmpty()) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        if (longUrl.isEmpty() || longUrl.equals(\"ffmpeg\")) {\n+            return longUrl;\n+        }\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+        }\n+        return temp;\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return cameraConfig.getPort();\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null)//\n+    // The authHandler will generate a digest string and re-send using this same function when needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(AUTH_HANDLER,\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(COMMON_HANDLER, new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case AMCREST_THING:\n+                            socketChannel.pipeline().addLast(AMCREST_HANDLER, new AmcrestHandler(getHandle()));\n+                            break;\n+                        case DAHUA_THING:\n+                            socketChannel.pipeline().addLast(new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case DOORBIRD_THING:\n+                            socketChannel.pipeline().addLast(new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case FOSCAM_THING:\n+                            socketChannel.pipeline().addLast(new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case HIKVISION_THING:\n+                            socketChannel.pipeline().addLast(new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case INSTAR_THING:\n+                            socketChannel.pipeline().addLast(INSTAR_HANDLER, new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (!\"PUT\".equals(httpMethod) || (useDigestAuth && digestString == null)) {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        } else {\n+            request = putRequestWithBody;\n+        }\n+\n+        if (!basicAuth.isEmpty()) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    Channel ch = future.channel();\n+                    boolean chTracked = false;\n+                    openChannels.add(ch);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    try {\n+                        for (ChannelTracking channelTracking : channelTracker) {\n+                            if (channelTracking.getRequestUrl().equals(httpRequestURL)) {\n+                                channelTracking.setChannel(ch);\n+                                chTracked = true;\n+                                break;\n+                            }\n+                        }\n+                        if (!chTracked) {\n+                            channelTracker.add(new ChannelTracking(ch, httpRequestURL));\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(COMMON_HANDLER);\n+                    commonHandler.setURL(httpRequestURLFull);\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(AUTH_HANDLER);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case AMCREST_THING:\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(AMCREST_HANDLER);\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case INSTAR_THING:\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(INSTAR_HANDLER);\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+                    ch.writeAndFlush(request);\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot(byte[] incommingSnapshot) {\n+        lockCurrentSnapshot.lock();\n+        try {\n+            currentSnapshot = incommingSnapshot;\n+            if (preroll > 0) {\n+                fifoSnapshotBuffer.add(incommingSnapshot);\n+                if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                    fifoSnapshotBuffer.removeFirst();\n+                }\n+            }\n+        } finally {\n+            lockCurrentSnapshot.unlock();\n+        }\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(incommingSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(incommingSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                // only happens every 8 seconds as some browsers need a frame that often to keep stream alive.\n+                sendMjpegFrame(incommingSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 60, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.debug(\"File server for camera at {} has started on port {} for all NIC's.\", ipAddress,\n+                            serverPort);\n+                    updateState(CHANNEL_MJPEG_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    cameraConfigError(\"Exception when starting server. Try changing the serverPort to another number.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setupSnapshotStreaming(boolean stream, ChannelHandlerContext ctx, boolean auto) {\n+        if (stream) {\n+            sendMjpegFirstPacket(ctx);\n+            if (auto) {\n+                autoSnapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                try {\n+                    sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                    // iOS uses a FIFO? and needs two frames to display a pic\n+                    sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                } finally {\n+                    lockCurrentSnapshot.unlock();\n+                }\n+                streamingAutoFps = true;\n+            } else {\n+                snapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                try {\n+                    sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+                } finally {\n+                    lockCurrentSnapshot.unlock();\n+                }\n+                streamingSnapshotMjpeg = true;\n+                startSnapshotPolling();\n+            }\n+        } else {\n+            snapshotMjpegChannelGroup.remove(ctx.channel());\n+            autoSnapshotMjpegChannelGroup.remove(ctx.channel());\n+            if (streamingSnapshotMjpeg && snapshotMjpegChannelGroup.isEmpty()) {\n+                streamingSnapshotMjpeg = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All snapshots.mjpeg streams have stopped.\");\n+            } else if (streamingAutoFps && autoSnapshotMjpegChannelGroup.isEmpty()) {\n+                streamingAutoFps = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All autofps.mjpeg streams have stopped.\");\n+            }\n+        }\n+    }\n+\n+    // If start is true the CTX is added to the list to stream video to, false stops\n+    // the stream.\n+    public void setupMjpegStreaming(boolean start, ChannelHandlerContext ctx) {\n+        if (start) {\n+            if (mjpegChannelGroup.isEmpty()) {// first stream being requested.\n+                mjpegChannelGroup.add(ctx.channel());\n+                if (mjpegUri.isEmpty() || mjpegUri.equals(\"ffmpeg\")) {\n+                    sendMjpegFirstPacket(ctx);\n+                    setupFfmpegFormat(ffmpegFormat.MJPEG);\n+                } else {\n+                    try {\n+                        // fix Dahua reboots when refreshing a mjpeg stream.\n+                        TimeUnit.MILLISECONDS.sleep(500);\n+                    } catch (InterruptedException e) {\n+                    }\n+                    sendHttpGET(mjpegUri);\n+                }\n+            } else if (ffmpegMjpeg != null) {// not first stream and we will use ffmpeg\n+                sendMjpegFirstPacket(ctx);\n+                mjpegChannelGroup.add(ctx.channel());\n+            } else {// not first stream and camera supplies the mjpeg source.\n+                ctx.channel().writeAndFlush(firstStreamedMsg);\n+                mjpegChannelGroup.add(ctx.channel());\n+            }\n+        } else {\n+            mjpegChannelGroup.remove(ctx.channel());\n+            if (mjpegChannelGroup.isEmpty()) {\n+                logger.debug(\"All ipcamera.mjpeg streams have stopped.\");\n+                if (mjpegUri.equals(\"ffmpeg\")) {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                } else if (!mjpegUri.isEmpty()) {\n+                    closeChannel(getTinyUrl(mjpegUri));\n+                } else {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (ChannelTracking channelTracking : channelTracker) {\n+                if (channelTracking.getRequestUrl().equals(url)) {\n+                    if (channelTracking.getChannel().isOpen()) {\n+                        channelTracking.getChannel().close();\n+                        return;\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    void cleanChannels() {\n+        ChannelTracking localTracking = null;\n+        lock.lock();\n+        try {\n+            for (ChannelTracking channelTracking : channelTracker) {\n+                logger.trace(\"Channel is open:{}, url is {}\", channelTracking.getChannel().isOpen(),\n+                        channelTracking.getRequestUrl());\n+                if (!channelTracking.getChannel().isOpen() && channelTracking.getReply().isEmpty()) {\n+                    localTracking = channelTracking;// Seems to create a deadlock if we remove whilst in loop\n+                    break;\n+                }\n+            }\n+            if (localTracking != null) {\n+                channelTracker.remove(localTracking);// clean up one closed channel.\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void storeHttpReply(String url, String content) {\n+        lock.lock();\n+        try {\n+            for (ChannelTracking channelTracking : channelTracker) {\n+                if (channelTracking.getRequestUrl().equals(url)) {\n+                    channelTracking.setReply(content);\n+                    return;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    // sends direct to ctx so can be either snapshots.mjpeg or normal mjpeg stream\n+    public void sendMjpegFirstPacket(ChannelHandlerContext ctx) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        String contentType = \"multipart/x-mixed-replace; boundary=\" + BOUNDARY;\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+        ctx.channel().writeAndFlush(response);\n+    }\n+\n+    public void sendMjpegFrame(byte[] jpg, ChannelGroup channelGroup) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        ByteBuf imageByteBuf = Unpooled.copiedBuffer(jpg);\n+        int length = imageByteBuf.readableBytes();\n+        String header = \"--\" + BOUNDARY + \"\\r\\n\" + \"content-type: image/jpeg\" + \"\\r\\n\" + \"content-length: \" + length\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuf headerBbuf = Unpooled.copiedBuffer(header, 0, header.length(), StandardCharsets.UTF_8);\n+        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+        streamToGroup(headerBbuf, channelGroup, false);\n+        streamToGroup(imageByteBuf, channelGroup, false);\n+        streamToGroup(footerBbuf, channelGroup, true);\n+    }\n+\n+    public void streamToGroup(Object msg, ChannelGroup channelGroup, boolean flush) {\n+        channelGroup.write(msg);\n+        if (flush) {\n+            channelGroup.flush();\n+        }\n+    }\n+\n+    private void storeSnapshots() {\n+        int count = 0;\n+        // Need to lock as fifoSnapshotBuffer is not thread safe and new snapshots can be incoming.\n+        lockCurrentSnapshot.lock();\n+        try {\n+            for (byte[] foo : fifoSnapshotBuffer) {\n+                File file = new File(ffmpegOutputFolder + \"snapshot\" + count + \".jpg\");\n+                count++;\n+                try {\n+                    OutputStream fos = new FileOutputStream(file);\n+                    fos.write(foo);\n+                    fos.close();\n+                } catch (FileNotFoundException e) {\n+                    logger.warn(\"FileNotFoundException {}\", e.getMessage());\n+                } catch (IOException e) {\n+                    logger.warn(\"IOException {}\", e.getMessage());\n+                }\n+            }\n+        } finally {\n+            lockCurrentSnapshot.unlock();\n+        }\n+    }\n+\n+    public void setupFfmpegFormat(ffmpegFormat format) {\n+        String inputOptions = cameraConfig.getFfmpegInputOptions();\n+        if (cameraConfig.getFfmpegOutput().isEmpty()) {\n+            logger.warn(\"The camera tried to use a FFmpeg feature when the output folder is not set.\");\n+            return;\n+        }\n+        if (rtspUri.isEmpty()) {\n+            logger.warn(\"The camera tried to use a FFmpeg feature when no valid input for FFmpeg is provided.\");\n+            return;\n+        }\n+        if (cameraConfig.getFfmpegLocation().isEmpty()) {\n+            logger.warn(\"The camera tried to use a FFmpeg feature when the location for FFmpeg is not known.\");\n+            return;\n+        }\n+        if (rtspUri.toLowerCase().contains(\"rtsp\")) {\n+            if (inputOptions.isEmpty()) {\n+                inputOptions = \"-rtsp_transport tcp\";\n+            } else {\n+                inputOptions = inputOptions + \" -rtsp_transport tcp\";\n+            }\n+        }\n+\n+        // Make sure the folder exists, if not create it.\n+        new File(ffmpegOutputFolder).mkdirs();\n+        switch (format) {\n+            case HLS:\n+                if (ffmpegHLS == null) {\n+                    if (!inputOptions.isEmpty()) {\n+                        ffmpegHLS = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(),\n+                                \"-hide_banner -loglevel warning \" + inputOptions, rtspUri,\n+                                cameraConfig.getHlsOutOptions(), ffmpegOutputFolder + \"ipcamera.m3u8\", username,\n+                                password);\n+                    } else {\n+                        ffmpegHLS = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(),\n+                                \"-hide_banner -loglevel warning\", rtspUri, cameraConfig.getHlsOutOptions(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    }\n+                }\n+                if (ffmpegHLS != null) {\n+                    ffmpegHLS.startConverting();\n+                }\n+                break;\n+            case GIF:\n+                if (preroll > 0) {\n+                    ffmpegGIF = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(),\n+                            \"-y -r 1 -hide_banner -loglevel warning\", ffmpegOutputFolder + \"snapshot%d.jpg\",\n+                            \"-frames:v \" + (preroll + postroll) + \" \" + cameraConfig.getGifOutOptions(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                } else {\n+                    if (!inputOptions.isEmpty()) {\n+                        inputOptions = \"-y -t \" + postroll + \" -hide_banner -loglevel warning \" + inputOptions;\n+                    } else {\n+                        inputOptions = \"-y -t \" + postroll + \" -hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegGIF = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(), inputOptions, rtspUri,\n+                            cameraConfig.getGifOutOptions(), ffmpegOutputFolder + gifFilename + \".gif\", username,\n+                            password);\n+                }\n+                if (preroll > 0) {\n+                    storeSnapshots();\n+                }\n+                if (ffmpegGIF != null) {\n+                    ffmpegGIF.startConverting();\n+                    if (gifHistory.isEmpty()) {\n+                        gifHistory = gifFilename;\n+                    } else if (!gifFilename.equals(\"ipcamera\")) {\n+                        gifHistory = gifFilename + \",\" + gifHistory;\n+                        if (gifHistoryLength > 49) {\n+                            int endIndex = gifHistory.lastIndexOf(\",\");\n+                            gifHistory = gifHistory.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_GIF_HISTORY, new StringType(gifHistory));\n+                }\n+                break;\n+            case RECORD:\n+                if (!inputOptions.isEmpty()) {\n+                    inputOptions = \"-y -t \" + mp4RecordTime + \" -hide_banner -loglevel warning \" + inputOptions;\n+                } else {\n+                    inputOptions = \"-y -t \" + mp4RecordTime + \" -hide_banner -loglevel warning\";\n+                }\n+                ffmpegRecord = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(), inputOptions, rtspUri,\n+                        cameraConfig.getMp4OutOptions(), ffmpegOutputFolder + mp4Filename + \".mp4\", username, password);\n+                if (mp4Preroll > 0) {\n+                    // fetchFromHLS(); todo: not done yet\n+                }\n+                if (ffmpegRecord != null) {\n+                    ffmpegRecord.startConverting();\n+                    if (mp4History.isEmpty()) {\n+                        mp4History = mp4Filename;\n+                    } else if (!mp4Filename.equals(\"ipcamera\")) {\n+                        mp4History = mp4Filename + \",\" + mp4History;\n+                        if (mp4HistoryLength > 49) {\n+                            int endIndex = mp4History.lastIndexOf(\",\");\n+                            mp4History = mp4History.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_MP4_HISTORY, new StringType(mp4History));\n+                }\n+                break;\n+            case RTSPHELPER:\n+                if (ffmpegRtspHelper != null) {\n+                    ffmpegRtspHelper.stopConverting();\n+                    if (!audioAlarmEnabled && !motionAlarmEnabled) {\n+                        return;\n+                    }\n+                }\n+                String input = (cameraConfig.getAlarmInputUrl().isEmpty()) ? rtspUri : cameraConfig.getAlarmInputUrl();\n+                String OutputOptions = \"-f null -\";\n+                String filterOptions = \"\";\n+                if (!audioAlarmEnabled) {\n+                    filterOptions = \"-an\";\n+                } else {\n+                    filterOptions = \"-af silencedetect=n=-\" + audioThreshold + \"dB:d=2\";\n+                }\n+                if (!motionAlarmEnabled && !ffmpegSnapshotGeneration) {\n+                    filterOptions = filterOptions.concat(\" -vn\");\n+                } else if (motionAlarmEnabled == true) {\n+                    filterOptions = filterOptions\n+                            .concat(\" -vf select='gte(scene,\" + motionThreshold + \")',metadata=print\");\n+                }\n+                if (!cameraConfig.getUser().isEmpty()) {\n+                    filterOptions += \" \";// add space as the Framework does not allow spaces at start of config.\n+                }\n+                ffmpegRtspHelper = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(), inputOptions, input,\n+                        filterOptions + cameraConfig.getMotionOptions(), OutputOptions, username, password);\n+                ffmpegRtspHelper.startConverting();\n+                break;\n+            case MJPEG:\n+                if (ffmpegMjpeg == null) {\n+                    if (inputOptions.isEmpty()) {\n+                        inputOptions = \"-hide_banner -loglevel warning\";\n+                    } else {\n+                        inputOptions = inputOptions + \" -hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegMjpeg = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(), inputOptions, rtspUri,\n+                            cameraConfig.getMjpegOptions(), \"http://127.0.0.1:\" + serverPort + \"/ipcamera.jpg\",\n+                            username, password);\n+                }\n+                if (ffmpegMjpeg != null) {\n+                    ffmpegMjpeg.startConverting();\n+                }\n+                break;\n+            case SNAPSHOT:\n+                // if mjpeg stream you can use ffmpeg -i input.h264 -codec:v copy -bsf:v mjpeg2jpeg output%03d.jpg\n+                if (ffmpegSnapshot == null) {\n+                    if (inputOptions.isEmpty()) {\n+                        // iFrames only\n+                        inputOptions = \"-threads 1 -skip_frame nokey -hide_banner -loglevel warning\";\n+                    } else {\n+                        inputOptions = inputOptions + \" -threads 1 -skip_frame nokey -hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegSnapshot = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(), inputOptions, rtspUri,\n+                            \"-an -vsync vfr -update 1\", \"http://127.0.0.1:\" + serverPort + \"/snapshot.jpg\", username,\n+                            password);\n+                }\n+                if (ffmpegSnapshot != null) {\n+                    ffmpegSnapshot.startConverting();\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void noMotionDetected(String thisAlarmsChannel) {\n+        setChannelState(thisAlarmsChannel, OnOffType.OFF);\n+        firstMotionAlarm = false;\n+        motionAlarmUpdateSnapshot = false;\n+        motionDetected = false;\n+        if (streamingAutoFps) {\n+            stopSnapshotPolling();\n+        } else if (updateImageWhen.contains(\"4\")) { // During Motion Alarms\n+            stopSnapshotPolling();\n+        }\n+    }\n+\n+    // Change alarms that are not counted as motion detecting.\n+    public void changeAlarmState(String thisAlarmsChannel, String state) {\n+        updateState(thisAlarmsChannel, OnOffType.valueOf(state));\n+    }\n+\n+    public void motionDetected(String thisAlarmsChannel) {\n+        updateState(CHANNEL_LAST_MOTION_TYPE, new StringType(thisAlarmsChannel));\n+        updateState(thisAlarmsChannel, OnOffType.ON);\n+        motionDetected = true;\n+        if (streamingAutoFps) {\n+            startSnapshotPolling();\n+        }\n+        if (updateImageWhen.contains(\"2\")) {\n+            if (!firstMotionAlarm) {\n+                if (!snapshotUri.isEmpty()) {\n+                    sendHttpGET(snapshotUri);\n+                }\n+                firstMotionAlarm = true;// reset back to false when the jpg arrives.\n+            }\n+        } else if (updateImageWhen.contains(\"4\")) { // During Motion Alarms\n+            if (!snapshotPolling) {\n+                startSnapshotPolling();\n+            }\n+            firstMotionAlarm = true;\n+            motionAlarmUpdateSnapshot = true;\n+        }\n+    }\n+\n+    public void audioDetected() {\n+        updateState(CHANNEL_AUDIO_ALARM, OnOffType.ON);\n+        if (updateImageWhen.contains(\"3\")) {\n+            if (!firstAudioAlarm) {\n+                if (!snapshotUri.isEmpty()) {\n+                    sendHttpGET(snapshotUri);\n+                }\n+                firstAudioAlarm = true;// reset back to false when the jpg arrives.\n+            }\n+        } else if (updateImageWhen.contains(\"5\")) {// During audio alarms\n+            firstAudioAlarm = true;\n+            audioAlarmUpdateSnapshot = true;\n+        }\n+    }\n+\n+    public void noAudioDetected() {\n+        setChannelState(CHANNEL_AUDIO_ALARM, OnOffType.OFF);\n+        firstAudioAlarm = false;\n+        audioAlarmUpdateSnapshot = false;\n+    }\n+\n+    public String returnValueFromString(String rawString, String searchedString) {\n+        String result = \"\";\n+        int index = rawString.indexOf(searchedString);\n+        if (index != -1) // -1 means \"not found\"\n+        {\n+            result = rawString.substring(index + searchedString.length(), rawString.length());\n+            index = result.indexOf(\"\\r\\n\"); // find a carriage return to find the end of the value.\n+            if (index == -1) {\n+                return result; // Did not find a carriage return.\n+            } else {\n+                return result.substring(0, index);\n+            }\n+        }\n+        return \"\"; // Did not find the String we were searching for\n+    }\n+\n+    private void sendPTZRequest() {\n+        onvifCamera.sendPTZRequest(\"AbsoluteMove\");\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_PAN:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        updateState(CHANNEL_PAN, new PercentType(Math.round(onvifCamera.getAbsolutePan())));\n+                    }\n+                    return;\n+                case CHANNEL_TILT:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        updateState(CHANNEL_TILT, new PercentType(Math.round(onvifCamera.getAbsoluteTilt())));\n+                    }\n+                    return;\n+                case CHANNEL_ZOOM:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        updateState(CHANNEL_ZOOM, new PercentType(Math.round(onvifCamera.getAbsoluteZoom())));\n+                    }\n+                    return;\n+                case CHANNEL_GOTO_PRESET:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        onvifCamera.sendPTZRequest(\"GetPresets\");\n+                    }\n+                    return;\n+            }\n+        } // caution \"REFRESH\" can still progress to brand Handlers below the else.\n+        else {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MP4_HISTORY_LENGTH:\n+                    if (DecimalType.ZERO.equals(command)) {\n+                        mp4HistoryLength = 0;\n+                        mp4History = \"\";\n+                        setChannelState(CHANNEL_MP4_HISTORY, new StringType(mp4History));\n+                    }\n+                    return;\n+                case CHANNEL_GIF_HISTORY_LENGTH:\n+                    if (DecimalType.ZERO.equals(command)) {\n+                        gifHistoryLength = 0;\n+                        gifHistory = \"\";\n+                        setChannelState(CHANNEL_GIF_HISTORY, new StringType(gifHistory));\n+                    }\n+                    return;\n+                case CHANNEL_FFMPEG_MOTION_CONTROL:\n+                    if (OnOffType.ON.equals(command)) {\n+                        motionAlarmEnabled = true;\n+                    } else if (OnOffType.OFF.equals(command) || DecimalType.ZERO.equals(command)) {\n+                        motionAlarmEnabled = false;\n+                        noMotionDetected(CHANNEL_MOTION_ALARM);\n+                    } else {\n+                        motionAlarmEnabled = true;\n+                        motionThreshold = Double.valueOf(command.toString());\n+                        motionThreshold = motionThreshold / 10000;\n+                    }\n+                    setupFfmpegFormat(ffmpegFormat.RTSPHELPER);\n+                    return;\n+                case CHANNEL_GIF_FILENAME:\n+                    gifFilename = command.toString();\n+                    if (gifFilename.isEmpty()) {\n+                        gifFilename = \"ipcamera\";\n+                    }\n+                    return;\n+                case CHANNEL_MP4_FILENAME:\n+                    mp4Filename = command.toString();\n+                    if (mp4Filename.isEmpty()) {\n+                        mp4Filename = \"ipcamera\";\n+                    }\n+                    return;\n+                case CHANNEL_RECORD_MP4:\n+                    mp4RecordTime = Integer.parseInt(command.toString());\n+                    setupFfmpegFormat(ffmpegFormat.RECORD);\n+                    return;\n+                case CHANNEL_START_STREAM:\n+                    if (OnOffType.ON.equals(command)) {\n+                        setupFfmpegFormat(ffmpegFormat.HLS);\n+                        if (ffmpegHLS != null) {\n+                            ffmpegHLS.setKeepAlive(-1);// will keep running till manually stopped.\n+                        }\n+                    } else {\n+                        if (ffmpegHLS != null) {\n+                            ffmpegHLS.setKeepAlive(1);\n+                        }\n+                    }\n+                    return;\n+                case CHANNEL_EXTERNAL_MOTION:\n+                    if (OnOffType.ON.equals(command)) {\n+                        motionDetected(CHANNEL_EXTERNAL_MOTION);\n+                    } else {\n+                        noMotionDetected(CHANNEL_EXTERNAL_MOTION);\n+                    }\n+                    return;\n+                case CHANNEL_GOTO_PRESET:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        onvifCamera.gotoPreset(Integer.valueOf(command.toString()));\n+                    }\n+                    return;\n+                case CHANNEL_POLL_IMAGE:\n+                    if (OnOffType.ON.equals(command)) {\n+                        if (snapshotUri.isEmpty()) {\n+                            ffmpegSnapshotGeneration = true;\n+                            setupFfmpegFormat(ffmpegFormat.SNAPSHOT);\n+                            updateImageChannel = false;\n+                        } else {\n+                            updateImageChannel = true;\n+                            sendHttpGET(snapshotUri);// Allows this to change Image FPS on demand\n+                        }\n+                    } else {\n+                        if (ffmpegSnapshot != null) {\n+                            ffmpegSnapshot.stopConverting();\n+                            ffmpegSnapshotGeneration = false;\n+                        }\n+                        updateImageChannel = false;\n+                    }\n+                    return;\n+                case CHANNEL_UPDATE_GIF:\n+                    if (OnOffType.ON.equals(command)) {\n+                        if (preroll > 0) {\n+                            snapCount = postroll;\n+                        } else {\n+                            setupFfmpegFormat(ffmpegFormat.GIF);\n+                        }\n+                    }\n+                    return;\n+                case CHANNEL_PAN:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        if (command instanceof IncreaseDecreaseType) {\n+                            if (command == IncreaseDecreaseType.INCREASE) {\n+                                if (cameraConfig.getPtzContinuous()) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveLeft\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveLeft\");\n+                                }\n+                            } else {\n+                                if (cameraConfig.getPtzContinuous()) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveRight\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveRight\");\n+                                }\n+                            }\n+                            return;\n+                        } else if (OnOffType.OFF.equals(command)) {\n+                            onvifCamera.sendPTZRequest(\"Stop\");\n+                            return;\n+                        }\n+                        onvifCamera.setAbsolutePan(Float.valueOf(command.toString()));\n+                        threadPool.schedule(this::sendPTZRequest, 500, TimeUnit.MILLISECONDS);\n+                    }\n+                    return;\n+                case CHANNEL_TILT:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        if (command instanceof IncreaseDecreaseType) {\n+                            if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                                if (cameraConfig.getPtzContinuous()) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveUp\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveUp\");\n+                                }\n+                            } else {\n+                                if (cameraConfig.getPtzContinuous()) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveDown\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveDown\");\n+                                }\n+                            }\n+                            return;\n+                        } else if (OnOffType.OFF.equals(command)) {\n+                            onvifCamera.sendPTZRequest(\"Stop\");\n+                            return;\n+                        }\n+                        onvifCamera.setAbsoluteTilt(Float.valueOf(command.toString()));\n+                        threadPool.schedule(this::sendPTZRequest, 500, TimeUnit.MILLISECONDS);\n+                    }\n+                    return;\n+                case CHANNEL_ZOOM:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        if (command instanceof IncreaseDecreaseType) {\n+                            if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                                if (cameraConfig.getPtzContinuous()) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveIn\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveIn\");\n+                                }\n+                            } else {\n+                                if (cameraConfig.getPtzContinuous()) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveOut\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveOut\");\n+                                }\n+                            }\n+                            return;\n+                        } else if (OnOffType.OFF.equals(command)) {\n+                            onvifCamera.sendPTZRequest(\"Stop\");\n+                            return;\n+                        }\n+                        onvifCamera.setAbsoluteZoom(Float.valueOf(command.toString()));\n+                        threadPool.schedule(this::sendPTZRequest, 500, TimeUnit.MILLISECONDS);\n+                    }\n+                    return;\n+            }\n+        }\n+        // commands and refresh now get passed to brand handlers\n+        switch (thing.getThingTypeUID().getId()) {\n+            case AMCREST_THING:\n+                AmcrestHandler amcrestHandler = new AmcrestHandler(getHandle());\n+                amcrestHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = amcrestHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            case DAHUA_THING:\n+                DahuaHandler dahuaHandler = new DahuaHandler(getHandle(), nvrChannel);\n+                dahuaHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = dahuaHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            case DOORBIRD_THING:\n+                DoorBirdHandler doorBirdHandler = new DoorBirdHandler(getHandle());\n+                doorBirdHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = doorBirdHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            case HIKVISION_THING:\n+                HikvisionHandler hikvisionHandler = new HikvisionHandler(getHandle(), nvrChannel);\n+                hikvisionHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = hikvisionHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            case FOSCAM_THING:\n+                FoscamHandler foscamHandler = new FoscamHandler(getHandle(), username, password);\n+                foscamHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = foscamHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            case INSTAR_THING:\n+                InstarHandler instarHandler = new InstarHandler(getHandle());\n+                instarHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = instarHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            default:\n+                HttpOnlyHandler defaultHandler = new HttpOnlyHandler(getHandle());\n+                defaultHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = defaultHandler.getLowPriorityRequests();\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void setChannelState(String channelToUpdate, State valueOf) {\n+        updateState(channelToUpdate, valueOf);\n+    }\n+\n+    void bringCameraOnline() {\n+        isOnline = true;\n+        updateStatus(ThingStatus.ONLINE);\n+        groupTracker.listOfOnlineCameraHandlers.add(this);\n+        groupTracker.listOfOnlineCameraUID.add(getThing().getUID().getId());\n+        if (cameraConnectionJob != null) {\n+            cameraConnectionJob.cancel(false);\n+        }\n+\n+        if (preroll > 0 || updateImageWhen.contains(\"1\")) {\n+            snapshotPolling = true;\n+            snapshotJob = threadPool.scheduleAtFixedRate(this::snapshotRunnable, 1000, cameraConfig.getPollTime(),\n+                    TimeUnit.MILLISECONDS);\n+        }\n+\n+        pollCameraJob = threadPool.scheduleWithFixedDelay(this::pollCameraRunnable, 1000, 8000, TimeUnit.MILLISECONDS);\n+\n+        if (!rtspUri.isEmpty()) {\n+            updateState(CHANNEL_RTSP_URL, new StringType(rtspUri));\n+        }\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_POLL_IMAGE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_POLL_IMAGE, OnOffType.OFF);\n+        }\n+        if (!groupTracker.listOfGroupHandlers.isEmpty()) {\n+            for (IpCameraGroupHandler handle : groupTracker.listOfGroupHandlers) {\n+                handle.cameraOnline(getThing().getUID().getId());\n+            }\n+        }\n+    }\n+\n+    void snapshotIsFfmpeg() {\n+        bringCameraOnline();\n+        snapshotUri = \"\";// ffmpeg is a valid option. Simplify further checks.\n+        logger.debug(\n+                \"Binding has no snapshot url. Will use your CPU and FFmpeg to create snapshots from the cameras RTSP.\");\n+        if (!rtspUri.isEmpty()) {\n+            updateImageChannel = false;\n+            ffmpegSnapshotGeneration = true;\n+            setupFfmpegFormat(ffmpegFormat.SNAPSHOT);\n+            updateState(CHANNEL_POLL_IMAGE, OnOffType.ON);\n+        } else {\n+            cameraConfigError(\"Binding can not find a RTSP url for this camera, please provide a FFmpeg Input URL.\");\n+        }\n+    }\n+\n+    void pollingCameraConnection() {\n+        if (thing.getThingTypeUID().getId().equals(GENERIC_THING)) {\n+            if (rtspUri.isEmpty()) {\n+                logger.warn(\"Binding has not been supplied with a FFmpeg Input URL, so some features will not work.\");\n+            }\n+            if (snapshotUri.isEmpty() || snapshotUri.equals(\"ffmpeg\")) {\n+                snapshotIsFfmpeg();\n+            } else {\n+                sendHttpRequest(\"GET\", snapshotUri, null);\n+            }\n+            return;\n+        }\n+        if (!onvifCamera.isConnected()) {\n+            logger.debug(\"About to connect to the IP Camera using the ONVIF PORT at IP:{}:{}\", ipAddress,\n+                    cameraConfig.getOnvifPort());\n+            onvifCamera.connect(thing.getThingTypeUID().getId().equals(ONVIF_THING));\n+        }\n+        if (snapshotUri.equals(\"ffmpeg\")) {\n+            snapshotIsFfmpeg();\n+        } else if (!snapshotUri.isEmpty()) {\n+            sendHttpRequest(\"GET\", snapshotUri, null);\n+        } else if (!rtspUri.isEmpty()) {\n+            snapshotIsFfmpeg();\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Camera failed to report a valid Snaphot and/or RTSP URL. See readme on how to use the SNAPSHOT_URL_OVERRIDE feature.\");\n+        }\n+    }\n+\n+    public void cameraConfigError(String reason) {\n+        // wont try to reconnect again due to a config error being the cause.\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, reason);\n+        restart();\n+    }\n+\n+    public void cameraCommunicationError(String reason) {\n+        // will try to reconnect again as camera may be rebooting.\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, reason);\n+        if (isOnline) {// if already offline dont try reconnecting in 6 seconds, we want 30sec wait.\n+            resetAndRetryConnecting();\n+        }\n+    }\n+\n+    boolean streamIsStopped(String url) {\n+        lock.lock();\n+        try {\n+            for (ChannelTracking channelTracking : channelTracker) {\n+                if (channelTracking.getRequestUrl().equals(url)) {", "originalCommit": "8b6c85c2e3c680bfdc9386b22e725fabea6727f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMDY5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r491230695", "bodyText": "Thanks heaps for this suggestion, it is much nicer now and has been working fine for 18 hours on my test rig.", "author": "Skinah", "createdAt": "2020-09-18T23:10:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxNDAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxNDQ0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r489814448", "bodyText": "Why do you need to copy all of these fields when you can directly reference the fields in the cameraConfig instead?", "author": "cpmeister", "createdAt": "2020-09-16T23:48:42Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,1795 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal.handler;\n+\n+import static org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.CameraConfig;\n+import org.openhab.binding.ipcamera.internal.ChannelTracking;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.GroupTracker;\n+import org.openhab.binding.ipcamera.internal.Helper;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.ffmpegFormat;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.internal.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(4);\n+    private GroupTracker groupTracker;\n+    public CameraConfig cameraConfig;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    private final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    private final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public final ChannelGroup openChannels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    public boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private int nvrChannel;\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    private int mp4RecordTime = 0;\n+    private int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp;\n+    private String ffmpegOutputFolder = \"\";\n+    public ReentrantLock lock = new ReentrantLock();\n+    public List<ChannelTracking> channelTracker = new ArrayList<>(18);\n+    public List<String> lowPriorityRequests = new ArrayList<>(0);\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useBasicAuth = false;\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageWhen = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    private boolean motionAlarmUpdateSnapshot = false;\n+    private boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    private boolean firstAudioAlarm = false;\n+    private boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    private boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    // These methods handle the response from all camera brands, nothing specific to 1 brand.\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                processSnapshot(incomingJpeg);\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    ctx.close();\n+                                } else {\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.isEmpty()) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause instanceof ArrayIndexOutOfBoundsException) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        String urlToKeepOpen = \"\";\n+                        switch (thing.getThingTypeUID().getId()) {\n+                            case DAHUA_THING:\n+                                urlToKeepOpen = \"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\";\n+                                break;\n+                            case HIKVISION_THING:\n+                                urlToKeepOpen = \"/ISAPI/Event/notification/alertStream\";\n+                                break;\n+                            case DOORBIRD_THING:\n+                                urlToKeepOpen = \"/bha-api/monitor.cgi?ring=doorbell,motionsensor\";\n+                                break;\n+                        }\n+\n+                        for (ChannelTracking channelTracking : channelTracker) {\n+                            if (channelTracking.getChannel().equals(ctx.channel())) {\n+                                if (channelTracking.getRequestUrl().equals(urlToKeepOpen)) {\n+                                    return; // don't auto close this as it is for the alarms.\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public IpCameraHandler(Thing thing, @Nullable String openhabIpAddress, GroupTracker groupTracker) {\n+        super(thing);\n+        cameraConfig = getConfigAs(CameraConfig.class);\n+        if (openhabIpAddress != null) {\n+            hostIp = openhabIpAddress;\n+        } else {\n+            hostIp = Helper.getLocalIpAddress();\n+        }\n+        this.groupTracker = groupTracker;\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.isEmpty()) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.isEmpty() && !password.isEmpty()) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        if (longUrl.isEmpty() || longUrl.equals(\"ffmpeg\")) {\n+            return longUrl;\n+        }\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+        }\n+        return temp;\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return cameraConfig.getPort();\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null)//\n+    // The authHandler will generate a digest string and re-send using this same function when needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(AUTH_HANDLER,\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(COMMON_HANDLER, new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case AMCREST_THING:\n+                            socketChannel.pipeline().addLast(AMCREST_HANDLER, new AmcrestHandler(getHandle()));\n+                            break;\n+                        case DAHUA_THING:\n+                            socketChannel.pipeline().addLast(new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case DOORBIRD_THING:\n+                            socketChannel.pipeline().addLast(new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case FOSCAM_THING:\n+                            socketChannel.pipeline().addLast(new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case HIKVISION_THING:\n+                            socketChannel.pipeline().addLast(new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case INSTAR_THING:\n+                            socketChannel.pipeline().addLast(INSTAR_HANDLER, new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (!\"PUT\".equals(httpMethod) || (useDigestAuth && digestString == null)) {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        } else {\n+            request = putRequestWithBody;\n+        }\n+\n+        if (!basicAuth.isEmpty()) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    Channel ch = future.channel();\n+                    boolean chTracked = false;\n+                    openChannels.add(ch);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    try {\n+                        for (ChannelTracking channelTracking : channelTracker) {\n+                            if (channelTracking.getRequestUrl().equals(httpRequestURL)) {\n+                                channelTracking.setChannel(ch);\n+                                chTracked = true;\n+                                break;\n+                            }\n+                        }\n+                        if (!chTracked) {\n+                            channelTracker.add(new ChannelTracking(ch, httpRequestURL));\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(COMMON_HANDLER);\n+                    commonHandler.setURL(httpRequestURLFull);\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(AUTH_HANDLER);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case AMCREST_THING:\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(AMCREST_HANDLER);\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case INSTAR_THING:\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(INSTAR_HANDLER);\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+                    ch.writeAndFlush(request);\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot(byte[] incommingSnapshot) {\n+        lockCurrentSnapshot.lock();\n+        try {\n+            currentSnapshot = incommingSnapshot;\n+            if (preroll > 0) {\n+                fifoSnapshotBuffer.add(incommingSnapshot);\n+                if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                    fifoSnapshotBuffer.removeFirst();\n+                }\n+            }\n+        } finally {\n+            lockCurrentSnapshot.unlock();\n+        }\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(incommingSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(incommingSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                // only happens every 8 seconds as some browsers need a frame that often to keep stream alive.\n+                sendMjpegFrame(incommingSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 60, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.debug(\"File server for camera at {} has started on port {} for all NIC's.\", ipAddress,\n+                            serverPort);\n+                    updateState(CHANNEL_MJPEG_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    cameraConfigError(\"Exception when starting server. Try changing the serverPort to another number.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setupSnapshotStreaming(boolean stream, ChannelHandlerContext ctx, boolean auto) {\n+        if (stream) {\n+            sendMjpegFirstPacket(ctx);\n+            if (auto) {\n+                autoSnapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                try {\n+                    sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                    // iOS uses a FIFO? and needs two frames to display a pic\n+                    sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                } finally {\n+                    lockCurrentSnapshot.unlock();\n+                }\n+                streamingAutoFps = true;\n+            } else {\n+                snapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                try {\n+                    sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+                } finally {\n+                    lockCurrentSnapshot.unlock();\n+                }\n+                streamingSnapshotMjpeg = true;\n+                startSnapshotPolling();\n+            }\n+        } else {\n+            snapshotMjpegChannelGroup.remove(ctx.channel());\n+            autoSnapshotMjpegChannelGroup.remove(ctx.channel());\n+            if (streamingSnapshotMjpeg && snapshotMjpegChannelGroup.isEmpty()) {\n+                streamingSnapshotMjpeg = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All snapshots.mjpeg streams have stopped.\");\n+            } else if (streamingAutoFps && autoSnapshotMjpegChannelGroup.isEmpty()) {\n+                streamingAutoFps = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All autofps.mjpeg streams have stopped.\");\n+            }\n+        }\n+    }\n+\n+    // If start is true the CTX is added to the list to stream video to, false stops\n+    // the stream.\n+    public void setupMjpegStreaming(boolean start, ChannelHandlerContext ctx) {\n+        if (start) {\n+            if (mjpegChannelGroup.isEmpty()) {// first stream being requested.\n+                mjpegChannelGroup.add(ctx.channel());\n+                if (mjpegUri.isEmpty() || mjpegUri.equals(\"ffmpeg\")) {\n+                    sendMjpegFirstPacket(ctx);\n+                    setupFfmpegFormat(ffmpegFormat.MJPEG);\n+                } else {\n+                    try {\n+                        // fix Dahua reboots when refreshing a mjpeg stream.\n+                        TimeUnit.MILLISECONDS.sleep(500);\n+                    } catch (InterruptedException e) {\n+                    }\n+                    sendHttpGET(mjpegUri);\n+                }\n+            } else if (ffmpegMjpeg != null) {// not first stream and we will use ffmpeg\n+                sendMjpegFirstPacket(ctx);\n+                mjpegChannelGroup.add(ctx.channel());\n+            } else {// not first stream and camera supplies the mjpeg source.\n+                ctx.channel().writeAndFlush(firstStreamedMsg);\n+                mjpegChannelGroup.add(ctx.channel());\n+            }\n+        } else {\n+            mjpegChannelGroup.remove(ctx.channel());\n+            if (mjpegChannelGroup.isEmpty()) {\n+                logger.debug(\"All ipcamera.mjpeg streams have stopped.\");\n+                if (mjpegUri.equals(\"ffmpeg\")) {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                } else if (!mjpegUri.isEmpty()) {\n+                    closeChannel(getTinyUrl(mjpegUri));\n+                } else {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (ChannelTracking channelTracking : channelTracker) {\n+                if (channelTracking.getRequestUrl().equals(url)) {\n+                    if (channelTracking.getChannel().isOpen()) {\n+                        channelTracking.getChannel().close();\n+                        return;\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    void cleanChannels() {\n+        ChannelTracking localTracking = null;\n+        lock.lock();\n+        try {\n+            for (ChannelTracking channelTracking : channelTracker) {\n+                logger.trace(\"Channel is open:{}, url is {}\", channelTracking.getChannel().isOpen(),\n+                        channelTracking.getRequestUrl());\n+                if (!channelTracking.getChannel().isOpen() && channelTracking.getReply().isEmpty()) {\n+                    localTracking = channelTracking;// Seems to create a deadlock if we remove whilst in loop\n+                    break;\n+                }\n+            }\n+            if (localTracking != null) {\n+                channelTracker.remove(localTracking);// clean up one closed channel.\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void storeHttpReply(String url, String content) {\n+        lock.lock();\n+        try {\n+            for (ChannelTracking channelTracking : channelTracker) {\n+                if (channelTracking.getRequestUrl().equals(url)) {\n+                    channelTracking.setReply(content);\n+                    return;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    // sends direct to ctx so can be either snapshots.mjpeg or normal mjpeg stream\n+    public void sendMjpegFirstPacket(ChannelHandlerContext ctx) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        String contentType = \"multipart/x-mixed-replace; boundary=\" + BOUNDARY;\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+        ctx.channel().writeAndFlush(response);\n+    }\n+\n+    public void sendMjpegFrame(byte[] jpg, ChannelGroup channelGroup) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        ByteBuf imageByteBuf = Unpooled.copiedBuffer(jpg);\n+        int length = imageByteBuf.readableBytes();\n+        String header = \"--\" + BOUNDARY + \"\\r\\n\" + \"content-type: image/jpeg\" + \"\\r\\n\" + \"content-length: \" + length\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuf headerBbuf = Unpooled.copiedBuffer(header, 0, header.length(), StandardCharsets.UTF_8);\n+        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+        streamToGroup(headerBbuf, channelGroup, false);\n+        streamToGroup(imageByteBuf, channelGroup, false);\n+        streamToGroup(footerBbuf, channelGroup, true);\n+    }\n+\n+    public void streamToGroup(Object msg, ChannelGroup channelGroup, boolean flush) {\n+        channelGroup.write(msg);\n+        if (flush) {\n+            channelGroup.flush();\n+        }\n+    }\n+\n+    private void storeSnapshots() {\n+        int count = 0;\n+        // Need to lock as fifoSnapshotBuffer is not thread safe and new snapshots can be incoming.\n+        lockCurrentSnapshot.lock();\n+        try {\n+            for (byte[] foo : fifoSnapshotBuffer) {\n+                File file = new File(ffmpegOutputFolder + \"snapshot\" + count + \".jpg\");\n+                count++;\n+                try {\n+                    OutputStream fos = new FileOutputStream(file);\n+                    fos.write(foo);\n+                    fos.close();\n+                } catch (FileNotFoundException e) {\n+                    logger.warn(\"FileNotFoundException {}\", e.getMessage());\n+                } catch (IOException e) {\n+                    logger.warn(\"IOException {}\", e.getMessage());\n+                }\n+            }\n+        } finally {\n+            lockCurrentSnapshot.unlock();\n+        }\n+    }\n+\n+    public void setupFfmpegFormat(ffmpegFormat format) {\n+        String inputOptions = cameraConfig.getFfmpegInputOptions();\n+        if (cameraConfig.getFfmpegOutput().isEmpty()) {\n+            logger.warn(\"The camera tried to use a FFmpeg feature when the output folder is not set.\");\n+            return;\n+        }\n+        if (rtspUri.isEmpty()) {\n+            logger.warn(\"The camera tried to use a FFmpeg feature when no valid input for FFmpeg is provided.\");\n+            return;\n+        }\n+        if (cameraConfig.getFfmpegLocation().isEmpty()) {\n+            logger.warn(\"The camera tried to use a FFmpeg feature when the location for FFmpeg is not known.\");\n+            return;\n+        }\n+        if (rtspUri.toLowerCase().contains(\"rtsp\")) {\n+            if (inputOptions.isEmpty()) {\n+                inputOptions = \"-rtsp_transport tcp\";\n+            } else {\n+                inputOptions = inputOptions + \" -rtsp_transport tcp\";\n+            }\n+        }\n+\n+        // Make sure the folder exists, if not create it.\n+        new File(ffmpegOutputFolder).mkdirs();\n+        switch (format) {\n+            case HLS:\n+                if (ffmpegHLS == null) {\n+                    if (!inputOptions.isEmpty()) {\n+                        ffmpegHLS = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(),\n+                                \"-hide_banner -loglevel warning \" + inputOptions, rtspUri,\n+                                cameraConfig.getHlsOutOptions(), ffmpegOutputFolder + \"ipcamera.m3u8\", username,\n+                                password);\n+                    } else {\n+                        ffmpegHLS = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(),\n+                                \"-hide_banner -loglevel warning\", rtspUri, cameraConfig.getHlsOutOptions(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    }\n+                }\n+                if (ffmpegHLS != null) {\n+                    ffmpegHLS.startConverting();\n+                }\n+                break;\n+            case GIF:\n+                if (preroll > 0) {\n+                    ffmpegGIF = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(),\n+                            \"-y -r 1 -hide_banner -loglevel warning\", ffmpegOutputFolder + \"snapshot%d.jpg\",\n+                            \"-frames:v \" + (preroll + postroll) + \" \" + cameraConfig.getGifOutOptions(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                } else {\n+                    if (!inputOptions.isEmpty()) {\n+                        inputOptions = \"-y -t \" + postroll + \" -hide_banner -loglevel warning \" + inputOptions;\n+                    } else {\n+                        inputOptions = \"-y -t \" + postroll + \" -hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegGIF = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(), inputOptions, rtspUri,\n+                            cameraConfig.getGifOutOptions(), ffmpegOutputFolder + gifFilename + \".gif\", username,\n+                            password);\n+                }\n+                if (preroll > 0) {\n+                    storeSnapshots();\n+                }\n+                if (ffmpegGIF != null) {\n+                    ffmpegGIF.startConverting();\n+                    if (gifHistory.isEmpty()) {\n+                        gifHistory = gifFilename;\n+                    } else if (!gifFilename.equals(\"ipcamera\")) {\n+                        gifHistory = gifFilename + \",\" + gifHistory;\n+                        if (gifHistoryLength > 49) {\n+                            int endIndex = gifHistory.lastIndexOf(\",\");\n+                            gifHistory = gifHistory.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_GIF_HISTORY, new StringType(gifHistory));\n+                }\n+                break;\n+            case RECORD:\n+                if (!inputOptions.isEmpty()) {\n+                    inputOptions = \"-y -t \" + mp4RecordTime + \" -hide_banner -loglevel warning \" + inputOptions;\n+                } else {\n+                    inputOptions = \"-y -t \" + mp4RecordTime + \" -hide_banner -loglevel warning\";\n+                }\n+                ffmpegRecord = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(), inputOptions, rtspUri,\n+                        cameraConfig.getMp4OutOptions(), ffmpegOutputFolder + mp4Filename + \".mp4\", username, password);\n+                if (mp4Preroll > 0) {\n+                    // fetchFromHLS(); todo: not done yet\n+                }\n+                if (ffmpegRecord != null) {\n+                    ffmpegRecord.startConverting();\n+                    if (mp4History.isEmpty()) {\n+                        mp4History = mp4Filename;\n+                    } else if (!mp4Filename.equals(\"ipcamera\")) {\n+                        mp4History = mp4Filename + \",\" + mp4History;\n+                        if (mp4HistoryLength > 49) {\n+                            int endIndex = mp4History.lastIndexOf(\",\");\n+                            mp4History = mp4History.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_MP4_HISTORY, new StringType(mp4History));\n+                }\n+                break;\n+            case RTSPHELPER:\n+                if (ffmpegRtspHelper != null) {\n+                    ffmpegRtspHelper.stopConverting();\n+                    if (!audioAlarmEnabled && !motionAlarmEnabled) {\n+                        return;\n+                    }\n+                }\n+                String input = (cameraConfig.getAlarmInputUrl().isEmpty()) ? rtspUri : cameraConfig.getAlarmInputUrl();\n+                String OutputOptions = \"-f null -\";\n+                String filterOptions = \"\";\n+                if (!audioAlarmEnabled) {\n+                    filterOptions = \"-an\";\n+                } else {\n+                    filterOptions = \"-af silencedetect=n=-\" + audioThreshold + \"dB:d=2\";\n+                }\n+                if (!motionAlarmEnabled && !ffmpegSnapshotGeneration) {\n+                    filterOptions = filterOptions.concat(\" -vn\");\n+                } else if (motionAlarmEnabled == true) {\n+                    filterOptions = filterOptions\n+                            .concat(\" -vf select='gte(scene,\" + motionThreshold + \")',metadata=print\");\n+                }\n+                if (!cameraConfig.getUser().isEmpty()) {\n+                    filterOptions += \" \";// add space as the Framework does not allow spaces at start of config.\n+                }\n+                ffmpegRtspHelper = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(), inputOptions, input,\n+                        filterOptions + cameraConfig.getMotionOptions(), OutputOptions, username, password);\n+                ffmpegRtspHelper.startConverting();\n+                break;\n+            case MJPEG:\n+                if (ffmpegMjpeg == null) {\n+                    if (inputOptions.isEmpty()) {\n+                        inputOptions = \"-hide_banner -loglevel warning\";\n+                    } else {\n+                        inputOptions = inputOptions + \" -hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegMjpeg = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(), inputOptions, rtspUri,\n+                            cameraConfig.getMjpegOptions(), \"http://127.0.0.1:\" + serverPort + \"/ipcamera.jpg\",\n+                            username, password);\n+                }\n+                if (ffmpegMjpeg != null) {\n+                    ffmpegMjpeg.startConverting();\n+                }\n+                break;\n+            case SNAPSHOT:\n+                // if mjpeg stream you can use ffmpeg -i input.h264 -codec:v copy -bsf:v mjpeg2jpeg output%03d.jpg\n+                if (ffmpegSnapshot == null) {\n+                    if (inputOptions.isEmpty()) {\n+                        // iFrames only\n+                        inputOptions = \"-threads 1 -skip_frame nokey -hide_banner -loglevel warning\";\n+                    } else {\n+                        inputOptions = inputOptions + \" -threads 1 -skip_frame nokey -hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegSnapshot = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(), inputOptions, rtspUri,\n+                            \"-an -vsync vfr -update 1\", \"http://127.0.0.1:\" + serverPort + \"/snapshot.jpg\", username,\n+                            password);\n+                }\n+                if (ffmpegSnapshot != null) {\n+                    ffmpegSnapshot.startConverting();\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void noMotionDetected(String thisAlarmsChannel) {\n+        setChannelState(thisAlarmsChannel, OnOffType.OFF);\n+        firstMotionAlarm = false;\n+        motionAlarmUpdateSnapshot = false;\n+        motionDetected = false;\n+        if (streamingAutoFps) {\n+            stopSnapshotPolling();\n+        } else if (updateImageWhen.contains(\"4\")) { // During Motion Alarms\n+            stopSnapshotPolling();\n+        }\n+    }\n+\n+    // Change alarms that are not counted as motion detecting.\n+    public void changeAlarmState(String thisAlarmsChannel, String state) {\n+        updateState(thisAlarmsChannel, OnOffType.valueOf(state));\n+    }\n+\n+    public void motionDetected(String thisAlarmsChannel) {\n+        updateState(CHANNEL_LAST_MOTION_TYPE, new StringType(thisAlarmsChannel));\n+        updateState(thisAlarmsChannel, OnOffType.ON);\n+        motionDetected = true;\n+        if (streamingAutoFps) {\n+            startSnapshotPolling();\n+        }\n+        if (updateImageWhen.contains(\"2\")) {\n+            if (!firstMotionAlarm) {\n+                if (!snapshotUri.isEmpty()) {\n+                    sendHttpGET(snapshotUri);\n+                }\n+                firstMotionAlarm = true;// reset back to false when the jpg arrives.\n+            }\n+        } else if (updateImageWhen.contains(\"4\")) { // During Motion Alarms\n+            if (!snapshotPolling) {\n+                startSnapshotPolling();\n+            }\n+            firstMotionAlarm = true;\n+            motionAlarmUpdateSnapshot = true;\n+        }\n+    }\n+\n+    public void audioDetected() {\n+        updateState(CHANNEL_AUDIO_ALARM, OnOffType.ON);\n+        if (updateImageWhen.contains(\"3\")) {\n+            if (!firstAudioAlarm) {\n+                if (!snapshotUri.isEmpty()) {\n+                    sendHttpGET(snapshotUri);\n+                }\n+                firstAudioAlarm = true;// reset back to false when the jpg arrives.\n+            }\n+        } else if (updateImageWhen.contains(\"5\")) {// During audio alarms\n+            firstAudioAlarm = true;\n+            audioAlarmUpdateSnapshot = true;\n+        }\n+    }\n+\n+    public void noAudioDetected() {\n+        setChannelState(CHANNEL_AUDIO_ALARM, OnOffType.OFF);\n+        firstAudioAlarm = false;\n+        audioAlarmUpdateSnapshot = false;\n+    }\n+\n+    public String returnValueFromString(String rawString, String searchedString) {\n+        String result = \"\";\n+        int index = rawString.indexOf(searchedString);\n+        if (index != -1) // -1 means \"not found\"\n+        {\n+            result = rawString.substring(index + searchedString.length(), rawString.length());\n+            index = result.indexOf(\"\\r\\n\"); // find a carriage return to find the end of the value.\n+            if (index == -1) {\n+                return result; // Did not find a carriage return.\n+            } else {\n+                return result.substring(0, index);\n+            }\n+        }\n+        return \"\"; // Did not find the String we were searching for\n+    }\n+\n+    private void sendPTZRequest() {\n+        onvifCamera.sendPTZRequest(\"AbsoluteMove\");\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_PAN:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        updateState(CHANNEL_PAN, new PercentType(Math.round(onvifCamera.getAbsolutePan())));\n+                    }\n+                    return;\n+                case CHANNEL_TILT:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        updateState(CHANNEL_TILT, new PercentType(Math.round(onvifCamera.getAbsoluteTilt())));\n+                    }\n+                    return;\n+                case CHANNEL_ZOOM:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        updateState(CHANNEL_ZOOM, new PercentType(Math.round(onvifCamera.getAbsoluteZoom())));\n+                    }\n+                    return;\n+                case CHANNEL_GOTO_PRESET:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        onvifCamera.sendPTZRequest(\"GetPresets\");\n+                    }\n+                    return;\n+            }\n+        } // caution \"REFRESH\" can still progress to brand Handlers below the else.\n+        else {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MP4_HISTORY_LENGTH:\n+                    if (DecimalType.ZERO.equals(command)) {\n+                        mp4HistoryLength = 0;\n+                        mp4History = \"\";\n+                        setChannelState(CHANNEL_MP4_HISTORY, new StringType(mp4History));\n+                    }\n+                    return;\n+                case CHANNEL_GIF_HISTORY_LENGTH:\n+                    if (DecimalType.ZERO.equals(command)) {\n+                        gifHistoryLength = 0;\n+                        gifHistory = \"\";\n+                        setChannelState(CHANNEL_GIF_HISTORY, new StringType(gifHistory));\n+                    }\n+                    return;\n+                case CHANNEL_FFMPEG_MOTION_CONTROL:\n+                    if (OnOffType.ON.equals(command)) {\n+                        motionAlarmEnabled = true;\n+                    } else if (OnOffType.OFF.equals(command) || DecimalType.ZERO.equals(command)) {\n+                        motionAlarmEnabled = false;\n+                        noMotionDetected(CHANNEL_MOTION_ALARM);\n+                    } else {\n+                        motionAlarmEnabled = true;\n+                        motionThreshold = Double.valueOf(command.toString());\n+                        motionThreshold = motionThreshold / 10000;\n+                    }\n+                    setupFfmpegFormat(ffmpegFormat.RTSPHELPER);\n+                    return;\n+                case CHANNEL_GIF_FILENAME:\n+                    gifFilename = command.toString();\n+                    if (gifFilename.isEmpty()) {\n+                        gifFilename = \"ipcamera\";\n+                    }\n+                    return;\n+                case CHANNEL_MP4_FILENAME:\n+                    mp4Filename = command.toString();\n+                    if (mp4Filename.isEmpty()) {\n+                        mp4Filename = \"ipcamera\";\n+                    }\n+                    return;\n+                case CHANNEL_RECORD_MP4:\n+                    mp4RecordTime = Integer.parseInt(command.toString());\n+                    setupFfmpegFormat(ffmpegFormat.RECORD);\n+                    return;\n+                case CHANNEL_START_STREAM:\n+                    if (OnOffType.ON.equals(command)) {\n+                        setupFfmpegFormat(ffmpegFormat.HLS);\n+                        if (ffmpegHLS != null) {\n+                            ffmpegHLS.setKeepAlive(-1);// will keep running till manually stopped.\n+                        }\n+                    } else {\n+                        if (ffmpegHLS != null) {\n+                            ffmpegHLS.setKeepAlive(1);\n+                        }\n+                    }\n+                    return;\n+                case CHANNEL_EXTERNAL_MOTION:\n+                    if (OnOffType.ON.equals(command)) {\n+                        motionDetected(CHANNEL_EXTERNAL_MOTION);\n+                    } else {\n+                        noMotionDetected(CHANNEL_EXTERNAL_MOTION);\n+                    }\n+                    return;\n+                case CHANNEL_GOTO_PRESET:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        onvifCamera.gotoPreset(Integer.valueOf(command.toString()));\n+                    }\n+                    return;\n+                case CHANNEL_POLL_IMAGE:\n+                    if (OnOffType.ON.equals(command)) {\n+                        if (snapshotUri.isEmpty()) {\n+                            ffmpegSnapshotGeneration = true;\n+                            setupFfmpegFormat(ffmpegFormat.SNAPSHOT);\n+                            updateImageChannel = false;\n+                        } else {\n+                            updateImageChannel = true;\n+                            sendHttpGET(snapshotUri);// Allows this to change Image FPS on demand\n+                        }\n+                    } else {\n+                        if (ffmpegSnapshot != null) {\n+                            ffmpegSnapshot.stopConverting();\n+                            ffmpegSnapshotGeneration = false;\n+                        }\n+                        updateImageChannel = false;\n+                    }\n+                    return;\n+                case CHANNEL_UPDATE_GIF:\n+                    if (OnOffType.ON.equals(command)) {\n+                        if (preroll > 0) {\n+                            snapCount = postroll;\n+                        } else {\n+                            setupFfmpegFormat(ffmpegFormat.GIF);\n+                        }\n+                    }\n+                    return;\n+                case CHANNEL_PAN:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        if (command instanceof IncreaseDecreaseType) {\n+                            if (command == IncreaseDecreaseType.INCREASE) {\n+                                if (cameraConfig.getPtzContinuous()) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveLeft\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveLeft\");\n+                                }\n+                            } else {\n+                                if (cameraConfig.getPtzContinuous()) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveRight\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveRight\");\n+                                }\n+                            }\n+                            return;\n+                        } else if (OnOffType.OFF.equals(command)) {\n+                            onvifCamera.sendPTZRequest(\"Stop\");\n+                            return;\n+                        }\n+                        onvifCamera.setAbsolutePan(Float.valueOf(command.toString()));\n+                        threadPool.schedule(this::sendPTZRequest, 500, TimeUnit.MILLISECONDS);\n+                    }\n+                    return;\n+                case CHANNEL_TILT:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        if (command instanceof IncreaseDecreaseType) {\n+                            if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                                if (cameraConfig.getPtzContinuous()) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveUp\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveUp\");\n+                                }\n+                            } else {\n+                                if (cameraConfig.getPtzContinuous()) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveDown\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveDown\");\n+                                }\n+                            }\n+                            return;\n+                        } else if (OnOffType.OFF.equals(command)) {\n+                            onvifCamera.sendPTZRequest(\"Stop\");\n+                            return;\n+                        }\n+                        onvifCamera.setAbsoluteTilt(Float.valueOf(command.toString()));\n+                        threadPool.schedule(this::sendPTZRequest, 500, TimeUnit.MILLISECONDS);\n+                    }\n+                    return;\n+                case CHANNEL_ZOOM:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        if (command instanceof IncreaseDecreaseType) {\n+                            if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                                if (cameraConfig.getPtzContinuous()) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveIn\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveIn\");\n+                                }\n+                            } else {\n+                                if (cameraConfig.getPtzContinuous()) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveOut\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveOut\");\n+                                }\n+                            }\n+                            return;\n+                        } else if (OnOffType.OFF.equals(command)) {\n+                            onvifCamera.sendPTZRequest(\"Stop\");\n+                            return;\n+                        }\n+                        onvifCamera.setAbsoluteZoom(Float.valueOf(command.toString()));\n+                        threadPool.schedule(this::sendPTZRequest, 500, TimeUnit.MILLISECONDS);\n+                    }\n+                    return;\n+            }\n+        }\n+        // commands and refresh now get passed to brand handlers\n+        switch (thing.getThingTypeUID().getId()) {\n+            case AMCREST_THING:\n+                AmcrestHandler amcrestHandler = new AmcrestHandler(getHandle());\n+                amcrestHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = amcrestHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            case DAHUA_THING:\n+                DahuaHandler dahuaHandler = new DahuaHandler(getHandle(), nvrChannel);\n+                dahuaHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = dahuaHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            case DOORBIRD_THING:\n+                DoorBirdHandler doorBirdHandler = new DoorBirdHandler(getHandle());\n+                doorBirdHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = doorBirdHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            case HIKVISION_THING:\n+                HikvisionHandler hikvisionHandler = new HikvisionHandler(getHandle(), nvrChannel);\n+                hikvisionHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = hikvisionHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            case FOSCAM_THING:\n+                FoscamHandler foscamHandler = new FoscamHandler(getHandle(), username, password);\n+                foscamHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = foscamHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            case INSTAR_THING:\n+                InstarHandler instarHandler = new InstarHandler(getHandle());\n+                instarHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = instarHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            default:\n+                HttpOnlyHandler defaultHandler = new HttpOnlyHandler(getHandle());\n+                defaultHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = defaultHandler.getLowPriorityRequests();\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void setChannelState(String channelToUpdate, State valueOf) {\n+        updateState(channelToUpdate, valueOf);\n+    }\n+\n+    void bringCameraOnline() {\n+        isOnline = true;\n+        updateStatus(ThingStatus.ONLINE);\n+        groupTracker.listOfOnlineCameraHandlers.add(this);\n+        groupTracker.listOfOnlineCameraUID.add(getThing().getUID().getId());\n+        if (cameraConnectionJob != null) {\n+            cameraConnectionJob.cancel(false);\n+        }\n+\n+        if (preroll > 0 || updateImageWhen.contains(\"1\")) {\n+            snapshotPolling = true;\n+            snapshotJob = threadPool.scheduleAtFixedRate(this::snapshotRunnable, 1000, cameraConfig.getPollTime(),\n+                    TimeUnit.MILLISECONDS);\n+        }\n+\n+        pollCameraJob = threadPool.scheduleWithFixedDelay(this::pollCameraRunnable, 1000, 8000, TimeUnit.MILLISECONDS);\n+\n+        if (!rtspUri.isEmpty()) {\n+            updateState(CHANNEL_RTSP_URL, new StringType(rtspUri));\n+        }\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_POLL_IMAGE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_POLL_IMAGE, OnOffType.OFF);\n+        }\n+        if (!groupTracker.listOfGroupHandlers.isEmpty()) {\n+            for (IpCameraGroupHandler handle : groupTracker.listOfGroupHandlers) {\n+                handle.cameraOnline(getThing().getUID().getId());\n+            }\n+        }\n+    }\n+\n+    void snapshotIsFfmpeg() {\n+        bringCameraOnline();\n+        snapshotUri = \"\";// ffmpeg is a valid option. Simplify further checks.\n+        logger.debug(\n+                \"Binding has no snapshot url. Will use your CPU and FFmpeg to create snapshots from the cameras RTSP.\");\n+        if (!rtspUri.isEmpty()) {\n+            updateImageChannel = false;\n+            ffmpegSnapshotGeneration = true;\n+            setupFfmpegFormat(ffmpegFormat.SNAPSHOT);\n+            updateState(CHANNEL_POLL_IMAGE, OnOffType.ON);\n+        } else {\n+            cameraConfigError(\"Binding can not find a RTSP url for this camera, please provide a FFmpeg Input URL.\");\n+        }\n+    }\n+\n+    void pollingCameraConnection() {\n+        if (thing.getThingTypeUID().getId().equals(GENERIC_THING)) {\n+            if (rtspUri.isEmpty()) {\n+                logger.warn(\"Binding has not been supplied with a FFmpeg Input URL, so some features will not work.\");\n+            }\n+            if (snapshotUri.isEmpty() || snapshotUri.equals(\"ffmpeg\")) {\n+                snapshotIsFfmpeg();\n+            } else {\n+                sendHttpRequest(\"GET\", snapshotUri, null);\n+            }\n+            return;\n+        }\n+        if (!onvifCamera.isConnected()) {\n+            logger.debug(\"About to connect to the IP Camera using the ONVIF PORT at IP:{}:{}\", ipAddress,\n+                    cameraConfig.getOnvifPort());\n+            onvifCamera.connect(thing.getThingTypeUID().getId().equals(ONVIF_THING));\n+        }\n+        if (snapshotUri.equals(\"ffmpeg\")) {\n+            snapshotIsFfmpeg();\n+        } else if (!snapshotUri.isEmpty()) {\n+            sendHttpRequest(\"GET\", snapshotUri, null);\n+        } else if (!rtspUri.isEmpty()) {\n+            snapshotIsFfmpeg();\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Camera failed to report a valid Snaphot and/or RTSP URL. See readme on how to use the SNAPSHOT_URL_OVERRIDE feature.\");\n+        }\n+    }\n+\n+    public void cameraConfigError(String reason) {\n+        // wont try to reconnect again due to a config error being the cause.\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, reason);\n+        restart();\n+    }\n+\n+    public void cameraCommunicationError(String reason) {\n+        // will try to reconnect again as camera may be rebooting.\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, reason);\n+        if (isOnline) {// if already offline dont try reconnecting in 6 seconds, we want 30sec wait.\n+            resetAndRetryConnecting();\n+        }\n+    }\n+\n+    boolean streamIsStopped(String url) {\n+        lock.lock();\n+        try {\n+            for (ChannelTracking channelTracking : channelTracker) {\n+                if (channelTracking.getRequestUrl().equals(url)) {\n+                    if (channelTracking.getChannel().isOpen()) {\n+                        return false;// stream is running.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+        return true; // Stream stopped or never started.\n+    }\n+\n+    void snapshotRunnable() {\n+        // Snapshot should be first to keep consistent time between shots\n+        sendHttpGET(snapshotUri);\n+        if (snapCount > 0) {\n+            if (--snapCount == 0) {\n+                setupFfmpegFormat(ffmpegFormat.GIF);\n+            }\n+        }\n+    }\n+\n+    public void stopSnapshotPolling() {\n+        if (!streamingSnapshotMjpeg && preroll == 0 && !updateImageWhen.contains(\"1\")) {\n+            snapshotPolling = false;\n+            if (snapshotJob != null) {\n+                snapshotJob.cancel(true);\n+            }\n+        } else if (updateImageWhen.contains(\"4\")) { // only during Motion Alarms\n+            snapshotPolling = false;\n+            if (snapshotJob != null) {\n+                snapshotJob.cancel(true);\n+            }\n+        }\n+    }\n+\n+    public void startSnapshotPolling() {\n+        if (snapshotPolling || ffmpegSnapshotGeneration) {\n+            return; // Already polling or creating with FFmpeg from RTSP\n+        }\n+        if (streamingSnapshotMjpeg || streamingAutoFps) {\n+            snapshotPolling = true;\n+            snapshotJob = threadPool.scheduleAtFixedRate(this::snapshotRunnable, 200, cameraConfig.getPollTime(),\n+                    TimeUnit.MILLISECONDS);\n+        } else if (updateImageWhen.contains(\"4\")) { // During Motion Alarms\n+            snapshotPolling = true;\n+            snapshotJob = threadPool.scheduleAtFixedRate(this::snapshotRunnable, 200, cameraConfig.getPollTime(),\n+                    TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    // runs every 8 seconds due to mjpeg streams not staying open unless they update this often.\n+    void pollCameraRunnable() {\n+        // Snapshot should be first to keep consistent time between shots\n+        if (!snapshotUri.isEmpty()) {\n+            if (updateImageChannel) {\n+                sendHttpGET(snapshotUri);\n+            }\n+        }\n+        if (streamingAutoFps) {\n+            updateAutoFps = true;\n+            if (!snapshotPolling && !ffmpegSnapshotGeneration) {\n+                // Dont need to poll if creating from RTSP stream with FFmpeg or we are polling at full rate already.\n+                sendHttpGET(snapshotUri);\n+            }\n+        }\n+        // NOTE: Use lowPriorityRequests if get request is not needed every poll.\n+        if (!lowPriorityRequests.isEmpty()) {\n+            if (lowPriorityCounter >= lowPriorityRequests.size()) {\n+                lowPriorityCounter = 0;\n+            }\n+            sendHttpGET(lowPriorityRequests.get(lowPriorityCounter++));\n+        }\n+        // what needs to be done every poll//\n+        switch (thing.getThingTypeUID().getId()) {\n+            case GENERIC_THING:\n+                break;\n+            case ONVIF_THING:\n+                if (!onvifCamera.isConnected()) {\n+                    onvifCamera.connect(true);\n+                }\n+                break;\n+            case INSTAR_THING:\n+                noMotionDetected(CHANNEL_MOTION_ALARM);\n+                noMotionDetected(CHANNEL_PIR_ALARM);\n+                noAudioDetected();\n+                break;\n+            case HIKVISION_THING:\n+                if (streamIsStopped(\"/ISAPI/Event/notification/alertStream\")) {\n+                    logger.info(\"The alarm stream was not running for camera {}, re-starting it now\", ipAddress);\n+                    sendHttpGET(\"/ISAPI/Event/notification/alertStream\");\n+                }\n+                break;\n+            case AMCREST_THING:\n+                sendHttpGET(\"/cgi-bin/eventManager.cgi?action=getEventIndexes&code=VideoMotion\");\n+                sendHttpGET(\"/cgi-bin/eventManager.cgi?action=getEventIndexes&code=AudioMutation\");\n+                break;\n+            case DAHUA_THING:\n+                // Check for alarms, channel for NVRs appears not to work at filtering.\n+                if (streamIsStopped(\"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\")) {\n+                    logger.info(\"The alarm stream was not running for camera {}, re-starting it now\", ipAddress);\n+                    sendHttpGET(\"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\");\n+                }\n+                break;\n+            case DOORBIRD_THING:\n+                // Check for alarms, channel for NVRs appears not to work at filtering.\n+                if (streamIsStopped(\"/bha-api/monitor.cgi?ring=doorbell,motionsensor\")) {\n+                    logger.info(\"The alarm stream was not running for camera {}, re-starting it now\", ipAddress);\n+                    sendHttpGET(\"/bha-api/monitor.cgi?ring=doorbell,motionsensor\");\n+                }\n+                break;\n+        }\n+        if (ffmpegHLS != null) {\n+            ffmpegHLS.checkKeepAlive();\n+        }\n+        if (openChannels.size() > 18 || channelTracker.size() > 18) {\n+            logger.debug(\"There are {} Channels being tracked, {} are open.\", channelTracker.size(),\n+                    openChannels.size());\n+            cleanChannels();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        cameraConfig = getConfigAs(CameraConfig.class);\n+        ipAddress = cameraConfig.getIp();\n+        username = cameraConfig.getUser();\n+        password = cameraConfig.getPassword();\n+        preroll = cameraConfig.getGifPreroll();\n+        postroll = cameraConfig.getGifPostroll();", "originalCommit": "8b6c85c2e3c680bfdc9386b22e725fabea6727f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg1ODE3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r490858176", "bodyText": "Removed half of them, the other half are more involved to change over without breaking anything. Will leave till later to look again.", "author": "Skinah", "createdAt": "2020-09-18T10:38:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxNDQ0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxNTIyNw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r489815227", "bodyText": "You should make these two separate methods. Create another method called stopStreamServer.", "author": "cpmeister", "createdAt": "2020-09-16T23:51:19Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,1795 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal.handler;\n+\n+import static org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.CameraConfig;\n+import org.openhab.binding.ipcamera.internal.ChannelTracking;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.GroupTracker;\n+import org.openhab.binding.ipcamera.internal.Helper;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.ffmpegFormat;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.internal.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(4);\n+    private GroupTracker groupTracker;\n+    public CameraConfig cameraConfig;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    private final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    private final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public final ChannelGroup openChannels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    public boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private int nvrChannel;\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    private int mp4RecordTime = 0;\n+    private int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp;\n+    private String ffmpegOutputFolder = \"\";\n+    public ReentrantLock lock = new ReentrantLock();\n+    public List<ChannelTracking> channelTracker = new ArrayList<>(18);\n+    public List<String> lowPriorityRequests = new ArrayList<>(0);\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useBasicAuth = false;\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageWhen = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    private boolean motionAlarmUpdateSnapshot = false;\n+    private boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    private boolean firstAudioAlarm = false;\n+    private boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    private boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    // These methods handle the response from all camera brands, nothing specific to 1 brand.\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                processSnapshot(incomingJpeg);\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    ctx.close();\n+                                } else {\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.isEmpty()) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause instanceof ArrayIndexOutOfBoundsException) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        String urlToKeepOpen = \"\";\n+                        switch (thing.getThingTypeUID().getId()) {\n+                            case DAHUA_THING:\n+                                urlToKeepOpen = \"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\";\n+                                break;\n+                            case HIKVISION_THING:\n+                                urlToKeepOpen = \"/ISAPI/Event/notification/alertStream\";\n+                                break;\n+                            case DOORBIRD_THING:\n+                                urlToKeepOpen = \"/bha-api/monitor.cgi?ring=doorbell,motionsensor\";\n+                                break;\n+                        }\n+\n+                        for (ChannelTracking channelTracking : channelTracker) {\n+                            if (channelTracking.getChannel().equals(ctx.channel())) {\n+                                if (channelTracking.getRequestUrl().equals(urlToKeepOpen)) {\n+                                    return; // don't auto close this as it is for the alarms.\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public IpCameraHandler(Thing thing, @Nullable String openhabIpAddress, GroupTracker groupTracker) {\n+        super(thing);\n+        cameraConfig = getConfigAs(CameraConfig.class);\n+        if (openhabIpAddress != null) {\n+            hostIp = openhabIpAddress;\n+        } else {\n+            hostIp = Helper.getLocalIpAddress();\n+        }\n+        this.groupTracker = groupTracker;\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.isEmpty()) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.isEmpty() && !password.isEmpty()) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        if (longUrl.isEmpty() || longUrl.equals(\"ffmpeg\")) {\n+            return longUrl;\n+        }\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+        }\n+        return temp;\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return cameraConfig.getPort();\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null)//\n+    // The authHandler will generate a digest string and re-send using this same function when needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(AUTH_HANDLER,\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(COMMON_HANDLER, new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case AMCREST_THING:\n+                            socketChannel.pipeline().addLast(AMCREST_HANDLER, new AmcrestHandler(getHandle()));\n+                            break;\n+                        case DAHUA_THING:\n+                            socketChannel.pipeline().addLast(new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case DOORBIRD_THING:\n+                            socketChannel.pipeline().addLast(new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case FOSCAM_THING:\n+                            socketChannel.pipeline().addLast(new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case HIKVISION_THING:\n+                            socketChannel.pipeline().addLast(new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case INSTAR_THING:\n+                            socketChannel.pipeline().addLast(INSTAR_HANDLER, new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (!\"PUT\".equals(httpMethod) || (useDigestAuth && digestString == null)) {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        } else {\n+            request = putRequestWithBody;\n+        }\n+\n+        if (!basicAuth.isEmpty()) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    Channel ch = future.channel();\n+                    boolean chTracked = false;\n+                    openChannels.add(ch);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    try {\n+                        for (ChannelTracking channelTracking : channelTracker) {\n+                            if (channelTracking.getRequestUrl().equals(httpRequestURL)) {\n+                                channelTracking.setChannel(ch);\n+                                chTracked = true;\n+                                break;\n+                            }\n+                        }\n+                        if (!chTracked) {\n+                            channelTracker.add(new ChannelTracking(ch, httpRequestURL));\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(COMMON_HANDLER);\n+                    commonHandler.setURL(httpRequestURLFull);\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(AUTH_HANDLER);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case AMCREST_THING:\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(AMCREST_HANDLER);\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case INSTAR_THING:\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(INSTAR_HANDLER);\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+                    ch.writeAndFlush(request);\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot(byte[] incommingSnapshot) {\n+        lockCurrentSnapshot.lock();\n+        try {\n+            currentSnapshot = incommingSnapshot;\n+            if (preroll > 0) {\n+                fifoSnapshotBuffer.add(incommingSnapshot);\n+                if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                    fifoSnapshotBuffer.removeFirst();\n+                }\n+            }\n+        } finally {\n+            lockCurrentSnapshot.unlock();\n+        }\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(incommingSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(incommingSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                // only happens every 8 seconds as some browsers need a frame that often to keep stream alive.\n+                sendMjpegFrame(incommingSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {", "originalCommit": "8b6c85c2e3c680bfdc9386b22e725fabea6727f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg2MDY1MA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r490860650", "bodyText": "DONE", "author": "Skinah", "createdAt": "2020-09-18T10:43:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxNTIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxNTUyMw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r489815523", "bodyText": "Dispose should perform cleanup, not restart. If anything restart should call dispose instead.", "author": "cpmeister", "createdAt": "2020-09-16T23:52:22Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,1795 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal.handler;\n+\n+import static org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.CameraConfig;\n+import org.openhab.binding.ipcamera.internal.ChannelTracking;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.GroupTracker;\n+import org.openhab.binding.ipcamera.internal.Helper;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.ffmpegFormat;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.internal.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(4);\n+    private GroupTracker groupTracker;\n+    public CameraConfig cameraConfig;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    private final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    private final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public final ChannelGroup openChannels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    public boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private int nvrChannel;\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    private int mp4RecordTime = 0;\n+    private int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp;\n+    private String ffmpegOutputFolder = \"\";\n+    public ReentrantLock lock = new ReentrantLock();\n+    public List<ChannelTracking> channelTracker = new ArrayList<>(18);\n+    public List<String> lowPriorityRequests = new ArrayList<>(0);\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useBasicAuth = false;\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageWhen = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    private boolean motionAlarmUpdateSnapshot = false;\n+    private boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    private boolean firstAudioAlarm = false;\n+    private boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    private boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    // These methods handle the response from all camera brands, nothing specific to 1 brand.\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                processSnapshot(incomingJpeg);\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    ctx.close();\n+                                } else {\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.isEmpty()) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause instanceof ArrayIndexOutOfBoundsException) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        String urlToKeepOpen = \"\";\n+                        switch (thing.getThingTypeUID().getId()) {\n+                            case DAHUA_THING:\n+                                urlToKeepOpen = \"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\";\n+                                break;\n+                            case HIKVISION_THING:\n+                                urlToKeepOpen = \"/ISAPI/Event/notification/alertStream\";\n+                                break;\n+                            case DOORBIRD_THING:\n+                                urlToKeepOpen = \"/bha-api/monitor.cgi?ring=doorbell,motionsensor\";\n+                                break;\n+                        }\n+\n+                        for (ChannelTracking channelTracking : channelTracker) {\n+                            if (channelTracking.getChannel().equals(ctx.channel())) {\n+                                if (channelTracking.getRequestUrl().equals(urlToKeepOpen)) {\n+                                    return; // don't auto close this as it is for the alarms.\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public IpCameraHandler(Thing thing, @Nullable String openhabIpAddress, GroupTracker groupTracker) {\n+        super(thing);\n+        cameraConfig = getConfigAs(CameraConfig.class);\n+        if (openhabIpAddress != null) {\n+            hostIp = openhabIpAddress;\n+        } else {\n+            hostIp = Helper.getLocalIpAddress();\n+        }\n+        this.groupTracker = groupTracker;\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.isEmpty()) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.isEmpty() && !password.isEmpty()) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        if (longUrl.isEmpty() || longUrl.equals(\"ffmpeg\")) {\n+            return longUrl;\n+        }\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+        }\n+        return temp;\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return cameraConfig.getPort();\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null)//\n+    // The authHandler will generate a digest string and re-send using this same function when needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(AUTH_HANDLER,\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(COMMON_HANDLER, new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case AMCREST_THING:\n+                            socketChannel.pipeline().addLast(AMCREST_HANDLER, new AmcrestHandler(getHandle()));\n+                            break;\n+                        case DAHUA_THING:\n+                            socketChannel.pipeline().addLast(new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case DOORBIRD_THING:\n+                            socketChannel.pipeline().addLast(new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case FOSCAM_THING:\n+                            socketChannel.pipeline().addLast(new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case HIKVISION_THING:\n+                            socketChannel.pipeline().addLast(new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case INSTAR_THING:\n+                            socketChannel.pipeline().addLast(INSTAR_HANDLER, new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (!\"PUT\".equals(httpMethod) || (useDigestAuth && digestString == null)) {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        } else {\n+            request = putRequestWithBody;\n+        }\n+\n+        if (!basicAuth.isEmpty()) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    Channel ch = future.channel();\n+                    boolean chTracked = false;\n+                    openChannels.add(ch);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    try {\n+                        for (ChannelTracking channelTracking : channelTracker) {\n+                            if (channelTracking.getRequestUrl().equals(httpRequestURL)) {\n+                                channelTracking.setChannel(ch);\n+                                chTracked = true;\n+                                break;\n+                            }\n+                        }\n+                        if (!chTracked) {\n+                            channelTracker.add(new ChannelTracking(ch, httpRequestURL));\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(COMMON_HANDLER);\n+                    commonHandler.setURL(httpRequestURLFull);\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(AUTH_HANDLER);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case AMCREST_THING:\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(AMCREST_HANDLER);\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case INSTAR_THING:\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(INSTAR_HANDLER);\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+                    ch.writeAndFlush(request);\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot(byte[] incommingSnapshot) {\n+        lockCurrentSnapshot.lock();\n+        try {\n+            currentSnapshot = incommingSnapshot;\n+            if (preroll > 0) {\n+                fifoSnapshotBuffer.add(incommingSnapshot);\n+                if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                    fifoSnapshotBuffer.removeFirst();\n+                }\n+            }\n+        } finally {\n+            lockCurrentSnapshot.unlock();\n+        }\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(incommingSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(incommingSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                // only happens every 8 seconds as some browsers need a frame that often to keep stream alive.\n+                sendMjpegFrame(incommingSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 60, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.debug(\"File server for camera at {} has started on port {} for all NIC's.\", ipAddress,\n+                            serverPort);\n+                    updateState(CHANNEL_MJPEG_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    cameraConfigError(\"Exception when starting server. Try changing the serverPort to another number.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setupSnapshotStreaming(boolean stream, ChannelHandlerContext ctx, boolean auto) {\n+        if (stream) {\n+            sendMjpegFirstPacket(ctx);\n+            if (auto) {\n+                autoSnapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                try {\n+                    sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                    // iOS uses a FIFO? and needs two frames to display a pic\n+                    sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                } finally {\n+                    lockCurrentSnapshot.unlock();\n+                }\n+                streamingAutoFps = true;\n+            } else {\n+                snapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                try {\n+                    sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+                } finally {\n+                    lockCurrentSnapshot.unlock();\n+                }\n+                streamingSnapshotMjpeg = true;\n+                startSnapshotPolling();\n+            }\n+        } else {\n+            snapshotMjpegChannelGroup.remove(ctx.channel());\n+            autoSnapshotMjpegChannelGroup.remove(ctx.channel());\n+            if (streamingSnapshotMjpeg && snapshotMjpegChannelGroup.isEmpty()) {\n+                streamingSnapshotMjpeg = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All snapshots.mjpeg streams have stopped.\");\n+            } else if (streamingAutoFps && autoSnapshotMjpegChannelGroup.isEmpty()) {\n+                streamingAutoFps = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All autofps.mjpeg streams have stopped.\");\n+            }\n+        }\n+    }\n+\n+    // If start is true the CTX is added to the list to stream video to, false stops\n+    // the stream.\n+    public void setupMjpegStreaming(boolean start, ChannelHandlerContext ctx) {\n+        if (start) {\n+            if (mjpegChannelGroup.isEmpty()) {// first stream being requested.\n+                mjpegChannelGroup.add(ctx.channel());\n+                if (mjpegUri.isEmpty() || mjpegUri.equals(\"ffmpeg\")) {\n+                    sendMjpegFirstPacket(ctx);\n+                    setupFfmpegFormat(ffmpegFormat.MJPEG);\n+                } else {\n+                    try {\n+                        // fix Dahua reboots when refreshing a mjpeg stream.\n+                        TimeUnit.MILLISECONDS.sleep(500);\n+                    } catch (InterruptedException e) {\n+                    }\n+                    sendHttpGET(mjpegUri);\n+                }\n+            } else if (ffmpegMjpeg != null) {// not first stream and we will use ffmpeg\n+                sendMjpegFirstPacket(ctx);\n+                mjpegChannelGroup.add(ctx.channel());\n+            } else {// not first stream and camera supplies the mjpeg source.\n+                ctx.channel().writeAndFlush(firstStreamedMsg);\n+                mjpegChannelGroup.add(ctx.channel());\n+            }\n+        } else {\n+            mjpegChannelGroup.remove(ctx.channel());\n+            if (mjpegChannelGroup.isEmpty()) {\n+                logger.debug(\"All ipcamera.mjpeg streams have stopped.\");\n+                if (mjpegUri.equals(\"ffmpeg\")) {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                } else if (!mjpegUri.isEmpty()) {\n+                    closeChannel(getTinyUrl(mjpegUri));\n+                } else {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (ChannelTracking channelTracking : channelTracker) {\n+                if (channelTracking.getRequestUrl().equals(url)) {\n+                    if (channelTracking.getChannel().isOpen()) {\n+                        channelTracking.getChannel().close();\n+                        return;\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    void cleanChannels() {\n+        ChannelTracking localTracking = null;\n+        lock.lock();\n+        try {\n+            for (ChannelTracking channelTracking : channelTracker) {\n+                logger.trace(\"Channel is open:{}, url is {}\", channelTracking.getChannel().isOpen(),\n+                        channelTracking.getRequestUrl());\n+                if (!channelTracking.getChannel().isOpen() && channelTracking.getReply().isEmpty()) {\n+                    localTracking = channelTracking;// Seems to create a deadlock if we remove whilst in loop\n+                    break;\n+                }\n+            }\n+            if (localTracking != null) {\n+                channelTracker.remove(localTracking);// clean up one closed channel.\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void storeHttpReply(String url, String content) {\n+        lock.lock();\n+        try {\n+            for (ChannelTracking channelTracking : channelTracker) {\n+                if (channelTracking.getRequestUrl().equals(url)) {\n+                    channelTracking.setReply(content);\n+                    return;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    // sends direct to ctx so can be either snapshots.mjpeg or normal mjpeg stream\n+    public void sendMjpegFirstPacket(ChannelHandlerContext ctx) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        String contentType = \"multipart/x-mixed-replace; boundary=\" + BOUNDARY;\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+        ctx.channel().writeAndFlush(response);\n+    }\n+\n+    public void sendMjpegFrame(byte[] jpg, ChannelGroup channelGroup) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        ByteBuf imageByteBuf = Unpooled.copiedBuffer(jpg);\n+        int length = imageByteBuf.readableBytes();\n+        String header = \"--\" + BOUNDARY + \"\\r\\n\" + \"content-type: image/jpeg\" + \"\\r\\n\" + \"content-length: \" + length\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuf headerBbuf = Unpooled.copiedBuffer(header, 0, header.length(), StandardCharsets.UTF_8);\n+        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+        streamToGroup(headerBbuf, channelGroup, false);\n+        streamToGroup(imageByteBuf, channelGroup, false);\n+        streamToGroup(footerBbuf, channelGroup, true);\n+    }\n+\n+    public void streamToGroup(Object msg, ChannelGroup channelGroup, boolean flush) {\n+        channelGroup.write(msg);\n+        if (flush) {\n+            channelGroup.flush();\n+        }\n+    }\n+\n+    private void storeSnapshots() {\n+        int count = 0;\n+        // Need to lock as fifoSnapshotBuffer is not thread safe and new snapshots can be incoming.\n+        lockCurrentSnapshot.lock();\n+        try {\n+            for (byte[] foo : fifoSnapshotBuffer) {\n+                File file = new File(ffmpegOutputFolder + \"snapshot\" + count + \".jpg\");\n+                count++;\n+                try {\n+                    OutputStream fos = new FileOutputStream(file);\n+                    fos.write(foo);\n+                    fos.close();\n+                } catch (FileNotFoundException e) {\n+                    logger.warn(\"FileNotFoundException {}\", e.getMessage());\n+                } catch (IOException e) {\n+                    logger.warn(\"IOException {}\", e.getMessage());\n+                }\n+            }\n+        } finally {\n+            lockCurrentSnapshot.unlock();\n+        }\n+    }\n+\n+    public void setupFfmpegFormat(ffmpegFormat format) {\n+        String inputOptions = cameraConfig.getFfmpegInputOptions();\n+        if (cameraConfig.getFfmpegOutput().isEmpty()) {\n+            logger.warn(\"The camera tried to use a FFmpeg feature when the output folder is not set.\");\n+            return;\n+        }\n+        if (rtspUri.isEmpty()) {\n+            logger.warn(\"The camera tried to use a FFmpeg feature when no valid input for FFmpeg is provided.\");\n+            return;\n+        }\n+        if (cameraConfig.getFfmpegLocation().isEmpty()) {\n+            logger.warn(\"The camera tried to use a FFmpeg feature when the location for FFmpeg is not known.\");\n+            return;\n+        }\n+        if (rtspUri.toLowerCase().contains(\"rtsp\")) {\n+            if (inputOptions.isEmpty()) {\n+                inputOptions = \"-rtsp_transport tcp\";\n+            } else {\n+                inputOptions = inputOptions + \" -rtsp_transport tcp\";\n+            }\n+        }\n+\n+        // Make sure the folder exists, if not create it.\n+        new File(ffmpegOutputFolder).mkdirs();\n+        switch (format) {\n+            case HLS:\n+                if (ffmpegHLS == null) {\n+                    if (!inputOptions.isEmpty()) {\n+                        ffmpegHLS = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(),\n+                                \"-hide_banner -loglevel warning \" + inputOptions, rtspUri,\n+                                cameraConfig.getHlsOutOptions(), ffmpegOutputFolder + \"ipcamera.m3u8\", username,\n+                                password);\n+                    } else {\n+                        ffmpegHLS = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(),\n+                                \"-hide_banner -loglevel warning\", rtspUri, cameraConfig.getHlsOutOptions(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    }\n+                }\n+                if (ffmpegHLS != null) {\n+                    ffmpegHLS.startConverting();\n+                }\n+                break;\n+            case GIF:\n+                if (preroll > 0) {\n+                    ffmpegGIF = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(),\n+                            \"-y -r 1 -hide_banner -loglevel warning\", ffmpegOutputFolder + \"snapshot%d.jpg\",\n+                            \"-frames:v \" + (preroll + postroll) + \" \" + cameraConfig.getGifOutOptions(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                } else {\n+                    if (!inputOptions.isEmpty()) {\n+                        inputOptions = \"-y -t \" + postroll + \" -hide_banner -loglevel warning \" + inputOptions;\n+                    } else {\n+                        inputOptions = \"-y -t \" + postroll + \" -hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegGIF = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(), inputOptions, rtspUri,\n+                            cameraConfig.getGifOutOptions(), ffmpegOutputFolder + gifFilename + \".gif\", username,\n+                            password);\n+                }\n+                if (preroll > 0) {\n+                    storeSnapshots();\n+                }\n+                if (ffmpegGIF != null) {\n+                    ffmpegGIF.startConverting();\n+                    if (gifHistory.isEmpty()) {\n+                        gifHistory = gifFilename;\n+                    } else if (!gifFilename.equals(\"ipcamera\")) {\n+                        gifHistory = gifFilename + \",\" + gifHistory;\n+                        if (gifHistoryLength > 49) {\n+                            int endIndex = gifHistory.lastIndexOf(\",\");\n+                            gifHistory = gifHistory.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_GIF_HISTORY, new StringType(gifHistory));\n+                }\n+                break;\n+            case RECORD:\n+                if (!inputOptions.isEmpty()) {\n+                    inputOptions = \"-y -t \" + mp4RecordTime + \" -hide_banner -loglevel warning \" + inputOptions;\n+                } else {\n+                    inputOptions = \"-y -t \" + mp4RecordTime + \" -hide_banner -loglevel warning\";\n+                }\n+                ffmpegRecord = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(), inputOptions, rtspUri,\n+                        cameraConfig.getMp4OutOptions(), ffmpegOutputFolder + mp4Filename + \".mp4\", username, password);\n+                if (mp4Preroll > 0) {\n+                    // fetchFromHLS(); todo: not done yet\n+                }\n+                if (ffmpegRecord != null) {\n+                    ffmpegRecord.startConverting();\n+                    if (mp4History.isEmpty()) {\n+                        mp4History = mp4Filename;\n+                    } else if (!mp4Filename.equals(\"ipcamera\")) {\n+                        mp4History = mp4Filename + \",\" + mp4History;\n+                        if (mp4HistoryLength > 49) {\n+                            int endIndex = mp4History.lastIndexOf(\",\");\n+                            mp4History = mp4History.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_MP4_HISTORY, new StringType(mp4History));\n+                }\n+                break;\n+            case RTSPHELPER:\n+                if (ffmpegRtspHelper != null) {\n+                    ffmpegRtspHelper.stopConverting();\n+                    if (!audioAlarmEnabled && !motionAlarmEnabled) {\n+                        return;\n+                    }\n+                }\n+                String input = (cameraConfig.getAlarmInputUrl().isEmpty()) ? rtspUri : cameraConfig.getAlarmInputUrl();\n+                String OutputOptions = \"-f null -\";\n+                String filterOptions = \"\";\n+                if (!audioAlarmEnabled) {\n+                    filterOptions = \"-an\";\n+                } else {\n+                    filterOptions = \"-af silencedetect=n=-\" + audioThreshold + \"dB:d=2\";\n+                }\n+                if (!motionAlarmEnabled && !ffmpegSnapshotGeneration) {\n+                    filterOptions = filterOptions.concat(\" -vn\");\n+                } else if (motionAlarmEnabled == true) {\n+                    filterOptions = filterOptions\n+                            .concat(\" -vf select='gte(scene,\" + motionThreshold + \")',metadata=print\");\n+                }\n+                if (!cameraConfig.getUser().isEmpty()) {\n+                    filterOptions += \" \";// add space as the Framework does not allow spaces at start of config.\n+                }\n+                ffmpegRtspHelper = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(), inputOptions, input,\n+                        filterOptions + cameraConfig.getMotionOptions(), OutputOptions, username, password);\n+                ffmpegRtspHelper.startConverting();\n+                break;\n+            case MJPEG:\n+                if (ffmpegMjpeg == null) {\n+                    if (inputOptions.isEmpty()) {\n+                        inputOptions = \"-hide_banner -loglevel warning\";\n+                    } else {\n+                        inputOptions = inputOptions + \" -hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegMjpeg = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(), inputOptions, rtspUri,\n+                            cameraConfig.getMjpegOptions(), \"http://127.0.0.1:\" + serverPort + \"/ipcamera.jpg\",\n+                            username, password);\n+                }\n+                if (ffmpegMjpeg != null) {\n+                    ffmpegMjpeg.startConverting();\n+                }\n+                break;\n+            case SNAPSHOT:\n+                // if mjpeg stream you can use ffmpeg -i input.h264 -codec:v copy -bsf:v mjpeg2jpeg output%03d.jpg\n+                if (ffmpegSnapshot == null) {\n+                    if (inputOptions.isEmpty()) {\n+                        // iFrames only\n+                        inputOptions = \"-threads 1 -skip_frame nokey -hide_banner -loglevel warning\";\n+                    } else {\n+                        inputOptions = inputOptions + \" -threads 1 -skip_frame nokey -hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegSnapshot = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(), inputOptions, rtspUri,\n+                            \"-an -vsync vfr -update 1\", \"http://127.0.0.1:\" + serverPort + \"/snapshot.jpg\", username,\n+                            password);\n+                }\n+                if (ffmpegSnapshot != null) {\n+                    ffmpegSnapshot.startConverting();\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void noMotionDetected(String thisAlarmsChannel) {\n+        setChannelState(thisAlarmsChannel, OnOffType.OFF);\n+        firstMotionAlarm = false;\n+        motionAlarmUpdateSnapshot = false;\n+        motionDetected = false;\n+        if (streamingAutoFps) {\n+            stopSnapshotPolling();\n+        } else if (updateImageWhen.contains(\"4\")) { // During Motion Alarms\n+            stopSnapshotPolling();\n+        }\n+    }\n+\n+    // Change alarms that are not counted as motion detecting.\n+    public void changeAlarmState(String thisAlarmsChannel, String state) {\n+        updateState(thisAlarmsChannel, OnOffType.valueOf(state));\n+    }\n+\n+    public void motionDetected(String thisAlarmsChannel) {\n+        updateState(CHANNEL_LAST_MOTION_TYPE, new StringType(thisAlarmsChannel));\n+        updateState(thisAlarmsChannel, OnOffType.ON);\n+        motionDetected = true;\n+        if (streamingAutoFps) {\n+            startSnapshotPolling();\n+        }\n+        if (updateImageWhen.contains(\"2\")) {\n+            if (!firstMotionAlarm) {\n+                if (!snapshotUri.isEmpty()) {\n+                    sendHttpGET(snapshotUri);\n+                }\n+                firstMotionAlarm = true;// reset back to false when the jpg arrives.\n+            }\n+        } else if (updateImageWhen.contains(\"4\")) { // During Motion Alarms\n+            if (!snapshotPolling) {\n+                startSnapshotPolling();\n+            }\n+            firstMotionAlarm = true;\n+            motionAlarmUpdateSnapshot = true;\n+        }\n+    }\n+\n+    public void audioDetected() {\n+        updateState(CHANNEL_AUDIO_ALARM, OnOffType.ON);\n+        if (updateImageWhen.contains(\"3\")) {\n+            if (!firstAudioAlarm) {\n+                if (!snapshotUri.isEmpty()) {\n+                    sendHttpGET(snapshotUri);\n+                }\n+                firstAudioAlarm = true;// reset back to false when the jpg arrives.\n+            }\n+        } else if (updateImageWhen.contains(\"5\")) {// During audio alarms\n+            firstAudioAlarm = true;\n+            audioAlarmUpdateSnapshot = true;\n+        }\n+    }\n+\n+    public void noAudioDetected() {\n+        setChannelState(CHANNEL_AUDIO_ALARM, OnOffType.OFF);\n+        firstAudioAlarm = false;\n+        audioAlarmUpdateSnapshot = false;\n+    }\n+\n+    public String returnValueFromString(String rawString, String searchedString) {\n+        String result = \"\";\n+        int index = rawString.indexOf(searchedString);\n+        if (index != -1) // -1 means \"not found\"\n+        {\n+            result = rawString.substring(index + searchedString.length(), rawString.length());\n+            index = result.indexOf(\"\\r\\n\"); // find a carriage return to find the end of the value.\n+            if (index == -1) {\n+                return result; // Did not find a carriage return.\n+            } else {\n+                return result.substring(0, index);\n+            }\n+        }\n+        return \"\"; // Did not find the String we were searching for\n+    }\n+\n+    private void sendPTZRequest() {\n+        onvifCamera.sendPTZRequest(\"AbsoluteMove\");\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_PAN:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        updateState(CHANNEL_PAN, new PercentType(Math.round(onvifCamera.getAbsolutePan())));\n+                    }\n+                    return;\n+                case CHANNEL_TILT:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        updateState(CHANNEL_TILT, new PercentType(Math.round(onvifCamera.getAbsoluteTilt())));\n+                    }\n+                    return;\n+                case CHANNEL_ZOOM:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        updateState(CHANNEL_ZOOM, new PercentType(Math.round(onvifCamera.getAbsoluteZoom())));\n+                    }\n+                    return;\n+                case CHANNEL_GOTO_PRESET:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        onvifCamera.sendPTZRequest(\"GetPresets\");\n+                    }\n+                    return;\n+            }\n+        } // caution \"REFRESH\" can still progress to brand Handlers below the else.\n+        else {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MP4_HISTORY_LENGTH:\n+                    if (DecimalType.ZERO.equals(command)) {\n+                        mp4HistoryLength = 0;\n+                        mp4History = \"\";\n+                        setChannelState(CHANNEL_MP4_HISTORY, new StringType(mp4History));\n+                    }\n+                    return;\n+                case CHANNEL_GIF_HISTORY_LENGTH:\n+                    if (DecimalType.ZERO.equals(command)) {\n+                        gifHistoryLength = 0;\n+                        gifHistory = \"\";\n+                        setChannelState(CHANNEL_GIF_HISTORY, new StringType(gifHistory));\n+                    }\n+                    return;\n+                case CHANNEL_FFMPEG_MOTION_CONTROL:\n+                    if (OnOffType.ON.equals(command)) {\n+                        motionAlarmEnabled = true;\n+                    } else if (OnOffType.OFF.equals(command) || DecimalType.ZERO.equals(command)) {\n+                        motionAlarmEnabled = false;\n+                        noMotionDetected(CHANNEL_MOTION_ALARM);\n+                    } else {\n+                        motionAlarmEnabled = true;\n+                        motionThreshold = Double.valueOf(command.toString());\n+                        motionThreshold = motionThreshold / 10000;\n+                    }\n+                    setupFfmpegFormat(ffmpegFormat.RTSPHELPER);\n+                    return;\n+                case CHANNEL_GIF_FILENAME:\n+                    gifFilename = command.toString();\n+                    if (gifFilename.isEmpty()) {\n+                        gifFilename = \"ipcamera\";\n+                    }\n+                    return;\n+                case CHANNEL_MP4_FILENAME:\n+                    mp4Filename = command.toString();\n+                    if (mp4Filename.isEmpty()) {\n+                        mp4Filename = \"ipcamera\";\n+                    }\n+                    return;\n+                case CHANNEL_RECORD_MP4:\n+                    mp4RecordTime = Integer.parseInt(command.toString());\n+                    setupFfmpegFormat(ffmpegFormat.RECORD);\n+                    return;\n+                case CHANNEL_START_STREAM:\n+                    if (OnOffType.ON.equals(command)) {\n+                        setupFfmpegFormat(ffmpegFormat.HLS);\n+                        if (ffmpegHLS != null) {\n+                            ffmpegHLS.setKeepAlive(-1);// will keep running till manually stopped.\n+                        }\n+                    } else {\n+                        if (ffmpegHLS != null) {\n+                            ffmpegHLS.setKeepAlive(1);\n+                        }\n+                    }\n+                    return;\n+                case CHANNEL_EXTERNAL_MOTION:\n+                    if (OnOffType.ON.equals(command)) {\n+                        motionDetected(CHANNEL_EXTERNAL_MOTION);\n+                    } else {\n+                        noMotionDetected(CHANNEL_EXTERNAL_MOTION);\n+                    }\n+                    return;\n+                case CHANNEL_GOTO_PRESET:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        onvifCamera.gotoPreset(Integer.valueOf(command.toString()));\n+                    }\n+                    return;\n+                case CHANNEL_POLL_IMAGE:\n+                    if (OnOffType.ON.equals(command)) {\n+                        if (snapshotUri.isEmpty()) {\n+                            ffmpegSnapshotGeneration = true;\n+                            setupFfmpegFormat(ffmpegFormat.SNAPSHOT);\n+                            updateImageChannel = false;\n+                        } else {\n+                            updateImageChannel = true;\n+                            sendHttpGET(snapshotUri);// Allows this to change Image FPS on demand\n+                        }\n+                    } else {\n+                        if (ffmpegSnapshot != null) {\n+                            ffmpegSnapshot.stopConverting();\n+                            ffmpegSnapshotGeneration = false;\n+                        }\n+                        updateImageChannel = false;\n+                    }\n+                    return;\n+                case CHANNEL_UPDATE_GIF:\n+                    if (OnOffType.ON.equals(command)) {\n+                        if (preroll > 0) {\n+                            snapCount = postroll;\n+                        } else {\n+                            setupFfmpegFormat(ffmpegFormat.GIF);\n+                        }\n+                    }\n+                    return;\n+                case CHANNEL_PAN:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        if (command instanceof IncreaseDecreaseType) {\n+                            if (command == IncreaseDecreaseType.INCREASE) {\n+                                if (cameraConfig.getPtzContinuous()) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveLeft\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveLeft\");\n+                                }\n+                            } else {\n+                                if (cameraConfig.getPtzContinuous()) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveRight\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveRight\");\n+                                }\n+                            }\n+                            return;\n+                        } else if (OnOffType.OFF.equals(command)) {\n+                            onvifCamera.sendPTZRequest(\"Stop\");\n+                            return;\n+                        }\n+                        onvifCamera.setAbsolutePan(Float.valueOf(command.toString()));\n+                        threadPool.schedule(this::sendPTZRequest, 500, TimeUnit.MILLISECONDS);\n+                    }\n+                    return;\n+                case CHANNEL_TILT:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        if (command instanceof IncreaseDecreaseType) {\n+                            if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                                if (cameraConfig.getPtzContinuous()) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveUp\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveUp\");\n+                                }\n+                            } else {\n+                                if (cameraConfig.getPtzContinuous()) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveDown\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveDown\");\n+                                }\n+                            }\n+                            return;\n+                        } else if (OnOffType.OFF.equals(command)) {\n+                            onvifCamera.sendPTZRequest(\"Stop\");\n+                            return;\n+                        }\n+                        onvifCamera.setAbsoluteTilt(Float.valueOf(command.toString()));\n+                        threadPool.schedule(this::sendPTZRequest, 500, TimeUnit.MILLISECONDS);\n+                    }\n+                    return;\n+                case CHANNEL_ZOOM:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        if (command instanceof IncreaseDecreaseType) {\n+                            if (IncreaseDecreaseType.INCREASE.equals(command)) {\n+                                if (cameraConfig.getPtzContinuous()) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveIn\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveIn\");\n+                                }\n+                            } else {\n+                                if (cameraConfig.getPtzContinuous()) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveOut\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveOut\");\n+                                }\n+                            }\n+                            return;\n+                        } else if (OnOffType.OFF.equals(command)) {\n+                            onvifCamera.sendPTZRequest(\"Stop\");\n+                            return;\n+                        }\n+                        onvifCamera.setAbsoluteZoom(Float.valueOf(command.toString()));\n+                        threadPool.schedule(this::sendPTZRequest, 500, TimeUnit.MILLISECONDS);\n+                    }\n+                    return;\n+            }\n+        }\n+        // commands and refresh now get passed to brand handlers\n+        switch (thing.getThingTypeUID().getId()) {\n+            case AMCREST_THING:\n+                AmcrestHandler amcrestHandler = new AmcrestHandler(getHandle());\n+                amcrestHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = amcrestHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            case DAHUA_THING:\n+                DahuaHandler dahuaHandler = new DahuaHandler(getHandle(), nvrChannel);\n+                dahuaHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = dahuaHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            case DOORBIRD_THING:\n+                DoorBirdHandler doorBirdHandler = new DoorBirdHandler(getHandle());\n+                doorBirdHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = doorBirdHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            case HIKVISION_THING:\n+                HikvisionHandler hikvisionHandler = new HikvisionHandler(getHandle(), nvrChannel);\n+                hikvisionHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = hikvisionHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            case FOSCAM_THING:\n+                FoscamHandler foscamHandler = new FoscamHandler(getHandle(), username, password);\n+                foscamHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = foscamHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            case INSTAR_THING:\n+                InstarHandler instarHandler = new InstarHandler(getHandle());\n+                instarHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = instarHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            default:\n+                HttpOnlyHandler defaultHandler = new HttpOnlyHandler(getHandle());\n+                defaultHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = defaultHandler.getLowPriorityRequests();\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void setChannelState(String channelToUpdate, State valueOf) {\n+        updateState(channelToUpdate, valueOf);\n+    }\n+\n+    void bringCameraOnline() {\n+        isOnline = true;\n+        updateStatus(ThingStatus.ONLINE);\n+        groupTracker.listOfOnlineCameraHandlers.add(this);\n+        groupTracker.listOfOnlineCameraUID.add(getThing().getUID().getId());\n+        if (cameraConnectionJob != null) {\n+            cameraConnectionJob.cancel(false);\n+        }\n+\n+        if (preroll > 0 || updateImageWhen.contains(\"1\")) {\n+            snapshotPolling = true;\n+            snapshotJob = threadPool.scheduleAtFixedRate(this::snapshotRunnable, 1000, cameraConfig.getPollTime(),\n+                    TimeUnit.MILLISECONDS);\n+        }\n+\n+        pollCameraJob = threadPool.scheduleWithFixedDelay(this::pollCameraRunnable, 1000, 8000, TimeUnit.MILLISECONDS);\n+\n+        if (!rtspUri.isEmpty()) {\n+            updateState(CHANNEL_RTSP_URL, new StringType(rtspUri));\n+        }\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_POLL_IMAGE, OnOffType.ON);\n+        } else {\n+            updateState(CHANNEL_POLL_IMAGE, OnOffType.OFF);\n+        }\n+        if (!groupTracker.listOfGroupHandlers.isEmpty()) {\n+            for (IpCameraGroupHandler handle : groupTracker.listOfGroupHandlers) {\n+                handle.cameraOnline(getThing().getUID().getId());\n+            }\n+        }\n+    }\n+\n+    void snapshotIsFfmpeg() {\n+        bringCameraOnline();\n+        snapshotUri = \"\";// ffmpeg is a valid option. Simplify further checks.\n+        logger.debug(\n+                \"Binding has no snapshot url. Will use your CPU and FFmpeg to create snapshots from the cameras RTSP.\");\n+        if (!rtspUri.isEmpty()) {\n+            updateImageChannel = false;\n+            ffmpegSnapshotGeneration = true;\n+            setupFfmpegFormat(ffmpegFormat.SNAPSHOT);\n+            updateState(CHANNEL_POLL_IMAGE, OnOffType.ON);\n+        } else {\n+            cameraConfigError(\"Binding can not find a RTSP url for this camera, please provide a FFmpeg Input URL.\");\n+        }\n+    }\n+\n+    void pollingCameraConnection() {\n+        if (thing.getThingTypeUID().getId().equals(GENERIC_THING)) {\n+            if (rtspUri.isEmpty()) {\n+                logger.warn(\"Binding has not been supplied with a FFmpeg Input URL, so some features will not work.\");\n+            }\n+            if (snapshotUri.isEmpty() || snapshotUri.equals(\"ffmpeg\")) {\n+                snapshotIsFfmpeg();\n+            } else {\n+                sendHttpRequest(\"GET\", snapshotUri, null);\n+            }\n+            return;\n+        }\n+        if (!onvifCamera.isConnected()) {\n+            logger.debug(\"About to connect to the IP Camera using the ONVIF PORT at IP:{}:{}\", ipAddress,\n+                    cameraConfig.getOnvifPort());\n+            onvifCamera.connect(thing.getThingTypeUID().getId().equals(ONVIF_THING));\n+        }\n+        if (snapshotUri.equals(\"ffmpeg\")) {\n+            snapshotIsFfmpeg();\n+        } else if (!snapshotUri.isEmpty()) {\n+            sendHttpRequest(\"GET\", snapshotUri, null);\n+        } else if (!rtspUri.isEmpty()) {\n+            snapshotIsFfmpeg();\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Camera failed to report a valid Snaphot and/or RTSP URL. See readme on how to use the SNAPSHOT_URL_OVERRIDE feature.\");\n+        }\n+    }\n+\n+    public void cameraConfigError(String reason) {\n+        // wont try to reconnect again due to a config error being the cause.\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, reason);\n+        restart();\n+    }\n+\n+    public void cameraCommunicationError(String reason) {\n+        // will try to reconnect again as camera may be rebooting.\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, reason);\n+        if (isOnline) {// if already offline dont try reconnecting in 6 seconds, we want 30sec wait.\n+            resetAndRetryConnecting();\n+        }\n+    }\n+\n+    boolean streamIsStopped(String url) {\n+        lock.lock();\n+        try {\n+            for (ChannelTracking channelTracking : channelTracker) {\n+                if (channelTracking.getRequestUrl().equals(url)) {\n+                    if (channelTracking.getChannel().isOpen()) {\n+                        return false;// stream is running.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+        return true; // Stream stopped or never started.\n+    }\n+\n+    void snapshotRunnable() {\n+        // Snapshot should be first to keep consistent time between shots\n+        sendHttpGET(snapshotUri);\n+        if (snapCount > 0) {\n+            if (--snapCount == 0) {\n+                setupFfmpegFormat(ffmpegFormat.GIF);\n+            }\n+        }\n+    }\n+\n+    public void stopSnapshotPolling() {\n+        if (!streamingSnapshotMjpeg && preroll == 0 && !updateImageWhen.contains(\"1\")) {\n+            snapshotPolling = false;\n+            if (snapshotJob != null) {\n+                snapshotJob.cancel(true);\n+            }\n+        } else if (updateImageWhen.contains(\"4\")) { // only during Motion Alarms\n+            snapshotPolling = false;\n+            if (snapshotJob != null) {\n+                snapshotJob.cancel(true);\n+            }\n+        }\n+    }\n+\n+    public void startSnapshotPolling() {\n+        if (snapshotPolling || ffmpegSnapshotGeneration) {\n+            return; // Already polling or creating with FFmpeg from RTSP\n+        }\n+        if (streamingSnapshotMjpeg || streamingAutoFps) {\n+            snapshotPolling = true;\n+            snapshotJob = threadPool.scheduleAtFixedRate(this::snapshotRunnable, 200, cameraConfig.getPollTime(),\n+                    TimeUnit.MILLISECONDS);\n+        } else if (updateImageWhen.contains(\"4\")) { // During Motion Alarms\n+            snapshotPolling = true;\n+            snapshotJob = threadPool.scheduleAtFixedRate(this::snapshotRunnable, 200, cameraConfig.getPollTime(),\n+                    TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    // runs every 8 seconds due to mjpeg streams not staying open unless they update this often.\n+    void pollCameraRunnable() {\n+        // Snapshot should be first to keep consistent time between shots\n+        if (!snapshotUri.isEmpty()) {\n+            if (updateImageChannel) {\n+                sendHttpGET(snapshotUri);\n+            }\n+        }\n+        if (streamingAutoFps) {\n+            updateAutoFps = true;\n+            if (!snapshotPolling && !ffmpegSnapshotGeneration) {\n+                // Dont need to poll if creating from RTSP stream with FFmpeg or we are polling at full rate already.\n+                sendHttpGET(snapshotUri);\n+            }\n+        }\n+        // NOTE: Use lowPriorityRequests if get request is not needed every poll.\n+        if (!lowPriorityRequests.isEmpty()) {\n+            if (lowPriorityCounter >= lowPriorityRequests.size()) {\n+                lowPriorityCounter = 0;\n+            }\n+            sendHttpGET(lowPriorityRequests.get(lowPriorityCounter++));\n+        }\n+        // what needs to be done every poll//\n+        switch (thing.getThingTypeUID().getId()) {\n+            case GENERIC_THING:\n+                break;\n+            case ONVIF_THING:\n+                if (!onvifCamera.isConnected()) {\n+                    onvifCamera.connect(true);\n+                }\n+                break;\n+            case INSTAR_THING:\n+                noMotionDetected(CHANNEL_MOTION_ALARM);\n+                noMotionDetected(CHANNEL_PIR_ALARM);\n+                noAudioDetected();\n+                break;\n+            case HIKVISION_THING:\n+                if (streamIsStopped(\"/ISAPI/Event/notification/alertStream\")) {\n+                    logger.info(\"The alarm stream was not running for camera {}, re-starting it now\", ipAddress);\n+                    sendHttpGET(\"/ISAPI/Event/notification/alertStream\");\n+                }\n+                break;\n+            case AMCREST_THING:\n+                sendHttpGET(\"/cgi-bin/eventManager.cgi?action=getEventIndexes&code=VideoMotion\");\n+                sendHttpGET(\"/cgi-bin/eventManager.cgi?action=getEventIndexes&code=AudioMutation\");\n+                break;\n+            case DAHUA_THING:\n+                // Check for alarms, channel for NVRs appears not to work at filtering.\n+                if (streamIsStopped(\"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\")) {\n+                    logger.info(\"The alarm stream was not running for camera {}, re-starting it now\", ipAddress);\n+                    sendHttpGET(\"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\");\n+                }\n+                break;\n+            case DOORBIRD_THING:\n+                // Check for alarms, channel for NVRs appears not to work at filtering.\n+                if (streamIsStopped(\"/bha-api/monitor.cgi?ring=doorbell,motionsensor\")) {\n+                    logger.info(\"The alarm stream was not running for camera {}, re-starting it now\", ipAddress);\n+                    sendHttpGET(\"/bha-api/monitor.cgi?ring=doorbell,motionsensor\");\n+                }\n+                break;\n+        }\n+        if (ffmpegHLS != null) {\n+            ffmpegHLS.checkKeepAlive();\n+        }\n+        if (openChannels.size() > 18 || channelTracker.size() > 18) {\n+            logger.debug(\"There are {} Channels being tracked, {} are open.\", channelTracker.size(),\n+                    openChannels.size());\n+            cleanChannels();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        cameraConfig = getConfigAs(CameraConfig.class);\n+        ipAddress = cameraConfig.getIp();\n+        username = cameraConfig.getUser();\n+        password = cameraConfig.getPassword();\n+        preroll = cameraConfig.getGifPreroll();\n+        postroll = cameraConfig.getGifPostroll();\n+        updateImageWhen = cameraConfig.getUpdateImageWhen();\n+        snapshotUri = getCorrectUrlFormat(cameraConfig.getSnapshotUrl());\n+        mjpegUri = getCorrectUrlFormat(cameraConfig.getMjpegUrl());\n+        nvrChannel = cameraConfig.getNvrChannel();\n+        selectedMediaProfile = cameraConfig.getOnvifMediaProfile();\n+        serverPort = cameraConfig.getServerPort();\n+        if (serverPort < 1) {\n+            logger.warn(\n+                    \"The serverPort is not set to a valid number which disables a lot of binding features. See readme for more info.\");\n+        } else if (serverPort < 1025) {\n+            logger.warn(\"The serverPort is <= 1024 and may cause permission errors under Linux, try a higher number.\");\n+        }\n+        rtspUri = cameraConfig.getFfmpegInput();\n+        ffmpegOutputFolder = cameraConfig.getFfmpegOutput();\n+        // Known cameras will connect quicker if we skip ONVIF questions.\n+        switch (thing.getThingTypeUID().getId()) {\n+            case AMCREST_THING:\n+            case DAHUA_THING:\n+                if (mjpegUri.isEmpty()) {\n+                    mjpegUri = \"/cgi-bin/mjpg/video.cgi?channel=\" + nvrChannel + \"&subtype=1\";\n+                }\n+                if (snapshotUri.isEmpty()) {\n+                    snapshotUri = \"/cgi-bin/snapshot.cgi?channel=\" + nvrChannel;\n+                }\n+                break;\n+            case DOORBIRD_THING:\n+                if (mjpegUri.isEmpty()) {\n+                    mjpegUri = \"/bha-api/video.cgi\";\n+                }\n+                if (snapshotUri.isEmpty()) {\n+                    snapshotUri = \"/bha-api/image.cgi\";\n+                }\n+                break;\n+            case FOSCAM_THING:\n+                // Foscam needs any special char like spaces (%20) to be encoded for URLs.\n+                username = Helper.encodeSpecialChars(username);\n+                password = Helper.encodeSpecialChars(password);\n+                if (mjpegUri.isEmpty()) {\n+                    mjpegUri = \"/cgi-bin/CGIStream.cgi?cmd=GetMJStream&usr=\" + username + \"&pwd=\" + password;\n+                }\n+                if (snapshotUri.isEmpty()) {\n+                    snapshotUri = \"/cgi-bin/CGIProxy.fcgi?usr=\" + username + \"&pwd=\" + password + \"&cmd=snapPicture2\";\n+                }\n+                break;\n+            case HIKVISION_THING:// The 02 gives you the first sub stream which needs to be set to MJPEG\n+                if (mjpegUri.isEmpty()) {\n+                    mjpegUri = \"/ISAPI/Streaming/channels/\" + nvrChannel + \"02\" + \"/httppreview\";\n+                }\n+                if (snapshotUri.isEmpty()) {\n+                    snapshotUri = \"/ISAPI/Streaming/channels/\" + nvrChannel + \"01/picture\";\n+                }\n+                break;\n+            case INSTAR_THING:\n+                if (snapshotUri.isEmpty()) {\n+                    snapshotUri = \"/tmpfs/snap.jpg\";\n+                }\n+                if (mjpegUri.isEmpty()) {\n+                    mjpegUri = \"/mjpegstream.cgi?-chn=12\";\n+                }\n+                break;\n+        }\n+\n+        // Onvif and Instar event handling needs the host IP and the server started.\n+        if (serverPort > 0) {\n+            startStreamServer(true);\n+        }\n+\n+        if (!thing.getThingTypeUID().getId().equals(GENERIC_THING)) {\n+            onvifCamera = new OnvifConnection(this, ipAddress + \":\" + cameraConfig.getOnvifPort(), username, password);\n+            onvifCamera.setSelectedMediaProfile(selectedMediaProfile);\n+            // Only use ONVIF events if it is not an API camera.\n+            onvifCamera.connect(thing.getThingTypeUID().getId().equals(ONVIF_THING));\n+        }\n+\n+        // for poll times above 5 seconds don't display a warning about the Image channel.\n+        if (9000 <= cameraConfig.getPollTime() && updateImageChannel) {\n+            logger.warn(\n+                    \"The Image channel is set to update more often than 8 seconds. This is not recommended. The Image channel is best used only for higher poll times. See the readme file on how to display the cameras picture for best results or use a higher poll time.\");\n+        }\n+        // Waiting 3 seconds for ONVIF to discover the urls before running.\n+        cameraConnectionJob = threadPool.scheduleWithFixedDelay(this::pollingCameraConnection, 4, 30, TimeUnit.SECONDS);\n+    }\n+\n+    // What the camera needs to re-connect if the initialize() is not called.\n+    private void resetAndRetryConnecting() {\n+        restart();\n+        initialize();\n+    }\n+\n+    // Called when camera goes offline but the main handler is not destroyed.\n+    private void restart() {\n+        isOnline = false;\n+        snapshotPolling = false;\n+        onvifCamera.disconnect();\n+        if (pollCameraJob != null) {\n+            pollCameraJob.cancel(true);\n+            pollCameraJob = null;\n+        }\n+        if (snapshotJob != null) {\n+            snapshotJob.cancel(true);\n+            snapshotJob = null;\n+        }\n+        if (cameraConnectionJob != null) {\n+            cameraConnectionJob.cancel(true);\n+            cameraConnectionJob = null;\n+        }\n+        threadPool.shutdown();\n+        threadPool = Executors.newScheduledThreadPool(4);\n+\n+        groupTracker.listOfOnlineCameraHandlers.remove(this);\n+        groupTracker.listOfOnlineCameraUID.remove(getThing().getUID().getId());\n+        // inform all group handlers that this camera has gone offline\n+        for (IpCameraGroupHandler handle : groupTracker.listOfGroupHandlers) {\n+            handle.cameraOffline(this);\n+        }\n+        basicAuth = \"\"; // clear out stored password hash\n+        useDigestAuth = false;\n+        startStreamServer(false);\n+        openChannels.close();\n+\n+        if (ffmpegHLS != null) {\n+            ffmpegHLS.stopConverting();\n+            ffmpegHLS = null;\n+        }\n+        if (ffmpegRecord != null) {\n+            ffmpegRecord.stopConverting();\n+            ffmpegRecord = null;\n+        }\n+        if (ffmpegGIF != null) {\n+            ffmpegGIF.stopConverting();\n+            ffmpegGIF = null;\n+        }\n+        if (ffmpegRtspHelper != null) {\n+            ffmpegRtspHelper.stopConverting();\n+            ffmpegRtspHelper = null;\n+        }\n+        if (ffmpegMjpeg != null) {\n+            ffmpegMjpeg.stopConverting();\n+            ffmpegMjpeg = null;\n+        }\n+        if (ffmpegSnapshot != null) {\n+            ffmpegSnapshot.stopConverting();\n+            ffmpegSnapshot = null;\n+        }\n+        lock.lock();\n+        try {\n+            channelTracker.clear();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        restart();", "originalCommit": "8b6c85c2e3c680bfdc9386b22e725fabea6727f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTM3NDEwNg==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r491374106", "bodyText": "DONE.", "author": "Skinah", "createdAt": "2020-09-19T10:37:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxNTUyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxNjEyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r489816125", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private Bootstrap bootstrap;\n          \n          \n            \n                private @Nullable Bootstrap bootstrap;", "author": "cpmeister", "createdAt": "2020-09-16T23:54:33Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/onvif/OnvifConnection.java", "diffHunk": "@@ -0,0 +1,795 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal.onvif;\n+\n+import static org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.*;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.text.SimpleDateFormat;\n+import java.util.Base64;\n+import java.util.Date;\n+import java.util.LinkedList;\n+import java.util.Random;\n+import java.util.TimeZone;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.ipcamera.internal.Helper;\n+import org.openhab.binding.ipcamera.internal.handler.IpCameraHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * The {@link OnvifConnection} This is a basic Netty implementation for connecting and communicating to ONVIF cameras.\n+ *\n+ *\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class OnvifConnection {\n+    @Nullable\n+    private Bootstrap bootstrap;", "originalCommit": "8b6c85c2e3c680bfdc9386b22e725fabea6727f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxNjMwMw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r489816303", "bodyText": "The logger should be declared at the top of the class but below any static fields.", "author": "cpmeister", "createdAt": "2020-09-16T23:55:08Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/onvif/OnvifConnection.java", "diffHunk": "@@ -0,0 +1,795 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal.onvif;\n+\n+import static org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.*;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.text.SimpleDateFormat;\n+import java.util.Base64;\n+import java.util.Date;\n+import java.util.LinkedList;\n+import java.util.Random;\n+import java.util.TimeZone;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.ipcamera.internal.Helper;\n+import org.openhab.binding.ipcamera.internal.handler.IpCameraHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * The {@link OnvifConnection} This is a basic Netty implementation for connecting and communicating to ONVIF cameras.\n+ *\n+ *\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class OnvifConnection {\n+    @Nullable\n+    private Bootstrap bootstrap;\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private String ipAddress = \"\";\n+    private String user = \"\";\n+    private String password = \"\";\n+    private int onvifPort = 80;\n+    private String deviceXAddr = \"/onvif/device_service\";\n+    private String eventXAddr = \"/onvif/device_service\";\n+    private String mediaXAddr = \"/onvif/device_service\";\n+    @SuppressWarnings(\"unused\")\n+    private String imagingXAddr = \"/onvif/device_service\";\n+    private String ptzXAddr = \"/onvif/ptz_service\";\n+    private String subscriptionXAddr = \"/onvif/device_service\";\n+    private boolean isConnected = false;\n+    private int mediaProfileIndex = 0;\n+    private String snapshotUri = \"\";\n+    private String rtspUri = \"\";\n+    private IpCameraHandler ipCameraHandler;\n+    private boolean usingEvents = false;\n+\n+    // These hold the cameras PTZ position in the range that the camera uses, ie\n+    // mine is -1 to +1\n+    private Float panRangeMin = -1.0f;\n+    private Float panRangeMax = 1.0f;\n+    private Float tiltRangeMin = -1.0f;\n+    private Float tiltRangeMax = 1.0f;\n+    private Float zoomMin = 0.0f;\n+    private Float zoomMax = 1.0f;\n+    // These hold the PTZ values for updating Openhabs controls in 0-100 range\n+    private Float currentPanPercentage = 0.0f;\n+    private Float currentTiltPercentage = 0.0f;\n+    private Float currentZoomPercentage = 0.0f;\n+    private Float currentPanCamValue = 0.0f;\n+    private Float currentTiltCamValue = 0.0f;\n+    private Float currentZoomCamValue = 0.0f;\n+    private String ptzNodeToken = \"000\";\n+    private String ptzConfigToken = \"000\";\n+    private int presetTokenIndex = 0;\n+    private LinkedList<String> presetTokens = new LinkedList<>();\n+    private LinkedList<String> mediaProfileTokens = new LinkedList<>();\n+    private boolean ptzDevice = true;\n+    private final Logger logger = LoggerFactory.getLogger(getClass());", "originalCommit": "8b6c85c2e3c680bfdc9386b22e725fabea6727f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg0NTE1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r490845153", "bodyText": "DONE", "author": "Skinah", "createdAt": "2020-09-18T10:12:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxNjMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxNjYzNw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r489816637", "bodyText": "getXml is a hefty method, so you should cache the result in a local variable so you don't call it twice.", "author": "cpmeister", "createdAt": "2020-09-16T23:56:21Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/onvif/OnvifConnection.java", "diffHunk": "@@ -0,0 +1,795 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal.onvif;\n+\n+import static org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.*;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.text.SimpleDateFormat;\n+import java.util.Base64;\n+import java.util.Date;\n+import java.util.LinkedList;\n+import java.util.Random;\n+import java.util.TimeZone;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.ipcamera.internal.Helper;\n+import org.openhab.binding.ipcamera.internal.handler.IpCameraHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * The {@link OnvifConnection} This is a basic Netty implementation for connecting and communicating to ONVIF cameras.\n+ *\n+ *\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class OnvifConnection {\n+    @Nullable\n+    private Bootstrap bootstrap;\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private String ipAddress = \"\";\n+    private String user = \"\";\n+    private String password = \"\";\n+    private int onvifPort = 80;\n+    private String deviceXAddr = \"/onvif/device_service\";\n+    private String eventXAddr = \"/onvif/device_service\";\n+    private String mediaXAddr = \"/onvif/device_service\";\n+    @SuppressWarnings(\"unused\")\n+    private String imagingXAddr = \"/onvif/device_service\";\n+    private String ptzXAddr = \"/onvif/ptz_service\";\n+    private String subscriptionXAddr = \"/onvif/device_service\";\n+    private boolean isConnected = false;\n+    private int mediaProfileIndex = 0;\n+    private String snapshotUri = \"\";\n+    private String rtspUri = \"\";\n+    private IpCameraHandler ipCameraHandler;\n+    private boolean usingEvents = false;\n+\n+    // These hold the cameras PTZ position in the range that the camera uses, ie\n+    // mine is -1 to +1\n+    private Float panRangeMin = -1.0f;\n+    private Float panRangeMax = 1.0f;\n+    private Float tiltRangeMin = -1.0f;\n+    private Float tiltRangeMax = 1.0f;\n+    private Float zoomMin = 0.0f;\n+    private Float zoomMax = 1.0f;\n+    // These hold the PTZ values for updating Openhabs controls in 0-100 range\n+    private Float currentPanPercentage = 0.0f;\n+    private Float currentTiltPercentage = 0.0f;\n+    private Float currentZoomPercentage = 0.0f;\n+    private Float currentPanCamValue = 0.0f;\n+    private Float currentTiltCamValue = 0.0f;\n+    private Float currentZoomCamValue = 0.0f;\n+    private String ptzNodeToken = \"000\";\n+    private String ptzConfigToken = \"000\";\n+    private int presetTokenIndex = 0;\n+    private LinkedList<String> presetTokens = new LinkedList<>();\n+    private LinkedList<String> mediaProfileTokens = new LinkedList<>();\n+    private boolean ptzDevice = true;\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    public OnvifConnection(IpCameraHandler ipCameraHandler, String ipAddress, String user, String password) {\n+        this.ipCameraHandler = ipCameraHandler;\n+        if (!ipAddress.isEmpty()) {\n+            this.user = user;\n+            this.password = password;\n+            getIPandPortFromUrl(ipAddress);\n+        }\n+    }\n+\n+    String getXml(String requestType) {\n+        switch (requestType) {\n+            case \"AbsoluteMove\":\n+                return \"<AbsoluteMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex) + \"</ProfileToken><Position><PanTilt x=\\\"\"\n+                        + currentPanCamValue + \"\\\" y=\\\"\" + currentTiltCamValue\n+                        + \"\\\" space=\\\"http://www.onvif.org/ver10/tptz/PanTiltSpaces/PositionGenericSpace\\\">\\n\"\n+                        + \"</PanTilt>\\n\" + \"<Zoom x=\\\"\" + currentZoomCamValue\n+                        + \"\\\" space=\\\"http://www.onvif.org/ver10/tptz/ZoomSpaces/PositionGenericSpace\\\">\\n\"\n+                        + \"</Zoom>\\n\" + \"</Position>\\n\"\n+                        + \"<Speed><PanTilt x=\\\"0.1\\\" y=\\\"0.1\\\" space=\\\"http://www.onvif.org/ver10/tptz/PanTiltSpaces/GenericSpeedSpace\\\"></PanTilt><Zoom x=\\\"1.0\\\" space=\\\"http://www.onvif.org/ver10/tptz/ZoomSpaces/ZoomGenericSpeedSpace\\\"></Zoom>\\n\"\n+                        + \"</Speed></AbsoluteMove>\";\n+            case \"AddPTZConfiguration\": // not tested to work yet\n+                return \"<AddPTZConfiguration xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex) + \"</ProfileToken><ConfigurationToken>\"\n+                        + ptzConfigToken + \"</ConfigurationToken></AddPTZConfiguration>\";\n+            case \"ContinuousMoveLeft\":\n+                return \"<ContinuousMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Velocity><PanTilt x=\\\"-0.5\\\" y=\\\"0\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Velocity></ContinuousMove>\";\n+            case \"ContinuousMoveRight\":\n+                return \"<ContinuousMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Velocity><PanTilt x=\\\"0.5\\\" y=\\\"0\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Velocity></ContinuousMove>\";\n+            case \"ContinuousMoveUp\":\n+                return \"<ContinuousMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Velocity><PanTilt x=\\\"0\\\" y=\\\"-0.5\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Velocity></ContinuousMove>\";\n+            case \"ContinuousMoveDown\":\n+                return \"<ContinuousMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Velocity><PanTilt x=\\\"0\\\" y=\\\"0.5\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Velocity></ContinuousMove>\";\n+            case \"Stop\":\n+                return \"<Stop xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><PanTilt>true</PanTilt><Zoom>true</Zoom></Stop>\";\n+            case \"ContinuousMoveIn\":\n+                return \"<ContinuousMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Velocity><Zoom x=\\\"0.5\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Velocity></ContinuousMove>\";\n+            case \"ContinuousMoveOut\":\n+                return \"<ContinuousMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Velocity><Zoom x=\\\"-0.5\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Velocity></ContinuousMove>\";\n+            case \"CreatePullPointSubscription\":\n+                return \"<CreatePullPointSubscription xmlns=\\\"http://www.onvif.org/ver10/events/wsdl\\\"><InitialTerminationTime>PT600S</InitialTerminationTime></CreatePullPointSubscription>\";\n+            case \"GetCapabilities\":\n+                return \"<GetCapabilities xmlns=\\\"http://www.onvif.org/ver10/device/wsdl\\\"><Category>All</Category></GetCapabilities>\";\n+\n+            case \"GetDeviceInformation\":\n+                return \"<GetDeviceInformation xmlns=\\\"http://www.onvif.org/ver10/device/wsdl\\\"/>\";\n+            case \"GetProfiles\":\n+                return \"<GetProfiles xmlns=\\\"http://www.onvif.org/ver10/media/wsdl\\\"/>\";\n+            case \"GetServiceCapabilities\":\n+                return \"<GetServiceCapabilities xmlns=\\\"http://docs.oasis-open.org/wsn/b-2/\\\"></GetServiceCapabilities>\";\n+            case \"GetSnapshotUri\":\n+                return \"<GetSnapshotUri xmlns=\\\"http://www.onvif.org/ver10/media/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex) + \"</ProfileToken></GetSnapshotUri>\";\n+            case \"GetStreamUri\":\n+                return \"<GetStreamUri xmlns=\\\"http://www.onvif.org/ver10/media/wsdl\\\"><StreamSetup><Stream xmlns=\\\"http://www.onvif.org/ver10/schema\\\">RTP-Unicast</Stream><Transport xmlns=\\\"http://www.onvif.org/ver10/schema\\\"><Protocol>RTSP</Protocol></Transport></StreamSetup><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex) + \"</ProfileToken></GetStreamUri>\";\n+            case \"GetSystemDateAndTime\":\n+                return \"<GetSystemDateAndTime xmlns=\\\"http://www.onvif.org/ver10/device/wsdl\\\"/>\";\n+            case \"Subscribe\":\n+                return \"<Subscribe xmlns=\\\"http://docs.oasis-open.org/wsn/b-2/\\\"><ConsumerReference><Address>http://\"\n+                        + ipCameraHandler.hostIp + \":\" + ipCameraHandler.serverPort\n+                        + \"/OnvifEvent</Address></ConsumerReference></Subscribe>\";\n+            case \"Unsubscribe\":\n+                return \"<Unsubscribe xmlns=\\\"http://docs.oasis-open.org/wsn/b-2/\\\"></Unsubscribe>\";\n+            case \"PullMessages\":\n+                return \"<PullMessages xmlns=\\\"http://www.onvif.org/ver10/events/wsdl\\\"><Timeout>PT8S</Timeout><MessageLimit>1</MessageLimit></PullMessages>\";\n+            case \"GetEventProperties\":\n+                return \"<GetEventProperties xmlns=\\\"http://www.onvif.org/ver10/events/wsdl\\\"/>\";\n+            case \"RelativeMoveLeft\":\n+                return \"<RelativeMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Translation><PanTilt x=\\\"0.05000000\\\" y=\\\"0\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Translation></RelativeMove>\";\n+            case \"RelativeMoveRight\":\n+                return \"<RelativeMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Translation><PanTilt x=\\\"-0.05000000\\\" y=\\\"0\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Translation></RelativeMove>\";\n+            case \"RelativeMoveUp\":\n+                return \"<RelativeMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Translation><PanTilt x=\\\"0\\\" y=\\\"0.100000000\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Translation></RelativeMove>\";\n+            case \"RelativeMoveDown\":\n+                return \"<RelativeMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Translation><PanTilt x=\\\"0\\\" y=\\\"-0.100000000\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Translation></RelativeMove>\";\n+            case \"RelativeMoveIn\":\n+                return \"<RelativeMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Translation><Zoom x=\\\"0.0240506344\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Translation></RelativeMove>\";\n+            case \"RelativeMoveOut\":\n+                return \"<RelativeMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Translation><Zoom x=\\\"-0.0240506344\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Translation></RelativeMove>\";\n+            case \"Renew\":\n+                return \"<Renew xmlns=\\\"http://docs.oasis-open.org/wsn/b-2\\\"><TerminationTime>PT1M</TerminationTime></Renew>\";\n+            case \"GetConfigurations\":\n+                return \"<GetConfigurations xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"></GetConfigurations>\";\n+            case \"GetConfigurationOptions\":\n+                return \"<GetConfigurationOptions xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ConfigurationToken>\"\n+                        + ptzConfigToken + \"</ConfigurationToken></GetConfigurationOptions>\";\n+            case \"GetConfiguration\":\n+                return \"<GetConfiguration xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><PTZConfigurationToken>\"\n+                        + ptzConfigToken + \"</PTZConfigurationToken></GetConfiguration>\";\n+            case \"SetConfiguration\":// not tested to work yet\n+                return \"<SetConfiguration xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><PTZConfiguration><NodeToken>\"\n+                        + ptzNodeToken\n+                        + \"</NodeToken><DefaultAbsolutePantTiltPositionSpace>AbsolutePanTiltPositionSpace</DefaultAbsolutePantTiltPositionSpace><DefaultAbsoluteZoomPositionSpace>AbsoluteZoomPositionSpace</DefaultAbsoluteZoomPositionSpace></PTZConfiguration></SetConfiguration>\";\n+            case \"GetNodes\":\n+                return \"<GetNodes xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"></GetNodes>\";\n+            case \"GetStatus\":\n+                return \"<GetStatus xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex) + \"</ProfileToken></GetStatus>\";\n+            case \"GotoPreset\":\n+                return \"<GotoPreset xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex) + \"</ProfileToken><PresetToken>\"\n+                        + presetTokens.get(presetTokenIndex)\n+                        + \"</PresetToken><Speed><PanTilt x=\\\"0.0\\\" y=\\\"0.0\\\" space=\\\"\\\"></PanTilt><Zoom x=\\\"0.0\\\" space=\\\"\\\"></Zoom></Speed></GotoPreset>\";\n+            case \"GetPresets\":\n+                return \"<GetPresets xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex) + \"</ProfileToken></GetPresets>\";\n+        }\n+        return \"notfound\";\n+    }\n+\n+    public void processReply(String message) {\n+        logger.trace(\"Onvif reply is:{}\", message);\n+        if (message.contains(\"PullMessagesResponse\")) {\n+            eventRecieved(message);\n+        } else if (message.contains(\"RenewResponse\")) {\n+            sendOnvifRequest(requestBuilder(\"PullMessages\", subscriptionXAddr));\n+        } else if (message.contains(\"GetSystemDateAndTimeResponse\")) {// 1st to be sent.\n+            isConnected = true;\n+            sendOnvifRequest(requestBuilder(\"GetCapabilities\", deviceXAddr));\n+            parseDateAndTime(message);\n+            logger.debug(\"Openhabs UTC dateTime is:{}\", getUTCdateTime());\n+        } else if (message.contains(\"GetCapabilitiesResponse\")) {// 2nd to be sent.\n+            parseXAddr(message);\n+            sendOnvifRequest(requestBuilder(\"GetProfiles\", mediaXAddr));\n+        } else if (message.contains(\"GetProfilesResponse\")) {// 3rd to be sent.\n+            parseProfiles(message);\n+            sendOnvifRequest(requestBuilder(\"GetSnapshotUri\", mediaXAddr));\n+            sendOnvifRequest(requestBuilder(\"GetStreamUri\", mediaXAddr));\n+            if (ptzDevice) {\n+                sendPTZRequest(\"GetNodes\");\n+            }\n+            if (usingEvents) {// stops API cameras from getting sent ONVIF events.\n+                sendOnvifRequest(requestBuilder(\"GetEventProperties\", eventXAddr));\n+                sendOnvifRequest(requestBuilder(\"GetServiceCapabilities\", eventXAddr));\n+            }\n+        } else if (message.contains(\"GetServiceCapabilitiesResponse\")) {\n+            if (message.contains(\"WSSubscriptionPolicySupport=\\\"true\\\"\")) {\n+                sendOnvifRequest(requestBuilder(\"Subscribe\", eventXAddr));\n+            }\n+        } else if (message.contains(\"GetEventPropertiesResponse\")) {\n+            sendOnvifRequest(requestBuilder(\"CreatePullPointSubscription\", eventXAddr));\n+        } else if (message.contains(\"SubscribeResponse\")) {\n+            logger.info(\"Onvif Subscribe appears to be working for Alarms/Events.\");\n+        } else if (message.contains(\"CreatePullPointSubscriptionResponse\")) {\n+            subscriptionXAddr = removeIPfromUrl(Helper.fetchXML(message, \"SubscriptionReference>\", \"Address>\"));\n+            logger.debug(\"subscriptionXAddr={}\", subscriptionXAddr);\n+            sendOnvifRequest(requestBuilder(\"PullMessages\", subscriptionXAddr));\n+        } else if (message.contains(\"GetStatusResponse\")) {\n+            processPTZLocation(message);\n+        } else if (message.contains(\"GetPresetsResponse\")) {\n+            presetTokens = listOfResults(message, \"<tptz:Preset\", \"token=\\\"\");\n+        } else if (message.contains(\"GetConfigurationsResponse\")) {\n+            sendPTZRequest(\"GetPresets\");\n+            ptzConfigToken = Helper.fetchXML(message, \"PTZConfiguration\", \"token=\\\"\");\n+            logger.debug(\"ptzConfigToken={}\", ptzConfigToken);\n+            sendPTZRequest(\"GetConfigurationOptions\");\n+        } else if (message.contains(\"GetNodesResponse\")) {\n+            sendPTZRequest(\"GetStatus\");\n+            ptzNodeToken = Helper.fetchXML(message, \"\", \"token=\\\"\");\n+            logger.debug(\"ptzNodeToken={}\", ptzNodeToken);\n+            sendPTZRequest(\"GetConfigurations\");\n+        } else if (message.contains(\"GetDeviceInformationResponse\")) {\n+            logger.debug(\"GetDeviceInformationResponse recieved\");\n+        } else if (message.contains(\"GetSnapshotUriResponse\")) {\n+            snapshotUri = removeIPfromUrl(Helper.fetchXML(message, \":MediaUri\", \":Uri\"));\n+            logger.debug(\"GetSnapshotUri:{}\", snapshotUri);\n+            if (ipCameraHandler.snapshotUri.isEmpty()) {\n+                ipCameraHandler.snapshotUri = snapshotUri;\n+            }\n+        } else if (message.contains(\"GetStreamUriResponse\")) {\n+            rtspUri = Helper.fetchXML(message, \":MediaUri\", \":Uri>\");\n+            logger.debug(\"GetStreamUri:{}\", rtspUri);\n+            if (ipCameraHandler.rtspUri.isEmpty()) {\n+                ipCameraHandler.rtspUri = rtspUri;\n+            }\n+        }\n+    }\n+\n+    HttpRequest requestBuilder(String requestType, String xAddr) {\n+        logger.trace(\"Sending ONVIF request:{}\", requestType);\n+        String security = \"\";\n+        String extraEnvelope = \" xmlns:a=\\\"http://www.w3.org/2005/08/addressing\\\"\";\n+        String headerTo = \"\";\n+        if (requestType.equals(\"CreatePullPointSubscription\") || requestType.equals(\"PullMessages\")\n+                || requestType.equals(\"Renew\") || requestType.equals(\"Unsubscribe\")) {\n+            headerTo = \"<a:To s:mustUnderstand=\\\"1\\\">http://\" + ipAddress + xAddr + \"</a:To>\";\n+        }\n+        if (!password.isEmpty()) {\n+            String nonce = createNonce();\n+            String dateTime = getUTCdateTime();\n+            String digest = createDigest(nonce, dateTime);\n+            security = \"<Security s:mustUnderstand=\\\"1\\\" xmlns=\\\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd\\\"><UsernameToken><Username>\"\n+                    + user\n+                    + \"</Username><Password Type=\\\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest\\\">\"\n+                    + digest\n+                    + \"</Password><Nonce EncodingType=\\\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary\\\">\"\n+                    + encodeBase64(nonce)\n+                    + \"</Nonce><Created xmlns=\\\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\\\">\"\n+                    + dateTime + \"</Created></UsernameToken></Security>\";\n+        }\n+        String headers = \"<s:Header>\" + security + headerTo + \"</s:Header>\";\n+\n+        if (requestType.equals(\"GetSystemDateAndTime\")) {\n+            extraEnvelope = \"\";\n+            headers = \"\";\n+        }\n+\n+        FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"POST\"), xAddr);\n+        request.headers().add(\"Content-Type\", \"application/soap+xml\");\n+        request.headers().add(\"charset\", \"utf-8\");\n+        if (onvifPort != 80) {\n+            request.headers().set(\"Host\", ipAddress + \":\" + onvifPort);\n+        } else {\n+            request.headers().set(\"Host\", ipAddress);\n+        }\n+        request.headers().set(\"Connection\", HttpHeaderValues.CLOSE);\n+        request.headers().set(\"Accept-Encoding\", \"gzip, deflate\");\n+        String fullXml = \"<s:Envelope xmlns:s=\\\"http://www.w3.org/2003/05/soap-envelope\\\"\" + extraEnvelope + \">\"\n+                + headers\n+                + \"<s:Body xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:xsd=\\\"http://www.w3.org/2001/XMLSchema\\\">\"\n+                + getXml(requestType) + \"</s:Body></s:Envelope>\";\n+        String actionString = Helper.fetchXML(getXml(requestType), requestType, \"xmlns=\\\"\");", "originalCommit": "8b6c85c2e3c680bfdc9386b22e725fabea6727f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg2MzU1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r490863555", "bodyText": "DONE", "author": "Skinah", "createdAt": "2020-09-18T10:49:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxNjYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxNzA2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r489817063", "bodyText": "You should make requestType an enum.", "author": "cpmeister", "createdAt": "2020-09-16T23:57:43Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/onvif/OnvifConnection.java", "diffHunk": "@@ -0,0 +1,795 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal.onvif;\n+\n+import static org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.*;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.text.SimpleDateFormat;\n+import java.util.Base64;\n+import java.util.Date;\n+import java.util.LinkedList;\n+import java.util.Random;\n+import java.util.TimeZone;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.ipcamera.internal.Helper;\n+import org.openhab.binding.ipcamera.internal.handler.IpCameraHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * The {@link OnvifConnection} This is a basic Netty implementation for connecting and communicating to ONVIF cameras.\n+ *\n+ *\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class OnvifConnection {\n+    @Nullable\n+    private Bootstrap bootstrap;\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private String ipAddress = \"\";\n+    private String user = \"\";\n+    private String password = \"\";\n+    private int onvifPort = 80;\n+    private String deviceXAddr = \"/onvif/device_service\";\n+    private String eventXAddr = \"/onvif/device_service\";\n+    private String mediaXAddr = \"/onvif/device_service\";\n+    @SuppressWarnings(\"unused\")\n+    private String imagingXAddr = \"/onvif/device_service\";\n+    private String ptzXAddr = \"/onvif/ptz_service\";\n+    private String subscriptionXAddr = \"/onvif/device_service\";\n+    private boolean isConnected = false;\n+    private int mediaProfileIndex = 0;\n+    private String snapshotUri = \"\";\n+    private String rtspUri = \"\";\n+    private IpCameraHandler ipCameraHandler;\n+    private boolean usingEvents = false;\n+\n+    // These hold the cameras PTZ position in the range that the camera uses, ie\n+    // mine is -1 to +1\n+    private Float panRangeMin = -1.0f;\n+    private Float panRangeMax = 1.0f;\n+    private Float tiltRangeMin = -1.0f;\n+    private Float tiltRangeMax = 1.0f;\n+    private Float zoomMin = 0.0f;\n+    private Float zoomMax = 1.0f;\n+    // These hold the PTZ values for updating Openhabs controls in 0-100 range\n+    private Float currentPanPercentage = 0.0f;\n+    private Float currentTiltPercentage = 0.0f;\n+    private Float currentZoomPercentage = 0.0f;\n+    private Float currentPanCamValue = 0.0f;\n+    private Float currentTiltCamValue = 0.0f;\n+    private Float currentZoomCamValue = 0.0f;\n+    private String ptzNodeToken = \"000\";\n+    private String ptzConfigToken = \"000\";\n+    private int presetTokenIndex = 0;\n+    private LinkedList<String> presetTokens = new LinkedList<>();\n+    private LinkedList<String> mediaProfileTokens = new LinkedList<>();\n+    private boolean ptzDevice = true;\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    public OnvifConnection(IpCameraHandler ipCameraHandler, String ipAddress, String user, String password) {\n+        this.ipCameraHandler = ipCameraHandler;\n+        if (!ipAddress.isEmpty()) {\n+            this.user = user;\n+            this.password = password;\n+            getIPandPortFromUrl(ipAddress);\n+        }\n+    }\n+\n+    String getXml(String requestType) {\n+        switch (requestType) {\n+            case \"AbsoluteMove\":\n+                return \"<AbsoluteMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex) + \"</ProfileToken><Position><PanTilt x=\\\"\"\n+                        + currentPanCamValue + \"\\\" y=\\\"\" + currentTiltCamValue\n+                        + \"\\\" space=\\\"http://www.onvif.org/ver10/tptz/PanTiltSpaces/PositionGenericSpace\\\">\\n\"\n+                        + \"</PanTilt>\\n\" + \"<Zoom x=\\\"\" + currentZoomCamValue\n+                        + \"\\\" space=\\\"http://www.onvif.org/ver10/tptz/ZoomSpaces/PositionGenericSpace\\\">\\n\"\n+                        + \"</Zoom>\\n\" + \"</Position>\\n\"\n+                        + \"<Speed><PanTilt x=\\\"0.1\\\" y=\\\"0.1\\\" space=\\\"http://www.onvif.org/ver10/tptz/PanTiltSpaces/GenericSpeedSpace\\\"></PanTilt><Zoom x=\\\"1.0\\\" space=\\\"http://www.onvif.org/ver10/tptz/ZoomSpaces/ZoomGenericSpeedSpace\\\"></Zoom>\\n\"\n+                        + \"</Speed></AbsoluteMove>\";\n+            case \"AddPTZConfiguration\": // not tested to work yet\n+                return \"<AddPTZConfiguration xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex) + \"</ProfileToken><ConfigurationToken>\"\n+                        + ptzConfigToken + \"</ConfigurationToken></AddPTZConfiguration>\";\n+            case \"ContinuousMoveLeft\":\n+                return \"<ContinuousMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Velocity><PanTilt x=\\\"-0.5\\\" y=\\\"0\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Velocity></ContinuousMove>\";\n+            case \"ContinuousMoveRight\":\n+                return \"<ContinuousMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Velocity><PanTilt x=\\\"0.5\\\" y=\\\"0\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Velocity></ContinuousMove>\";\n+            case \"ContinuousMoveUp\":\n+                return \"<ContinuousMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Velocity><PanTilt x=\\\"0\\\" y=\\\"-0.5\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Velocity></ContinuousMove>\";\n+            case \"ContinuousMoveDown\":\n+                return \"<ContinuousMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Velocity><PanTilt x=\\\"0\\\" y=\\\"0.5\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Velocity></ContinuousMove>\";\n+            case \"Stop\":\n+                return \"<Stop xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><PanTilt>true</PanTilt><Zoom>true</Zoom></Stop>\";\n+            case \"ContinuousMoveIn\":\n+                return \"<ContinuousMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Velocity><Zoom x=\\\"0.5\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Velocity></ContinuousMove>\";\n+            case \"ContinuousMoveOut\":\n+                return \"<ContinuousMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Velocity><Zoom x=\\\"-0.5\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Velocity></ContinuousMove>\";\n+            case \"CreatePullPointSubscription\":\n+                return \"<CreatePullPointSubscription xmlns=\\\"http://www.onvif.org/ver10/events/wsdl\\\"><InitialTerminationTime>PT600S</InitialTerminationTime></CreatePullPointSubscription>\";\n+            case \"GetCapabilities\":\n+                return \"<GetCapabilities xmlns=\\\"http://www.onvif.org/ver10/device/wsdl\\\"><Category>All</Category></GetCapabilities>\";\n+\n+            case \"GetDeviceInformation\":\n+                return \"<GetDeviceInformation xmlns=\\\"http://www.onvif.org/ver10/device/wsdl\\\"/>\";\n+            case \"GetProfiles\":\n+                return \"<GetProfiles xmlns=\\\"http://www.onvif.org/ver10/media/wsdl\\\"/>\";\n+            case \"GetServiceCapabilities\":\n+                return \"<GetServiceCapabilities xmlns=\\\"http://docs.oasis-open.org/wsn/b-2/\\\"></GetServiceCapabilities>\";\n+            case \"GetSnapshotUri\":\n+                return \"<GetSnapshotUri xmlns=\\\"http://www.onvif.org/ver10/media/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex) + \"</ProfileToken></GetSnapshotUri>\";\n+            case \"GetStreamUri\":\n+                return \"<GetStreamUri xmlns=\\\"http://www.onvif.org/ver10/media/wsdl\\\"><StreamSetup><Stream xmlns=\\\"http://www.onvif.org/ver10/schema\\\">RTP-Unicast</Stream><Transport xmlns=\\\"http://www.onvif.org/ver10/schema\\\"><Protocol>RTSP</Protocol></Transport></StreamSetup><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex) + \"</ProfileToken></GetStreamUri>\";\n+            case \"GetSystemDateAndTime\":\n+                return \"<GetSystemDateAndTime xmlns=\\\"http://www.onvif.org/ver10/device/wsdl\\\"/>\";\n+            case \"Subscribe\":\n+                return \"<Subscribe xmlns=\\\"http://docs.oasis-open.org/wsn/b-2/\\\"><ConsumerReference><Address>http://\"\n+                        + ipCameraHandler.hostIp + \":\" + ipCameraHandler.serverPort\n+                        + \"/OnvifEvent</Address></ConsumerReference></Subscribe>\";\n+            case \"Unsubscribe\":\n+                return \"<Unsubscribe xmlns=\\\"http://docs.oasis-open.org/wsn/b-2/\\\"></Unsubscribe>\";\n+            case \"PullMessages\":\n+                return \"<PullMessages xmlns=\\\"http://www.onvif.org/ver10/events/wsdl\\\"><Timeout>PT8S</Timeout><MessageLimit>1</MessageLimit></PullMessages>\";\n+            case \"GetEventProperties\":\n+                return \"<GetEventProperties xmlns=\\\"http://www.onvif.org/ver10/events/wsdl\\\"/>\";\n+            case \"RelativeMoveLeft\":\n+                return \"<RelativeMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Translation><PanTilt x=\\\"0.05000000\\\" y=\\\"0\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Translation></RelativeMove>\";\n+            case \"RelativeMoveRight\":\n+                return \"<RelativeMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Translation><PanTilt x=\\\"-0.05000000\\\" y=\\\"0\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Translation></RelativeMove>\";\n+            case \"RelativeMoveUp\":\n+                return \"<RelativeMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Translation><PanTilt x=\\\"0\\\" y=\\\"0.100000000\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Translation></RelativeMove>\";\n+            case \"RelativeMoveDown\":\n+                return \"<RelativeMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Translation><PanTilt x=\\\"0\\\" y=\\\"-0.100000000\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Translation></RelativeMove>\";\n+            case \"RelativeMoveIn\":\n+                return \"<RelativeMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Translation><Zoom x=\\\"0.0240506344\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Translation></RelativeMove>\";\n+            case \"RelativeMoveOut\":\n+                return \"<RelativeMove xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex)\n+                        + \"</ProfileToken><Translation><Zoom x=\\\"-0.0240506344\\\" xmlns=\\\"http://www.onvif.org/ver10/schema\\\"/></Translation></RelativeMove>\";\n+            case \"Renew\":\n+                return \"<Renew xmlns=\\\"http://docs.oasis-open.org/wsn/b-2\\\"><TerminationTime>PT1M</TerminationTime></Renew>\";\n+            case \"GetConfigurations\":\n+                return \"<GetConfigurations xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"></GetConfigurations>\";\n+            case \"GetConfigurationOptions\":\n+                return \"<GetConfigurationOptions xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ConfigurationToken>\"\n+                        + ptzConfigToken + \"</ConfigurationToken></GetConfigurationOptions>\";\n+            case \"GetConfiguration\":\n+                return \"<GetConfiguration xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><PTZConfigurationToken>\"\n+                        + ptzConfigToken + \"</PTZConfigurationToken></GetConfiguration>\";\n+            case \"SetConfiguration\":// not tested to work yet\n+                return \"<SetConfiguration xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><PTZConfiguration><NodeToken>\"\n+                        + ptzNodeToken\n+                        + \"</NodeToken><DefaultAbsolutePantTiltPositionSpace>AbsolutePanTiltPositionSpace</DefaultAbsolutePantTiltPositionSpace><DefaultAbsoluteZoomPositionSpace>AbsoluteZoomPositionSpace</DefaultAbsoluteZoomPositionSpace></PTZConfiguration></SetConfiguration>\";\n+            case \"GetNodes\":\n+                return \"<GetNodes xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"></GetNodes>\";\n+            case \"GetStatus\":\n+                return \"<GetStatus xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex) + \"</ProfileToken></GetStatus>\";\n+            case \"GotoPreset\":\n+                return \"<GotoPreset xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex) + \"</ProfileToken><PresetToken>\"\n+                        + presetTokens.get(presetTokenIndex)\n+                        + \"</PresetToken><Speed><PanTilt x=\\\"0.0\\\" y=\\\"0.0\\\" space=\\\"\\\"></PanTilt><Zoom x=\\\"0.0\\\" space=\\\"\\\"></Zoom></Speed></GotoPreset>\";\n+            case \"GetPresets\":\n+                return \"<GetPresets xmlns=\\\"http://www.onvif.org/ver20/ptz/wsdl\\\"><ProfileToken>\"\n+                        + mediaProfileTokens.get(mediaProfileIndex) + \"</ProfileToken></GetPresets>\";\n+        }\n+        return \"notfound\";\n+    }\n+\n+    public void processReply(String message) {\n+        logger.trace(\"Onvif reply is:{}\", message);\n+        if (message.contains(\"PullMessagesResponse\")) {\n+            eventRecieved(message);\n+        } else if (message.contains(\"RenewResponse\")) {\n+            sendOnvifRequest(requestBuilder(\"PullMessages\", subscriptionXAddr));\n+        } else if (message.contains(\"GetSystemDateAndTimeResponse\")) {// 1st to be sent.\n+            isConnected = true;\n+            sendOnvifRequest(requestBuilder(\"GetCapabilities\", deviceXAddr));\n+            parseDateAndTime(message);\n+            logger.debug(\"Openhabs UTC dateTime is:{}\", getUTCdateTime());\n+        } else if (message.contains(\"GetCapabilitiesResponse\")) {// 2nd to be sent.\n+            parseXAddr(message);\n+            sendOnvifRequest(requestBuilder(\"GetProfiles\", mediaXAddr));\n+        } else if (message.contains(\"GetProfilesResponse\")) {// 3rd to be sent.\n+            parseProfiles(message);\n+            sendOnvifRequest(requestBuilder(\"GetSnapshotUri\", mediaXAddr));\n+            sendOnvifRequest(requestBuilder(\"GetStreamUri\", mediaXAddr));\n+            if (ptzDevice) {\n+                sendPTZRequest(\"GetNodes\");\n+            }\n+            if (usingEvents) {// stops API cameras from getting sent ONVIF events.\n+                sendOnvifRequest(requestBuilder(\"GetEventProperties\", eventXAddr));\n+                sendOnvifRequest(requestBuilder(\"GetServiceCapabilities\", eventXAddr));\n+            }\n+        } else if (message.contains(\"GetServiceCapabilitiesResponse\")) {\n+            if (message.contains(\"WSSubscriptionPolicySupport=\\\"true\\\"\")) {\n+                sendOnvifRequest(requestBuilder(\"Subscribe\", eventXAddr));\n+            }\n+        } else if (message.contains(\"GetEventPropertiesResponse\")) {\n+            sendOnvifRequest(requestBuilder(\"CreatePullPointSubscription\", eventXAddr));\n+        } else if (message.contains(\"SubscribeResponse\")) {\n+            logger.info(\"Onvif Subscribe appears to be working for Alarms/Events.\");\n+        } else if (message.contains(\"CreatePullPointSubscriptionResponse\")) {\n+            subscriptionXAddr = removeIPfromUrl(Helper.fetchXML(message, \"SubscriptionReference>\", \"Address>\"));\n+            logger.debug(\"subscriptionXAddr={}\", subscriptionXAddr);\n+            sendOnvifRequest(requestBuilder(\"PullMessages\", subscriptionXAddr));\n+        } else if (message.contains(\"GetStatusResponse\")) {\n+            processPTZLocation(message);\n+        } else if (message.contains(\"GetPresetsResponse\")) {\n+            presetTokens = listOfResults(message, \"<tptz:Preset\", \"token=\\\"\");\n+        } else if (message.contains(\"GetConfigurationsResponse\")) {\n+            sendPTZRequest(\"GetPresets\");\n+            ptzConfigToken = Helper.fetchXML(message, \"PTZConfiguration\", \"token=\\\"\");\n+            logger.debug(\"ptzConfigToken={}\", ptzConfigToken);\n+            sendPTZRequest(\"GetConfigurationOptions\");\n+        } else if (message.contains(\"GetNodesResponse\")) {\n+            sendPTZRequest(\"GetStatus\");\n+            ptzNodeToken = Helper.fetchXML(message, \"\", \"token=\\\"\");\n+            logger.debug(\"ptzNodeToken={}\", ptzNodeToken);\n+            sendPTZRequest(\"GetConfigurations\");\n+        } else if (message.contains(\"GetDeviceInformationResponse\")) {\n+            logger.debug(\"GetDeviceInformationResponse recieved\");\n+        } else if (message.contains(\"GetSnapshotUriResponse\")) {\n+            snapshotUri = removeIPfromUrl(Helper.fetchXML(message, \":MediaUri\", \":Uri\"));\n+            logger.debug(\"GetSnapshotUri:{}\", snapshotUri);\n+            if (ipCameraHandler.snapshotUri.isEmpty()) {\n+                ipCameraHandler.snapshotUri = snapshotUri;\n+            }\n+        } else if (message.contains(\"GetStreamUriResponse\")) {\n+            rtspUri = Helper.fetchXML(message, \":MediaUri\", \":Uri>\");\n+            logger.debug(\"GetStreamUri:{}\", rtspUri);\n+            if (ipCameraHandler.rtspUri.isEmpty()) {\n+                ipCameraHandler.rtspUri = rtspUri;\n+            }\n+        }\n+    }\n+\n+    HttpRequest requestBuilder(String requestType, String xAddr) {", "originalCommit": "8b6c85c2e3c680bfdc9386b22e725fabea6727f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg0NTI1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r490845251", "bodyText": "DONE.", "author": "Skinah", "createdAt": "2020-09-18T10:12:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxNzA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxODQzNA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r489818434", "bodyText": "This method is misleading since it affects any channel given (not just an alarm channel). Also since you are expecting either ON or OFF as the state value you might as well enforce by changing the state parameter to an OnOffType instead of String.", "author": "cpmeister", "createdAt": "2020-09-17T00:02:30Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,1795 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal.handler;\n+\n+import static org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.CameraConfig;\n+import org.openhab.binding.ipcamera.internal.ChannelTracking;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.GroupTracker;\n+import org.openhab.binding.ipcamera.internal.Helper;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.ffmpegFormat;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.internal.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(4);\n+    private GroupTracker groupTracker;\n+    public CameraConfig cameraConfig;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    private final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    private final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public final ChannelGroup openChannels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    public boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private int nvrChannel;\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    private int mp4RecordTime = 0;\n+    private int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp;\n+    private String ffmpegOutputFolder = \"\";\n+    public ReentrantLock lock = new ReentrantLock();\n+    public List<ChannelTracking> channelTracker = new ArrayList<>(18);\n+    public List<String> lowPriorityRequests = new ArrayList<>(0);\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useBasicAuth = false;\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageWhen = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    private boolean motionAlarmUpdateSnapshot = false;\n+    private boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    private boolean firstAudioAlarm = false;\n+    private boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    private boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    // These methods handle the response from all camera brands, nothing specific to 1 brand.\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                processSnapshot(incomingJpeg);\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    ctx.close();\n+                                } else {\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.isEmpty()) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause instanceof ArrayIndexOutOfBoundsException) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        String urlToKeepOpen = \"\";\n+                        switch (thing.getThingTypeUID().getId()) {\n+                            case DAHUA_THING:\n+                                urlToKeepOpen = \"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\";\n+                                break;\n+                            case HIKVISION_THING:\n+                                urlToKeepOpen = \"/ISAPI/Event/notification/alertStream\";\n+                                break;\n+                            case DOORBIRD_THING:\n+                                urlToKeepOpen = \"/bha-api/monitor.cgi?ring=doorbell,motionsensor\";\n+                                break;\n+                        }\n+\n+                        for (ChannelTracking channelTracking : channelTracker) {\n+                            if (channelTracking.getChannel().equals(ctx.channel())) {\n+                                if (channelTracking.getRequestUrl().equals(urlToKeepOpen)) {\n+                                    return; // don't auto close this as it is for the alarms.\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public IpCameraHandler(Thing thing, @Nullable String openhabIpAddress, GroupTracker groupTracker) {\n+        super(thing);\n+        cameraConfig = getConfigAs(CameraConfig.class);\n+        if (openhabIpAddress != null) {\n+            hostIp = openhabIpAddress;\n+        } else {\n+            hostIp = Helper.getLocalIpAddress();\n+        }\n+        this.groupTracker = groupTracker;\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.isEmpty()) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.isEmpty() && !password.isEmpty()) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        if (longUrl.isEmpty() || longUrl.equals(\"ffmpeg\")) {\n+            return longUrl;\n+        }\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+        }\n+        return temp;\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return cameraConfig.getPort();\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null)//\n+    // The authHandler will generate a digest string and re-send using this same function when needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(AUTH_HANDLER,\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(COMMON_HANDLER, new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case AMCREST_THING:\n+                            socketChannel.pipeline().addLast(AMCREST_HANDLER, new AmcrestHandler(getHandle()));\n+                            break;\n+                        case DAHUA_THING:\n+                            socketChannel.pipeline().addLast(new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case DOORBIRD_THING:\n+                            socketChannel.pipeline().addLast(new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case FOSCAM_THING:\n+                            socketChannel.pipeline().addLast(new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case HIKVISION_THING:\n+                            socketChannel.pipeline().addLast(new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case INSTAR_THING:\n+                            socketChannel.pipeline().addLast(INSTAR_HANDLER, new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (!\"PUT\".equals(httpMethod) || (useDigestAuth && digestString == null)) {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        } else {\n+            request = putRequestWithBody;\n+        }\n+\n+        if (!basicAuth.isEmpty()) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    Channel ch = future.channel();\n+                    boolean chTracked = false;\n+                    openChannels.add(ch);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    try {\n+                        for (ChannelTracking channelTracking : channelTracker) {\n+                            if (channelTracking.getRequestUrl().equals(httpRequestURL)) {\n+                                channelTracking.setChannel(ch);\n+                                chTracked = true;\n+                                break;\n+                            }\n+                        }\n+                        if (!chTracked) {\n+                            channelTracker.add(new ChannelTracking(ch, httpRequestURL));\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(COMMON_HANDLER);\n+                    commonHandler.setURL(httpRequestURLFull);\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(AUTH_HANDLER);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case AMCREST_THING:\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(AMCREST_HANDLER);\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case INSTAR_THING:\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(INSTAR_HANDLER);\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+                    ch.writeAndFlush(request);\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot(byte[] incommingSnapshot) {\n+        lockCurrentSnapshot.lock();\n+        try {\n+            currentSnapshot = incommingSnapshot;\n+            if (preroll > 0) {\n+                fifoSnapshotBuffer.add(incommingSnapshot);\n+                if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                    fifoSnapshotBuffer.removeFirst();\n+                }\n+            }\n+        } finally {\n+            lockCurrentSnapshot.unlock();\n+        }\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(incommingSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(incommingSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                // only happens every 8 seconds as some browsers need a frame that often to keep stream alive.\n+                sendMjpegFrame(incommingSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 60, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.debug(\"File server for camera at {} has started on port {} for all NIC's.\", ipAddress,\n+                            serverPort);\n+                    updateState(CHANNEL_MJPEG_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    cameraConfigError(\"Exception when starting server. Try changing the serverPort to another number.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setupSnapshotStreaming(boolean stream, ChannelHandlerContext ctx, boolean auto) {\n+        if (stream) {\n+            sendMjpegFirstPacket(ctx);\n+            if (auto) {\n+                autoSnapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                try {\n+                    sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                    // iOS uses a FIFO? and needs two frames to display a pic\n+                    sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                } finally {\n+                    lockCurrentSnapshot.unlock();\n+                }\n+                streamingAutoFps = true;\n+            } else {\n+                snapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                try {\n+                    sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+                } finally {\n+                    lockCurrentSnapshot.unlock();\n+                }\n+                streamingSnapshotMjpeg = true;\n+                startSnapshotPolling();\n+            }\n+        } else {\n+            snapshotMjpegChannelGroup.remove(ctx.channel());\n+            autoSnapshotMjpegChannelGroup.remove(ctx.channel());\n+            if (streamingSnapshotMjpeg && snapshotMjpegChannelGroup.isEmpty()) {\n+                streamingSnapshotMjpeg = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All snapshots.mjpeg streams have stopped.\");\n+            } else if (streamingAutoFps && autoSnapshotMjpegChannelGroup.isEmpty()) {\n+                streamingAutoFps = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All autofps.mjpeg streams have stopped.\");\n+            }\n+        }\n+    }\n+\n+    // If start is true the CTX is added to the list to stream video to, false stops\n+    // the stream.\n+    public void setupMjpegStreaming(boolean start, ChannelHandlerContext ctx) {\n+        if (start) {\n+            if (mjpegChannelGroup.isEmpty()) {// first stream being requested.\n+                mjpegChannelGroup.add(ctx.channel());\n+                if (mjpegUri.isEmpty() || mjpegUri.equals(\"ffmpeg\")) {\n+                    sendMjpegFirstPacket(ctx);\n+                    setupFfmpegFormat(ffmpegFormat.MJPEG);\n+                } else {\n+                    try {\n+                        // fix Dahua reboots when refreshing a mjpeg stream.\n+                        TimeUnit.MILLISECONDS.sleep(500);\n+                    } catch (InterruptedException e) {\n+                    }\n+                    sendHttpGET(mjpegUri);\n+                }\n+            } else if (ffmpegMjpeg != null) {// not first stream and we will use ffmpeg\n+                sendMjpegFirstPacket(ctx);\n+                mjpegChannelGroup.add(ctx.channel());\n+            } else {// not first stream and camera supplies the mjpeg source.\n+                ctx.channel().writeAndFlush(firstStreamedMsg);\n+                mjpegChannelGroup.add(ctx.channel());\n+            }\n+        } else {\n+            mjpegChannelGroup.remove(ctx.channel());\n+            if (mjpegChannelGroup.isEmpty()) {\n+                logger.debug(\"All ipcamera.mjpeg streams have stopped.\");\n+                if (mjpegUri.equals(\"ffmpeg\")) {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                } else if (!mjpegUri.isEmpty()) {\n+                    closeChannel(getTinyUrl(mjpegUri));\n+                } else {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (ChannelTracking channelTracking : channelTracker) {\n+                if (channelTracking.getRequestUrl().equals(url)) {\n+                    if (channelTracking.getChannel().isOpen()) {\n+                        channelTracking.getChannel().close();\n+                        return;\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    void cleanChannels() {\n+        ChannelTracking localTracking = null;\n+        lock.lock();\n+        try {\n+            for (ChannelTracking channelTracking : channelTracker) {\n+                logger.trace(\"Channel is open:{}, url is {}\", channelTracking.getChannel().isOpen(),\n+                        channelTracking.getRequestUrl());\n+                if (!channelTracking.getChannel().isOpen() && channelTracking.getReply().isEmpty()) {\n+                    localTracking = channelTracking;// Seems to create a deadlock if we remove whilst in loop\n+                    break;\n+                }\n+            }\n+            if (localTracking != null) {\n+                channelTracker.remove(localTracking);// clean up one closed channel.\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void storeHttpReply(String url, String content) {\n+        lock.lock();\n+        try {\n+            for (ChannelTracking channelTracking : channelTracker) {\n+                if (channelTracking.getRequestUrl().equals(url)) {\n+                    channelTracking.setReply(content);\n+                    return;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    // sends direct to ctx so can be either snapshots.mjpeg or normal mjpeg stream\n+    public void sendMjpegFirstPacket(ChannelHandlerContext ctx) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        String contentType = \"multipart/x-mixed-replace; boundary=\" + BOUNDARY;\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+        ctx.channel().writeAndFlush(response);\n+    }\n+\n+    public void sendMjpegFrame(byte[] jpg, ChannelGroup channelGroup) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        ByteBuf imageByteBuf = Unpooled.copiedBuffer(jpg);\n+        int length = imageByteBuf.readableBytes();\n+        String header = \"--\" + BOUNDARY + \"\\r\\n\" + \"content-type: image/jpeg\" + \"\\r\\n\" + \"content-length: \" + length\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuf headerBbuf = Unpooled.copiedBuffer(header, 0, header.length(), StandardCharsets.UTF_8);\n+        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+        streamToGroup(headerBbuf, channelGroup, false);\n+        streamToGroup(imageByteBuf, channelGroup, false);\n+        streamToGroup(footerBbuf, channelGroup, true);\n+    }\n+\n+    public void streamToGroup(Object msg, ChannelGroup channelGroup, boolean flush) {\n+        channelGroup.write(msg);\n+        if (flush) {\n+            channelGroup.flush();\n+        }\n+    }\n+\n+    private void storeSnapshots() {\n+        int count = 0;\n+        // Need to lock as fifoSnapshotBuffer is not thread safe and new snapshots can be incoming.\n+        lockCurrentSnapshot.lock();\n+        try {\n+            for (byte[] foo : fifoSnapshotBuffer) {\n+                File file = new File(ffmpegOutputFolder + \"snapshot\" + count + \".jpg\");\n+                count++;\n+                try {\n+                    OutputStream fos = new FileOutputStream(file);\n+                    fos.write(foo);\n+                    fos.close();\n+                } catch (FileNotFoundException e) {\n+                    logger.warn(\"FileNotFoundException {}\", e.getMessage());\n+                } catch (IOException e) {\n+                    logger.warn(\"IOException {}\", e.getMessage());\n+                }\n+            }\n+        } finally {\n+            lockCurrentSnapshot.unlock();\n+        }\n+    }\n+\n+    public void setupFfmpegFormat(ffmpegFormat format) {\n+        String inputOptions = cameraConfig.getFfmpegInputOptions();\n+        if (cameraConfig.getFfmpegOutput().isEmpty()) {\n+            logger.warn(\"The camera tried to use a FFmpeg feature when the output folder is not set.\");\n+            return;\n+        }\n+        if (rtspUri.isEmpty()) {\n+            logger.warn(\"The camera tried to use a FFmpeg feature when no valid input for FFmpeg is provided.\");\n+            return;\n+        }\n+        if (cameraConfig.getFfmpegLocation().isEmpty()) {\n+            logger.warn(\"The camera tried to use a FFmpeg feature when the location for FFmpeg is not known.\");\n+            return;\n+        }\n+        if (rtspUri.toLowerCase().contains(\"rtsp\")) {\n+            if (inputOptions.isEmpty()) {\n+                inputOptions = \"-rtsp_transport tcp\";\n+            } else {\n+                inputOptions = inputOptions + \" -rtsp_transport tcp\";\n+            }\n+        }\n+\n+        // Make sure the folder exists, if not create it.\n+        new File(ffmpegOutputFolder).mkdirs();\n+        switch (format) {\n+            case HLS:\n+                if (ffmpegHLS == null) {\n+                    if (!inputOptions.isEmpty()) {\n+                        ffmpegHLS = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(),\n+                                \"-hide_banner -loglevel warning \" + inputOptions, rtspUri,\n+                                cameraConfig.getHlsOutOptions(), ffmpegOutputFolder + \"ipcamera.m3u8\", username,\n+                                password);\n+                    } else {\n+                        ffmpegHLS = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(),\n+                                \"-hide_banner -loglevel warning\", rtspUri, cameraConfig.getHlsOutOptions(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    }\n+                }\n+                if (ffmpegHLS != null) {\n+                    ffmpegHLS.startConverting();\n+                }\n+                break;\n+            case GIF:\n+                if (preroll > 0) {\n+                    ffmpegGIF = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(),\n+                            \"-y -r 1 -hide_banner -loglevel warning\", ffmpegOutputFolder + \"snapshot%d.jpg\",\n+                            \"-frames:v \" + (preroll + postroll) + \" \" + cameraConfig.getGifOutOptions(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                } else {\n+                    if (!inputOptions.isEmpty()) {\n+                        inputOptions = \"-y -t \" + postroll + \" -hide_banner -loglevel warning \" + inputOptions;\n+                    } else {\n+                        inputOptions = \"-y -t \" + postroll + \" -hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegGIF = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(), inputOptions, rtspUri,\n+                            cameraConfig.getGifOutOptions(), ffmpegOutputFolder + gifFilename + \".gif\", username,\n+                            password);\n+                }\n+                if (preroll > 0) {\n+                    storeSnapshots();\n+                }\n+                if (ffmpegGIF != null) {\n+                    ffmpegGIF.startConverting();\n+                    if (gifHistory.isEmpty()) {\n+                        gifHistory = gifFilename;\n+                    } else if (!gifFilename.equals(\"ipcamera\")) {\n+                        gifHistory = gifFilename + \",\" + gifHistory;\n+                        if (gifHistoryLength > 49) {\n+                            int endIndex = gifHistory.lastIndexOf(\",\");\n+                            gifHistory = gifHistory.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_GIF_HISTORY, new StringType(gifHistory));\n+                }\n+                break;\n+            case RECORD:\n+                if (!inputOptions.isEmpty()) {\n+                    inputOptions = \"-y -t \" + mp4RecordTime + \" -hide_banner -loglevel warning \" + inputOptions;\n+                } else {\n+                    inputOptions = \"-y -t \" + mp4RecordTime + \" -hide_banner -loglevel warning\";\n+                }\n+                ffmpegRecord = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(), inputOptions, rtspUri,\n+                        cameraConfig.getMp4OutOptions(), ffmpegOutputFolder + mp4Filename + \".mp4\", username, password);\n+                if (mp4Preroll > 0) {\n+                    // fetchFromHLS(); todo: not done yet\n+                }\n+                if (ffmpegRecord != null) {\n+                    ffmpegRecord.startConverting();\n+                    if (mp4History.isEmpty()) {\n+                        mp4History = mp4Filename;\n+                    } else if (!mp4Filename.equals(\"ipcamera\")) {\n+                        mp4History = mp4Filename + \",\" + mp4History;\n+                        if (mp4HistoryLength > 49) {\n+                            int endIndex = mp4History.lastIndexOf(\",\");\n+                            mp4History = mp4History.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_MP4_HISTORY, new StringType(mp4History));\n+                }\n+                break;\n+            case RTSPHELPER:\n+                if (ffmpegRtspHelper != null) {\n+                    ffmpegRtspHelper.stopConverting();\n+                    if (!audioAlarmEnabled && !motionAlarmEnabled) {\n+                        return;\n+                    }\n+                }\n+                String input = (cameraConfig.getAlarmInputUrl().isEmpty()) ? rtspUri : cameraConfig.getAlarmInputUrl();\n+                String OutputOptions = \"-f null -\";\n+                String filterOptions = \"\";\n+                if (!audioAlarmEnabled) {\n+                    filterOptions = \"-an\";\n+                } else {\n+                    filterOptions = \"-af silencedetect=n=-\" + audioThreshold + \"dB:d=2\";\n+                }\n+                if (!motionAlarmEnabled && !ffmpegSnapshotGeneration) {\n+                    filterOptions = filterOptions.concat(\" -vn\");\n+                } else if (motionAlarmEnabled == true) {\n+                    filterOptions = filterOptions\n+                            .concat(\" -vf select='gte(scene,\" + motionThreshold + \")',metadata=print\");\n+                }\n+                if (!cameraConfig.getUser().isEmpty()) {\n+                    filterOptions += \" \";// add space as the Framework does not allow spaces at start of config.\n+                }\n+                ffmpegRtspHelper = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(), inputOptions, input,\n+                        filterOptions + cameraConfig.getMotionOptions(), OutputOptions, username, password);\n+                ffmpegRtspHelper.startConverting();\n+                break;\n+            case MJPEG:\n+                if (ffmpegMjpeg == null) {\n+                    if (inputOptions.isEmpty()) {\n+                        inputOptions = \"-hide_banner -loglevel warning\";\n+                    } else {\n+                        inputOptions = inputOptions + \" -hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegMjpeg = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(), inputOptions, rtspUri,\n+                            cameraConfig.getMjpegOptions(), \"http://127.0.0.1:\" + serverPort + \"/ipcamera.jpg\",\n+                            username, password);\n+                }\n+                if (ffmpegMjpeg != null) {\n+                    ffmpegMjpeg.startConverting();\n+                }\n+                break;\n+            case SNAPSHOT:\n+                // if mjpeg stream you can use ffmpeg -i input.h264 -codec:v copy -bsf:v mjpeg2jpeg output%03d.jpg\n+                if (ffmpegSnapshot == null) {\n+                    if (inputOptions.isEmpty()) {\n+                        // iFrames only\n+                        inputOptions = \"-threads 1 -skip_frame nokey -hide_banner -loglevel warning\";\n+                    } else {\n+                        inputOptions = inputOptions + \" -threads 1 -skip_frame nokey -hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegSnapshot = new Ffmpeg(this, format, cameraConfig.getFfmpegLocation(), inputOptions, rtspUri,\n+                            \"-an -vsync vfr -update 1\", \"http://127.0.0.1:\" + serverPort + \"/snapshot.jpg\", username,\n+                            password);\n+                }\n+                if (ffmpegSnapshot != null) {\n+                    ffmpegSnapshot.startConverting();\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void noMotionDetected(String thisAlarmsChannel) {\n+        setChannelState(thisAlarmsChannel, OnOffType.OFF);\n+        firstMotionAlarm = false;\n+        motionAlarmUpdateSnapshot = false;\n+        motionDetected = false;\n+        if (streamingAutoFps) {\n+            stopSnapshotPolling();\n+        } else if (updateImageWhen.contains(\"4\")) { // During Motion Alarms\n+            stopSnapshotPolling();\n+        }\n+    }\n+\n+    // Change alarms that are not counted as motion detecting.\n+    public void changeAlarmState(String thisAlarmsChannel, String state) {\n+        updateState(thisAlarmsChannel, OnOffType.valueOf(state));\n+    }", "originalCommit": "8b6c85c2e3c680bfdc9386b22e725fabea6727f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3MjAzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r490872039", "bodyText": "Made the change to using OnOffType as suggested and also added javadoc to make things clear and easier to check the intension by hovering over the method.", "author": "Skinah", "createdAt": "2020-09-18T11:05:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxODQzNA=="}], "type": "inlineReview"}, {"oid": "27735b3f797ec99df97bae368f5012ee172e85bd", "url": "https://github.com/openhab/openhab-addons/commit/27735b3f797ec99df97bae368f5012ee172e85bd", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/HttpOnlyHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: cpmeister <mistercpp2000@gmail.com>", "committedDate": "2020-09-17T07:57:18Z", "type": "commit"}, {"oid": "7dc8de49b2f0641136c4a834011bb2144eeaadbd", "url": "https://github.com/openhab/openhab-addons/commit/7dc8de49b2f0641136c4a834011bb2144eeaadbd", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/InstarHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: cpmeister <mistercpp2000@gmail.com>", "committedDate": "2020-09-17T07:57:44Z", "type": "commit"}, {"oid": "c4ab5a7e204e9c7b5b1e19613f76de5d99eb30d3", "url": "https://github.com/openhab/openhab-addons/commit/c4ab5a7e204e9c7b5b1e19613f76de5d99eb30d3", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/onvif/OnvifConnection.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: cpmeister <mistercpp2000@gmail.com>", "committedDate": "2020-09-17T07:58:00Z", "type": "commit"}, {"oid": "bba0a2042ee9cfe0e52a773906615b195c2edea7", "url": "https://github.com/openhab/openhab-addons/commit/bba0a2042ee9cfe0e52a773906615b195c2edea7", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/IpCameraBindingConstants.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: cpmeister <mistercpp2000@gmail.com>", "committedDate": "2020-09-17T07:58:21Z", "type": "commit"}, {"oid": "6e23183a61051a9593871b3fd60d8a355a7904d2", "url": "https://github.com/openhab/openhab-addons/commit/6e23183a61051a9593871b3fd60d8a355a7904d2", "message": "Change all occurrences of enum to start with Capital.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-17T08:39:07Z", "type": "commit"}, {"oid": "e8ab24b32297a89c853abb7b59c35f2f8da080b3", "url": "https://github.com/openhab/openhab-addons/commit/e8ab24b32297a89c853abb7b59c35f2f8da080b3", "message": "Cleanup thread for ffmpeg.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-17T10:53:43Z", "type": "commit"}, {"oid": "5eda4fc55cbee8e06222b9c1393e36e55daa81d2", "url": "https://github.com/openhab/openhab-addons/commit/5eda4fc55cbee8e06222b9c1393e36e55daa81d2", "message": "Allow more cameras to use PTZ features.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-17T11:50:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ1ODc5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r490458795", "bodyText": "This exception is never thrown.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void sendSnapshotImage(ChannelHandlerContext ctx, String contentType) throws IOException {\n          \n          \n            \n                private void sendSnapshotImage(ChannelHandlerContext ctx, String contentType) {", "author": "fwolter", "createdAt": "2020-09-17T18:09:25Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/StreamServerGroupHandler.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import static org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.CHANNEL_START_STREAM;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.openhab.binding.ipcamera.internal.handler.IpCameraGroupHandler;\n+import org.openhab.binding.ipcamera.internal.handler.IpCameraHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.QueryStringDecoder;\n+import io.netty.handler.stream.ChunkedFile;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * The {@link StreamServerGroupHandler} class is responsible for handling streams and sending any requested files to\n+ * Openhabs\n+ * features for a group of cameras instead of individual cameras.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class StreamServerGroupHandler extends ChannelInboundHandlerAdapter {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private IpCameraGroupHandler ipCameraGroupHandler;\n+    private String whiteList = \"\";\n+\n+    public StreamServerGroupHandler(IpCameraGroupHandler ipCameraGroupHandler) {\n+        this.ipCameraGroupHandler = ipCameraGroupHandler;\n+        whiteList = ipCameraGroupHandler.groupConfig.getIpWhitelist();\n+    }\n+\n+    @Override\n+    public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+    }\n+\n+    private String resolveIndexToPath(String uri) {\n+        if (!uri.substring(1, 2).equals(\"i\")) {\n+            return ipCameraGroupHandler.getOutputFolder(Integer.parseInt(uri.substring(1, 2)));\n+        }\n+        return \"notFound\";\n+        // example is /1ipcameraxx.ts\n+    }\n+\n+    @Override\n+    public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+        if (msg == null || ctx == null) {\n+            return;\n+        }\n+        try {\n+            if (msg instanceof HttpRequest) {\n+                HttpRequest httpRequest = (HttpRequest) msg;\n+                String requestIP = \"(\"\n+                        + ((InetSocketAddress) ctx.channel().remoteAddress()).getAddress().getHostAddress() + \")\";\n+                if (!whiteList.contains(requestIP) && !whiteList.equals(\"DISABLE\")) {\n+                    logger.warn(\"The request made from {} was not in the whitelist and will be ignored.\", requestIP);\n+                    return;\n+                } else if (HttpMethod.GET.equals(httpRequest.method())) {\n+                    // Some browsers send a query string after the path when refreshing a picture.\n+                    QueryStringDecoder queryStringDecoder = new QueryStringDecoder(httpRequest.uri());\n+                    switch (queryStringDecoder.path()) {\n+                        case \"/ipcamera.m3u8\":\n+                            if (ipCameraGroupHandler.hlsTurnedOn) {\n+                                String debugMe = ipCameraGroupHandler.getPlayList();\n+                                logger.debug(\"playlist is:{}\", debugMe);\n+                                sendString(ctx, debugMe, \"application/x-mpegurl\");\n+                                return;\n+                            } else {\n+                                logger.warn(\n+                                        \"HLS requires the groups startStream channel to be turned on first. Just starting it now.\");\n+                                String channelPrefix = \"ipcamera:\" + ipCameraGroupHandler.getThing().getThingTypeUID()\n+                                        + \":\" + ipCameraGroupHandler.getThing().getUID().getId() + \":\";\n+                                ipCameraGroupHandler.handleCommand(new ChannelUID(channelPrefix + CHANNEL_START_STREAM),\n+                                        OnOffType.ON);\n+                            }\n+                            break;\n+                        case \"/ipcamera.jpg\":\n+                            sendSnapshotImage(ctx, \"image/jpg\");\n+                            return;\n+                        default:\n+                            if (httpRequest.uri().contains(\".ts\")) {\n+                                sendFile(ctx, resolveIndexToPath(httpRequest.uri()) + httpRequest.uri().substring(2),\n+                                        \"video/MP2T\");\n+                            } else if (httpRequest.uri().contains(\".jpg\")) {\n+                                sendFile(ctx, httpRequest.uri(), \"image/jpg\");\n+                            } else if (httpRequest.uri().contains(\".m4s\") || httpRequest.uri().contains(\".mp4\")) {\n+                                sendFile(ctx, httpRequest.uri(), \"video/mp4\");\n+                            }\n+                    }\n+                }\n+            }\n+        } finally {\n+            ReferenceCountUtil.release(msg);\n+        }\n+    }\n+\n+    private void sendSnapshotImage(ChannelHandlerContext ctx, String contentType) throws IOException {", "originalCommit": "5eda4fc55cbee8e06222b9c1393e36e55daa81d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ1OTAzMg==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r490459032", "bodyText": "See above\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void sendString(ChannelHandlerContext ctx, String contents, String contentType) throws IOException {\n          \n          \n            \n                private void sendString(ChannelHandlerContext ctx, String contents, String contentType) {", "author": "fwolter", "createdAt": "2020-09-17T18:09:51Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/StreamServerGroupHandler.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import static org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.CHANNEL_START_STREAM;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.openhab.binding.ipcamera.internal.handler.IpCameraGroupHandler;\n+import org.openhab.binding.ipcamera.internal.handler.IpCameraHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.QueryStringDecoder;\n+import io.netty.handler.stream.ChunkedFile;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * The {@link StreamServerGroupHandler} class is responsible for handling streams and sending any requested files to\n+ * Openhabs\n+ * features for a group of cameras instead of individual cameras.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class StreamServerGroupHandler extends ChannelInboundHandlerAdapter {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private IpCameraGroupHandler ipCameraGroupHandler;\n+    private String whiteList = \"\";\n+\n+    public StreamServerGroupHandler(IpCameraGroupHandler ipCameraGroupHandler) {\n+        this.ipCameraGroupHandler = ipCameraGroupHandler;\n+        whiteList = ipCameraGroupHandler.groupConfig.getIpWhitelist();\n+    }\n+\n+    @Override\n+    public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+    }\n+\n+    private String resolveIndexToPath(String uri) {\n+        if (!uri.substring(1, 2).equals(\"i\")) {\n+            return ipCameraGroupHandler.getOutputFolder(Integer.parseInt(uri.substring(1, 2)));\n+        }\n+        return \"notFound\";\n+        // example is /1ipcameraxx.ts\n+    }\n+\n+    @Override\n+    public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+        if (msg == null || ctx == null) {\n+            return;\n+        }\n+        try {\n+            if (msg instanceof HttpRequest) {\n+                HttpRequest httpRequest = (HttpRequest) msg;\n+                String requestIP = \"(\"\n+                        + ((InetSocketAddress) ctx.channel().remoteAddress()).getAddress().getHostAddress() + \")\";\n+                if (!whiteList.contains(requestIP) && !whiteList.equals(\"DISABLE\")) {\n+                    logger.warn(\"The request made from {} was not in the whitelist and will be ignored.\", requestIP);\n+                    return;\n+                } else if (HttpMethod.GET.equals(httpRequest.method())) {\n+                    // Some browsers send a query string after the path when refreshing a picture.\n+                    QueryStringDecoder queryStringDecoder = new QueryStringDecoder(httpRequest.uri());\n+                    switch (queryStringDecoder.path()) {\n+                        case \"/ipcamera.m3u8\":\n+                            if (ipCameraGroupHandler.hlsTurnedOn) {\n+                                String debugMe = ipCameraGroupHandler.getPlayList();\n+                                logger.debug(\"playlist is:{}\", debugMe);\n+                                sendString(ctx, debugMe, \"application/x-mpegurl\");\n+                                return;\n+                            } else {\n+                                logger.warn(\n+                                        \"HLS requires the groups startStream channel to be turned on first. Just starting it now.\");\n+                                String channelPrefix = \"ipcamera:\" + ipCameraGroupHandler.getThing().getThingTypeUID()\n+                                        + \":\" + ipCameraGroupHandler.getThing().getUID().getId() + \":\";\n+                                ipCameraGroupHandler.handleCommand(new ChannelUID(channelPrefix + CHANNEL_START_STREAM),\n+                                        OnOffType.ON);\n+                            }\n+                            break;\n+                        case \"/ipcamera.jpg\":\n+                            sendSnapshotImage(ctx, \"image/jpg\");\n+                            return;\n+                        default:\n+                            if (httpRequest.uri().contains(\".ts\")) {\n+                                sendFile(ctx, resolveIndexToPath(httpRequest.uri()) + httpRequest.uri().substring(2),\n+                                        \"video/MP2T\");\n+                            } else if (httpRequest.uri().contains(\".jpg\")) {\n+                                sendFile(ctx, httpRequest.uri(), \"image/jpg\");\n+                            } else if (httpRequest.uri().contains(\".m4s\") || httpRequest.uri().contains(\".mp4\")) {\n+                                sendFile(ctx, httpRequest.uri(), \"video/mp4\");\n+                            }\n+                    }\n+                }\n+            }\n+        } finally {\n+            ReferenceCountUtil.release(msg);\n+        }\n+    }\n+\n+    private void sendSnapshotImage(ChannelHandlerContext ctx, String contentType) throws IOException {\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        if (ipCameraGroupHandler.cameraIndex >= ipCameraGroupHandler.cameraOrder.size()) {\n+            logger.debug(\"WARN: Openhab may still be starting, or all cameras in the group are OFFLINE.\");\n+            return;\n+        }\n+        IpCameraHandler handler = ipCameraGroupHandler.cameraOrder.get(ipCameraGroupHandler.cameraIndex);\n+        handler.lockCurrentSnapshot.lock();\n+        try {\n+            ByteBuf snapshotData = Unpooled.copiedBuffer(handler.currentSnapshot);\n+            response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+            response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+            response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+            response.headers().add(HttpHeaderNames.CONTENT_LENGTH, snapshotData.readableBytes());\n+            response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+            response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+            ctx.channel().write(response);\n+            ctx.channel().write(snapshotData);\n+            ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+            ctx.channel().writeAndFlush(footerBbuf);\n+        } finally {\n+            handler.lockCurrentSnapshot.unlock();\n+        }\n+    }\n+\n+    private void sendFile(ChannelHandlerContext ctx, String fileUri, String contentType) throws IOException {\n+        logger.trace(\"file is :{}\", fileUri);\n+        File file = new File(fileUri);\n+        ChunkedFile chunkedFile = new ChunkedFile(file);\n+        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+        response.headers().add(HttpHeaderNames.CONTENT_LENGTH, chunkedFile.length());\n+        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+        ctx.channel().write(response);\n+        ctx.channel().write(chunkedFile);\n+        ctx.channel().writeAndFlush(footerBbuf);\n+    }\n+\n+    private void sendString(ChannelHandlerContext ctx, String contents, String contentType) throws IOException {", "originalCommit": "5eda4fc55cbee8e06222b9c1393e36e55daa81d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ1OTMxNA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r490459314", "bodyText": "See above\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void sendSnapshotImage(ChannelHandlerContext ctx, String contentType) throws IOException {\n          \n          \n            \n                private void sendSnapshotImage(ChannelHandlerContext ctx, String contentType) {", "author": "fwolter", "createdAt": "2020-09-17T18:10:22Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/StreamServerHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.ipcamera.internal.IpCameraBindingConstants.FFmpegFormat;\n+import org.openhab.binding.ipcamera.internal.handler.IpCameraHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.codec.http.QueryStringDecoder;\n+import io.netty.handler.stream.ChunkedFile;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * The {@link StreamServerHandler} class is responsible for handling streams and sending any requested files to openHABs\n+ * features.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class StreamServerHandler extends ChannelInboundHandlerAdapter {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private IpCameraHandler ipCameraHandler;\n+    private boolean handlingMjpeg = false; // used to remove ctx from group when handler is removed.\n+    private boolean handlingSnapshotStream = false; // used to remove ctx from group when handler is removed.\n+    private byte[] incomingJpeg = new byte[0];\n+    private String whiteList = \"\";\n+    private int recievedBytes = 0;\n+    private boolean updateSnapshot = false;\n+    private boolean onvifEvent = false;\n+\n+    public StreamServerHandler(IpCameraHandler ipCameraHandler) {\n+        this.ipCameraHandler = ipCameraHandler;\n+        whiteList = ipCameraHandler.getWhiteList();\n+    }\n+\n+    @Override\n+    public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+    }\n+\n+    @Override\n+    public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+        if (ctx == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (msg instanceof HttpRequest) {\n+                HttpRequest httpRequest = (HttpRequest) msg;\n+                if (!whiteList.equals(\"DISABLE\")) {\n+                    String requestIP = \"(\"\n+                            + ((InetSocketAddress) ctx.channel().remoteAddress()).getAddress().getHostAddress() + \")\";\n+                    if (!whiteList.contains(requestIP)) {\n+                        logger.warn(\"The request made from {} was not in the whitelist and will be ignored.\",\n+                                requestIP);\n+                        return;\n+                    }\n+                }\n+                if (\"GET\".equalsIgnoreCase(httpRequest.method().toString())) {\n+                    logger.debug(\"Stream Server recieved request \\tGET:{}\", httpRequest.uri());\n+                    // Some browsers send a query string after the path when refreshing a picture.\n+                    QueryStringDecoder queryStringDecoder = new QueryStringDecoder(httpRequest.uri());\n+                    switch (queryStringDecoder.path()) {\n+                        case \"/ipcamera.m3u8\":\n+                            if (ipCameraHandler.ffmpegHLS != null) {\n+                                if (!ipCameraHandler.ffmpegHLS.getIsAlive()) {\n+                                    if (ipCameraHandler.ffmpegHLS != null) {\n+                                        ipCameraHandler.ffmpegHLS.startConverting();\n+                                    }\n+                                }\n+                            } else {\n+                                ipCameraHandler.setupFfmpegFormat(FFmpegFormat.HLS);\n+                            }\n+                            if (ipCameraHandler.ffmpegHLS != null) {\n+                                ipCameraHandler.ffmpegHLS.setKeepAlive(8);\n+                            }\n+                            sendFile(ctx, httpRequest.uri(), \"application/x-mpegurl\");\n+                            ctx.close();\n+                            return;\n+                        case \"/ipcamera.mpd\":\n+                            sendFile(ctx, httpRequest.uri(), \"application/dash+xml\");\n+                            return;\n+                        case \"/ipcamera.gif\":\n+                            sendFile(ctx, httpRequest.uri(), \"image/gif\");\n+                            return;\n+                        case \"/ipcamera.jpg\":\n+                            if (!ipCameraHandler.snapshotPolling && ipCameraHandler.snapshotUri != \"\") {\n+                                ipCameraHandler.sendHttpGET(ipCameraHandler.snapshotUri);\n+                            }\n+                            if (ipCameraHandler.currentSnapshot.length == 1) {\n+                                logger.warn(\"ipcamera.jpg was requested but there is no jpg in ram to send.\");\n+                                return;\n+                            }\n+                            sendSnapshotImage(ctx, \"image/jpg\");\n+                            return;\n+                        case \"/snapshots.mjpeg\":\n+                            handlingSnapshotStream = true;\n+                            ipCameraHandler.startSnapshotPolling();\n+                            ipCameraHandler.setupSnapshotStreaming(true, ctx, false);\n+                            return;\n+                        case \"/ipcamera.mjpeg\":\n+                            ipCameraHandler.setupMjpegStreaming(true, ctx);\n+                            handlingMjpeg = true;\n+                            return;\n+                        case \"/autofps.mjpeg\":\n+                            handlingSnapshotStream = true;\n+                            ipCameraHandler.setupSnapshotStreaming(true, ctx, true);\n+                            return;\n+                        case \"/instar\":\n+                            InstarHandler instar = new InstarHandler(ipCameraHandler);\n+                            instar.alarmTriggered(httpRequest.uri().toString());\n+                            ctx.close();\n+                            return;\n+                        case \"/ipcamera0.ts\":\n+                        default:\n+                            if (httpRequest.uri().contains(\".ts\")) {\n+                                sendFile(ctx, queryStringDecoder.path(), \"video/MP2T\");\n+                            } else if (httpRequest.uri().contains(\".gif\")) {\n+                                sendFile(ctx, queryStringDecoder.path(), \"image/gif\");\n+                            } else if (httpRequest.uri().contains(\".jpg\")) {\n+                                // Allow access to the preroll and postroll jpg files\n+                                sendFile(ctx, queryStringDecoder.path(), \"image/jpg\");\n+                            } else if (httpRequest.uri().contains(\".m4s\") || httpRequest.uri().contains(\".mp4\")) {\n+                                sendFile(ctx, queryStringDecoder.path(), \"video/mp4\");\n+                            }\n+                            return;\n+                    }\n+                } else if (\"POST\".equalsIgnoreCase(httpRequest.method().toString())) {\n+                    switch (httpRequest.uri()) {\n+                        case \"/ipcamera.jpg\":\n+                            break;\n+                        case \"/snapshot.jpg\":\n+                            updateSnapshot = true;\n+                            break;\n+                        case \"/OnvifEvent\":\n+                            onvifEvent = true;\n+                            break;\n+                        default:\n+                            logger.debug(\"Stream Server recieved unknown request \\tPOST:{}\", httpRequest.uri());\n+                            break;\n+                    }\n+                }\n+            }\n+            if (msg instanceof HttpContent) {\n+                HttpContent content = (HttpContent) msg;\n+                int index = 0;\n+                if (recievedBytes == 0) {\n+                    incomingJpeg = new byte[content.content().capacity()];\n+                } else {\n+                    byte[] temp = incomingJpeg;\n+                    incomingJpeg = new byte[recievedBytes + content.content().capacity()];\n+\n+                    for (; index < temp.length; index++) {\n+                        incomingJpeg[index] = temp[index];\n+                    }\n+                }\n+                for (int i = 0; i < content.content().capacity(); i++) {\n+                    incomingJpeg[index++] = content.content().getByte(i);\n+                }\n+                recievedBytes = incomingJpeg.length;\n+                if (content instanceof LastHttpContent) {\n+                    if (updateSnapshot) {\n+                        ipCameraHandler.processSnapshot(incomingJpeg);\n+                    } else if (onvifEvent) {\n+                        ipCameraHandler.onvifCamera.eventRecieved(new String(incomingJpeg, StandardCharsets.UTF_8));\n+                    } else { // handles the snapshots that make up mjpeg from rtsp to ffmpeg conversions.\n+                        if (recievedBytes > 1000) {\n+                            ipCameraHandler.sendMjpegFrame(incomingJpeg, ipCameraHandler.mjpegChannelGroup);\n+                        }\n+                    }\n+                    recievedBytes = 0;\n+                }\n+            }\n+        } finally {\n+            ReferenceCountUtil.release(msg);\n+        }\n+    }\n+\n+    private void sendSnapshotImage(ChannelHandlerContext ctx, String contentType) throws IOException {", "originalCommit": "5eda4fc55cbee8e06222b9c1393e36e55daa81d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fcac08b7f45a3062fc08e6bdb0fb69f70405cad8", "url": "https://github.com/openhab/openhab-addons/commit/fcac08b7f45a3062fc08e6bdb0fb69f70405cad8", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/StreamServerHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-09-18T06:33:25Z", "type": "commit"}, {"oid": "3edc86fa934839a40f126a22f66a9b3ba10e858a", "url": "https://github.com/openhab/openhab-addons/commit/3edc86fa934839a40f126a22f66a9b3ba10e858a", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/StreamServerGroupHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-09-18T06:33:42Z", "type": "commit"}, {"oid": "e9515c90cd71f564616fbecccd8b31340257b642", "url": "https://github.com/openhab/openhab-addons/commit/e9515c90cd71f564616fbecccd8b31340257b642", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/StreamServerGroupHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-09-18T06:34:12Z", "type": "commit"}, {"oid": "c1d93571ba806f653f44b2461ce7e48aaedc20fb", "url": "https://github.com/openhab/openhab-addons/commit/c1d93571ba806f653f44b2461ce7e48aaedc20fb", "message": "Remove variables that can be used direct from camerConfig\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-18T08:34:11Z", "type": "commit"}, {"oid": "57c0aaa344ace983e4e5e185dadb53fe3112beae", "url": "https://github.com/openhab/openhab-addons/commit/57c0aaa344ace983e4e5e185dadb53fe3112beae", "message": "Change requestType to Enum.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-18T10:08:27Z", "type": "commit"}, {"oid": "1bcc4bdc156ffe1cdb786df07eb2ffdbe2a7c1d5", "url": "https://github.com/openhab/openhab-addons/commit/1bcc4bdc156ffe1cdb786df07eb2ffdbe2a7c1d5", "message": "stopStreamServer() created.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-18T10:40:02Z", "type": "commit"}, {"oid": "2bdd34e1857835d1e2655f8248f4cecd2b2a80a1", "url": "https://github.com/openhab/openhab-addons/commit/2bdd34e1857835d1e2655f8248f4cecd2b2a80a1", "message": "fix 1\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-22T13:19:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTM2MA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477579360", "bodyText": "You should compare commands on class level not on string level:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!\"REFRESH\".equals(command.toString())) {\n          \n          \n            \n                    if (!(command instanceof RefreshType)) {", "author": "Hilbrand", "createdAt": "2020-08-26T20:46:43Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraGroupHandler.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.ipcamera.internal.StreamServerGroupHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * The {@link IpCameraGroupHandler} is responsible for finding cameras that are part of this group and displaying a\n+ * group picture.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraGroupHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_GROUPDISPLAY));\n+    private Configuration config;\n+    BigDecimal pollTimeInSeconds = new BigDecimal(2);\n+    public ArrayList<IpCameraHandler> cameraOrder = new ArrayList<IpCameraHandler>(2);\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private final ScheduledExecutorService pollCameraGroup = Executors.newSingleThreadScheduledExecutor();\n+    private @Nullable ScheduledFuture<?> pollCameraGroupJob = null;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public String hostIp = \"0.0.0.0\";\n+    boolean motionChangesOrder = true;\n+    public int serverPort = 0;\n+    public String playList = \"\";\n+    String playingNow = \"\";\n+    public int cameraIndex = 0;\n+    public boolean hlsTurnedOn = false;\n+    int entries = 0;\n+    BigDecimal numberOfFiles = new BigDecimal(1);\n+    int mediaSequence = 1;\n+    int discontinuitySequence = 0;\n+\n+    public IpCameraGroupHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    // @SuppressWarnings(\"null\")\n+    public String getWhiteList() {\n+        return (config.get(CONFIG_IP_WHITELIST) == null) ? \"\" : config.get(CONFIG_IP_WHITELIST).toString();\n+    }\n+\n+    public String getPlayList() {\n+        return playList;\n+    }\n+\n+    public String getOutputFolder(int index) {\n+        IpCameraHandler handle = cameraOrder.get(index);\n+        return (String) handle.config.get(CONFIG_FFMPEG_OUTPUT);\n+    }\n+\n+    private String readCamerasPlaylist(int cameraIndex) {\n+        String camerasm3u8 = \"\";\n+        IpCameraHandler handle = cameraOrder.get(cameraIndex);\n+        try {\n+            String file = handle.config.get(CONFIG_FFMPEG_OUTPUT).toString() + \"ipcamera.m3u8\";\n+            camerasm3u8 = new String(Files.readAllBytes(Paths.get(file)));\n+        } catch (IOException e) {\n+            logger.error(\"Error occured fetching cameras m3u8 file :{}\", e.getMessage());\n+        }\n+        return camerasm3u8;\n+    }\n+\n+    String keepLast(String string, int numberToRetain) {\n+        int start = string.length();\n+        for (int loop = numberToRetain; loop > 0; loop--) {\n+            start = string.lastIndexOf(\"#EXTINF:\", start - 1);\n+            if (start == -1) {\n+                logger.error(\n+                        \"Playlist did not contain enough entries, check all cameras in groups use the same HLS settings.\");\n+                return \"\";\n+            }\n+        }\n+        entries = entries + numberToRetain;\n+        return string.substring(start);\n+    }\n+\n+    String removeFromStart(String string, int numberToRemove) {\n+        int startingFrom = string.indexOf(\"#EXTINF:\");\n+        for (int loop = numberToRemove; loop > 0; loop--) {\n+            startingFrom = string.indexOf(\"#EXTINF:\", startingFrom + 27);\n+            if (startingFrom == -1) {\n+                logger.error(\n+                        \"Playlist failed to remove entries from start, check all cameras in groups use the same HLS settings.\");\n+                return string;\n+            }\n+        }\n+        mediaSequence = mediaSequence + numberToRemove;\n+        entries = entries - numberToRemove;\n+        return string.substring(startingFrom);\n+    }\n+\n+    int howManySegments(String m3u8File) {\n+        int start = m3u8File.length();\n+        int numberOfFiles = 0;\n+        for (BigDecimal totalTime = new BigDecimal(0); totalTime.intValue() < pollTimeInSeconds\n+                .intValue(); numberOfFiles++) {\n+            start = m3u8File.lastIndexOf(\"#EXTINF:\", start - 1);\n+            if (start != -1) {\n+                totalTime = totalTime.add(new BigDecimal(m3u8File.substring(start + 8, m3u8File.indexOf(\",\", start))));\n+            } else {\n+                logger.debug(\"Group did not find enough segments, lower the poll time if this message continues.\");\n+                break;\n+            }\n+        }\n+        return numberOfFiles;\n+    }\n+\n+    public void createPlayList() {\n+        String m3u8File = readCamerasPlaylist(cameraIndex);\n+        if (m3u8File == \"\") {\n+            return;\n+        }\n+        int numberOfSegments = howManySegments(m3u8File);\n+        logger.debug(\"Using {} segmented files to make up a poll period.\", numberOfSegments);\n+        m3u8File = keepLast(m3u8File, numberOfSegments);\n+        // logger.debug(\"replacing files to keep now\");\n+        m3u8File = m3u8File.replace(\"ipcamera\", cameraIndex + \"ipcamera\"); // add index so we can then fetch output path\n+        // logger.debug(\"There are {} segments, so we will remove {} from playlist.\", entries, numberOfSegments);\n+        if (entries > numberOfSegments * 3) {\n+            playingNow = removeFromStart(playingNow, entries - (numberOfSegments * 3));\n+        }\n+        playingNow = playingNow + \"#EXT-X-DISCONTINUITY\\n\" + m3u8File;\n+        playList = \"#EXTM3U\\n#EXT-X-VERSION:6\\n#EXT-X-TARGETDURATION:5\\n#EXT-X-ALLOW-CACHE:NO\\n#EXT-X-DISCONTINUITY-SEQUENCE:\"\n+                + discontinuitySequence + \"\\n#EXT-X-MEDIA-SEQUENCE:\" + mediaSequence + \"\\n\" + playingNow;\n+    }\n+\n+    private IpCameraGroupHandler getHandle() {\n+        return this;\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully(8, 8, TimeUnit.SECONDS);\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerGroupHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.info(\"IpCamera file server for a group of cameras has started on port {} for all NIC's.\",\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    logger.error(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number: {}\",\n+                            e.getMessage());\n+                }\n+            }\n+        }\n+    }\n+\n+    // @SuppressWarnings(\"null\")\n+    void addCamera(String UniqueID) {\n+        if (IpCameraHandler.listOfOnlineCameraUID.contains(UniqueID)) {\n+            for (IpCameraHandler handler : IpCameraHandler.listOfOnlineCameraHandlers) {\n+                if (handler.getThing().getUID().getId().equals(UniqueID)) {\n+                    if (!cameraOrder.contains(handler)) {\n+                        logger.info(\"Adding {} to a camera group.\", UniqueID);\n+                        if (hlsTurnedOn) {\n+                            logger.info(\"Starting HLS for the new camera.\");\n+                            String channelPrefix = \"ipcamera:\" + handler.getThing().getThingTypeUID() + \":\"\n+                                    + handler.getThing().getUID().getId() + \":\";\n+                            handler.handleCommand(new ChannelUID(channelPrefix + CHANNEL_START_STREAM),\n+                                    OnOffType.valueOf(\"ON\"));\n+                        }\n+                        cameraOrder.add(handler);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // Event based. This is called as each camera comes online after the group handler is registered.\n+    public void cameraOnline(String uid) {\n+        logger.debug(\"New camera {} came online, checking if part of this group\", uid);\n+        if (config.get(CONFIG_FIRST_CAM).equals(uid)) {\n+            addCamera(uid);\n+        } else if (config.get(CONFIG_SECOND_CAM).equals(uid)) {\n+            addCamera(uid);\n+        } else if (config.get(CONFIG_THIRD_CAM).equals(uid)) {\n+            addCamera(uid);\n+        } else if (config.get(CONFIG_FORTH_CAM).equals(uid)) {\n+            addCamera(uid);\n+        }\n+    }\n+\n+    // Event based. This is called as each camera comes online after the group handler is registered.\n+    public void cameraOffline(IpCameraHandler handle) {\n+        if (cameraOrder.remove(handle)) {\n+            logger.info(\"Camera {} is now offline, now removed from this group.\", handle.getThing().getUID().getId());\n+        }\n+    }\n+\n+    boolean addIfOnline(String UniqueID) {\n+        if (IpCameraHandler.listOfOnlineCameraUID.contains(UniqueID)) {\n+            addCamera(UniqueID);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    void createCameraOrder() {\n+        addIfOnline(config.get(CONFIG_FIRST_CAM).toString());\n+        addIfOnline(config.get(CONFIG_SECOND_CAM).toString());\n+        if (config.get(CONFIG_THIRD_CAM) != null) {\n+            addIfOnline(config.get(CONFIG_THIRD_CAM).toString());\n+        }\n+        if (config.get(CONFIG_FORTH_CAM) != null) {\n+            addIfOnline(config.get(CONFIG_FORTH_CAM).toString());\n+        }\n+        // Cameras can now send events of when they go on and offline.\n+        IpCameraHandler.listOfGroupHandlers.add(this);\n+    }\n+\n+    int checkForMotion(int nextCamerasIndex) {\n+        int checked = 0;\n+        for (int index = nextCamerasIndex; checked < cameraOrder.size(); checked++) {\n+            if (cameraOrder.get(index).motionDetected) {\n+                // logger.trace(\"Motion detected on a camera in a group, the display order has changed.\");\n+                return index;\n+            }\n+            if (++index >= cameraOrder.size()) {\n+                index = 0;\n+            }\n+        }\n+        return nextCamerasIndex;\n+    }\n+\n+    Runnable pollingCameraGroup = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (cameraOrder.isEmpty()) {\n+                createCameraOrder();\n+            }\n+            if (++cameraIndex >= cameraOrder.size()) {\n+                cameraIndex = 0;\n+            }\n+            if (motionChangesOrder) {\n+                cameraIndex = checkForMotion(cameraIndex);\n+            }\n+            if (hlsTurnedOn) {\n+                discontinuitySequence++;\n+                createPlayList();\n+                if (mediaSequence > 2147000000) {\n+                    mediaSequence = 0;\n+                    discontinuitySequence = 0;\n+                }\n+            }\n+        }\n+    };\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (!\"REFRESH\".equals(command.toString())) {", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4MDIyMw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477580223", "bodyText": "Same here. Use equals (or you can use == because it's an enum) to compare and no string comparison:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (\"ON\".equals(command.toString())) {\n          \n          \n            \n                                if (OnOffType.ON.equals(command))) {", "author": "Hilbrand", "createdAt": "2020-08-26T20:48:31Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraGroupHandler.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.ipcamera.internal.StreamServerGroupHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * The {@link IpCameraGroupHandler} is responsible for finding cameras that are part of this group and displaying a\n+ * group picture.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraGroupHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_GROUPDISPLAY));\n+    private Configuration config;\n+    BigDecimal pollTimeInSeconds = new BigDecimal(2);\n+    public ArrayList<IpCameraHandler> cameraOrder = new ArrayList<IpCameraHandler>(2);\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private final ScheduledExecutorService pollCameraGroup = Executors.newSingleThreadScheduledExecutor();\n+    private @Nullable ScheduledFuture<?> pollCameraGroupJob = null;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public String hostIp = \"0.0.0.0\";\n+    boolean motionChangesOrder = true;\n+    public int serverPort = 0;\n+    public String playList = \"\";\n+    String playingNow = \"\";\n+    public int cameraIndex = 0;\n+    public boolean hlsTurnedOn = false;\n+    int entries = 0;\n+    BigDecimal numberOfFiles = new BigDecimal(1);\n+    int mediaSequence = 1;\n+    int discontinuitySequence = 0;\n+\n+    public IpCameraGroupHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    // @SuppressWarnings(\"null\")\n+    public String getWhiteList() {\n+        return (config.get(CONFIG_IP_WHITELIST) == null) ? \"\" : config.get(CONFIG_IP_WHITELIST).toString();\n+    }\n+\n+    public String getPlayList() {\n+        return playList;\n+    }\n+\n+    public String getOutputFolder(int index) {\n+        IpCameraHandler handle = cameraOrder.get(index);\n+        return (String) handle.config.get(CONFIG_FFMPEG_OUTPUT);\n+    }\n+\n+    private String readCamerasPlaylist(int cameraIndex) {\n+        String camerasm3u8 = \"\";\n+        IpCameraHandler handle = cameraOrder.get(cameraIndex);\n+        try {\n+            String file = handle.config.get(CONFIG_FFMPEG_OUTPUT).toString() + \"ipcamera.m3u8\";\n+            camerasm3u8 = new String(Files.readAllBytes(Paths.get(file)));\n+        } catch (IOException e) {\n+            logger.error(\"Error occured fetching cameras m3u8 file :{}\", e.getMessage());\n+        }\n+        return camerasm3u8;\n+    }\n+\n+    String keepLast(String string, int numberToRetain) {\n+        int start = string.length();\n+        for (int loop = numberToRetain; loop > 0; loop--) {\n+            start = string.lastIndexOf(\"#EXTINF:\", start - 1);\n+            if (start == -1) {\n+                logger.error(\n+                        \"Playlist did not contain enough entries, check all cameras in groups use the same HLS settings.\");\n+                return \"\";\n+            }\n+        }\n+        entries = entries + numberToRetain;\n+        return string.substring(start);\n+    }\n+\n+    String removeFromStart(String string, int numberToRemove) {\n+        int startingFrom = string.indexOf(\"#EXTINF:\");\n+        for (int loop = numberToRemove; loop > 0; loop--) {\n+            startingFrom = string.indexOf(\"#EXTINF:\", startingFrom + 27);\n+            if (startingFrom == -1) {\n+                logger.error(\n+                        \"Playlist failed to remove entries from start, check all cameras in groups use the same HLS settings.\");\n+                return string;\n+            }\n+        }\n+        mediaSequence = mediaSequence + numberToRemove;\n+        entries = entries - numberToRemove;\n+        return string.substring(startingFrom);\n+    }\n+\n+    int howManySegments(String m3u8File) {\n+        int start = m3u8File.length();\n+        int numberOfFiles = 0;\n+        for (BigDecimal totalTime = new BigDecimal(0); totalTime.intValue() < pollTimeInSeconds\n+                .intValue(); numberOfFiles++) {\n+            start = m3u8File.lastIndexOf(\"#EXTINF:\", start - 1);\n+            if (start != -1) {\n+                totalTime = totalTime.add(new BigDecimal(m3u8File.substring(start + 8, m3u8File.indexOf(\",\", start))));\n+            } else {\n+                logger.debug(\"Group did not find enough segments, lower the poll time if this message continues.\");\n+                break;\n+            }\n+        }\n+        return numberOfFiles;\n+    }\n+\n+    public void createPlayList() {\n+        String m3u8File = readCamerasPlaylist(cameraIndex);\n+        if (m3u8File == \"\") {\n+            return;\n+        }\n+        int numberOfSegments = howManySegments(m3u8File);\n+        logger.debug(\"Using {} segmented files to make up a poll period.\", numberOfSegments);\n+        m3u8File = keepLast(m3u8File, numberOfSegments);\n+        // logger.debug(\"replacing files to keep now\");\n+        m3u8File = m3u8File.replace(\"ipcamera\", cameraIndex + \"ipcamera\"); // add index so we can then fetch output path\n+        // logger.debug(\"There are {} segments, so we will remove {} from playlist.\", entries, numberOfSegments);\n+        if (entries > numberOfSegments * 3) {\n+            playingNow = removeFromStart(playingNow, entries - (numberOfSegments * 3));\n+        }\n+        playingNow = playingNow + \"#EXT-X-DISCONTINUITY\\n\" + m3u8File;\n+        playList = \"#EXTM3U\\n#EXT-X-VERSION:6\\n#EXT-X-TARGETDURATION:5\\n#EXT-X-ALLOW-CACHE:NO\\n#EXT-X-DISCONTINUITY-SEQUENCE:\"\n+                + discontinuitySequence + \"\\n#EXT-X-MEDIA-SEQUENCE:\" + mediaSequence + \"\\n\" + playingNow;\n+    }\n+\n+    private IpCameraGroupHandler getHandle() {\n+        return this;\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully(8, 8, TimeUnit.SECONDS);\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerGroupHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.info(\"IpCamera file server for a group of cameras has started on port {} for all NIC's.\",\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    logger.error(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number: {}\",\n+                            e.getMessage());\n+                }\n+            }\n+        }\n+    }\n+\n+    // @SuppressWarnings(\"null\")\n+    void addCamera(String UniqueID) {\n+        if (IpCameraHandler.listOfOnlineCameraUID.contains(UniqueID)) {\n+            for (IpCameraHandler handler : IpCameraHandler.listOfOnlineCameraHandlers) {\n+                if (handler.getThing().getUID().getId().equals(UniqueID)) {\n+                    if (!cameraOrder.contains(handler)) {\n+                        logger.info(\"Adding {} to a camera group.\", UniqueID);\n+                        if (hlsTurnedOn) {\n+                            logger.info(\"Starting HLS for the new camera.\");\n+                            String channelPrefix = \"ipcamera:\" + handler.getThing().getThingTypeUID() + \":\"\n+                                    + handler.getThing().getUID().getId() + \":\";\n+                            handler.handleCommand(new ChannelUID(channelPrefix + CHANNEL_START_STREAM),\n+                                    OnOffType.valueOf(\"ON\"));\n+                        }\n+                        cameraOrder.add(handler);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // Event based. This is called as each camera comes online after the group handler is registered.\n+    public void cameraOnline(String uid) {\n+        logger.debug(\"New camera {} came online, checking if part of this group\", uid);\n+        if (config.get(CONFIG_FIRST_CAM).equals(uid)) {\n+            addCamera(uid);\n+        } else if (config.get(CONFIG_SECOND_CAM).equals(uid)) {\n+            addCamera(uid);\n+        } else if (config.get(CONFIG_THIRD_CAM).equals(uid)) {\n+            addCamera(uid);\n+        } else if (config.get(CONFIG_FORTH_CAM).equals(uid)) {\n+            addCamera(uid);\n+        }\n+    }\n+\n+    // Event based. This is called as each camera comes online after the group handler is registered.\n+    public void cameraOffline(IpCameraHandler handle) {\n+        if (cameraOrder.remove(handle)) {\n+            logger.info(\"Camera {} is now offline, now removed from this group.\", handle.getThing().getUID().getId());\n+        }\n+    }\n+\n+    boolean addIfOnline(String UniqueID) {\n+        if (IpCameraHandler.listOfOnlineCameraUID.contains(UniqueID)) {\n+            addCamera(UniqueID);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    void createCameraOrder() {\n+        addIfOnline(config.get(CONFIG_FIRST_CAM).toString());\n+        addIfOnline(config.get(CONFIG_SECOND_CAM).toString());\n+        if (config.get(CONFIG_THIRD_CAM) != null) {\n+            addIfOnline(config.get(CONFIG_THIRD_CAM).toString());\n+        }\n+        if (config.get(CONFIG_FORTH_CAM) != null) {\n+            addIfOnline(config.get(CONFIG_FORTH_CAM).toString());\n+        }\n+        // Cameras can now send events of when they go on and offline.\n+        IpCameraHandler.listOfGroupHandlers.add(this);\n+    }\n+\n+    int checkForMotion(int nextCamerasIndex) {\n+        int checked = 0;\n+        for (int index = nextCamerasIndex; checked < cameraOrder.size(); checked++) {\n+            if (cameraOrder.get(index).motionDetected) {\n+                // logger.trace(\"Motion detected on a camera in a group, the display order has changed.\");\n+                return index;\n+            }\n+            if (++index >= cameraOrder.size()) {\n+                index = 0;\n+            }\n+        }\n+        return nextCamerasIndex;\n+    }\n+\n+    Runnable pollingCameraGroup = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (cameraOrder.isEmpty()) {\n+                createCameraOrder();\n+            }\n+            if (++cameraIndex >= cameraOrder.size()) {\n+                cameraIndex = 0;\n+            }\n+            if (motionChangesOrder) {\n+                cameraIndex = checkForMotion(cameraIndex);\n+            }\n+            if (hlsTurnedOn) {\n+                discontinuitySequence++;\n+                createPlayList();\n+                if (mediaSequence > 2147000000) {\n+                    mediaSequence = 0;\n+                    discontinuitySequence = 0;\n+                }\n+            }\n+        }\n+    };\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (!\"REFRESH\".equals(command.toString())) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_START_STREAM:\n+                    if (\"ON\".equals(command.toString())) {", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4MDYyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477580622", "bodyText": "The command is already logged. Maybe reduce this to debug here?", "author": "Hilbrand", "createdAt": "2020-08-26T20:49:20Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraGroupHandler.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.ipcamera.internal.StreamServerGroupHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * The {@link IpCameraGroupHandler} is responsible for finding cameras that are part of this group and displaying a\n+ * group picture.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraGroupHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_GROUPDISPLAY));\n+    private Configuration config;\n+    BigDecimal pollTimeInSeconds = new BigDecimal(2);\n+    public ArrayList<IpCameraHandler> cameraOrder = new ArrayList<IpCameraHandler>(2);\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private final ScheduledExecutorService pollCameraGroup = Executors.newSingleThreadScheduledExecutor();\n+    private @Nullable ScheduledFuture<?> pollCameraGroupJob = null;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public String hostIp = \"0.0.0.0\";\n+    boolean motionChangesOrder = true;\n+    public int serverPort = 0;\n+    public String playList = \"\";\n+    String playingNow = \"\";\n+    public int cameraIndex = 0;\n+    public boolean hlsTurnedOn = false;\n+    int entries = 0;\n+    BigDecimal numberOfFiles = new BigDecimal(1);\n+    int mediaSequence = 1;\n+    int discontinuitySequence = 0;\n+\n+    public IpCameraGroupHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    // @SuppressWarnings(\"null\")\n+    public String getWhiteList() {\n+        return (config.get(CONFIG_IP_WHITELIST) == null) ? \"\" : config.get(CONFIG_IP_WHITELIST).toString();\n+    }\n+\n+    public String getPlayList() {\n+        return playList;\n+    }\n+\n+    public String getOutputFolder(int index) {\n+        IpCameraHandler handle = cameraOrder.get(index);\n+        return (String) handle.config.get(CONFIG_FFMPEG_OUTPUT);\n+    }\n+\n+    private String readCamerasPlaylist(int cameraIndex) {\n+        String camerasm3u8 = \"\";\n+        IpCameraHandler handle = cameraOrder.get(cameraIndex);\n+        try {\n+            String file = handle.config.get(CONFIG_FFMPEG_OUTPUT).toString() + \"ipcamera.m3u8\";\n+            camerasm3u8 = new String(Files.readAllBytes(Paths.get(file)));\n+        } catch (IOException e) {\n+            logger.error(\"Error occured fetching cameras m3u8 file :{}\", e.getMessage());\n+        }\n+        return camerasm3u8;\n+    }\n+\n+    String keepLast(String string, int numberToRetain) {\n+        int start = string.length();\n+        for (int loop = numberToRetain; loop > 0; loop--) {\n+            start = string.lastIndexOf(\"#EXTINF:\", start - 1);\n+            if (start == -1) {\n+                logger.error(\n+                        \"Playlist did not contain enough entries, check all cameras in groups use the same HLS settings.\");\n+                return \"\";\n+            }\n+        }\n+        entries = entries + numberToRetain;\n+        return string.substring(start);\n+    }\n+\n+    String removeFromStart(String string, int numberToRemove) {\n+        int startingFrom = string.indexOf(\"#EXTINF:\");\n+        for (int loop = numberToRemove; loop > 0; loop--) {\n+            startingFrom = string.indexOf(\"#EXTINF:\", startingFrom + 27);\n+            if (startingFrom == -1) {\n+                logger.error(\n+                        \"Playlist failed to remove entries from start, check all cameras in groups use the same HLS settings.\");\n+                return string;\n+            }\n+        }\n+        mediaSequence = mediaSequence + numberToRemove;\n+        entries = entries - numberToRemove;\n+        return string.substring(startingFrom);\n+    }\n+\n+    int howManySegments(String m3u8File) {\n+        int start = m3u8File.length();\n+        int numberOfFiles = 0;\n+        for (BigDecimal totalTime = new BigDecimal(0); totalTime.intValue() < pollTimeInSeconds\n+                .intValue(); numberOfFiles++) {\n+            start = m3u8File.lastIndexOf(\"#EXTINF:\", start - 1);\n+            if (start != -1) {\n+                totalTime = totalTime.add(new BigDecimal(m3u8File.substring(start + 8, m3u8File.indexOf(\",\", start))));\n+            } else {\n+                logger.debug(\"Group did not find enough segments, lower the poll time if this message continues.\");\n+                break;\n+            }\n+        }\n+        return numberOfFiles;\n+    }\n+\n+    public void createPlayList() {\n+        String m3u8File = readCamerasPlaylist(cameraIndex);\n+        if (m3u8File == \"\") {\n+            return;\n+        }\n+        int numberOfSegments = howManySegments(m3u8File);\n+        logger.debug(\"Using {} segmented files to make up a poll period.\", numberOfSegments);\n+        m3u8File = keepLast(m3u8File, numberOfSegments);\n+        // logger.debug(\"replacing files to keep now\");\n+        m3u8File = m3u8File.replace(\"ipcamera\", cameraIndex + \"ipcamera\"); // add index so we can then fetch output path\n+        // logger.debug(\"There are {} segments, so we will remove {} from playlist.\", entries, numberOfSegments);\n+        if (entries > numberOfSegments * 3) {\n+            playingNow = removeFromStart(playingNow, entries - (numberOfSegments * 3));\n+        }\n+        playingNow = playingNow + \"#EXT-X-DISCONTINUITY\\n\" + m3u8File;\n+        playList = \"#EXTM3U\\n#EXT-X-VERSION:6\\n#EXT-X-TARGETDURATION:5\\n#EXT-X-ALLOW-CACHE:NO\\n#EXT-X-DISCONTINUITY-SEQUENCE:\"\n+                + discontinuitySequence + \"\\n#EXT-X-MEDIA-SEQUENCE:\" + mediaSequence + \"\\n\" + playingNow;\n+    }\n+\n+    private IpCameraGroupHandler getHandle() {\n+        return this;\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully(8, 8, TimeUnit.SECONDS);\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerGroupHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.info(\"IpCamera file server for a group of cameras has started on port {} for all NIC's.\",\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    logger.error(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number: {}\",\n+                            e.getMessage());\n+                }\n+            }\n+        }\n+    }\n+\n+    // @SuppressWarnings(\"null\")\n+    void addCamera(String UniqueID) {\n+        if (IpCameraHandler.listOfOnlineCameraUID.contains(UniqueID)) {\n+            for (IpCameraHandler handler : IpCameraHandler.listOfOnlineCameraHandlers) {\n+                if (handler.getThing().getUID().getId().equals(UniqueID)) {\n+                    if (!cameraOrder.contains(handler)) {\n+                        logger.info(\"Adding {} to a camera group.\", UniqueID);\n+                        if (hlsTurnedOn) {\n+                            logger.info(\"Starting HLS for the new camera.\");\n+                            String channelPrefix = \"ipcamera:\" + handler.getThing().getThingTypeUID() + \":\"\n+                                    + handler.getThing().getUID().getId() + \":\";\n+                            handler.handleCommand(new ChannelUID(channelPrefix + CHANNEL_START_STREAM),\n+                                    OnOffType.valueOf(\"ON\"));\n+                        }\n+                        cameraOrder.add(handler);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // Event based. This is called as each camera comes online after the group handler is registered.\n+    public void cameraOnline(String uid) {\n+        logger.debug(\"New camera {} came online, checking if part of this group\", uid);\n+        if (config.get(CONFIG_FIRST_CAM).equals(uid)) {\n+            addCamera(uid);\n+        } else if (config.get(CONFIG_SECOND_CAM).equals(uid)) {\n+            addCamera(uid);\n+        } else if (config.get(CONFIG_THIRD_CAM).equals(uid)) {\n+            addCamera(uid);\n+        } else if (config.get(CONFIG_FORTH_CAM).equals(uid)) {\n+            addCamera(uid);\n+        }\n+    }\n+\n+    // Event based. This is called as each camera comes online after the group handler is registered.\n+    public void cameraOffline(IpCameraHandler handle) {\n+        if (cameraOrder.remove(handle)) {\n+            logger.info(\"Camera {} is now offline, now removed from this group.\", handle.getThing().getUID().getId());\n+        }\n+    }\n+\n+    boolean addIfOnline(String UniqueID) {\n+        if (IpCameraHandler.listOfOnlineCameraUID.contains(UniqueID)) {\n+            addCamera(UniqueID);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    void createCameraOrder() {\n+        addIfOnline(config.get(CONFIG_FIRST_CAM).toString());\n+        addIfOnline(config.get(CONFIG_SECOND_CAM).toString());\n+        if (config.get(CONFIG_THIRD_CAM) != null) {\n+            addIfOnline(config.get(CONFIG_THIRD_CAM).toString());\n+        }\n+        if (config.get(CONFIG_FORTH_CAM) != null) {\n+            addIfOnline(config.get(CONFIG_FORTH_CAM).toString());\n+        }\n+        // Cameras can now send events of when they go on and offline.\n+        IpCameraHandler.listOfGroupHandlers.add(this);\n+    }\n+\n+    int checkForMotion(int nextCamerasIndex) {\n+        int checked = 0;\n+        for (int index = nextCamerasIndex; checked < cameraOrder.size(); checked++) {\n+            if (cameraOrder.get(index).motionDetected) {\n+                // logger.trace(\"Motion detected on a camera in a group, the display order has changed.\");\n+                return index;\n+            }\n+            if (++index >= cameraOrder.size()) {\n+                index = 0;\n+            }\n+        }\n+        return nextCamerasIndex;\n+    }\n+\n+    Runnable pollingCameraGroup = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (cameraOrder.isEmpty()) {\n+                createCameraOrder();\n+            }\n+            if (++cameraIndex >= cameraOrder.size()) {\n+                cameraIndex = 0;\n+            }\n+            if (motionChangesOrder) {\n+                cameraIndex = checkForMotion(cameraIndex);\n+            }\n+            if (hlsTurnedOn) {\n+                discontinuitySequence++;\n+                createPlayList();\n+                if (mediaSequence > 2147000000) {\n+                    mediaSequence = 0;\n+                    discontinuitySequence = 0;\n+                }\n+            }\n+        }\n+    };\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (!\"REFRESH\".equals(command.toString())) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_START_STREAM:\n+                    if (\"ON\".equals(command.toString())) {\n+                        logger.info(\"Starting HLS generation for all cameras in a group.\");", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA4NDU1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r481084559", "bodyText": "Removed it.", "author": "Skinah", "createdAt": "2020-09-01T12:01:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4MDYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4MDkxNg==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477580916", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                OnOffType.valueOf(\"ON\"));\n          \n          \n            \n                                                OnOffType.ON);", "author": "Hilbrand", "createdAt": "2020-08-26T20:49:56Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraGroupHandler.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.ipcamera.internal.StreamServerGroupHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * The {@link IpCameraGroupHandler} is responsible for finding cameras that are part of this group and displaying a\n+ * group picture.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraGroupHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_GROUPDISPLAY));\n+    private Configuration config;\n+    BigDecimal pollTimeInSeconds = new BigDecimal(2);\n+    public ArrayList<IpCameraHandler> cameraOrder = new ArrayList<IpCameraHandler>(2);\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private final ScheduledExecutorService pollCameraGroup = Executors.newSingleThreadScheduledExecutor();\n+    private @Nullable ScheduledFuture<?> pollCameraGroupJob = null;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public String hostIp = \"0.0.0.0\";\n+    boolean motionChangesOrder = true;\n+    public int serverPort = 0;\n+    public String playList = \"\";\n+    String playingNow = \"\";\n+    public int cameraIndex = 0;\n+    public boolean hlsTurnedOn = false;\n+    int entries = 0;\n+    BigDecimal numberOfFiles = new BigDecimal(1);\n+    int mediaSequence = 1;\n+    int discontinuitySequence = 0;\n+\n+    public IpCameraGroupHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    // @SuppressWarnings(\"null\")\n+    public String getWhiteList() {\n+        return (config.get(CONFIG_IP_WHITELIST) == null) ? \"\" : config.get(CONFIG_IP_WHITELIST).toString();\n+    }\n+\n+    public String getPlayList() {\n+        return playList;\n+    }\n+\n+    public String getOutputFolder(int index) {\n+        IpCameraHandler handle = cameraOrder.get(index);\n+        return (String) handle.config.get(CONFIG_FFMPEG_OUTPUT);\n+    }\n+\n+    private String readCamerasPlaylist(int cameraIndex) {\n+        String camerasm3u8 = \"\";\n+        IpCameraHandler handle = cameraOrder.get(cameraIndex);\n+        try {\n+            String file = handle.config.get(CONFIG_FFMPEG_OUTPUT).toString() + \"ipcamera.m3u8\";\n+            camerasm3u8 = new String(Files.readAllBytes(Paths.get(file)));\n+        } catch (IOException e) {\n+            logger.error(\"Error occured fetching cameras m3u8 file :{}\", e.getMessage());\n+        }\n+        return camerasm3u8;\n+    }\n+\n+    String keepLast(String string, int numberToRetain) {\n+        int start = string.length();\n+        for (int loop = numberToRetain; loop > 0; loop--) {\n+            start = string.lastIndexOf(\"#EXTINF:\", start - 1);\n+            if (start == -1) {\n+                logger.error(\n+                        \"Playlist did not contain enough entries, check all cameras in groups use the same HLS settings.\");\n+                return \"\";\n+            }\n+        }\n+        entries = entries + numberToRetain;\n+        return string.substring(start);\n+    }\n+\n+    String removeFromStart(String string, int numberToRemove) {\n+        int startingFrom = string.indexOf(\"#EXTINF:\");\n+        for (int loop = numberToRemove; loop > 0; loop--) {\n+            startingFrom = string.indexOf(\"#EXTINF:\", startingFrom + 27);\n+            if (startingFrom == -1) {\n+                logger.error(\n+                        \"Playlist failed to remove entries from start, check all cameras in groups use the same HLS settings.\");\n+                return string;\n+            }\n+        }\n+        mediaSequence = mediaSequence + numberToRemove;\n+        entries = entries - numberToRemove;\n+        return string.substring(startingFrom);\n+    }\n+\n+    int howManySegments(String m3u8File) {\n+        int start = m3u8File.length();\n+        int numberOfFiles = 0;\n+        for (BigDecimal totalTime = new BigDecimal(0); totalTime.intValue() < pollTimeInSeconds\n+                .intValue(); numberOfFiles++) {\n+            start = m3u8File.lastIndexOf(\"#EXTINF:\", start - 1);\n+            if (start != -1) {\n+                totalTime = totalTime.add(new BigDecimal(m3u8File.substring(start + 8, m3u8File.indexOf(\",\", start))));\n+            } else {\n+                logger.debug(\"Group did not find enough segments, lower the poll time if this message continues.\");\n+                break;\n+            }\n+        }\n+        return numberOfFiles;\n+    }\n+\n+    public void createPlayList() {\n+        String m3u8File = readCamerasPlaylist(cameraIndex);\n+        if (m3u8File == \"\") {\n+            return;\n+        }\n+        int numberOfSegments = howManySegments(m3u8File);\n+        logger.debug(\"Using {} segmented files to make up a poll period.\", numberOfSegments);\n+        m3u8File = keepLast(m3u8File, numberOfSegments);\n+        // logger.debug(\"replacing files to keep now\");\n+        m3u8File = m3u8File.replace(\"ipcamera\", cameraIndex + \"ipcamera\"); // add index so we can then fetch output path\n+        // logger.debug(\"There are {} segments, so we will remove {} from playlist.\", entries, numberOfSegments);\n+        if (entries > numberOfSegments * 3) {\n+            playingNow = removeFromStart(playingNow, entries - (numberOfSegments * 3));\n+        }\n+        playingNow = playingNow + \"#EXT-X-DISCONTINUITY\\n\" + m3u8File;\n+        playList = \"#EXTM3U\\n#EXT-X-VERSION:6\\n#EXT-X-TARGETDURATION:5\\n#EXT-X-ALLOW-CACHE:NO\\n#EXT-X-DISCONTINUITY-SEQUENCE:\"\n+                + discontinuitySequence + \"\\n#EXT-X-MEDIA-SEQUENCE:\" + mediaSequence + \"\\n\" + playingNow;\n+    }\n+\n+    private IpCameraGroupHandler getHandle() {\n+        return this;\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully(8, 8, TimeUnit.SECONDS);\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerGroupHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.info(\"IpCamera file server for a group of cameras has started on port {} for all NIC's.\",\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    logger.error(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number: {}\",\n+                            e.getMessage());\n+                }\n+            }\n+        }\n+    }\n+\n+    // @SuppressWarnings(\"null\")\n+    void addCamera(String UniqueID) {\n+        if (IpCameraHandler.listOfOnlineCameraUID.contains(UniqueID)) {\n+            for (IpCameraHandler handler : IpCameraHandler.listOfOnlineCameraHandlers) {\n+                if (handler.getThing().getUID().getId().equals(UniqueID)) {\n+                    if (!cameraOrder.contains(handler)) {\n+                        logger.info(\"Adding {} to a camera group.\", UniqueID);\n+                        if (hlsTurnedOn) {\n+                            logger.info(\"Starting HLS for the new camera.\");\n+                            String channelPrefix = \"ipcamera:\" + handler.getThing().getThingTypeUID() + \":\"\n+                                    + handler.getThing().getUID().getId() + \":\";\n+                            handler.handleCommand(new ChannelUID(channelPrefix + CHANNEL_START_STREAM),\n+                                    OnOffType.valueOf(\"ON\"));\n+                        }\n+                        cameraOrder.add(handler);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // Event based. This is called as each camera comes online after the group handler is registered.\n+    public void cameraOnline(String uid) {\n+        logger.debug(\"New camera {} came online, checking if part of this group\", uid);\n+        if (config.get(CONFIG_FIRST_CAM).equals(uid)) {\n+            addCamera(uid);\n+        } else if (config.get(CONFIG_SECOND_CAM).equals(uid)) {\n+            addCamera(uid);\n+        } else if (config.get(CONFIG_THIRD_CAM).equals(uid)) {\n+            addCamera(uid);\n+        } else if (config.get(CONFIG_FORTH_CAM).equals(uid)) {\n+            addCamera(uid);\n+        }\n+    }\n+\n+    // Event based. This is called as each camera comes online after the group handler is registered.\n+    public void cameraOffline(IpCameraHandler handle) {\n+        if (cameraOrder.remove(handle)) {\n+            logger.info(\"Camera {} is now offline, now removed from this group.\", handle.getThing().getUID().getId());\n+        }\n+    }\n+\n+    boolean addIfOnline(String UniqueID) {\n+        if (IpCameraHandler.listOfOnlineCameraUID.contains(UniqueID)) {\n+            addCamera(UniqueID);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    void createCameraOrder() {\n+        addIfOnline(config.get(CONFIG_FIRST_CAM).toString());\n+        addIfOnline(config.get(CONFIG_SECOND_CAM).toString());\n+        if (config.get(CONFIG_THIRD_CAM) != null) {\n+            addIfOnline(config.get(CONFIG_THIRD_CAM).toString());\n+        }\n+        if (config.get(CONFIG_FORTH_CAM) != null) {\n+            addIfOnline(config.get(CONFIG_FORTH_CAM).toString());\n+        }\n+        // Cameras can now send events of when they go on and offline.\n+        IpCameraHandler.listOfGroupHandlers.add(this);\n+    }\n+\n+    int checkForMotion(int nextCamerasIndex) {\n+        int checked = 0;\n+        for (int index = nextCamerasIndex; checked < cameraOrder.size(); checked++) {\n+            if (cameraOrder.get(index).motionDetected) {\n+                // logger.trace(\"Motion detected on a camera in a group, the display order has changed.\");\n+                return index;\n+            }\n+            if (++index >= cameraOrder.size()) {\n+                index = 0;\n+            }\n+        }\n+        return nextCamerasIndex;\n+    }\n+\n+    Runnable pollingCameraGroup = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (cameraOrder.isEmpty()) {\n+                createCameraOrder();\n+            }\n+            if (++cameraIndex >= cameraOrder.size()) {\n+                cameraIndex = 0;\n+            }\n+            if (motionChangesOrder) {\n+                cameraIndex = checkForMotion(cameraIndex);\n+            }\n+            if (hlsTurnedOn) {\n+                discontinuitySequence++;\n+                createPlayList();\n+                if (mediaSequence > 2147000000) {\n+                    mediaSequence = 0;\n+                    discontinuitySequence = 0;\n+                }\n+            }\n+        }\n+    };\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (!\"REFRESH\".equals(command.toString())) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_START_STREAM:\n+                    if (\"ON\".equals(command.toString())) {\n+                        logger.info(\"Starting HLS generation for all cameras in a group.\");\n+                        hlsTurnedOn = true;\n+                        for (IpCameraHandler handler : cameraOrder) {\n+                            String channelPrefix = \"ipcamera:\" + handler.getThing().getThingTypeUID() + \":\"\n+                                    + handler.getThing().getUID().getId() + \":\";\n+\n+                            handler.handleCommand(new ChannelUID(channelPrefix + CHANNEL_START_STREAM),\n+                                    OnOffType.valueOf(\"ON\"));", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4MTY5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477581693", "bodyText": "Can this Expection be reduced to catch the specific Exception(s) or does a method throw Exception?", "author": "Hilbrand", "createdAt": "2020-08-26T20:51:27Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraGroupHandler.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.ipcamera.internal.StreamServerGroupHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * The {@link IpCameraGroupHandler} is responsible for finding cameras that are part of this group and displaying a\n+ * group picture.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraGroupHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_GROUPDISPLAY));\n+    private Configuration config;\n+    BigDecimal pollTimeInSeconds = new BigDecimal(2);\n+    public ArrayList<IpCameraHandler> cameraOrder = new ArrayList<IpCameraHandler>(2);\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private final ScheduledExecutorService pollCameraGroup = Executors.newSingleThreadScheduledExecutor();\n+    private @Nullable ScheduledFuture<?> pollCameraGroupJob = null;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public String hostIp = \"0.0.0.0\";\n+    boolean motionChangesOrder = true;\n+    public int serverPort = 0;\n+    public String playList = \"\";\n+    String playingNow = \"\";\n+    public int cameraIndex = 0;\n+    public boolean hlsTurnedOn = false;\n+    int entries = 0;\n+    BigDecimal numberOfFiles = new BigDecimal(1);\n+    int mediaSequence = 1;\n+    int discontinuitySequence = 0;\n+\n+    public IpCameraGroupHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    // @SuppressWarnings(\"null\")\n+    public String getWhiteList() {\n+        return (config.get(CONFIG_IP_WHITELIST) == null) ? \"\" : config.get(CONFIG_IP_WHITELIST).toString();\n+    }\n+\n+    public String getPlayList() {\n+        return playList;\n+    }\n+\n+    public String getOutputFolder(int index) {\n+        IpCameraHandler handle = cameraOrder.get(index);\n+        return (String) handle.config.get(CONFIG_FFMPEG_OUTPUT);\n+    }\n+\n+    private String readCamerasPlaylist(int cameraIndex) {\n+        String camerasm3u8 = \"\";\n+        IpCameraHandler handle = cameraOrder.get(cameraIndex);\n+        try {\n+            String file = handle.config.get(CONFIG_FFMPEG_OUTPUT).toString() + \"ipcamera.m3u8\";\n+            camerasm3u8 = new String(Files.readAllBytes(Paths.get(file)));\n+        } catch (IOException e) {\n+            logger.error(\"Error occured fetching cameras m3u8 file :{}\", e.getMessage());\n+        }\n+        return camerasm3u8;\n+    }\n+\n+    String keepLast(String string, int numberToRetain) {\n+        int start = string.length();\n+        for (int loop = numberToRetain; loop > 0; loop--) {\n+            start = string.lastIndexOf(\"#EXTINF:\", start - 1);\n+            if (start == -1) {\n+                logger.error(\n+                        \"Playlist did not contain enough entries, check all cameras in groups use the same HLS settings.\");\n+                return \"\";\n+            }\n+        }\n+        entries = entries + numberToRetain;\n+        return string.substring(start);\n+    }\n+\n+    String removeFromStart(String string, int numberToRemove) {\n+        int startingFrom = string.indexOf(\"#EXTINF:\");\n+        for (int loop = numberToRemove; loop > 0; loop--) {\n+            startingFrom = string.indexOf(\"#EXTINF:\", startingFrom + 27);\n+            if (startingFrom == -1) {\n+                logger.error(\n+                        \"Playlist failed to remove entries from start, check all cameras in groups use the same HLS settings.\");\n+                return string;\n+            }\n+        }\n+        mediaSequence = mediaSequence + numberToRemove;\n+        entries = entries - numberToRemove;\n+        return string.substring(startingFrom);\n+    }\n+\n+    int howManySegments(String m3u8File) {\n+        int start = m3u8File.length();\n+        int numberOfFiles = 0;\n+        for (BigDecimal totalTime = new BigDecimal(0); totalTime.intValue() < pollTimeInSeconds\n+                .intValue(); numberOfFiles++) {\n+            start = m3u8File.lastIndexOf(\"#EXTINF:\", start - 1);\n+            if (start != -1) {\n+                totalTime = totalTime.add(new BigDecimal(m3u8File.substring(start + 8, m3u8File.indexOf(\",\", start))));\n+            } else {\n+                logger.debug(\"Group did not find enough segments, lower the poll time if this message continues.\");\n+                break;\n+            }\n+        }\n+        return numberOfFiles;\n+    }\n+\n+    public void createPlayList() {\n+        String m3u8File = readCamerasPlaylist(cameraIndex);\n+        if (m3u8File == \"\") {\n+            return;\n+        }\n+        int numberOfSegments = howManySegments(m3u8File);\n+        logger.debug(\"Using {} segmented files to make up a poll period.\", numberOfSegments);\n+        m3u8File = keepLast(m3u8File, numberOfSegments);\n+        // logger.debug(\"replacing files to keep now\");\n+        m3u8File = m3u8File.replace(\"ipcamera\", cameraIndex + \"ipcamera\"); // add index so we can then fetch output path\n+        // logger.debug(\"There are {} segments, so we will remove {} from playlist.\", entries, numberOfSegments);\n+        if (entries > numberOfSegments * 3) {\n+            playingNow = removeFromStart(playingNow, entries - (numberOfSegments * 3));\n+        }\n+        playingNow = playingNow + \"#EXT-X-DISCONTINUITY\\n\" + m3u8File;\n+        playList = \"#EXTM3U\\n#EXT-X-VERSION:6\\n#EXT-X-TARGETDURATION:5\\n#EXT-X-ALLOW-CACHE:NO\\n#EXT-X-DISCONTINUITY-SEQUENCE:\"\n+                + discontinuitySequence + \"\\n#EXT-X-MEDIA-SEQUENCE:\" + mediaSequence + \"\\n\" + playingNow;\n+    }\n+\n+    private IpCameraGroupHandler getHandle() {\n+        return this;\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully(8, 8, TimeUnit.SECONDS);\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerGroupHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.info(\"IpCamera file server for a group of cameras has started on port {} for all NIC's.\",\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4MjczNg==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477582736", "bodyText": "Is this a bug when this happens? If not it should probably not log to error. It might even need to set the thing status to offline with the specific text shown here so the user doesn't have to look into the logs to find out what's wrong.\nAlso log the actual exception, by adding  , e);", "author": "Hilbrand", "createdAt": "2020-08-26T20:53:39Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraGroupHandler.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.ipcamera.internal.StreamServerGroupHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * The {@link IpCameraGroupHandler} is responsible for finding cameras that are part of this group and displaying a\n+ * group picture.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraGroupHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_GROUPDISPLAY));\n+    private Configuration config;\n+    BigDecimal pollTimeInSeconds = new BigDecimal(2);\n+    public ArrayList<IpCameraHandler> cameraOrder = new ArrayList<IpCameraHandler>(2);\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private final ScheduledExecutorService pollCameraGroup = Executors.newSingleThreadScheduledExecutor();\n+    private @Nullable ScheduledFuture<?> pollCameraGroupJob = null;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public String hostIp = \"0.0.0.0\";\n+    boolean motionChangesOrder = true;\n+    public int serverPort = 0;\n+    public String playList = \"\";\n+    String playingNow = \"\";\n+    public int cameraIndex = 0;\n+    public boolean hlsTurnedOn = false;\n+    int entries = 0;\n+    BigDecimal numberOfFiles = new BigDecimal(1);\n+    int mediaSequence = 1;\n+    int discontinuitySequence = 0;\n+\n+    public IpCameraGroupHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    // @SuppressWarnings(\"null\")\n+    public String getWhiteList() {\n+        return (config.get(CONFIG_IP_WHITELIST) == null) ? \"\" : config.get(CONFIG_IP_WHITELIST).toString();\n+    }\n+\n+    public String getPlayList() {\n+        return playList;\n+    }\n+\n+    public String getOutputFolder(int index) {\n+        IpCameraHandler handle = cameraOrder.get(index);\n+        return (String) handle.config.get(CONFIG_FFMPEG_OUTPUT);\n+    }\n+\n+    private String readCamerasPlaylist(int cameraIndex) {\n+        String camerasm3u8 = \"\";\n+        IpCameraHandler handle = cameraOrder.get(cameraIndex);\n+        try {\n+            String file = handle.config.get(CONFIG_FFMPEG_OUTPUT).toString() + \"ipcamera.m3u8\";\n+            camerasm3u8 = new String(Files.readAllBytes(Paths.get(file)));\n+        } catch (IOException e) {\n+            logger.error(\"Error occured fetching cameras m3u8 file :{}\", e.getMessage());\n+        }\n+        return camerasm3u8;\n+    }\n+\n+    String keepLast(String string, int numberToRetain) {\n+        int start = string.length();\n+        for (int loop = numberToRetain; loop > 0; loop--) {\n+            start = string.lastIndexOf(\"#EXTINF:\", start - 1);\n+            if (start == -1) {\n+                logger.error(\n+                        \"Playlist did not contain enough entries, check all cameras in groups use the same HLS settings.\");\n+                return \"\";\n+            }\n+        }\n+        entries = entries + numberToRetain;\n+        return string.substring(start);\n+    }\n+\n+    String removeFromStart(String string, int numberToRemove) {\n+        int startingFrom = string.indexOf(\"#EXTINF:\");\n+        for (int loop = numberToRemove; loop > 0; loop--) {\n+            startingFrom = string.indexOf(\"#EXTINF:\", startingFrom + 27);\n+            if (startingFrom == -1) {\n+                logger.error(\n+                        \"Playlist failed to remove entries from start, check all cameras in groups use the same HLS settings.\");\n+                return string;\n+            }\n+        }\n+        mediaSequence = mediaSequence + numberToRemove;\n+        entries = entries - numberToRemove;\n+        return string.substring(startingFrom);\n+    }\n+\n+    int howManySegments(String m3u8File) {\n+        int start = m3u8File.length();\n+        int numberOfFiles = 0;\n+        for (BigDecimal totalTime = new BigDecimal(0); totalTime.intValue() < pollTimeInSeconds\n+                .intValue(); numberOfFiles++) {\n+            start = m3u8File.lastIndexOf(\"#EXTINF:\", start - 1);\n+            if (start != -1) {\n+                totalTime = totalTime.add(new BigDecimal(m3u8File.substring(start + 8, m3u8File.indexOf(\",\", start))));\n+            } else {\n+                logger.debug(\"Group did not find enough segments, lower the poll time if this message continues.\");\n+                break;\n+            }\n+        }\n+        return numberOfFiles;\n+    }\n+\n+    public void createPlayList() {\n+        String m3u8File = readCamerasPlaylist(cameraIndex);\n+        if (m3u8File == \"\") {\n+            return;\n+        }\n+        int numberOfSegments = howManySegments(m3u8File);\n+        logger.debug(\"Using {} segmented files to make up a poll period.\", numberOfSegments);\n+        m3u8File = keepLast(m3u8File, numberOfSegments);\n+        // logger.debug(\"replacing files to keep now\");\n+        m3u8File = m3u8File.replace(\"ipcamera\", cameraIndex + \"ipcamera\"); // add index so we can then fetch output path\n+        // logger.debug(\"There are {} segments, so we will remove {} from playlist.\", entries, numberOfSegments);\n+        if (entries > numberOfSegments * 3) {\n+            playingNow = removeFromStart(playingNow, entries - (numberOfSegments * 3));\n+        }\n+        playingNow = playingNow + \"#EXT-X-DISCONTINUITY\\n\" + m3u8File;\n+        playList = \"#EXTM3U\\n#EXT-X-VERSION:6\\n#EXT-X-TARGETDURATION:5\\n#EXT-X-ALLOW-CACHE:NO\\n#EXT-X-DISCONTINUITY-SEQUENCE:\"\n+                + discontinuitySequence + \"\\n#EXT-X-MEDIA-SEQUENCE:\" + mediaSequence + \"\\n\" + playingNow;\n+    }\n+\n+    private IpCameraGroupHandler getHandle() {\n+        return this;\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully(8, 8, TimeUnit.SECONDS);\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerGroupHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.info(\"IpCamera file server for a group of cameras has started on port {} for all NIC's.\",\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    logger.error(", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg0OTg3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r481849879", "bodyText": "DONE: sets thing to offline with status.", "author": "Skinah", "createdAt": "2020-09-02T07:51:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4MjczNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4MjkzNg==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477582936", "bodyText": "Removed commented out code.", "author": "Hilbrand", "createdAt": "2020-08-26T20:54:06Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraGroupHandler.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.ipcamera.internal.StreamServerGroupHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * The {@link IpCameraGroupHandler} is responsible for finding cameras that are part of this group and displaying a\n+ * group picture.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraGroupHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_GROUPDISPLAY));\n+    private Configuration config;\n+    BigDecimal pollTimeInSeconds = new BigDecimal(2);\n+    public ArrayList<IpCameraHandler> cameraOrder = new ArrayList<IpCameraHandler>(2);\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private final ScheduledExecutorService pollCameraGroup = Executors.newSingleThreadScheduledExecutor();\n+    private @Nullable ScheduledFuture<?> pollCameraGroupJob = null;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public String hostIp = \"0.0.0.0\";\n+    boolean motionChangesOrder = true;\n+    public int serverPort = 0;\n+    public String playList = \"\";\n+    String playingNow = \"\";\n+    public int cameraIndex = 0;\n+    public boolean hlsTurnedOn = false;\n+    int entries = 0;\n+    BigDecimal numberOfFiles = new BigDecimal(1);\n+    int mediaSequence = 1;\n+    int discontinuitySequence = 0;\n+\n+    public IpCameraGroupHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    // @SuppressWarnings(\"null\")\n+    public String getWhiteList() {\n+        return (config.get(CONFIG_IP_WHITELIST) == null) ? \"\" : config.get(CONFIG_IP_WHITELIST).toString();\n+    }\n+\n+    public String getPlayList() {\n+        return playList;\n+    }\n+\n+    public String getOutputFolder(int index) {\n+        IpCameraHandler handle = cameraOrder.get(index);\n+        return (String) handle.config.get(CONFIG_FFMPEG_OUTPUT);\n+    }\n+\n+    private String readCamerasPlaylist(int cameraIndex) {\n+        String camerasm3u8 = \"\";\n+        IpCameraHandler handle = cameraOrder.get(cameraIndex);\n+        try {\n+            String file = handle.config.get(CONFIG_FFMPEG_OUTPUT).toString() + \"ipcamera.m3u8\";\n+            camerasm3u8 = new String(Files.readAllBytes(Paths.get(file)));\n+        } catch (IOException e) {\n+            logger.error(\"Error occured fetching cameras m3u8 file :{}\", e.getMessage());\n+        }\n+        return camerasm3u8;\n+    }\n+\n+    String keepLast(String string, int numberToRetain) {\n+        int start = string.length();\n+        for (int loop = numberToRetain; loop > 0; loop--) {\n+            start = string.lastIndexOf(\"#EXTINF:\", start - 1);\n+            if (start == -1) {\n+                logger.error(\n+                        \"Playlist did not contain enough entries, check all cameras in groups use the same HLS settings.\");\n+                return \"\";\n+            }\n+        }\n+        entries = entries + numberToRetain;\n+        return string.substring(start);\n+    }\n+\n+    String removeFromStart(String string, int numberToRemove) {\n+        int startingFrom = string.indexOf(\"#EXTINF:\");\n+        for (int loop = numberToRemove; loop > 0; loop--) {\n+            startingFrom = string.indexOf(\"#EXTINF:\", startingFrom + 27);\n+            if (startingFrom == -1) {\n+                logger.error(\n+                        \"Playlist failed to remove entries from start, check all cameras in groups use the same HLS settings.\");\n+                return string;\n+            }\n+        }\n+        mediaSequence = mediaSequence + numberToRemove;\n+        entries = entries - numberToRemove;\n+        return string.substring(startingFrom);\n+    }\n+\n+    int howManySegments(String m3u8File) {\n+        int start = m3u8File.length();\n+        int numberOfFiles = 0;\n+        for (BigDecimal totalTime = new BigDecimal(0); totalTime.intValue() < pollTimeInSeconds\n+                .intValue(); numberOfFiles++) {\n+            start = m3u8File.lastIndexOf(\"#EXTINF:\", start - 1);\n+            if (start != -1) {\n+                totalTime = totalTime.add(new BigDecimal(m3u8File.substring(start + 8, m3u8File.indexOf(\",\", start))));\n+            } else {\n+                logger.debug(\"Group did not find enough segments, lower the poll time if this message continues.\");\n+                break;\n+            }\n+        }\n+        return numberOfFiles;\n+    }\n+\n+    public void createPlayList() {\n+        String m3u8File = readCamerasPlaylist(cameraIndex);\n+        if (m3u8File == \"\") {\n+            return;\n+        }\n+        int numberOfSegments = howManySegments(m3u8File);\n+        logger.debug(\"Using {} segmented files to make up a poll period.\", numberOfSegments);\n+        m3u8File = keepLast(m3u8File, numberOfSegments);\n+        // logger.debug(\"replacing files to keep now\");\n+        m3u8File = m3u8File.replace(\"ipcamera\", cameraIndex + \"ipcamera\"); // add index so we can then fetch output path\n+        // logger.debug(\"There are {} segments, so we will remove {} from playlist.\", entries, numberOfSegments);\n+        if (entries > numberOfSegments * 3) {\n+            playingNow = removeFromStart(playingNow, entries - (numberOfSegments * 3));\n+        }\n+        playingNow = playingNow + \"#EXT-X-DISCONTINUITY\\n\" + m3u8File;\n+        playList = \"#EXTM3U\\n#EXT-X-VERSION:6\\n#EXT-X-TARGETDURATION:5\\n#EXT-X-ALLOW-CACHE:NO\\n#EXT-X-DISCONTINUITY-SEQUENCE:\"\n+                + discontinuitySequence + \"\\n#EXT-X-MEDIA-SEQUENCE:\" + mediaSequence + \"\\n\" + playingNow;\n+    }\n+\n+    private IpCameraGroupHandler getHandle() {\n+        return this;\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully(8, 8, TimeUnit.SECONDS);\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerGroupHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.info(\"IpCamera file server for a group of cameras has started on port {} for all NIC's.\",\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    logger.error(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number: {}\",\n+                            e.getMessage());\n+                }\n+            }\n+        }\n+    }\n+\n+    // @SuppressWarnings(\"null\")", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA4NTU4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r481085582", "bodyText": "Done.", "author": "Skinah", "createdAt": "2020-09-01T12:03:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4MjkzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4NDM4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477584387", "bodyText": "The run part can be a method in the class. And when using it refer to it as this::pollingCameraGroup", "author": "Hilbrand", "createdAt": "2020-08-26T20:57:05Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraGroupHandler.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.ipcamera.internal.StreamServerGroupHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * The {@link IpCameraGroupHandler} is responsible for finding cameras that are part of this group and displaying a\n+ * group picture.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraGroupHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_GROUPDISPLAY));\n+    private Configuration config;\n+    BigDecimal pollTimeInSeconds = new BigDecimal(2);\n+    public ArrayList<IpCameraHandler> cameraOrder = new ArrayList<IpCameraHandler>(2);\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private final ScheduledExecutorService pollCameraGroup = Executors.newSingleThreadScheduledExecutor();\n+    private @Nullable ScheduledFuture<?> pollCameraGroupJob = null;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public String hostIp = \"0.0.0.0\";\n+    boolean motionChangesOrder = true;\n+    public int serverPort = 0;\n+    public String playList = \"\";\n+    String playingNow = \"\";\n+    public int cameraIndex = 0;\n+    public boolean hlsTurnedOn = false;\n+    int entries = 0;\n+    BigDecimal numberOfFiles = new BigDecimal(1);\n+    int mediaSequence = 1;\n+    int discontinuitySequence = 0;\n+\n+    public IpCameraGroupHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    // @SuppressWarnings(\"null\")\n+    public String getWhiteList() {\n+        return (config.get(CONFIG_IP_WHITELIST) == null) ? \"\" : config.get(CONFIG_IP_WHITELIST).toString();\n+    }\n+\n+    public String getPlayList() {\n+        return playList;\n+    }\n+\n+    public String getOutputFolder(int index) {\n+        IpCameraHandler handle = cameraOrder.get(index);\n+        return (String) handle.config.get(CONFIG_FFMPEG_OUTPUT);\n+    }\n+\n+    private String readCamerasPlaylist(int cameraIndex) {\n+        String camerasm3u8 = \"\";\n+        IpCameraHandler handle = cameraOrder.get(cameraIndex);\n+        try {\n+            String file = handle.config.get(CONFIG_FFMPEG_OUTPUT).toString() + \"ipcamera.m3u8\";\n+            camerasm3u8 = new String(Files.readAllBytes(Paths.get(file)));\n+        } catch (IOException e) {\n+            logger.error(\"Error occured fetching cameras m3u8 file :{}\", e.getMessage());\n+        }\n+        return camerasm3u8;\n+    }\n+\n+    String keepLast(String string, int numberToRetain) {\n+        int start = string.length();\n+        for (int loop = numberToRetain; loop > 0; loop--) {\n+            start = string.lastIndexOf(\"#EXTINF:\", start - 1);\n+            if (start == -1) {\n+                logger.error(\n+                        \"Playlist did not contain enough entries, check all cameras in groups use the same HLS settings.\");\n+                return \"\";\n+            }\n+        }\n+        entries = entries + numberToRetain;\n+        return string.substring(start);\n+    }\n+\n+    String removeFromStart(String string, int numberToRemove) {\n+        int startingFrom = string.indexOf(\"#EXTINF:\");\n+        for (int loop = numberToRemove; loop > 0; loop--) {\n+            startingFrom = string.indexOf(\"#EXTINF:\", startingFrom + 27);\n+            if (startingFrom == -1) {\n+                logger.error(\n+                        \"Playlist failed to remove entries from start, check all cameras in groups use the same HLS settings.\");\n+                return string;\n+            }\n+        }\n+        mediaSequence = mediaSequence + numberToRemove;\n+        entries = entries - numberToRemove;\n+        return string.substring(startingFrom);\n+    }\n+\n+    int howManySegments(String m3u8File) {\n+        int start = m3u8File.length();\n+        int numberOfFiles = 0;\n+        for (BigDecimal totalTime = new BigDecimal(0); totalTime.intValue() < pollTimeInSeconds\n+                .intValue(); numberOfFiles++) {\n+            start = m3u8File.lastIndexOf(\"#EXTINF:\", start - 1);\n+            if (start != -1) {\n+                totalTime = totalTime.add(new BigDecimal(m3u8File.substring(start + 8, m3u8File.indexOf(\",\", start))));\n+            } else {\n+                logger.debug(\"Group did not find enough segments, lower the poll time if this message continues.\");\n+                break;\n+            }\n+        }\n+        return numberOfFiles;\n+    }\n+\n+    public void createPlayList() {\n+        String m3u8File = readCamerasPlaylist(cameraIndex);\n+        if (m3u8File == \"\") {\n+            return;\n+        }\n+        int numberOfSegments = howManySegments(m3u8File);\n+        logger.debug(\"Using {} segmented files to make up a poll period.\", numberOfSegments);\n+        m3u8File = keepLast(m3u8File, numberOfSegments);\n+        // logger.debug(\"replacing files to keep now\");\n+        m3u8File = m3u8File.replace(\"ipcamera\", cameraIndex + \"ipcamera\"); // add index so we can then fetch output path\n+        // logger.debug(\"There are {} segments, so we will remove {} from playlist.\", entries, numberOfSegments);\n+        if (entries > numberOfSegments * 3) {\n+            playingNow = removeFromStart(playingNow, entries - (numberOfSegments * 3));\n+        }\n+        playingNow = playingNow + \"#EXT-X-DISCONTINUITY\\n\" + m3u8File;\n+        playList = \"#EXTM3U\\n#EXT-X-VERSION:6\\n#EXT-X-TARGETDURATION:5\\n#EXT-X-ALLOW-CACHE:NO\\n#EXT-X-DISCONTINUITY-SEQUENCE:\"\n+                + discontinuitySequence + \"\\n#EXT-X-MEDIA-SEQUENCE:\" + mediaSequence + \"\\n\" + playingNow;\n+    }\n+\n+    private IpCameraGroupHandler getHandle() {\n+        return this;\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully(8, 8, TimeUnit.SECONDS);\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerGroupHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.info(\"IpCamera file server for a group of cameras has started on port {} for all NIC's.\",\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    logger.error(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number: {}\",\n+                            e.getMessage());\n+                }\n+            }\n+        }\n+    }\n+\n+    // @SuppressWarnings(\"null\")\n+    void addCamera(String UniqueID) {\n+        if (IpCameraHandler.listOfOnlineCameraUID.contains(UniqueID)) {\n+            for (IpCameraHandler handler : IpCameraHandler.listOfOnlineCameraHandlers) {\n+                if (handler.getThing().getUID().getId().equals(UniqueID)) {\n+                    if (!cameraOrder.contains(handler)) {\n+                        logger.info(\"Adding {} to a camera group.\", UniqueID);\n+                        if (hlsTurnedOn) {\n+                            logger.info(\"Starting HLS for the new camera.\");\n+                            String channelPrefix = \"ipcamera:\" + handler.getThing().getThingTypeUID() + \":\"\n+                                    + handler.getThing().getUID().getId() + \":\";\n+                            handler.handleCommand(new ChannelUID(channelPrefix + CHANNEL_START_STREAM),\n+                                    OnOffType.valueOf(\"ON\"));\n+                        }\n+                        cameraOrder.add(handler);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // Event based. This is called as each camera comes online after the group handler is registered.\n+    public void cameraOnline(String uid) {\n+        logger.debug(\"New camera {} came online, checking if part of this group\", uid);\n+        if (config.get(CONFIG_FIRST_CAM).equals(uid)) {\n+            addCamera(uid);\n+        } else if (config.get(CONFIG_SECOND_CAM).equals(uid)) {\n+            addCamera(uid);\n+        } else if (config.get(CONFIG_THIRD_CAM).equals(uid)) {\n+            addCamera(uid);\n+        } else if (config.get(CONFIG_FORTH_CAM).equals(uid)) {\n+            addCamera(uid);\n+        }\n+    }\n+\n+    // Event based. This is called as each camera comes online after the group handler is registered.\n+    public void cameraOffline(IpCameraHandler handle) {\n+        if (cameraOrder.remove(handle)) {\n+            logger.info(\"Camera {} is now offline, now removed from this group.\", handle.getThing().getUID().getId());\n+        }\n+    }\n+\n+    boolean addIfOnline(String UniqueID) {\n+        if (IpCameraHandler.listOfOnlineCameraUID.contains(UniqueID)) {\n+            addCamera(UniqueID);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    void createCameraOrder() {\n+        addIfOnline(config.get(CONFIG_FIRST_CAM).toString());\n+        addIfOnline(config.get(CONFIG_SECOND_CAM).toString());\n+        if (config.get(CONFIG_THIRD_CAM) != null) {\n+            addIfOnline(config.get(CONFIG_THIRD_CAM).toString());\n+        }\n+        if (config.get(CONFIG_FORTH_CAM) != null) {\n+            addIfOnline(config.get(CONFIG_FORTH_CAM).toString());\n+        }\n+        // Cameras can now send events of when they go on and offline.\n+        IpCameraHandler.listOfGroupHandlers.add(this);\n+    }\n+\n+    int checkForMotion(int nextCamerasIndex) {\n+        int checked = 0;\n+        for (int index = nextCamerasIndex; checked < cameraOrder.size(); checked++) {\n+            if (cameraOrder.get(index).motionDetected) {\n+                // logger.trace(\"Motion detected on a camera in a group, the display order has changed.\");\n+                return index;\n+            }\n+            if (++index >= cameraOrder.size()) {\n+                index = 0;\n+            }\n+        }\n+        return nextCamerasIndex;\n+    }\n+\n+    Runnable pollingCameraGroup = new Runnable() {", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk3NjAxMw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r481976013", "bodyText": "Thanks that's easier to remember the syntax for.", "author": "Skinah", "createdAt": "2020-09-02T10:46:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4NDM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4NTE0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477585144", "bodyText": "Can you make the number a constant and add some explanation about it's value or give it a name that implies the number explanation.", "author": "Hilbrand", "createdAt": "2020-08-26T20:58:30Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraGroupHandler.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.ipcamera.internal.StreamServerGroupHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * The {@link IpCameraGroupHandler} is responsible for finding cameras that are part of this group and displaying a\n+ * group picture.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraGroupHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_GROUPDISPLAY));\n+    private Configuration config;\n+    BigDecimal pollTimeInSeconds = new BigDecimal(2);\n+    public ArrayList<IpCameraHandler> cameraOrder = new ArrayList<IpCameraHandler>(2);\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private final ScheduledExecutorService pollCameraGroup = Executors.newSingleThreadScheduledExecutor();\n+    private @Nullable ScheduledFuture<?> pollCameraGroupJob = null;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public String hostIp = \"0.0.0.0\";\n+    boolean motionChangesOrder = true;\n+    public int serverPort = 0;\n+    public String playList = \"\";\n+    String playingNow = \"\";\n+    public int cameraIndex = 0;\n+    public boolean hlsTurnedOn = false;\n+    int entries = 0;\n+    BigDecimal numberOfFiles = new BigDecimal(1);\n+    int mediaSequence = 1;\n+    int discontinuitySequence = 0;\n+\n+    public IpCameraGroupHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    // @SuppressWarnings(\"null\")\n+    public String getWhiteList() {\n+        return (config.get(CONFIG_IP_WHITELIST) == null) ? \"\" : config.get(CONFIG_IP_WHITELIST).toString();\n+    }\n+\n+    public String getPlayList() {\n+        return playList;\n+    }\n+\n+    public String getOutputFolder(int index) {\n+        IpCameraHandler handle = cameraOrder.get(index);\n+        return (String) handle.config.get(CONFIG_FFMPEG_OUTPUT);\n+    }\n+\n+    private String readCamerasPlaylist(int cameraIndex) {\n+        String camerasm3u8 = \"\";\n+        IpCameraHandler handle = cameraOrder.get(cameraIndex);\n+        try {\n+            String file = handle.config.get(CONFIG_FFMPEG_OUTPUT).toString() + \"ipcamera.m3u8\";\n+            camerasm3u8 = new String(Files.readAllBytes(Paths.get(file)));\n+        } catch (IOException e) {\n+            logger.error(\"Error occured fetching cameras m3u8 file :{}\", e.getMessage());\n+        }\n+        return camerasm3u8;\n+    }\n+\n+    String keepLast(String string, int numberToRetain) {\n+        int start = string.length();\n+        for (int loop = numberToRetain; loop > 0; loop--) {\n+            start = string.lastIndexOf(\"#EXTINF:\", start - 1);\n+            if (start == -1) {\n+                logger.error(\n+                        \"Playlist did not contain enough entries, check all cameras in groups use the same HLS settings.\");\n+                return \"\";\n+            }\n+        }\n+        entries = entries + numberToRetain;\n+        return string.substring(start);\n+    }\n+\n+    String removeFromStart(String string, int numberToRemove) {\n+        int startingFrom = string.indexOf(\"#EXTINF:\");\n+        for (int loop = numberToRemove; loop > 0; loop--) {\n+            startingFrom = string.indexOf(\"#EXTINF:\", startingFrom + 27);\n+            if (startingFrom == -1) {\n+                logger.error(\n+                        \"Playlist failed to remove entries from start, check all cameras in groups use the same HLS settings.\");\n+                return string;\n+            }\n+        }\n+        mediaSequence = mediaSequence + numberToRemove;\n+        entries = entries - numberToRemove;\n+        return string.substring(startingFrom);\n+    }\n+\n+    int howManySegments(String m3u8File) {\n+        int start = m3u8File.length();\n+        int numberOfFiles = 0;\n+        for (BigDecimal totalTime = new BigDecimal(0); totalTime.intValue() < pollTimeInSeconds\n+                .intValue(); numberOfFiles++) {\n+            start = m3u8File.lastIndexOf(\"#EXTINF:\", start - 1);\n+            if (start != -1) {\n+                totalTime = totalTime.add(new BigDecimal(m3u8File.substring(start + 8, m3u8File.indexOf(\",\", start))));\n+            } else {\n+                logger.debug(\"Group did not find enough segments, lower the poll time if this message continues.\");\n+                break;\n+            }\n+        }\n+        return numberOfFiles;\n+    }\n+\n+    public void createPlayList() {\n+        String m3u8File = readCamerasPlaylist(cameraIndex);\n+        if (m3u8File == \"\") {\n+            return;\n+        }\n+        int numberOfSegments = howManySegments(m3u8File);\n+        logger.debug(\"Using {} segmented files to make up a poll period.\", numberOfSegments);\n+        m3u8File = keepLast(m3u8File, numberOfSegments);\n+        // logger.debug(\"replacing files to keep now\");\n+        m3u8File = m3u8File.replace(\"ipcamera\", cameraIndex + \"ipcamera\"); // add index so we can then fetch output path\n+        // logger.debug(\"There are {} segments, so we will remove {} from playlist.\", entries, numberOfSegments);\n+        if (entries > numberOfSegments * 3) {\n+            playingNow = removeFromStart(playingNow, entries - (numberOfSegments * 3));\n+        }\n+        playingNow = playingNow + \"#EXT-X-DISCONTINUITY\\n\" + m3u8File;\n+        playList = \"#EXTM3U\\n#EXT-X-VERSION:6\\n#EXT-X-TARGETDURATION:5\\n#EXT-X-ALLOW-CACHE:NO\\n#EXT-X-DISCONTINUITY-SEQUENCE:\"\n+                + discontinuitySequence + \"\\n#EXT-X-MEDIA-SEQUENCE:\" + mediaSequence + \"\\n\" + playingNow;\n+    }\n+\n+    private IpCameraGroupHandler getHandle() {\n+        return this;\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully(8, 8, TimeUnit.SECONDS);\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerGroupHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.info(\"IpCamera file server for a group of cameras has started on port {} for all NIC's.\",\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    logger.error(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number: {}\",\n+                            e.getMessage());\n+                }\n+            }\n+        }\n+    }\n+\n+    // @SuppressWarnings(\"null\")\n+    void addCamera(String UniqueID) {\n+        if (IpCameraHandler.listOfOnlineCameraUID.contains(UniqueID)) {\n+            for (IpCameraHandler handler : IpCameraHandler.listOfOnlineCameraHandlers) {\n+                if (handler.getThing().getUID().getId().equals(UniqueID)) {\n+                    if (!cameraOrder.contains(handler)) {\n+                        logger.info(\"Adding {} to a camera group.\", UniqueID);\n+                        if (hlsTurnedOn) {\n+                            logger.info(\"Starting HLS for the new camera.\");\n+                            String channelPrefix = \"ipcamera:\" + handler.getThing().getThingTypeUID() + \":\"\n+                                    + handler.getThing().getUID().getId() + \":\";\n+                            handler.handleCommand(new ChannelUID(channelPrefix + CHANNEL_START_STREAM),\n+                                    OnOffType.valueOf(\"ON\"));\n+                        }\n+                        cameraOrder.add(handler);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // Event based. This is called as each camera comes online after the group handler is registered.\n+    public void cameraOnline(String uid) {\n+        logger.debug(\"New camera {} came online, checking if part of this group\", uid);\n+        if (config.get(CONFIG_FIRST_CAM).equals(uid)) {\n+            addCamera(uid);\n+        } else if (config.get(CONFIG_SECOND_CAM).equals(uid)) {\n+            addCamera(uid);\n+        } else if (config.get(CONFIG_THIRD_CAM).equals(uid)) {\n+            addCamera(uid);\n+        } else if (config.get(CONFIG_FORTH_CAM).equals(uid)) {\n+            addCamera(uid);\n+        }\n+    }\n+\n+    // Event based. This is called as each camera comes online after the group handler is registered.\n+    public void cameraOffline(IpCameraHandler handle) {\n+        if (cameraOrder.remove(handle)) {\n+            logger.info(\"Camera {} is now offline, now removed from this group.\", handle.getThing().getUID().getId());\n+        }\n+    }\n+\n+    boolean addIfOnline(String UniqueID) {\n+        if (IpCameraHandler.listOfOnlineCameraUID.contains(UniqueID)) {\n+            addCamera(UniqueID);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    void createCameraOrder() {\n+        addIfOnline(config.get(CONFIG_FIRST_CAM).toString());\n+        addIfOnline(config.get(CONFIG_SECOND_CAM).toString());\n+        if (config.get(CONFIG_THIRD_CAM) != null) {\n+            addIfOnline(config.get(CONFIG_THIRD_CAM).toString());\n+        }\n+        if (config.get(CONFIG_FORTH_CAM) != null) {\n+            addIfOnline(config.get(CONFIG_FORTH_CAM).toString());\n+        }\n+        // Cameras can now send events of when they go on and offline.\n+        IpCameraHandler.listOfGroupHandlers.add(this);\n+    }\n+\n+    int checkForMotion(int nextCamerasIndex) {\n+        int checked = 0;\n+        for (int index = nextCamerasIndex; checked < cameraOrder.size(); checked++) {\n+            if (cameraOrder.get(index).motionDetected) {\n+                // logger.trace(\"Motion detected on a camera in a group, the display order has changed.\");\n+                return index;\n+            }\n+            if (++index >= cameraOrder.size()) {\n+                index = 0;\n+            }\n+        }\n+        return nextCamerasIndex;\n+    }\n+\n+    Runnable pollingCameraGroup = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (cameraOrder.isEmpty()) {\n+                createCameraOrder();\n+            }\n+            if (++cameraIndex >= cameraOrder.size()) {\n+                cameraIndex = 0;\n+            }\n+            if (motionChangesOrder) {\n+                cameraIndex = checkForMotion(cameraIndex);\n+            }\n+            if (hlsTurnedOn) {\n+                discontinuitySequence++;\n+                createPlayList();\n+                if (mediaSequence > 2147000000) {", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg2NjgxMA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r481866810", "bodyText": "Removed it as I just learnt Java gracefully handles overflows. Used to program microprocessors.", "author": "Skinah", "createdAt": "2020-09-02T08:10:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4NTE0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg3NzIwOA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r481877208", "bodyText": "Java handles overflows like microcontrollers. They simply overflow.", "author": "fwolter", "createdAt": "2020-09-02T08:22:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4NTE0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI2OTMwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r484269304", "bodyText": "I'm confused now and need someone that knows Java to tell me what to do... Yes they both overflow but at least in the old days when a variable/register overflowed it would effect the next memory position and cause undesirable effects. So really all I need to know is, do I have to check and prevent the overflow, or is it safe to let an overflow occur in Java?", "author": "Skinah", "createdAt": "2020-09-07T08:20:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4NTE0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI4NTIxMw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r484285213", "bodyText": "Maybe there's a misunderstanding, but an integer overflow doesn't affect the next memory position, at least in architectures like Java, x86, AVR, MSP430, ARM M0+. It overflows to 0 after the max value is reached. So, you don't need to handle overflows to protect any memory. But it might be necessary from the functional perspective as the value drops to 0 suddenly when overflowing, and starts over.", "author": "fwolter", "createdAt": "2020-09-07T08:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4NTE0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0MjkxOA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r484342918", "bodyText": "Thank you, the code will work fine unless someone wants to stream non stop for more than 136 years :)", "author": "Skinah", "createdAt": "2020-09-07T10:27:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4NTE0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4NjE5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477586197", "bodyText": "When using getConfigAs you can simply pass a class with the parameters as fields so you don't have to parse and cast all config parameters your self.", "author": "Hilbrand", "createdAt": "2020-08-26T21:00:28Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraGroupHandler.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.ipcamera.internal.StreamServerGroupHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * The {@link IpCameraGroupHandler} is responsible for finding cameras that are part of this group and displaying a\n+ * group picture.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraGroupHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_GROUPDISPLAY));\n+    private Configuration config;\n+    BigDecimal pollTimeInSeconds = new BigDecimal(2);\n+    public ArrayList<IpCameraHandler> cameraOrder = new ArrayList<IpCameraHandler>(2);\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private final ScheduledExecutorService pollCameraGroup = Executors.newSingleThreadScheduledExecutor();\n+    private @Nullable ScheduledFuture<?> pollCameraGroupJob = null;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public String hostIp = \"0.0.0.0\";\n+    boolean motionChangesOrder = true;\n+    public int serverPort = 0;\n+    public String playList = \"\";\n+    String playingNow = \"\";\n+    public int cameraIndex = 0;\n+    public boolean hlsTurnedOn = false;\n+    int entries = 0;\n+    BigDecimal numberOfFiles = new BigDecimal(1);\n+    int mediaSequence = 1;\n+    int discontinuitySequence = 0;\n+\n+    public IpCameraGroupHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    // @SuppressWarnings(\"null\")\n+    public String getWhiteList() {\n+        return (config.get(CONFIG_IP_WHITELIST) == null) ? \"\" : config.get(CONFIG_IP_WHITELIST).toString();\n+    }\n+\n+    public String getPlayList() {\n+        return playList;\n+    }\n+\n+    public String getOutputFolder(int index) {\n+        IpCameraHandler handle = cameraOrder.get(index);\n+        return (String) handle.config.get(CONFIG_FFMPEG_OUTPUT);\n+    }\n+\n+    private String readCamerasPlaylist(int cameraIndex) {\n+        String camerasm3u8 = \"\";\n+        IpCameraHandler handle = cameraOrder.get(cameraIndex);\n+        try {\n+            String file = handle.config.get(CONFIG_FFMPEG_OUTPUT).toString() + \"ipcamera.m3u8\";\n+            camerasm3u8 = new String(Files.readAllBytes(Paths.get(file)));\n+        } catch (IOException e) {\n+            logger.error(\"Error occured fetching cameras m3u8 file :{}\", e.getMessage());\n+        }\n+        return camerasm3u8;\n+    }\n+\n+    String keepLast(String string, int numberToRetain) {\n+        int start = string.length();\n+        for (int loop = numberToRetain; loop > 0; loop--) {\n+            start = string.lastIndexOf(\"#EXTINF:\", start - 1);\n+            if (start == -1) {\n+                logger.error(\n+                        \"Playlist did not contain enough entries, check all cameras in groups use the same HLS settings.\");\n+                return \"\";\n+            }\n+        }\n+        entries = entries + numberToRetain;\n+        return string.substring(start);\n+    }\n+\n+    String removeFromStart(String string, int numberToRemove) {\n+        int startingFrom = string.indexOf(\"#EXTINF:\");\n+        for (int loop = numberToRemove; loop > 0; loop--) {\n+            startingFrom = string.indexOf(\"#EXTINF:\", startingFrom + 27);\n+            if (startingFrom == -1) {\n+                logger.error(\n+                        \"Playlist failed to remove entries from start, check all cameras in groups use the same HLS settings.\");\n+                return string;\n+            }\n+        }\n+        mediaSequence = mediaSequence + numberToRemove;\n+        entries = entries - numberToRemove;\n+        return string.substring(startingFrom);\n+    }\n+\n+    int howManySegments(String m3u8File) {\n+        int start = m3u8File.length();\n+        int numberOfFiles = 0;\n+        for (BigDecimal totalTime = new BigDecimal(0); totalTime.intValue() < pollTimeInSeconds\n+                .intValue(); numberOfFiles++) {\n+            start = m3u8File.lastIndexOf(\"#EXTINF:\", start - 1);\n+            if (start != -1) {\n+                totalTime = totalTime.add(new BigDecimal(m3u8File.substring(start + 8, m3u8File.indexOf(\",\", start))));\n+            } else {\n+                logger.debug(\"Group did not find enough segments, lower the poll time if this message continues.\");\n+                break;\n+            }\n+        }\n+        return numberOfFiles;\n+    }\n+\n+    public void createPlayList() {\n+        String m3u8File = readCamerasPlaylist(cameraIndex);\n+        if (m3u8File == \"\") {\n+            return;\n+        }\n+        int numberOfSegments = howManySegments(m3u8File);\n+        logger.debug(\"Using {} segmented files to make up a poll period.\", numberOfSegments);\n+        m3u8File = keepLast(m3u8File, numberOfSegments);\n+        // logger.debug(\"replacing files to keep now\");\n+        m3u8File = m3u8File.replace(\"ipcamera\", cameraIndex + \"ipcamera\"); // add index so we can then fetch output path\n+        // logger.debug(\"There are {} segments, so we will remove {} from playlist.\", entries, numberOfSegments);\n+        if (entries > numberOfSegments * 3) {\n+            playingNow = removeFromStart(playingNow, entries - (numberOfSegments * 3));\n+        }\n+        playingNow = playingNow + \"#EXT-X-DISCONTINUITY\\n\" + m3u8File;\n+        playList = \"#EXTM3U\\n#EXT-X-VERSION:6\\n#EXT-X-TARGETDURATION:5\\n#EXT-X-ALLOW-CACHE:NO\\n#EXT-X-DISCONTINUITY-SEQUENCE:\"\n+                + discontinuitySequence + \"\\n#EXT-X-MEDIA-SEQUENCE:\" + mediaSequence + \"\\n\" + playingNow;\n+    }\n+\n+    private IpCameraGroupHandler getHandle() {\n+        return this;\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully(8, 8, TimeUnit.SECONDS);\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerGroupHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.info(\"IpCamera file server for a group of cameras has started on port {} for all NIC's.\",\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    logger.error(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number: {}\",\n+                            e.getMessage());\n+                }\n+            }\n+        }\n+    }\n+\n+    // @SuppressWarnings(\"null\")\n+    void addCamera(String UniqueID) {\n+        if (IpCameraHandler.listOfOnlineCameraUID.contains(UniqueID)) {\n+            for (IpCameraHandler handler : IpCameraHandler.listOfOnlineCameraHandlers) {\n+                if (handler.getThing().getUID().getId().equals(UniqueID)) {\n+                    if (!cameraOrder.contains(handler)) {\n+                        logger.info(\"Adding {} to a camera group.\", UniqueID);\n+                        if (hlsTurnedOn) {\n+                            logger.info(\"Starting HLS for the new camera.\");\n+                            String channelPrefix = \"ipcamera:\" + handler.getThing().getThingTypeUID() + \":\"\n+                                    + handler.getThing().getUID().getId() + \":\";\n+                            handler.handleCommand(new ChannelUID(channelPrefix + CHANNEL_START_STREAM),\n+                                    OnOffType.valueOf(\"ON\"));\n+                        }\n+                        cameraOrder.add(handler);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // Event based. This is called as each camera comes online after the group handler is registered.\n+    public void cameraOnline(String uid) {\n+        logger.debug(\"New camera {} came online, checking if part of this group\", uid);\n+        if (config.get(CONFIG_FIRST_CAM).equals(uid)) {\n+            addCamera(uid);\n+        } else if (config.get(CONFIG_SECOND_CAM).equals(uid)) {\n+            addCamera(uid);\n+        } else if (config.get(CONFIG_THIRD_CAM).equals(uid)) {\n+            addCamera(uid);\n+        } else if (config.get(CONFIG_FORTH_CAM).equals(uid)) {\n+            addCamera(uid);\n+        }\n+    }\n+\n+    // Event based. This is called as each camera comes online after the group handler is registered.\n+    public void cameraOffline(IpCameraHandler handle) {\n+        if (cameraOrder.remove(handle)) {\n+            logger.info(\"Camera {} is now offline, now removed from this group.\", handle.getThing().getUID().getId());\n+        }\n+    }\n+\n+    boolean addIfOnline(String UniqueID) {\n+        if (IpCameraHandler.listOfOnlineCameraUID.contains(UniqueID)) {\n+            addCamera(UniqueID);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    void createCameraOrder() {\n+        addIfOnline(config.get(CONFIG_FIRST_CAM).toString());\n+        addIfOnline(config.get(CONFIG_SECOND_CAM).toString());\n+        if (config.get(CONFIG_THIRD_CAM) != null) {\n+            addIfOnline(config.get(CONFIG_THIRD_CAM).toString());\n+        }\n+        if (config.get(CONFIG_FORTH_CAM) != null) {\n+            addIfOnline(config.get(CONFIG_FORTH_CAM).toString());\n+        }\n+        // Cameras can now send events of when they go on and offline.\n+        IpCameraHandler.listOfGroupHandlers.add(this);\n+    }\n+\n+    int checkForMotion(int nextCamerasIndex) {\n+        int checked = 0;\n+        for (int index = nextCamerasIndex; checked < cameraOrder.size(); checked++) {\n+            if (cameraOrder.get(index).motionDetected) {\n+                // logger.trace(\"Motion detected on a camera in a group, the display order has changed.\");\n+                return index;\n+            }\n+            if (++index >= cameraOrder.size()) {\n+                index = 0;\n+            }\n+        }\n+        return nextCamerasIndex;\n+    }\n+\n+    Runnable pollingCameraGroup = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (cameraOrder.isEmpty()) {\n+                createCameraOrder();\n+            }\n+            if (++cameraIndex >= cameraOrder.size()) {\n+                cameraIndex = 0;\n+            }\n+            if (motionChangesOrder) {\n+                cameraIndex = checkForMotion(cameraIndex);\n+            }\n+            if (hlsTurnedOn) {\n+                discontinuitySequence++;\n+                createPlayList();\n+                if (mediaSequence > 2147000000) {\n+                    mediaSequence = 0;\n+                    discontinuitySequence = 0;\n+                }\n+            }\n+        }\n+    };\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (!\"REFRESH\".equals(command.toString())) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_START_STREAM:\n+                    if (\"ON\".equals(command.toString())) {\n+                        logger.info(\"Starting HLS generation for all cameras in a group.\");\n+                        hlsTurnedOn = true;\n+                        for (IpCameraHandler handler : cameraOrder) {\n+                            String channelPrefix = \"ipcamera:\" + handler.getThing().getThingTypeUID() + \":\"\n+                                    + handler.getThing().getUID().getId() + \":\";\n+\n+                            handler.handleCommand(new ChannelUID(channelPrefix + CHANNEL_START_STREAM),\n+                                    OnOffType.valueOf(\"ON\"));\n+                        }\n+                    } else {\n+                        // do we turn all off or do we remember the state before we turned them all on?\n+                        hlsTurnedOn = false;\n+                    }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = thing.getConfiguration();", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg4NzA4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r484887086", "bodyText": "I Changed it, but now I get \"Initializing handler for thing 'ipcamera:hikvision:DrivewayCam' takes more than 5000ms.\" so it takes a lot longer to fetch the configs.", "author": "Skinah", "createdAt": "2020-09-08T12:46:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4NjE5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMyNTA4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r487325089", "bodyText": "@Hilbrand any ideas why it takes a much longer time to init the handlers after making this change? Is the only solution to use a future listener or other work around?", "author": "Skinah", "createdAt": "2020-09-11T22:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4NjE5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MzU0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r487393547", "bodyText": "SOLVED, working fine now.", "author": "Skinah", "createdAt": "2020-09-12T10:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4NjE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4NzkwNg==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477587906", "bodyText": "These fields should not be static. Same for 2 fields below.", "author": "Hilbrand", "createdAt": "2020-08-26T21:03:47Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAyNjU3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r482026573", "bodyText": "Fixed: SUPPORTED_THING_TYPES.", "author": "Skinah", "createdAt": "2020-09-02T12:24:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4NzkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDczMjMyOA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r484732328", "bodyText": "Fixed ALL.", "author": "Skinah", "createdAt": "2020-09-08T08:11:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4NzkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4ODc4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477588787", "bodyText": "Field can be List and initialization should be diamond operator <>:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n          \n          \n            \n                public List<String> listOfRequests = new ArrayList<>(18);", "author": "Hilbrand", "createdAt": "2020-08-26T21:05:29Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA5NjkxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r481096915", "bodyText": "This change created a large number of errors and wont compile. Will look again at this suggestion but looking at moving this to a class.", "author": "Skinah", "createdAt": "2020-09-01T12:24:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4ODc4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTkxMzA1OA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r481913058", "bodyText": "Fixed, was my mistake late at night.", "author": "Skinah", "createdAt": "2020-09-02T09:01:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4ODc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4OTE5NA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477589194", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else if (!basicAuth.equals(\"\")) {\n          \n          \n            \n                    } else if (!basicAuth.equals(\"\")) {\n          \n      \n    \n    \n  \n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else if (!basicAuth.equals(\"\")) {\n          \n          \n            \n                    } else if (!basicAuth.isEmpty()) {", "author": "Hilbrand", "createdAt": "2020-08-26T21:06:16Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU5MDM1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477590359", "bodyText": "Remove this commented out code.", "author": "Hilbrand", "createdAt": "2020-08-26T21:08:38Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                logger.error(\"A non valid url has been given to the binding, it is: {}\", longUrl);\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (httpMethod.contentEquals(\"PUT\")) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA5NzUxMg==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r481097512", "bodyText": "Done.", "author": "Skinah", "createdAt": "2020-09-01T12:25:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU5MDM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU5MTgwNg==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477591806", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (audioAlarmEnabled == false) {\n          \n          \n            \n                            if (!audioAlarmEnabled) {", "author": "Hilbrand", "createdAt": "2020-08-26T21:11:30Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                logger.error(\"A non valid url has been given to the binding, it is: {}\", longUrl);\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (httpMethod.contentEquals(\"PUT\")) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot() {\n+        lockCurrentSnapshot.lock();\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+        if (preroll > 0) {\n+            fifoSnapshotBuffer.add(currentSnapshot);\n+            if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                fifoSnapshotBuffer.removeFirst();\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    // These methods handle the response from all Camera brands, nothing specific to\n+    // any brand should be in here //\n+\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                // logger.trace(\"{}\", msg.toString());\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                            if (closeConnection) {\n+                                lock.lock();\n+                                try {\n+                                    byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                    if (indexInLists >= 0) {\n+                                        listOfChStatus.set(indexInLists, (byte) 0);\n+                                    } else {\n+                                        logger.debug(\"!!!! Could not find the ch for a Connection: close URL:{}\",\n+                                                requestUrl);\n+                                    }\n+                                } finally {\n+                                    lock.unlock();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                lockCurrentSnapshot.lock();\n+                                currentSnapshot = incomingJpeg;\n+                                lockCurrentSnapshot.unlock();\n+                                processSnapshot();\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    // logger.trace(\"Snapshot recieved: Binding will now close the channel.\");\n+                                    ctx.close();\n+                                } else {\n+                                    lock.lock();\n+                                    try {\n+                                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                        if (indexInLists >= 0) {\n+                                            listOfChStatus.set(indexInLists, (byte) 2);\n+                                        }\n+                                    } finally {\n+                                        lock.unlock();\n+                                        bytesToRecieve = 0;\n+                                        bytesAlreadyRecieved = 0;\n+                                    }\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.equals(\"\")) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // logger.debug(\"Packet back from camera is not matching HttpContent\");\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+            if (ctx == null) {\n+                return;\n+            }\n+            lock.lock();\n+            try {\n+                byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                if (indexInLists >= 0) {\n+                    // logger.debug(\"commonCameraHandler closed channel:{} \\tURL:{}\", indexInLists, requestUrl);\n+                    listOfChStatus.set(indexInLists, (byte) -1);\n+                } else {\n+                    if (listOfChannels.size() > 0) {\n+                        logger.warn(\"Can't find ch when removing handler \\t\\tURL:{}\", requestUrl);\n+                    }\n+                }\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause.toString().contains(\"java.lang.ArrayIndexOutOfBoundsException\")) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                        if (indexInLists >= 0) {\n+                            String urlToKeepOpen;\n+                            switch (thing.getThingTypeUID().getId()) {\n+                                case \"DAHUA\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"HIKVISION\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/ISAPI/Event/notification/alertStream\".contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"DOORBIRD\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/bha-api/monitor.cgi?ring=doorbell,motionsensor\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                            }\n+                            logger.debug(\"! Channel was found idle for more than 15 seconds so closing it down. !\");\n+                            listOfChStatus.set(indexInLists, (byte) 0);\n+                        } else {\n+                            logger.warn(\"!?! Channel that was found idle could not be located in our tracking. !?!\");\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.debug(\"File server for camera at {} has started on port {} for all NIC's.\", ipAddress,\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    logger.error(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number: {}\",\n+                            e.getMessage());\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setupSnapshotStreaming(boolean stream, ChannelHandlerContext ctx, boolean auto) {\n+        if (stream) {\n+            sendMjpegFirstPacket(ctx);\n+            if (auto) {\n+                autoSnapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                // iOS uses a FIFO? and needs two frames to display a pic\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingAutoFps = true;\n+            } else {\n+                snapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingSnapshotMjpeg = true;\n+                startSnapshotPolling();\n+            }\n+        } else {\n+            snapshotMjpegChannelGroup.remove(ctx.channel());\n+            autoSnapshotMjpegChannelGroup.remove(ctx.channel());\n+            if (streamingSnapshotMjpeg && snapshotMjpegChannelGroup.isEmpty()) {\n+                streamingSnapshotMjpeg = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All Snapshot based MJPEG streams have stopped.\");\n+            } else if (streamingAutoFps && autoSnapshotMjpegChannelGroup.isEmpty()) {\n+                streamingAutoFps = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All AutoFps Snapshot based MJPEG streams have stopped.\");\n+            }\n+        }\n+    }\n+\n+    // If start is true the CTX is added to the list to stream video to, false stops\n+    // the stream.\n+    public void setupMjpegStreaming(boolean start, ChannelHandlerContext ctx) {\n+        if (start) {\n+            if (mjpegChannelGroup.isEmpty()) {// first stream being requested.\n+                mjpegChannelGroup.add(ctx.channel());\n+                if (mjpegUri.equals(\"\") || mjpegUri.equals(\"ffmpeg\")) {\n+                    sendMjpegFirstPacket(ctx);\n+                    setupFfmpegFormat(\"MJPEG\");\n+                } else {\n+                    try {\n+                        // fix Dahua reboots when refreshing a mjpeg stream.\n+                        TimeUnit.MILLISECONDS.sleep(500);\n+                    } catch (InterruptedException e) {\n+                    }\n+                    sendHttpGET(mjpegUri);\n+                }\n+            } else if (ffmpegMjpeg != null) {// not first stream and we will use ffmpeg\n+                sendMjpegFirstPacket(ctx);\n+                mjpegChannelGroup.add(ctx.channel());\n+            } else {// not first stream and camera supplies the mjpeg source.\n+                ctx.channel().writeAndFlush(firstStreamedMsg);\n+                mjpegChannelGroup.add(ctx.channel());\n+            }\n+        } else {\n+            mjpegChannelGroup.remove(ctx.channel());\n+            if (mjpegChannelGroup.isEmpty()) {\n+                logger.debug(\"All Mjpeg streams have stopped, cleaning up now\");\n+                if (mjpegUri.equals(\"ffmpeg\")) {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                } else if (!mjpegUri.equals(\"\")) {\n+                    closeChannel(getTinyUrl(mjpegUri));\n+                } else {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // sends direct to ctx so can be either snapshots.mjpeg or normal mjpeg stream\n+    public void sendMjpegFirstPacket(ChannelHandlerContext ctx) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        String contentType = \"multipart/x-mixed-replace; boundary=\" + BOUNDARY;\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+        ctx.channel().writeAndFlush(response);\n+    }\n+\n+    public void sendMjpegFrame(byte[] jpg, ChannelGroup channelGroup) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        ByteBuf imageByteBuf = Unpooled.copiedBuffer(jpg);\n+        int length = imageByteBuf.readableBytes();\n+        String header = \"--\" + BOUNDARY + \"\\r\\n\" + \"content-type: image/jpeg\" + \"\\r\\n\" + \"content-length: \" + length\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuf headerBbuf = Unpooled.copiedBuffer(header, 0, header.length(), StandardCharsets.UTF_8);\n+        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+        streamToGroup(headerBbuf, channelGroup, false);\n+        streamToGroup(imageByteBuf, channelGroup, false);\n+        streamToGroup(footerBbuf, channelGroup, true);\n+    }\n+\n+    public void streamToGroup(Object msg, ChannelGroup channelGroup, boolean flush) {\n+        channelGroup.write(msg);\n+        if (flush) {\n+            channelGroup.flush();\n+        }\n+    }\n+\n+    private void storeSnapshots() {\n+        int count = 0;\n+        // Need to lock as fifoSnapshotBuffer is not thread safe and new snapshots can be incoming.\n+        lockCurrentSnapshot.lock();\n+        logger.debug(\"Storing snapshots now to disk for GIF\");\n+        for (Object incomingJpeg : fifoSnapshotBuffer) {\n+            byte[] foo = (byte[]) incomingJpeg;\n+            File file = new File(ffmpegOutputFolder + \"snapshot\" + count + \".jpg\");\n+            count++;\n+            try {\n+                OutputStream fos = new FileOutputStream(file);\n+                fos.write(foo);\n+                fos.close();\n+            } catch (FileNotFoundException e) {\n+                logger.error(\"FileNotFoundException {}\", e.getMessage());\n+            } catch (IOException e) {\n+                logger.error(\"IOException {}\", e.getMessage());\n+            }\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    public void setupFfmpegFormat(String format) {\n+        String inOptions = \"\";\n+        if (ffmpegOutputFolder.equals(\"\")) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when the output folder is not set.\");\n+            return;\n+        }\n+        if (rtspUri.equals(\"\")) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when no valid input for ffmpeg is provided.\");\n+            return;\n+        }\n+        if (config.get(CONFIG_FFMPEG_LOCATION) == null) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when the location for ffmpeg is not known.\");\n+            return;\n+        }\n+\n+        // Make sure the folder exists, if not create it.\n+        new File(ffmpegOutputFolder).mkdirs();\n+        switch (format) {\n+            case \"HLS\":\n+                if (ffmpegHLS == null) {\n+                    if (rtspUri.contains(\":554\")) {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning -rtsp_transport tcp\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    } else {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    }\n+                }\n+                if (ffmpegHLS != null) {\n+                    ffmpegHLS.startConverting();\n+                }\n+                break;\n+            case \"GIF\":\n+                if (preroll > 0) {\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                            \"-y -r 1 -hide_banner -loglevel warning\", ffmpegOutputFolder + \"snapshot%d.jpg\",\n+                            \"-frames:v \" + (preroll + postroll) + \" \"\n+                                    + config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                } else {\n+                    inOptions = \"-y -t \" + postroll + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-y -t \" + postroll;\n+                    }\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                }\n+                if (preroll > 0) {\n+                    storeSnapshots();\n+                }\n+                if (ffmpegGIF != null) {\n+                    ffmpegGIF.startConverting();\n+                    if (gifHistory.equals(\"\")) {\n+                        gifHistory = gifFilename;\n+                    } else if (!gifFilename.equals(\"ipcamera\")) {\n+                        gifHistory = gifFilename + \",\" + gifHistory;\n+                        if (gifHistoryLength > 49) {\n+                            int endIndex = gifHistory.lastIndexOf(\",\");\n+                            gifHistory = gifHistory.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_GIF_HISTORY, new StringType(gifHistory));\n+                }\n+                break;\n+            case \"RECORD\":\n+                inOptions = \"-y -t \" + mp4RecordTime + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                if (!rtspUri.contains(\"rtsp\")) {\n+                    inOptions = \"-y -t \" + mp4RecordTime;\n+                }\n+                ffmpegRecord = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                        rtspUri, config.get(CONFIG_FFMPEG_MP4_OUT_ARGUMENTS).toString(),\n+                        ffmpegOutputFolder + mp4Filename + \".mp4\", username, password);\n+                if (mp4Preroll > 0) {\n+                    // fetchFromHLS(); todo: not done yet\n+                }\n+                if (ffmpegRecord != null) {\n+                    ffmpegRecord.startConverting();\n+                    if (mp4History.equals(\"\")) {\n+                        mp4History = mp4Filename;\n+                    } else if (!mp4Filename.equals(\"ipcamera\")) {\n+                        mp4History = mp4Filename + \",\" + mp4History;\n+                        if (mp4HistoryLength > 49) {\n+                            int endIndex = mp4History.lastIndexOf(\",\");\n+                            mp4History = mp4History.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_MP4_HISTORY, new StringType(mp4History));\n+                }\n+                break;\n+            case \"RTSPHELPER\":\n+                if (ffmpegRtspHelper != null) {\n+                    ffmpegRtspHelper.stopConverting();\n+                    if (!audioAlarmEnabled && !motionAlarmEnabled) {\n+                        return;\n+                    }\n+                }\n+                String input = (config.get(CONFIG_FFMPEG_MOTION_INPUT) == null) ? rtspUri\n+                        : config.get(CONFIG_FFMPEG_MOTION_INPUT).toString();\n+                String OutputOptions = \"-f null -\";\n+                String filterOptions = \"\";\n+                inOptions = \"-rtsp_transport tcp\";\n+                if (!input.contains(\"rtsp\")) {\n+                    inOptions = \"\";\n+                }\n+                if (audioAlarmEnabled == false) {", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU5MjIwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477592204", "bodyText": "audioAlarmEnable will always be true here:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            } else if (audioAlarmEnabled == true) {\n          \n          \n            \n                            } else {", "author": "Hilbrand", "createdAt": "2020-08-26T21:12:22Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                logger.error(\"A non valid url has been given to the binding, it is: {}\", longUrl);\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (httpMethod.contentEquals(\"PUT\")) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot() {\n+        lockCurrentSnapshot.lock();\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+        if (preroll > 0) {\n+            fifoSnapshotBuffer.add(currentSnapshot);\n+            if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                fifoSnapshotBuffer.removeFirst();\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    // These methods handle the response from all Camera brands, nothing specific to\n+    // any brand should be in here //\n+\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                // logger.trace(\"{}\", msg.toString());\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                            if (closeConnection) {\n+                                lock.lock();\n+                                try {\n+                                    byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                    if (indexInLists >= 0) {\n+                                        listOfChStatus.set(indexInLists, (byte) 0);\n+                                    } else {\n+                                        logger.debug(\"!!!! Could not find the ch for a Connection: close URL:{}\",\n+                                                requestUrl);\n+                                    }\n+                                } finally {\n+                                    lock.unlock();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                lockCurrentSnapshot.lock();\n+                                currentSnapshot = incomingJpeg;\n+                                lockCurrentSnapshot.unlock();\n+                                processSnapshot();\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    // logger.trace(\"Snapshot recieved: Binding will now close the channel.\");\n+                                    ctx.close();\n+                                } else {\n+                                    lock.lock();\n+                                    try {\n+                                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                        if (indexInLists >= 0) {\n+                                            listOfChStatus.set(indexInLists, (byte) 2);\n+                                        }\n+                                    } finally {\n+                                        lock.unlock();\n+                                        bytesToRecieve = 0;\n+                                        bytesAlreadyRecieved = 0;\n+                                    }\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.equals(\"\")) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // logger.debug(\"Packet back from camera is not matching HttpContent\");\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+            if (ctx == null) {\n+                return;\n+            }\n+            lock.lock();\n+            try {\n+                byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                if (indexInLists >= 0) {\n+                    // logger.debug(\"commonCameraHandler closed channel:{} \\tURL:{}\", indexInLists, requestUrl);\n+                    listOfChStatus.set(indexInLists, (byte) -1);\n+                } else {\n+                    if (listOfChannels.size() > 0) {\n+                        logger.warn(\"Can't find ch when removing handler \\t\\tURL:{}\", requestUrl);\n+                    }\n+                }\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause.toString().contains(\"java.lang.ArrayIndexOutOfBoundsException\")) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                        if (indexInLists >= 0) {\n+                            String urlToKeepOpen;\n+                            switch (thing.getThingTypeUID().getId()) {\n+                                case \"DAHUA\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"HIKVISION\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/ISAPI/Event/notification/alertStream\".contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"DOORBIRD\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/bha-api/monitor.cgi?ring=doorbell,motionsensor\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                            }\n+                            logger.debug(\"! Channel was found idle for more than 15 seconds so closing it down. !\");\n+                            listOfChStatus.set(indexInLists, (byte) 0);\n+                        } else {\n+                            logger.warn(\"!?! Channel that was found idle could not be located in our tracking. !?!\");\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.debug(\"File server for camera at {} has started on port {} for all NIC's.\", ipAddress,\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    logger.error(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number: {}\",\n+                            e.getMessage());\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setupSnapshotStreaming(boolean stream, ChannelHandlerContext ctx, boolean auto) {\n+        if (stream) {\n+            sendMjpegFirstPacket(ctx);\n+            if (auto) {\n+                autoSnapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                // iOS uses a FIFO? and needs two frames to display a pic\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingAutoFps = true;\n+            } else {\n+                snapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingSnapshotMjpeg = true;\n+                startSnapshotPolling();\n+            }\n+        } else {\n+            snapshotMjpegChannelGroup.remove(ctx.channel());\n+            autoSnapshotMjpegChannelGroup.remove(ctx.channel());\n+            if (streamingSnapshotMjpeg && snapshotMjpegChannelGroup.isEmpty()) {\n+                streamingSnapshotMjpeg = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All Snapshot based MJPEG streams have stopped.\");\n+            } else if (streamingAutoFps && autoSnapshotMjpegChannelGroup.isEmpty()) {\n+                streamingAutoFps = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All AutoFps Snapshot based MJPEG streams have stopped.\");\n+            }\n+        }\n+    }\n+\n+    // If start is true the CTX is added to the list to stream video to, false stops\n+    // the stream.\n+    public void setupMjpegStreaming(boolean start, ChannelHandlerContext ctx) {\n+        if (start) {\n+            if (mjpegChannelGroup.isEmpty()) {// first stream being requested.\n+                mjpegChannelGroup.add(ctx.channel());\n+                if (mjpegUri.equals(\"\") || mjpegUri.equals(\"ffmpeg\")) {\n+                    sendMjpegFirstPacket(ctx);\n+                    setupFfmpegFormat(\"MJPEG\");\n+                } else {\n+                    try {\n+                        // fix Dahua reboots when refreshing a mjpeg stream.\n+                        TimeUnit.MILLISECONDS.sleep(500);\n+                    } catch (InterruptedException e) {\n+                    }\n+                    sendHttpGET(mjpegUri);\n+                }\n+            } else if (ffmpegMjpeg != null) {// not first stream and we will use ffmpeg\n+                sendMjpegFirstPacket(ctx);\n+                mjpegChannelGroup.add(ctx.channel());\n+            } else {// not first stream and camera supplies the mjpeg source.\n+                ctx.channel().writeAndFlush(firstStreamedMsg);\n+                mjpegChannelGroup.add(ctx.channel());\n+            }\n+        } else {\n+            mjpegChannelGroup.remove(ctx.channel());\n+            if (mjpegChannelGroup.isEmpty()) {\n+                logger.debug(\"All Mjpeg streams have stopped, cleaning up now\");\n+                if (mjpegUri.equals(\"ffmpeg\")) {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                } else if (!mjpegUri.equals(\"\")) {\n+                    closeChannel(getTinyUrl(mjpegUri));\n+                } else {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // sends direct to ctx so can be either snapshots.mjpeg or normal mjpeg stream\n+    public void sendMjpegFirstPacket(ChannelHandlerContext ctx) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        String contentType = \"multipart/x-mixed-replace; boundary=\" + BOUNDARY;\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+        ctx.channel().writeAndFlush(response);\n+    }\n+\n+    public void sendMjpegFrame(byte[] jpg, ChannelGroup channelGroup) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        ByteBuf imageByteBuf = Unpooled.copiedBuffer(jpg);\n+        int length = imageByteBuf.readableBytes();\n+        String header = \"--\" + BOUNDARY + \"\\r\\n\" + \"content-type: image/jpeg\" + \"\\r\\n\" + \"content-length: \" + length\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuf headerBbuf = Unpooled.copiedBuffer(header, 0, header.length(), StandardCharsets.UTF_8);\n+        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+        streamToGroup(headerBbuf, channelGroup, false);\n+        streamToGroup(imageByteBuf, channelGroup, false);\n+        streamToGroup(footerBbuf, channelGroup, true);\n+    }\n+\n+    public void streamToGroup(Object msg, ChannelGroup channelGroup, boolean flush) {\n+        channelGroup.write(msg);\n+        if (flush) {\n+            channelGroup.flush();\n+        }\n+    }\n+\n+    private void storeSnapshots() {\n+        int count = 0;\n+        // Need to lock as fifoSnapshotBuffer is not thread safe and new snapshots can be incoming.\n+        lockCurrentSnapshot.lock();\n+        logger.debug(\"Storing snapshots now to disk for GIF\");\n+        for (Object incomingJpeg : fifoSnapshotBuffer) {\n+            byte[] foo = (byte[]) incomingJpeg;\n+            File file = new File(ffmpegOutputFolder + \"snapshot\" + count + \".jpg\");\n+            count++;\n+            try {\n+                OutputStream fos = new FileOutputStream(file);\n+                fos.write(foo);\n+                fos.close();\n+            } catch (FileNotFoundException e) {\n+                logger.error(\"FileNotFoundException {}\", e.getMessage());\n+            } catch (IOException e) {\n+                logger.error(\"IOException {}\", e.getMessage());\n+            }\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    public void setupFfmpegFormat(String format) {\n+        String inOptions = \"\";\n+        if (ffmpegOutputFolder.equals(\"\")) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when the output folder is not set.\");\n+            return;\n+        }\n+        if (rtspUri.equals(\"\")) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when no valid input for ffmpeg is provided.\");\n+            return;\n+        }\n+        if (config.get(CONFIG_FFMPEG_LOCATION) == null) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when the location for ffmpeg is not known.\");\n+            return;\n+        }\n+\n+        // Make sure the folder exists, if not create it.\n+        new File(ffmpegOutputFolder).mkdirs();\n+        switch (format) {\n+            case \"HLS\":\n+                if (ffmpegHLS == null) {\n+                    if (rtspUri.contains(\":554\")) {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning -rtsp_transport tcp\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    } else {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    }\n+                }\n+                if (ffmpegHLS != null) {\n+                    ffmpegHLS.startConverting();\n+                }\n+                break;\n+            case \"GIF\":\n+                if (preroll > 0) {\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                            \"-y -r 1 -hide_banner -loglevel warning\", ffmpegOutputFolder + \"snapshot%d.jpg\",\n+                            \"-frames:v \" + (preroll + postroll) + \" \"\n+                                    + config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                } else {\n+                    inOptions = \"-y -t \" + postroll + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-y -t \" + postroll;\n+                    }\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                }\n+                if (preroll > 0) {\n+                    storeSnapshots();\n+                }\n+                if (ffmpegGIF != null) {\n+                    ffmpegGIF.startConverting();\n+                    if (gifHistory.equals(\"\")) {\n+                        gifHistory = gifFilename;\n+                    } else if (!gifFilename.equals(\"ipcamera\")) {\n+                        gifHistory = gifFilename + \",\" + gifHistory;\n+                        if (gifHistoryLength > 49) {\n+                            int endIndex = gifHistory.lastIndexOf(\",\");\n+                            gifHistory = gifHistory.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_GIF_HISTORY, new StringType(gifHistory));\n+                }\n+                break;\n+            case \"RECORD\":\n+                inOptions = \"-y -t \" + mp4RecordTime + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                if (!rtspUri.contains(\"rtsp\")) {\n+                    inOptions = \"-y -t \" + mp4RecordTime;\n+                }\n+                ffmpegRecord = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                        rtspUri, config.get(CONFIG_FFMPEG_MP4_OUT_ARGUMENTS).toString(),\n+                        ffmpegOutputFolder + mp4Filename + \".mp4\", username, password);\n+                if (mp4Preroll > 0) {\n+                    // fetchFromHLS(); todo: not done yet\n+                }\n+                if (ffmpegRecord != null) {\n+                    ffmpegRecord.startConverting();\n+                    if (mp4History.equals(\"\")) {\n+                        mp4History = mp4Filename;\n+                    } else if (!mp4Filename.equals(\"ipcamera\")) {\n+                        mp4History = mp4Filename + \",\" + mp4History;\n+                        if (mp4HistoryLength > 49) {\n+                            int endIndex = mp4History.lastIndexOf(\",\");\n+                            mp4History = mp4History.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_MP4_HISTORY, new StringType(mp4History));\n+                }\n+                break;\n+            case \"RTSPHELPER\":\n+                if (ffmpegRtspHelper != null) {\n+                    ffmpegRtspHelper.stopConverting();\n+                    if (!audioAlarmEnabled && !motionAlarmEnabled) {\n+                        return;\n+                    }\n+                }\n+                String input = (config.get(CONFIG_FFMPEG_MOTION_INPUT) == null) ? rtspUri\n+                        : config.get(CONFIG_FFMPEG_MOTION_INPUT).toString();\n+                String OutputOptions = \"-f null -\";\n+                String filterOptions = \"\";\n+                inOptions = \"-rtsp_transport tcp\";\n+                if (!input.contains(\"rtsp\")) {\n+                    inOptions = \"\";\n+                }\n+                if (audioAlarmEnabled == false) {\n+                    filterOptions = \"-an\";\n+                } else if (audioAlarmEnabled == true) {", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU5MjU0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477592548", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (motionAlarmEnabled == false && ffmpegSnapshotGeneration == false) {\n          \n          \n            \n                            if (!motionAlarmEnabled && !ffmpegSnapshotGeneration) {", "author": "Hilbrand", "createdAt": "2020-08-26T21:12:59Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                logger.error(\"A non valid url has been given to the binding, it is: {}\", longUrl);\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (httpMethod.contentEquals(\"PUT\")) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot() {\n+        lockCurrentSnapshot.lock();\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+        if (preroll > 0) {\n+            fifoSnapshotBuffer.add(currentSnapshot);\n+            if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                fifoSnapshotBuffer.removeFirst();\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    // These methods handle the response from all Camera brands, nothing specific to\n+    // any brand should be in here //\n+\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                // logger.trace(\"{}\", msg.toString());\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                            if (closeConnection) {\n+                                lock.lock();\n+                                try {\n+                                    byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                    if (indexInLists >= 0) {\n+                                        listOfChStatus.set(indexInLists, (byte) 0);\n+                                    } else {\n+                                        logger.debug(\"!!!! Could not find the ch for a Connection: close URL:{}\",\n+                                                requestUrl);\n+                                    }\n+                                } finally {\n+                                    lock.unlock();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                lockCurrentSnapshot.lock();\n+                                currentSnapshot = incomingJpeg;\n+                                lockCurrentSnapshot.unlock();\n+                                processSnapshot();\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    // logger.trace(\"Snapshot recieved: Binding will now close the channel.\");\n+                                    ctx.close();\n+                                } else {\n+                                    lock.lock();\n+                                    try {\n+                                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                        if (indexInLists >= 0) {\n+                                            listOfChStatus.set(indexInLists, (byte) 2);\n+                                        }\n+                                    } finally {\n+                                        lock.unlock();\n+                                        bytesToRecieve = 0;\n+                                        bytesAlreadyRecieved = 0;\n+                                    }\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.equals(\"\")) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // logger.debug(\"Packet back from camera is not matching HttpContent\");\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+            if (ctx == null) {\n+                return;\n+            }\n+            lock.lock();\n+            try {\n+                byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                if (indexInLists >= 0) {\n+                    // logger.debug(\"commonCameraHandler closed channel:{} \\tURL:{}\", indexInLists, requestUrl);\n+                    listOfChStatus.set(indexInLists, (byte) -1);\n+                } else {\n+                    if (listOfChannels.size() > 0) {\n+                        logger.warn(\"Can't find ch when removing handler \\t\\tURL:{}\", requestUrl);\n+                    }\n+                }\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause.toString().contains(\"java.lang.ArrayIndexOutOfBoundsException\")) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                        if (indexInLists >= 0) {\n+                            String urlToKeepOpen;\n+                            switch (thing.getThingTypeUID().getId()) {\n+                                case \"DAHUA\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"HIKVISION\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/ISAPI/Event/notification/alertStream\".contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"DOORBIRD\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/bha-api/monitor.cgi?ring=doorbell,motionsensor\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                            }\n+                            logger.debug(\"! Channel was found idle for more than 15 seconds so closing it down. !\");\n+                            listOfChStatus.set(indexInLists, (byte) 0);\n+                        } else {\n+                            logger.warn(\"!?! Channel that was found idle could not be located in our tracking. !?!\");\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.debug(\"File server for camera at {} has started on port {} for all NIC's.\", ipAddress,\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    logger.error(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number: {}\",\n+                            e.getMessage());\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setupSnapshotStreaming(boolean stream, ChannelHandlerContext ctx, boolean auto) {\n+        if (stream) {\n+            sendMjpegFirstPacket(ctx);\n+            if (auto) {\n+                autoSnapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                // iOS uses a FIFO? and needs two frames to display a pic\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingAutoFps = true;\n+            } else {\n+                snapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingSnapshotMjpeg = true;\n+                startSnapshotPolling();\n+            }\n+        } else {\n+            snapshotMjpegChannelGroup.remove(ctx.channel());\n+            autoSnapshotMjpegChannelGroup.remove(ctx.channel());\n+            if (streamingSnapshotMjpeg && snapshotMjpegChannelGroup.isEmpty()) {\n+                streamingSnapshotMjpeg = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All Snapshot based MJPEG streams have stopped.\");\n+            } else if (streamingAutoFps && autoSnapshotMjpegChannelGroup.isEmpty()) {\n+                streamingAutoFps = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All AutoFps Snapshot based MJPEG streams have stopped.\");\n+            }\n+        }\n+    }\n+\n+    // If start is true the CTX is added to the list to stream video to, false stops\n+    // the stream.\n+    public void setupMjpegStreaming(boolean start, ChannelHandlerContext ctx) {\n+        if (start) {\n+            if (mjpegChannelGroup.isEmpty()) {// first stream being requested.\n+                mjpegChannelGroup.add(ctx.channel());\n+                if (mjpegUri.equals(\"\") || mjpegUri.equals(\"ffmpeg\")) {\n+                    sendMjpegFirstPacket(ctx);\n+                    setupFfmpegFormat(\"MJPEG\");\n+                } else {\n+                    try {\n+                        // fix Dahua reboots when refreshing a mjpeg stream.\n+                        TimeUnit.MILLISECONDS.sleep(500);\n+                    } catch (InterruptedException e) {\n+                    }\n+                    sendHttpGET(mjpegUri);\n+                }\n+            } else if (ffmpegMjpeg != null) {// not first stream and we will use ffmpeg\n+                sendMjpegFirstPacket(ctx);\n+                mjpegChannelGroup.add(ctx.channel());\n+            } else {// not first stream and camera supplies the mjpeg source.\n+                ctx.channel().writeAndFlush(firstStreamedMsg);\n+                mjpegChannelGroup.add(ctx.channel());\n+            }\n+        } else {\n+            mjpegChannelGroup.remove(ctx.channel());\n+            if (mjpegChannelGroup.isEmpty()) {\n+                logger.debug(\"All Mjpeg streams have stopped, cleaning up now\");\n+                if (mjpegUri.equals(\"ffmpeg\")) {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                } else if (!mjpegUri.equals(\"\")) {\n+                    closeChannel(getTinyUrl(mjpegUri));\n+                } else {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // sends direct to ctx so can be either snapshots.mjpeg or normal mjpeg stream\n+    public void sendMjpegFirstPacket(ChannelHandlerContext ctx) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        String contentType = \"multipart/x-mixed-replace; boundary=\" + BOUNDARY;\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+        ctx.channel().writeAndFlush(response);\n+    }\n+\n+    public void sendMjpegFrame(byte[] jpg, ChannelGroup channelGroup) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        ByteBuf imageByteBuf = Unpooled.copiedBuffer(jpg);\n+        int length = imageByteBuf.readableBytes();\n+        String header = \"--\" + BOUNDARY + \"\\r\\n\" + \"content-type: image/jpeg\" + \"\\r\\n\" + \"content-length: \" + length\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuf headerBbuf = Unpooled.copiedBuffer(header, 0, header.length(), StandardCharsets.UTF_8);\n+        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+        streamToGroup(headerBbuf, channelGroup, false);\n+        streamToGroup(imageByteBuf, channelGroup, false);\n+        streamToGroup(footerBbuf, channelGroup, true);\n+    }\n+\n+    public void streamToGroup(Object msg, ChannelGroup channelGroup, boolean flush) {\n+        channelGroup.write(msg);\n+        if (flush) {\n+            channelGroup.flush();\n+        }\n+    }\n+\n+    private void storeSnapshots() {\n+        int count = 0;\n+        // Need to lock as fifoSnapshotBuffer is not thread safe and new snapshots can be incoming.\n+        lockCurrentSnapshot.lock();\n+        logger.debug(\"Storing snapshots now to disk for GIF\");\n+        for (Object incomingJpeg : fifoSnapshotBuffer) {\n+            byte[] foo = (byte[]) incomingJpeg;\n+            File file = new File(ffmpegOutputFolder + \"snapshot\" + count + \".jpg\");\n+            count++;\n+            try {\n+                OutputStream fos = new FileOutputStream(file);\n+                fos.write(foo);\n+                fos.close();\n+            } catch (FileNotFoundException e) {\n+                logger.error(\"FileNotFoundException {}\", e.getMessage());\n+            } catch (IOException e) {\n+                logger.error(\"IOException {}\", e.getMessage());\n+            }\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    public void setupFfmpegFormat(String format) {\n+        String inOptions = \"\";\n+        if (ffmpegOutputFolder.equals(\"\")) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when the output folder is not set.\");\n+            return;\n+        }\n+        if (rtspUri.equals(\"\")) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when no valid input for ffmpeg is provided.\");\n+            return;\n+        }\n+        if (config.get(CONFIG_FFMPEG_LOCATION) == null) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when the location for ffmpeg is not known.\");\n+            return;\n+        }\n+\n+        // Make sure the folder exists, if not create it.\n+        new File(ffmpegOutputFolder).mkdirs();\n+        switch (format) {\n+            case \"HLS\":\n+                if (ffmpegHLS == null) {\n+                    if (rtspUri.contains(\":554\")) {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning -rtsp_transport tcp\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    } else {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    }\n+                }\n+                if (ffmpegHLS != null) {\n+                    ffmpegHLS.startConverting();\n+                }\n+                break;\n+            case \"GIF\":\n+                if (preroll > 0) {\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                            \"-y -r 1 -hide_banner -loglevel warning\", ffmpegOutputFolder + \"snapshot%d.jpg\",\n+                            \"-frames:v \" + (preroll + postroll) + \" \"\n+                                    + config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                } else {\n+                    inOptions = \"-y -t \" + postroll + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-y -t \" + postroll;\n+                    }\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                }\n+                if (preroll > 0) {\n+                    storeSnapshots();\n+                }\n+                if (ffmpegGIF != null) {\n+                    ffmpegGIF.startConverting();\n+                    if (gifHistory.equals(\"\")) {\n+                        gifHistory = gifFilename;\n+                    } else if (!gifFilename.equals(\"ipcamera\")) {\n+                        gifHistory = gifFilename + \",\" + gifHistory;\n+                        if (gifHistoryLength > 49) {\n+                            int endIndex = gifHistory.lastIndexOf(\",\");\n+                            gifHistory = gifHistory.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_GIF_HISTORY, new StringType(gifHistory));\n+                }\n+                break;\n+            case \"RECORD\":\n+                inOptions = \"-y -t \" + mp4RecordTime + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                if (!rtspUri.contains(\"rtsp\")) {\n+                    inOptions = \"-y -t \" + mp4RecordTime;\n+                }\n+                ffmpegRecord = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                        rtspUri, config.get(CONFIG_FFMPEG_MP4_OUT_ARGUMENTS).toString(),\n+                        ffmpegOutputFolder + mp4Filename + \".mp4\", username, password);\n+                if (mp4Preroll > 0) {\n+                    // fetchFromHLS(); todo: not done yet\n+                }\n+                if (ffmpegRecord != null) {\n+                    ffmpegRecord.startConverting();\n+                    if (mp4History.equals(\"\")) {\n+                        mp4History = mp4Filename;\n+                    } else if (!mp4Filename.equals(\"ipcamera\")) {\n+                        mp4History = mp4Filename + \",\" + mp4History;\n+                        if (mp4HistoryLength > 49) {\n+                            int endIndex = mp4History.lastIndexOf(\",\");\n+                            mp4History = mp4History.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_MP4_HISTORY, new StringType(mp4History));\n+                }\n+                break;\n+            case \"RTSPHELPER\":\n+                if (ffmpegRtspHelper != null) {\n+                    ffmpegRtspHelper.stopConverting();\n+                    if (!audioAlarmEnabled && !motionAlarmEnabled) {\n+                        return;\n+                    }\n+                }\n+                String input = (config.get(CONFIG_FFMPEG_MOTION_INPUT) == null) ? rtspUri\n+                        : config.get(CONFIG_FFMPEG_MOTION_INPUT).toString();\n+                String OutputOptions = \"-f null -\";\n+                String filterOptions = \"\";\n+                inOptions = \"-rtsp_transport tcp\";\n+                if (!input.contains(\"rtsp\")) {\n+                    inOptions = \"\";\n+                }\n+                if (audioAlarmEnabled == false) {\n+                    filterOptions = \"-an\";\n+                } else if (audioAlarmEnabled == true) {\n+                    filterOptions = \"-af silencedetect=n=-\" + audioThreshold + \"dB:d=2\";\n+                }\n+                if (motionAlarmEnabled == false && ffmpegSnapshotGeneration == false) {", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU5NDE0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477594147", "bodyText": "inner classes should be either at the beginning or end in the class.", "author": "Hilbrand", "createdAt": "2020-08-26T21:16:11Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                logger.error(\"A non valid url has been given to the binding, it is: {}\", longUrl);\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (httpMethod.contentEquals(\"PUT\")) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot() {\n+        lockCurrentSnapshot.lock();\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+        if (preroll > 0) {\n+            fifoSnapshotBuffer.add(currentSnapshot);\n+            if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                fifoSnapshotBuffer.removeFirst();\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    // These methods handle the response from all Camera brands, nothing specific to\n+    // any brand should be in here //\n+\n+    private class CommonCameraHandler extends ChannelDuplexHandler {", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg3MDM5OA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r481870398", "bodyText": "Move to start.", "author": "Skinah", "createdAt": "2020-09-02T08:14:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU5NDE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU5NTM5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477595391", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (listOfChannels.size() > 0) {\n          \n          \n            \n                                if (!listOfChannels.isEmpty()) {", "author": "Hilbrand", "createdAt": "2020-08-26T21:18:46Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                logger.error(\"A non valid url has been given to the binding, it is: {}\", longUrl);\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (httpMethod.contentEquals(\"PUT\")) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot() {\n+        lockCurrentSnapshot.lock();\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+        if (preroll > 0) {\n+            fifoSnapshotBuffer.add(currentSnapshot);\n+            if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                fifoSnapshotBuffer.removeFirst();\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    // These methods handle the response from all Camera brands, nothing specific to\n+    // any brand should be in here //\n+\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                // logger.trace(\"{}\", msg.toString());\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                            if (closeConnection) {\n+                                lock.lock();\n+                                try {\n+                                    byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                    if (indexInLists >= 0) {\n+                                        listOfChStatus.set(indexInLists, (byte) 0);\n+                                    } else {\n+                                        logger.debug(\"!!!! Could not find the ch for a Connection: close URL:{}\",\n+                                                requestUrl);\n+                                    }\n+                                } finally {\n+                                    lock.unlock();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                lockCurrentSnapshot.lock();\n+                                currentSnapshot = incomingJpeg;\n+                                lockCurrentSnapshot.unlock();\n+                                processSnapshot();\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    // logger.trace(\"Snapshot recieved: Binding will now close the channel.\");\n+                                    ctx.close();\n+                                } else {\n+                                    lock.lock();\n+                                    try {\n+                                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                        if (indexInLists >= 0) {\n+                                            listOfChStatus.set(indexInLists, (byte) 2);\n+                                        }\n+                                    } finally {\n+                                        lock.unlock();\n+                                        bytesToRecieve = 0;\n+                                        bytesAlreadyRecieved = 0;\n+                                    }\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.equals(\"\")) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // logger.debug(\"Packet back from camera is not matching HttpContent\");\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+            if (ctx == null) {\n+                return;\n+            }\n+            lock.lock();\n+            try {\n+                byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                if (indexInLists >= 0) {\n+                    // logger.debug(\"commonCameraHandler closed channel:{} \\tURL:{}\", indexInLists, requestUrl);\n+                    listOfChStatus.set(indexInLists, (byte) -1);\n+                } else {\n+                    if (listOfChannels.size() > 0) {", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU5NjA5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477596095", "bodyText": "Any reason not using an int? Using byte is very uncommon.", "author": "Hilbrand", "createdAt": "2020-08-26T21:20:12Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                logger.error(\"A non valid url has been given to the binding, it is: {}\", longUrl);\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (httpMethod.contentEquals(\"PUT\")) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot() {\n+        lockCurrentSnapshot.lock();\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+        if (preroll > 0) {\n+            fifoSnapshotBuffer.add(currentSnapshot);\n+            if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                fifoSnapshotBuffer.removeFirst();\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    // These methods handle the response from all Camera brands, nothing specific to\n+    // any brand should be in here //\n+\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                // logger.trace(\"{}\", msg.toString());\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                            if (closeConnection) {\n+                                lock.lock();\n+                                try {\n+                                    byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                    if (indexInLists >= 0) {\n+                                        listOfChStatus.set(indexInLists, (byte) 0);\n+                                    } else {\n+                                        logger.debug(\"!!!! Could not find the ch for a Connection: close URL:{}\",\n+                                                requestUrl);\n+                                    }\n+                                } finally {\n+                                    lock.unlock();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                lockCurrentSnapshot.lock();\n+                                currentSnapshot = incomingJpeg;\n+                                lockCurrentSnapshot.unlock();\n+                                processSnapshot();\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    // logger.trace(\"Snapshot recieved: Binding will now close the channel.\");\n+                                    ctx.close();\n+                                } else {\n+                                    lock.lock();\n+                                    try {\n+                                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                        if (indexInLists >= 0) {\n+                                            listOfChStatus.set(indexInLists, (byte) 2);\n+                                        }\n+                                    } finally {\n+                                        lock.unlock();\n+                                        bytesToRecieve = 0;\n+                                        bytesAlreadyRecieved = 0;\n+                                    }\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.equals(\"\")) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // logger.debug(\"Packet back from camera is not matching HttpContent\");\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+            if (ctx == null) {\n+                return;\n+            }\n+            lock.lock();\n+            try {\n+                byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk1ODU4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r481958581", "bodyText": "Done, changed to int.", "author": "Skinah", "createdAt": "2020-09-02T10:14:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU5NjA5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU5NjQ1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477596454", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (cause.toString().contains(\"java.lang.ArrayIndexOutOfBoundsException\")) {\n          \n          \n            \n                        if (cause instanceof ArrayIndexOutOfBoundsException) {", "author": "Hilbrand", "createdAt": "2020-08-26T21:20:57Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                logger.error(\"A non valid url has been given to the binding, it is: {}\", longUrl);\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (httpMethod.contentEquals(\"PUT\")) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot() {\n+        lockCurrentSnapshot.lock();\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+        if (preroll > 0) {\n+            fifoSnapshotBuffer.add(currentSnapshot);\n+            if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                fifoSnapshotBuffer.removeFirst();\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    // These methods handle the response from all Camera brands, nothing specific to\n+    // any brand should be in here //\n+\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                // logger.trace(\"{}\", msg.toString());\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                            if (closeConnection) {\n+                                lock.lock();\n+                                try {\n+                                    byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                    if (indexInLists >= 0) {\n+                                        listOfChStatus.set(indexInLists, (byte) 0);\n+                                    } else {\n+                                        logger.debug(\"!!!! Could not find the ch for a Connection: close URL:{}\",\n+                                                requestUrl);\n+                                    }\n+                                } finally {\n+                                    lock.unlock();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                lockCurrentSnapshot.lock();\n+                                currentSnapshot = incomingJpeg;\n+                                lockCurrentSnapshot.unlock();\n+                                processSnapshot();\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    // logger.trace(\"Snapshot recieved: Binding will now close the channel.\");\n+                                    ctx.close();\n+                                } else {\n+                                    lock.lock();\n+                                    try {\n+                                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                        if (indexInLists >= 0) {\n+                                            listOfChStatus.set(indexInLists, (byte) 2);\n+                                        }\n+                                    } finally {\n+                                        lock.unlock();\n+                                        bytesToRecieve = 0;\n+                                        bytesAlreadyRecieved = 0;\n+                                    }\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.equals(\"\")) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // logger.debug(\"Packet back from camera is not matching HttpContent\");\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+            if (ctx == null) {\n+                return;\n+            }\n+            lock.lock();\n+            try {\n+                byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                if (indexInLists >= 0) {\n+                    // logger.debug(\"commonCameraHandler closed channel:{} \\tURL:{}\", indexInLists, requestUrl);\n+                    listOfChStatus.set(indexInLists, (byte) -1);\n+                } else {\n+                    if (listOfChannels.size() > 0) {\n+                        logger.warn(\"Can't find ch when removing handler \\t\\tURL:{}\", requestUrl);\n+                    }\n+                }\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause.toString().contains(\"java.lang.ArrayIndexOutOfBoundsException\")) {", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU5Nzg2OA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477597868", "bodyText": "Is this a bug when happening? otherwise it should not log to error an probably update thet thing status with this message.", "author": "Hilbrand", "createdAt": "2020-08-26T21:24:03Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                logger.error(\"A non valid url has been given to the binding, it is: {}\", longUrl);", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTcyNzcwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479727707", "bodyText": "Fixed by removing error and changing thing status instead. In this case it would happen if someone entered a typo in the URL. Instead of 'http://hostname/snap.jpg' they entered 'HTPP://hostname/snap.jpg'.", "author": "Skinah", "createdAt": "2020-08-30T06:17:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU5Nzg2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTcyNzc3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479727771", "bodyText": "b1c023a", "author": "Skinah", "createdAt": "2020-08-30T06:18:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU5Nzg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU5OTE5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477599190", "bodyText": "Using equals should be enough:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (httpMethod.contentEquals(\"PUT\")) {\n          \n          \n            \n                    if (\"PUT\".equals(httpMethod)) {", "author": "Hilbrand", "createdAt": "2020-08-26T21:26:44Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                logger.error(\"A non valid url has been given to the binding, it is: {}\", longUrl);\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (httpMethod.contentEquals(\"PUT\")) {", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU5OTgyOA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r477599828", "bodyText": "Can't you use 1 threadpool with 4 threads?", "author": "Hilbrand", "createdAt": "2020-08-26T21:28:01Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);", "originalCommit": "b3e320c3cf6ba55090889bd0443c00545c4a0752", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA2NjQ3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r481066479", "bodyText": "Done.", "author": "Skinah", "createdAt": "2020-09-01T11:26:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU5OTgyOA=="}], "type": "inlineReview"}, {"oid": "95a6cab5e42765729332dac5dac40c360332a88d", "url": "https://github.com/openhab/openhab-addons/commit/95a6cab5e42765729332dac5dac40c360332a88d", "message": "[dsmr] Set Thread name and daemon state (#8325)\n\nSigned-off-by: Hilbrand Bouwkamp <hilbrand@h72.nl>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T00:42:46Z", "type": "commit"}, {"oid": "e2a0fb0d78826d5ae7d639347baf32438eb05e5b", "url": "https://github.com/openhab/openhab-addons/commit/e2a0fb0d78826d5ae7d639347baf32438eb05e5b", "message": "fix 1\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T00:42:46Z", "type": "commit"}, {"oid": "30c5c44aa5c802baa8847cecf59c8d3f4ce32908", "url": "https://github.com/openhab/openhab-addons/commit/30c5c44aa5c802baa8847cecf59c8d3f4ce32908", "message": "IPcamera binding\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T01:08:22Z", "type": "commit"}, {"oid": "4ebe5738c0f9a10942b18b6074f95db4a28ba017", "url": "https://github.com/openhab/openhab-addons/commit/4ebe5738c0f9a10942b18b6074f95db4a28ba017", "message": "Update bundles/org.openhab.binding.ipcamera/README.md\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T01:08:22Z", "type": "commit"}, {"oid": "ed7c464a95a30d5c67669ef9b922ec58b83c948b", "url": "https://github.com/openhab/openhab-addons/commit/ed7c464a95a30d5c67669ef9b922ec58b83c948b", "message": "Update bundles/org.openhab.binding.ipcamera/NOTICE\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T01:08:22Z", "type": "commit"}, {"oid": "927a6dbd94fb65b58608ce2c979c1ce8abb14cfd", "url": "https://github.com/openhab/openhab-addons/commit/927a6dbd94fb65b58608ce2c979c1ce8abb14cfd", "message": "Update bundles/org.openhab.binding.ipcamera/README.md\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T01:08:22Z", "type": "commit"}, {"oid": "d762c960e3dcbbc5768c8f13bb84d802aca5805c", "url": "https://github.com/openhab/openhab-addons/commit/d762c960e3dcbbc5768c8f13bb84d802aca5805c", "message": "Update bundles/org.openhab.binding.ipcamera/README.md\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T01:08:22Z", "type": "commit"}, {"oid": "37fc9d4033a66256928d66626a77b0bbf6efe19f", "url": "https://github.com/openhab/openhab-addons/commit/37fc9d4033a66256928d66626a77b0bbf6efe19f", "message": "Update bundles/org.openhab.binding.ipcamera/README.md\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T01:08:22Z", "type": "commit"}, {"oid": "26c08c2bb73232e6cd3d9fc64575ddf9619ee97d", "url": "https://github.com/openhab/openhab-addons/commit/26c08c2bb73232e6cd3d9fc64575ddf9619ee97d", "message": "Update bundles/org.openhab.binding.ipcamera/README.md\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T01:08:22Z", "type": "commit"}, {"oid": "a99255f1c44521af236ba7f7528db0eb7582e3ac", "url": "https://github.com/openhab/openhab-addons/commit/a99255f1c44521af236ba7f7528db0eb7582e3ac", "message": "Fix capitalization in readme.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T01:08:22Z", "type": "commit"}, {"oid": "effc547366ce52e1d306223e8ff503cd293fb12d", "url": "https://github.com/openhab/openhab-addons/commit/effc547366ce52e1d306223e8ff503cd293fb12d", "message": "Remove license as advised it is not needed.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T01:08:22Z", "type": "commit"}, {"oid": "ded8493ab8775dfce8adf504b0516fdab3a7faa3", "url": "https://github.com/openhab/openhab-addons/commit/ded8493ab8775dfce8adf504b0516fdab3a7faa3", "message": "Remove PaperUI references.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T01:08:22Z", "type": "commit"}, {"oid": "42b0e994a5c864307f6788289672a23d18934b26", "url": "https://github.com/openhab/openhab-addons/commit/42b0e994a5c864307f6788289672a23d18934b26", "message": "Update bundles/org.openhab.binding.ipcamera/README.md\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T01:08:22Z", "type": "commit"}, {"oid": "4b8a51a5aca7448eca9c125358301d58d8a1557b", "url": "https://github.com/openhab/openhab-addons/commit/4b8a51a5aca7448eca9c125358301d58d8a1557b", "message": "Update bundles/org.openhab.binding.ipcamera/README.md\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T01:08:22Z", "type": "commit"}, {"oid": "66de1c4f4c24411fbf15d1b5d68d1777ee40c7d4", "url": "https://github.com/openhab/openhab-addons/commit/66de1c4f4c24411fbf15d1b5d68d1777ee40c7d4", "message": "Change all OpenHAB to openHAB\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T01:08:22Z", "type": "commit"}, {"oid": "72042ad6c0879cc58789e97d8ed64aa30944d223", "url": "https://github.com/openhab/openhab-addons/commit/72042ad6c0879cc58789e97d8ed64aa30944d223", "message": "Update bundles/org.openhab.binding.ipcamera/README.md\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-08-30T01:14:26Z", "type": "commit"}, {"oid": "2c0be796c91fff806206c1b2d5ca663401fb7b48", "url": "https://github.com/openhab/openhab-addons/commit/2c0be796c91fff806206c1b2d5ca663401fb7b48", "message": "Delete only the file ipcamera_xx_XX.properties\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T02:58:29Z", "type": "commit"}, {"oid": "657d0d1e42cb29a621ff43c212ae2cb844f84491", "url": "https://github.com/openhab/openhab-addons/commit/657d0d1e42cb29a621ff43c212ae2cb844f84491", "message": "Remove Netty from Notice file as requested in review.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T03:09:50Z", "type": "commit"}, {"oid": "88085b53cff5b59d803446f9f395659a6bc51754", "url": "https://github.com/openhab/openhab-addons/commit/88085b53cff5b59d803446f9f395659a6bc51754", "message": "Spotless check fixes.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T04:03:20Z", "type": "commit"}, {"oid": "d4ceae3a42373ffd9bfcaa2da7c6e7f5379109a4", "url": "https://github.com/openhab/openhab-addons/commit/d4ceae3a42373ffd9bfcaa2da7c6e7f5379109a4", "message": "Removed empty tags from xml.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T04:09:18Z", "type": "commit"}, {"oid": "a3a53df9d777c6951bf30f9d083cbf5bb6b05dd3", "url": "https://github.com/openhab/openhab-addons/commit/a3a53df9d777c6951bf30f9d083cbf5bb6b05dd3", "message": "Change errors to make thingStatus Offline when it makes sense.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T04:48:10Z", "type": "commit"}, {"oid": "d260652a2842d706aa626760f4db9be26a2909aa", "url": "https://github.com/openhab/openhab-addons/commit/d260652a2842d706aa626760f4db9be26a2909aa", "message": "IPcamera binding\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T05:01:15Z", "type": "commit"}, {"oid": "c943ee8bfdb91ec48d2457d2489b88757b9748c5", "url": "https://github.com/openhab/openhab-addons/commit/c943ee8bfdb91ec48d2457d2489b88757b9748c5", "message": "Update bundles/org.openhab.binding.ipcamera/README.md\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T05:01:16Z", "type": "commit"}, {"oid": "1b983c66d3faf66fb653a3a251c161e87d80d790", "url": "https://github.com/openhab/openhab-addons/commit/1b983c66d3faf66fb653a3a251c161e87d80d790", "message": "Update bundles/org.openhab.binding.ipcamera/NOTICE\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T05:01:17Z", "type": "commit"}, {"oid": "69f0fd43a2961434cc10cb510220720054911c84", "url": "https://github.com/openhab/openhab-addons/commit/69f0fd43a2961434cc10cb510220720054911c84", "message": "Update bundles/org.openhab.binding.ipcamera/README.md\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T05:01:18Z", "type": "commit"}, {"oid": "da1f1b21e89bff7df6023a4cf831506244a17ec3", "url": "https://github.com/openhab/openhab-addons/commit/da1f1b21e89bff7df6023a4cf831506244a17ec3", "message": "Update bundles/org.openhab.binding.ipcamera/README.md\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T05:01:19Z", "type": "commit"}, {"oid": "d5e5366e8fa381c42ec04845e84fc6db1d983c98", "url": "https://github.com/openhab/openhab-addons/commit/d5e5366e8fa381c42ec04845e84fc6db1d983c98", "message": "Update bundles/org.openhab.binding.ipcamera/README.md\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T05:01:21Z", "type": "commit"}, {"oid": "baf0310a89f9ff4333d9eb9e669ac9a27955aaf8", "url": "https://github.com/openhab/openhab-addons/commit/baf0310a89f9ff4333d9eb9e669ac9a27955aaf8", "message": "Update bundles/org.openhab.binding.ipcamera/README.md\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T05:01:22Z", "type": "commit"}, {"oid": "c88f99d4d827def99aba164ab091b2271723c5a1", "url": "https://github.com/openhab/openhab-addons/commit/c88f99d4d827def99aba164ab091b2271723c5a1", "message": "Fix capitalization in readme.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T05:01:23Z", "type": "commit"}, {"oid": "f3637471f099a2478a5122c01b3173b2796d76bc", "url": "https://github.com/openhab/openhab-addons/commit/f3637471f099a2478a5122c01b3173b2796d76bc", "message": "Remove license as advised it is not needed.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T05:01:24Z", "type": "commit"}, {"oid": "ce303657293c41f53182ec64a22c4ba38846938f", "url": "https://github.com/openhab/openhab-addons/commit/ce303657293c41f53182ec64a22c4ba38846938f", "message": "Remove PaperUI references.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T05:01:26Z", "type": "commit"}, {"oid": "1ad11293e56ef3f09fe3a93f78f420891f3c7c28", "url": "https://github.com/openhab/openhab-addons/commit/1ad11293e56ef3f09fe3a93f78f420891f3c7c28", "message": "Update bundles/org.openhab.binding.ipcamera/README.md\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T05:01:27Z", "type": "commit"}, {"oid": "1796cd8a2eea63dc179389192cb01920a8d97592", "url": "https://github.com/openhab/openhab-addons/commit/1796cd8a2eea63dc179389192cb01920a8d97592", "message": "Update bundles/org.openhab.binding.ipcamera/README.md\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T05:01:28Z", "type": "commit"}, {"oid": "3e17cbbec593ef9a3bd46959074969728201cdbb", "url": "https://github.com/openhab/openhab-addons/commit/3e17cbbec593ef9a3bd46959074969728201cdbb", "message": "Change all OpenHAB to openHAB\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T05:01:29Z", "type": "commit"}, {"oid": "534b24af3596c7a0a3da96735efab23f89388da0", "url": "https://github.com/openhab/openhab-addons/commit/534b24af3596c7a0a3da96735efab23f89388da0", "message": "Update bundles/org.openhab.binding.ipcamera/README.md\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-08-30T05:01:30Z", "type": "commit"}, {"oid": "65bb1981fa8cfe0845a533047f85c05a3caff046", "url": "https://github.com/openhab/openhab-addons/commit/65bb1981fa8cfe0845a533047f85c05a3caff046", "message": "Delete only the file ipcamera_xx_XX.properties\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T05:01:32Z", "type": "commit"}, {"oid": "76d542176b6bd4583678b1f8db99b6d9f5915a69", "url": "https://github.com/openhab/openhab-addons/commit/76d542176b6bd4583678b1f8db99b6d9f5915a69", "message": "Remove Netty from Notice file as requested in review.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T05:01:33Z", "type": "commit"}, {"oid": "b841bac10d4c0029fc9247489138f1439031abf3", "url": "https://github.com/openhab/openhab-addons/commit/b841bac10d4c0029fc9247489138f1439031abf3", "message": "Spotless check fixes.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T05:01:34Z", "type": "commit"}, {"oid": "7c46e45d0dc073e779ec5597762f942b240308fd", "url": "https://github.com/openhab/openhab-addons/commit/7c46e45d0dc073e779ec5597762f942b240308fd", "message": "Removed empty tags from xml.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T05:01:35Z", "type": "commit"}, {"oid": "b1c023a60b67f2cf87243994b89e83a6256cf260", "url": "https://github.com/openhab/openhab-addons/commit/b1c023a60b67f2cf87243994b89e83a6256cf260", "message": "Change errors to make thingStatus Offline when it makes sense.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T05:01:36Z", "type": "commit"}, {"oid": "4af7123f147af38d1ddefb996f8c68720f78c19e", "url": "https://github.com/openhab/openhab-addons/commit/4af7123f147af38d1ddefb996f8c68720f78c19e", "message": "Merge branch 'ipcamera' of https://github.com/Skinah/openhab-addons.git into ipcamera", "committedDate": "2020-08-30T05:16:41Z", "type": "commit"}, {"oid": "6fac17616bf095bd02189e4d14e253f103b8bee5", "url": "https://github.com/openhab/openhab-addons/commit/6fac17616bf095bd02189e4d14e253f103b8bee5", "message": "Merge pull request #2 from openhab/2.5.x\n\nUpdate branch to use 2.5.9 snapshot.", "committedDate": "2020-08-30T05:22:37Z", "type": "commit"}, {"oid": "6699d9cebd33e67fbfa96653b50e5f9bcfc2886b", "url": "https://github.com/openhab/openhab-addons/commit/6699d9cebd33e67fbfa96653b50e5f9bcfc2886b", "message": "Merge branch 'ipcamera' of https://github.com/Skinah/openhab-addons.git into ipcamera", "committedDate": "2020-08-30T05:20:56Z", "type": "commit"}, {"oid": "4835ddc3f4428d9729fa5384324da08fa8afcfbf", "url": "https://github.com/openhab/openhab-addons/commit/4835ddc3f4428d9729fa5384324da08fa8afcfbf", "message": "Update pom and feature files correctly for Netty libs\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T05:49:19Z", "type": "commit"}, {"oid": "1c8bfe1b523d94df54a2edc70b5c6e50dec237d3", "url": "https://github.com/openhab/openhab-addons/commit/1c8bfe1b523d94df54a2edc70b5c6e50dec237d3", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>", "committedDate": "2020-08-30T06:11:24Z", "type": "commit"}, {"oid": "a150c6c5b90d90ff3cb8e6c134502545c55af2bb", "url": "https://github.com/openhab/openhab-addons/commit/a150c6c5b90d90ff3cb8e6c134502545c55af2bb", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>", "committedDate": "2020-08-30T06:12:30Z", "type": "commit"}, {"oid": "02afa3be70ab46717edf043b6e2a6e67e84e16d7", "url": "https://github.com/openhab/openhab-addons/commit/02afa3be70ab46717edf043b6e2a6e67e84e16d7", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraGroupHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>", "committedDate": "2020-08-30T06:22:19Z", "type": "commit"}, {"oid": "e68875bbabdc1dd005db797dbce135f7d5e7370a", "url": "https://github.com/openhab/openhab-addons/commit/e68875bbabdc1dd005db797dbce135f7d5e7370a", "message": "Use (command instanceof RefreshType) across all src files.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T06:36:04Z", "type": "commit"}, {"oid": "d3d1065c420b7a9de035fa5d29d2c43f4e817114", "url": "https://github.com/openhab/openhab-addons/commit/d3d1065c420b7a9de035fa5d29d2c43f4e817114", "message": "Readme Improvements.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T09:17:18Z", "type": "commit"}, {"oid": "f3160c8d3b77badd1548b6e5c455669f5fa67225", "url": "https://github.com/openhab/openhab-addons/commit/f3160c8d3b77badd1548b6e5c455669f5fa67225", "message": "Update bundles/org.openhab.binding.ipcamera/README.md\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-08-30T09:21:14Z", "type": "commit"}, {"oid": "00e0674398a30edabbcaca93fadb6f3b4aa17eed", "url": "https://github.com/openhab/openhab-addons/commit/00e0674398a30edabbcaca93fadb6f3b4aa17eed", "message": "Use single ticks and new lines for each sentence.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T11:05:46Z", "type": "commit"}, {"oid": "b5f5be4f36ba873a0b9ba1c4cdbd090b645af535", "url": "https://github.com/openhab/openhab-addons/commit/b5f5be4f36ba873a0b9ba1c4cdbd090b645af535", "message": "Merge branch 'ipcamera' of https://github.com/Skinah/openhab-addons.git into ipcamera", "committedDate": "2020-08-30T11:08:26Z", "type": "commit"}, {"oid": "e4b87ab6798375136f1bda8318a49d1752ba233e", "url": "https://github.com/openhab/openhab-addons/commit/e4b87ab6798375136f1bda8318a49d1752ba233e", "message": "Update bundles/org.openhab.binding.ipcamera/README.md\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-08-30T11:38:49Z", "type": "commit"}, {"oid": "1e56b1c4715c1cd5a06a0cae76ee7f602395dcc4", "url": "https://github.com/openhab/openhab-addons/commit/1e56b1c4715c1cd5a06a0cae76ee7f602395dcc4", "message": "Update bundles/org.openhab.binding.ipcamera/README.md\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-08-30T11:51:05Z", "type": "commit"}, {"oid": "3672be0f1aae4da0daeb64f0aae1bc74e9f0b671", "url": "https://github.com/openhab/openhab-addons/commit/3672be0f1aae4da0daeb64f0aae1bc74e9f0b671", "message": "Update bundles/org.openhab.binding.ipcamera/README.md\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-08-30T11:54:04Z", "type": "commit"}, {"oid": "d345c1f6cf296fe76607fd989fa803e014919614", "url": "https://github.com/openhab/openhab-addons/commit/d345c1f6cf296fe76607fd989fa803e014919614", "message": "Update bundles/org.openhab.binding.ipcamera/README.md\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-08-30T11:58:52Z", "type": "commit"}, {"oid": "87df52a712eb8fd52707b2ceef59cb8808d2c908", "url": "https://github.com/openhab/openhab-addons/commit/87df52a712eb8fd52707b2ceef59cb8808d2c908", "message": "Readme fixes.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T12:02:34Z", "type": "commit"}, {"oid": "3f922c649d216b1711ce5fa8ac911207153fd155", "url": "https://github.com/openhab/openhab-addons/commit/3f922c649d216b1711ce5fa8ac911207153fd155", "message": "Update bundles/org.openhab.binding.ipcamera/README.md\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-08-30T12:03:13Z", "type": "commit"}, {"oid": "062c829c018742ec966530d8ed0e09bdb530f383", "url": "https://github.com/openhab/openhab-addons/commit/062c829c018742ec966530d8ed0e09bdb530f383", "message": "Merge branch 'ipcamera' of https://github.com/Skinah/openhab-addons.git into ipcamera", "committedDate": "2020-08-30T12:02:46Z", "type": "commit"}, {"oid": "184daa6452b9468f5d35e09402d255d84684c9a9", "url": "https://github.com/openhab/openhab-addons/commit/184daa6452b9468f5d35e09402d255d84684c9a9", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraGroupHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>", "committedDate": "2020-08-30T12:48:56Z", "type": "commit"}, {"oid": "942623c2ea655ec74211b14c57758ed9b9afe222", "url": "https://github.com/openhab/openhab-addons/commit/942623c2ea655ec74211b14c57758ed9b9afe222", "message": "logger change.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T13:27:06Z", "type": "commit"}, {"oid": "712d6d44cf0a0fbe7479e2ac0d32db4d4aad9da3", "url": "https://github.com/openhab/openhab-addons/commit/712d6d44cf0a0fbe7479e2ac0d32db4d4aad9da3", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraGroupHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>", "committedDate": "2020-08-30T13:29:05Z", "type": "commit"}, {"oid": "7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "url": "https://github.com/openhab/openhab-addons/commit/7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "message": "# WARNING: head commit changed in the meantime\n\nFix conflict.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-30T13:32:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgwNzYzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479807631", "bodyText": "I find it a bit concerning that you aren't doing\nIf listOfRequests, listOfChStatus, and listOfChannels are all supposed to accessed inside this loop but you only do a size check for listOfRequests. This reeks of a potential out of bounds error occurring. I think it would be better if instead of storing the data across multiple arrays you store the data in the fields of a new class and just have a single array of that new class instead.", "author": "cpmeister", "createdAt": "2020-08-30T19:38:33Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);", "originalCommit": "7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4NzAxMg==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479887012", "bodyText": "Agree, I was planning on doing that after discussing this with a friend who is a programmer that helps when I get stuck. The code has been working so I have left it alone, but to make it easier to modify in the future the class is the better way and it will solve the next few concerns you have regarding the unlock.", "author": "Skinah", "createdAt": "2020-08-31T04:53:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgwNzYzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU1MzEwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r483553107", "bodyText": "Done, created a new class and its much nicer and easier to change the binding now without risk of breaking.", "author": "Skinah", "createdAt": "2020-09-04T11:17:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgwNzYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgwNzg1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479807857", "bodyText": "unlocks should be done in the finally block of a try-finally.", "author": "cpmeister", "createdAt": "2020-08-30T19:41:02Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();", "originalCommit": "7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkzNTEzNw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479935137", "bodyText": "Done: Moved all unlocks into finally blocks.", "author": "Skinah", "createdAt": "2020-08-31T07:02:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgwNzg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgwODI0MA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479808240", "bodyText": "same issue here", "author": "cpmeister", "createdAt": "2020-08-30T19:45:30Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (\"PUT\".equals(httpMethod)) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot() {\n+        lockCurrentSnapshot.lock();\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+        if (preroll > 0) {\n+            fifoSnapshotBuffer.add(currentSnapshot);\n+            if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                fifoSnapshotBuffer.removeFirst();\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+        lockCurrentSnapshot.unlock();", "originalCommit": "7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkzNTE5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479935193", "bodyText": "Done: Moved all unlocks into finally blocks.", "author": "Skinah", "createdAt": "2020-08-31T07:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgwODI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgwODY1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479808651", "bodyText": "here too", "author": "cpmeister", "createdAt": "2020-08-30T19:50:45Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (\"PUT\".equals(httpMethod)) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot() {\n+        lockCurrentSnapshot.lock();\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+        if (preroll > 0) {\n+            fifoSnapshotBuffer.add(currentSnapshot);\n+            if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                fifoSnapshotBuffer.removeFirst();\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    // These methods handle the response from all Camera brands, nothing specific to\n+    // any brand should be in here //\n+\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                // logger.trace(\"{}\", msg.toString());\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                            if (closeConnection) {\n+                                lock.lock();\n+                                try {\n+                                    byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                    if (indexInLists >= 0) {\n+                                        listOfChStatus.set(indexInLists, (byte) 0);\n+                                    } else {\n+                                        logger.debug(\"!!!! Could not find the ch for a Connection: close URL:{}\",\n+                                                requestUrl);\n+                                    }\n+                                } finally {\n+                                    lock.unlock();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                lockCurrentSnapshot.lock();\n+                                currentSnapshot = incomingJpeg;\n+                                lockCurrentSnapshot.unlock();\n+                                processSnapshot();\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    // logger.trace(\"Snapshot recieved: Binding will now close the channel.\");\n+                                    ctx.close();\n+                                } else {\n+                                    lock.lock();\n+                                    try {\n+                                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                        if (indexInLists >= 0) {\n+                                            listOfChStatus.set(indexInLists, (byte) 2);\n+                                        }\n+                                    } finally {\n+                                        lock.unlock();\n+                                        bytesToRecieve = 0;\n+                                        bytesAlreadyRecieved = 0;\n+                                    }\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.equals(\"\")) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // logger.debug(\"Packet back from camera is not matching HttpContent\");\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+            if (ctx == null) {\n+                return;\n+            }\n+            lock.lock();\n+            try {\n+                byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                if (indexInLists >= 0) {\n+                    // logger.debug(\"commonCameraHandler closed channel:{} \\tURL:{}\", indexInLists, requestUrl);\n+                    listOfChStatus.set(indexInLists, (byte) -1);\n+                } else {\n+                    if (listOfChannels.size() > 0) {\n+                        logger.warn(\"Can't find ch when removing handler \\t\\tURL:{}\", requestUrl);\n+                    }\n+                }\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause instanceof ArrayIndexOutOfBoundsException) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                        if (indexInLists >= 0) {\n+                            String urlToKeepOpen;\n+                            switch (thing.getThingTypeUID().getId()) {\n+                                case \"DAHUA\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"HIKVISION\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/ISAPI/Event/notification/alertStream\".contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"DOORBIRD\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/bha-api/monitor.cgi?ring=doorbell,motionsensor\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                            }\n+                            logger.debug(\"! Channel was found idle for more than 15 seconds so closing it down. !\");\n+                            listOfChStatus.set(indexInLists, (byte) 0);\n+                        } else {\n+                            logger.warn(\"!?! Channel that was found idle could not be located in our tracking. !?!\");\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.debug(\"File server for camera at {} has started on port {} for all NIC's.\", ipAddress,\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    cameraConfigError(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setupSnapshotStreaming(boolean stream, ChannelHandlerContext ctx, boolean auto) {\n+        if (stream) {\n+            sendMjpegFirstPacket(ctx);\n+            if (auto) {\n+                autoSnapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                // iOS uses a FIFO? and needs two frames to display a pic\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();", "originalCommit": "7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkzNTI5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479935292", "bodyText": "Done: Moved all unlocks into finally blocks.", "author": "Skinah", "createdAt": "2020-08-31T07:02:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgwODY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgwODY1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479808654", "bodyText": "and here", "author": "cpmeister", "createdAt": "2020-08-30T19:50:51Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (\"PUT\".equals(httpMethod)) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot() {\n+        lockCurrentSnapshot.lock();\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+        if (preroll > 0) {\n+            fifoSnapshotBuffer.add(currentSnapshot);\n+            if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                fifoSnapshotBuffer.removeFirst();\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    // These methods handle the response from all Camera brands, nothing specific to\n+    // any brand should be in here //\n+\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                // logger.trace(\"{}\", msg.toString());\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                            if (closeConnection) {\n+                                lock.lock();\n+                                try {\n+                                    byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                    if (indexInLists >= 0) {\n+                                        listOfChStatus.set(indexInLists, (byte) 0);\n+                                    } else {\n+                                        logger.debug(\"!!!! Could not find the ch for a Connection: close URL:{}\",\n+                                                requestUrl);\n+                                    }\n+                                } finally {\n+                                    lock.unlock();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                lockCurrentSnapshot.lock();\n+                                currentSnapshot = incomingJpeg;\n+                                lockCurrentSnapshot.unlock();\n+                                processSnapshot();\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    // logger.trace(\"Snapshot recieved: Binding will now close the channel.\");\n+                                    ctx.close();\n+                                } else {\n+                                    lock.lock();\n+                                    try {\n+                                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                        if (indexInLists >= 0) {\n+                                            listOfChStatus.set(indexInLists, (byte) 2);\n+                                        }\n+                                    } finally {\n+                                        lock.unlock();\n+                                        bytesToRecieve = 0;\n+                                        bytesAlreadyRecieved = 0;\n+                                    }\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.equals(\"\")) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // logger.debug(\"Packet back from camera is not matching HttpContent\");\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+            if (ctx == null) {\n+                return;\n+            }\n+            lock.lock();\n+            try {\n+                byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                if (indexInLists >= 0) {\n+                    // logger.debug(\"commonCameraHandler closed channel:{} \\tURL:{}\", indexInLists, requestUrl);\n+                    listOfChStatus.set(indexInLists, (byte) -1);\n+                } else {\n+                    if (listOfChannels.size() > 0) {\n+                        logger.warn(\"Can't find ch when removing handler \\t\\tURL:{}\", requestUrl);\n+                    }\n+                }\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause instanceof ArrayIndexOutOfBoundsException) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                        if (indexInLists >= 0) {\n+                            String urlToKeepOpen;\n+                            switch (thing.getThingTypeUID().getId()) {\n+                                case \"DAHUA\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"HIKVISION\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/ISAPI/Event/notification/alertStream\".contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"DOORBIRD\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/bha-api/monitor.cgi?ring=doorbell,motionsensor\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                            }\n+                            logger.debug(\"! Channel was found idle for more than 15 seconds so closing it down. !\");\n+                            listOfChStatus.set(indexInLists, (byte) 0);\n+                        } else {\n+                            logger.warn(\"!?! Channel that was found idle could not be located in our tracking. !?!\");\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.debug(\"File server for camera at {} has started on port {} for all NIC's.\", ipAddress,\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    cameraConfigError(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setupSnapshotStreaming(boolean stream, ChannelHandlerContext ctx, boolean auto) {\n+        if (stream) {\n+            sendMjpegFirstPacket(ctx);\n+            if (auto) {\n+                autoSnapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                // iOS uses a FIFO? and needs two frames to display a pic\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingAutoFps = true;\n+            } else {\n+                snapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();", "originalCommit": "7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkzNTM0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479935342", "bodyText": "Done: Moved all unlocks into finally blocks.", "author": "Skinah", "createdAt": "2020-08-31T07:02:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgwODY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgwODY4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479808683", "bodyText": "and here", "author": "cpmeister", "createdAt": "2020-08-30T19:51:09Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (\"PUT\".equals(httpMethod)) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot() {\n+        lockCurrentSnapshot.lock();\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+        if (preroll > 0) {\n+            fifoSnapshotBuffer.add(currentSnapshot);\n+            if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                fifoSnapshotBuffer.removeFirst();\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    // These methods handle the response from all Camera brands, nothing specific to\n+    // any brand should be in here //\n+\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                // logger.trace(\"{}\", msg.toString());\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                            if (closeConnection) {\n+                                lock.lock();\n+                                try {\n+                                    byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                    if (indexInLists >= 0) {\n+                                        listOfChStatus.set(indexInLists, (byte) 0);\n+                                    } else {\n+                                        logger.debug(\"!!!! Could not find the ch for a Connection: close URL:{}\",\n+                                                requestUrl);\n+                                    }\n+                                } finally {\n+                                    lock.unlock();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                lockCurrentSnapshot.lock();\n+                                currentSnapshot = incomingJpeg;\n+                                lockCurrentSnapshot.unlock();\n+                                processSnapshot();\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    // logger.trace(\"Snapshot recieved: Binding will now close the channel.\");\n+                                    ctx.close();\n+                                } else {\n+                                    lock.lock();\n+                                    try {\n+                                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                        if (indexInLists >= 0) {\n+                                            listOfChStatus.set(indexInLists, (byte) 2);\n+                                        }\n+                                    } finally {\n+                                        lock.unlock();\n+                                        bytesToRecieve = 0;\n+                                        bytesAlreadyRecieved = 0;\n+                                    }\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.equals(\"\")) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // logger.debug(\"Packet back from camera is not matching HttpContent\");\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+            if (ctx == null) {\n+                return;\n+            }\n+            lock.lock();\n+            try {\n+                byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                if (indexInLists >= 0) {\n+                    // logger.debug(\"commonCameraHandler closed channel:{} \\tURL:{}\", indexInLists, requestUrl);\n+                    listOfChStatus.set(indexInLists, (byte) -1);\n+                } else {\n+                    if (listOfChannels.size() > 0) {\n+                        logger.warn(\"Can't find ch when removing handler \\t\\tURL:{}\", requestUrl);\n+                    }\n+                }\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause instanceof ArrayIndexOutOfBoundsException) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                        if (indexInLists >= 0) {\n+                            String urlToKeepOpen;\n+                            switch (thing.getThingTypeUID().getId()) {\n+                                case \"DAHUA\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"HIKVISION\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/ISAPI/Event/notification/alertStream\".contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"DOORBIRD\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/bha-api/monitor.cgi?ring=doorbell,motionsensor\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                            }\n+                            logger.debug(\"! Channel was found idle for more than 15 seconds so closing it down. !\");\n+                            listOfChStatus.set(indexInLists, (byte) 0);\n+                        } else {\n+                            logger.warn(\"!?! Channel that was found idle could not be located in our tracking. !?!\");\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.debug(\"File server for camera at {} has started on port {} for all NIC's.\", ipAddress,\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    cameraConfigError(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setupSnapshotStreaming(boolean stream, ChannelHandlerContext ctx, boolean auto) {\n+        if (stream) {\n+            sendMjpegFirstPacket(ctx);\n+            if (auto) {\n+                autoSnapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                // iOS uses a FIFO? and needs two frames to display a pic\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingAutoFps = true;\n+            } else {\n+                snapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingSnapshotMjpeg = true;\n+                startSnapshotPolling();\n+            }\n+        } else {\n+            snapshotMjpegChannelGroup.remove(ctx.channel());\n+            autoSnapshotMjpegChannelGroup.remove(ctx.channel());\n+            if (streamingSnapshotMjpeg && snapshotMjpegChannelGroup.isEmpty()) {\n+                streamingSnapshotMjpeg = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All Snapshot based MJPEG streams have stopped.\");\n+            } else if (streamingAutoFps && autoSnapshotMjpegChannelGroup.isEmpty()) {\n+                streamingAutoFps = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All AutoFps Snapshot based MJPEG streams have stopped.\");\n+            }\n+        }\n+    }\n+\n+    // If start is true the CTX is added to the list to stream video to, false stops\n+    // the stream.\n+    public void setupMjpegStreaming(boolean start, ChannelHandlerContext ctx) {\n+        if (start) {\n+            if (mjpegChannelGroup.isEmpty()) {// first stream being requested.\n+                mjpegChannelGroup.add(ctx.channel());\n+                if (mjpegUri.equals(\"\") || mjpegUri.equals(\"ffmpeg\")) {\n+                    sendMjpegFirstPacket(ctx);\n+                    setupFfmpegFormat(\"MJPEG\");\n+                } else {\n+                    try {\n+                        // fix Dahua reboots when refreshing a mjpeg stream.\n+                        TimeUnit.MILLISECONDS.sleep(500);\n+                    } catch (InterruptedException e) {\n+                    }\n+                    sendHttpGET(mjpegUri);\n+                }\n+            } else if (ffmpegMjpeg != null) {// not first stream and we will use ffmpeg\n+                sendMjpegFirstPacket(ctx);\n+                mjpegChannelGroup.add(ctx.channel());\n+            } else {// not first stream and camera supplies the mjpeg source.\n+                ctx.channel().writeAndFlush(firstStreamedMsg);\n+                mjpegChannelGroup.add(ctx.channel());\n+            }\n+        } else {\n+            mjpegChannelGroup.remove(ctx.channel());\n+            if (mjpegChannelGroup.isEmpty()) {\n+                logger.debug(\"All Mjpeg streams have stopped, cleaning up now\");\n+                if (mjpegUri.equals(\"ffmpeg\")) {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                } else if (!mjpegUri.equals(\"\")) {\n+                    closeChannel(getTinyUrl(mjpegUri));\n+                } else {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // sends direct to ctx so can be either snapshots.mjpeg or normal mjpeg stream\n+    public void sendMjpegFirstPacket(ChannelHandlerContext ctx) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        String contentType = \"multipart/x-mixed-replace; boundary=\" + BOUNDARY;\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+        ctx.channel().writeAndFlush(response);\n+    }\n+\n+    public void sendMjpegFrame(byte[] jpg, ChannelGroup channelGroup) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        ByteBuf imageByteBuf = Unpooled.copiedBuffer(jpg);\n+        int length = imageByteBuf.readableBytes();\n+        String header = \"--\" + BOUNDARY + \"\\r\\n\" + \"content-type: image/jpeg\" + \"\\r\\n\" + \"content-length: \" + length\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuf headerBbuf = Unpooled.copiedBuffer(header, 0, header.length(), StandardCharsets.UTF_8);\n+        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+        streamToGroup(headerBbuf, channelGroup, false);\n+        streamToGroup(imageByteBuf, channelGroup, false);\n+        streamToGroup(footerBbuf, channelGroup, true);\n+    }\n+\n+    public void streamToGroup(Object msg, ChannelGroup channelGroup, boolean flush) {\n+        channelGroup.write(msg);\n+        if (flush) {\n+            channelGroup.flush();\n+        }\n+    }\n+\n+    private void storeSnapshots() {\n+        int count = 0;\n+        // Need to lock as fifoSnapshotBuffer is not thread safe and new snapshots can be incoming.\n+        lockCurrentSnapshot.lock();\n+        logger.debug(\"Storing snapshots now to disk for GIF\");\n+        for (Object incomingJpeg : fifoSnapshotBuffer) {\n+            byte[] foo = (byte[]) incomingJpeg;\n+            File file = new File(ffmpegOutputFolder + \"snapshot\" + count + \".jpg\");\n+            count++;\n+            try {\n+                OutputStream fos = new FileOutputStream(file);\n+                fos.write(foo);\n+                fos.close();\n+            } catch (FileNotFoundException e) {\n+                logger.error(\"FileNotFoundException {}\", e.getMessage());\n+            } catch (IOException e) {\n+                logger.error(\"IOException {}\", e.getMessage());\n+            }\n+        }\n+        lockCurrentSnapshot.unlock();", "originalCommit": "7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkzNTQwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479935401", "bodyText": "Done: Moved all unlocks into finally blocks.", "author": "Skinah", "createdAt": "2020-08-31T07:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgwODY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgwOTU2NA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479809564", "bodyText": "Why not just pass in the snapshot to be processed into processSnapshot as an argument?", "author": "cpmeister", "createdAt": "2020-08-30T20:00:05Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (\"PUT\".equals(httpMethod)) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot() {\n+        lockCurrentSnapshot.lock();\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+        if (preroll > 0) {\n+            fifoSnapshotBuffer.add(currentSnapshot);\n+            if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                fifoSnapshotBuffer.removeFirst();\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    // These methods handle the response from all Camera brands, nothing specific to\n+    // any brand should be in here //\n+\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                // logger.trace(\"{}\", msg.toString());\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                            if (closeConnection) {\n+                                lock.lock();\n+                                try {\n+                                    byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                    if (indexInLists >= 0) {\n+                                        listOfChStatus.set(indexInLists, (byte) 0);\n+                                    } else {\n+                                        logger.debug(\"!!!! Could not find the ch for a Connection: close URL:{}\",\n+                                                requestUrl);\n+                                    }\n+                                } finally {\n+                                    lock.unlock();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                lockCurrentSnapshot.lock();\n+                                currentSnapshot = incomingJpeg;\n+                                lockCurrentSnapshot.unlock();\n+                                processSnapshot();", "originalCommit": "7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkyNDUxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479924511", "bodyText": "Thanks, that made things cleaner.", "author": "Skinah", "createdAt": "2020-08-31T06:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgwOTU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMDI1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479810255", "bodyText": "The error logging level should be reserved for issues catastrophic enough to threaten the operation of openHab itself. An error in a binding shouldn't qualify for this. Please read the openHab coding guidelines for expected use of logging in bindings.\nI recommend changing this to a warning instead.", "author": "cpmeister", "createdAt": "2020-08-30T20:07:39Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (\"PUT\".equals(httpMethod)) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot() {\n+        lockCurrentSnapshot.lock();\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+        if (preroll > 0) {\n+            fifoSnapshotBuffer.add(currentSnapshot);\n+            if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                fifoSnapshotBuffer.removeFirst();\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    // These methods handle the response from all Camera brands, nothing specific to\n+    // any brand should be in here //\n+\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                // logger.trace(\"{}\", msg.toString());\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                            if (closeConnection) {\n+                                lock.lock();\n+                                try {\n+                                    byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                    if (indexInLists >= 0) {\n+                                        listOfChStatus.set(indexInLists, (byte) 0);\n+                                    } else {\n+                                        logger.debug(\"!!!! Could not find the ch for a Connection: close URL:{}\",\n+                                                requestUrl);\n+                                    }\n+                                } finally {\n+                                    lock.unlock();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                lockCurrentSnapshot.lock();\n+                                currentSnapshot = incomingJpeg;\n+                                lockCurrentSnapshot.unlock();\n+                                processSnapshot();\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    // logger.trace(\"Snapshot recieved: Binding will now close the channel.\");\n+                                    ctx.close();\n+                                } else {\n+                                    lock.lock();\n+                                    try {\n+                                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                        if (indexInLists >= 0) {\n+                                            listOfChStatus.set(indexInLists, (byte) 2);\n+                                        }\n+                                    } finally {\n+                                        lock.unlock();\n+                                        bytesToRecieve = 0;\n+                                        bytesAlreadyRecieved = 0;\n+                                    }\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.equals(\"\")) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // logger.debug(\"Packet back from camera is not matching HttpContent\");\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+            if (ctx == null) {\n+                return;\n+            }\n+            lock.lock();\n+            try {\n+                byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                if (indexInLists >= 0) {\n+                    // logger.debug(\"commonCameraHandler closed channel:{} \\tURL:{}\", indexInLists, requestUrl);\n+                    listOfChStatus.set(indexInLists, (byte) -1);\n+                } else {\n+                    if (listOfChannels.size() > 0) {\n+                        logger.warn(\"Can't find ch when removing handler \\t\\tURL:{}\", requestUrl);\n+                    }\n+                }\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause instanceof ArrayIndexOutOfBoundsException) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                        if (indexInLists >= 0) {\n+                            String urlToKeepOpen;\n+                            switch (thing.getThingTypeUID().getId()) {\n+                                case \"DAHUA\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"HIKVISION\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/ISAPI/Event/notification/alertStream\".contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"DOORBIRD\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/bha-api/monitor.cgi?ring=doorbell,motionsensor\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                            }\n+                            logger.debug(\"! Channel was found idle for more than 15 seconds so closing it down. !\");\n+                            listOfChStatus.set(indexInLists, (byte) 0);\n+                        } else {\n+                            logger.warn(\"!?! Channel that was found idle could not be located in our tracking. !?!\");\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.debug(\"File server for camera at {} has started on port {} for all NIC's.\", ipAddress,\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    cameraConfigError(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setupSnapshotStreaming(boolean stream, ChannelHandlerContext ctx, boolean auto) {\n+        if (stream) {\n+            sendMjpegFirstPacket(ctx);\n+            if (auto) {\n+                autoSnapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                // iOS uses a FIFO? and needs two frames to display a pic\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingAutoFps = true;\n+            } else {\n+                snapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingSnapshotMjpeg = true;\n+                startSnapshotPolling();\n+            }\n+        } else {\n+            snapshotMjpegChannelGroup.remove(ctx.channel());\n+            autoSnapshotMjpegChannelGroup.remove(ctx.channel());\n+            if (streamingSnapshotMjpeg && snapshotMjpegChannelGroup.isEmpty()) {\n+                streamingSnapshotMjpeg = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All Snapshot based MJPEG streams have stopped.\");\n+            } else if (streamingAutoFps && autoSnapshotMjpegChannelGroup.isEmpty()) {\n+                streamingAutoFps = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All AutoFps Snapshot based MJPEG streams have stopped.\");\n+            }\n+        }\n+    }\n+\n+    // If start is true the CTX is added to the list to stream video to, false stops\n+    // the stream.\n+    public void setupMjpegStreaming(boolean start, ChannelHandlerContext ctx) {\n+        if (start) {\n+            if (mjpegChannelGroup.isEmpty()) {// first stream being requested.\n+                mjpegChannelGroup.add(ctx.channel());\n+                if (mjpegUri.equals(\"\") || mjpegUri.equals(\"ffmpeg\")) {\n+                    sendMjpegFirstPacket(ctx);\n+                    setupFfmpegFormat(\"MJPEG\");\n+                } else {\n+                    try {\n+                        // fix Dahua reboots when refreshing a mjpeg stream.\n+                        TimeUnit.MILLISECONDS.sleep(500);\n+                    } catch (InterruptedException e) {\n+                    }\n+                    sendHttpGET(mjpegUri);\n+                }\n+            } else if (ffmpegMjpeg != null) {// not first stream and we will use ffmpeg\n+                sendMjpegFirstPacket(ctx);\n+                mjpegChannelGroup.add(ctx.channel());\n+            } else {// not first stream and camera supplies the mjpeg source.\n+                ctx.channel().writeAndFlush(firstStreamedMsg);\n+                mjpegChannelGroup.add(ctx.channel());\n+            }\n+        } else {\n+            mjpegChannelGroup.remove(ctx.channel());\n+            if (mjpegChannelGroup.isEmpty()) {\n+                logger.debug(\"All Mjpeg streams have stopped, cleaning up now\");\n+                if (mjpegUri.equals(\"ffmpeg\")) {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                } else if (!mjpegUri.equals(\"\")) {\n+                    closeChannel(getTinyUrl(mjpegUri));\n+                } else {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // sends direct to ctx so can be either snapshots.mjpeg or normal mjpeg stream\n+    public void sendMjpegFirstPacket(ChannelHandlerContext ctx) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        String contentType = \"multipart/x-mixed-replace; boundary=\" + BOUNDARY;\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+        ctx.channel().writeAndFlush(response);\n+    }\n+\n+    public void sendMjpegFrame(byte[] jpg, ChannelGroup channelGroup) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        ByteBuf imageByteBuf = Unpooled.copiedBuffer(jpg);\n+        int length = imageByteBuf.readableBytes();\n+        String header = \"--\" + BOUNDARY + \"\\r\\n\" + \"content-type: image/jpeg\" + \"\\r\\n\" + \"content-length: \" + length\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuf headerBbuf = Unpooled.copiedBuffer(header, 0, header.length(), StandardCharsets.UTF_8);\n+        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+        streamToGroup(headerBbuf, channelGroup, false);\n+        streamToGroup(imageByteBuf, channelGroup, false);\n+        streamToGroup(footerBbuf, channelGroup, true);\n+    }\n+\n+    public void streamToGroup(Object msg, ChannelGroup channelGroup, boolean flush) {\n+        channelGroup.write(msg);\n+        if (flush) {\n+            channelGroup.flush();\n+        }\n+    }\n+\n+    private void storeSnapshots() {\n+        int count = 0;\n+        // Need to lock as fifoSnapshotBuffer is not thread safe and new snapshots can be incoming.\n+        lockCurrentSnapshot.lock();\n+        logger.debug(\"Storing snapshots now to disk for GIF\");\n+        for (Object incomingJpeg : fifoSnapshotBuffer) {\n+            byte[] foo = (byte[]) incomingJpeg;\n+            File file = new File(ffmpegOutputFolder + \"snapshot\" + count + \".jpg\");\n+            count++;\n+            try {\n+                OutputStream fos = new FileOutputStream(file);\n+                fos.write(foo);\n+                fos.close();\n+            } catch (FileNotFoundException e) {\n+                logger.error(\"FileNotFoundException {}\", e.getMessage());\n+            } catch (IOException e) {\n+                logger.error(\"IOException {}\", e.getMessage());\n+            }\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    public void setupFfmpegFormat(String format) {\n+        String inOptions = \"\";\n+        if (ffmpegOutputFolder.equals(\"\")) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when the output folder is not set.\");", "originalCommit": "7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg5NjEzMA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479896130", "bodyText": "FIXED: Thank you for suggesting, I have gone through all files and made the change to warn.", "author": "Skinah", "createdAt": "2020-08-31T05:31:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMDI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMDM3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479810372", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    updateState(CHANNEL_AUDIO_ALARM, OnOffType.valueOf(\"ON\"));\n          \n          \n            \n                    updateState(CHANNEL_AUDIO_ALARM, OnOffType.ON);", "author": "cpmeister", "createdAt": "2020-08-30T20:08:38Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (\"PUT\".equals(httpMethod)) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot() {\n+        lockCurrentSnapshot.lock();\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+        if (preroll > 0) {\n+            fifoSnapshotBuffer.add(currentSnapshot);\n+            if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                fifoSnapshotBuffer.removeFirst();\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    // These methods handle the response from all Camera brands, nothing specific to\n+    // any brand should be in here //\n+\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                // logger.trace(\"{}\", msg.toString());\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                            if (closeConnection) {\n+                                lock.lock();\n+                                try {\n+                                    byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                    if (indexInLists >= 0) {\n+                                        listOfChStatus.set(indexInLists, (byte) 0);\n+                                    } else {\n+                                        logger.debug(\"!!!! Could not find the ch for a Connection: close URL:{}\",\n+                                                requestUrl);\n+                                    }\n+                                } finally {\n+                                    lock.unlock();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                lockCurrentSnapshot.lock();\n+                                currentSnapshot = incomingJpeg;\n+                                lockCurrentSnapshot.unlock();\n+                                processSnapshot();\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    // logger.trace(\"Snapshot recieved: Binding will now close the channel.\");\n+                                    ctx.close();\n+                                } else {\n+                                    lock.lock();\n+                                    try {\n+                                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                        if (indexInLists >= 0) {\n+                                            listOfChStatus.set(indexInLists, (byte) 2);\n+                                        }\n+                                    } finally {\n+                                        lock.unlock();\n+                                        bytesToRecieve = 0;\n+                                        bytesAlreadyRecieved = 0;\n+                                    }\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.equals(\"\")) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // logger.debug(\"Packet back from camera is not matching HttpContent\");\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+            if (ctx == null) {\n+                return;\n+            }\n+            lock.lock();\n+            try {\n+                byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                if (indexInLists >= 0) {\n+                    // logger.debug(\"commonCameraHandler closed channel:{} \\tURL:{}\", indexInLists, requestUrl);\n+                    listOfChStatus.set(indexInLists, (byte) -1);\n+                } else {\n+                    if (listOfChannels.size() > 0) {\n+                        logger.warn(\"Can't find ch when removing handler \\t\\tURL:{}\", requestUrl);\n+                    }\n+                }\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause instanceof ArrayIndexOutOfBoundsException) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                        if (indexInLists >= 0) {\n+                            String urlToKeepOpen;\n+                            switch (thing.getThingTypeUID().getId()) {\n+                                case \"DAHUA\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"HIKVISION\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/ISAPI/Event/notification/alertStream\".contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"DOORBIRD\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/bha-api/monitor.cgi?ring=doorbell,motionsensor\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                            }\n+                            logger.debug(\"! Channel was found idle for more than 15 seconds so closing it down. !\");\n+                            listOfChStatus.set(indexInLists, (byte) 0);\n+                        } else {\n+                            logger.warn(\"!?! Channel that was found idle could not be located in our tracking. !?!\");\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.debug(\"File server for camera at {} has started on port {} for all NIC's.\", ipAddress,\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    cameraConfigError(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setupSnapshotStreaming(boolean stream, ChannelHandlerContext ctx, boolean auto) {\n+        if (stream) {\n+            sendMjpegFirstPacket(ctx);\n+            if (auto) {\n+                autoSnapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                // iOS uses a FIFO? and needs two frames to display a pic\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingAutoFps = true;\n+            } else {\n+                snapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingSnapshotMjpeg = true;\n+                startSnapshotPolling();\n+            }\n+        } else {\n+            snapshotMjpegChannelGroup.remove(ctx.channel());\n+            autoSnapshotMjpegChannelGroup.remove(ctx.channel());\n+            if (streamingSnapshotMjpeg && snapshotMjpegChannelGroup.isEmpty()) {\n+                streamingSnapshotMjpeg = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All Snapshot based MJPEG streams have stopped.\");\n+            } else if (streamingAutoFps && autoSnapshotMjpegChannelGroup.isEmpty()) {\n+                streamingAutoFps = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All AutoFps Snapshot based MJPEG streams have stopped.\");\n+            }\n+        }\n+    }\n+\n+    // If start is true the CTX is added to the list to stream video to, false stops\n+    // the stream.\n+    public void setupMjpegStreaming(boolean start, ChannelHandlerContext ctx) {\n+        if (start) {\n+            if (mjpegChannelGroup.isEmpty()) {// first stream being requested.\n+                mjpegChannelGroup.add(ctx.channel());\n+                if (mjpegUri.equals(\"\") || mjpegUri.equals(\"ffmpeg\")) {\n+                    sendMjpegFirstPacket(ctx);\n+                    setupFfmpegFormat(\"MJPEG\");\n+                } else {\n+                    try {\n+                        // fix Dahua reboots when refreshing a mjpeg stream.\n+                        TimeUnit.MILLISECONDS.sleep(500);\n+                    } catch (InterruptedException e) {\n+                    }\n+                    sendHttpGET(mjpegUri);\n+                }\n+            } else if (ffmpegMjpeg != null) {// not first stream and we will use ffmpeg\n+                sendMjpegFirstPacket(ctx);\n+                mjpegChannelGroup.add(ctx.channel());\n+            } else {// not first stream and camera supplies the mjpeg source.\n+                ctx.channel().writeAndFlush(firstStreamedMsg);\n+                mjpegChannelGroup.add(ctx.channel());\n+            }\n+        } else {\n+            mjpegChannelGroup.remove(ctx.channel());\n+            if (mjpegChannelGroup.isEmpty()) {\n+                logger.debug(\"All Mjpeg streams have stopped, cleaning up now\");\n+                if (mjpegUri.equals(\"ffmpeg\")) {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                } else if (!mjpegUri.equals(\"\")) {\n+                    closeChannel(getTinyUrl(mjpegUri));\n+                } else {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // sends direct to ctx so can be either snapshots.mjpeg or normal mjpeg stream\n+    public void sendMjpegFirstPacket(ChannelHandlerContext ctx) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        String contentType = \"multipart/x-mixed-replace; boundary=\" + BOUNDARY;\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+        ctx.channel().writeAndFlush(response);\n+    }\n+\n+    public void sendMjpegFrame(byte[] jpg, ChannelGroup channelGroup) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        ByteBuf imageByteBuf = Unpooled.copiedBuffer(jpg);\n+        int length = imageByteBuf.readableBytes();\n+        String header = \"--\" + BOUNDARY + \"\\r\\n\" + \"content-type: image/jpeg\" + \"\\r\\n\" + \"content-length: \" + length\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuf headerBbuf = Unpooled.copiedBuffer(header, 0, header.length(), StandardCharsets.UTF_8);\n+        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+        streamToGroup(headerBbuf, channelGroup, false);\n+        streamToGroup(imageByteBuf, channelGroup, false);\n+        streamToGroup(footerBbuf, channelGroup, true);\n+    }\n+\n+    public void streamToGroup(Object msg, ChannelGroup channelGroup, boolean flush) {\n+        channelGroup.write(msg);\n+        if (flush) {\n+            channelGroup.flush();\n+        }\n+    }\n+\n+    private void storeSnapshots() {\n+        int count = 0;\n+        // Need to lock as fifoSnapshotBuffer is not thread safe and new snapshots can be incoming.\n+        lockCurrentSnapshot.lock();\n+        logger.debug(\"Storing snapshots now to disk for GIF\");\n+        for (Object incomingJpeg : fifoSnapshotBuffer) {\n+            byte[] foo = (byte[]) incomingJpeg;\n+            File file = new File(ffmpegOutputFolder + \"snapshot\" + count + \".jpg\");\n+            count++;\n+            try {\n+                OutputStream fos = new FileOutputStream(file);\n+                fos.write(foo);\n+                fos.close();\n+            } catch (FileNotFoundException e) {\n+                logger.error(\"FileNotFoundException {}\", e.getMessage());\n+            } catch (IOException e) {\n+                logger.error(\"IOException {}\", e.getMessage());\n+            }\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    public void setupFfmpegFormat(String format) {\n+        String inOptions = \"\";\n+        if (ffmpegOutputFolder.equals(\"\")) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when the output folder is not set.\");\n+            return;\n+        }\n+        if (rtspUri.equals(\"\")) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when no valid input for ffmpeg is provided.\");\n+            return;\n+        }\n+        if (config.get(CONFIG_FFMPEG_LOCATION) == null) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when the location for ffmpeg is not known.\");\n+            return;\n+        }\n+\n+        // Make sure the folder exists, if not create it.\n+        new File(ffmpegOutputFolder).mkdirs();\n+        switch (format) {\n+            case \"HLS\":\n+                if (ffmpegHLS == null) {\n+                    if (rtspUri.contains(\":554\")) {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning -rtsp_transport tcp\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    } else {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    }\n+                }\n+                if (ffmpegHLS != null) {\n+                    ffmpegHLS.startConverting();\n+                }\n+                break;\n+            case \"GIF\":\n+                if (preroll > 0) {\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                            \"-y -r 1 -hide_banner -loglevel warning\", ffmpegOutputFolder + \"snapshot%d.jpg\",\n+                            \"-frames:v \" + (preroll + postroll) + \" \"\n+                                    + config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                } else {\n+                    inOptions = \"-y -t \" + postroll + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-y -t \" + postroll;\n+                    }\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                }\n+                if (preroll > 0) {\n+                    storeSnapshots();\n+                }\n+                if (ffmpegGIF != null) {\n+                    ffmpegGIF.startConverting();\n+                    if (gifHistory.equals(\"\")) {\n+                        gifHistory = gifFilename;\n+                    } else if (!gifFilename.equals(\"ipcamera\")) {\n+                        gifHistory = gifFilename + \",\" + gifHistory;\n+                        if (gifHistoryLength > 49) {\n+                            int endIndex = gifHistory.lastIndexOf(\",\");\n+                            gifHistory = gifHistory.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_GIF_HISTORY, new StringType(gifHistory));\n+                }\n+                break;\n+            case \"RECORD\":\n+                inOptions = \"-y -t \" + mp4RecordTime + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                if (!rtspUri.contains(\"rtsp\")) {\n+                    inOptions = \"-y -t \" + mp4RecordTime;\n+                }\n+                ffmpegRecord = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                        rtspUri, config.get(CONFIG_FFMPEG_MP4_OUT_ARGUMENTS).toString(),\n+                        ffmpegOutputFolder + mp4Filename + \".mp4\", username, password);\n+                if (mp4Preroll > 0) {\n+                    // fetchFromHLS(); todo: not done yet\n+                }\n+                if (ffmpegRecord != null) {\n+                    ffmpegRecord.startConverting();\n+                    if (mp4History.equals(\"\")) {\n+                        mp4History = mp4Filename;\n+                    } else if (!mp4Filename.equals(\"ipcamera\")) {\n+                        mp4History = mp4Filename + \",\" + mp4History;\n+                        if (mp4HistoryLength > 49) {\n+                            int endIndex = mp4History.lastIndexOf(\",\");\n+                            mp4History = mp4History.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_MP4_HISTORY, new StringType(mp4History));\n+                }\n+                break;\n+            case \"RTSPHELPER\":\n+                if (ffmpegRtspHelper != null) {\n+                    ffmpegRtspHelper.stopConverting();\n+                    if (!audioAlarmEnabled && !motionAlarmEnabled) {\n+                        return;\n+                    }\n+                }\n+                String input = (config.get(CONFIG_FFMPEG_MOTION_INPUT) == null) ? rtspUri\n+                        : config.get(CONFIG_FFMPEG_MOTION_INPUT).toString();\n+                String OutputOptions = \"-f null -\";\n+                String filterOptions = \"\";\n+                inOptions = \"-rtsp_transport tcp\";\n+                if (!input.contains(\"rtsp\")) {\n+                    inOptions = \"\";\n+                }\n+                if (audioAlarmEnabled == false) {\n+                    filterOptions = \"-an\";\n+                } else if (audioAlarmEnabled == true) {\n+                    filterOptions = \"-af silencedetect=n=-\" + audioThreshold + \"dB:d=2\";\n+                }\n+                if (motionAlarmEnabled == false && ffmpegSnapshotGeneration == false) {\n+                    filterOptions = filterOptions.concat(\" -vn\");\n+                } else if (motionAlarmEnabled == true) {\n+                    filterOptions = filterOptions\n+                            .concat(\" -vf select='gte(scene,\" + motionThreshold + \")',metadata=print\");\n+                }\n+                if (config.get(CONFIG_USERNAME) != null) {\n+                    filterOptions += \" \";// add space as the Framework does not allow spaces at start of config.\n+                }\n+                ffmpegRtspHelper = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                        input, filterOptions + config.get(CONFIG_FFMPEG_MOTION_ARGUMENTS), OutputOptions, username,\n+                        password);\n+                ffmpegRtspHelper.startConverting();\n+                break;\n+            case \"MJPEG\":\n+                if (ffmpegMjpeg == null) {\n+                    inOptions = \"-rtsp_transport tcp -hide_banner -loglevel warning\";\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegMjpeg = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, config.get(CONFIG_FFMPEG_MJPEG_ARGUMENTS).toString(),\n+                            \"http://127.0.0.1:\" + serverPort + \"/ipcamera.jpg\", username, password);\n+                }\n+                if (ffmpegMjpeg != null) {\n+                    ffmpegMjpeg.startConverting();\n+                }\n+                break;\n+            case \"SNAPSHOT\":\n+                // if mjpeg stream you can use ffmpeg -i input.h264 -codec:v copy -bsf:v mjpeg2jpeg output%03d.jpg\n+                if (ffmpegSnapshot == null) {\n+                    inOptions = \"-rtsp_transport tcp -threads 1 -skip_frame nokey -hide_banner -loglevel warning\";// iFrames\n+                                                                                                                  // only\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-threads 1 -skip_frame nokey -hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegSnapshot = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, \"-an -vsync vfr -update 1\", \"http://127.0.0.1:\" + serverPort + \"/snapshot.jpg\",\n+                            username, password);\n+                }\n+                if (ffmpegSnapshot != null) {\n+                    ffmpegSnapshot.startConverting();\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void noMotionDetected(String thisAlarmsChannel) {\n+        setChannelState(thisAlarmsChannel, OnOffType.valueOf(\"OFF\"));\n+        firstMotionAlarm = false;\n+        motionAlarmUpdateSnapshot = false;\n+        motionDetected = false;\n+        if (streamingAutoFps) {\n+            stopSnapshotPolling();\n+        } else if (updateImageEvents.contains(\"4\")) { // During Motion Alarms\n+            stopSnapshotPolling();\n+        }\n+    }\n+\n+    // Change alarms that are not counted as motion detecting.\n+    public void changeAlarmState(String thisAlarmsChannel, String state) {\n+        updateState(thisAlarmsChannel, OnOffType.valueOf(state));\n+    }\n+\n+    public void motionDetected(String thisAlarmsChannel) {\n+        updateState(CHANNEL_LAST_MOTION_TYPE, new StringType(thisAlarmsChannel));\n+        updateState(thisAlarmsChannel, OnOffType.valueOf(\"ON\"));\n+        motionDetected = true;\n+        if (streamingAutoFps) {\n+            startSnapshotPolling();\n+        }\n+        if (updateImageEvents.contains(\"2\")) {\n+            if (!firstMotionAlarm) {\n+                if (!snapshotUri.isEmpty()) {\n+                    sendHttpGET(snapshotUri);\n+                }\n+                firstMotionAlarm = true;// reset back to false when the jpg arrives.\n+            }\n+        } else if (updateImageEvents.contains(\"4\")) { // During Motion Alarms\n+            if (!snapshotPolling) {\n+                startSnapshotPolling();\n+            }\n+            firstMotionAlarm = true;\n+            motionAlarmUpdateSnapshot = true;\n+        }\n+    }\n+\n+    public void audioDetected() {\n+        updateState(CHANNEL_AUDIO_ALARM, OnOffType.valueOf(\"ON\"));", "originalCommit": "7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMDM4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479810385", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    updateState(thisAlarmsChannel, OnOffType.valueOf(\"ON\"));\n          \n          \n            \n                    updateState(thisAlarmsChannel, OnOffType.ON);", "author": "cpmeister", "createdAt": "2020-08-30T20:08:48Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (\"PUT\".equals(httpMethod)) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot() {\n+        lockCurrentSnapshot.lock();\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+        if (preroll > 0) {\n+            fifoSnapshotBuffer.add(currentSnapshot);\n+            if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                fifoSnapshotBuffer.removeFirst();\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    // These methods handle the response from all Camera brands, nothing specific to\n+    // any brand should be in here //\n+\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                // logger.trace(\"{}\", msg.toString());\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                            if (closeConnection) {\n+                                lock.lock();\n+                                try {\n+                                    byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                    if (indexInLists >= 0) {\n+                                        listOfChStatus.set(indexInLists, (byte) 0);\n+                                    } else {\n+                                        logger.debug(\"!!!! Could not find the ch for a Connection: close URL:{}\",\n+                                                requestUrl);\n+                                    }\n+                                } finally {\n+                                    lock.unlock();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                lockCurrentSnapshot.lock();\n+                                currentSnapshot = incomingJpeg;\n+                                lockCurrentSnapshot.unlock();\n+                                processSnapshot();\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    // logger.trace(\"Snapshot recieved: Binding will now close the channel.\");\n+                                    ctx.close();\n+                                } else {\n+                                    lock.lock();\n+                                    try {\n+                                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                        if (indexInLists >= 0) {\n+                                            listOfChStatus.set(indexInLists, (byte) 2);\n+                                        }\n+                                    } finally {\n+                                        lock.unlock();\n+                                        bytesToRecieve = 0;\n+                                        bytesAlreadyRecieved = 0;\n+                                    }\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.equals(\"\")) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // logger.debug(\"Packet back from camera is not matching HttpContent\");\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+            if (ctx == null) {\n+                return;\n+            }\n+            lock.lock();\n+            try {\n+                byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                if (indexInLists >= 0) {\n+                    // logger.debug(\"commonCameraHandler closed channel:{} \\tURL:{}\", indexInLists, requestUrl);\n+                    listOfChStatus.set(indexInLists, (byte) -1);\n+                } else {\n+                    if (listOfChannels.size() > 0) {\n+                        logger.warn(\"Can't find ch when removing handler \\t\\tURL:{}\", requestUrl);\n+                    }\n+                }\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause instanceof ArrayIndexOutOfBoundsException) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                        if (indexInLists >= 0) {\n+                            String urlToKeepOpen;\n+                            switch (thing.getThingTypeUID().getId()) {\n+                                case \"DAHUA\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"HIKVISION\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/ISAPI/Event/notification/alertStream\".contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"DOORBIRD\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/bha-api/monitor.cgi?ring=doorbell,motionsensor\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                            }\n+                            logger.debug(\"! Channel was found idle for more than 15 seconds so closing it down. !\");\n+                            listOfChStatus.set(indexInLists, (byte) 0);\n+                        } else {\n+                            logger.warn(\"!?! Channel that was found idle could not be located in our tracking. !?!\");\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.debug(\"File server for camera at {} has started on port {} for all NIC's.\", ipAddress,\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    cameraConfigError(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setupSnapshotStreaming(boolean stream, ChannelHandlerContext ctx, boolean auto) {\n+        if (stream) {\n+            sendMjpegFirstPacket(ctx);\n+            if (auto) {\n+                autoSnapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                // iOS uses a FIFO? and needs two frames to display a pic\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingAutoFps = true;\n+            } else {\n+                snapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingSnapshotMjpeg = true;\n+                startSnapshotPolling();\n+            }\n+        } else {\n+            snapshotMjpegChannelGroup.remove(ctx.channel());\n+            autoSnapshotMjpegChannelGroup.remove(ctx.channel());\n+            if (streamingSnapshotMjpeg && snapshotMjpegChannelGroup.isEmpty()) {\n+                streamingSnapshotMjpeg = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All Snapshot based MJPEG streams have stopped.\");\n+            } else if (streamingAutoFps && autoSnapshotMjpegChannelGroup.isEmpty()) {\n+                streamingAutoFps = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All AutoFps Snapshot based MJPEG streams have stopped.\");\n+            }\n+        }\n+    }\n+\n+    // If start is true the CTX is added to the list to stream video to, false stops\n+    // the stream.\n+    public void setupMjpegStreaming(boolean start, ChannelHandlerContext ctx) {\n+        if (start) {\n+            if (mjpegChannelGroup.isEmpty()) {// first stream being requested.\n+                mjpegChannelGroup.add(ctx.channel());\n+                if (mjpegUri.equals(\"\") || mjpegUri.equals(\"ffmpeg\")) {\n+                    sendMjpegFirstPacket(ctx);\n+                    setupFfmpegFormat(\"MJPEG\");\n+                } else {\n+                    try {\n+                        // fix Dahua reboots when refreshing a mjpeg stream.\n+                        TimeUnit.MILLISECONDS.sleep(500);\n+                    } catch (InterruptedException e) {\n+                    }\n+                    sendHttpGET(mjpegUri);\n+                }\n+            } else if (ffmpegMjpeg != null) {// not first stream and we will use ffmpeg\n+                sendMjpegFirstPacket(ctx);\n+                mjpegChannelGroup.add(ctx.channel());\n+            } else {// not first stream and camera supplies the mjpeg source.\n+                ctx.channel().writeAndFlush(firstStreamedMsg);\n+                mjpegChannelGroup.add(ctx.channel());\n+            }\n+        } else {\n+            mjpegChannelGroup.remove(ctx.channel());\n+            if (mjpegChannelGroup.isEmpty()) {\n+                logger.debug(\"All Mjpeg streams have stopped, cleaning up now\");\n+                if (mjpegUri.equals(\"ffmpeg\")) {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                } else if (!mjpegUri.equals(\"\")) {\n+                    closeChannel(getTinyUrl(mjpegUri));\n+                } else {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // sends direct to ctx so can be either snapshots.mjpeg or normal mjpeg stream\n+    public void sendMjpegFirstPacket(ChannelHandlerContext ctx) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        String contentType = \"multipart/x-mixed-replace; boundary=\" + BOUNDARY;\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+        ctx.channel().writeAndFlush(response);\n+    }\n+\n+    public void sendMjpegFrame(byte[] jpg, ChannelGroup channelGroup) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        ByteBuf imageByteBuf = Unpooled.copiedBuffer(jpg);\n+        int length = imageByteBuf.readableBytes();\n+        String header = \"--\" + BOUNDARY + \"\\r\\n\" + \"content-type: image/jpeg\" + \"\\r\\n\" + \"content-length: \" + length\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuf headerBbuf = Unpooled.copiedBuffer(header, 0, header.length(), StandardCharsets.UTF_8);\n+        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+        streamToGroup(headerBbuf, channelGroup, false);\n+        streamToGroup(imageByteBuf, channelGroup, false);\n+        streamToGroup(footerBbuf, channelGroup, true);\n+    }\n+\n+    public void streamToGroup(Object msg, ChannelGroup channelGroup, boolean flush) {\n+        channelGroup.write(msg);\n+        if (flush) {\n+            channelGroup.flush();\n+        }\n+    }\n+\n+    private void storeSnapshots() {\n+        int count = 0;\n+        // Need to lock as fifoSnapshotBuffer is not thread safe and new snapshots can be incoming.\n+        lockCurrentSnapshot.lock();\n+        logger.debug(\"Storing snapshots now to disk for GIF\");\n+        for (Object incomingJpeg : fifoSnapshotBuffer) {\n+            byte[] foo = (byte[]) incomingJpeg;\n+            File file = new File(ffmpegOutputFolder + \"snapshot\" + count + \".jpg\");\n+            count++;\n+            try {\n+                OutputStream fos = new FileOutputStream(file);\n+                fos.write(foo);\n+                fos.close();\n+            } catch (FileNotFoundException e) {\n+                logger.error(\"FileNotFoundException {}\", e.getMessage());\n+            } catch (IOException e) {\n+                logger.error(\"IOException {}\", e.getMessage());\n+            }\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    public void setupFfmpegFormat(String format) {\n+        String inOptions = \"\";\n+        if (ffmpegOutputFolder.equals(\"\")) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when the output folder is not set.\");\n+            return;\n+        }\n+        if (rtspUri.equals(\"\")) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when no valid input for ffmpeg is provided.\");\n+            return;\n+        }\n+        if (config.get(CONFIG_FFMPEG_LOCATION) == null) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when the location for ffmpeg is not known.\");\n+            return;\n+        }\n+\n+        // Make sure the folder exists, if not create it.\n+        new File(ffmpegOutputFolder).mkdirs();\n+        switch (format) {\n+            case \"HLS\":\n+                if (ffmpegHLS == null) {\n+                    if (rtspUri.contains(\":554\")) {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning -rtsp_transport tcp\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    } else {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    }\n+                }\n+                if (ffmpegHLS != null) {\n+                    ffmpegHLS.startConverting();\n+                }\n+                break;\n+            case \"GIF\":\n+                if (preroll > 0) {\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                            \"-y -r 1 -hide_banner -loglevel warning\", ffmpegOutputFolder + \"snapshot%d.jpg\",\n+                            \"-frames:v \" + (preroll + postroll) + \" \"\n+                                    + config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                } else {\n+                    inOptions = \"-y -t \" + postroll + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-y -t \" + postroll;\n+                    }\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                }\n+                if (preroll > 0) {\n+                    storeSnapshots();\n+                }\n+                if (ffmpegGIF != null) {\n+                    ffmpegGIF.startConverting();\n+                    if (gifHistory.equals(\"\")) {\n+                        gifHistory = gifFilename;\n+                    } else if (!gifFilename.equals(\"ipcamera\")) {\n+                        gifHistory = gifFilename + \",\" + gifHistory;\n+                        if (gifHistoryLength > 49) {\n+                            int endIndex = gifHistory.lastIndexOf(\",\");\n+                            gifHistory = gifHistory.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_GIF_HISTORY, new StringType(gifHistory));\n+                }\n+                break;\n+            case \"RECORD\":\n+                inOptions = \"-y -t \" + mp4RecordTime + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                if (!rtspUri.contains(\"rtsp\")) {\n+                    inOptions = \"-y -t \" + mp4RecordTime;\n+                }\n+                ffmpegRecord = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                        rtspUri, config.get(CONFIG_FFMPEG_MP4_OUT_ARGUMENTS).toString(),\n+                        ffmpegOutputFolder + mp4Filename + \".mp4\", username, password);\n+                if (mp4Preroll > 0) {\n+                    // fetchFromHLS(); todo: not done yet\n+                }\n+                if (ffmpegRecord != null) {\n+                    ffmpegRecord.startConverting();\n+                    if (mp4History.equals(\"\")) {\n+                        mp4History = mp4Filename;\n+                    } else if (!mp4Filename.equals(\"ipcamera\")) {\n+                        mp4History = mp4Filename + \",\" + mp4History;\n+                        if (mp4HistoryLength > 49) {\n+                            int endIndex = mp4History.lastIndexOf(\",\");\n+                            mp4History = mp4History.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_MP4_HISTORY, new StringType(mp4History));\n+                }\n+                break;\n+            case \"RTSPHELPER\":\n+                if (ffmpegRtspHelper != null) {\n+                    ffmpegRtspHelper.stopConverting();\n+                    if (!audioAlarmEnabled && !motionAlarmEnabled) {\n+                        return;\n+                    }\n+                }\n+                String input = (config.get(CONFIG_FFMPEG_MOTION_INPUT) == null) ? rtspUri\n+                        : config.get(CONFIG_FFMPEG_MOTION_INPUT).toString();\n+                String OutputOptions = \"-f null -\";\n+                String filterOptions = \"\";\n+                inOptions = \"-rtsp_transport tcp\";\n+                if (!input.contains(\"rtsp\")) {\n+                    inOptions = \"\";\n+                }\n+                if (audioAlarmEnabled == false) {\n+                    filterOptions = \"-an\";\n+                } else if (audioAlarmEnabled == true) {\n+                    filterOptions = \"-af silencedetect=n=-\" + audioThreshold + \"dB:d=2\";\n+                }\n+                if (motionAlarmEnabled == false && ffmpegSnapshotGeneration == false) {\n+                    filterOptions = filterOptions.concat(\" -vn\");\n+                } else if (motionAlarmEnabled == true) {\n+                    filterOptions = filterOptions\n+                            .concat(\" -vf select='gte(scene,\" + motionThreshold + \")',metadata=print\");\n+                }\n+                if (config.get(CONFIG_USERNAME) != null) {\n+                    filterOptions += \" \";// add space as the Framework does not allow spaces at start of config.\n+                }\n+                ffmpegRtspHelper = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                        input, filterOptions + config.get(CONFIG_FFMPEG_MOTION_ARGUMENTS), OutputOptions, username,\n+                        password);\n+                ffmpegRtspHelper.startConverting();\n+                break;\n+            case \"MJPEG\":\n+                if (ffmpegMjpeg == null) {\n+                    inOptions = \"-rtsp_transport tcp -hide_banner -loglevel warning\";\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegMjpeg = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, config.get(CONFIG_FFMPEG_MJPEG_ARGUMENTS).toString(),\n+                            \"http://127.0.0.1:\" + serverPort + \"/ipcamera.jpg\", username, password);\n+                }\n+                if (ffmpegMjpeg != null) {\n+                    ffmpegMjpeg.startConverting();\n+                }\n+                break;\n+            case \"SNAPSHOT\":\n+                // if mjpeg stream you can use ffmpeg -i input.h264 -codec:v copy -bsf:v mjpeg2jpeg output%03d.jpg\n+                if (ffmpegSnapshot == null) {\n+                    inOptions = \"-rtsp_transport tcp -threads 1 -skip_frame nokey -hide_banner -loglevel warning\";// iFrames\n+                                                                                                                  // only\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-threads 1 -skip_frame nokey -hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegSnapshot = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, \"-an -vsync vfr -update 1\", \"http://127.0.0.1:\" + serverPort + \"/snapshot.jpg\",\n+                            username, password);\n+                }\n+                if (ffmpegSnapshot != null) {\n+                    ffmpegSnapshot.startConverting();\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void noMotionDetected(String thisAlarmsChannel) {\n+        setChannelState(thisAlarmsChannel, OnOffType.valueOf(\"OFF\"));\n+        firstMotionAlarm = false;\n+        motionAlarmUpdateSnapshot = false;\n+        motionDetected = false;\n+        if (streamingAutoFps) {\n+            stopSnapshotPolling();\n+        } else if (updateImageEvents.contains(\"4\")) { // During Motion Alarms\n+            stopSnapshotPolling();\n+        }\n+    }\n+\n+    // Change alarms that are not counted as motion detecting.\n+    public void changeAlarmState(String thisAlarmsChannel, String state) {\n+        updateState(thisAlarmsChannel, OnOffType.valueOf(state));\n+    }\n+\n+    public void motionDetected(String thisAlarmsChannel) {\n+        updateState(CHANNEL_LAST_MOTION_TYPE, new StringType(thisAlarmsChannel));\n+        updateState(thisAlarmsChannel, OnOffType.valueOf(\"ON\"));", "originalCommit": "7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMDQxNA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479810414", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    setChannelState(thisAlarmsChannel, OnOffType.valueOf(\"OFF\"));\n          \n          \n            \n                    setChannelState(thisAlarmsChannel, OnOffType.OFF);", "author": "cpmeister", "createdAt": "2020-08-30T20:09:13Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (\"PUT\".equals(httpMethod)) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot() {\n+        lockCurrentSnapshot.lock();\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+        if (preroll > 0) {\n+            fifoSnapshotBuffer.add(currentSnapshot);\n+            if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                fifoSnapshotBuffer.removeFirst();\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    // These methods handle the response from all Camera brands, nothing specific to\n+    // any brand should be in here //\n+\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                // logger.trace(\"{}\", msg.toString());\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                            if (closeConnection) {\n+                                lock.lock();\n+                                try {\n+                                    byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                    if (indexInLists >= 0) {\n+                                        listOfChStatus.set(indexInLists, (byte) 0);\n+                                    } else {\n+                                        logger.debug(\"!!!! Could not find the ch for a Connection: close URL:{}\",\n+                                                requestUrl);\n+                                    }\n+                                } finally {\n+                                    lock.unlock();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                lockCurrentSnapshot.lock();\n+                                currentSnapshot = incomingJpeg;\n+                                lockCurrentSnapshot.unlock();\n+                                processSnapshot();\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    // logger.trace(\"Snapshot recieved: Binding will now close the channel.\");\n+                                    ctx.close();\n+                                } else {\n+                                    lock.lock();\n+                                    try {\n+                                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                        if (indexInLists >= 0) {\n+                                            listOfChStatus.set(indexInLists, (byte) 2);\n+                                        }\n+                                    } finally {\n+                                        lock.unlock();\n+                                        bytesToRecieve = 0;\n+                                        bytesAlreadyRecieved = 0;\n+                                    }\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.equals(\"\")) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // logger.debug(\"Packet back from camera is not matching HttpContent\");\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+            if (ctx == null) {\n+                return;\n+            }\n+            lock.lock();\n+            try {\n+                byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                if (indexInLists >= 0) {\n+                    // logger.debug(\"commonCameraHandler closed channel:{} \\tURL:{}\", indexInLists, requestUrl);\n+                    listOfChStatus.set(indexInLists, (byte) -1);\n+                } else {\n+                    if (listOfChannels.size() > 0) {\n+                        logger.warn(\"Can't find ch when removing handler \\t\\tURL:{}\", requestUrl);\n+                    }\n+                }\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause instanceof ArrayIndexOutOfBoundsException) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                        if (indexInLists >= 0) {\n+                            String urlToKeepOpen;\n+                            switch (thing.getThingTypeUID().getId()) {\n+                                case \"DAHUA\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"HIKVISION\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/ISAPI/Event/notification/alertStream\".contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"DOORBIRD\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/bha-api/monitor.cgi?ring=doorbell,motionsensor\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                            }\n+                            logger.debug(\"! Channel was found idle for more than 15 seconds so closing it down. !\");\n+                            listOfChStatus.set(indexInLists, (byte) 0);\n+                        } else {\n+                            logger.warn(\"!?! Channel that was found idle could not be located in our tracking. !?!\");\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.debug(\"File server for camera at {} has started on port {} for all NIC's.\", ipAddress,\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    cameraConfigError(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setupSnapshotStreaming(boolean stream, ChannelHandlerContext ctx, boolean auto) {\n+        if (stream) {\n+            sendMjpegFirstPacket(ctx);\n+            if (auto) {\n+                autoSnapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                // iOS uses a FIFO? and needs two frames to display a pic\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingAutoFps = true;\n+            } else {\n+                snapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingSnapshotMjpeg = true;\n+                startSnapshotPolling();\n+            }\n+        } else {\n+            snapshotMjpegChannelGroup.remove(ctx.channel());\n+            autoSnapshotMjpegChannelGroup.remove(ctx.channel());\n+            if (streamingSnapshotMjpeg && snapshotMjpegChannelGroup.isEmpty()) {\n+                streamingSnapshotMjpeg = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All Snapshot based MJPEG streams have stopped.\");\n+            } else if (streamingAutoFps && autoSnapshotMjpegChannelGroup.isEmpty()) {\n+                streamingAutoFps = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All AutoFps Snapshot based MJPEG streams have stopped.\");\n+            }\n+        }\n+    }\n+\n+    // If start is true the CTX is added to the list to stream video to, false stops\n+    // the stream.\n+    public void setupMjpegStreaming(boolean start, ChannelHandlerContext ctx) {\n+        if (start) {\n+            if (mjpegChannelGroup.isEmpty()) {// first stream being requested.\n+                mjpegChannelGroup.add(ctx.channel());\n+                if (mjpegUri.equals(\"\") || mjpegUri.equals(\"ffmpeg\")) {\n+                    sendMjpegFirstPacket(ctx);\n+                    setupFfmpegFormat(\"MJPEG\");\n+                } else {\n+                    try {\n+                        // fix Dahua reboots when refreshing a mjpeg stream.\n+                        TimeUnit.MILLISECONDS.sleep(500);\n+                    } catch (InterruptedException e) {\n+                    }\n+                    sendHttpGET(mjpegUri);\n+                }\n+            } else if (ffmpegMjpeg != null) {// not first stream and we will use ffmpeg\n+                sendMjpegFirstPacket(ctx);\n+                mjpegChannelGroup.add(ctx.channel());\n+            } else {// not first stream and camera supplies the mjpeg source.\n+                ctx.channel().writeAndFlush(firstStreamedMsg);\n+                mjpegChannelGroup.add(ctx.channel());\n+            }\n+        } else {\n+            mjpegChannelGroup.remove(ctx.channel());\n+            if (mjpegChannelGroup.isEmpty()) {\n+                logger.debug(\"All Mjpeg streams have stopped, cleaning up now\");\n+                if (mjpegUri.equals(\"ffmpeg\")) {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                } else if (!mjpegUri.equals(\"\")) {\n+                    closeChannel(getTinyUrl(mjpegUri));\n+                } else {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // sends direct to ctx so can be either snapshots.mjpeg or normal mjpeg stream\n+    public void sendMjpegFirstPacket(ChannelHandlerContext ctx) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        String contentType = \"multipart/x-mixed-replace; boundary=\" + BOUNDARY;\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+        ctx.channel().writeAndFlush(response);\n+    }\n+\n+    public void sendMjpegFrame(byte[] jpg, ChannelGroup channelGroup) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        ByteBuf imageByteBuf = Unpooled.copiedBuffer(jpg);\n+        int length = imageByteBuf.readableBytes();\n+        String header = \"--\" + BOUNDARY + \"\\r\\n\" + \"content-type: image/jpeg\" + \"\\r\\n\" + \"content-length: \" + length\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuf headerBbuf = Unpooled.copiedBuffer(header, 0, header.length(), StandardCharsets.UTF_8);\n+        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+        streamToGroup(headerBbuf, channelGroup, false);\n+        streamToGroup(imageByteBuf, channelGroup, false);\n+        streamToGroup(footerBbuf, channelGroup, true);\n+    }\n+\n+    public void streamToGroup(Object msg, ChannelGroup channelGroup, boolean flush) {\n+        channelGroup.write(msg);\n+        if (flush) {\n+            channelGroup.flush();\n+        }\n+    }\n+\n+    private void storeSnapshots() {\n+        int count = 0;\n+        // Need to lock as fifoSnapshotBuffer is not thread safe and new snapshots can be incoming.\n+        lockCurrentSnapshot.lock();\n+        logger.debug(\"Storing snapshots now to disk for GIF\");\n+        for (Object incomingJpeg : fifoSnapshotBuffer) {\n+            byte[] foo = (byte[]) incomingJpeg;\n+            File file = new File(ffmpegOutputFolder + \"snapshot\" + count + \".jpg\");\n+            count++;\n+            try {\n+                OutputStream fos = new FileOutputStream(file);\n+                fos.write(foo);\n+                fos.close();\n+            } catch (FileNotFoundException e) {\n+                logger.error(\"FileNotFoundException {}\", e.getMessage());\n+            } catch (IOException e) {\n+                logger.error(\"IOException {}\", e.getMessage());\n+            }\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    public void setupFfmpegFormat(String format) {\n+        String inOptions = \"\";\n+        if (ffmpegOutputFolder.equals(\"\")) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when the output folder is not set.\");\n+            return;\n+        }\n+        if (rtspUri.equals(\"\")) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when no valid input for ffmpeg is provided.\");\n+            return;\n+        }\n+        if (config.get(CONFIG_FFMPEG_LOCATION) == null) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when the location for ffmpeg is not known.\");\n+            return;\n+        }\n+\n+        // Make sure the folder exists, if not create it.\n+        new File(ffmpegOutputFolder).mkdirs();\n+        switch (format) {\n+            case \"HLS\":\n+                if (ffmpegHLS == null) {\n+                    if (rtspUri.contains(\":554\")) {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning -rtsp_transport tcp\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    } else {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    }\n+                }\n+                if (ffmpegHLS != null) {\n+                    ffmpegHLS.startConverting();\n+                }\n+                break;\n+            case \"GIF\":\n+                if (preroll > 0) {\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                            \"-y -r 1 -hide_banner -loglevel warning\", ffmpegOutputFolder + \"snapshot%d.jpg\",\n+                            \"-frames:v \" + (preroll + postroll) + \" \"\n+                                    + config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                } else {\n+                    inOptions = \"-y -t \" + postroll + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-y -t \" + postroll;\n+                    }\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                }\n+                if (preroll > 0) {\n+                    storeSnapshots();\n+                }\n+                if (ffmpegGIF != null) {\n+                    ffmpegGIF.startConverting();\n+                    if (gifHistory.equals(\"\")) {\n+                        gifHistory = gifFilename;\n+                    } else if (!gifFilename.equals(\"ipcamera\")) {\n+                        gifHistory = gifFilename + \",\" + gifHistory;\n+                        if (gifHistoryLength > 49) {\n+                            int endIndex = gifHistory.lastIndexOf(\",\");\n+                            gifHistory = gifHistory.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_GIF_HISTORY, new StringType(gifHistory));\n+                }\n+                break;\n+            case \"RECORD\":\n+                inOptions = \"-y -t \" + mp4RecordTime + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                if (!rtspUri.contains(\"rtsp\")) {\n+                    inOptions = \"-y -t \" + mp4RecordTime;\n+                }\n+                ffmpegRecord = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                        rtspUri, config.get(CONFIG_FFMPEG_MP4_OUT_ARGUMENTS).toString(),\n+                        ffmpegOutputFolder + mp4Filename + \".mp4\", username, password);\n+                if (mp4Preroll > 0) {\n+                    // fetchFromHLS(); todo: not done yet\n+                }\n+                if (ffmpegRecord != null) {\n+                    ffmpegRecord.startConverting();\n+                    if (mp4History.equals(\"\")) {\n+                        mp4History = mp4Filename;\n+                    } else if (!mp4Filename.equals(\"ipcamera\")) {\n+                        mp4History = mp4Filename + \",\" + mp4History;\n+                        if (mp4HistoryLength > 49) {\n+                            int endIndex = mp4History.lastIndexOf(\",\");\n+                            mp4History = mp4History.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_MP4_HISTORY, new StringType(mp4History));\n+                }\n+                break;\n+            case \"RTSPHELPER\":\n+                if (ffmpegRtspHelper != null) {\n+                    ffmpegRtspHelper.stopConverting();\n+                    if (!audioAlarmEnabled && !motionAlarmEnabled) {\n+                        return;\n+                    }\n+                }\n+                String input = (config.get(CONFIG_FFMPEG_MOTION_INPUT) == null) ? rtspUri\n+                        : config.get(CONFIG_FFMPEG_MOTION_INPUT).toString();\n+                String OutputOptions = \"-f null -\";\n+                String filterOptions = \"\";\n+                inOptions = \"-rtsp_transport tcp\";\n+                if (!input.contains(\"rtsp\")) {\n+                    inOptions = \"\";\n+                }\n+                if (audioAlarmEnabled == false) {\n+                    filterOptions = \"-an\";\n+                } else if (audioAlarmEnabled == true) {\n+                    filterOptions = \"-af silencedetect=n=-\" + audioThreshold + \"dB:d=2\";\n+                }\n+                if (motionAlarmEnabled == false && ffmpegSnapshotGeneration == false) {\n+                    filterOptions = filterOptions.concat(\" -vn\");\n+                } else if (motionAlarmEnabled == true) {\n+                    filterOptions = filterOptions\n+                            .concat(\" -vf select='gte(scene,\" + motionThreshold + \")',metadata=print\");\n+                }\n+                if (config.get(CONFIG_USERNAME) != null) {\n+                    filterOptions += \" \";// add space as the Framework does not allow spaces at start of config.\n+                }\n+                ffmpegRtspHelper = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                        input, filterOptions + config.get(CONFIG_FFMPEG_MOTION_ARGUMENTS), OutputOptions, username,\n+                        password);\n+                ffmpegRtspHelper.startConverting();\n+                break;\n+            case \"MJPEG\":\n+                if (ffmpegMjpeg == null) {\n+                    inOptions = \"-rtsp_transport tcp -hide_banner -loglevel warning\";\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegMjpeg = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, config.get(CONFIG_FFMPEG_MJPEG_ARGUMENTS).toString(),\n+                            \"http://127.0.0.1:\" + serverPort + \"/ipcamera.jpg\", username, password);\n+                }\n+                if (ffmpegMjpeg != null) {\n+                    ffmpegMjpeg.startConverting();\n+                }\n+                break;\n+            case \"SNAPSHOT\":\n+                // if mjpeg stream you can use ffmpeg -i input.h264 -codec:v copy -bsf:v mjpeg2jpeg output%03d.jpg\n+                if (ffmpegSnapshot == null) {\n+                    inOptions = \"-rtsp_transport tcp -threads 1 -skip_frame nokey -hide_banner -loglevel warning\";// iFrames\n+                                                                                                                  // only\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-threads 1 -skip_frame nokey -hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegSnapshot = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, \"-an -vsync vfr -update 1\", \"http://127.0.0.1:\" + serverPort + \"/snapshot.jpg\",\n+                            username, password);\n+                }\n+                if (ffmpegSnapshot != null) {\n+                    ffmpegSnapshot.startConverting();\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void noMotionDetected(String thisAlarmsChannel) {\n+        setChannelState(thisAlarmsChannel, OnOffType.valueOf(\"OFF\"));", "originalCommit": "7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMDg4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479810885", "bodyText": "Can you add comments or javadoc for this method so we know what this method should be doing. It is difficult to tell if this code below is correct if you don't know what it should be doing.", "author": "cpmeister", "createdAt": "2020-08-30T20:13:58Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (\"PUT\".equals(httpMethod)) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot() {\n+        lockCurrentSnapshot.lock();\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+        if (preroll > 0) {\n+            fifoSnapshotBuffer.add(currentSnapshot);\n+            if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                fifoSnapshotBuffer.removeFirst();\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    // These methods handle the response from all Camera brands, nothing specific to\n+    // any brand should be in here //\n+\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                // logger.trace(\"{}\", msg.toString());\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                            if (closeConnection) {\n+                                lock.lock();\n+                                try {\n+                                    byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                    if (indexInLists >= 0) {\n+                                        listOfChStatus.set(indexInLists, (byte) 0);\n+                                    } else {\n+                                        logger.debug(\"!!!! Could not find the ch for a Connection: close URL:{}\",\n+                                                requestUrl);\n+                                    }\n+                                } finally {\n+                                    lock.unlock();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                lockCurrentSnapshot.lock();\n+                                currentSnapshot = incomingJpeg;\n+                                lockCurrentSnapshot.unlock();\n+                                processSnapshot();\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    // logger.trace(\"Snapshot recieved: Binding will now close the channel.\");\n+                                    ctx.close();\n+                                } else {\n+                                    lock.lock();\n+                                    try {\n+                                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                        if (indexInLists >= 0) {\n+                                            listOfChStatus.set(indexInLists, (byte) 2);\n+                                        }\n+                                    } finally {\n+                                        lock.unlock();\n+                                        bytesToRecieve = 0;\n+                                        bytesAlreadyRecieved = 0;\n+                                    }\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.equals(\"\")) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // logger.debug(\"Packet back from camera is not matching HttpContent\");\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+            if (ctx == null) {\n+                return;\n+            }\n+            lock.lock();\n+            try {\n+                byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                if (indexInLists >= 0) {\n+                    // logger.debug(\"commonCameraHandler closed channel:{} \\tURL:{}\", indexInLists, requestUrl);\n+                    listOfChStatus.set(indexInLists, (byte) -1);\n+                } else {\n+                    if (listOfChannels.size() > 0) {\n+                        logger.warn(\"Can't find ch when removing handler \\t\\tURL:{}\", requestUrl);\n+                    }\n+                }\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause instanceof ArrayIndexOutOfBoundsException) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                        if (indexInLists >= 0) {\n+                            String urlToKeepOpen;\n+                            switch (thing.getThingTypeUID().getId()) {\n+                                case \"DAHUA\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"HIKVISION\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/ISAPI/Event/notification/alertStream\".contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"DOORBIRD\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/bha-api/monitor.cgi?ring=doorbell,motionsensor\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                            }\n+                            logger.debug(\"! Channel was found idle for more than 15 seconds so closing it down. !\");\n+                            listOfChStatus.set(indexInLists, (byte) 0);\n+                        } else {\n+                            logger.warn(\"!?! Channel that was found idle could not be located in our tracking. !?!\");\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.debug(\"File server for camera at {} has started on port {} for all NIC's.\", ipAddress,\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    cameraConfigError(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setupSnapshotStreaming(boolean stream, ChannelHandlerContext ctx, boolean auto) {\n+        if (stream) {\n+            sendMjpegFirstPacket(ctx);\n+            if (auto) {\n+                autoSnapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                // iOS uses a FIFO? and needs two frames to display a pic\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingAutoFps = true;\n+            } else {\n+                snapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingSnapshotMjpeg = true;\n+                startSnapshotPolling();\n+            }\n+        } else {\n+            snapshotMjpegChannelGroup.remove(ctx.channel());\n+            autoSnapshotMjpegChannelGroup.remove(ctx.channel());\n+            if (streamingSnapshotMjpeg && snapshotMjpegChannelGroup.isEmpty()) {\n+                streamingSnapshotMjpeg = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All Snapshot based MJPEG streams have stopped.\");\n+            } else if (streamingAutoFps && autoSnapshotMjpegChannelGroup.isEmpty()) {\n+                streamingAutoFps = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All AutoFps Snapshot based MJPEG streams have stopped.\");\n+            }\n+        }\n+    }\n+\n+    // If start is true the CTX is added to the list to stream video to, false stops\n+    // the stream.\n+    public void setupMjpegStreaming(boolean start, ChannelHandlerContext ctx) {\n+        if (start) {\n+            if (mjpegChannelGroup.isEmpty()) {// first stream being requested.\n+                mjpegChannelGroup.add(ctx.channel());\n+                if (mjpegUri.equals(\"\") || mjpegUri.equals(\"ffmpeg\")) {\n+                    sendMjpegFirstPacket(ctx);\n+                    setupFfmpegFormat(\"MJPEG\");\n+                } else {\n+                    try {\n+                        // fix Dahua reboots when refreshing a mjpeg stream.\n+                        TimeUnit.MILLISECONDS.sleep(500);\n+                    } catch (InterruptedException e) {\n+                    }\n+                    sendHttpGET(mjpegUri);\n+                }\n+            } else if (ffmpegMjpeg != null) {// not first stream and we will use ffmpeg\n+                sendMjpegFirstPacket(ctx);\n+                mjpegChannelGroup.add(ctx.channel());\n+            } else {// not first stream and camera supplies the mjpeg source.\n+                ctx.channel().writeAndFlush(firstStreamedMsg);\n+                mjpegChannelGroup.add(ctx.channel());\n+            }\n+        } else {\n+            mjpegChannelGroup.remove(ctx.channel());\n+            if (mjpegChannelGroup.isEmpty()) {\n+                logger.debug(\"All Mjpeg streams have stopped, cleaning up now\");\n+                if (mjpegUri.equals(\"ffmpeg\")) {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                } else if (!mjpegUri.equals(\"\")) {\n+                    closeChannel(getTinyUrl(mjpegUri));\n+                } else {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // sends direct to ctx so can be either snapshots.mjpeg or normal mjpeg stream\n+    public void sendMjpegFirstPacket(ChannelHandlerContext ctx) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        String contentType = \"multipart/x-mixed-replace; boundary=\" + BOUNDARY;\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+        ctx.channel().writeAndFlush(response);\n+    }\n+\n+    public void sendMjpegFrame(byte[] jpg, ChannelGroup channelGroup) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        ByteBuf imageByteBuf = Unpooled.copiedBuffer(jpg);\n+        int length = imageByteBuf.readableBytes();\n+        String header = \"--\" + BOUNDARY + \"\\r\\n\" + \"content-type: image/jpeg\" + \"\\r\\n\" + \"content-length: \" + length\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuf headerBbuf = Unpooled.copiedBuffer(header, 0, header.length(), StandardCharsets.UTF_8);\n+        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+        streamToGroup(headerBbuf, channelGroup, false);\n+        streamToGroup(imageByteBuf, channelGroup, false);\n+        streamToGroup(footerBbuf, channelGroup, true);\n+    }\n+\n+    public void streamToGroup(Object msg, ChannelGroup channelGroup, boolean flush) {\n+        channelGroup.write(msg);\n+        if (flush) {\n+            channelGroup.flush();\n+        }\n+    }\n+\n+    private void storeSnapshots() {\n+        int count = 0;\n+        // Need to lock as fifoSnapshotBuffer is not thread safe and new snapshots can be incoming.\n+        lockCurrentSnapshot.lock();\n+        logger.debug(\"Storing snapshots now to disk for GIF\");\n+        for (Object incomingJpeg : fifoSnapshotBuffer) {\n+            byte[] foo = (byte[]) incomingJpeg;\n+            File file = new File(ffmpegOutputFolder + \"snapshot\" + count + \".jpg\");\n+            count++;\n+            try {\n+                OutputStream fos = new FileOutputStream(file);\n+                fos.write(foo);\n+                fos.close();\n+            } catch (FileNotFoundException e) {\n+                logger.error(\"FileNotFoundException {}\", e.getMessage());\n+            } catch (IOException e) {\n+                logger.error(\"IOException {}\", e.getMessage());\n+            }\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    public void setupFfmpegFormat(String format) {\n+        String inOptions = \"\";\n+        if (ffmpegOutputFolder.equals(\"\")) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when the output folder is not set.\");\n+            return;\n+        }\n+        if (rtspUri.equals(\"\")) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when no valid input for ffmpeg is provided.\");\n+            return;\n+        }\n+        if (config.get(CONFIG_FFMPEG_LOCATION) == null) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when the location for ffmpeg is not known.\");\n+            return;\n+        }\n+\n+        // Make sure the folder exists, if not create it.\n+        new File(ffmpegOutputFolder).mkdirs();\n+        switch (format) {\n+            case \"HLS\":\n+                if (ffmpegHLS == null) {\n+                    if (rtspUri.contains(\":554\")) {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning -rtsp_transport tcp\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    } else {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    }\n+                }\n+                if (ffmpegHLS != null) {\n+                    ffmpegHLS.startConverting();\n+                }\n+                break;\n+            case \"GIF\":\n+                if (preroll > 0) {\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                            \"-y -r 1 -hide_banner -loglevel warning\", ffmpegOutputFolder + \"snapshot%d.jpg\",\n+                            \"-frames:v \" + (preroll + postroll) + \" \"\n+                                    + config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                } else {\n+                    inOptions = \"-y -t \" + postroll + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-y -t \" + postroll;\n+                    }\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                }\n+                if (preroll > 0) {\n+                    storeSnapshots();\n+                }\n+                if (ffmpegGIF != null) {\n+                    ffmpegGIF.startConverting();\n+                    if (gifHistory.equals(\"\")) {\n+                        gifHistory = gifFilename;\n+                    } else if (!gifFilename.equals(\"ipcamera\")) {\n+                        gifHistory = gifFilename + \",\" + gifHistory;\n+                        if (gifHistoryLength > 49) {\n+                            int endIndex = gifHistory.lastIndexOf(\",\");\n+                            gifHistory = gifHistory.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_GIF_HISTORY, new StringType(gifHistory));\n+                }\n+                break;\n+            case \"RECORD\":\n+                inOptions = \"-y -t \" + mp4RecordTime + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                if (!rtspUri.contains(\"rtsp\")) {\n+                    inOptions = \"-y -t \" + mp4RecordTime;\n+                }\n+                ffmpegRecord = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                        rtspUri, config.get(CONFIG_FFMPEG_MP4_OUT_ARGUMENTS).toString(),\n+                        ffmpegOutputFolder + mp4Filename + \".mp4\", username, password);\n+                if (mp4Preroll > 0) {\n+                    // fetchFromHLS(); todo: not done yet\n+                }\n+                if (ffmpegRecord != null) {\n+                    ffmpegRecord.startConverting();\n+                    if (mp4History.equals(\"\")) {\n+                        mp4History = mp4Filename;\n+                    } else if (!mp4Filename.equals(\"ipcamera\")) {\n+                        mp4History = mp4Filename + \",\" + mp4History;\n+                        if (mp4HistoryLength > 49) {\n+                            int endIndex = mp4History.lastIndexOf(\",\");\n+                            mp4History = mp4History.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_MP4_HISTORY, new StringType(mp4History));\n+                }\n+                break;\n+            case \"RTSPHELPER\":\n+                if (ffmpegRtspHelper != null) {\n+                    ffmpegRtspHelper.stopConverting();\n+                    if (!audioAlarmEnabled && !motionAlarmEnabled) {\n+                        return;\n+                    }\n+                }\n+                String input = (config.get(CONFIG_FFMPEG_MOTION_INPUT) == null) ? rtspUri\n+                        : config.get(CONFIG_FFMPEG_MOTION_INPUT).toString();\n+                String OutputOptions = \"-f null -\";\n+                String filterOptions = \"\";\n+                inOptions = \"-rtsp_transport tcp\";\n+                if (!input.contains(\"rtsp\")) {\n+                    inOptions = \"\";\n+                }\n+                if (audioAlarmEnabled == false) {\n+                    filterOptions = \"-an\";\n+                } else if (audioAlarmEnabled == true) {\n+                    filterOptions = \"-af silencedetect=n=-\" + audioThreshold + \"dB:d=2\";\n+                }\n+                if (motionAlarmEnabled == false && ffmpegSnapshotGeneration == false) {\n+                    filterOptions = filterOptions.concat(\" -vn\");\n+                } else if (motionAlarmEnabled == true) {\n+                    filterOptions = filterOptions\n+                            .concat(\" -vf select='gte(scene,\" + motionThreshold + \")',metadata=print\");\n+                }\n+                if (config.get(CONFIG_USERNAME) != null) {\n+                    filterOptions += \" \";// add space as the Framework does not allow spaces at start of config.\n+                }\n+                ffmpegRtspHelper = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                        input, filterOptions + config.get(CONFIG_FFMPEG_MOTION_ARGUMENTS), OutputOptions, username,\n+                        password);\n+                ffmpegRtspHelper.startConverting();\n+                break;\n+            case \"MJPEG\":\n+                if (ffmpegMjpeg == null) {\n+                    inOptions = \"-rtsp_transport tcp -hide_banner -loglevel warning\";\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegMjpeg = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, config.get(CONFIG_FFMPEG_MJPEG_ARGUMENTS).toString(),\n+                            \"http://127.0.0.1:\" + serverPort + \"/ipcamera.jpg\", username, password);\n+                }\n+                if (ffmpegMjpeg != null) {\n+                    ffmpegMjpeg.startConverting();\n+                }\n+                break;\n+            case \"SNAPSHOT\":\n+                // if mjpeg stream you can use ffmpeg -i input.h264 -codec:v copy -bsf:v mjpeg2jpeg output%03d.jpg\n+                if (ffmpegSnapshot == null) {\n+                    inOptions = \"-rtsp_transport tcp -threads 1 -skip_frame nokey -hide_banner -loglevel warning\";// iFrames\n+                                                                                                                  // only\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-threads 1 -skip_frame nokey -hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegSnapshot = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, \"-an -vsync vfr -update 1\", \"http://127.0.0.1:\" + serverPort + \"/snapshot.jpg\",\n+                            username, password);\n+                }\n+                if (ffmpegSnapshot != null) {\n+                    ffmpegSnapshot.startConverting();\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void noMotionDetected(String thisAlarmsChannel) {\n+        setChannelState(thisAlarmsChannel, OnOffType.valueOf(\"OFF\"));\n+        firstMotionAlarm = false;\n+        motionAlarmUpdateSnapshot = false;\n+        motionDetected = false;\n+        if (streamingAutoFps) {\n+            stopSnapshotPolling();\n+        } else if (updateImageEvents.contains(\"4\")) { // During Motion Alarms\n+            stopSnapshotPolling();\n+        }\n+    }\n+\n+    // Change alarms that are not counted as motion detecting.\n+    public void changeAlarmState(String thisAlarmsChannel, String state) {\n+        updateState(thisAlarmsChannel, OnOffType.valueOf(state));\n+    }\n+\n+    public void motionDetected(String thisAlarmsChannel) {\n+        updateState(CHANNEL_LAST_MOTION_TYPE, new StringType(thisAlarmsChannel));\n+        updateState(thisAlarmsChannel, OnOffType.valueOf(\"ON\"));\n+        motionDetected = true;\n+        if (streamingAutoFps) {\n+            startSnapshotPolling();\n+        }\n+        if (updateImageEvents.contains(\"2\")) {\n+            if (!firstMotionAlarm) {\n+                if (!snapshotUri.isEmpty()) {\n+                    sendHttpGET(snapshotUri);\n+                }\n+                firstMotionAlarm = true;// reset back to false when the jpg arrives.\n+            }\n+        } else if (updateImageEvents.contains(\"4\")) { // During Motion Alarms\n+            if (!snapshotPolling) {\n+                startSnapshotPolling();\n+            }\n+            firstMotionAlarm = true;\n+            motionAlarmUpdateSnapshot = true;\n+        }\n+    }\n+\n+    public void audioDetected() {\n+        updateState(CHANNEL_AUDIO_ALARM, OnOffType.valueOf(\"ON\"));\n+        if (updateImageEvents.contains(\"3\")) {\n+            if (!firstAudioAlarm) {\n+                if (!snapshotUri.isEmpty()) {\n+                    sendHttpGET(snapshotUri);\n+                }\n+                firstAudioAlarm = true;// reset back to false when the jpg arrives.\n+            }\n+        } else if (updateImageEvents.contains(\"5\")) {// During audio alarms\n+            firstAudioAlarm = true;\n+            audioAlarmUpdateSnapshot = true;\n+        }\n+    }\n+\n+    public void noAudioDetected() {\n+        setChannelState(CHANNEL_AUDIO_ALARM, OnOffType.valueOf(\"OFF\"));\n+        firstAudioAlarm = false;\n+        audioAlarmUpdateSnapshot = false;\n+    }\n+\n+    public String returnValueFromString(String rawString, String searchedString) {\n+        String result = \"\";\n+        int index = rawString.indexOf(searchedString);\n+        if (index != -1) // -1 means \"not found\"\n+        {\n+            result = rawString.substring(index + searchedString.length(), rawString.length());\n+            index = result.indexOf(\"\\r\\n\"); // find a carriage return to find the end of the value.\n+            if (index == -1) {\n+                return result; // Did not find a carriage return.\n+            } else {\n+                return result.substring(0, index);\n+            }\n+        }\n+        return \"\"; // Did not find the String we were searching for\n+    }\n+\n+    public String searchString(String rawString, String searchedString) {", "originalCommit": "7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkxMzcwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479913707", "bodyText": "DONE: Added javdoc and moved the function to the only class that used it and made it private.", "author": "Skinah", "createdAt": "2020-08-31T06:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMDg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMTI3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479811273", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (index == -1) {\n          \n          \n            \n                            index = result.indexOf('\"');\n          \n          \n            \n                            if (index == -1) {\n          \n          \n            \n                                index = result.indexOf('}');\n          \n          \n            \n                                if (index == -1) {\n          \n          \n            \n                                    return result;\n          \n          \n            \n                                } else {\n          \n          \n            \n                                    return result.substring(0, index);\n          \n          \n            \n                                }\n          \n          \n            \n                            } else {\n          \n          \n            \n                                return result.substring(0, index);\n          \n          \n            \n                            }\n          \n          \n            \n                        } else {\n          \n          \n            \n                            result = result.substring(0, index);\n          \n          \n            \n                            index = result.indexOf('\"');\n          \n          \n            \n                            if (index == -1) {\n          \n          \n            \n                                return result;\n          \n          \n            \n                            } else {\n          \n          \n            \n                                return result.substring(0, index);\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                        if (index == -1) {\n          \n          \n            \n                            index = result.indexOf('\"');\n          \n          \n            \n                            if (index == -1) {\n          \n          \n            \n                                index = result.indexOf('}');\n          \n          \n            \n                            }\n          \n          \n            \n                        } else {\n          \n          \n            \n                            result = result.substring(0, index);\n          \n          \n            \n                            index = result.indexOf('\"');\n          \n          \n            \n                        }\n          \n          \n            \n                        if (index == -1) {\n          \n          \n            \n                            return result;\n          \n          \n            \n                        } else {\n          \n          \n            \n                            return result.substring(0, index);\n          \n          \n            \n                        }", "author": "cpmeister", "createdAt": "2020-08-30T20:18:22Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (\"PUT\".equals(httpMethod)) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot() {\n+        lockCurrentSnapshot.lock();\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+        if (preroll > 0) {\n+            fifoSnapshotBuffer.add(currentSnapshot);\n+            if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                fifoSnapshotBuffer.removeFirst();\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    // These methods handle the response from all Camera brands, nothing specific to\n+    // any brand should be in here //\n+\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                // logger.trace(\"{}\", msg.toString());\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                            if (closeConnection) {\n+                                lock.lock();\n+                                try {\n+                                    byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                    if (indexInLists >= 0) {\n+                                        listOfChStatus.set(indexInLists, (byte) 0);\n+                                    } else {\n+                                        logger.debug(\"!!!! Could not find the ch for a Connection: close URL:{}\",\n+                                                requestUrl);\n+                                    }\n+                                } finally {\n+                                    lock.unlock();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                lockCurrentSnapshot.lock();\n+                                currentSnapshot = incomingJpeg;\n+                                lockCurrentSnapshot.unlock();\n+                                processSnapshot();\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    // logger.trace(\"Snapshot recieved: Binding will now close the channel.\");\n+                                    ctx.close();\n+                                } else {\n+                                    lock.lock();\n+                                    try {\n+                                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                        if (indexInLists >= 0) {\n+                                            listOfChStatus.set(indexInLists, (byte) 2);\n+                                        }\n+                                    } finally {\n+                                        lock.unlock();\n+                                        bytesToRecieve = 0;\n+                                        bytesAlreadyRecieved = 0;\n+                                    }\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.equals(\"\")) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // logger.debug(\"Packet back from camera is not matching HttpContent\");\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+            if (ctx == null) {\n+                return;\n+            }\n+            lock.lock();\n+            try {\n+                byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                if (indexInLists >= 0) {\n+                    // logger.debug(\"commonCameraHandler closed channel:{} \\tURL:{}\", indexInLists, requestUrl);\n+                    listOfChStatus.set(indexInLists, (byte) -1);\n+                } else {\n+                    if (listOfChannels.size() > 0) {\n+                        logger.warn(\"Can't find ch when removing handler \\t\\tURL:{}\", requestUrl);\n+                    }\n+                }\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause instanceof ArrayIndexOutOfBoundsException) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                        if (indexInLists >= 0) {\n+                            String urlToKeepOpen;\n+                            switch (thing.getThingTypeUID().getId()) {\n+                                case \"DAHUA\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"HIKVISION\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/ISAPI/Event/notification/alertStream\".contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"DOORBIRD\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/bha-api/monitor.cgi?ring=doorbell,motionsensor\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                            }\n+                            logger.debug(\"! Channel was found idle for more than 15 seconds so closing it down. !\");\n+                            listOfChStatus.set(indexInLists, (byte) 0);\n+                        } else {\n+                            logger.warn(\"!?! Channel that was found idle could not be located in our tracking. !?!\");\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.debug(\"File server for camera at {} has started on port {} for all NIC's.\", ipAddress,\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    cameraConfigError(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setupSnapshotStreaming(boolean stream, ChannelHandlerContext ctx, boolean auto) {\n+        if (stream) {\n+            sendMjpegFirstPacket(ctx);\n+            if (auto) {\n+                autoSnapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                // iOS uses a FIFO? and needs two frames to display a pic\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingAutoFps = true;\n+            } else {\n+                snapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingSnapshotMjpeg = true;\n+                startSnapshotPolling();\n+            }\n+        } else {\n+            snapshotMjpegChannelGroup.remove(ctx.channel());\n+            autoSnapshotMjpegChannelGroup.remove(ctx.channel());\n+            if (streamingSnapshotMjpeg && snapshotMjpegChannelGroup.isEmpty()) {\n+                streamingSnapshotMjpeg = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All Snapshot based MJPEG streams have stopped.\");\n+            } else if (streamingAutoFps && autoSnapshotMjpegChannelGroup.isEmpty()) {\n+                streamingAutoFps = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All AutoFps Snapshot based MJPEG streams have stopped.\");\n+            }\n+        }\n+    }\n+\n+    // If start is true the CTX is added to the list to stream video to, false stops\n+    // the stream.\n+    public void setupMjpegStreaming(boolean start, ChannelHandlerContext ctx) {\n+        if (start) {\n+            if (mjpegChannelGroup.isEmpty()) {// first stream being requested.\n+                mjpegChannelGroup.add(ctx.channel());\n+                if (mjpegUri.equals(\"\") || mjpegUri.equals(\"ffmpeg\")) {\n+                    sendMjpegFirstPacket(ctx);\n+                    setupFfmpegFormat(\"MJPEG\");\n+                } else {\n+                    try {\n+                        // fix Dahua reboots when refreshing a mjpeg stream.\n+                        TimeUnit.MILLISECONDS.sleep(500);\n+                    } catch (InterruptedException e) {\n+                    }\n+                    sendHttpGET(mjpegUri);\n+                }\n+            } else if (ffmpegMjpeg != null) {// not first stream and we will use ffmpeg\n+                sendMjpegFirstPacket(ctx);\n+                mjpegChannelGroup.add(ctx.channel());\n+            } else {// not first stream and camera supplies the mjpeg source.\n+                ctx.channel().writeAndFlush(firstStreamedMsg);\n+                mjpegChannelGroup.add(ctx.channel());\n+            }\n+        } else {\n+            mjpegChannelGroup.remove(ctx.channel());\n+            if (mjpegChannelGroup.isEmpty()) {\n+                logger.debug(\"All Mjpeg streams have stopped, cleaning up now\");\n+                if (mjpegUri.equals(\"ffmpeg\")) {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                } else if (!mjpegUri.equals(\"\")) {\n+                    closeChannel(getTinyUrl(mjpegUri));\n+                } else {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // sends direct to ctx so can be either snapshots.mjpeg or normal mjpeg stream\n+    public void sendMjpegFirstPacket(ChannelHandlerContext ctx) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        String contentType = \"multipart/x-mixed-replace; boundary=\" + BOUNDARY;\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+        ctx.channel().writeAndFlush(response);\n+    }\n+\n+    public void sendMjpegFrame(byte[] jpg, ChannelGroup channelGroup) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        ByteBuf imageByteBuf = Unpooled.copiedBuffer(jpg);\n+        int length = imageByteBuf.readableBytes();\n+        String header = \"--\" + BOUNDARY + \"\\r\\n\" + \"content-type: image/jpeg\" + \"\\r\\n\" + \"content-length: \" + length\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuf headerBbuf = Unpooled.copiedBuffer(header, 0, header.length(), StandardCharsets.UTF_8);\n+        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+        streamToGroup(headerBbuf, channelGroup, false);\n+        streamToGroup(imageByteBuf, channelGroup, false);\n+        streamToGroup(footerBbuf, channelGroup, true);\n+    }\n+\n+    public void streamToGroup(Object msg, ChannelGroup channelGroup, boolean flush) {\n+        channelGroup.write(msg);\n+        if (flush) {\n+            channelGroup.flush();\n+        }\n+    }\n+\n+    private void storeSnapshots() {\n+        int count = 0;\n+        // Need to lock as fifoSnapshotBuffer is not thread safe and new snapshots can be incoming.\n+        lockCurrentSnapshot.lock();\n+        logger.debug(\"Storing snapshots now to disk for GIF\");\n+        for (Object incomingJpeg : fifoSnapshotBuffer) {\n+            byte[] foo = (byte[]) incomingJpeg;\n+            File file = new File(ffmpegOutputFolder + \"snapshot\" + count + \".jpg\");\n+            count++;\n+            try {\n+                OutputStream fos = new FileOutputStream(file);\n+                fos.write(foo);\n+                fos.close();\n+            } catch (FileNotFoundException e) {\n+                logger.error(\"FileNotFoundException {}\", e.getMessage());\n+            } catch (IOException e) {\n+                logger.error(\"IOException {}\", e.getMessage());\n+            }\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    public void setupFfmpegFormat(String format) {\n+        String inOptions = \"\";\n+        if (ffmpegOutputFolder.equals(\"\")) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when the output folder is not set.\");\n+            return;\n+        }\n+        if (rtspUri.equals(\"\")) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when no valid input for ffmpeg is provided.\");\n+            return;\n+        }\n+        if (config.get(CONFIG_FFMPEG_LOCATION) == null) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when the location for ffmpeg is not known.\");\n+            return;\n+        }\n+\n+        // Make sure the folder exists, if not create it.\n+        new File(ffmpegOutputFolder).mkdirs();\n+        switch (format) {\n+            case \"HLS\":\n+                if (ffmpegHLS == null) {\n+                    if (rtspUri.contains(\":554\")) {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning -rtsp_transport tcp\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    } else {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    }\n+                }\n+                if (ffmpegHLS != null) {\n+                    ffmpegHLS.startConverting();\n+                }\n+                break;\n+            case \"GIF\":\n+                if (preroll > 0) {\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                            \"-y -r 1 -hide_banner -loglevel warning\", ffmpegOutputFolder + \"snapshot%d.jpg\",\n+                            \"-frames:v \" + (preroll + postroll) + \" \"\n+                                    + config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                } else {\n+                    inOptions = \"-y -t \" + postroll + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-y -t \" + postroll;\n+                    }\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                }\n+                if (preroll > 0) {\n+                    storeSnapshots();\n+                }\n+                if (ffmpegGIF != null) {\n+                    ffmpegGIF.startConverting();\n+                    if (gifHistory.equals(\"\")) {\n+                        gifHistory = gifFilename;\n+                    } else if (!gifFilename.equals(\"ipcamera\")) {\n+                        gifHistory = gifFilename + \",\" + gifHistory;\n+                        if (gifHistoryLength > 49) {\n+                            int endIndex = gifHistory.lastIndexOf(\",\");\n+                            gifHistory = gifHistory.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_GIF_HISTORY, new StringType(gifHistory));\n+                }\n+                break;\n+            case \"RECORD\":\n+                inOptions = \"-y -t \" + mp4RecordTime + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                if (!rtspUri.contains(\"rtsp\")) {\n+                    inOptions = \"-y -t \" + mp4RecordTime;\n+                }\n+                ffmpegRecord = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                        rtspUri, config.get(CONFIG_FFMPEG_MP4_OUT_ARGUMENTS).toString(),\n+                        ffmpegOutputFolder + mp4Filename + \".mp4\", username, password);\n+                if (mp4Preroll > 0) {\n+                    // fetchFromHLS(); todo: not done yet\n+                }\n+                if (ffmpegRecord != null) {\n+                    ffmpegRecord.startConverting();\n+                    if (mp4History.equals(\"\")) {\n+                        mp4History = mp4Filename;\n+                    } else if (!mp4Filename.equals(\"ipcamera\")) {\n+                        mp4History = mp4Filename + \",\" + mp4History;\n+                        if (mp4HistoryLength > 49) {\n+                            int endIndex = mp4History.lastIndexOf(\",\");\n+                            mp4History = mp4History.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_MP4_HISTORY, new StringType(mp4History));\n+                }\n+                break;\n+            case \"RTSPHELPER\":\n+                if (ffmpegRtspHelper != null) {\n+                    ffmpegRtspHelper.stopConverting();\n+                    if (!audioAlarmEnabled && !motionAlarmEnabled) {\n+                        return;\n+                    }\n+                }\n+                String input = (config.get(CONFIG_FFMPEG_MOTION_INPUT) == null) ? rtspUri\n+                        : config.get(CONFIG_FFMPEG_MOTION_INPUT).toString();\n+                String OutputOptions = \"-f null -\";\n+                String filterOptions = \"\";\n+                inOptions = \"-rtsp_transport tcp\";\n+                if (!input.contains(\"rtsp\")) {\n+                    inOptions = \"\";\n+                }\n+                if (audioAlarmEnabled == false) {\n+                    filterOptions = \"-an\";\n+                } else if (audioAlarmEnabled == true) {\n+                    filterOptions = \"-af silencedetect=n=-\" + audioThreshold + \"dB:d=2\";\n+                }\n+                if (motionAlarmEnabled == false && ffmpegSnapshotGeneration == false) {\n+                    filterOptions = filterOptions.concat(\" -vn\");\n+                } else if (motionAlarmEnabled == true) {\n+                    filterOptions = filterOptions\n+                            .concat(\" -vf select='gte(scene,\" + motionThreshold + \")',metadata=print\");\n+                }\n+                if (config.get(CONFIG_USERNAME) != null) {\n+                    filterOptions += \" \";// add space as the Framework does not allow spaces at start of config.\n+                }\n+                ffmpegRtspHelper = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                        input, filterOptions + config.get(CONFIG_FFMPEG_MOTION_ARGUMENTS), OutputOptions, username,\n+                        password);\n+                ffmpegRtspHelper.startConverting();\n+                break;\n+            case \"MJPEG\":\n+                if (ffmpegMjpeg == null) {\n+                    inOptions = \"-rtsp_transport tcp -hide_banner -loglevel warning\";\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegMjpeg = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, config.get(CONFIG_FFMPEG_MJPEG_ARGUMENTS).toString(),\n+                            \"http://127.0.0.1:\" + serverPort + \"/ipcamera.jpg\", username, password);\n+                }\n+                if (ffmpegMjpeg != null) {\n+                    ffmpegMjpeg.startConverting();\n+                }\n+                break;\n+            case \"SNAPSHOT\":\n+                // if mjpeg stream you can use ffmpeg -i input.h264 -codec:v copy -bsf:v mjpeg2jpeg output%03d.jpg\n+                if (ffmpegSnapshot == null) {\n+                    inOptions = \"-rtsp_transport tcp -threads 1 -skip_frame nokey -hide_banner -loglevel warning\";// iFrames\n+                                                                                                                  // only\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-threads 1 -skip_frame nokey -hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegSnapshot = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, \"-an -vsync vfr -update 1\", \"http://127.0.0.1:\" + serverPort + \"/snapshot.jpg\",\n+                            username, password);\n+                }\n+                if (ffmpegSnapshot != null) {\n+                    ffmpegSnapshot.startConverting();\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void noMotionDetected(String thisAlarmsChannel) {\n+        setChannelState(thisAlarmsChannel, OnOffType.valueOf(\"OFF\"));\n+        firstMotionAlarm = false;\n+        motionAlarmUpdateSnapshot = false;\n+        motionDetected = false;\n+        if (streamingAutoFps) {\n+            stopSnapshotPolling();\n+        } else if (updateImageEvents.contains(\"4\")) { // During Motion Alarms\n+            stopSnapshotPolling();\n+        }\n+    }\n+\n+    // Change alarms that are not counted as motion detecting.\n+    public void changeAlarmState(String thisAlarmsChannel, String state) {\n+        updateState(thisAlarmsChannel, OnOffType.valueOf(state));\n+    }\n+\n+    public void motionDetected(String thisAlarmsChannel) {\n+        updateState(CHANNEL_LAST_MOTION_TYPE, new StringType(thisAlarmsChannel));\n+        updateState(thisAlarmsChannel, OnOffType.valueOf(\"ON\"));\n+        motionDetected = true;\n+        if (streamingAutoFps) {\n+            startSnapshotPolling();\n+        }\n+        if (updateImageEvents.contains(\"2\")) {\n+            if (!firstMotionAlarm) {\n+                if (!snapshotUri.isEmpty()) {\n+                    sendHttpGET(snapshotUri);\n+                }\n+                firstMotionAlarm = true;// reset back to false when the jpg arrives.\n+            }\n+        } else if (updateImageEvents.contains(\"4\")) { // During Motion Alarms\n+            if (!snapshotPolling) {\n+                startSnapshotPolling();\n+            }\n+            firstMotionAlarm = true;\n+            motionAlarmUpdateSnapshot = true;\n+        }\n+    }\n+\n+    public void audioDetected() {\n+        updateState(CHANNEL_AUDIO_ALARM, OnOffType.valueOf(\"ON\"));\n+        if (updateImageEvents.contains(\"3\")) {\n+            if (!firstAudioAlarm) {\n+                if (!snapshotUri.isEmpty()) {\n+                    sendHttpGET(snapshotUri);\n+                }\n+                firstAudioAlarm = true;// reset back to false when the jpg arrives.\n+            }\n+        } else if (updateImageEvents.contains(\"5\")) {// During audio alarms\n+            firstAudioAlarm = true;\n+            audioAlarmUpdateSnapshot = true;\n+        }\n+    }\n+\n+    public void noAudioDetected() {\n+        setChannelState(CHANNEL_AUDIO_ALARM, OnOffType.valueOf(\"OFF\"));\n+        firstAudioAlarm = false;\n+        audioAlarmUpdateSnapshot = false;\n+    }\n+\n+    public String returnValueFromString(String rawString, String searchedString) {\n+        String result = \"\";\n+        int index = rawString.indexOf(searchedString);\n+        if (index != -1) // -1 means \"not found\"\n+        {\n+            result = rawString.substring(index + searchedString.length(), rawString.length());\n+            index = result.indexOf(\"\\r\\n\"); // find a carriage return to find the end of the value.\n+            if (index == -1) {\n+                return result; // Did not find a carriage return.\n+            } else {\n+                return result.substring(0, index);\n+            }\n+        }\n+        return \"\"; // Did not find the String we were searching for\n+    }\n+\n+    public String searchString(String rawString, String searchedString) {\n+        String result = \"\";\n+        int index = 0;\n+        index = rawString.indexOf(searchedString);\n+        if (index != -1) // -1 means \"not found\"\n+        {\n+            result = rawString.substring(index + searchedString.length(), rawString.length());\n+            index = result.indexOf(',');\n+            if (index == -1) {\n+                index = result.indexOf('\"');\n+                if (index == -1) {\n+                    index = result.indexOf('}');\n+                    if (index == -1) {\n+                        return result;\n+                    } else {\n+                        return result.substring(0, index);\n+                    }\n+                } else {\n+                    return result.substring(0, index);\n+                }\n+            } else {\n+                result = result.substring(0, index);\n+                index = result.indexOf('\"');\n+                if (index == -1) {\n+                    return result;\n+                } else {\n+                    return result.substring(0, index);\n+                }\n+            }", "originalCommit": "7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMTQwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479811401", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    setChannelState(CHANNEL_AUDIO_ALARM, OnOffType.valueOf(\"OFF\"));\n          \n          \n            \n                    setChannelState(CHANNEL_AUDIO_ALARM, OnOffType.OFF);", "author": "cpmeister", "createdAt": "2020-08-30T20:19:44Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (\"PUT\".equals(httpMethod)) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot() {\n+        lockCurrentSnapshot.lock();\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+        if (preroll > 0) {\n+            fifoSnapshotBuffer.add(currentSnapshot);\n+            if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                fifoSnapshotBuffer.removeFirst();\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    // These methods handle the response from all Camera brands, nothing specific to\n+    // any brand should be in here //\n+\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                // logger.trace(\"{}\", msg.toString());\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                            if (closeConnection) {\n+                                lock.lock();\n+                                try {\n+                                    byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                    if (indexInLists >= 0) {\n+                                        listOfChStatus.set(indexInLists, (byte) 0);\n+                                    } else {\n+                                        logger.debug(\"!!!! Could not find the ch for a Connection: close URL:{}\",\n+                                                requestUrl);\n+                                    }\n+                                } finally {\n+                                    lock.unlock();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                lockCurrentSnapshot.lock();\n+                                currentSnapshot = incomingJpeg;\n+                                lockCurrentSnapshot.unlock();\n+                                processSnapshot();\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    // logger.trace(\"Snapshot recieved: Binding will now close the channel.\");\n+                                    ctx.close();\n+                                } else {\n+                                    lock.lock();\n+                                    try {\n+                                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                        if (indexInLists >= 0) {\n+                                            listOfChStatus.set(indexInLists, (byte) 2);\n+                                        }\n+                                    } finally {\n+                                        lock.unlock();\n+                                        bytesToRecieve = 0;\n+                                        bytesAlreadyRecieved = 0;\n+                                    }\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.equals(\"\")) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // logger.debug(\"Packet back from camera is not matching HttpContent\");\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+            if (ctx == null) {\n+                return;\n+            }\n+            lock.lock();\n+            try {\n+                byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                if (indexInLists >= 0) {\n+                    // logger.debug(\"commonCameraHandler closed channel:{} \\tURL:{}\", indexInLists, requestUrl);\n+                    listOfChStatus.set(indexInLists, (byte) -1);\n+                } else {\n+                    if (listOfChannels.size() > 0) {\n+                        logger.warn(\"Can't find ch when removing handler \\t\\tURL:{}\", requestUrl);\n+                    }\n+                }\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause instanceof ArrayIndexOutOfBoundsException) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                        if (indexInLists >= 0) {\n+                            String urlToKeepOpen;\n+                            switch (thing.getThingTypeUID().getId()) {\n+                                case \"DAHUA\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"HIKVISION\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/ISAPI/Event/notification/alertStream\".contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"DOORBIRD\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/bha-api/monitor.cgi?ring=doorbell,motionsensor\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                            }\n+                            logger.debug(\"! Channel was found idle for more than 15 seconds so closing it down. !\");\n+                            listOfChStatus.set(indexInLists, (byte) 0);\n+                        } else {\n+                            logger.warn(\"!?! Channel that was found idle could not be located in our tracking. !?!\");\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.debug(\"File server for camera at {} has started on port {} for all NIC's.\", ipAddress,\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    cameraConfigError(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setupSnapshotStreaming(boolean stream, ChannelHandlerContext ctx, boolean auto) {\n+        if (stream) {\n+            sendMjpegFirstPacket(ctx);\n+            if (auto) {\n+                autoSnapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                // iOS uses a FIFO? and needs two frames to display a pic\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingAutoFps = true;\n+            } else {\n+                snapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingSnapshotMjpeg = true;\n+                startSnapshotPolling();\n+            }\n+        } else {\n+            snapshotMjpegChannelGroup.remove(ctx.channel());\n+            autoSnapshotMjpegChannelGroup.remove(ctx.channel());\n+            if (streamingSnapshotMjpeg && snapshotMjpegChannelGroup.isEmpty()) {\n+                streamingSnapshotMjpeg = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All Snapshot based MJPEG streams have stopped.\");\n+            } else if (streamingAutoFps && autoSnapshotMjpegChannelGroup.isEmpty()) {\n+                streamingAutoFps = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All AutoFps Snapshot based MJPEG streams have stopped.\");\n+            }\n+        }\n+    }\n+\n+    // If start is true the CTX is added to the list to stream video to, false stops\n+    // the stream.\n+    public void setupMjpegStreaming(boolean start, ChannelHandlerContext ctx) {\n+        if (start) {\n+            if (mjpegChannelGroup.isEmpty()) {// first stream being requested.\n+                mjpegChannelGroup.add(ctx.channel());\n+                if (mjpegUri.equals(\"\") || mjpegUri.equals(\"ffmpeg\")) {\n+                    sendMjpegFirstPacket(ctx);\n+                    setupFfmpegFormat(\"MJPEG\");\n+                } else {\n+                    try {\n+                        // fix Dahua reboots when refreshing a mjpeg stream.\n+                        TimeUnit.MILLISECONDS.sleep(500);\n+                    } catch (InterruptedException e) {\n+                    }\n+                    sendHttpGET(mjpegUri);\n+                }\n+            } else if (ffmpegMjpeg != null) {// not first stream and we will use ffmpeg\n+                sendMjpegFirstPacket(ctx);\n+                mjpegChannelGroup.add(ctx.channel());\n+            } else {// not first stream and camera supplies the mjpeg source.\n+                ctx.channel().writeAndFlush(firstStreamedMsg);\n+                mjpegChannelGroup.add(ctx.channel());\n+            }\n+        } else {\n+            mjpegChannelGroup.remove(ctx.channel());\n+            if (mjpegChannelGroup.isEmpty()) {\n+                logger.debug(\"All Mjpeg streams have stopped, cleaning up now\");\n+                if (mjpegUri.equals(\"ffmpeg\")) {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                } else if (!mjpegUri.equals(\"\")) {\n+                    closeChannel(getTinyUrl(mjpegUri));\n+                } else {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // sends direct to ctx so can be either snapshots.mjpeg or normal mjpeg stream\n+    public void sendMjpegFirstPacket(ChannelHandlerContext ctx) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        String contentType = \"multipart/x-mixed-replace; boundary=\" + BOUNDARY;\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+        ctx.channel().writeAndFlush(response);\n+    }\n+\n+    public void sendMjpegFrame(byte[] jpg, ChannelGroup channelGroup) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        ByteBuf imageByteBuf = Unpooled.copiedBuffer(jpg);\n+        int length = imageByteBuf.readableBytes();\n+        String header = \"--\" + BOUNDARY + \"\\r\\n\" + \"content-type: image/jpeg\" + \"\\r\\n\" + \"content-length: \" + length\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuf headerBbuf = Unpooled.copiedBuffer(header, 0, header.length(), StandardCharsets.UTF_8);\n+        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+        streamToGroup(headerBbuf, channelGroup, false);\n+        streamToGroup(imageByteBuf, channelGroup, false);\n+        streamToGroup(footerBbuf, channelGroup, true);\n+    }\n+\n+    public void streamToGroup(Object msg, ChannelGroup channelGroup, boolean flush) {\n+        channelGroup.write(msg);\n+        if (flush) {\n+            channelGroup.flush();\n+        }\n+    }\n+\n+    private void storeSnapshots() {\n+        int count = 0;\n+        // Need to lock as fifoSnapshotBuffer is not thread safe and new snapshots can be incoming.\n+        lockCurrentSnapshot.lock();\n+        logger.debug(\"Storing snapshots now to disk for GIF\");\n+        for (Object incomingJpeg : fifoSnapshotBuffer) {\n+            byte[] foo = (byte[]) incomingJpeg;\n+            File file = new File(ffmpegOutputFolder + \"snapshot\" + count + \".jpg\");\n+            count++;\n+            try {\n+                OutputStream fos = new FileOutputStream(file);\n+                fos.write(foo);\n+                fos.close();\n+            } catch (FileNotFoundException e) {\n+                logger.error(\"FileNotFoundException {}\", e.getMessage());\n+            } catch (IOException e) {\n+                logger.error(\"IOException {}\", e.getMessage());\n+            }\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    public void setupFfmpegFormat(String format) {\n+        String inOptions = \"\";\n+        if (ffmpegOutputFolder.equals(\"\")) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when the output folder is not set.\");\n+            return;\n+        }\n+        if (rtspUri.equals(\"\")) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when no valid input for ffmpeg is provided.\");\n+            return;\n+        }\n+        if (config.get(CONFIG_FFMPEG_LOCATION) == null) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when the location for ffmpeg is not known.\");\n+            return;\n+        }\n+\n+        // Make sure the folder exists, if not create it.\n+        new File(ffmpegOutputFolder).mkdirs();\n+        switch (format) {\n+            case \"HLS\":\n+                if (ffmpegHLS == null) {\n+                    if (rtspUri.contains(\":554\")) {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning -rtsp_transport tcp\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    } else {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    }\n+                }\n+                if (ffmpegHLS != null) {\n+                    ffmpegHLS.startConverting();\n+                }\n+                break;\n+            case \"GIF\":\n+                if (preroll > 0) {\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                            \"-y -r 1 -hide_banner -loglevel warning\", ffmpegOutputFolder + \"snapshot%d.jpg\",\n+                            \"-frames:v \" + (preroll + postroll) + \" \"\n+                                    + config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                } else {\n+                    inOptions = \"-y -t \" + postroll + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-y -t \" + postroll;\n+                    }\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                }\n+                if (preroll > 0) {\n+                    storeSnapshots();\n+                }\n+                if (ffmpegGIF != null) {\n+                    ffmpegGIF.startConverting();\n+                    if (gifHistory.equals(\"\")) {\n+                        gifHistory = gifFilename;\n+                    } else if (!gifFilename.equals(\"ipcamera\")) {\n+                        gifHistory = gifFilename + \",\" + gifHistory;\n+                        if (gifHistoryLength > 49) {\n+                            int endIndex = gifHistory.lastIndexOf(\",\");\n+                            gifHistory = gifHistory.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_GIF_HISTORY, new StringType(gifHistory));\n+                }\n+                break;\n+            case \"RECORD\":\n+                inOptions = \"-y -t \" + mp4RecordTime + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                if (!rtspUri.contains(\"rtsp\")) {\n+                    inOptions = \"-y -t \" + mp4RecordTime;\n+                }\n+                ffmpegRecord = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                        rtspUri, config.get(CONFIG_FFMPEG_MP4_OUT_ARGUMENTS).toString(),\n+                        ffmpegOutputFolder + mp4Filename + \".mp4\", username, password);\n+                if (mp4Preroll > 0) {\n+                    // fetchFromHLS(); todo: not done yet\n+                }\n+                if (ffmpegRecord != null) {\n+                    ffmpegRecord.startConverting();\n+                    if (mp4History.equals(\"\")) {\n+                        mp4History = mp4Filename;\n+                    } else if (!mp4Filename.equals(\"ipcamera\")) {\n+                        mp4History = mp4Filename + \",\" + mp4History;\n+                        if (mp4HistoryLength > 49) {\n+                            int endIndex = mp4History.lastIndexOf(\",\");\n+                            mp4History = mp4History.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_MP4_HISTORY, new StringType(mp4History));\n+                }\n+                break;\n+            case \"RTSPHELPER\":\n+                if (ffmpegRtspHelper != null) {\n+                    ffmpegRtspHelper.stopConverting();\n+                    if (!audioAlarmEnabled && !motionAlarmEnabled) {\n+                        return;\n+                    }\n+                }\n+                String input = (config.get(CONFIG_FFMPEG_MOTION_INPUT) == null) ? rtspUri\n+                        : config.get(CONFIG_FFMPEG_MOTION_INPUT).toString();\n+                String OutputOptions = \"-f null -\";\n+                String filterOptions = \"\";\n+                inOptions = \"-rtsp_transport tcp\";\n+                if (!input.contains(\"rtsp\")) {\n+                    inOptions = \"\";\n+                }\n+                if (audioAlarmEnabled == false) {\n+                    filterOptions = \"-an\";\n+                } else if (audioAlarmEnabled == true) {\n+                    filterOptions = \"-af silencedetect=n=-\" + audioThreshold + \"dB:d=2\";\n+                }\n+                if (motionAlarmEnabled == false && ffmpegSnapshotGeneration == false) {\n+                    filterOptions = filterOptions.concat(\" -vn\");\n+                } else if (motionAlarmEnabled == true) {\n+                    filterOptions = filterOptions\n+                            .concat(\" -vf select='gte(scene,\" + motionThreshold + \")',metadata=print\");\n+                }\n+                if (config.get(CONFIG_USERNAME) != null) {\n+                    filterOptions += \" \";// add space as the Framework does not allow spaces at start of config.\n+                }\n+                ffmpegRtspHelper = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                        input, filterOptions + config.get(CONFIG_FFMPEG_MOTION_ARGUMENTS), OutputOptions, username,\n+                        password);\n+                ffmpegRtspHelper.startConverting();\n+                break;\n+            case \"MJPEG\":\n+                if (ffmpegMjpeg == null) {\n+                    inOptions = \"-rtsp_transport tcp -hide_banner -loglevel warning\";\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegMjpeg = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, config.get(CONFIG_FFMPEG_MJPEG_ARGUMENTS).toString(),\n+                            \"http://127.0.0.1:\" + serverPort + \"/ipcamera.jpg\", username, password);\n+                }\n+                if (ffmpegMjpeg != null) {\n+                    ffmpegMjpeg.startConverting();\n+                }\n+                break;\n+            case \"SNAPSHOT\":\n+                // if mjpeg stream you can use ffmpeg -i input.h264 -codec:v copy -bsf:v mjpeg2jpeg output%03d.jpg\n+                if (ffmpegSnapshot == null) {\n+                    inOptions = \"-rtsp_transport tcp -threads 1 -skip_frame nokey -hide_banner -loglevel warning\";// iFrames\n+                                                                                                                  // only\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-threads 1 -skip_frame nokey -hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegSnapshot = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, \"-an -vsync vfr -update 1\", \"http://127.0.0.1:\" + serverPort + \"/snapshot.jpg\",\n+                            username, password);\n+                }\n+                if (ffmpegSnapshot != null) {\n+                    ffmpegSnapshot.startConverting();\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void noMotionDetected(String thisAlarmsChannel) {\n+        setChannelState(thisAlarmsChannel, OnOffType.valueOf(\"OFF\"));\n+        firstMotionAlarm = false;\n+        motionAlarmUpdateSnapshot = false;\n+        motionDetected = false;\n+        if (streamingAutoFps) {\n+            stopSnapshotPolling();\n+        } else if (updateImageEvents.contains(\"4\")) { // During Motion Alarms\n+            stopSnapshotPolling();\n+        }\n+    }\n+\n+    // Change alarms that are not counted as motion detecting.\n+    public void changeAlarmState(String thisAlarmsChannel, String state) {\n+        updateState(thisAlarmsChannel, OnOffType.valueOf(state));\n+    }\n+\n+    public void motionDetected(String thisAlarmsChannel) {\n+        updateState(CHANNEL_LAST_MOTION_TYPE, new StringType(thisAlarmsChannel));\n+        updateState(thisAlarmsChannel, OnOffType.valueOf(\"ON\"));\n+        motionDetected = true;\n+        if (streamingAutoFps) {\n+            startSnapshotPolling();\n+        }\n+        if (updateImageEvents.contains(\"2\")) {\n+            if (!firstMotionAlarm) {\n+                if (!snapshotUri.isEmpty()) {\n+                    sendHttpGET(snapshotUri);\n+                }\n+                firstMotionAlarm = true;// reset back to false when the jpg arrives.\n+            }\n+        } else if (updateImageEvents.contains(\"4\")) { // During Motion Alarms\n+            if (!snapshotPolling) {\n+                startSnapshotPolling();\n+            }\n+            firstMotionAlarm = true;\n+            motionAlarmUpdateSnapshot = true;\n+        }\n+    }\n+\n+    public void audioDetected() {\n+        updateState(CHANNEL_AUDIO_ALARM, OnOffType.valueOf(\"ON\"));\n+        if (updateImageEvents.contains(\"3\")) {\n+            if (!firstAudioAlarm) {\n+                if (!snapshotUri.isEmpty()) {\n+                    sendHttpGET(snapshotUri);\n+                }\n+                firstAudioAlarm = true;// reset back to false when the jpg arrives.\n+            }\n+        } else if (updateImageEvents.contains(\"5\")) {// During audio alarms\n+            firstAudioAlarm = true;\n+            audioAlarmUpdateSnapshot = true;\n+        }\n+    }\n+\n+    public void noAudioDetected() {\n+        setChannelState(CHANNEL_AUDIO_ALARM, OnOffType.valueOf(\"OFF\"));", "originalCommit": "7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMTUyMA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479811520", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        if (\"INCREASE\".equals(command.toString())) {\n          \n          \n            \n                                        if (command == IncreaseDecreaseType.INCREASE) {", "author": "cpmeister", "createdAt": "2020-08-30T20:21:08Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,2020 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        for (byte index = 0; index < listOfRequests.size(); index++) {\n+            logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+            switch (listOfChStatus.get(index)) {\n+                case 2: // Open and OK to reuse\n+                case 1: // Open\n+                case 0: // Closing but still open\n+                    Channel channel = listOfChannels.get(index);\n+                    if (channel.isOpen()) {\n+                        break;\n+                    } else {\n+                        listOfChStatus.set(index, (byte) -1);\n+                        logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                    }\n+                case -1: // closed\n+                    listOfRequests.remove(index);\n+                    listOfChStatus.remove(index);\n+                    listOfChannels.remove(index);\n+                    listOfReplies.remove(index);\n+                    index--;\n+                    break;\n+            }\n+        }\n+        lock.unlock();\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (\"PUT\".equals(httpMethod)) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot() {\n+        lockCurrentSnapshot.lock();\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+        if (preroll > 0) {\n+            fifoSnapshotBuffer.add(currentSnapshot);\n+            if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                fifoSnapshotBuffer.removeFirst();\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(currentSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    // These methods handle the response from all Camera brands, nothing specific to\n+    // any brand should be in here //\n+\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                // logger.trace(\"{}\", msg.toString());\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                            if (closeConnection) {\n+                                lock.lock();\n+                                try {\n+                                    byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                    if (indexInLists >= 0) {\n+                                        listOfChStatus.set(indexInLists, (byte) 0);\n+                                    } else {\n+                                        logger.debug(\"!!!! Could not find the ch for a Connection: close URL:{}\",\n+                                                requestUrl);\n+                                    }\n+                                } finally {\n+                                    lock.unlock();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                lockCurrentSnapshot.lock();\n+                                currentSnapshot = incomingJpeg;\n+                                lockCurrentSnapshot.unlock();\n+                                processSnapshot();\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    // logger.trace(\"Snapshot recieved: Binding will now close the channel.\");\n+                                    ctx.close();\n+                                } else {\n+                                    lock.lock();\n+                                    try {\n+                                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                        if (indexInLists >= 0) {\n+                                            listOfChStatus.set(indexInLists, (byte) 2);\n+                                        }\n+                                    } finally {\n+                                        lock.unlock();\n+                                        bytesToRecieve = 0;\n+                                        bytesAlreadyRecieved = 0;\n+                                    }\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.equals(\"\")) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // logger.debug(\"Packet back from camera is not matching HttpContent\");\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+            if (ctx == null) {\n+                return;\n+            }\n+            lock.lock();\n+            try {\n+                byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                if (indexInLists >= 0) {\n+                    // logger.debug(\"commonCameraHandler closed channel:{} \\tURL:{}\", indexInLists, requestUrl);\n+                    listOfChStatus.set(indexInLists, (byte) -1);\n+                } else {\n+                    if (listOfChannels.size() > 0) {\n+                        logger.warn(\"Can't find ch when removing handler \\t\\tURL:{}\", requestUrl);\n+                    }\n+                }\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause instanceof ArrayIndexOutOfBoundsException) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                        if (indexInLists >= 0) {\n+                            String urlToKeepOpen;\n+                            switch (thing.getThingTypeUID().getId()) {\n+                                case \"DAHUA\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"HIKVISION\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/ISAPI/Event/notification/alertStream\".contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"DOORBIRD\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/bha-api/monitor.cgi?ring=doorbell,motionsensor\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                            }\n+                            logger.debug(\"! Channel was found idle for more than 15 seconds so closing it down. !\");\n+                            listOfChStatus.set(indexInLists, (byte) 0);\n+                        } else {\n+                            logger.warn(\"!?! Channel that was found idle could not be located in our tracking. !?!\");\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.debug(\"File server for camera at {} has started on port {} for all NIC's.\", ipAddress,\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    cameraConfigError(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setupSnapshotStreaming(boolean stream, ChannelHandlerContext ctx, boolean auto) {\n+        if (stream) {\n+            sendMjpegFirstPacket(ctx);\n+            if (auto) {\n+                autoSnapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                // iOS uses a FIFO? and needs two frames to display a pic\n+                sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingAutoFps = true;\n+            } else {\n+                snapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+                lockCurrentSnapshot.unlock();\n+                streamingSnapshotMjpeg = true;\n+                startSnapshotPolling();\n+            }\n+        } else {\n+            snapshotMjpegChannelGroup.remove(ctx.channel());\n+            autoSnapshotMjpegChannelGroup.remove(ctx.channel());\n+            if (streamingSnapshotMjpeg && snapshotMjpegChannelGroup.isEmpty()) {\n+                streamingSnapshotMjpeg = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All Snapshot based MJPEG streams have stopped.\");\n+            } else if (streamingAutoFps && autoSnapshotMjpegChannelGroup.isEmpty()) {\n+                streamingAutoFps = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All AutoFps Snapshot based MJPEG streams have stopped.\");\n+            }\n+        }\n+    }\n+\n+    // If start is true the CTX is added to the list to stream video to, false stops\n+    // the stream.\n+    public void setupMjpegStreaming(boolean start, ChannelHandlerContext ctx) {\n+        if (start) {\n+            if (mjpegChannelGroup.isEmpty()) {// first stream being requested.\n+                mjpegChannelGroup.add(ctx.channel());\n+                if (mjpegUri.equals(\"\") || mjpegUri.equals(\"ffmpeg\")) {\n+                    sendMjpegFirstPacket(ctx);\n+                    setupFfmpegFormat(\"MJPEG\");\n+                } else {\n+                    try {\n+                        // fix Dahua reboots when refreshing a mjpeg stream.\n+                        TimeUnit.MILLISECONDS.sleep(500);\n+                    } catch (InterruptedException e) {\n+                    }\n+                    sendHttpGET(mjpegUri);\n+                }\n+            } else if (ffmpegMjpeg != null) {// not first stream and we will use ffmpeg\n+                sendMjpegFirstPacket(ctx);\n+                mjpegChannelGroup.add(ctx.channel());\n+            } else {// not first stream and camera supplies the mjpeg source.\n+                ctx.channel().writeAndFlush(firstStreamedMsg);\n+                mjpegChannelGroup.add(ctx.channel());\n+            }\n+        } else {\n+            mjpegChannelGroup.remove(ctx.channel());\n+            if (mjpegChannelGroup.isEmpty()) {\n+                logger.debug(\"All Mjpeg streams have stopped, cleaning up now\");\n+                if (mjpegUri.equals(\"ffmpeg\")) {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                } else if (!mjpegUri.equals(\"\")) {\n+                    closeChannel(getTinyUrl(mjpegUri));\n+                } else {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // sends direct to ctx so can be either snapshots.mjpeg or normal mjpeg stream\n+    public void sendMjpegFirstPacket(ChannelHandlerContext ctx) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        String contentType = \"multipart/x-mixed-replace; boundary=\" + BOUNDARY;\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+        ctx.channel().writeAndFlush(response);\n+    }\n+\n+    public void sendMjpegFrame(byte[] jpg, ChannelGroup channelGroup) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        ByteBuf imageByteBuf = Unpooled.copiedBuffer(jpg);\n+        int length = imageByteBuf.readableBytes();\n+        String header = \"--\" + BOUNDARY + \"\\r\\n\" + \"content-type: image/jpeg\" + \"\\r\\n\" + \"content-length: \" + length\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuf headerBbuf = Unpooled.copiedBuffer(header, 0, header.length(), StandardCharsets.UTF_8);\n+        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+        streamToGroup(headerBbuf, channelGroup, false);\n+        streamToGroup(imageByteBuf, channelGroup, false);\n+        streamToGroup(footerBbuf, channelGroup, true);\n+    }\n+\n+    public void streamToGroup(Object msg, ChannelGroup channelGroup, boolean flush) {\n+        channelGroup.write(msg);\n+        if (flush) {\n+            channelGroup.flush();\n+        }\n+    }\n+\n+    private void storeSnapshots() {\n+        int count = 0;\n+        // Need to lock as fifoSnapshotBuffer is not thread safe and new snapshots can be incoming.\n+        lockCurrentSnapshot.lock();\n+        logger.debug(\"Storing snapshots now to disk for GIF\");\n+        for (Object incomingJpeg : fifoSnapshotBuffer) {\n+            byte[] foo = (byte[]) incomingJpeg;\n+            File file = new File(ffmpegOutputFolder + \"snapshot\" + count + \".jpg\");\n+            count++;\n+            try {\n+                OutputStream fos = new FileOutputStream(file);\n+                fos.write(foo);\n+                fos.close();\n+            } catch (FileNotFoundException e) {\n+                logger.error(\"FileNotFoundException {}\", e.getMessage());\n+            } catch (IOException e) {\n+                logger.error(\"IOException {}\", e.getMessage());\n+            }\n+        }\n+        lockCurrentSnapshot.unlock();\n+    }\n+\n+    public void setupFfmpegFormat(String format) {\n+        String inOptions = \"\";\n+        if (ffmpegOutputFolder.equals(\"\")) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when the output folder is not set.\");\n+            return;\n+        }\n+        if (rtspUri.equals(\"\")) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when no valid input for ffmpeg is provided.\");\n+            return;\n+        }\n+        if (config.get(CONFIG_FFMPEG_LOCATION) == null) {\n+            logger.error(\"The camera tried to use a ffmpeg feature when the location for ffmpeg is not known.\");\n+            return;\n+        }\n+\n+        // Make sure the folder exists, if not create it.\n+        new File(ffmpegOutputFolder).mkdirs();\n+        switch (format) {\n+            case \"HLS\":\n+                if (ffmpegHLS == null) {\n+                    if (rtspUri.contains(\":554\")) {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning -rtsp_transport tcp\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    } else {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    }\n+                }\n+                if (ffmpegHLS != null) {\n+                    ffmpegHLS.startConverting();\n+                }\n+                break;\n+            case \"GIF\":\n+                if (preroll > 0) {\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                            \"-y -r 1 -hide_banner -loglevel warning\", ffmpegOutputFolder + \"snapshot%d.jpg\",\n+                            \"-frames:v \" + (preroll + postroll) + \" \"\n+                                    + config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                } else {\n+                    inOptions = \"-y -t \" + postroll + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-y -t \" + postroll;\n+                    }\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                }\n+                if (preroll > 0) {\n+                    storeSnapshots();\n+                }\n+                if (ffmpegGIF != null) {\n+                    ffmpegGIF.startConverting();\n+                    if (gifHistory.equals(\"\")) {\n+                        gifHistory = gifFilename;\n+                    } else if (!gifFilename.equals(\"ipcamera\")) {\n+                        gifHistory = gifFilename + \",\" + gifHistory;\n+                        if (gifHistoryLength > 49) {\n+                            int endIndex = gifHistory.lastIndexOf(\",\");\n+                            gifHistory = gifHistory.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_GIF_HISTORY, new StringType(gifHistory));\n+                }\n+                break;\n+            case \"RECORD\":\n+                inOptions = \"-y -t \" + mp4RecordTime + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                if (!rtspUri.contains(\"rtsp\")) {\n+                    inOptions = \"-y -t \" + mp4RecordTime;\n+                }\n+                ffmpegRecord = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                        rtspUri, config.get(CONFIG_FFMPEG_MP4_OUT_ARGUMENTS).toString(),\n+                        ffmpegOutputFolder + mp4Filename + \".mp4\", username, password);\n+                if (mp4Preroll > 0) {\n+                    // fetchFromHLS(); todo: not done yet\n+                }\n+                if (ffmpegRecord != null) {\n+                    ffmpegRecord.startConverting();\n+                    if (mp4History.equals(\"\")) {\n+                        mp4History = mp4Filename;\n+                    } else if (!mp4Filename.equals(\"ipcamera\")) {\n+                        mp4History = mp4Filename + \",\" + mp4History;\n+                        if (mp4HistoryLength > 49) {\n+                            int endIndex = mp4History.lastIndexOf(\",\");\n+                            mp4History = mp4History.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_MP4_HISTORY, new StringType(mp4History));\n+                }\n+                break;\n+            case \"RTSPHELPER\":\n+                if (ffmpegRtspHelper != null) {\n+                    ffmpegRtspHelper.stopConverting();\n+                    if (!audioAlarmEnabled && !motionAlarmEnabled) {\n+                        return;\n+                    }\n+                }\n+                String input = (config.get(CONFIG_FFMPEG_MOTION_INPUT) == null) ? rtspUri\n+                        : config.get(CONFIG_FFMPEG_MOTION_INPUT).toString();\n+                String OutputOptions = \"-f null -\";\n+                String filterOptions = \"\";\n+                inOptions = \"-rtsp_transport tcp\";\n+                if (!input.contains(\"rtsp\")) {\n+                    inOptions = \"\";\n+                }\n+                if (audioAlarmEnabled == false) {\n+                    filterOptions = \"-an\";\n+                } else if (audioAlarmEnabled == true) {\n+                    filterOptions = \"-af silencedetect=n=-\" + audioThreshold + \"dB:d=2\";\n+                }\n+                if (motionAlarmEnabled == false && ffmpegSnapshotGeneration == false) {\n+                    filterOptions = filterOptions.concat(\" -vn\");\n+                } else if (motionAlarmEnabled == true) {\n+                    filterOptions = filterOptions\n+                            .concat(\" -vf select='gte(scene,\" + motionThreshold + \")',metadata=print\");\n+                }\n+                if (config.get(CONFIG_USERNAME) != null) {\n+                    filterOptions += \" \";// add space as the Framework does not allow spaces at start of config.\n+                }\n+                ffmpegRtspHelper = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                        input, filterOptions + config.get(CONFIG_FFMPEG_MOTION_ARGUMENTS), OutputOptions, username,\n+                        password);\n+                ffmpegRtspHelper.startConverting();\n+                break;\n+            case \"MJPEG\":\n+                if (ffmpegMjpeg == null) {\n+                    inOptions = \"-rtsp_transport tcp -hide_banner -loglevel warning\";\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegMjpeg = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, config.get(CONFIG_FFMPEG_MJPEG_ARGUMENTS).toString(),\n+                            \"http://127.0.0.1:\" + serverPort + \"/ipcamera.jpg\", username, password);\n+                }\n+                if (ffmpegMjpeg != null) {\n+                    ffmpegMjpeg.startConverting();\n+                }\n+                break;\n+            case \"SNAPSHOT\":\n+                // if mjpeg stream you can use ffmpeg -i input.h264 -codec:v copy -bsf:v mjpeg2jpeg output%03d.jpg\n+                if (ffmpegSnapshot == null) {\n+                    inOptions = \"-rtsp_transport tcp -threads 1 -skip_frame nokey -hide_banner -loglevel warning\";// iFrames\n+                                                                                                                  // only\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-threads 1 -skip_frame nokey -hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegSnapshot = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, \"-an -vsync vfr -update 1\", \"http://127.0.0.1:\" + serverPort + \"/snapshot.jpg\",\n+                            username, password);\n+                }\n+                if (ffmpegSnapshot != null) {\n+                    ffmpegSnapshot.startConverting();\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void noMotionDetected(String thisAlarmsChannel) {\n+        setChannelState(thisAlarmsChannel, OnOffType.valueOf(\"OFF\"));\n+        firstMotionAlarm = false;\n+        motionAlarmUpdateSnapshot = false;\n+        motionDetected = false;\n+        if (streamingAutoFps) {\n+            stopSnapshotPolling();\n+        } else if (updateImageEvents.contains(\"4\")) { // During Motion Alarms\n+            stopSnapshotPolling();\n+        }\n+    }\n+\n+    // Change alarms that are not counted as motion detecting.\n+    public void changeAlarmState(String thisAlarmsChannel, String state) {\n+        updateState(thisAlarmsChannel, OnOffType.valueOf(state));\n+    }\n+\n+    public void motionDetected(String thisAlarmsChannel) {\n+        updateState(CHANNEL_LAST_MOTION_TYPE, new StringType(thisAlarmsChannel));\n+        updateState(thisAlarmsChannel, OnOffType.valueOf(\"ON\"));\n+        motionDetected = true;\n+        if (streamingAutoFps) {\n+            startSnapshotPolling();\n+        }\n+        if (updateImageEvents.contains(\"2\")) {\n+            if (!firstMotionAlarm) {\n+                if (!snapshotUri.isEmpty()) {\n+                    sendHttpGET(snapshotUri);\n+                }\n+                firstMotionAlarm = true;// reset back to false when the jpg arrives.\n+            }\n+        } else if (updateImageEvents.contains(\"4\")) { // During Motion Alarms\n+            if (!snapshotPolling) {\n+                startSnapshotPolling();\n+            }\n+            firstMotionAlarm = true;\n+            motionAlarmUpdateSnapshot = true;\n+        }\n+    }\n+\n+    public void audioDetected() {\n+        updateState(CHANNEL_AUDIO_ALARM, OnOffType.valueOf(\"ON\"));\n+        if (updateImageEvents.contains(\"3\")) {\n+            if (!firstAudioAlarm) {\n+                if (!snapshotUri.isEmpty()) {\n+                    sendHttpGET(snapshotUri);\n+                }\n+                firstAudioAlarm = true;// reset back to false when the jpg arrives.\n+            }\n+        } else if (updateImageEvents.contains(\"5\")) {// During audio alarms\n+            firstAudioAlarm = true;\n+            audioAlarmUpdateSnapshot = true;\n+        }\n+    }\n+\n+    public void noAudioDetected() {\n+        setChannelState(CHANNEL_AUDIO_ALARM, OnOffType.valueOf(\"OFF\"));\n+        firstAudioAlarm = false;\n+        audioAlarmUpdateSnapshot = false;\n+    }\n+\n+    public String returnValueFromString(String rawString, String searchedString) {\n+        String result = \"\";\n+        int index = rawString.indexOf(searchedString);\n+        if (index != -1) // -1 means \"not found\"\n+        {\n+            result = rawString.substring(index + searchedString.length(), rawString.length());\n+            index = result.indexOf(\"\\r\\n\"); // find a carriage return to find the end of the value.\n+            if (index == -1) {\n+                return result; // Did not find a carriage return.\n+            } else {\n+                return result.substring(0, index);\n+            }\n+        }\n+        return \"\"; // Did not find the String we were searching for\n+    }\n+\n+    public String searchString(String rawString, String searchedString) {\n+        String result = \"\";\n+        int index = 0;\n+        index = rawString.indexOf(searchedString);\n+        if (index != -1) // -1 means \"not found\"\n+        {\n+            result = rawString.substring(index + searchedString.length(), rawString.length());\n+            index = result.indexOf(',');\n+            if (index == -1) {\n+                index = result.indexOf('\"');\n+                if (index == -1) {\n+                    index = result.indexOf('}');\n+                    if (index == -1) {\n+                        return result;\n+                    } else {\n+                        return result.substring(0, index);\n+                    }\n+                } else {\n+                    return result.substring(0, index);\n+                }\n+            } else {\n+                result = result.substring(0, index);\n+                index = result.indexOf('\"');\n+                if (index == -1) {\n+                    return result;\n+                } else {\n+                    return result.substring(0, index);\n+                }\n+            }\n+        }\n+        return \"\";\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_PAN:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        updateState(CHANNEL_PAN, new PercentType(Math.round(onvifCamera.getAbsolutePan())));\n+                    }\n+                    return;\n+                case CHANNEL_TILT:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        updateState(CHANNEL_TILT, new PercentType(Math.round(onvifCamera.getAbsoluteTilt())));\n+                    }\n+                    return;\n+                case CHANNEL_ZOOM:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        updateState(CHANNEL_ZOOM, new PercentType(Math.round(onvifCamera.getAbsoluteZoom())));\n+                    }\n+                    return;\n+            }\n+        } // caution \"REFRESH\" can still progress to brand Handlers below the else.\n+        else {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MP4_HISTORY_LENGTH:\n+                    if (\"0\".equals(command.toString())) {\n+                        mp4HistoryLength = 0;\n+                        mp4History = \"\";\n+                        setChannelState(CHANNEL_MP4_HISTORY, new StringType(mp4History));\n+                    }\n+                    return;\n+                case CHANNEL_GIF_HISTORY_LENGTH:\n+                    if (\"0\".equals(command.toString())) {\n+                        gifHistoryLength = 0;\n+                        gifHistory = \"\";\n+                        setChannelState(CHANNEL_GIF_HISTORY, new StringType(gifHistory));\n+                    }\n+                    return;\n+                case CHANNEL_FFMPEG_MOTION_CONTROL:\n+                    if (\"ON\".equals(command.toString())) {\n+                        motionAlarmEnabled = true;\n+                    } else if (\"OFF\".equals(command.toString()) || \"0\".equals(command.toString())) {\n+                        motionAlarmEnabled = false;\n+                        noMotionDetected(CHANNEL_MOTION_ALARM);\n+                    } else {\n+                        motionAlarmEnabled = true;\n+                        motionThreshold = Double.valueOf(command.toString());\n+                        motionThreshold = motionThreshold / 10000;\n+                    }\n+                    setupFfmpegFormat(\"RTSPHELPER\");\n+                    return;\n+                case CHANNEL_GIF_FILENAME:\n+                    logger.debug(\"Changing the gif filename to {}.\", command);\n+                    gifFilename = command.toString();\n+                    if (gifFilename.isEmpty()) {\n+                        gifFilename = \"ipcamera\";\n+                    }\n+                    return;\n+                case CHANNEL_MP4_FILENAME:\n+                    logger.debug(\"Changing the mp4 filename to {}.\", command);\n+                    mp4Filename = command.toString();\n+                    if (mp4Filename.isEmpty()) {\n+                        mp4Filename = \"ipcamera\";\n+                    }\n+                    return;\n+                case CHANNEL_RECORD_MP4:\n+                    logger.debug(\"Recording {} Seconds to MP4 format.\", command);\n+                    mp4RecordTime = Integer.parseInt(command.toString());\n+                    setupFfmpegFormat(\"RECORD\");\n+                    return;\n+                case CHANNEL_START_STREAM:\n+                    if (\"ON\".equals(command.toString())) {\n+                        setupFfmpegFormat(\"HLS\");\n+                        if (ffmpegHLS != null) {\n+                            ffmpegHLS.setKeepAlive(-1);// will keep running till manually stopped.\n+                        }\n+                    } else {\n+                        if (ffmpegHLS != null) {\n+                            ffmpegHLS.setKeepAlive(1);\n+                        }\n+                    }\n+                    return;\n+                case CHANNEL_EXTERNAL_MOTION:\n+                    if (\"ON\".equals(command.toString())) {\n+                        motionDetected(CHANNEL_EXTERNAL_MOTION);\n+                    } else {\n+                        noMotionDetected(CHANNEL_EXTERNAL_MOTION);\n+                    }\n+                    return;\n+                case CHANNEL_GOTO_PRESET:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        onvifCamera.gotoPreset(Integer.valueOf(command.toString()));\n+                    }\n+                    return;\n+                case CHANNEL_UPDATE_IMAGE_NOW:\n+                    if (\"ON\".equals(command.toString())) {\n+                        if (snapshotUri.equals(\"\")) {\n+                            ffmpegSnapshotGeneration = true;\n+                            setupFfmpegFormat(\"SNAPSHOT\");\n+                            updateImageChannel = false;\n+                        } else {\n+                            updateImageChannel = true;\n+                            sendHttpGET(snapshotUri);// Allows this to change Image FPS on demand\n+                        }\n+                    } else {\n+                        if (ffmpegSnapshot != null) {\n+                            ffmpegSnapshot.stopConverting();\n+                            ffmpegSnapshotGeneration = false;\n+                        }\n+                        updateImageChannel = false;\n+                    }\n+                    return;\n+                case CHANNEL_UPDATE_GIF:\n+                    if (\"ON\".equals(command.toString())) {\n+                        if (preroll > 0) {\n+                            snapCount = postroll;\n+                        } else {\n+                            setupFfmpegFormat(\"GIF\");\n+                        }\n+                    }\n+                    return;\n+                case CHANNEL_PAN:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        if (command instanceof IncreaseDecreaseType) {\n+                            if (\"INCREASE\".equals(command.toString())) {", "originalCommit": "7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMTc1OA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479811758", "bodyText": "Please use camelcase for variable names.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String Processed = text;\n          \n          \n            \n                    String processed = text;", "author": "cpmeister", "createdAt": "2020-08-30T20:23:44Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/AmcrestHandler.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.ipcamera.handler.IpCameraHandler;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * The {@link AmcrestHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class AmcrestHandler extends ChannelDuplexHandler {\n+    private String requestUrl = \"Empty\";\n+    IpCameraHandler ipCameraHandler;\n+\n+    public AmcrestHandler(ThingHandler handler) {\n+        ipCameraHandler = (IpCameraHandler) handler;\n+    }\n+\n+    public void setURL(String url) {\n+        requestUrl = url;\n+    }\n+\n+    // This handles the incoming http replies back from the camera.\n+    @Override\n+    public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+        if (msg == null || ctx == null) {\n+            return;\n+        }\n+        try {\n+            String content = msg.toString();\n+\n+            if (!content.isEmpty()) {\n+                ipCameraHandler.logger.trace(\"HTTP Result back from camera is \\t:{}:\", content);\n+            }\n+            if (content.contains(\"Error: No Events\")) {\n+                if (\"/cgi-bin/eventManager.cgi?action=getEventIndexes&code=VideoMotion\".equals(requestUrl)) {\n+                    ipCameraHandler.noMotionDetected(CHANNEL_MOTION_ALARM);\n+                } else if (\"/cgi-bin/eventManager.cgi?action=getEventIndexes&code=AudioMutation\".equals(requestUrl)) {\n+                    ipCameraHandler.noAudioDetected();\n+                }\n+            } else if (content.contains(\"channels[0]=0\")) {\n+                if (\"/cgi-bin/eventManager.cgi?action=getEventIndexes&code=VideoMotion\".equals(requestUrl)) {\n+                    ipCameraHandler.motionDetected(CHANNEL_MOTION_ALARM);\n+                } else if (\"/cgi-bin/eventManager.cgi?action=getEventIndexes&code=AudioMutation\".equals(requestUrl)) {\n+                    ipCameraHandler.audioDetected();\n+                }\n+            }\n+\n+            if (content.contains(\"table.MotionDetect[0].Enable=false\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_MOTION_ALARM, OnOffType.valueOf(\"OFF\"));\n+            } else if (content.contains(\"table.MotionDetect[0].Enable=true\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_MOTION_ALARM, OnOffType.valueOf(\"ON\"));\n+            }\n+            // determine if the audio alarm is turned on or off.\n+            if (content.contains(\"table.AudioDetect[0].MutationDetect=true\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_AUDIO_ALARM, OnOffType.valueOf(\"ON\"));\n+            } else if (content.contains(\"table.AudioDetect[0].MutationDetect=false\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_AUDIO_ALARM, OnOffType.valueOf(\"OFF\"));\n+            }\n+            // Handle AudioMutationThreshold alarm\n+            if (content.contains(\"table.AudioDetect[0].MutationThreold=\")) {\n+                String value = ipCameraHandler.returnValueFromString(content, \"table.AudioDetect[0].MutationThreold=\");\n+                ipCameraHandler.setChannelState(CHANNEL_THRESHOLD_AUDIO_ALARM, PercentType.valueOf(value));\n+            }\n+\n+        } finally {\n+            ReferenceCountUtil.release(msg);\n+            ctx.close();\n+        }\n+    }\n+\n+    public String encodeSpecialChars(String text) {\n+        String Processed = text;", "originalCommit": "7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMTgyNw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479811827", "bodyText": "missing code?", "author": "cpmeister", "createdAt": "2020-08-30T20:24:32Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/AmcrestHandler.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.ipcamera.handler.IpCameraHandler;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * The {@link AmcrestHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class AmcrestHandler extends ChannelDuplexHandler {\n+    private String requestUrl = \"Empty\";\n+    IpCameraHandler ipCameraHandler;\n+\n+    public AmcrestHandler(ThingHandler handler) {\n+        ipCameraHandler = (IpCameraHandler) handler;\n+    }\n+\n+    public void setURL(String url) {\n+        requestUrl = url;\n+    }\n+\n+    // This handles the incoming http replies back from the camera.\n+    @Override\n+    public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+        if (msg == null || ctx == null) {\n+            return;\n+        }\n+        try {\n+            String content = msg.toString();\n+\n+            if (!content.isEmpty()) {\n+                ipCameraHandler.logger.trace(\"HTTP Result back from camera is \\t:{}:\", content);\n+            }\n+            if (content.contains(\"Error: No Events\")) {\n+                if (\"/cgi-bin/eventManager.cgi?action=getEventIndexes&code=VideoMotion\".equals(requestUrl)) {\n+                    ipCameraHandler.noMotionDetected(CHANNEL_MOTION_ALARM);\n+                } else if (\"/cgi-bin/eventManager.cgi?action=getEventIndexes&code=AudioMutation\".equals(requestUrl)) {\n+                    ipCameraHandler.noAudioDetected();\n+                }\n+            } else if (content.contains(\"channels[0]=0\")) {\n+                if (\"/cgi-bin/eventManager.cgi?action=getEventIndexes&code=VideoMotion\".equals(requestUrl)) {\n+                    ipCameraHandler.motionDetected(CHANNEL_MOTION_ALARM);\n+                } else if (\"/cgi-bin/eventManager.cgi?action=getEventIndexes&code=AudioMutation\".equals(requestUrl)) {\n+                    ipCameraHandler.audioDetected();\n+                }\n+            }\n+\n+            if (content.contains(\"table.MotionDetect[0].Enable=false\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_MOTION_ALARM, OnOffType.valueOf(\"OFF\"));\n+            } else if (content.contains(\"table.MotionDetect[0].Enable=true\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_MOTION_ALARM, OnOffType.valueOf(\"ON\"));\n+            }\n+            // determine if the audio alarm is turned on or off.\n+            if (content.contains(\"table.AudioDetect[0].MutationDetect=true\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_AUDIO_ALARM, OnOffType.valueOf(\"ON\"));\n+            } else if (content.contains(\"table.AudioDetect[0].MutationDetect=false\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_AUDIO_ALARM, OnOffType.valueOf(\"OFF\"));\n+            }\n+            // Handle AudioMutationThreshold alarm\n+            if (content.contains(\"table.AudioDetect[0].MutationThreold=\")) {\n+                String value = ipCameraHandler.returnValueFromString(content, \"table.AudioDetect[0].MutationThreold=\");\n+                ipCameraHandler.setChannelState(CHANNEL_THRESHOLD_AUDIO_ALARM, PercentType.valueOf(value));\n+            }\n+\n+        } finally {\n+            ReferenceCountUtil.release(msg);\n+            ctx.close();\n+        }\n+    }\n+\n+    public String encodeSpecialChars(String text) {\n+        String Processed = text;\n+        try {\n+            Processed = URLEncoder.encode(text, \"UTF-8\").replace(\"+\", \"%20\");\n+        } catch (UnsupportedEncodingException e) {\n+\n+        }\n+        return Processed;\n+    }\n+\n+    // This handles the commands that come from the Openhab event bus.\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_THRESHOLD_AUDIO_ALARM:\n+                    ipCameraHandler.sendHttpGET(\"/cgi-bin/configManager.cgi?action=getConfig&name=AudioDetect[0]\");\n+                    return;\n+                case CHANNEL_ENABLE_AUDIO_ALARM:\n+                    ipCameraHandler.sendHttpGET(\"/cgi-bin/configManager.cgi?action=getConfig&name=AudioDetect[0]\");\n+                    return;\n+                case CHANNEL_ENABLE_LINE_CROSSING_ALARM:\n+                    ipCameraHandler\n+                            .sendHttpGET(\"/cgi-bin/configManager.cgi?action=getConfig&name=CrossLineDetection[0]\");\n+                    return;\n+                case CHANNEL_ENABLE_MOTION_ALARM:\n+                    ipCameraHandler.sendHttpGET(\"/cgi-bin/configManager.cgi?action=getConfig&name=MotionDetect[0]\");\n+                    return;\n+            }\n+            return; // Return as we have handled the refresh command above and don't need to\n+                    // continue further.\n+        } // end of \"REFRESH\"\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TEXT_OVERLAY:\n+                String text = encodeSpecialChars(command.toString());\n+                if (\"\".contentEquals(text)) {\n+                    ipCameraHandler.sendHttpGET(\n+                            \"/cgi-bin/configManager.cgi?action=setConfig&VideoWidget[0].CustomTitle[1].EncodeBlend=false\");\n+                } else {\n+                    ipCameraHandler.sendHttpGET(\n+                            \"/cgi-bin/configManager.cgi?action=setConfig&VideoWidget[0].CustomTitle[1].EncodeBlend=true&VideoWidget[0].CustomTitle[1].Text=\"\n+                                    + text);\n+                }\n+                return;\n+            case CHANNEL_API_ACCESS:\n+                if (command.toString() != null) {\n+                    ipCameraHandler.logger.info(\"API Access was sent this command :{}\", command.toString());\n+                    ipCameraHandler.sendHttpGET(command.toString());\n+                    ipCameraHandler.setChannelState(CHANNEL_API_ACCESS, StringType.valueOf(\"\"));\n+                }\n+                return;\n+            case CHANNEL_ENABLE_LED:\n+                ipCameraHandler.setChannelState(CHANNEL_AUTO_LED, OnOffType.valueOf(\"OFF\"));\n+                if (\"0\".equals(command.toString()) || \"OFF\".equals(command.toString())) {\n+                    ipCameraHandler.sendHttpGET(\"/cgi-bin/configManager.cgi?action=setConfig&Lighting[0][0].Mode=Off\");\n+                } else if (\"ON\".equals(command.toString())) {\n+                    ipCameraHandler\n+                            .sendHttpGET(\"/cgi-bin/configManager.cgi?action=setConfig&Lighting[0][0].Mode=Manual\");\n+                } else {\n+                    ipCameraHandler.sendHttpGET(\n+                            \"/cgi-bin/configManager.cgi?action=setConfig&Lighting[0][0].Mode=Manual&Lighting[0][0].MiddleLight[0].Light=\"\n+                                    + command.toString());\n+                }\n+                return;\n+            case CHANNEL_AUTO_LED:\n+                if (\"ON\".equals(command.toString())) {\n+                    ipCameraHandler.setChannelState(CHANNEL_ENABLE_LED, UnDefType.valueOf(\"UNDEF\"));\n+                    ipCameraHandler.sendHttpGET(\"/cgi-bin/configManager.cgi?action=setConfig&Lighting[0][0].Mode=Auto\");\n+                }\n+                return;\n+            case CHANNEL_THRESHOLD_AUDIO_ALARM:\n+                int threshold = Math.round(Float.valueOf(command.toString()));\n+\n+                if (threshold == 0) {\n+                    ipCameraHandler.sendHttpGET(\n+                            \"/cgi-bin/configManager.cgi?action=setConfig&AudioDetect[0].MutationThreold=1\");\n+                } else {\n+                    ipCameraHandler.sendHttpGET(\n+                            \"/cgi-bin/configManager.cgi?action=setConfig&AudioDetect[0].MutationThreold=\" + threshold);\n+                }\n+                return;\n+            case CHANNEL_ENABLE_AUDIO_ALARM:\n+                if (\"ON\".equals(command.toString())) {\n+                    ipCameraHandler.sendHttpGET(\n+                            \"/cgi-bin/configManager.cgi?action=setConfig&AudioDetect[0].MutationDetect=true&AudioDetect[0].EventHandler.Dejitter=1\");\n+                } else {\n+                    ipCameraHandler.sendHttpGET(\n+                            \"/cgi-bin/configManager.cgi?action=setConfig&AudioDetect[0].MutationDetect=false\");\n+                }\n+                return;\n+            case CHANNEL_ENABLE_LINE_CROSSING_ALARM:\n+                if (\"ON\".equals(command.toString())) {\n+\n+                } else {\n+\n+                }", "originalCommit": "7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MTg1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479881854", "bodyText": "Thank you, copy paste bandit struck. Fixed.", "author": "Skinah", "createdAt": "2020-08-31T04:29:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMTgyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMTkzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479811935", "bodyText": "Why not just return an empty list here? It it expected for the caller to add to it?", "author": "cpmeister", "createdAt": "2020-08-30T20:25:34Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/HttpOnlyHandler.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.util.ArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.ipcamera.handler.IpCameraHandler;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * The {@link HttpOnlyHandler} is responsible for handling commands for httponly and Onvif thingtypes.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class HttpOnlyHandler extends ChannelDuplexHandler {\n+    IpCameraHandler ipCameraHandler;\n+\n+    public HttpOnlyHandler(IpCameraHandler handler) {\n+        ipCameraHandler = handler;\n+    }\n+\n+    // This handles the incoming http replies back from the camera.\n+    @Override\n+    public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+        ReferenceCountUtil.release(msg);\n+    }\n+\n+    // This handles the commands that come from the Openhab event bus.\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_ENABLE_AUDIO_ALARM:\n+                    return;\n+            }\n+            return; // Return as we have handled the refresh command above and don't need to\n+                    // continue further.\n+        } // end of \"REFRESH\"\n+        switch (channelUID.getId()) {\n+            case CHANNEL_THRESHOLD_AUDIO_ALARM:\n+                if (\"ON\".equals(command.toString())) {\n+                    ipCameraHandler.audioAlarmEnabled = true;\n+                } else if (\"OFF\".equals(command.toString()) || \"0\".equals(command.toString())) {\n+                    ipCameraHandler.audioAlarmEnabled = false;\n+                } else {\n+                    ipCameraHandler.audioAlarmEnabled = true;\n+                    ipCameraHandler.audioThreshold = Integer.valueOf(command.toString());\n+                }\n+                ipCameraHandler.setupFfmpegFormat(\"RTSPHELPER\");\n+                return;\n+        }\n+    }\n+\n+    // If a camera does not need to poll a request as often as snapshots, it can be\n+    // added here. Binding steps through the list.\n+    public ArrayList<String> getLowPriorityRequests() {\n+        ArrayList<String> lowPriorityRequests = new ArrayList<String>(1);\n+        return lowPriorityRequests;", "originalCommit": "7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4NTM5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479885396", "bodyText": "Fixed, returns an empty list.", "author": "Skinah", "createdAt": "2020-08-31T04:46:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMTkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMjA1OA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479812058", "bodyText": "Any reason these fields aren't private?", "author": "cpmeister", "createdAt": "2020-08-30T20:27:03Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/MyNettyAuthHandler.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import java.security.MessageDigest;\n+import java.util.Random;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.ipcamera.handler.IpCameraHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.http.HttpResponse;\n+\n+/**\n+ * The {@link MyNettyAuthHandler} is responsible for handling the basic and digest auths\n+ *\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class MyNettyAuthHandler extends ChannelDuplexHandler {\n+\n+    private Logger logger = LoggerFactory.getLogger(getClass());\n+    private IpCameraHandler myHandler;\n+    private String username, password;\n+    private String httpMethod = \"\", httpUrl = \"\";\n+    private byte ncCounter = 0;\n+    String nonce = \"\", opaque = \"\", qop = \"\";\n+    String realm = \"\";", "originalCommit": "7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4Mjg4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479882887", "bodyText": "None so this is fixed.", "author": "Skinah", "createdAt": "2020-08-31T04:34:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMjA1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMjA5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479812090", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch (java.security.NoSuchAlgorithmException e) {\n          \n          \n            \n                    } catch (NoSuchAlgorithmException e) {", "author": "cpmeister", "createdAt": "2020-08-30T20:27:19Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/MyNettyAuthHandler.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import java.security.MessageDigest;\n+import java.util.Random;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.ipcamera.handler.IpCameraHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.http.HttpResponse;\n+\n+/**\n+ * The {@link MyNettyAuthHandler} is responsible for handling the basic and digest auths\n+ *\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class MyNettyAuthHandler extends ChannelDuplexHandler {\n+\n+    private Logger logger = LoggerFactory.getLogger(getClass());\n+    private IpCameraHandler myHandler;\n+    private String username, password;\n+    private String httpMethod = \"\", httpUrl = \"\";\n+    private byte ncCounter = 0;\n+    String nonce = \"\", opaque = \"\", qop = \"\";\n+    String realm = \"\";\n+\n+    public MyNettyAuthHandler(String user, String pass, String method, String url, ThingHandler handle) {\n+        myHandler = (IpCameraHandler) handle;\n+        username = user;\n+        password = pass;\n+        httpUrl = url;\n+        httpMethod = method;\n+    }\n+\n+    public MyNettyAuthHandler(String user, String pass, ThingHandler handle) {\n+        myHandler = (IpCameraHandler) handle;\n+        username = user;\n+        password = pass;\n+    }\n+\n+    public void setURL(String method, String url) {\n+        httpUrl = url;\n+        httpMethod = method;\n+    }\n+\n+    private String calcMD5Hash(String toHash) {\n+        try {\n+            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n+            byte[] array = messageDigest.digest(toHash.getBytes());\n+            StringBuffer stringBuffer = new StringBuffer();\n+            for (int i = 0; i < array.length; ++i) {\n+                stringBuffer.append(Integer.toHexString((array[i] & 0xFF) | 0x100).substring(1, 3));\n+            }\n+            messageDigest = null;\n+            array = null;\n+            return stringBuffer.toString();\n+        } catch (java.security.NoSuchAlgorithmException e) {", "originalCommit": "7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMjIwMg==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r479812202", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        } else if (httpRequest.uri().contains(\".m4s\")) {\n          \n          \n            \n                                            sendFile(ctx, queryStringDecoder.path(), \"video/mp4\");\n          \n          \n            \n                                        } else if (httpRequest.uri().contains(\".mp4\")) {\n          \n          \n            \n                                        } else if (httpRequest.uri().contains(\".m4s\") || httpRequest.uri().contains(\".mp4\")) {", "author": "cpmeister", "createdAt": "2020-08-30T20:28:59Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/StreamServerHandler.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.CONFIG_FFMPEG_OUTPUT;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.ipcamera.handler.IpCameraHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.codec.http.QueryStringDecoder;\n+import io.netty.handler.stream.ChunkedFile;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * The {@link StreamServerHandler} class is responsible for handling streams and sending any requested files to Openhabs\n+ * features.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class StreamServerHandler extends ChannelInboundHandlerAdapter {\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private IpCameraHandler ipCameraHandler;\n+    private boolean handlingMjpeg = false; // used to remove ctx from group when handler is removed.\n+    private boolean handlingSnapshotStream = false; // used to remove ctx from group when handler is removed.\n+    private byte[] incomingJpeg = new byte[0];\n+    String whiteList = \"\";\n+    int recievedBytes = 0;\n+    int count = 0;\n+    boolean updateSnapshot = false;\n+    boolean onvifEvent = false;\n+\n+    public StreamServerHandler(IpCameraHandler ipCameraHandler) {\n+        this.ipCameraHandler = ipCameraHandler;\n+        whiteList = ipCameraHandler.getWhiteList();\n+    }\n+\n+    @Override\n+    public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        // logger.trace(\"Opening a StreamServerHandler.\");\n+    }\n+\n+    @Override\n+    public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+        if (ctx == null) {\n+            return;\n+        }\n+\n+        @Nullable\n+        HttpContent content = null;\n+        try {\n+            if (msg instanceof HttpRequest) {\n+                HttpRequest httpRequest = (HttpRequest) msg;\n+                // logger.debug(\"Stream Server recieved request \\t{}:{}\", httpRequest.method(), httpRequest.uri());\n+                if (!whiteList.equals(\"DISABLE\")) {\n+                    String requestIP = \"(\"\n+                            + ((InetSocketAddress) ctx.channel().remoteAddress()).getAddress().getHostAddress() + \")\";\n+                    if (!whiteList.contains(requestIP)) {\n+                        logger.warn(\"The request made from {} was not in the whitelist and will be ignored.\",\n+                                requestIP);\n+                        return;\n+                    }\n+                }\n+                if (\"GET\".equalsIgnoreCase(httpRequest.method().toString())) {\n+                    logger.debug(\"Stream Server recieved request \\tGET:{}\", httpRequest.uri());\n+                    // Some browsers send a query string after the path when refreshing a picture.\n+                    QueryStringDecoder queryStringDecoder = new QueryStringDecoder(httpRequest.uri());\n+                    switch (queryStringDecoder.path()) {\n+                        case \"/ipcamera.m3u8\":\n+                            if (ipCameraHandler.ffmpegHLS != null) {\n+                                if (!ipCameraHandler.ffmpegHLS.getIsAlive()) {\n+                                    if (ipCameraHandler.ffmpegHLS != null) {\n+                                        ipCameraHandler.ffmpegHLS.startConverting();\n+                                    }\n+                                }\n+                            } else {\n+                                ipCameraHandler.setupFfmpegFormat(\"HLS\");\n+                            }\n+                            if (ipCameraHandler.ffmpegHLS != null) {\n+                                ipCameraHandler.ffmpegHLS.setKeepAlive(8);\n+                            }\n+                            sendFile(ctx, httpRequest.uri(), \"application/x-mpegurl\");\n+                            ctx.close();\n+                            return;\n+                        case \"/ipcamera.mpd\":\n+                            sendFile(ctx, httpRequest.uri(), \"application/dash+xml\");\n+                            return;\n+                        case \"/ipcamera.gif\":\n+                            sendFile(ctx, httpRequest.uri(), \"image/gif\");\n+                            return;\n+                        case \"/ipcamera.jpg\":\n+                            if (!ipCameraHandler.snapshotPolling && ipCameraHandler.snapshotUri != \"\") {\n+                                ipCameraHandler.sendHttpGET(ipCameraHandler.snapshotUri);\n+                            }\n+                            if (ipCameraHandler.currentSnapshot.length == 1) {\n+                                logger.warn(\"ipcamera.jpg was requested but there is no jpg in ram to send.\");\n+                                return;\n+                            }\n+                            sendSnapshotImage(ctx, \"image/jpg\");\n+                            return;\n+                        case \"/snapshots.mjpeg\":\n+                            handlingSnapshotStream = true;\n+                            ipCameraHandler.startSnapshotPolling();\n+                            ipCameraHandler.setupSnapshotStreaming(true, ctx, false);\n+                            return;\n+                        case \"/ipcamera.mjpeg\":\n+                            ipCameraHandler.setupMjpegStreaming(true, ctx);\n+                            handlingMjpeg = true;\n+                            return;\n+                        case \"/autofps.mjpeg\":\n+                            handlingSnapshotStream = true;\n+                            ipCameraHandler.setupSnapshotStreaming(true, ctx, true);\n+                            return;\n+                        case \"/instar\":\n+                            InstarHandler instar = new InstarHandler(ipCameraHandler);\n+                            instar.alarmTriggered(httpRequest.uri().toString());\n+                            ctx.close();\n+                            return;\n+                        case \"/ipcamera0.ts\":\n+                            // TimeUnit.MILLISECONDS.sleep(10);// Give time for file to be created.\n+                        default:\n+                            if (httpRequest.uri().contains(\".ts\")) {\n+                                TimeUnit.MILLISECONDS.sleep(75);// Give time for file to be created.\n+                                sendFile(ctx, queryStringDecoder.path(), \"video/MP2T\");\n+                            } else if (httpRequest.uri().contains(\".gif\")) {\n+                                sendFile(ctx, queryStringDecoder.path(), \"image/gif\");\n+                            } else if (httpRequest.uri().contains(\".jpg\")) {\n+                                // Allow access to the preroll and postroll jpg files\n+                                sendFile(ctx, queryStringDecoder.path(), \"image/jpg\");\n+                            } else if (httpRequest.uri().contains(\".m4s\")) {\n+                                sendFile(ctx, queryStringDecoder.path(), \"video/mp4\");\n+                            } else if (httpRequest.uri().contains(\".mp4\")) {", "originalCommit": "7c6989d04da4e27f478f6f9ca3a62f982eeb860b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "92e98d32bf5b5c02501fe85db54ef04360b76660", "url": "https://github.com/openhab/openhab-addons/commit/92e98d32bf5b5c02501fe85db54ef04360b76660", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/StreamServerHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: cpmeister <mistercpp2000@gmail.com>", "committedDate": "2020-08-31T04:08:07Z", "type": "commit"}, {"oid": "7be6422f2e2be8a1a60f055d3a5ebbd880ee2126", "url": "https://github.com/openhab/openhab-addons/commit/7be6422f2e2be8a1a60f055d3a5ebbd880ee2126", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/MyNettyAuthHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: cpmeister <mistercpp2000@gmail.com>", "committedDate": "2020-08-31T04:15:41Z", "type": "commit"}, {"oid": "4d6355d11d97ae400df755c088ef98f267237dc8", "url": "https://github.com/openhab/openhab-addons/commit/4d6355d11d97ae400df755c088ef98f267237dc8", "message": "Fixed missing Amcrest enable line crossing.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-31T04:26:04Z", "type": "commit"}, {"oid": "e8e1db265061e29f9f3ae7dee0cdf28769cd0f04", "url": "https://github.com/openhab/openhab-addons/commit/e8e1db265061e29f9f3ae7dee0cdf28769cd0f04", "message": "Make strings private.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-31T04:29:18Z", "type": "commit"}, {"oid": "947c119d7279c733b7a33ec039d4d0f14caa43b2", "url": "https://github.com/openhab/openhab-addons/commit/947c119d7279c733b7a33ec039d4d0f14caa43b2", "message": "Return empty list.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-31T04:38:09Z", "type": "commit"}, {"oid": "24ddd154a5e18d324219461401f790182ae8f42e", "url": "https://github.com/openhab/openhab-addons/commit/24ddd154a5e18d324219461401f790182ae8f42e", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/AmcrestHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: cpmeister <mistercpp2000@gmail.com>", "committedDate": "2020-08-31T04:47:47Z", "type": "commit"}, {"oid": "1b0af18a40834ffb44d44051f525e73a911a1d44", "url": "https://github.com/openhab/openhab-addons/commit/1b0af18a40834ffb44d44051f525e73a911a1d44", "message": "Fixed mismatched variable case name.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-31T04:57:13Z", "type": "commit"}, {"oid": "07702c58e97abc5977211bf2fb175de767fed7a4", "url": "https://github.com/openhab/openhab-addons/commit/07702c58e97abc5977211bf2fb175de767fed7a4", "message": "Change log error to warn.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-31T05:09:47Z", "type": "commit"}, {"oid": "cd65e88964469e166e438bc7c930cff8480e9281", "url": "https://github.com/openhab/openhab-addons/commit/cd65e88964469e166e438bc7c930cff8480e9281", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: cpmeister <mistercpp2000@gmail.com>", "committedDate": "2020-08-31T05:13:40Z", "type": "commit"}, {"oid": "ffd3362212dff6f257063836b9f56d04c8c6c74b", "url": "https://github.com/openhab/openhab-addons/commit/ffd3362212dff6f257063836b9f56d04c8c6c74b", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: cpmeister <mistercpp2000@gmail.com>", "committedDate": "2020-08-31T05:24:36Z", "type": "commit"}, {"oid": "5ad3bc0c2f5b301ada6d16a9e1162f30cbb0be8b", "url": "https://github.com/openhab/openhab-addons/commit/5ad3bc0c2f5b301ada6d16a9e1162f30cbb0be8b", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: cpmeister <mistercpp2000@gmail.com>", "committedDate": "2020-08-31T05:25:19Z", "type": "commit"}, {"oid": "25eac1ed01c041021aae3fa4252a593f6b8960a8", "url": "https://github.com/openhab/openhab-addons/commit/25eac1ed01c041021aae3fa4252a593f6b8960a8", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: cpmeister <mistercpp2000@gmail.com>", "committedDate": "2020-08-31T05:25:57Z", "type": "commit"}, {"oid": "74b45e7b1ff3f6b52eec8d57aa58062f0b27f651", "url": "https://github.com/openhab/openhab-addons/commit/74b45e7b1ff3f6b52eec8d57aa58062f0b27f651", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: cpmeister <mistercpp2000@gmail.com>", "committedDate": "2020-08-31T05:26:27Z", "type": "commit"}, {"oid": "58838c51b7e80dd7326b35e642b0f4d1089dcfae", "url": "https://github.com/openhab/openhab-addons/commit/58838c51b7e80dd7326b35e642b0f4d1089dcfae", "message": "Update bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java\r\n\r\nSigned-off-by: Matthew Skinner <matt@pcmus.com>\n\nCo-authored-by: cpmeister <mistercpp2000@gmail.com>", "committedDate": "2020-08-31T05:28:30Z", "type": "commit"}, {"oid": "f198e7fa1cf225658840d2de7203969a38690d5e", "url": "https://github.com/openhab/openhab-addons/commit/f198e7fa1cf225658840d2de7203969a38690d5e", "message": "Shift search string into class that uses it and provide javadoc.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-31T06:02:30Z", "type": "commit"}, {"oid": "8555153b4ddcce61f1330c1b3ab6890603a6d750", "url": "https://github.com/openhab/openhab-addons/commit/8555153b4ddcce61f1330c1b3ab6890603a6d750", "message": "Moved searchString\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-31T06:05:17Z", "type": "commit"}, {"oid": "1ba3a94e624d5d6fdcd31ab500d89446cb95b1dd", "url": "https://github.com/openhab/openhab-addons/commit/1ba3a94e624d5d6fdcd31ab500d89446cb95b1dd", "message": "Process snapshot with parameter.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-31T06:38:29Z", "type": "commit"}, {"oid": "1c9dd8a7f9bd3dbfa15f6d53fb869f6880ff1611", "url": "https://github.com/openhab/openhab-addons/commit/1c9dd8a7f9bd3dbfa15f6d53fb869f6880ff1611", "message": "Fix variable with capital.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-31T06:40:10Z", "type": "commit"}, {"oid": "19ead20ad39d173fbdad8c93ab34d95962a48f44", "url": "https://github.com/openhab/openhab-addons/commit/19ead20ad39d173fbdad8c93ab34d95962a48f44", "message": "Variable with caps.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-31T06:42:16Z", "type": "commit"}, {"oid": "5e7771f9719f01b9b18ddb75fc37c11f4845977b", "url": "https://github.com/openhab/openhab-addons/commit/5e7771f9719f01b9b18ddb75fc37c11f4845977b", "message": "Move all unlocks in finally blocks.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-31T06:58:26Z", "type": "commit"}, {"oid": "5a0c48af9294599de82aa93c8d77a4579df1a848", "url": "https://github.com/openhab/openhab-addons/commit/5a0c48af9294599de82aa93c8d77a4579df1a848", "message": "apiAccess channel removed.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-31T08:13:38Z", "type": "commit"}, {"oid": "49db6a3dd278a44463a6dc22c07d72dd194c8719", "url": "https://github.com/openhab/openhab-addons/commit/49db6a3dd278a44463a6dc22c07d72dd194c8719", "message": "Readme improvements.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-31T08:32:21Z", "type": "commit"}, {"oid": "508c867402ae8c053c83c3c6c60a8e78e592ea34", "url": "https://github.com/openhab/openhab-addons/commit/508c867402ae8c053c83c3c6c60a8e78e592ea34", "message": "Reorder sections and Improve How to Cast a Camera.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-31T09:06:00Z", "type": "commit"}, {"oid": "5729011d4405e52c202665f19a31ff5fc31a4f4a", "url": "https://github.com/openhab/openhab-addons/commit/5729011d4405e52c202665f19a31ff5fc31a4f4a", "message": "Remove HowTo section.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-31T10:22:34Z", "type": "commit"}, {"oid": "fc241a8b17a3fee3aae387643dc669b6b236792c", "url": "https://github.com/openhab/openhab-addons/commit/fc241a8b17a3fee3aae387643dc669b6b236792c", "message": "Removed roadmap.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-31T10:27:12Z", "type": "commit"}, {"oid": "8ef3977f7a6239bc2d05a7f0d5626de91834a746", "url": "https://github.com/openhab/openhab-addons/commit/8ef3977f7a6239bc2d05a7f0d5626de91834a746", "message": "Removed double empty lines.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-31T10:34:49Z", "type": "commit"}, {"oid": "9d8014448558db068341122ad8122908fe35221d", "url": "https://github.com/openhab/openhab-addons/commit/9d8014448558db068341122ad8122908fe35221d", "message": "Add anchor.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-31T10:40:12Z", "type": "commit"}, {"oid": "c13e66b813d36d1c7655650f20a8f7a0532361de", "url": "https://github.com/openhab/openhab-addons/commit/c13e66b813d36d1c7655650f20a8f7a0532361de", "message": "Rename heading to 'Thing Configuration'\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-31T10:57:09Z", "type": "commit"}, {"oid": "13f2b7e4312aa5389244f4a45b653798d3b4c355", "url": "https://github.com/openhab/openhab-addons/commit/13f2b7e4312aa5389244f4a45b653798d3b4c355", "message": "Readme fixes.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-08-31T11:06:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3NTAzMg==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r480375032", "bodyText": "This code is duplicated in multiple classes, you should refactor this into either a shared parent class or into a static method of a utility class.", "author": "cpmeister", "createdAt": "2020-08-31T20:16:57Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/InstarHandler.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.ipcamera.handler.IpCameraHandler;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * The {@link InstarHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class InstarHandler extends ChannelDuplexHandler {\n+    IpCameraHandler ipCameraHandler;\n+    String requestUrl = \"Empty\";\n+\n+    public InstarHandler(ThingHandler thingHandler) {\n+        ipCameraHandler = (IpCameraHandler) thingHandler;\n+    }\n+\n+    public void setURL(String url) {\n+        requestUrl = url;\n+    }\n+\n+    // This handles the incoming http replies back from the camera.\n+    @Override\n+    public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+        if (msg == null || ctx == null) {\n+            return;\n+        }\n+        String content = \"\";\n+        String value1 = \"\";\n+        try {\n+            content = msg.toString();\n+            if (content.isEmpty()) {\n+                return;\n+            }\n+            // ipCameraHandler.logger.trace(\"HTTP Result back from camera is \\t:{}:\", content);\n+            switch (requestUrl) {\n+                case \"/param.cgi?cmd=getinfrared\":\n+                    if (content.contains(\"var infraredstat=\\\"auto\")) {\n+                        ipCameraHandler.setChannelState(CHANNEL_AUTO_LED, OnOffType.valueOf(\"ON\"));\n+                    } else {\n+                        ipCameraHandler.setChannelState(CHANNEL_AUTO_LED, OnOffType.valueOf(\"OFF\"));\n+                    }\n+                    break;\n+                case \"/param.cgi?cmd=getoverlayattr&-region=1\":// Text Overlays\n+                    if (content.contains(\"var show_1=\\\"0\\\"\")) {\n+                        ipCameraHandler.setChannelState(CHANNEL_TEXT_OVERLAY, StringType.valueOf(\"\"));\n+                    } else {\n+                        value1 = searchString(content, \"var name_1=\\\"\");\n+                        if (!value1.isEmpty()) {\n+                            ipCameraHandler.setChannelState(CHANNEL_TEXT_OVERLAY, StringType.valueOf(value1));\n+                        }\n+                    }\n+                    break;\n+                case \"/cgi-bin/hi3510/param.cgi?cmd=getmdattr\":// Motion Alarm\n+                    // Motion Alarm\n+                    if (content.contains(\"var m1_enable=\\\"1\\\"\")) {\n+                        ipCameraHandler.setChannelState(CHANNEL_ENABLE_MOTION_ALARM, OnOffType.valueOf(\"ON\"));\n+                    } else {\n+                        ipCameraHandler.setChannelState(CHANNEL_ENABLE_MOTION_ALARM, OnOffType.valueOf(\"OFF\"));\n+                    }\n+                    break;\n+                case \"/cgi-bin/hi3510/param.cgi?cmd=getaudioalarmattr\":// Audio Alarm\n+                    if (content.contains(\"var aa_enable=\\\"1\\\"\")) {\n+                        ipCameraHandler.setChannelState(CHANNEL_ENABLE_AUDIO_ALARM, OnOffType.valueOf(\"ON\"));\n+                        value1 = searchString(content, \"var aa_value=\\\"\");\n+                        if (!value1.isEmpty()) {\n+                            // ipCameraHandler.logger.debug(\"Threshold is changing to {}\", value1);\n+                            ipCameraHandler.setChannelState(CHANNEL_THRESHOLD_AUDIO_ALARM, PercentType.valueOf(value1));\n+                        }\n+                    } else {\n+                        ipCameraHandler.setChannelState(CHANNEL_ENABLE_AUDIO_ALARM, OnOffType.valueOf(\"OFF\"));\n+                    }\n+                    break;\n+                case \"param.cgi?cmd=getpirattr\":// PIR Alarm\n+                    if (content.contains(\"var pir_enable=\\\"1\\\"\")) {\n+                        ipCameraHandler.setChannelState(CHANNEL_ENABLE_PIR_ALARM, OnOffType.valueOf(\"ON\"));\n+                    } else {\n+                        ipCameraHandler.setChannelState(CHANNEL_ENABLE_PIR_ALARM, OnOffType.valueOf(\"OFF\"));\n+                    }\n+                    // Reset the Alarm, need to find better place to put this.\n+                    ipCameraHandler.noMotionDetected(CHANNEL_PIR_ALARM);\n+                    break;\n+                case \"/param.cgi?cmd=getioattr\":// External Alarm Input\n+                    if (content.contains(\"var io_enable=\\\"1\\\"\")) {\n+                        ipCameraHandler.setChannelState(CHANNEL_ENABLE_EXTERNAL_ALARM_INPUT, OnOffType.valueOf(\"ON\"));\n+                    } else {\n+                        ipCameraHandler.setChannelState(CHANNEL_ENABLE_EXTERNAL_ALARM_INPUT, OnOffType.valueOf(\"OFF\"));\n+                    }\n+                    break;\n+            }\n+        } finally {\n+            ReferenceCountUtil.release(msg);\n+        }\n+    }\n+\n+    /**\n+     * The {@link searchString} Used to grab values out of JSON or other quote encapsulated structures without needing\n+     * an external lib. String may be terminated by ,\" or }.\n+     *\n+     * @author Matthew Skinner - Initial contribution\n+     */\n+    String searchString(String rawString, String searchedString) {", "originalCommit": "13f2b7e4312aa5389244f4a45b653798d3b4c355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAzNDI5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r481034290", "bodyText": "Done", "author": "Skinah", "createdAt": "2020-09-01T10:22:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3NTAzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3NTczMA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r480375730", "bodyText": "This method should be refactored as well.", "author": "cpmeister", "createdAt": "2020-08-31T20:18:20Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/DahuaHandler.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.ipcamera.handler.IpCameraHandler;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * The {@link DahuaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class DahuaHandler extends ChannelDuplexHandler {\n+    IpCameraHandler ipCameraHandler;\n+    String nvrChannel;\n+\n+    public DahuaHandler(IpCameraHandler handler, String nvrChannel) {\n+        ipCameraHandler = handler;\n+        this.nvrChannel = nvrChannel;\n+    }\n+\n+    // This handles the incoming http replies back from the camera.\n+    @Override\n+    public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+        if (msg == null || ctx == null) {\n+            return;\n+        }\n+        String content = null;\n+        try {\n+            content = msg.toString();\n+            if (!content.isEmpty()) {\n+                ipCameraHandler.logger.trace(\"HTTP Result back from camera is \\t:{}:\", content);\n+            }\n+            // determine if the motion detection is turned on or off.\n+            if (content.contains(\"table.MotionDetect[0].Enable=true\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_MOTION_ALARM, OnOffType.valueOf(\"ON\"));\n+            } else if (content.contains(\"table.MotionDetect[\" + nvrChannel + \"].Enable=false\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_MOTION_ALARM, OnOffType.valueOf(\"OFF\"));\n+            }\n+            // Handle motion alarm\n+            if (content.contains(\"Code=VideoMotion;action=Start;index=0\")) {\n+                ipCameraHandler.motionDetected(CHANNEL_MOTION_ALARM);\n+            } else if (content.contains(\"Code=VideoMotion;action=Stop;index=0\")) {\n+                ipCameraHandler.noMotionDetected(CHANNEL_MOTION_ALARM);\n+            }\n+            // Handle item taken alarm\n+            if (content.contains(\"Code=TakenAwayDetection;action=Start;index=0\")) {\n+                ipCameraHandler.motionDetected(CHANNEL_ITEM_TAKEN);\n+            } else if (content.contains(\"Code=TakenAwayDetection;action=Stop;index=0\")) {\n+                ipCameraHandler.noMotionDetected(CHANNEL_ITEM_TAKEN);\n+            }\n+            // Handle item left alarm\n+            if (content.contains(\"Code=LeftDetection;action=Start;index=0\")) {\n+                ipCameraHandler.motionDetected(CHANNEL_ITEM_LEFT);\n+            } else if (content.contains(\"Code=LeftDetection;action=Stop;index=0\")) {\n+                ipCameraHandler.noMotionDetected(CHANNEL_ITEM_LEFT);\n+            }\n+            // Handle CrossLineDetection alarm\n+            if (content.contains(\"Code=CrossLineDetection;action=Start;index=0\")) {\n+                ipCameraHandler.motionDetected(CHANNEL_LINE_CROSSING_ALARM);\n+            } else if (content.contains(\"Code=CrossLineDetection;action=Stop;index=0\")) {\n+                ipCameraHandler.noMotionDetected(CHANNEL_LINE_CROSSING_ALARM);\n+            }\n+            // determine if the audio alarm is turned on or off.\n+            if (content.contains(\"table.AudioDetect[0].MutationDetect=true\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_AUDIO_ALARM, OnOffType.valueOf(\"ON\"));\n+            } else if (content.contains(\"table.AudioDetect[0].MutationDetect=false\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_AUDIO_ALARM, OnOffType.valueOf(\"OFF\"));\n+            }\n+            // Handle AudioMutation alarm\n+            if (content.contains(\"Code=AudioMutation;action=Start;index=0\")) {\n+                ipCameraHandler.audioDetected();\n+            } else if (content.contains(\"Code=AudioMutation;action=Stop;index=0\")) {\n+                ipCameraHandler.noAudioDetected();\n+            }\n+            // Handle AudioMutationThreshold alarm\n+            if (content.contains(\"table.AudioDetect[0].MutationThreold=\")) {\n+                String value = ipCameraHandler.returnValueFromString(content, \"table.AudioDetect[0].MutationThreold=\");\n+                ipCameraHandler.setChannelState(CHANNEL_THRESHOLD_AUDIO_ALARM, PercentType.valueOf(value));\n+            }\n+            // Handle FaceDetection alarm\n+            if (content.contains(\"Code=FaceDetection;action=Start;index=0\")) {\n+                ipCameraHandler.motionDetected(CHANNEL_FACE_DETECTED);\n+            } else if (content.contains(\"Code=FaceDetection;action=Stop;index=0\")) {\n+                ipCameraHandler.noMotionDetected(CHANNEL_FACE_DETECTED);\n+            }\n+            // Handle ParkingDetection alarm\n+            if (content.contains(\"Code=ParkingDetection;action=Start;index=0\")) {\n+                ipCameraHandler.motionDetected(CHANNEL_PARKING_ALARM);\n+            } else if (content.contains(\"Code=ParkingDetection;action=Stop;index=0\")) {\n+                ipCameraHandler.noMotionDetected(CHANNEL_PARKING_ALARM);\n+            }\n+            // Handle CrossRegionDetection alarm\n+            if (content.contains(\"Code=CrossRegionDetection;action=Start;index=0\")) {\n+                ipCameraHandler.motionDetected(CHANNEL_FIELD_DETECTION_ALARM);\n+            } else if (content.contains(\"Code=CrossRegionDetection;action=Stop;index=0\")) {\n+                ipCameraHandler.noMotionDetected(CHANNEL_FIELD_DETECTION_ALARM);\n+            }\n+            // Handle External Input alarm\n+            if (content.contains(\"Code=AlarmLocal;action=Start;index=0\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_EXTERNAL_ALARM_INPUT, OnOffType.valueOf(\"ON\"));\n+            } else if (content.contains(\"Code=AlarmLocal;action=Stop;index=0\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_EXTERNAL_ALARM_INPUT, OnOffType.valueOf(\"OFF\"));\n+            }\n+            // Handle External Input alarm2\n+            if (content.contains(\"Code=AlarmLocal;action=Start;index=1\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_EXTERNAL_ALARM_INPUT2, OnOffType.valueOf(\"ON\"));\n+            } else if (content.contains(\"Code=AlarmLocal;action=Stop;index=1\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_EXTERNAL_ALARM_INPUT2, OnOffType.valueOf(\"OFF\"));\n+            }\n+            // CrossLineDetection alarm on/off\n+            if (content.contains(\"table.VideoAnalyseRule[0][1].Enable=true\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_LINE_CROSSING_ALARM, OnOffType.valueOf(\"ON\"));\n+            } else if (content.contains(\"table.VideoAnalyseRule[0][1].Enable=false\")) {\n+                ipCameraHandler.setChannelState(CHANNEL_ENABLE_LINE_CROSSING_ALARM, OnOffType.valueOf(\"OFF\"));\n+            }\n+        } finally {\n+            ReferenceCountUtil.release(msg);\n+            content = null;\n+        }\n+    }\n+\n+    public String encodeSpecialChars(String text) {", "originalCommit": "13f2b7e4312aa5389244f4a45b653798d3b4c355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAzNDQxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r481034415", "bodyText": "Done", "author": "Skinah", "createdAt": "2020-09-01T10:22:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3NTczMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3Njk4NA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r480376984", "bodyText": "Is this class used?", "author": "cpmeister", "createdAt": "2020-08-31T20:20:49Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/IpCameraConfiguration.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link IpCameraConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraConfiguration {", "originalCommit": "13f2b7e4312aa5389244f4a45b653798d3b4c355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwMTM0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r480901348", "bodyText": "Fixed: removed class/file.", "author": "Skinah", "createdAt": "2020-09-01T07:07:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3Njk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3ODU2OA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r480378568", "bodyText": "Java will automatically handle garbage collection, so these null assignments are unnecessary. You should remove them.", "author": "cpmeister", "createdAt": "2020-08-31T20:23:57Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/MyNettyAuthHandler.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Random;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.ipcamera.handler.IpCameraHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.http.HttpResponse;\n+\n+/**\n+ * The {@link MyNettyAuthHandler} is responsible for handling the basic and digest auths\n+ *\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class MyNettyAuthHandler extends ChannelDuplexHandler {\n+\n+    private Logger logger = LoggerFactory.getLogger(getClass());\n+    private IpCameraHandler myHandler;\n+    private String username, password;\n+    private String httpMethod = \"\", httpUrl = \"\";\n+    private byte ncCounter = 0;\n+    private String nonce = \"\", opaque = \"\", qop = \"\";\n+    private String realm = \"\";\n+\n+    public MyNettyAuthHandler(String user, String pass, String method, String url, ThingHandler handle) {\n+        myHandler = (IpCameraHandler) handle;\n+        username = user;\n+        password = pass;\n+        httpUrl = url;\n+        httpMethod = method;\n+    }\n+\n+    public MyNettyAuthHandler(String user, String pass, ThingHandler handle) {\n+        myHandler = (IpCameraHandler) handle;\n+        username = user;\n+        password = pass;\n+    }\n+\n+    public void setURL(String method, String url) {\n+        httpUrl = url;\n+        httpMethod = method;\n+    }\n+\n+    private String calcMD5Hash(String toHash) {\n+        try {\n+            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n+            byte[] array = messageDigest.digest(toHash.getBytes());\n+            StringBuffer stringBuffer = new StringBuffer();\n+            for (int i = 0; i < array.length; ++i) {\n+                stringBuffer.append(Integer.toHexString((array[i] & 0xFF) | 0x100).substring(1, 3));\n+            }\n+            messageDigest = null;\n+            array = null;", "originalCommit": "13f2b7e4312aa5389244f4a45b653798d3b4c355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg5OTk2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r480899963", "bodyText": "Done, went through all files and removed a small number.", "author": "Skinah", "createdAt": "2020-09-01T07:06:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3ODU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4MDIwMw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r480380203", "bodyText": "Is the information logged here necessary for the average user to see? If not then I suggest changing the logging level to debug.", "author": "cpmeister", "createdAt": "2020-08-31T20:27:09Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/RtspHandler.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import java.net.InetSocketAddress;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.http.DefaultHttpRequest;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.rtsp.RtspDecoder;\n+import io.netty.handler.codec.rtsp.RtspEncoder;\n+import io.netty.handler.codec.rtsp.RtspHeaderNames;\n+import io.netty.handler.codec.rtsp.RtspMethods;\n+import io.netty.handler.codec.rtsp.RtspVersions;\n+import io.netty.util.CharsetUtil;\n+\n+/**\n+ * The {@link RtspHandler} is a WIP and is currently not used. Soon will be able to report what format the stream is in\n+ * mjpeg\n+ * or H.264/5.\n+ *\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class RtspHandler extends ChannelDuplexHandler {\n+    @Nullable\n+    private Bootstrap rtspBootstrap;\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private String ipAddress = \"todo\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    RtspHandler() {\n+        // todo may need to pass in IP of camera plus a few others to make this code\n+        // work again.\n+    }\n+\n+    public HttpRequest getRTSPoptions(String rtspURL) {\n+        HttpRequest request = new DefaultHttpRequest(RtspVersions.RTSP_1_0, RtspMethods.OPTIONS, rtspURL);\n+        request.headers().add(RtspHeaderNames.CSEQ, \"1\");\n+        return request;\n+    }\n+\n+    public HttpRequest getRTSPdescribe(String rtspURL) {\n+        HttpRequest request = new DefaultHttpRequest(RtspVersions.RTSP_1_0, RtspMethods.DESCRIBE, rtspURL);\n+        request.headers().add(RtspHeaderNames.CSEQ, \"2\");\n+        return request;\n+    }\n+\n+    public HttpRequest getRTSPsetup(String rtspURL) {\n+        HttpRequest request = new DefaultHttpRequest(RtspVersions.RTSP_1_0, RtspMethods.SETUP, rtspURL);\n+        request.headers().add(RtspHeaderNames.CSEQ, \"3\");\n+        request.headers().add(RtspHeaderNames.TRANSPORT, \"RTP/AVP;unicast;client_port=5000-5001\");\n+        return request;\n+    }\n+\n+    public HttpRequest getRTSPplay(String rtspURL) {\n+        HttpRequest request = new DefaultHttpRequest(RtspVersions.RTSP_1_0, RtspMethods.PLAY, rtspURL);\n+        request.headers().add(RtspHeaderNames.CSEQ, \"4\");\n+        request.headers().add(RtspHeaderNames.SESSION, \"12345678\"); // need session number to match that of setup\n+        return request;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void setupRTSP() {\n+        if (rtspBootstrap == null) {\n+            rtspBootstrap = new Bootstrap();\n+            rtspBootstrap.group(mainEventLoopGroup);\n+            rtspBootstrap.channel(NioSocketChannel.class);\n+            rtspBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            rtspBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            rtspBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            rtspBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            rtspBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            rtspBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18,\n+                    // 0, 0));\n+                    socketChannel.pipeline().addLast(\"RtspDecoder\", new RtspDecoder());\n+                    socketChannel.pipeline().addLast(\"RtspEncoder\", new RtspEncoder());\n+                    socketChannel.pipeline().addLast(\"myRTSPHandler\", new RtspHandler());\n+                }\n+            });\n+        }\n+\n+        ChannelFuture chFuture = rtspBootstrap.connect(new InetSocketAddress(ipAddress, 554));\n+        chFuture.awaitUninterruptibly(); // ChannelOption.CONNECT_TIMEOUT_MILLIS means this will not hang here\n+        if (!chFuture.isSuccess()) {\n+            logger.debug(\"!!!! RTSP could not open channel.\");\n+        }\n+        Channel ch = chFuture.channel();\n+\n+        ch.writeAndFlush(getRTSPoptions(\n+                \"rtsp://192.168.xx.xx:554/cam/realmonitor?channel=1&subtype=1&unicast=true&proto=Onvif/\"));\n+        // returns this:\n+        // RTSP/1.0 200 OK\n+        // CSeq: 1\n+        // Server: Rtsp Server/3.0\n+        // Public: OPTIONS, DESCRIBE, ANNOUNCE, SETUP, PLAY, RECORD, PAUSE, TEARDOWN,\n+        // SET_PARAMETER, GET_PARAMETER\n+\n+        // ch.writeAndFlush(getRTSPdescribe(rtspUri));\n+        // returns this:\n+        // RTSP/1.0 200 OK\n+        // CSeq: 2\n+        // x-Accept-Dynamic-Rate: 1\n+        // Content-Base:\n+        // rtsp://192.168.xx.xx:554/cam/realmonitor?channel=1&subtype=1&unicast=true&proto=Onvif/\n+        // Cache-Control: must-revalidate\n+        // Content-Length: 582\n+        // Content-Type: application/sdp\n+\n+        // ch.writeAndFlush(getRTSPsetup(rtspUri));\n+        // ch.writeAndFlush(getRTSPplay(rtspUri));\n+\n+        // Cleanup\n+        chFuture = null;\n+    }\n+\n+    @Override\n+    public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+        if (msg == null) {\n+            return;\n+        }\n+\n+        logger.info(\"{}\", msg.toString());\n+\n+        if (msg instanceof HttpContent) {\n+            HttpContent content = (HttpContent) msg;\n+            String detail = content.content().toString(CharsetUtil.UTF_8);\n+            logger.info(\"detail is {}\", detail);", "originalCommit": "13f2b7e4312aa5389244f4a45b653798d3b4c355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwMzkxOA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r480903918", "bodyText": "Done: Removed the info logs as not needed.", "author": "Skinah", "createdAt": "2020-09-01T07:11:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4MDIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4MDk3NA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r480380974", "bodyText": "These logging statements provide no useful addition information with regards to debugging, so either remove them or change their logging level to trace.", "author": "cpmeister", "createdAt": "2020-08-31T20:28:47Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/internal/RtspHandler.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.internal;\n+\n+import java.net.InetSocketAddress;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.http.DefaultHttpRequest;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.rtsp.RtspDecoder;\n+import io.netty.handler.codec.rtsp.RtspEncoder;\n+import io.netty.handler.codec.rtsp.RtspHeaderNames;\n+import io.netty.handler.codec.rtsp.RtspMethods;\n+import io.netty.handler.codec.rtsp.RtspVersions;\n+import io.netty.util.CharsetUtil;\n+\n+/**\n+ * The {@link RtspHandler} is a WIP and is currently not used. Soon will be able to report what format the stream is in\n+ * mjpeg\n+ * or H.264/5.\n+ *\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class RtspHandler extends ChannelDuplexHandler {\n+    @Nullable\n+    private Bootstrap rtspBootstrap;\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private String ipAddress = \"todo\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    RtspHandler() {\n+        // todo may need to pass in IP of camera plus a few others to make this code\n+        // work again.\n+    }\n+\n+    public HttpRequest getRTSPoptions(String rtspURL) {\n+        HttpRequest request = new DefaultHttpRequest(RtspVersions.RTSP_1_0, RtspMethods.OPTIONS, rtspURL);\n+        request.headers().add(RtspHeaderNames.CSEQ, \"1\");\n+        return request;\n+    }\n+\n+    public HttpRequest getRTSPdescribe(String rtspURL) {\n+        HttpRequest request = new DefaultHttpRequest(RtspVersions.RTSP_1_0, RtspMethods.DESCRIBE, rtspURL);\n+        request.headers().add(RtspHeaderNames.CSEQ, \"2\");\n+        return request;\n+    }\n+\n+    public HttpRequest getRTSPsetup(String rtspURL) {\n+        HttpRequest request = new DefaultHttpRequest(RtspVersions.RTSP_1_0, RtspMethods.SETUP, rtspURL);\n+        request.headers().add(RtspHeaderNames.CSEQ, \"3\");\n+        request.headers().add(RtspHeaderNames.TRANSPORT, \"RTP/AVP;unicast;client_port=5000-5001\");\n+        return request;\n+    }\n+\n+    public HttpRequest getRTSPplay(String rtspURL) {\n+        HttpRequest request = new DefaultHttpRequest(RtspVersions.RTSP_1_0, RtspMethods.PLAY, rtspURL);\n+        request.headers().add(RtspHeaderNames.CSEQ, \"4\");\n+        request.headers().add(RtspHeaderNames.SESSION, \"12345678\"); // need session number to match that of setup\n+        return request;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void setupRTSP() {\n+        if (rtspBootstrap == null) {\n+            rtspBootstrap = new Bootstrap();\n+            rtspBootstrap.group(mainEventLoopGroup);\n+            rtspBootstrap.channel(NioSocketChannel.class);\n+            rtspBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            rtspBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            rtspBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            rtspBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            rtspBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            rtspBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18,\n+                    // 0, 0));\n+                    socketChannel.pipeline().addLast(\"RtspDecoder\", new RtspDecoder());\n+                    socketChannel.pipeline().addLast(\"RtspEncoder\", new RtspEncoder());\n+                    socketChannel.pipeline().addLast(\"myRTSPHandler\", new RtspHandler());\n+                }\n+            });\n+        }\n+\n+        ChannelFuture chFuture = rtspBootstrap.connect(new InetSocketAddress(ipAddress, 554));\n+        chFuture.awaitUninterruptibly(); // ChannelOption.CONNECT_TIMEOUT_MILLIS means this will not hang here\n+        if (!chFuture.isSuccess()) {\n+            logger.debug(\"!!!! RTSP could not open channel.\");\n+        }\n+        Channel ch = chFuture.channel();\n+\n+        ch.writeAndFlush(getRTSPoptions(\n+                \"rtsp://192.168.xx.xx:554/cam/realmonitor?channel=1&subtype=1&unicast=true&proto=Onvif/\"));\n+        // returns this:\n+        // RTSP/1.0 200 OK\n+        // CSeq: 1\n+        // Server: Rtsp Server/3.0\n+        // Public: OPTIONS, DESCRIBE, ANNOUNCE, SETUP, PLAY, RECORD, PAUSE, TEARDOWN,\n+        // SET_PARAMETER, GET_PARAMETER\n+\n+        // ch.writeAndFlush(getRTSPdescribe(rtspUri));\n+        // returns this:\n+        // RTSP/1.0 200 OK\n+        // CSeq: 2\n+        // x-Accept-Dynamic-Rate: 1\n+        // Content-Base:\n+        // rtsp://192.168.xx.xx:554/cam/realmonitor?channel=1&subtype=1&unicast=true&proto=Onvif/\n+        // Cache-Control: must-revalidate\n+        // Content-Length: 582\n+        // Content-Type: application/sdp\n+\n+        // ch.writeAndFlush(getRTSPsetup(rtspUri));\n+        // ch.writeAndFlush(getRTSPplay(rtspUri));\n+\n+        // Cleanup\n+        chFuture = null;\n+    }\n+\n+    @Override\n+    public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+        if (msg == null) {\n+            return;\n+        }\n+\n+        logger.info(\"{}\", msg.toString());\n+\n+        if (msg instanceof HttpContent) {\n+            HttpContent content = (HttpContent) msg;\n+            String detail = content.content().toString(CharsetUtil.UTF_8);\n+            logger.info(\"detail is {}\", detail);\n+        }\n+    }\n+\n+    @Override\n+    public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+    }\n+\n+    @Override\n+    public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        logger.debug(\"RTSP handler just created now\");\n+    }\n+\n+    @Override\n+    public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+        logger.debug(\"RTSP handler removed just now\");", "originalCommit": "13f2b7e4312aa5389244f4a45b653798d3b4c355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwNDQ1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r480904456", "bodyText": "FIXED: removed.", "author": "Skinah", "createdAt": "2020-09-01T07:11:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4MDk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4NDI1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r480384254", "bodyText": "It is best to eliminate code duplication where possible.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (\"PUT\".equals(httpMethod)) {\n          \n          \n            \n                        if (useDigestAuth && digestString == null) {\n          \n          \n            \n                            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n          \n          \n            \n                            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n          \n          \n            \n                            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n          \n          \n            \n                        } else {\n          \n          \n            \n                            request = putRequestWithBody;\n          \n          \n            \n                        }\n          \n          \n            \n                    } else {\n          \n          \n            \n                        request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n          \n          \n            \n                        request.headers().set(HttpHeaderNames.HOST, ipAddress);\n          \n          \n            \n                        request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n          \n          \n            \n                    }\n          \n          \n            \n                    if (!\"PUT\".equals(httpMethod) || (useDigestAuth && digestString == null)) {\n          \n          \n            \n                        request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n          \n          \n            \n                        request.headers().set(HttpHeaderNames.HOST, ipAddress);\n          \n          \n            \n                        request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n          \n          \n            \n                    } else {\n          \n          \n            \n                        request = putRequestWithBody;\n          \n          \n            \n                    }", "author": "cpmeister", "createdAt": "2020-08-31T20:35:35Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,1999 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Open and OK to reuse\n+                    case 1: // Open\n+                    case 0: // Closing but still open\n+                        Channel channel = listOfChannels.get(index);\n+                        if (channel.isOpen()) {\n+                            break;\n+                        } else {\n+                            listOfChStatus.set(index, (byte) -1);\n+                            logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                        }\n+                    case -1: // closed\n+                        listOfRequests.remove(index);\n+                        listOfChStatus.remove(index);\n+                        listOfChannels.remove(index);\n+                        listOfReplies.remove(index);\n+                        index--;\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (\"PUT\".equals(httpMethod)) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }", "originalCommit": "13f2b7e4312aa5389244f4a45b653798d3b4c355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4NzEzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r480387135", "bodyText": "\"authHandler\" seems to be used in multiple places in the code so I suggest that you make it a static final field and reference it through the field instead, that way any naming changes would affect all relevant parts of the code as well as enforce consistency during compile time.\nYou should also do the same for the other pipeline names that are retrieved by name.", "author": "cpmeister", "createdAt": "2020-08-31T20:41:29Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,1999 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Open and OK to reuse\n+                    case 1: // Open\n+                    case 0: // Closing but still open\n+                        Channel channel = listOfChannels.get(index);\n+                        if (channel.isOpen()) {\n+                            break;\n+                        } else {\n+                            listOfChStatus.set(index, (byte) -1);\n+                            logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                        }\n+                    case -1: // closed\n+                        listOfRequests.remove(index);\n+                        listOfChStatus.remove(index);\n+                        listOfChannels.remove(index);\n+                        listOfReplies.remove(index);\n+                        index--;\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",", "originalCommit": "13f2b7e4312aa5389244f4a45b653798d3b4c355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2MDY3NA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r480960674", "bodyText": "Done", "author": "Skinah", "createdAt": "2020-09-01T08:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4NzEzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NTI5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r480395295", "bodyText": "Fields should be declared at the top of the class.", "author": "cpmeister", "createdAt": "2020-08-31T20:58:22Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,1999 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Open and OK to reuse\n+                    case 1: // Open\n+                    case 0: // Closing but still open\n+                        Channel channel = listOfChannels.get(index);\n+                        if (channel.isOpen()) {\n+                            break;\n+                        } else {\n+                            listOfChStatus.set(index, (byte) -1);\n+                            logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                        }\n+                    case -1: // closed\n+                        listOfRequests.remove(index);\n+                        listOfChStatus.remove(index);\n+                        listOfChannels.remove(index);\n+                        listOfReplies.remove(index);\n+                        index--;\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (\"PUT\".equals(httpMethod)) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot(byte[] incommingSnapshot) {\n+        lockCurrentSnapshot.lock();\n+        try {\n+            currentSnapshot = incommingSnapshot;\n+            if (preroll > 0) {\n+                fifoSnapshotBuffer.add(incommingSnapshot);\n+                if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                    fifoSnapshotBuffer.removeFirst();\n+                }\n+            }\n+        } finally {\n+            lockCurrentSnapshot.unlock();\n+        }\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(incommingSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(incommingSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                // only happens every 8 seconds as some browsers need a frame that often to keep stream alive.\n+                sendMjpegFrame(incommingSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+    }\n+\n+    // These methods handle the response from all camera brands, nothing specific to\n+    // any brand should be in here //\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                // logger.trace(\"{}\", msg.toString());\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                            if (closeConnection) {\n+                                lock.lock();\n+                                try {\n+                                    byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                    if (indexInLists >= 0) {\n+                                        listOfChStatus.set(indexInLists, (byte) 0);\n+                                    } else {\n+                                        logger.debug(\"!!!! Could not find the ch for a Connection: close URL:{}\",\n+                                                requestUrl);\n+                                    }\n+                                } finally {\n+                                    lock.unlock();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                processSnapshot(incomingJpeg);\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    // logger.trace(\"Snapshot recieved: Binding will now close the channel.\");\n+                                    ctx.close();\n+                                } else {\n+                                    lock.lock();\n+                                    try {\n+                                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                        if (indexInLists >= 0) {\n+                                            listOfChStatus.set(indexInLists, (byte) 2);\n+                                        }\n+                                    } finally {\n+                                        lock.unlock();\n+                                        bytesToRecieve = 0;\n+                                        bytesAlreadyRecieved = 0;\n+                                    }\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.equals(\"\")) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // logger.debug(\"Packet back from camera is not matching HttpContent\");\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+            if (ctx == null) {\n+                return;\n+            }\n+            lock.lock();\n+            try {\n+                byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                if (indexInLists >= 0) {\n+                    // logger.debug(\"commonCameraHandler closed channel:{} \\tURL:{}\", indexInLists, requestUrl);\n+                    listOfChStatus.set(indexInLists, (byte) -1);\n+                } else {\n+                    if (listOfChannels.size() > 0) {\n+                        logger.warn(\"Can't find ch when removing handler \\t\\tURL:{}\", requestUrl);\n+                    }\n+                }\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause instanceof ArrayIndexOutOfBoundsException) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                        if (indexInLists >= 0) {\n+                            String urlToKeepOpen;\n+                            switch (thing.getThingTypeUID().getId()) {\n+                                case \"DAHUA\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"HIKVISION\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/ISAPI/Event/notification/alertStream\".contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"DOORBIRD\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/bha-api/monitor.cgi?ring=doorbell,motionsensor\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                            }\n+                            logger.debug(\"! Channel was found idle for more than 15 seconds so closing it down. !\");\n+                            listOfChStatus.set(indexInLists, (byte) 0);\n+                        } else {\n+                            logger.warn(\"!?! Channel that was found idle could not be located in our tracking. !?!\");\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.debug(\"File server for camera at {} has started on port {} for all NIC's.\", ipAddress,\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    cameraConfigError(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setupSnapshotStreaming(boolean stream, ChannelHandlerContext ctx, boolean auto) {\n+        if (stream) {\n+            sendMjpegFirstPacket(ctx);\n+            if (auto) {\n+                autoSnapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                try {\n+                    sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                    // iOS uses a FIFO? and needs two frames to display a pic\n+                    sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                } finally {\n+                    lockCurrentSnapshot.unlock();\n+                }\n+                streamingAutoFps = true;\n+            } else {\n+                snapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                try {\n+                    sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+                } finally {\n+                    lockCurrentSnapshot.unlock();\n+                }\n+                streamingSnapshotMjpeg = true;\n+                startSnapshotPolling();\n+            }\n+        } else {\n+            snapshotMjpegChannelGroup.remove(ctx.channel());\n+            autoSnapshotMjpegChannelGroup.remove(ctx.channel());\n+            if (streamingSnapshotMjpeg && snapshotMjpegChannelGroup.isEmpty()) {\n+                streamingSnapshotMjpeg = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All Snapshot based MJPEG streams have stopped.\");\n+            } else if (streamingAutoFps && autoSnapshotMjpegChannelGroup.isEmpty()) {\n+                streamingAutoFps = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All AutoFps Snapshot based MJPEG streams have stopped.\");\n+            }\n+        }\n+    }\n+\n+    // If start is true the CTX is added to the list to stream video to, false stops\n+    // the stream.\n+    public void setupMjpegStreaming(boolean start, ChannelHandlerContext ctx) {\n+        if (start) {\n+            if (mjpegChannelGroup.isEmpty()) {// first stream being requested.\n+                mjpegChannelGroup.add(ctx.channel());\n+                if (mjpegUri.equals(\"\") || mjpegUri.equals(\"ffmpeg\")) {\n+                    sendMjpegFirstPacket(ctx);\n+                    setupFfmpegFormat(\"MJPEG\");\n+                } else {\n+                    try {\n+                        // fix Dahua reboots when refreshing a mjpeg stream.\n+                        TimeUnit.MILLISECONDS.sleep(500);\n+                    } catch (InterruptedException e) {\n+                    }\n+                    sendHttpGET(mjpegUri);\n+                }\n+            } else if (ffmpegMjpeg != null) {// not first stream and we will use ffmpeg\n+                sendMjpegFirstPacket(ctx);\n+                mjpegChannelGroup.add(ctx.channel());\n+            } else {// not first stream and camera supplies the mjpeg source.\n+                ctx.channel().writeAndFlush(firstStreamedMsg);\n+                mjpegChannelGroup.add(ctx.channel());\n+            }\n+        } else {\n+            mjpegChannelGroup.remove(ctx.channel());\n+            if (mjpegChannelGroup.isEmpty()) {\n+                logger.debug(\"All Mjpeg streams have stopped, cleaning up now\");\n+                if (mjpegUri.equals(\"ffmpeg\")) {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                } else if (!mjpegUri.equals(\"\")) {\n+                    closeChannel(getTinyUrl(mjpegUri));\n+                } else {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // sends direct to ctx so can be either snapshots.mjpeg or normal mjpeg stream\n+    public void sendMjpegFirstPacket(ChannelHandlerContext ctx) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        String contentType = \"multipart/x-mixed-replace; boundary=\" + BOUNDARY;\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+        ctx.channel().writeAndFlush(response);\n+    }\n+\n+    public void sendMjpegFrame(byte[] jpg, ChannelGroup channelGroup) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        ByteBuf imageByteBuf = Unpooled.copiedBuffer(jpg);\n+        int length = imageByteBuf.readableBytes();\n+        String header = \"--\" + BOUNDARY + \"\\r\\n\" + \"content-type: image/jpeg\" + \"\\r\\n\" + \"content-length: \" + length\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuf headerBbuf = Unpooled.copiedBuffer(header, 0, header.length(), StandardCharsets.UTF_8);\n+        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+        streamToGroup(headerBbuf, channelGroup, false);\n+        streamToGroup(imageByteBuf, channelGroup, false);\n+        streamToGroup(footerBbuf, channelGroup, true);\n+    }\n+\n+    public void streamToGroup(Object msg, ChannelGroup channelGroup, boolean flush) {\n+        channelGroup.write(msg);\n+        if (flush) {\n+            channelGroup.flush();\n+        }\n+    }\n+\n+    private void storeSnapshots() {\n+        int count = 0;\n+        // Need to lock as fifoSnapshotBuffer is not thread safe and new snapshots can be incoming.\n+        lockCurrentSnapshot.lock();\n+        try {\n+            for (Object incomingJpeg : fifoSnapshotBuffer) {\n+                byte[] foo = (byte[]) incomingJpeg;\n+                File file = new File(ffmpegOutputFolder + \"snapshot\" + count + \".jpg\");\n+                count++;\n+                try {\n+                    OutputStream fos = new FileOutputStream(file);\n+                    fos.write(foo);\n+                    fos.close();\n+                } catch (FileNotFoundException e) {\n+                    logger.warn(\"FileNotFoundException {}\", e.getMessage());\n+                } catch (IOException e) {\n+                    logger.warn(\"IOException {}\", e.getMessage());\n+                }\n+            }\n+        } finally {\n+            lockCurrentSnapshot.unlock();\n+        }\n+    }\n+\n+    public void setupFfmpegFormat(String format) {\n+        String inOptions = \"\";\n+        if (ffmpegOutputFolder.equals(\"\")) {\n+            logger.warn(\"The camera tried to use a FFmpeg feature when the output folder is not set.\");\n+            return;\n+        }\n+        if (rtspUri.equals(\"\")) {\n+            logger.warn(\"The camera tried to use a FFmpeg feature when no valid input for FFmpeg is provided.\");\n+            return;\n+        }\n+        if (config.get(CONFIG_FFMPEG_LOCATION) == null) {\n+            logger.warn(\"The camera tried to use a FFmpeg feature when the location for FFmpeg is not known.\");\n+            return;\n+        }\n+\n+        // Make sure the folder exists, if not create it.\n+        new File(ffmpegOutputFolder).mkdirs();\n+        switch (format) {\n+            case \"HLS\":\n+                if (ffmpegHLS == null) {\n+                    if (rtspUri.contains(\":554\")) {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning -rtsp_transport tcp\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    } else {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    }\n+                }\n+                if (ffmpegHLS != null) {\n+                    ffmpegHLS.startConverting();\n+                }\n+                break;\n+            case \"GIF\":\n+                if (preroll > 0) {\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                            \"-y -r 1 -hide_banner -loglevel warning\", ffmpegOutputFolder + \"snapshot%d.jpg\",\n+                            \"-frames:v \" + (preroll + postroll) + \" \"\n+                                    + config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                } else {\n+                    inOptions = \"-y -t \" + postroll + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-y -t \" + postroll;\n+                    }\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                }\n+                if (preroll > 0) {\n+                    storeSnapshots();\n+                }\n+                if (ffmpegGIF != null) {\n+                    ffmpegGIF.startConverting();\n+                    if (gifHistory.equals(\"\")) {\n+                        gifHistory = gifFilename;\n+                    } else if (!gifFilename.equals(\"ipcamera\")) {\n+                        gifHistory = gifFilename + \",\" + gifHistory;\n+                        if (gifHistoryLength > 49) {\n+                            int endIndex = gifHistory.lastIndexOf(\",\");\n+                            gifHistory = gifHistory.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_GIF_HISTORY, new StringType(gifHistory));\n+                }\n+                break;\n+            case \"RECORD\":\n+                inOptions = \"-y -t \" + mp4RecordTime + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                if (!rtspUri.contains(\"rtsp\")) {\n+                    inOptions = \"-y -t \" + mp4RecordTime;\n+                }\n+                ffmpegRecord = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                        rtspUri, config.get(CONFIG_FFMPEG_MP4_OUT_ARGUMENTS).toString(),\n+                        ffmpegOutputFolder + mp4Filename + \".mp4\", username, password);\n+                if (mp4Preroll > 0) {\n+                    // fetchFromHLS(); todo: not done yet\n+                }\n+                if (ffmpegRecord != null) {\n+                    ffmpegRecord.startConverting();\n+                    if (mp4History.equals(\"\")) {\n+                        mp4History = mp4Filename;\n+                    } else if (!mp4Filename.equals(\"ipcamera\")) {\n+                        mp4History = mp4Filename + \",\" + mp4History;\n+                        if (mp4HistoryLength > 49) {\n+                            int endIndex = mp4History.lastIndexOf(\",\");\n+                            mp4History = mp4History.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_MP4_HISTORY, new StringType(mp4History));\n+                }\n+                break;\n+            case \"RTSPHELPER\":\n+                if (ffmpegRtspHelper != null) {\n+                    ffmpegRtspHelper.stopConverting();\n+                    if (!audioAlarmEnabled && !motionAlarmEnabled) {\n+                        return;\n+                    }\n+                }\n+                String input = (config.get(CONFIG_FFMPEG_MOTION_INPUT) == null) ? rtspUri\n+                        : config.get(CONFIG_FFMPEG_MOTION_INPUT).toString();\n+                String OutputOptions = \"-f null -\";\n+                String filterOptions = \"\";\n+                inOptions = \"-rtsp_transport tcp\";\n+                if (!input.contains(\"rtsp\")) {\n+                    inOptions = \"\";\n+                }\n+                if (audioAlarmEnabled == false) {\n+                    filterOptions = \"-an\";\n+                } else if (audioAlarmEnabled == true) {\n+                    filterOptions = \"-af silencedetect=n=-\" + audioThreshold + \"dB:d=2\";\n+                }\n+                if (motionAlarmEnabled == false && ffmpegSnapshotGeneration == false) {\n+                    filterOptions = filterOptions.concat(\" -vn\");\n+                } else if (motionAlarmEnabled == true) {\n+                    filterOptions = filterOptions\n+                            .concat(\" -vf select='gte(scene,\" + motionThreshold + \")',metadata=print\");\n+                }\n+                if (config.get(CONFIG_USERNAME) != null) {\n+                    filterOptions += \" \";// add space as the Framework does not allow spaces at start of config.\n+                }\n+                ffmpegRtspHelper = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                        input, filterOptions + config.get(CONFIG_FFMPEG_MOTION_ARGUMENTS), OutputOptions, username,\n+                        password);\n+                ffmpegRtspHelper.startConverting();\n+                break;\n+            case \"MJPEG\":\n+                if (ffmpegMjpeg == null) {\n+                    inOptions = \"-rtsp_transport tcp -hide_banner -loglevel warning\";\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegMjpeg = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, config.get(CONFIG_FFMPEG_MJPEG_ARGUMENTS).toString(),\n+                            \"http://127.0.0.1:\" + serverPort + \"/ipcamera.jpg\", username, password);\n+                }\n+                if (ffmpegMjpeg != null) {\n+                    ffmpegMjpeg.startConverting();\n+                }\n+                break;\n+            case \"SNAPSHOT\":\n+                // if mjpeg stream you can use ffmpeg -i input.h264 -codec:v copy -bsf:v mjpeg2jpeg output%03d.jpg\n+                if (ffmpegSnapshot == null) {\n+                    inOptions = \"-rtsp_transport tcp -threads 1 -skip_frame nokey -hide_banner -loglevel warning\";// iFrames\n+                                                                                                                  // only\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-threads 1 -skip_frame nokey -hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegSnapshot = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, \"-an -vsync vfr -update 1\", \"http://127.0.0.1:\" + serverPort + \"/snapshot.jpg\",\n+                            username, password);\n+                }\n+                if (ffmpegSnapshot != null) {\n+                    ffmpegSnapshot.startConverting();\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void noMotionDetected(String thisAlarmsChannel) {\n+        setChannelState(thisAlarmsChannel, OnOffType.OFF);\n+        firstMotionAlarm = false;\n+        motionAlarmUpdateSnapshot = false;\n+        motionDetected = false;\n+        if (streamingAutoFps) {\n+            stopSnapshotPolling();\n+        } else if (updateImageEvents.contains(\"4\")) { // During Motion Alarms\n+            stopSnapshotPolling();\n+        }\n+    }\n+\n+    // Change alarms that are not counted as motion detecting.\n+    public void changeAlarmState(String thisAlarmsChannel, String state) {\n+        updateState(thisAlarmsChannel, OnOffType.valueOf(state));\n+    }\n+\n+    public void motionDetected(String thisAlarmsChannel) {\n+        updateState(CHANNEL_LAST_MOTION_TYPE, new StringType(thisAlarmsChannel));\n+        updateState(thisAlarmsChannel, OnOffType.ON);\n+        motionDetected = true;\n+        if (streamingAutoFps) {\n+            startSnapshotPolling();\n+        }\n+        if (updateImageEvents.contains(\"2\")) {\n+            if (!firstMotionAlarm) {\n+                if (!snapshotUri.isEmpty()) {\n+                    sendHttpGET(snapshotUri);\n+                }\n+                firstMotionAlarm = true;// reset back to false when the jpg arrives.\n+            }\n+        } else if (updateImageEvents.contains(\"4\")) { // During Motion Alarms\n+            if (!snapshotPolling) {\n+                startSnapshotPolling();\n+            }\n+            firstMotionAlarm = true;\n+            motionAlarmUpdateSnapshot = true;\n+        }\n+    }\n+\n+    public void audioDetected() {\n+        updateState(CHANNEL_AUDIO_ALARM, OnOffType.ON);\n+        if (updateImageEvents.contains(\"3\")) {\n+            if (!firstAudioAlarm) {\n+                if (!snapshotUri.isEmpty()) {\n+                    sendHttpGET(snapshotUri);\n+                }\n+                firstAudioAlarm = true;// reset back to false when the jpg arrives.\n+            }\n+        } else if (updateImageEvents.contains(\"5\")) {// During audio alarms\n+            firstAudioAlarm = true;\n+            audioAlarmUpdateSnapshot = true;\n+        }\n+    }\n+\n+    public void noAudioDetected() {\n+        setChannelState(CHANNEL_AUDIO_ALARM, OnOffType.OFF);\n+        firstAudioAlarm = false;\n+        audioAlarmUpdateSnapshot = false;\n+    }\n+\n+    public String returnValueFromString(String rawString, String searchedString) {\n+        String result = \"\";\n+        int index = rawString.indexOf(searchedString);\n+        if (index != -1) // -1 means \"not found\"\n+        {\n+            result = rawString.substring(index + searchedString.length(), rawString.length());\n+            index = result.indexOf(\"\\r\\n\"); // find a carriage return to find the end of the value.\n+            if (index == -1) {\n+                return result; // Did not find a carriage return.\n+            } else {\n+                return result.substring(0, index);\n+            }\n+        }\n+        return \"\"; // Did not find the String we were searching for\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_PAN:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        updateState(CHANNEL_PAN, new PercentType(Math.round(onvifCamera.getAbsolutePan())));\n+                    }\n+                    return;\n+                case CHANNEL_TILT:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        updateState(CHANNEL_TILT, new PercentType(Math.round(onvifCamera.getAbsoluteTilt())));\n+                    }\n+                    return;\n+                case CHANNEL_ZOOM:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        updateState(CHANNEL_ZOOM, new PercentType(Math.round(onvifCamera.getAbsoluteZoom())));\n+                    }\n+                    return;\n+            }\n+        } // caution \"REFRESH\" can still progress to brand Handlers below the else.\n+        else {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MP4_HISTORY_LENGTH:\n+                    if (\"0\".equals(command.toString())) {\n+                        mp4HistoryLength = 0;\n+                        mp4History = \"\";\n+                        setChannelState(CHANNEL_MP4_HISTORY, new StringType(mp4History));\n+                    }\n+                    return;\n+                case CHANNEL_GIF_HISTORY_LENGTH:\n+                    if (\"0\".equals(command.toString())) {\n+                        gifHistoryLength = 0;\n+                        gifHistory = \"\";\n+                        setChannelState(CHANNEL_GIF_HISTORY, new StringType(gifHistory));\n+                    }\n+                    return;\n+                case CHANNEL_FFMPEG_MOTION_CONTROL:\n+                    if (\"ON\".equals(command.toString())) {\n+                        motionAlarmEnabled = true;\n+                    } else if (\"OFF\".equals(command.toString()) || \"0\".equals(command.toString())) {\n+                        motionAlarmEnabled = false;\n+                        noMotionDetected(CHANNEL_MOTION_ALARM);\n+                    } else {\n+                        motionAlarmEnabled = true;\n+                        motionThreshold = Double.valueOf(command.toString());\n+                        motionThreshold = motionThreshold / 10000;\n+                    }\n+                    setupFfmpegFormat(\"RTSPHELPER\");\n+                    return;\n+                case CHANNEL_GIF_FILENAME:\n+                    logger.debug(\"Changing the gif filename to {}.\", command);\n+                    gifFilename = command.toString();\n+                    if (gifFilename.isEmpty()) {\n+                        gifFilename = \"ipcamera\";\n+                    }\n+                    return;\n+                case CHANNEL_MP4_FILENAME:\n+                    logger.debug(\"Changing the mp4 filename to {}.\", command);\n+                    mp4Filename = command.toString();\n+                    if (mp4Filename.isEmpty()) {\n+                        mp4Filename = \"ipcamera\";\n+                    }\n+                    return;\n+                case CHANNEL_RECORD_MP4:\n+                    logger.debug(\"Recording {} Seconds to MP4 format.\", command);\n+                    mp4RecordTime = Integer.parseInt(command.toString());\n+                    setupFfmpegFormat(\"RECORD\");\n+                    return;\n+                case CHANNEL_START_STREAM:\n+                    if (\"ON\".equals(command.toString())) {\n+                        setupFfmpegFormat(\"HLS\");\n+                        if (ffmpegHLS != null) {\n+                            ffmpegHLS.setKeepAlive(-1);// will keep running till manually stopped.\n+                        }\n+                    } else {\n+                        if (ffmpegHLS != null) {\n+                            ffmpegHLS.setKeepAlive(1);\n+                        }\n+                    }\n+                    return;\n+                case CHANNEL_EXTERNAL_MOTION:\n+                    if (\"ON\".equals(command.toString())) {\n+                        motionDetected(CHANNEL_EXTERNAL_MOTION);\n+                    } else {\n+                        noMotionDetected(CHANNEL_EXTERNAL_MOTION);\n+                    }\n+                    return;\n+                case CHANNEL_GOTO_PRESET:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        onvifCamera.gotoPreset(Integer.valueOf(command.toString()));\n+                    }\n+                    return;\n+                case CHANNEL_UPDATE_IMAGE_NOW:\n+                    if (\"ON\".equals(command.toString())) {\n+                        if (snapshotUri.equals(\"\")) {\n+                            ffmpegSnapshotGeneration = true;\n+                            setupFfmpegFormat(\"SNAPSHOT\");\n+                            updateImageChannel = false;\n+                        } else {\n+                            updateImageChannel = true;\n+                            sendHttpGET(snapshotUri);// Allows this to change Image FPS on demand\n+                        }\n+                    } else {\n+                        if (ffmpegSnapshot != null) {\n+                            ffmpegSnapshot.stopConverting();\n+                            ffmpegSnapshotGeneration = false;\n+                        }\n+                        updateImageChannel = false;\n+                    }\n+                    return;\n+                case CHANNEL_UPDATE_GIF:\n+                    if (\"ON\".equals(command.toString())) {\n+                        if (preroll > 0) {\n+                            snapCount = postroll;\n+                        } else {\n+                            setupFfmpegFormat(\"GIF\");\n+                        }\n+                    }\n+                    return;\n+                case CHANNEL_PAN:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        if (command instanceof IncreaseDecreaseType) {\n+                            if (command == IncreaseDecreaseType.INCREASE) {\n+                                if ((boolean) config.get(CONFIG_PTZ_CONTINUOUS)) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveLeft\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveLeft\");\n+                                }\n+                            } else {\n+                                if ((boolean) config.get(CONFIG_PTZ_CONTINUOUS)) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveRight\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveRight\");\n+                                }\n+                            }\n+                            return;\n+                        } else if (\"OFF\".equals(command.toString())) {\n+                            onvifCamera.sendPTZRequest(\"Stop\");\n+                            return;\n+                        }\n+                        onvifCamera.setAbsolutePan(Float.valueOf(command.toString()));\n+                        scheduledMovePTZ.schedule(runnableMovePTZ, 500, TimeUnit.MILLISECONDS);\n+                    }\n+                    return;\n+                case CHANNEL_TILT:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        if (command instanceof IncreaseDecreaseType) {\n+                            if (\"INCREASE\".equals(command.toString())) {\n+                                if ((boolean) config.get(CONFIG_PTZ_CONTINUOUS)) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveUp\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveUp\");\n+                                }\n+                            } else {\n+                                if ((boolean) config.get(CONFIG_PTZ_CONTINUOUS)) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveDown\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveDown\");\n+                                }\n+                            }\n+                            return;\n+                        } else if (\"OFF\".equals(command.toString())) {\n+                            onvifCamera.sendPTZRequest(\"Stop\");\n+                            return;\n+                        }\n+                        onvifCamera.setAbsoluteTilt(Float.valueOf(command.toString()));\n+                        scheduledMovePTZ.schedule(runnableMovePTZ, 500, TimeUnit.MILLISECONDS);\n+                    }\n+                    return;\n+                case CHANNEL_ZOOM:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        if (command instanceof IncreaseDecreaseType) {\n+                            if (\"INCREASE\".equals(command.toString())) {\n+                                if ((boolean) config.get(CONFIG_PTZ_CONTINUOUS)) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveIn\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveIn\");\n+                                }\n+                            } else {\n+                                if ((boolean) config.get(CONFIG_PTZ_CONTINUOUS)) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveOut\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveOut\");\n+                                }\n+                            }\n+                            return;\n+                        } else if (\"OFF\".equals(command.toString())) {\n+                            onvifCamera.sendPTZRequest(\"Stop\");\n+                            return;\n+                        }\n+                        onvifCamera.setAbsoluteZoom(Float.valueOf(command.toString()));\n+                        scheduledMovePTZ.schedule(runnableMovePTZ, 500, TimeUnit.MILLISECONDS);\n+                    }\n+                    return;\n+            }\n+        }\n+        // commands and refresh now get passed to brand handlers\n+        switch (thing.getThingTypeUID().getId()) {\n+            case \"AMCREST\":\n+                AmcrestHandler amcrestHandler = new AmcrestHandler(getHandle());\n+                amcrestHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = amcrestHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            case \"DAHUA\":\n+                DahuaHandler dahuaHandler = new DahuaHandler(getHandle(), nvrChannel);\n+                dahuaHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = dahuaHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            case \"DOORBIRD\":\n+                DoorBirdHandler doorBirdHandler = new DoorBirdHandler(getHandle());\n+                doorBirdHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = doorBirdHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            case \"HIKVISION\":\n+                HikvisionHandler hikvisionHandler = new HikvisionHandler(getHandle(), nvrChannel);\n+                hikvisionHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = hikvisionHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            case \"FOSCAM\":\n+                FoscamHandler foscamHandler = new FoscamHandler(getHandle(), username, password);\n+                foscamHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = foscamHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            case \"INSTAR\":\n+                InstarHandler instarHandler = new InstarHandler(getHandle());\n+                instarHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = instarHandler.getLowPriorityRequests();\n+                }\n+                break;\n+            default:\n+                HttpOnlyHandler defaultHandler = new HttpOnlyHandler(getHandle());\n+                defaultHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = defaultHandler.getLowPriorityRequests();\n+                }\n+                break;\n+        }\n+    }\n+\n+    Runnable runnableMovePTZ = new Runnable() {\n+        @Override\n+        public void run() {\n+            logger.debug(\"Trying to move with new PTZ Absolute move.\");\n+            onvifCamera.sendPTZRequest(\"AbsoluteMove\");\n+        }\n+    };", "originalCommit": "13f2b7e4312aa5389244f4a45b653798d3b4c355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2NDg0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r480964848", "bodyText": "Done.", "author": "Skinah", "createdAt": "2020-09-01T08:30:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NTI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQxNDkzMg==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r480414932", "bodyText": "All of these switch statements look like identical code. You could simplify this by having each camera handler implement a common interface:\npublic interface BrandHandler {\n    public void handleCommand(ChannelUID channelUID, Command command);\n    public List<String> getLowPriorityRequests();\n}\n\n    brandHandler.handleCommand(channelUID, command);\n    if (lowPriorityRequests.isEmpty()) {\n        lowPriorityRequests = brandHandler.getLowPriorityRequests();\n    }\n\nYou might be able to refactor further by turning each of the brand handler classes into IPCameraHandler subclasses and just move their existing code into a nested classes. But you don't have to make such changes just yet if you don't want.", "author": "cpmeister", "createdAt": "2020-08-31T21:40:38Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,1999 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Open and OK to reuse\n+                    case 1: // Open\n+                    case 0: // Closing but still open\n+                        Channel channel = listOfChannels.get(index);\n+                        if (channel.isOpen()) {\n+                            break;\n+                        } else {\n+                            listOfChStatus.set(index, (byte) -1);\n+                            logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                        }\n+                    case -1: // closed\n+                        listOfRequests.remove(index);\n+                        listOfChStatus.remove(index);\n+                        listOfChannels.remove(index);\n+                        listOfReplies.remove(index);\n+                        index--;\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (\"PUT\".equals(httpMethod)) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot(byte[] incommingSnapshot) {\n+        lockCurrentSnapshot.lock();\n+        try {\n+            currentSnapshot = incommingSnapshot;\n+            if (preroll > 0) {\n+                fifoSnapshotBuffer.add(incommingSnapshot);\n+                if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                    fifoSnapshotBuffer.removeFirst();\n+                }\n+            }\n+        } finally {\n+            lockCurrentSnapshot.unlock();\n+        }\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(incommingSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(incommingSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                // only happens every 8 seconds as some browsers need a frame that often to keep stream alive.\n+                sendMjpegFrame(incommingSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+    }\n+\n+    // These methods handle the response from all camera brands, nothing specific to\n+    // any brand should be in here //\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                // logger.trace(\"{}\", msg.toString());\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                            if (closeConnection) {\n+                                lock.lock();\n+                                try {\n+                                    byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                    if (indexInLists >= 0) {\n+                                        listOfChStatus.set(indexInLists, (byte) 0);\n+                                    } else {\n+                                        logger.debug(\"!!!! Could not find the ch for a Connection: close URL:{}\",\n+                                                requestUrl);\n+                                    }\n+                                } finally {\n+                                    lock.unlock();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                processSnapshot(incomingJpeg);\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    // logger.trace(\"Snapshot recieved: Binding will now close the channel.\");\n+                                    ctx.close();\n+                                } else {\n+                                    lock.lock();\n+                                    try {\n+                                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                        if (indexInLists >= 0) {\n+                                            listOfChStatus.set(indexInLists, (byte) 2);\n+                                        }\n+                                    } finally {\n+                                        lock.unlock();\n+                                        bytesToRecieve = 0;\n+                                        bytesAlreadyRecieved = 0;\n+                                    }\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.equals(\"\")) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // logger.debug(\"Packet back from camera is not matching HttpContent\");\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+            if (ctx == null) {\n+                return;\n+            }\n+            lock.lock();\n+            try {\n+                byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                if (indexInLists >= 0) {\n+                    // logger.debug(\"commonCameraHandler closed channel:{} \\tURL:{}\", indexInLists, requestUrl);\n+                    listOfChStatus.set(indexInLists, (byte) -1);\n+                } else {\n+                    if (listOfChannels.size() > 0) {\n+                        logger.warn(\"Can't find ch when removing handler \\t\\tURL:{}\", requestUrl);\n+                    }\n+                }\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause instanceof ArrayIndexOutOfBoundsException) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                        if (indexInLists >= 0) {\n+                            String urlToKeepOpen;\n+                            switch (thing.getThingTypeUID().getId()) {\n+                                case \"DAHUA\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"HIKVISION\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/ISAPI/Event/notification/alertStream\".contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"DOORBIRD\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/bha-api/monitor.cgi?ring=doorbell,motionsensor\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                            }\n+                            logger.debug(\"! Channel was found idle for more than 15 seconds so closing it down. !\");\n+                            listOfChStatus.set(indexInLists, (byte) 0);\n+                        } else {\n+                            logger.warn(\"!?! Channel that was found idle could not be located in our tracking. !?!\");\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.debug(\"File server for camera at {} has started on port {} for all NIC's.\", ipAddress,\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    cameraConfigError(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setupSnapshotStreaming(boolean stream, ChannelHandlerContext ctx, boolean auto) {\n+        if (stream) {\n+            sendMjpegFirstPacket(ctx);\n+            if (auto) {\n+                autoSnapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                try {\n+                    sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                    // iOS uses a FIFO? and needs two frames to display a pic\n+                    sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                } finally {\n+                    lockCurrentSnapshot.unlock();\n+                }\n+                streamingAutoFps = true;\n+            } else {\n+                snapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                try {\n+                    sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+                } finally {\n+                    lockCurrentSnapshot.unlock();\n+                }\n+                streamingSnapshotMjpeg = true;\n+                startSnapshotPolling();\n+            }\n+        } else {\n+            snapshotMjpegChannelGroup.remove(ctx.channel());\n+            autoSnapshotMjpegChannelGroup.remove(ctx.channel());\n+            if (streamingSnapshotMjpeg && snapshotMjpegChannelGroup.isEmpty()) {\n+                streamingSnapshotMjpeg = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All Snapshot based MJPEG streams have stopped.\");\n+            } else if (streamingAutoFps && autoSnapshotMjpegChannelGroup.isEmpty()) {\n+                streamingAutoFps = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All AutoFps Snapshot based MJPEG streams have stopped.\");\n+            }\n+        }\n+    }\n+\n+    // If start is true the CTX is added to the list to stream video to, false stops\n+    // the stream.\n+    public void setupMjpegStreaming(boolean start, ChannelHandlerContext ctx) {\n+        if (start) {\n+            if (mjpegChannelGroup.isEmpty()) {// first stream being requested.\n+                mjpegChannelGroup.add(ctx.channel());\n+                if (mjpegUri.equals(\"\") || mjpegUri.equals(\"ffmpeg\")) {\n+                    sendMjpegFirstPacket(ctx);\n+                    setupFfmpegFormat(\"MJPEG\");\n+                } else {\n+                    try {\n+                        // fix Dahua reboots when refreshing a mjpeg stream.\n+                        TimeUnit.MILLISECONDS.sleep(500);\n+                    } catch (InterruptedException e) {\n+                    }\n+                    sendHttpGET(mjpegUri);\n+                }\n+            } else if (ffmpegMjpeg != null) {// not first stream and we will use ffmpeg\n+                sendMjpegFirstPacket(ctx);\n+                mjpegChannelGroup.add(ctx.channel());\n+            } else {// not first stream and camera supplies the mjpeg source.\n+                ctx.channel().writeAndFlush(firstStreamedMsg);\n+                mjpegChannelGroup.add(ctx.channel());\n+            }\n+        } else {\n+            mjpegChannelGroup.remove(ctx.channel());\n+            if (mjpegChannelGroup.isEmpty()) {\n+                logger.debug(\"All Mjpeg streams have stopped, cleaning up now\");\n+                if (mjpegUri.equals(\"ffmpeg\")) {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                } else if (!mjpegUri.equals(\"\")) {\n+                    closeChannel(getTinyUrl(mjpegUri));\n+                } else {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // sends direct to ctx so can be either snapshots.mjpeg or normal mjpeg stream\n+    public void sendMjpegFirstPacket(ChannelHandlerContext ctx) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        String contentType = \"multipart/x-mixed-replace; boundary=\" + BOUNDARY;\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+        ctx.channel().writeAndFlush(response);\n+    }\n+\n+    public void sendMjpegFrame(byte[] jpg, ChannelGroup channelGroup) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        ByteBuf imageByteBuf = Unpooled.copiedBuffer(jpg);\n+        int length = imageByteBuf.readableBytes();\n+        String header = \"--\" + BOUNDARY + \"\\r\\n\" + \"content-type: image/jpeg\" + \"\\r\\n\" + \"content-length: \" + length\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuf headerBbuf = Unpooled.copiedBuffer(header, 0, header.length(), StandardCharsets.UTF_8);\n+        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+        streamToGroup(headerBbuf, channelGroup, false);\n+        streamToGroup(imageByteBuf, channelGroup, false);\n+        streamToGroup(footerBbuf, channelGroup, true);\n+    }\n+\n+    public void streamToGroup(Object msg, ChannelGroup channelGroup, boolean flush) {\n+        channelGroup.write(msg);\n+        if (flush) {\n+            channelGroup.flush();\n+        }\n+    }\n+\n+    private void storeSnapshots() {\n+        int count = 0;\n+        // Need to lock as fifoSnapshotBuffer is not thread safe and new snapshots can be incoming.\n+        lockCurrentSnapshot.lock();\n+        try {\n+            for (Object incomingJpeg : fifoSnapshotBuffer) {\n+                byte[] foo = (byte[]) incomingJpeg;\n+                File file = new File(ffmpegOutputFolder + \"snapshot\" + count + \".jpg\");\n+                count++;\n+                try {\n+                    OutputStream fos = new FileOutputStream(file);\n+                    fos.write(foo);\n+                    fos.close();\n+                } catch (FileNotFoundException e) {\n+                    logger.warn(\"FileNotFoundException {}\", e.getMessage());\n+                } catch (IOException e) {\n+                    logger.warn(\"IOException {}\", e.getMessage());\n+                }\n+            }\n+        } finally {\n+            lockCurrentSnapshot.unlock();\n+        }\n+    }\n+\n+    public void setupFfmpegFormat(String format) {\n+        String inOptions = \"\";\n+        if (ffmpegOutputFolder.equals(\"\")) {\n+            logger.warn(\"The camera tried to use a FFmpeg feature when the output folder is not set.\");\n+            return;\n+        }\n+        if (rtspUri.equals(\"\")) {\n+            logger.warn(\"The camera tried to use a FFmpeg feature when no valid input for FFmpeg is provided.\");\n+            return;\n+        }\n+        if (config.get(CONFIG_FFMPEG_LOCATION) == null) {\n+            logger.warn(\"The camera tried to use a FFmpeg feature when the location for FFmpeg is not known.\");\n+            return;\n+        }\n+\n+        // Make sure the folder exists, if not create it.\n+        new File(ffmpegOutputFolder).mkdirs();\n+        switch (format) {\n+            case \"HLS\":\n+                if (ffmpegHLS == null) {\n+                    if (rtspUri.contains(\":554\")) {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning -rtsp_transport tcp\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    } else {\n+                        ffmpegHLS = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                                \"-hide_banner -loglevel warning\", rtspUri,\n+                                config.get(CONFIG_FFMPEG_HLS_OUT_ARGUMENTS).toString(),\n+                                ffmpegOutputFolder + \"ipcamera.m3u8\", username, password);\n+                    }\n+                }\n+                if (ffmpegHLS != null) {\n+                    ffmpegHLS.startConverting();\n+                }\n+                break;\n+            case \"GIF\":\n+                if (preroll > 0) {\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(),\n+                            \"-y -r 1 -hide_banner -loglevel warning\", ffmpegOutputFolder + \"snapshot%d.jpg\",\n+                            \"-frames:v \" + (preroll + postroll) + \" \"\n+                                    + config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                } else {\n+                    inOptions = \"-y -t \" + postroll + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-y -t \" + postroll;\n+                    }\n+                    ffmpegGIF = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, config.get(CONFIG_FFMPEG_GIF_OUT_ARGUMENTS).toString(),\n+                            ffmpegOutputFolder + gifFilename + \".gif\", username, password);\n+                }\n+                if (preroll > 0) {\n+                    storeSnapshots();\n+                }\n+                if (ffmpegGIF != null) {\n+                    ffmpegGIF.startConverting();\n+                    if (gifHistory.equals(\"\")) {\n+                        gifHistory = gifFilename;\n+                    } else if (!gifFilename.equals(\"ipcamera\")) {\n+                        gifHistory = gifFilename + \",\" + gifHistory;\n+                        if (gifHistoryLength > 49) {\n+                            int endIndex = gifHistory.lastIndexOf(\",\");\n+                            gifHistory = gifHistory.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_GIF_HISTORY, new StringType(gifHistory));\n+                }\n+                break;\n+            case \"RECORD\":\n+                inOptions = \"-y -t \" + mp4RecordTime + \" -rtsp_transport tcp -hide_banner -loglevel warning\";\n+                if (!rtspUri.contains(\"rtsp\")) {\n+                    inOptions = \"-y -t \" + mp4RecordTime;\n+                }\n+                ffmpegRecord = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                        rtspUri, config.get(CONFIG_FFMPEG_MP4_OUT_ARGUMENTS).toString(),\n+                        ffmpegOutputFolder + mp4Filename + \".mp4\", username, password);\n+                if (mp4Preroll > 0) {\n+                    // fetchFromHLS(); todo: not done yet\n+                }\n+                if (ffmpegRecord != null) {\n+                    ffmpegRecord.startConverting();\n+                    if (mp4History.equals(\"\")) {\n+                        mp4History = mp4Filename;\n+                    } else if (!mp4Filename.equals(\"ipcamera\")) {\n+                        mp4History = mp4Filename + \",\" + mp4History;\n+                        if (mp4HistoryLength > 49) {\n+                            int endIndex = mp4History.lastIndexOf(\",\");\n+                            mp4History = mp4History.substring(0, endIndex);\n+                        }\n+                    }\n+                    setChannelState(CHANNEL_MP4_HISTORY, new StringType(mp4History));\n+                }\n+                break;\n+            case \"RTSPHELPER\":\n+                if (ffmpegRtspHelper != null) {\n+                    ffmpegRtspHelper.stopConverting();\n+                    if (!audioAlarmEnabled && !motionAlarmEnabled) {\n+                        return;\n+                    }\n+                }\n+                String input = (config.get(CONFIG_FFMPEG_MOTION_INPUT) == null) ? rtspUri\n+                        : config.get(CONFIG_FFMPEG_MOTION_INPUT).toString();\n+                String OutputOptions = \"-f null -\";\n+                String filterOptions = \"\";\n+                inOptions = \"-rtsp_transport tcp\";\n+                if (!input.contains(\"rtsp\")) {\n+                    inOptions = \"\";\n+                }\n+                if (audioAlarmEnabled == false) {\n+                    filterOptions = \"-an\";\n+                } else if (audioAlarmEnabled == true) {\n+                    filterOptions = \"-af silencedetect=n=-\" + audioThreshold + \"dB:d=2\";\n+                }\n+                if (motionAlarmEnabled == false && ffmpegSnapshotGeneration == false) {\n+                    filterOptions = filterOptions.concat(\" -vn\");\n+                } else if (motionAlarmEnabled == true) {\n+                    filterOptions = filterOptions\n+                            .concat(\" -vf select='gte(scene,\" + motionThreshold + \")',metadata=print\");\n+                }\n+                if (config.get(CONFIG_USERNAME) != null) {\n+                    filterOptions += \" \";// add space as the Framework does not allow spaces at start of config.\n+                }\n+                ffmpegRtspHelper = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                        input, filterOptions + config.get(CONFIG_FFMPEG_MOTION_ARGUMENTS), OutputOptions, username,\n+                        password);\n+                ffmpegRtspHelper.startConverting();\n+                break;\n+            case \"MJPEG\":\n+                if (ffmpegMjpeg == null) {\n+                    inOptions = \"-rtsp_transport tcp -hide_banner -loglevel warning\";\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegMjpeg = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, config.get(CONFIG_FFMPEG_MJPEG_ARGUMENTS).toString(),\n+                            \"http://127.0.0.1:\" + serverPort + \"/ipcamera.jpg\", username, password);\n+                }\n+                if (ffmpegMjpeg != null) {\n+                    ffmpegMjpeg.startConverting();\n+                }\n+                break;\n+            case \"SNAPSHOT\":\n+                // if mjpeg stream you can use ffmpeg -i input.h264 -codec:v copy -bsf:v mjpeg2jpeg output%03d.jpg\n+                if (ffmpegSnapshot == null) {\n+                    inOptions = \"-rtsp_transport tcp -threads 1 -skip_frame nokey -hide_banner -loglevel warning\";// iFrames\n+                                                                                                                  // only\n+                    if (!rtspUri.contains(\"rtsp\")) {\n+                        inOptions = \"-threads 1 -skip_frame nokey -hide_banner -loglevel warning\";\n+                    }\n+                    ffmpegSnapshot = new Ffmpeg(this, format, config.get(CONFIG_FFMPEG_LOCATION).toString(), inOptions,\n+                            rtspUri, \"-an -vsync vfr -update 1\", \"http://127.0.0.1:\" + serverPort + \"/snapshot.jpg\",\n+                            username, password);\n+                }\n+                if (ffmpegSnapshot != null) {\n+                    ffmpegSnapshot.startConverting();\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void noMotionDetected(String thisAlarmsChannel) {\n+        setChannelState(thisAlarmsChannel, OnOffType.OFF);\n+        firstMotionAlarm = false;\n+        motionAlarmUpdateSnapshot = false;\n+        motionDetected = false;\n+        if (streamingAutoFps) {\n+            stopSnapshotPolling();\n+        } else if (updateImageEvents.contains(\"4\")) { // During Motion Alarms\n+            stopSnapshotPolling();\n+        }\n+    }\n+\n+    // Change alarms that are not counted as motion detecting.\n+    public void changeAlarmState(String thisAlarmsChannel, String state) {\n+        updateState(thisAlarmsChannel, OnOffType.valueOf(state));\n+    }\n+\n+    public void motionDetected(String thisAlarmsChannel) {\n+        updateState(CHANNEL_LAST_MOTION_TYPE, new StringType(thisAlarmsChannel));\n+        updateState(thisAlarmsChannel, OnOffType.ON);\n+        motionDetected = true;\n+        if (streamingAutoFps) {\n+            startSnapshotPolling();\n+        }\n+        if (updateImageEvents.contains(\"2\")) {\n+            if (!firstMotionAlarm) {\n+                if (!snapshotUri.isEmpty()) {\n+                    sendHttpGET(snapshotUri);\n+                }\n+                firstMotionAlarm = true;// reset back to false when the jpg arrives.\n+            }\n+        } else if (updateImageEvents.contains(\"4\")) { // During Motion Alarms\n+            if (!snapshotPolling) {\n+                startSnapshotPolling();\n+            }\n+            firstMotionAlarm = true;\n+            motionAlarmUpdateSnapshot = true;\n+        }\n+    }\n+\n+    public void audioDetected() {\n+        updateState(CHANNEL_AUDIO_ALARM, OnOffType.ON);\n+        if (updateImageEvents.contains(\"3\")) {\n+            if (!firstAudioAlarm) {\n+                if (!snapshotUri.isEmpty()) {\n+                    sendHttpGET(snapshotUri);\n+                }\n+                firstAudioAlarm = true;// reset back to false when the jpg arrives.\n+            }\n+        } else if (updateImageEvents.contains(\"5\")) {// During audio alarms\n+            firstAudioAlarm = true;\n+            audioAlarmUpdateSnapshot = true;\n+        }\n+    }\n+\n+    public void noAudioDetected() {\n+        setChannelState(CHANNEL_AUDIO_ALARM, OnOffType.OFF);\n+        firstAudioAlarm = false;\n+        audioAlarmUpdateSnapshot = false;\n+    }\n+\n+    public String returnValueFromString(String rawString, String searchedString) {\n+        String result = \"\";\n+        int index = rawString.indexOf(searchedString);\n+        if (index != -1) // -1 means \"not found\"\n+        {\n+            result = rawString.substring(index + searchedString.length(), rawString.length());\n+            index = result.indexOf(\"\\r\\n\"); // find a carriage return to find the end of the value.\n+            if (index == -1) {\n+                return result; // Did not find a carriage return.\n+            } else {\n+                return result.substring(0, index);\n+            }\n+        }\n+        return \"\"; // Did not find the String we were searching for\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_PAN:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        updateState(CHANNEL_PAN, new PercentType(Math.round(onvifCamera.getAbsolutePan())));\n+                    }\n+                    return;\n+                case CHANNEL_TILT:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        updateState(CHANNEL_TILT, new PercentType(Math.round(onvifCamera.getAbsoluteTilt())));\n+                    }\n+                    return;\n+                case CHANNEL_ZOOM:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        updateState(CHANNEL_ZOOM, new PercentType(Math.round(onvifCamera.getAbsoluteZoom())));\n+                    }\n+                    return;\n+            }\n+        } // caution \"REFRESH\" can still progress to brand Handlers below the else.\n+        else {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_MP4_HISTORY_LENGTH:\n+                    if (\"0\".equals(command.toString())) {\n+                        mp4HistoryLength = 0;\n+                        mp4History = \"\";\n+                        setChannelState(CHANNEL_MP4_HISTORY, new StringType(mp4History));\n+                    }\n+                    return;\n+                case CHANNEL_GIF_HISTORY_LENGTH:\n+                    if (\"0\".equals(command.toString())) {\n+                        gifHistoryLength = 0;\n+                        gifHistory = \"\";\n+                        setChannelState(CHANNEL_GIF_HISTORY, new StringType(gifHistory));\n+                    }\n+                    return;\n+                case CHANNEL_FFMPEG_MOTION_CONTROL:\n+                    if (\"ON\".equals(command.toString())) {\n+                        motionAlarmEnabled = true;\n+                    } else if (\"OFF\".equals(command.toString()) || \"0\".equals(command.toString())) {\n+                        motionAlarmEnabled = false;\n+                        noMotionDetected(CHANNEL_MOTION_ALARM);\n+                    } else {\n+                        motionAlarmEnabled = true;\n+                        motionThreshold = Double.valueOf(command.toString());\n+                        motionThreshold = motionThreshold / 10000;\n+                    }\n+                    setupFfmpegFormat(\"RTSPHELPER\");\n+                    return;\n+                case CHANNEL_GIF_FILENAME:\n+                    logger.debug(\"Changing the gif filename to {}.\", command);\n+                    gifFilename = command.toString();\n+                    if (gifFilename.isEmpty()) {\n+                        gifFilename = \"ipcamera\";\n+                    }\n+                    return;\n+                case CHANNEL_MP4_FILENAME:\n+                    logger.debug(\"Changing the mp4 filename to {}.\", command);\n+                    mp4Filename = command.toString();\n+                    if (mp4Filename.isEmpty()) {\n+                        mp4Filename = \"ipcamera\";\n+                    }\n+                    return;\n+                case CHANNEL_RECORD_MP4:\n+                    logger.debug(\"Recording {} Seconds to MP4 format.\", command);\n+                    mp4RecordTime = Integer.parseInt(command.toString());\n+                    setupFfmpegFormat(\"RECORD\");\n+                    return;\n+                case CHANNEL_START_STREAM:\n+                    if (\"ON\".equals(command.toString())) {\n+                        setupFfmpegFormat(\"HLS\");\n+                        if (ffmpegHLS != null) {\n+                            ffmpegHLS.setKeepAlive(-1);// will keep running till manually stopped.\n+                        }\n+                    } else {\n+                        if (ffmpegHLS != null) {\n+                            ffmpegHLS.setKeepAlive(1);\n+                        }\n+                    }\n+                    return;\n+                case CHANNEL_EXTERNAL_MOTION:\n+                    if (\"ON\".equals(command.toString())) {\n+                        motionDetected(CHANNEL_EXTERNAL_MOTION);\n+                    } else {\n+                        noMotionDetected(CHANNEL_EXTERNAL_MOTION);\n+                    }\n+                    return;\n+                case CHANNEL_GOTO_PRESET:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        onvifCamera.gotoPreset(Integer.valueOf(command.toString()));\n+                    }\n+                    return;\n+                case CHANNEL_UPDATE_IMAGE_NOW:\n+                    if (\"ON\".equals(command.toString())) {\n+                        if (snapshotUri.equals(\"\")) {\n+                            ffmpegSnapshotGeneration = true;\n+                            setupFfmpegFormat(\"SNAPSHOT\");\n+                            updateImageChannel = false;\n+                        } else {\n+                            updateImageChannel = true;\n+                            sendHttpGET(snapshotUri);// Allows this to change Image FPS on demand\n+                        }\n+                    } else {\n+                        if (ffmpegSnapshot != null) {\n+                            ffmpegSnapshot.stopConverting();\n+                            ffmpegSnapshotGeneration = false;\n+                        }\n+                        updateImageChannel = false;\n+                    }\n+                    return;\n+                case CHANNEL_UPDATE_GIF:\n+                    if (\"ON\".equals(command.toString())) {\n+                        if (preroll > 0) {\n+                            snapCount = postroll;\n+                        } else {\n+                            setupFfmpegFormat(\"GIF\");\n+                        }\n+                    }\n+                    return;\n+                case CHANNEL_PAN:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        if (command instanceof IncreaseDecreaseType) {\n+                            if (command == IncreaseDecreaseType.INCREASE) {\n+                                if ((boolean) config.get(CONFIG_PTZ_CONTINUOUS)) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveLeft\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveLeft\");\n+                                }\n+                            } else {\n+                                if ((boolean) config.get(CONFIG_PTZ_CONTINUOUS)) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveRight\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveRight\");\n+                                }\n+                            }\n+                            return;\n+                        } else if (\"OFF\".equals(command.toString())) {\n+                            onvifCamera.sendPTZRequest(\"Stop\");\n+                            return;\n+                        }\n+                        onvifCamera.setAbsolutePan(Float.valueOf(command.toString()));\n+                        scheduledMovePTZ.schedule(runnableMovePTZ, 500, TimeUnit.MILLISECONDS);\n+                    }\n+                    return;\n+                case CHANNEL_TILT:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        if (command instanceof IncreaseDecreaseType) {\n+                            if (\"INCREASE\".equals(command.toString())) {\n+                                if ((boolean) config.get(CONFIG_PTZ_CONTINUOUS)) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveUp\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveUp\");\n+                                }\n+                            } else {\n+                                if ((boolean) config.get(CONFIG_PTZ_CONTINUOUS)) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveDown\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveDown\");\n+                                }\n+                            }\n+                            return;\n+                        } else if (\"OFF\".equals(command.toString())) {\n+                            onvifCamera.sendPTZRequest(\"Stop\");\n+                            return;\n+                        }\n+                        onvifCamera.setAbsoluteTilt(Float.valueOf(command.toString()));\n+                        scheduledMovePTZ.schedule(runnableMovePTZ, 500, TimeUnit.MILLISECONDS);\n+                    }\n+                    return;\n+                case CHANNEL_ZOOM:\n+                    if (onvifCamera.supportsPTZ()) {\n+                        if (command instanceof IncreaseDecreaseType) {\n+                            if (\"INCREASE\".equals(command.toString())) {\n+                                if ((boolean) config.get(CONFIG_PTZ_CONTINUOUS)) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveIn\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveIn\");\n+                                }\n+                            } else {\n+                                if ((boolean) config.get(CONFIG_PTZ_CONTINUOUS)) {\n+                                    onvifCamera.sendPTZRequest(\"ContinuousMoveOut\");\n+                                } else {\n+                                    onvifCamera.sendPTZRequest(\"RelativeMoveOut\");\n+                                }\n+                            }\n+                            return;\n+                        } else if (\"OFF\".equals(command.toString())) {\n+                            onvifCamera.sendPTZRequest(\"Stop\");\n+                            return;\n+                        }\n+                        onvifCamera.setAbsoluteZoom(Float.valueOf(command.toString()));\n+                        scheduledMovePTZ.schedule(runnableMovePTZ, 500, TimeUnit.MILLISECONDS);\n+                    }\n+                    return;\n+            }\n+        }\n+        // commands and refresh now get passed to brand handlers\n+        switch (thing.getThingTypeUID().getId()) {\n+            case \"AMCREST\":\n+                AmcrestHandler amcrestHandler = new AmcrestHandler(getHandle());\n+                amcrestHandler.handleCommand(channelUID, command);\n+                if (lowPriorityRequests.isEmpty()) {\n+                    lowPriorityRequests = amcrestHandler.getLowPriorityRequests();\n+                }\n+                break;", "originalCommit": "13f2b7e4312aa5389244f4a45b653798d3b4c355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU1NTU1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r483555552", "bodyText": "I'm at a loss how to improve it as I am still learning Java. I have a huge amount to change still to meet the deadline of 2.5.9 build so I'll leave this till last.", "author": "Skinah", "createdAt": "2020-09-04T11:23:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQxNDkzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQyMDQwMw==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r480420403", "bodyText": "Since format should only be a small finite number of values, you should make this parameter a enum type instead.", "author": "cpmeister", "createdAt": "2020-08-31T21:53:56Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,1999 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;\n+    public boolean streamingAutoFps = false;\n+    boolean motionDetected = false;\n+\n+    private @Nullable ScheduledFuture<?> cameraConnectionJob = null;\n+    private @Nullable ScheduledFuture<?> pollCameraJob = null;\n+    private @Nullable ScheduledFuture<?> snapshotJob = null;\n+    private @Nullable Bootstrap mainBootstrap;\n+    private @Nullable ServerBootstrap serverBootstrap;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private int selectedMediaProfile = 0;\n+\n+    private EventLoopGroup mainEventLoopGroup = new NioEventLoopGroup();\n+    private EventLoopGroup serversLoopGroup = new NioEventLoopGroup();\n+    private FullHttpRequest putRequestWithBody = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(\"PUT\"),\n+            \"\");\n+    private String nvrChannel = \"\";\n+    private String gifFilename = \"ipcamera\";\n+    private String gifHistory = \"\";\n+    private String mp4History = \"\";\n+    public int gifHistoryLength = 0;\n+    public int mp4HistoryLength = 0;\n+    private String mp4Filename = \"ipcamera\";\n+    int mp4RecordTime = 0;\n+    int mp4Preroll = 0;\n+    private LinkedList<byte[]> fifoSnapshotBuffer = new LinkedList<byte[]>();\n+    private int preroll, postroll, snapCount = 0;\n+    private boolean updateImageChannel = false;\n+    private boolean updateAutoFps = false;\n+    private byte lowPriorityCounter = 0;\n+    public String hostIp = \"0.0.0.0\";\n+    private String ffmpegOutputFolder = \"\";\n+\n+    public ArrayList<String> listOfRequests = new ArrayList<String>(18);\n+    public ArrayList<Channel> listOfChannels = new ArrayList<Channel>(18);\n+    // Status can be -2=storing a reply, -1=closed, 0=closing (do not re-use\n+    // channel), 1=open, 2=open and ok to reuse\n+    public ArrayList<Byte> listOfChStatus = new ArrayList<Byte>(18);\n+    public ArrayList<String> listOfReplies = new ArrayList<String>(18);\n+    public ArrayList<String> lowPriorityRequests = new ArrayList<String>(0);\n+    public ReentrantLock lock = new ReentrantLock();\n+\n+    // basicAuth MUST remain private as it holds the password\n+    private String basicAuth = \"\";\n+    public boolean useDigestAuth = false;\n+    public String snapshotUri = \"\";\n+    public String mjpegUri = \"\";\n+    private @Nullable ChannelFuture serverFuture = null;\n+    public int serverPort = 0;\n+    private Object firstStreamedMsg = new Object();\n+    public byte[] currentSnapshot = new byte[] { (byte) 0x00 };\n+    public ReentrantLock lockCurrentSnapshot = new ReentrantLock();\n+    public String rtspUri = \"\";\n+    public String ipAddress = \"empty\";\n+    public String updateImageEvents = \"\";\n+    public boolean audioAlarmUpdateSnapshot = false;\n+    boolean motionAlarmUpdateSnapshot = false;\n+    boolean isOnline = false; // Used so only 1 error is logged when a network issue occurs.\n+    boolean firstAudioAlarm = false;\n+    boolean firstMotionAlarm = false;\n+    public Double motionThreshold = 0.0016;\n+    public int audioThreshold = 35;\n+    @SuppressWarnings(\"unused\")\n+    private @Nullable StreamServerHandler streamServerHandler;\n+    boolean streamingSnapshotMjpeg = false;\n+    public boolean motionAlarmEnabled = false;\n+    public boolean audioAlarmEnabled = false;\n+    public boolean ffmpegSnapshotGeneration = false;\n+    public boolean snapshotPolling = false;\n+    public OnvifConnection onvifCamera = new OnvifConnection(this, \"\", \"\", \"\");\n+\n+    public IpCameraHandler(Thing thing) {\n+        super(thing);\n+        config = thing.getConfiguration();\n+    }\n+\n+    private IpCameraHandler getHandle() {\n+        return this;\n+    }\n+\n+    // false clears the stored user/pass hash, true creates the hash\n+    public boolean setBasicAuth(boolean useBasic) {\n+        if (useBasic == false) {\n+            logger.debug(\"Clearing out the stored BASIC auth now.\");\n+            basicAuth = \"\";\n+            return false;\n+        } else if (!basicAuth.equals(\"\")) {\n+            // due to camera may have been sent multiple requests before the auth was set, this may trigger falsely.\n+            logger.warn(\"Camera is reporting your username and/or password is wrong.\");\n+            return false;\n+        }\n+        if (!username.equals(\"\") && !password.equals(\"\")) {\n+            String authString = username + \":\" + password;\n+            ByteBuf byteBuf = null;\n+            try {\n+                byteBuf = Base64.encode(Unpooled.wrappedBuffer(authString.getBytes(CharsetUtil.UTF_8)));\n+                basicAuth = byteBuf.getCharSequence(0, byteBuf.capacity(), CharsetUtil.UTF_8).toString();\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                    byteBuf = null;\n+                }\n+            }\n+            return true;\n+        } else {\n+            cameraConfigError(\n+                    \"Camera is asking for Basic Auth when you have not provided a username and/or password !\");\n+        }\n+        return false;\n+    }\n+\n+    private String getCorrectUrlFormat(String longUrl) {\n+        String temp = longUrl;\n+        URL url;\n+\n+        try {\n+            url = new URL(longUrl);\n+            int port = url.getPort();\n+            if (port == -1) {\n+                if (url.getQuery() == null) {\n+                    temp = url.getPath();\n+                } else {\n+                    temp = url.getPath() + \"?\" + url.getQuery();\n+                }\n+            } else {\n+                if (url.getQuery() == null) {\n+                    temp = \":\" + url.getPort() + url.getPath();\n+                } else {\n+                    temp = \":\" + url.getPort() + url.getPath() + \"?\" + url.getQuery();\n+                }\n+            }\n+        } catch (MalformedURLException e) {\n+            if (!longUrl.equals(\"ffmpeg\")) {\n+                cameraConfigError(\"A non valid URL has been given to the binding, check they work in a browser.\");\n+                return \"\";\n+            }\n+        }\n+        return temp;\n+    }\n+\n+    private void cleanChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Open and OK to reuse\n+                    case 1: // Open\n+                    case 0: // Closing but still open\n+                        Channel channel = listOfChannels.get(index);\n+                        if (channel.isOpen()) {\n+                            break;\n+                        } else {\n+                            listOfChStatus.set(index, (byte) -1);\n+                            logger.warn(\"Cleaning the channels has just found a connection with wrong open state.\");\n+                        }\n+                    case -1: // closed\n+                        listOfRequests.remove(index);\n+                        listOfChStatus.remove(index);\n+                        listOfChannels.remove(index);\n+                        listOfReplies.remove(index);\n+                        index--;\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeChannel(String url) {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                if (listOfRequests.get(index).equals(url)) {\n+                    switch (listOfChStatus.get(index)) {\n+                        case 2: // Still open and OK to reuse\n+                        case 1: // Still open\n+                        case 0: // Marked as closing but channel still needs to be closed.\n+                            Channel chan = listOfChannels.get(index);\n+                            chan.close();// We can't wait as OH kills any handler that takes >5 seconds.\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void closeAllChannels() {\n+        lock.lock();\n+        try {\n+            for (byte index = 0; index < listOfRequests.size(); index++) {\n+                logger.debug(\"Channel status is {} for URL:{}\", listOfChStatus.get(index), listOfRequests.get(index));\n+                switch (listOfChStatus.get(index)) {\n+                    case 2: // Still open and ok to reuse\n+                    case 1: // Still open\n+                    case 0: // Marked as closing but channel still needs to be closed.\n+                        Channel chan = listOfChannels.get(index);\n+                        chan.close();\n+                        // Handlers may get shutdown by Openhab if total delay >5 secs so no wait.\n+                        break;\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void sendHttpPUT(String httpRequestURL, FullHttpRequest request) {\n+        putRequestWithBody = request; // use Global so the authhandler can use it when resent with DIGEST.\n+        sendHttpRequest(\"PUT\", httpRequestURL, null);\n+    }\n+\n+    public void sendHttpGET(String httpRequestURL) {\n+        sendHttpRequest(\"GET\", httpRequestURL, null);\n+    }\n+\n+    public int getPortFromShortenedUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int end = httpRequestURL.indexOf(\"/\");\n+            return Integer.parseInt(httpRequestURL.substring(1, end));\n+        }\n+        return Integer.parseInt(config.get(CONFIG_PORT).toString());\n+    }\n+\n+    public String getTinyUrl(String httpRequestURL) {\n+        if (httpRequestURL.startsWith(\":\")) {\n+            int beginIndex = httpRequestURL.indexOf(\"/\");\n+            return httpRequestURL.substring(beginIndex);\n+        }\n+        return httpRequestURL;\n+    }\n+\n+    // Always use this as sendHttpGET(GET/POST/PUT/DELETE, \"/foo/bar\",null,false)//\n+    // The authHandler will use the url inside a digest string as needed.\n+    @SuppressWarnings(\"null\")\n+    public void sendHttpRequest(String httpMethod, String httpRequestURLFull, @Nullable String digestString) {\n+\n+        int port = getPortFromShortenedUrl(httpRequestURLFull);\n+        String httpRequestURL = getTinyUrl(httpRequestURLFull);\n+\n+        if (mainBootstrap == null) {\n+            mainBootstrap = new Bootstrap();\n+            mainBootstrap.group(mainEventLoopGroup);\n+            mainBootstrap.channel(NioSocketChannel.class);\n+            mainBootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+            mainBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4500);\n+            mainBootstrap.option(ChannelOption.SO_SNDBUF, 1024 * 8);\n+            mainBootstrap.option(ChannelOption.SO_RCVBUF, 1024 * 1024);\n+            mainBootstrap.option(ChannelOption.TCP_NODELAY, true);\n+            mainBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+                @Override\n+                public void initChannel(SocketChannel socketChannel) throws Exception {\n+                    // HIK Alarm stream needs > 9sec idle to stop stream closing\n+                    socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(18, 0, 0));\n+                    socketChannel.pipeline().addLast(\"HttpClientCodec\", new HttpClientCodec());\n+                    socketChannel.pipeline().addLast(\"authHandler\",\n+                            new MyNettyAuthHandler(username, password, getHandle()));\n+                    socketChannel.pipeline().addLast(\"commonHandler\", new CommonCameraHandler());\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            socketChannel.pipeline().addLast(\"amcrestHandler\", new AmcrestHandler(getHandle()));\n+                            break;\n+                        case \"DAHUA\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DahuaHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"DOORBIRD\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new DoorBirdHandler(getHandle()));\n+                            break;\n+                        case \"FOSCAM\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new FoscamHandler(getHandle(), username, password));\n+                            break;\n+                        case \"HIKVISION\":\n+                            socketChannel.pipeline().addLast(\"brandHandler\",\n+                                    new HikvisionHandler(getHandle(), nvrChannel));\n+                            break;\n+                        case \"INSTAR\":\n+                            socketChannel.pipeline().addLast(\"instarHandler\", new InstarHandler(getHandle()));\n+                            break;\n+                        default:\n+                            socketChannel.pipeline().addLast(\"brandHandler\", new HttpOnlyHandler(getHandle()));\n+                            break;\n+                    }\n+                }\n+            });\n+        }\n+\n+        FullHttpRequest request;\n+        if (\"PUT\".equals(httpMethod)) {\n+            if (useDigestAuth && digestString == null) {\n+                request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+                request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+            } else {\n+                request = putRequestWithBody;\n+            }\n+        } else {\n+            request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, new HttpMethod(httpMethod), httpRequestURL);\n+            request.headers().set(HttpHeaderNames.HOST, ipAddress);\n+            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n+        }\n+\n+        if (!basicAuth.equals(\"\")) {\n+            if (useDigestAuth) {\n+                logger.warn(\"Camera at IP:{} had both Basic and Digest set to be used\", ipAddress);\n+                setBasicAuth(false);\n+            } else {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Basic \" + basicAuth);\n+            }\n+        }\n+\n+        if (useDigestAuth) {\n+            if (digestString != null) {\n+                request.headers().set(HttpHeaderNames.AUTHORIZATION, \"Digest \" + digestString);\n+            }\n+        }\n+\n+        mainBootstrap.connect(new InetSocketAddress(ipAddress, port)).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(@Nullable ChannelFuture future) {\n+                if (future == null) {\n+                    return;\n+                }\n+                if (future.isDone() && future.isSuccess()) {\n+                    logger.trace(\"Sending camera: {}: http://{}{}\", httpMethod, ipAddress, httpRequestURL);\n+                    lock.lock();\n+                    byte indexInLists = -1;\n+                    try {\n+                        for (byte index = 0; index < listOfRequests.size(); index++) {\n+                            boolean done = false;\n+                            if (listOfRequests.get(index).equals(httpRequestURL)) {\n+                                switch (listOfChStatus.get(index)) {\n+                                    case 2: // Open and ok to reuse\n+                                        Channel ch = listOfChannels.get(index);\n+                                        if (ch.isOpen()) {\n+                                            logger.debug(\"Using the already open channel:{} \\t{}:{}\", index, httpMethod,\n+                                                    httpRequestURL);\n+                                            CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline()\n+                                                    .get(\"commonHandler\");\n+                                            commonHandler.setURL(httpRequestURLFull);\n+                                            MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline()\n+                                                    .get(\"authHandler\");\n+                                            authHandler.setURL(httpMethod, httpRequestURL);\n+                                            ch.writeAndFlush(request);\n+                                            return;\n+                                        }\n+                                    case -1: // Closed\n+                                        indexInLists = index;\n+                                        listOfChStatus.set(indexInLists, (byte) 1);\n+                                        done = true;\n+                                        break;\n+                                }\n+                                if (done) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+\n+                    Channel ch = future.channel();\n+                    CommonCameraHandler commonHandler = (CommonCameraHandler) ch.pipeline().get(\"commonHandler\");\n+                    MyNettyAuthHandler authHandler = (MyNettyAuthHandler) ch.pipeline().get(\"authHandler\");\n+                    commonHandler.setURL(httpRequestURL);\n+                    authHandler.setURL(httpMethod, httpRequestURL);\n+\n+                    switch (thing.getThingTypeUID().getId()) {\n+                        case \"AMCREST\":\n+                            AmcrestHandler amcrestHandler = (AmcrestHandler) ch.pipeline().get(\"amcrestHandler\");\n+                            amcrestHandler.setURL(httpRequestURL);\n+                            break;\n+                        case \"INSTAR\":\n+                            InstarHandler instarHandler = (InstarHandler) ch.pipeline().get(\"instarHandler\");\n+                            instarHandler.setURL(httpRequestURL);\n+                            break;\n+                    }\n+\n+                    if (indexInLists >= 0) {\n+                        lock.lock();\n+                        try {\n+                            listOfChannels.set(indexInLists, ch);\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have re-opened the closed channel:{} \\t{}:{}\", indexInLists, httpMethod,\n+                        // httpRequestURL);\n+                    } else {\n+                        lock.lock();\n+                        try {\n+                            listOfRequests.add(httpRequestURL);\n+                            listOfChannels.add(ch);\n+                            listOfChStatus.add((byte) 1);\n+                            listOfReplies.add(\"\");\n+                        } finally {\n+                            lock.unlock();\n+                        }\n+                        // logger.debug(\"Have opened a brand NEW channel:{} \\t{}:{}\", listOfRequests.size() - 1,\n+                        // httpMethod, httpRequestURL);\n+                    }\n+                    ch.writeAndFlush(request);\n+                    if (!isOnline) {\n+                        bringCameraOnline();\n+                    }\n+                    return;\n+                } else { // an error occured\n+                    cameraCommunicationError(\n+                            \"Connection Timeout: Check your IP and PORT are correct and the camera can be reached.\");\n+                }\n+            }\n+        });\n+    }\n+\n+    public void processSnapshot(byte[] incommingSnapshot) {\n+        lockCurrentSnapshot.lock();\n+        try {\n+            currentSnapshot = incommingSnapshot;\n+            if (preroll > 0) {\n+                fifoSnapshotBuffer.add(incommingSnapshot);\n+                if (fifoSnapshotBuffer.size() > (preroll + postroll)) {\n+                    fifoSnapshotBuffer.removeFirst();\n+                }\n+            }\n+        } finally {\n+            lockCurrentSnapshot.unlock();\n+        }\n+\n+        if (streamingSnapshotMjpeg) {\n+            sendMjpegFrame(incommingSnapshot, snapshotMjpegChannelGroup);\n+        }\n+        if (streamingAutoFps) {\n+            if (motionDetected) {\n+                sendMjpegFrame(incommingSnapshot, autoSnapshotMjpegChannelGroup);\n+            } else if (updateAutoFps) {\n+                // only happens every 8 seconds as some browsers need a frame that often to keep stream alive.\n+                sendMjpegFrame(incommingSnapshot, autoSnapshotMjpegChannelGroup);\n+                updateAutoFps = false;\n+            }\n+        }\n+\n+        if (updateImageChannel) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+        } else if (firstMotionAlarm || motionAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+            firstMotionAlarm = motionAlarmUpdateSnapshot = false;\n+        } else if (firstAudioAlarm || audioAlarmUpdateSnapshot) {\n+            updateState(CHANNEL_IMAGE, new RawType(incommingSnapshot, \"image/jpeg\"));\n+            firstAudioAlarm = audioAlarmUpdateSnapshot = false;\n+        }\n+    }\n+\n+    // These methods handle the response from all camera brands, nothing specific to\n+    // any brand should be in here //\n+    private class CommonCameraHandler extends ChannelDuplexHandler {\n+        private int bytesToRecieve = 0;\n+        private int bytesAlreadyRecieved = 0;\n+        private byte[] incomingJpeg = new byte[0];\n+        private String incomingMessage = \"\";\n+        private String contentType = \"empty\";\n+        private Object reply = new Object();\n+        private String requestUrl = \"\";\n+        private boolean closeConnection = true;\n+        private boolean isChunked = false;\n+\n+        public void setURL(String url) {\n+            requestUrl = url;\n+        }\n+\n+        @Override\n+        public void channelRead(@Nullable ChannelHandlerContext ctx, @Nullable Object msg) throws Exception {\n+            if (msg == null || ctx == null) {\n+                return;\n+            }\n+            try {\n+                // logger.trace(\"{}\", msg.toString());\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse response = (HttpResponse) msg;\n+                    if (response.status().code() != 401) {\n+                        if (!response.headers().isEmpty()) {\n+                            for (String name : response.headers().names()) {\n+                                // Some cameras use first letter uppercase and others dont.\n+                                switch (name.toLowerCase()) { // Possible localization issues doing this\n+                                    case \"content-type\":\n+                                        contentType = response.headers().getAsString(name);\n+                                        break;\n+                                    case \"content-length\":\n+                                        bytesToRecieve = Integer.parseInt(response.headers().getAsString(name));\n+                                        break;\n+                                    case \"connection\":\n+                                        if (response.headers().getAsString(name).contains(\"keep-alive\")) {\n+                                            closeConnection = false;\n+                                        }\n+                                        break;\n+                                    case \"transfer-encoding\":\n+                                        if (response.headers().getAsString(name).contains(\"chunked\")) {\n+                                            isChunked = true;\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            if (contentType.contains(\"multipart\")) {\n+                                closeConnection = false;\n+                                if (mjpegUri.contains(requestUrl)) {\n+                                    if (msg instanceof HttpMessage) {\n+                                        // very start of stream only\n+                                        ReferenceCountUtil.retain(msg, 1);\n+                                        firstStreamedMsg = msg;\n+                                        streamToGroup(firstStreamedMsg, mjpegChannelGroup, true);\n+                                    }\n+                                }\n+                            } else if (contentType.contains(\"image/jp\")) {\n+                                if (bytesToRecieve == 0) {\n+                                    bytesToRecieve = 768000; // 0.768 Mbyte when no Content-Length is sent\n+                                    logger.debug(\"Camera has no Content-Length header, we have to guess how much RAM.\");\n+                                }\n+                                incomingJpeg = new byte[bytesToRecieve];\n+                            }\n+                            if (closeConnection) {\n+                                lock.lock();\n+                                try {\n+                                    byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                    if (indexInLists >= 0) {\n+                                        listOfChStatus.set(indexInLists, (byte) 0);\n+                                    } else {\n+                                        logger.debug(\"!!!! Could not find the ch for a Connection: close URL:{}\",\n+                                                requestUrl);\n+                                    }\n+                                } finally {\n+                                    lock.unlock();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    if (mjpegUri.contains(requestUrl)) {\n+                        // multiple MJPEG stream packets come back as this.\n+                        ReferenceCountUtil.retain(msg, 1);\n+                        streamToGroup(msg, mjpegChannelGroup, true);\n+                    } else {\n+                        HttpContent content = (HttpContent) msg;\n+                        // Found some cameras uses Content-Type: image/jpg instead of image/jpeg\n+                        if (contentType.contains(\"image/jp\")) {\n+                            for (int i = 0; i < content.content().capacity(); i++) {\n+                                incomingJpeg[bytesAlreadyRecieved++] = content.content().getByte(i);\n+                            }\n+                            if (content instanceof LastHttpContent) {\n+                                processSnapshot(incomingJpeg);\n+                                // testing next line and if works need to do a full cleanup of this function.\n+                                closeConnection = true;\n+                                if (closeConnection) {\n+                                    // logger.trace(\"Snapshot recieved: Binding will now close the channel.\");\n+                                    ctx.close();\n+                                } else {\n+                                    lock.lock();\n+                                    try {\n+                                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                                        if (indexInLists >= 0) {\n+                                            listOfChStatus.set(indexInLists, (byte) 2);\n+                                        }\n+                                    } finally {\n+                                        lock.unlock();\n+                                        bytesToRecieve = 0;\n+                                        bytesAlreadyRecieved = 0;\n+                                    }\n+                                }\n+                            }\n+                        } else { // incomingMessage that is not an IMAGE\n+                            if (incomingMessage.equals(\"\")) {\n+                                incomingMessage = content.content().toString(CharsetUtil.UTF_8);\n+                            } else {\n+                                incomingMessage += content.content().toString(CharsetUtil.UTF_8);\n+                            }\n+                            bytesAlreadyRecieved = incomingMessage.length();\n+                            if (content instanceof LastHttpContent) {\n+                                // If it is not an image send it on to the next handler//\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // HIKVISION alertStream never has a LastHttpContent as it always stays open//\n+                            if (contentType.contains(\"multipart\")) {\n+                                if (bytesAlreadyRecieved != 0) {\n+                                    reply = incomingMessage;\n+                                    incomingMessage = \"\";\n+                                    bytesToRecieve = 0;\n+                                    bytesAlreadyRecieved = 0;\n+                                    super.channelRead(ctx, reply);\n+                                }\n+                            }\n+                            // Foscam needs this as will other cameras with chunks//\n+                            if (isChunked && bytesAlreadyRecieved != 0) {\n+                                reply = incomingMessage;\n+                                super.channelRead(ctx, reply);\n+                            }\n+                        }\n+                    }\n+                } else { // msg is not HttpContent\n+                    // logger.debug(\"Packet back from camera is not matching HttpContent\");\n+                    // Foscam and Amcrest cameras need this\n+                    if (!contentType.contains(\"image/jp\") && bytesAlreadyRecieved != 0) {\n+                        reply = incomingMessage;\n+                        logger.debug(\"Packet back from camera is {}\", incomingMessage);\n+                        super.channelRead(ctx, reply);\n+                    }\n+                }\n+            } finally {\n+                ReferenceCountUtil.release(msg);\n+            }\n+        }\n+\n+        @Override\n+        public void channelReadComplete(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerAdded(@Nullable ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void handlerRemoved(@Nullable ChannelHandlerContext ctx) {\n+            if (ctx == null) {\n+                return;\n+            }\n+            lock.lock();\n+            try {\n+                byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                if (indexInLists >= 0) {\n+                    // logger.debug(\"commonCameraHandler closed channel:{} \\tURL:{}\", indexInLists, requestUrl);\n+                    listOfChStatus.set(indexInLists, (byte) -1);\n+                } else {\n+                    if (listOfChannels.size() > 0) {\n+                        logger.warn(\"Can't find ch when removing handler \\t\\tURL:{}\", requestUrl);\n+                    }\n+                }\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n+\n+        @Override\n+        public void exceptionCaught(@Nullable ChannelHandlerContext ctx, @Nullable Throwable cause) {\n+            if (cause == null || ctx == null) {\n+                return;\n+            }\n+            if (cause instanceof ArrayIndexOutOfBoundsException) {\n+                logger.debug(\"Camera sent {} bytes when the content-length header was {}.\", bytesAlreadyRecieved,\n+                        bytesToRecieve);\n+            } else {\n+                logger.warn(\"!!!! Camera possibly closed the channel on the binding, cause reported is: {}\",\n+                        cause.getMessage());\n+            }\n+            ctx.close();\n+        }\n+\n+        @Override\n+        public void userEventTriggered(@Nullable ChannelHandlerContext ctx, @Nullable Object evt) throws Exception {\n+            if (ctx == null) {\n+                return;\n+            }\n+            if (evt instanceof IdleStateEvent) {\n+                IdleStateEvent e = (IdleStateEvent) evt;\n+                // If camera does not use the channel for X amount of time it will close.\n+                if (e.state() == IdleState.READER_IDLE) {\n+                    lock.lock();\n+                    try {\n+                        byte indexInLists = (byte) listOfChannels.indexOf(ctx.channel());\n+                        if (indexInLists >= 0) {\n+                            String urlToKeepOpen;\n+                            switch (thing.getThingTypeUID().getId()) {\n+                                case \"DAHUA\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/cgi-bin/eventManager.cgi?action=attach&codes=[All]\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"HIKVISION\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/ISAPI/Event/notification/alertStream\".contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                                case \"DOORBIRD\":\n+                                    urlToKeepOpen = listOfRequests.get(indexInLists);\n+                                    if (\"/bha-api/monitor.cgi?ring=doorbell,motionsensor\"\n+                                            .contentEquals(urlToKeepOpen)) {\n+                                        return;\n+                                    }\n+                                    break;\n+                            }\n+                            logger.debug(\"! Channel was found idle for more than 15 seconds so closing it down. !\");\n+                            listOfChStatus.set(indexInLists, (byte) 0);\n+                        } else {\n+                            logger.warn(\"!?! Channel that was found idle could not be located in our tracking. !?!\");\n+                        }\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                    ctx.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public String getLocalIpAddress() {\n+        String ipAddress = \"\";\n+        try {\n+            for (Enumeration<NetworkInterface> enumNetworks = NetworkInterface.getNetworkInterfaces(); enumNetworks\n+                    .hasMoreElements();) {\n+                NetworkInterface networkInterface = enumNetworks.nextElement();\n+                for (Enumeration<InetAddress> enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr\n+                        .hasMoreElements();) {\n+                    InetAddress inetAddress = enumIpAddr.nextElement();\n+                    if (!inetAddress.isLoopbackAddress() && inetAddress.getHostAddress().toString().length() < 18\n+                            && inetAddress.isSiteLocalAddress()) {\n+                        ipAddress = inetAddress.getHostAddress().toString();\n+                        logger.debug(\"Possible NIC/IP match found:{}\", ipAddress);\n+                    }\n+                }\n+            }\n+        } catch (SocketException ex) {\n+        }\n+        return ipAddress;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void startStreamServer(boolean start) {\n+\n+        if (!start) {\n+            serversLoopGroup.shutdownGracefully();\n+            serverBootstrap = null;\n+        } else {\n+            if (serverBootstrap == null) {\n+                hostIp = getLocalIpAddress();\n+                try {\n+                    serversLoopGroup = new NioEventLoopGroup();\n+                    serverBootstrap = new ServerBootstrap();\n+                    serverBootstrap.group(serversLoopGroup);\n+                    serverBootstrap.channel(NioServerSocketChannel.class);\n+                    // IP \"0.0.0.0\" will bind the server to all network connections//\n+                    serverBootstrap.localAddress(new InetSocketAddress(\"0.0.0.0\", serverPort));\n+                    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                        @Override\n+                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n+                            socketChannel.pipeline().addLast(\"idleStateHandler\", new IdleStateHandler(0, 25, 0));\n+                            socketChannel.pipeline().addLast(\"HttpServerCodec\", new HttpServerCodec());\n+                            socketChannel.pipeline().addLast(\"ChunkedWriteHandler\", new ChunkedWriteHandler());\n+                            socketChannel.pipeline().addLast(\"streamServerHandler\",\n+                                    new StreamServerHandler(getHandle()));\n+                        }\n+                    });\n+                    serverFuture = serverBootstrap.bind().sync();\n+                    serverFuture.await(4000);\n+                    logger.debug(\"File server for camera at {} has started on port {} for all NIC's.\", ipAddress,\n+                            serverPort);\n+                    updateState(CHANNEL_STREAM_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.mjpeg\"));\n+                    updateState(CHANNEL_HLS_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.m3u8\"));\n+                    updateState(CHANNEL_IMAGE_URL,\n+                            new StringType(\"http://\" + hostIp + \":\" + serverPort + \"/ipcamera.jpg\"));\n+                } catch (Exception e) {\n+                    cameraConfigError(\n+                            \"Exception occured when starting the streaming server. Try changing the SERVER_PORT to another number.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setupSnapshotStreaming(boolean stream, ChannelHandlerContext ctx, boolean auto) {\n+        if (stream) {\n+            sendMjpegFirstPacket(ctx);\n+            if (auto) {\n+                autoSnapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                try {\n+                    sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                    // iOS uses a FIFO? and needs two frames to display a pic\n+                    sendMjpegFrame(currentSnapshot, autoSnapshotMjpegChannelGroup);\n+                } finally {\n+                    lockCurrentSnapshot.unlock();\n+                }\n+                streamingAutoFps = true;\n+            } else {\n+                snapshotMjpegChannelGroup.add(ctx.channel());\n+                lockCurrentSnapshot.lock();\n+                try {\n+                    sendMjpegFrame(currentSnapshot, snapshotMjpegChannelGroup);\n+                } finally {\n+                    lockCurrentSnapshot.unlock();\n+                }\n+                streamingSnapshotMjpeg = true;\n+                startSnapshotPolling();\n+            }\n+        } else {\n+            snapshotMjpegChannelGroup.remove(ctx.channel());\n+            autoSnapshotMjpegChannelGroup.remove(ctx.channel());\n+            if (streamingSnapshotMjpeg && snapshotMjpegChannelGroup.isEmpty()) {\n+                streamingSnapshotMjpeg = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All Snapshot based MJPEG streams have stopped.\");\n+            } else if (streamingAutoFps && autoSnapshotMjpegChannelGroup.isEmpty()) {\n+                streamingAutoFps = false;\n+                stopSnapshotPolling();\n+                logger.debug(\"All AutoFps Snapshot based MJPEG streams have stopped.\");\n+            }\n+        }\n+    }\n+\n+    // If start is true the CTX is added to the list to stream video to, false stops\n+    // the stream.\n+    public void setupMjpegStreaming(boolean start, ChannelHandlerContext ctx) {\n+        if (start) {\n+            if (mjpegChannelGroup.isEmpty()) {// first stream being requested.\n+                mjpegChannelGroup.add(ctx.channel());\n+                if (mjpegUri.equals(\"\") || mjpegUri.equals(\"ffmpeg\")) {\n+                    sendMjpegFirstPacket(ctx);\n+                    setupFfmpegFormat(\"MJPEG\");\n+                } else {\n+                    try {\n+                        // fix Dahua reboots when refreshing a mjpeg stream.\n+                        TimeUnit.MILLISECONDS.sleep(500);\n+                    } catch (InterruptedException e) {\n+                    }\n+                    sendHttpGET(mjpegUri);\n+                }\n+            } else if (ffmpegMjpeg != null) {// not first stream and we will use ffmpeg\n+                sendMjpegFirstPacket(ctx);\n+                mjpegChannelGroup.add(ctx.channel());\n+            } else {// not first stream and camera supplies the mjpeg source.\n+                ctx.channel().writeAndFlush(firstStreamedMsg);\n+                mjpegChannelGroup.add(ctx.channel());\n+            }\n+        } else {\n+            mjpegChannelGroup.remove(ctx.channel());\n+            if (mjpegChannelGroup.isEmpty()) {\n+                logger.debug(\"All Mjpeg streams have stopped, cleaning up now\");\n+                if (mjpegUri.equals(\"ffmpeg\")) {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                } else if (!mjpegUri.equals(\"\")) {\n+                    closeChannel(getTinyUrl(mjpegUri));\n+                } else {\n+                    if (ffmpegMjpeg != null) {\n+                        ffmpegMjpeg.stopConverting();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // sends direct to ctx so can be either snapshots.mjpeg or normal mjpeg stream\n+    public void sendMjpegFirstPacket(ChannelHandlerContext ctx) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        String contentType = \"multipart/x-mixed-replace; boundary=\" + BOUNDARY;\n+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n+        response.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);\n+        response.headers().set(HttpHeaderNames.CACHE_CONTROL, HttpHeaderValues.NO_CACHE);\n+        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n+        response.headers().add(\"Access-Control-Allow-Origin\", \"*\");\n+        response.headers().add(\"Access-Control-Expose-Headers\", \"*\");\n+        ctx.channel().writeAndFlush(response);\n+    }\n+\n+    public void sendMjpegFrame(byte[] jpg, ChannelGroup channelGroup) {\n+        final String BOUNDARY = \"thisMjpegStream\";\n+        ByteBuf imageByteBuf = Unpooled.copiedBuffer(jpg);\n+        int length = imageByteBuf.readableBytes();\n+        String header = \"--\" + BOUNDARY + \"\\r\\n\" + \"content-type: image/jpeg\" + \"\\r\\n\" + \"content-length: \" + length\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuf headerBbuf = Unpooled.copiedBuffer(header, 0, header.length(), StandardCharsets.UTF_8);\n+        ByteBuf footerBbuf = Unpooled.copiedBuffer(\"\\r\\n\", 0, 2, StandardCharsets.UTF_8);\n+        streamToGroup(headerBbuf, channelGroup, false);\n+        streamToGroup(imageByteBuf, channelGroup, false);\n+        streamToGroup(footerBbuf, channelGroup, true);\n+    }\n+\n+    public void streamToGroup(Object msg, ChannelGroup channelGroup, boolean flush) {\n+        channelGroup.write(msg);\n+        if (flush) {\n+            channelGroup.flush();\n+        }\n+    }\n+\n+    private void storeSnapshots() {\n+        int count = 0;\n+        // Need to lock as fifoSnapshotBuffer is not thread safe and new snapshots can be incoming.\n+        lockCurrentSnapshot.lock();\n+        try {\n+            for (Object incomingJpeg : fifoSnapshotBuffer) {\n+                byte[] foo = (byte[]) incomingJpeg;\n+                File file = new File(ffmpegOutputFolder + \"snapshot\" + count + \".jpg\");\n+                count++;\n+                try {\n+                    OutputStream fos = new FileOutputStream(file);\n+                    fos.write(foo);\n+                    fos.close();\n+                } catch (FileNotFoundException e) {\n+                    logger.warn(\"FileNotFoundException {}\", e.getMessage());\n+                } catch (IOException e) {\n+                    logger.warn(\"IOException {}\", e.getMessage());\n+                }\n+            }\n+        } finally {\n+            lockCurrentSnapshot.unlock();\n+        }\n+    }\n+\n+    public void setupFfmpegFormat(String format) {", "originalCommit": "13f2b7e4312aa5389244f4a45b653798d3b4c355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk5MzE2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r480993165", "bodyText": "Done.", "author": "Skinah", "createdAt": "2020-09-01T09:17:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQyMDQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQyMTE0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r480421144", "bodyText": "Do you need a separate field for each of these? Isn't only one of them ever going to be non-null? Can you use a single field instead?", "author": "cpmeister", "createdAt": "2020-08-31T21:55:35Z", "path": "bundles/org.openhab.binding.ipcamera/src/main/java/org/openhab/binding/ipcamera/handler/IpCameraHandler.java", "diffHunk": "@@ -0,0 +1,1999 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.ipcamera.handler;\n+\n+import static org.openhab.binding.ipcamera.IpCameraBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigDecimal;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.ipcamera.internal.AmcrestHandler;\n+import org.openhab.binding.ipcamera.internal.DahuaHandler;\n+import org.openhab.binding.ipcamera.internal.DoorBirdHandler;\n+import org.openhab.binding.ipcamera.internal.Ffmpeg;\n+import org.openhab.binding.ipcamera.internal.FoscamHandler;\n+import org.openhab.binding.ipcamera.internal.HikvisionHandler;\n+import org.openhab.binding.ipcamera.internal.HttpOnlyHandler;\n+import org.openhab.binding.ipcamera.internal.InstarHandler;\n+import org.openhab.binding.ipcamera.internal.MyNettyAuthHandler;\n+import org.openhab.binding.ipcamera.internal.StreamServerHandler;\n+import org.openhab.binding.ipcamera.onvif.OnvifConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.base64.Base64;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpClientCodec;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMessage;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.GlobalEventExecutor;\n+\n+/**\n+ * The {@link IpCameraHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Matthew Skinner - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class IpCameraHandler extends BaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = new HashSet<ThingTypeUID>(\n+            Arrays.asList(THING_TYPE_ONVIF, THING_TYPE_HTTPONLY, THING_TYPE_AMCREST, THING_TYPE_DAHUA,\n+                    THING_TYPE_INSTAR, THING_TYPE_FOSCAM, THING_TYPE_DOORBIRD, THING_TYPE_HIKVISION));\n+    public static ArrayList<IpCameraHandler> listOfOnlineCameraHandlers = new ArrayList<IpCameraHandler>(1);\n+    public static ArrayList<IpCameraGroupHandler> listOfGroupHandlers = new ArrayList<IpCameraGroupHandler>(0);\n+    public static ArrayList<String> listOfOnlineCameraUID = new ArrayList<String>(1);\n+    public final Logger logger = LoggerFactory.getLogger(getClass());\n+    private ScheduledExecutorService cameraConnection = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService scheduledMovePTZ = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService pollCamera = Executors.newScheduledThreadPool(1);\n+    private ScheduledExecutorService snapshot = Executors.newScheduledThreadPool(1);\n+    public Configuration config;\n+\n+    // ChannelGroup is thread safe\n+    public final ChannelGroup mjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup snapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    final ChannelGroup autoSnapshotMjpegChannelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n+    public @Nullable Ffmpeg ffmpegHLS = null;\n+    public @Nullable Ffmpeg ffmpegRecord = null;\n+    public @Nullable Ffmpeg ffmpegGIF = null;\n+    public @Nullable Ffmpeg ffmpegRtspHelper = null;\n+    public @Nullable Ffmpeg ffmpegMjpeg = null;\n+    public @Nullable Ffmpeg ffmpegSnapshot = null;", "originalCommit": "13f2b7e4312aa5389244f4a45b653798d3b4c355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2NzgwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8329#discussion_r480967809", "bodyText": "Each one of those could be running in their own thread at the same time. So YES I do believe I need each of them ,unless I am not seeing something that you are because I am a self taught programmer with little experience.", "author": "Skinah", "createdAt": "2020-09-01T08:34:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQyMTE0NA=="}], "type": "inlineReview"}, {"oid": "b60daf28633e2ea326967a5435315d3dbb479d9b", "url": "https://github.com/openhab/openhab-addons/commit/b60daf28633e2ea326967a5435315d3dbb479d9b", "message": "Removed var=null cleanups.\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-01T07:02:03Z", "type": "commit"}, {"oid": "3de946dfd577099231425c47a352dbc95f604083", "url": "https://github.com/openhab/openhab-addons/commit/3de946dfd577099231425c47a352dbc95f604083", "message": "Removed IpCameraConfiguration.java\n\nSigned-off-by: Matthew Skinner <matt@pcmus.com>", "committedDate": "2020-09-01T07:05:58Z", "type": "commit"}]}