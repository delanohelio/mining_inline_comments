{"pr_number": 9449, "pr_title": "[resol] Add Resol Controller Binding - Initial Contribution", "pr_createdAt": "2020-12-21T00:00:58Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/9449", "timeline": [{"oid": "14e88d0c0fd543e7e7ad445c921d3499201e1be8", "url": "https://github.com/openhab/openhab-addons/commit/14e88d0c0fd543e7e7ad445c921d3499201e1be8", "message": "swap to OH3, improve docs and some minor fixes\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2020-12-21T00:09:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAxODUwMw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551018503", "bodyText": "Same for the others.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private ScheduledFuture<?> pollingJob;\n          \n          \n            \n                private @Nullable ScheduledFuture<?> pollingJob;", "author": "fwolter", "createdAt": "2021-01-03T15:17:22Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAxOTM0NA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551019344", "bodyText": "Syntactical sugar. Same for the others.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Set<String> availableDevices = new HashSet<String>();\n          \n          \n            \n                private Set<String> availableDevices = new HashSet<>();", "author": "fwolter", "createdAt": "2021-01-03T15:25:26Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMDM5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551020391", "bodyText": "Please put all fields to the top of the class.", "author": "fwolter", "createdAt": "2021-01-03T15:34:44Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();\n+\n+    private Map<Integer, @NonNull ResolEmuEMThingHandler> emThingHandlerMap = new HashMap<Integer, @NonNull ResolEmuEMThingHandler>();\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(locale);\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    // Managing Thing Discovery Service\n+\n+    @Nullable\n+    private ResolDiscoveryService discoveryService = null;", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMDU0NA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551020544", "bodyText": "You could make this a method\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Runnable pollingRunnable = new Runnable() {\n          \n          \n            \n                    @Override\n          \n          \n            \n                    public void run() {\n          \n          \n            \n            private void pollingRunnable() {", "author": "fwolter", "createdAt": "2021-01-03T15:35:55Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();\n+\n+    private Map<Integer, @NonNull ResolEmuEMThingHandler> emThingHandlerMap = new HashMap<Integer, @NonNull ResolEmuEMThingHandler>();\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(locale);\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    // Managing Thing Discovery Service\n+\n+    @Nullable\n+    private ResolDiscoveryService discoveryService = null;\n+\n+    public void registerDiscoveryService(ResolDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    private void createThing(String thingType, String thingID, String name) {\n+        ResolDiscoveryService service = discoveryService;\n+        logger.trace(\"Create thing Type='{}' id='{}'\", thingType, thingID);\n+\n+        if (service != null) {\n+            service.addResolThing(thingType, thingID, name);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolThingHandler thingHandler) {\n+        Thing t = thingHandler.getThing();\n+\n+        String thingType = t.getUID().getId();\n+\n+        if (!thingHandlerMap.containsKey(thingType)) {\n+            thingHandlerMap.put(thingType, thingHandler);\n+            logger.trace(\"register thingHandler for thing: {}\", thingType);\n+            updateThingHandlerStatus(thingHandler, this.getStatus());\n+        } else {\n+            logger.trace(\"thingHandler for thing: '{}' allready registerd\", thingType);\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolThingHandler thingHandler) {\n+        String thingID = thingHandler.getThing().getUID().getId();\n+        if (!thingHandlerMap.containsKey(thingID)) {\n+            logger.warn(\"thingHandler for thing: {} not registered\", thingID);\n+        } else {\n+            thingHandler.updateStatus(ThingStatus.OFFLINE);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+\n+        emThingHandlerMap.put(resolEmuEMThingHandler.getVbusAddress(), resolEmuEMThingHandler);\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (isConnected && con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+                updateStatus();\n+            } else {\n+                resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            }\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        if (!emThingHandlerMap.containsKey(resolEmuEMThingHandler.getVbusAddress())) {\n+            logger.warn(\"thingHandler for vbus address {} not registered\", resolEmuEMThingHandler.getVbusAddress());\n+        } else {\n+            resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            emThingHandlerMap.remove(resolEmuEMThingHandler.getVbusAddress());\n+        }\n+    }\n+\n+    private void updateThingHandlerStatus(ResolThingHandler thingHandler, ThingStatus status) {\n+        thingHandler.updateStatus(status);\n+    }\n+\n+    private Runnable pollingRunnable = new Runnable() {\n+        @Override\n+        public void run() {", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMDYzMA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551020630", "bodyText": "Are you logging the stack trace by intention?", "author": "fwolter", "createdAt": "2021-01-03T15:36:30Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();\n+\n+    private Map<Integer, @NonNull ResolEmuEMThingHandler> emThingHandlerMap = new HashMap<Integer, @NonNull ResolEmuEMThingHandler>();\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(locale);\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    // Managing Thing Discovery Service\n+\n+    @Nullable\n+    private ResolDiscoveryService discoveryService = null;\n+\n+    public void registerDiscoveryService(ResolDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    private void createThing(String thingType, String thingID, String name) {\n+        ResolDiscoveryService service = discoveryService;\n+        logger.trace(\"Create thing Type='{}' id='{}'\", thingType, thingID);\n+\n+        if (service != null) {\n+            service.addResolThing(thingType, thingID, name);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolThingHandler thingHandler) {\n+        Thing t = thingHandler.getThing();\n+\n+        String thingType = t.getUID().getId();\n+\n+        if (!thingHandlerMap.containsKey(thingType)) {\n+            thingHandlerMap.put(thingType, thingHandler);\n+            logger.trace(\"register thingHandler for thing: {}\", thingType);\n+            updateThingHandlerStatus(thingHandler, this.getStatus());\n+        } else {\n+            logger.trace(\"thingHandler for thing: '{}' allready registerd\", thingType);\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolThingHandler thingHandler) {\n+        String thingID = thingHandler.getThing().getUID().getId();\n+        if (!thingHandlerMap.containsKey(thingID)) {\n+            logger.warn(\"thingHandler for thing: {} not registered\", thingID);\n+        } else {\n+            thingHandler.updateStatus(ThingStatus.OFFLINE);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+\n+        emThingHandlerMap.put(resolEmuEMThingHandler.getVbusAddress(), resolEmuEMThingHandler);\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (isConnected && con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+                updateStatus();\n+            } else {\n+                resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            }\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        if (!emThingHandlerMap.containsKey(resolEmuEMThingHandler.getVbusAddress())) {\n+            logger.warn(\"thingHandler for vbus address {} not registered\", resolEmuEMThingHandler.getVbusAddress());\n+        } else {\n+            resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            emThingHandlerMap.remove(resolEmuEMThingHandler.getVbusAddress());\n+        }\n+    }\n+\n+    private void updateThingHandlerStatus(ResolThingHandler thingHandler, ThingStatus status) {\n+        thingHandler.updateStatus(status);\n+    }\n+\n+    private Runnable pollingRunnable = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (!isConnected) {\n+                synchronized (ResolBridgeHandler.this) {\n+                    Connection connection = tcpConnection;\n+                    /* first cleanup in case there is an old but failed TCP connection around */\n+                    try {\n+                        if (connection != null) {\n+                            connection.disconnect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.stop();\n+                                }\n+                            }\n+\n+                            connection = null;\n+                            tcpConnection = null;\n+                        }\n+                    } catch (IOException e) {\n+                        logger.warn(\"TCP disconnect failed\", e);", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU0MDMyOA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551540328", "bodyText": "no, not really. e.getMessage() should be sufficient.", "author": "ramack", "createdAt": "2021-01-04T20:07:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMDYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMDc3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551020775", "bodyText": "The context of this message might not be clear if there are intermittent log messages from other loggers in the log. If the unconnectedReason is logged via updateStatus(), this message could be removed at all.", "author": "fwolter", "createdAt": "2021-01-03T15:37:54Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();\n+\n+    private Map<Integer, @NonNull ResolEmuEMThingHandler> emThingHandlerMap = new HashMap<Integer, @NonNull ResolEmuEMThingHandler>();\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(locale);\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    // Managing Thing Discovery Service\n+\n+    @Nullable\n+    private ResolDiscoveryService discoveryService = null;\n+\n+    public void registerDiscoveryService(ResolDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    private void createThing(String thingType, String thingID, String name) {\n+        ResolDiscoveryService service = discoveryService;\n+        logger.trace(\"Create thing Type='{}' id='{}'\", thingType, thingID);\n+\n+        if (service != null) {\n+            service.addResolThing(thingType, thingID, name);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolThingHandler thingHandler) {\n+        Thing t = thingHandler.getThing();\n+\n+        String thingType = t.getUID().getId();\n+\n+        if (!thingHandlerMap.containsKey(thingType)) {\n+            thingHandlerMap.put(thingType, thingHandler);\n+            logger.trace(\"register thingHandler for thing: {}\", thingType);\n+            updateThingHandlerStatus(thingHandler, this.getStatus());\n+        } else {\n+            logger.trace(\"thingHandler for thing: '{}' allready registerd\", thingType);\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolThingHandler thingHandler) {\n+        String thingID = thingHandler.getThing().getUID().getId();\n+        if (!thingHandlerMap.containsKey(thingID)) {\n+            logger.warn(\"thingHandler for thing: {} not registered\", thingID);\n+        } else {\n+            thingHandler.updateStatus(ThingStatus.OFFLINE);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+\n+        emThingHandlerMap.put(resolEmuEMThingHandler.getVbusAddress(), resolEmuEMThingHandler);\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (isConnected && con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+                updateStatus();\n+            } else {\n+                resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            }\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        if (!emThingHandlerMap.containsKey(resolEmuEMThingHandler.getVbusAddress())) {\n+            logger.warn(\"thingHandler for vbus address {} not registered\", resolEmuEMThingHandler.getVbusAddress());\n+        } else {\n+            resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            emThingHandlerMap.remove(resolEmuEMThingHandler.getVbusAddress());\n+        }\n+    }\n+\n+    private void updateThingHandlerStatus(ResolThingHandler thingHandler, ThingStatus status) {\n+        thingHandler.updateStatus(status);\n+    }\n+\n+    private Runnable pollingRunnable = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (!isConnected) {\n+                synchronized (ResolBridgeHandler.this) {\n+                    Connection connection = tcpConnection;\n+                    /* first cleanup in case there is an old but failed TCP connection around */\n+                    try {\n+                        if (connection != null) {\n+                            connection.disconnect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.stop();\n+                                }\n+                            }\n+\n+                            connection = null;\n+                            tcpConnection = null;\n+                        }\n+                    } catch (IOException e) {\n+                        logger.warn(\"TCP disconnect failed\", e);\n+                    }\n+                    TcpDataSource source = null;\n+                    /* now try to establish a new TCP connection */\n+                    try {\n+                        source = TcpDataSourceProvider.fetchInformation(InetAddress.getByName(ipAddress), 500);\n+                        if (source != null) {\n+                            source.setLivePassword(password);\n+                        }\n+                    } catch (IOException e) {\n+                        isConnected = false;\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                    }\n+                    if (source != null) {\n+                        try {\n+                            logger.debug(\"Opening a new connection...\");\n+                            connection = source.connectLive(0, 0x0020);\n+                            tcpConnection = connection;\n+                        } catch (Exception e) {\n+                            // this generic Exception catch is required, as TcpDataSource.connectLive throws this\n+                            // generic\n+                            // type\n+                            logger.debug(\"... failed.\");", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMTAxMg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551021012", "bodyText": "This could be removed, according to the principle if there's no error message the operation suceeded.", "author": "fwolter", "createdAt": "2021-01-03T15:39:43Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();\n+\n+    private Map<Integer, @NonNull ResolEmuEMThingHandler> emThingHandlerMap = new HashMap<Integer, @NonNull ResolEmuEMThingHandler>();\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(locale);\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    // Managing Thing Discovery Service\n+\n+    @Nullable\n+    private ResolDiscoveryService discoveryService = null;\n+\n+    public void registerDiscoveryService(ResolDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    private void createThing(String thingType, String thingID, String name) {\n+        ResolDiscoveryService service = discoveryService;\n+        logger.trace(\"Create thing Type='{}' id='{}'\", thingType, thingID);\n+\n+        if (service != null) {\n+            service.addResolThing(thingType, thingID, name);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolThingHandler thingHandler) {\n+        Thing t = thingHandler.getThing();\n+\n+        String thingType = t.getUID().getId();\n+\n+        if (!thingHandlerMap.containsKey(thingType)) {\n+            thingHandlerMap.put(thingType, thingHandler);\n+            logger.trace(\"register thingHandler for thing: {}\", thingType);\n+            updateThingHandlerStatus(thingHandler, this.getStatus());\n+        } else {\n+            logger.trace(\"thingHandler for thing: '{}' allready registerd\", thingType);\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolThingHandler thingHandler) {\n+        String thingID = thingHandler.getThing().getUID().getId();\n+        if (!thingHandlerMap.containsKey(thingID)) {\n+            logger.warn(\"thingHandler for thing: {} not registered\", thingID);\n+        } else {\n+            thingHandler.updateStatus(ThingStatus.OFFLINE);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+\n+        emThingHandlerMap.put(resolEmuEMThingHandler.getVbusAddress(), resolEmuEMThingHandler);\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (isConnected && con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+                updateStatus();\n+            } else {\n+                resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            }\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        if (!emThingHandlerMap.containsKey(resolEmuEMThingHandler.getVbusAddress())) {\n+            logger.warn(\"thingHandler for vbus address {} not registered\", resolEmuEMThingHandler.getVbusAddress());\n+        } else {\n+            resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            emThingHandlerMap.remove(resolEmuEMThingHandler.getVbusAddress());\n+        }\n+    }\n+\n+    private void updateThingHandlerStatus(ResolThingHandler thingHandler, ThingStatus status) {\n+        thingHandler.updateStatus(status);\n+    }\n+\n+    private Runnable pollingRunnable = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (!isConnected) {\n+                synchronized (ResolBridgeHandler.this) {\n+                    Connection connection = tcpConnection;\n+                    /* first cleanup in case there is an old but failed TCP connection around */\n+                    try {\n+                        if (connection != null) {\n+                            connection.disconnect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.stop();\n+                                }\n+                            }\n+\n+                            connection = null;\n+                            tcpConnection = null;\n+                        }\n+                    } catch (IOException e) {\n+                        logger.warn(\"TCP disconnect failed\", e);\n+                    }\n+                    TcpDataSource source = null;\n+                    /* now try to establish a new TCP connection */\n+                    try {\n+                        source = TcpDataSourceProvider.fetchInformation(InetAddress.getByName(ipAddress), 500);\n+                        if (source != null) {\n+                            source.setLivePassword(password);\n+                        }\n+                    } catch (IOException e) {\n+                        isConnected = false;\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                    }\n+                    if (source != null) {\n+                        try {\n+                            logger.debug(\"Opening a new connection...\");\n+                            connection = source.connectLive(0, 0x0020);\n+                            tcpConnection = connection;\n+                        } catch (Exception e) {\n+                            // this generic Exception catch is required, as TcpDataSource.connectLive throws this\n+                            // generic\n+                            // type\n+                            logger.debug(\"... failed.\");\n+                            isConnected = false;\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                        }\n+                        logger.debug(\"... succeeded.\");", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMTE3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551021172", "bodyText": "Is there a reason why you don't add the listener immediately after the connection is established? For what are you waiting here?", "author": "fwolter", "createdAt": "2021-01-03T15:41:34Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();\n+\n+    private Map<Integer, @NonNull ResolEmuEMThingHandler> emThingHandlerMap = new HashMap<Integer, @NonNull ResolEmuEMThingHandler>();\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(locale);\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    // Managing Thing Discovery Service\n+\n+    @Nullable\n+    private ResolDiscoveryService discoveryService = null;\n+\n+    public void registerDiscoveryService(ResolDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    private void createThing(String thingType, String thingID, String name) {\n+        ResolDiscoveryService service = discoveryService;\n+        logger.trace(\"Create thing Type='{}' id='{}'\", thingType, thingID);\n+\n+        if (service != null) {\n+            service.addResolThing(thingType, thingID, name);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolThingHandler thingHandler) {\n+        Thing t = thingHandler.getThing();\n+\n+        String thingType = t.getUID().getId();\n+\n+        if (!thingHandlerMap.containsKey(thingType)) {\n+            thingHandlerMap.put(thingType, thingHandler);\n+            logger.trace(\"register thingHandler for thing: {}\", thingType);\n+            updateThingHandlerStatus(thingHandler, this.getStatus());\n+        } else {\n+            logger.trace(\"thingHandler for thing: '{}' allready registerd\", thingType);\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolThingHandler thingHandler) {\n+        String thingID = thingHandler.getThing().getUID().getId();\n+        if (!thingHandlerMap.containsKey(thingID)) {\n+            logger.warn(\"thingHandler for thing: {} not registered\", thingID);\n+        } else {\n+            thingHandler.updateStatus(ThingStatus.OFFLINE);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+\n+        emThingHandlerMap.put(resolEmuEMThingHandler.getVbusAddress(), resolEmuEMThingHandler);\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (isConnected && con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+                updateStatus();\n+            } else {\n+                resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            }\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        if (!emThingHandlerMap.containsKey(resolEmuEMThingHandler.getVbusAddress())) {\n+            logger.warn(\"thingHandler for vbus address {} not registered\", resolEmuEMThingHandler.getVbusAddress());\n+        } else {\n+            resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            emThingHandlerMap.remove(resolEmuEMThingHandler.getVbusAddress());\n+        }\n+    }\n+\n+    private void updateThingHandlerStatus(ResolThingHandler thingHandler, ThingStatus status) {\n+        thingHandler.updateStatus(status);\n+    }\n+\n+    private Runnable pollingRunnable = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (!isConnected) {\n+                synchronized (ResolBridgeHandler.this) {\n+                    Connection connection = tcpConnection;\n+                    /* first cleanup in case there is an old but failed TCP connection around */\n+                    try {\n+                        if (connection != null) {\n+                            connection.disconnect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.stop();\n+                                }\n+                            }\n+\n+                            connection = null;\n+                            tcpConnection = null;\n+                        }\n+                    } catch (IOException e) {\n+                        logger.warn(\"TCP disconnect failed\", e);\n+                    }\n+                    TcpDataSource source = null;\n+                    /* now try to establish a new TCP connection */\n+                    try {\n+                        source = TcpDataSourceProvider.fetchInformation(InetAddress.getByName(ipAddress), 500);\n+                        if (source != null) {\n+                            source.setLivePassword(password);\n+                        }\n+                    } catch (IOException e) {\n+                        isConnected = false;\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                    }\n+                    if (source != null) {\n+                        try {\n+                            logger.debug(\"Opening a new connection...\");\n+                            connection = source.connectLive(0, 0x0020);\n+                            tcpConnection = connection;\n+                        } catch (Exception e) {\n+                            // this generic Exception catch is required, as TcpDataSource.connectLive throws this\n+                            // generic\n+                            // type\n+                            logger.debug(\"... failed.\");\n+                            isConnected = false;\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                        }\n+                        logger.debug(\"... succeeded.\");\n+\n+                        if (connection != null) {\n+                            try {\n+                                Thread.sleep(3000); // Wait for connection...", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU1MTM5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551551391", "bodyText": "you are right. I guess this was left over from an early phase where the listener did not correctly update the connected status. Will remove it.", "author": "ramack", "createdAt": "2021-01-04T20:29:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMTE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMTUzNw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551021537", "bodyText": "The log message could be removed, as the status update is already logged by the framework.\nThe state change originated by updateStatus() is logged to events.log. Including the status detail message.", "author": "fwolter", "createdAt": "2021-01-03T15:44:57Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();\n+\n+    private Map<Integer, @NonNull ResolEmuEMThingHandler> emThingHandlerMap = new HashMap<Integer, @NonNull ResolEmuEMThingHandler>();\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(locale);\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    // Managing Thing Discovery Service\n+\n+    @Nullable\n+    private ResolDiscoveryService discoveryService = null;\n+\n+    public void registerDiscoveryService(ResolDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    private void createThing(String thingType, String thingID, String name) {\n+        ResolDiscoveryService service = discoveryService;\n+        logger.trace(\"Create thing Type='{}' id='{}'\", thingType, thingID);\n+\n+        if (service != null) {\n+            service.addResolThing(thingType, thingID, name);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolThingHandler thingHandler) {\n+        Thing t = thingHandler.getThing();\n+\n+        String thingType = t.getUID().getId();\n+\n+        if (!thingHandlerMap.containsKey(thingType)) {\n+            thingHandlerMap.put(thingType, thingHandler);\n+            logger.trace(\"register thingHandler for thing: {}\", thingType);\n+            updateThingHandlerStatus(thingHandler, this.getStatus());\n+        } else {\n+            logger.trace(\"thingHandler for thing: '{}' allready registerd\", thingType);\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolThingHandler thingHandler) {\n+        String thingID = thingHandler.getThing().getUID().getId();\n+        if (!thingHandlerMap.containsKey(thingID)) {\n+            logger.warn(\"thingHandler for thing: {} not registered\", thingID);\n+        } else {\n+            thingHandler.updateStatus(ThingStatus.OFFLINE);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+\n+        emThingHandlerMap.put(resolEmuEMThingHandler.getVbusAddress(), resolEmuEMThingHandler);\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (isConnected && con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+                updateStatus();\n+            } else {\n+                resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            }\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        if (!emThingHandlerMap.containsKey(resolEmuEMThingHandler.getVbusAddress())) {\n+            logger.warn(\"thingHandler for vbus address {} not registered\", resolEmuEMThingHandler.getVbusAddress());\n+        } else {\n+            resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            emThingHandlerMap.remove(resolEmuEMThingHandler.getVbusAddress());\n+        }\n+    }\n+\n+    private void updateThingHandlerStatus(ResolThingHandler thingHandler, ThingStatus status) {\n+        thingHandler.updateStatus(status);\n+    }\n+\n+    private Runnable pollingRunnable = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (!isConnected) {\n+                synchronized (ResolBridgeHandler.this) {\n+                    Connection connection = tcpConnection;\n+                    /* first cleanup in case there is an old but failed TCP connection around */\n+                    try {\n+                        if (connection != null) {\n+                            connection.disconnect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.stop();\n+                                }\n+                            }\n+\n+                            connection = null;\n+                            tcpConnection = null;\n+                        }\n+                    } catch (IOException e) {\n+                        logger.warn(\"TCP disconnect failed\", e);\n+                    }\n+                    TcpDataSource source = null;\n+                    /* now try to establish a new TCP connection */\n+                    try {\n+                        source = TcpDataSourceProvider.fetchInformation(InetAddress.getByName(ipAddress), 500);\n+                        if (source != null) {\n+                            source.setLivePassword(password);\n+                        }\n+                    } catch (IOException e) {\n+                        isConnected = false;\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                    }\n+                    if (source != null) {\n+                        try {\n+                            logger.debug(\"Opening a new connection...\");\n+                            connection = source.connectLive(0, 0x0020);\n+                            tcpConnection = connection;\n+                        } catch (Exception e) {\n+                            // this generic Exception catch is required, as TcpDataSource.connectLive throws this\n+                            // generic\n+                            // type\n+                            logger.debug(\"... failed.\");\n+                            isConnected = false;\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                        }\n+                        logger.debug(\"... succeeded.\");\n+\n+                        if (connection != null) {\n+                            try {\n+                                Thread.sleep(3000); // Wait for connection...\n+                            } catch (InterruptedException e) {\n+                                isConnected = (connection.getConnectionState()\n+                                        .equals(Connection.ConnectionState.CONNECTED));\n+                            }\n+\n+                            // Add a listener to the Connection to monitor state changes and\n+                            // read incoming frames\n+                            connection.addListener(new ResolConnectorAdapter());\n+                        }\n+                    }\n+                    // Establish the connection\n+                    if (connection != null) {\n+                        try {\n+                            connection.connect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.useConnection(connection);\n+                                }\n+                            }\n+                        } catch (IOException e) {\n+                            logger.warn(\"Connection failed: {}\", e.getMessage());\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMTg4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551021882", "bodyText": "scheduler tasks should not use sleep, because the threadpool is shared among all bindings and that could potentially exhaust the pool, affecting other bindings. You could schedule another task with a delay of 3sec.", "author": "fwolter", "createdAt": "2021-01-03T15:47:23Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();\n+\n+    private Map<Integer, @NonNull ResolEmuEMThingHandler> emThingHandlerMap = new HashMap<Integer, @NonNull ResolEmuEMThingHandler>();\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(locale);\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    // Managing Thing Discovery Service\n+\n+    @Nullable\n+    private ResolDiscoveryService discoveryService = null;\n+\n+    public void registerDiscoveryService(ResolDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    private void createThing(String thingType, String thingID, String name) {\n+        ResolDiscoveryService service = discoveryService;\n+        logger.trace(\"Create thing Type='{}' id='{}'\", thingType, thingID);\n+\n+        if (service != null) {\n+            service.addResolThing(thingType, thingID, name);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolThingHandler thingHandler) {\n+        Thing t = thingHandler.getThing();\n+\n+        String thingType = t.getUID().getId();\n+\n+        if (!thingHandlerMap.containsKey(thingType)) {\n+            thingHandlerMap.put(thingType, thingHandler);\n+            logger.trace(\"register thingHandler for thing: {}\", thingType);\n+            updateThingHandlerStatus(thingHandler, this.getStatus());\n+        } else {\n+            logger.trace(\"thingHandler for thing: '{}' allready registerd\", thingType);\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolThingHandler thingHandler) {\n+        String thingID = thingHandler.getThing().getUID().getId();\n+        if (!thingHandlerMap.containsKey(thingID)) {\n+            logger.warn(\"thingHandler for thing: {} not registered\", thingID);\n+        } else {\n+            thingHandler.updateStatus(ThingStatus.OFFLINE);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+\n+        emThingHandlerMap.put(resolEmuEMThingHandler.getVbusAddress(), resolEmuEMThingHandler);\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (isConnected && con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+                updateStatus();\n+            } else {\n+                resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            }\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        if (!emThingHandlerMap.containsKey(resolEmuEMThingHandler.getVbusAddress())) {\n+            logger.warn(\"thingHandler for vbus address {} not registered\", resolEmuEMThingHandler.getVbusAddress());\n+        } else {\n+            resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            emThingHandlerMap.remove(resolEmuEMThingHandler.getVbusAddress());\n+        }\n+    }\n+\n+    private void updateThingHandlerStatus(ResolThingHandler thingHandler, ThingStatus status) {\n+        thingHandler.updateStatus(status);\n+    }\n+\n+    private Runnable pollingRunnable = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (!isConnected) {\n+                synchronized (ResolBridgeHandler.this) {\n+                    Connection connection = tcpConnection;\n+                    /* first cleanup in case there is an old but failed TCP connection around */\n+                    try {\n+                        if (connection != null) {\n+                            connection.disconnect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.stop();\n+                                }\n+                            }\n+\n+                            connection = null;\n+                            tcpConnection = null;\n+                        }\n+                    } catch (IOException e) {\n+                        logger.warn(\"TCP disconnect failed\", e);\n+                    }\n+                    TcpDataSource source = null;\n+                    /* now try to establish a new TCP connection */\n+                    try {\n+                        source = TcpDataSourceProvider.fetchInformation(InetAddress.getByName(ipAddress), 500);\n+                        if (source != null) {\n+                            source.setLivePassword(password);\n+                        }\n+                    } catch (IOException e) {\n+                        isConnected = false;\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                    }\n+                    if (source != null) {\n+                        try {\n+                            logger.debug(\"Opening a new connection...\");\n+                            connection = source.connectLive(0, 0x0020);\n+                            tcpConnection = connection;\n+                        } catch (Exception e) {\n+                            // this generic Exception catch is required, as TcpDataSource.connectLive throws this\n+                            // generic\n+                            // type\n+                            logger.debug(\"... failed.\");\n+                            isConnected = false;\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                        }\n+                        logger.debug(\"... succeeded.\");\n+\n+                        if (connection != null) {\n+                            try {\n+                                Thread.sleep(3000); // Wait for connection...\n+                            } catch (InterruptedException e) {\n+                                isConnected = (connection.getConnectionState()\n+                                        .equals(Connection.ConnectionState.CONNECTED));\n+                            }\n+\n+                            // Add a listener to the Connection to monitor state changes and\n+                            // read incoming frames\n+                            connection.addListener(new ResolConnectorAdapter());\n+                        }\n+                    }\n+                    // Establish the connection\n+                    if (connection != null) {\n+                        try {\n+                            connection.connect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.useConnection(connection);\n+                                }\n+                            }\n+                        } catch (IOException e) {\n+                            logger.warn(\"Connection failed: {}\", e.getMessage());\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                            isConnected = false;\n+                        }\n+\n+                        try {\n+                            Thread.sleep(3000); // after a reconnect wait 3 sec", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMjEyNw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551022127", "bodyText": "If you apply above change.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        pollingJob = scheduler.scheduleWithFixedDelay(pollingRunnable, 0, refreshInterval, TimeUnit.SECONDS);\n          \n          \n            \n                        pollingJob = scheduler.scheduleWithFixedDelay(this::pollingRunnable, 0, refreshInterval, TimeUnit.SECONDS);", "author": "fwolter", "createdAt": "2021-01-03T15:49:44Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();\n+\n+    private Map<Integer, @NonNull ResolEmuEMThingHandler> emThingHandlerMap = new HashMap<Integer, @NonNull ResolEmuEMThingHandler>();\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(locale);\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    // Managing Thing Discovery Service\n+\n+    @Nullable\n+    private ResolDiscoveryService discoveryService = null;\n+\n+    public void registerDiscoveryService(ResolDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    private void createThing(String thingType, String thingID, String name) {\n+        ResolDiscoveryService service = discoveryService;\n+        logger.trace(\"Create thing Type='{}' id='{}'\", thingType, thingID);\n+\n+        if (service != null) {\n+            service.addResolThing(thingType, thingID, name);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolThingHandler thingHandler) {\n+        Thing t = thingHandler.getThing();\n+\n+        String thingType = t.getUID().getId();\n+\n+        if (!thingHandlerMap.containsKey(thingType)) {\n+            thingHandlerMap.put(thingType, thingHandler);\n+            logger.trace(\"register thingHandler for thing: {}\", thingType);\n+            updateThingHandlerStatus(thingHandler, this.getStatus());\n+        } else {\n+            logger.trace(\"thingHandler for thing: '{}' allready registerd\", thingType);\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolThingHandler thingHandler) {\n+        String thingID = thingHandler.getThing().getUID().getId();\n+        if (!thingHandlerMap.containsKey(thingID)) {\n+            logger.warn(\"thingHandler for thing: {} not registered\", thingID);\n+        } else {\n+            thingHandler.updateStatus(ThingStatus.OFFLINE);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+\n+        emThingHandlerMap.put(resolEmuEMThingHandler.getVbusAddress(), resolEmuEMThingHandler);\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (isConnected && con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+                updateStatus();\n+            } else {\n+                resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            }\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        if (!emThingHandlerMap.containsKey(resolEmuEMThingHandler.getVbusAddress())) {\n+            logger.warn(\"thingHandler for vbus address {} not registered\", resolEmuEMThingHandler.getVbusAddress());\n+        } else {\n+            resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            emThingHandlerMap.remove(resolEmuEMThingHandler.getVbusAddress());\n+        }\n+    }\n+\n+    private void updateThingHandlerStatus(ResolThingHandler thingHandler, ThingStatus status) {\n+        thingHandler.updateStatus(status);\n+    }\n+\n+    private Runnable pollingRunnable = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (!isConnected) {\n+                synchronized (ResolBridgeHandler.this) {\n+                    Connection connection = tcpConnection;\n+                    /* first cleanup in case there is an old but failed TCP connection around */\n+                    try {\n+                        if (connection != null) {\n+                            connection.disconnect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.stop();\n+                                }\n+                            }\n+\n+                            connection = null;\n+                            tcpConnection = null;\n+                        }\n+                    } catch (IOException e) {\n+                        logger.warn(\"TCP disconnect failed\", e);\n+                    }\n+                    TcpDataSource source = null;\n+                    /* now try to establish a new TCP connection */\n+                    try {\n+                        source = TcpDataSourceProvider.fetchInformation(InetAddress.getByName(ipAddress), 500);\n+                        if (source != null) {\n+                            source.setLivePassword(password);\n+                        }\n+                    } catch (IOException e) {\n+                        isConnected = false;\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                    }\n+                    if (source != null) {\n+                        try {\n+                            logger.debug(\"Opening a new connection...\");\n+                            connection = source.connectLive(0, 0x0020);\n+                            tcpConnection = connection;\n+                        } catch (Exception e) {\n+                            // this generic Exception catch is required, as TcpDataSource.connectLive throws this\n+                            // generic\n+                            // type\n+                            logger.debug(\"... failed.\");\n+                            isConnected = false;\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                        }\n+                        logger.debug(\"... succeeded.\");\n+\n+                        if (connection != null) {\n+                            try {\n+                                Thread.sleep(3000); // Wait for connection...\n+                            } catch (InterruptedException e) {\n+                                isConnected = (connection.getConnectionState()\n+                                        .equals(Connection.ConnectionState.CONNECTED));\n+                            }\n+\n+                            // Add a listener to the Connection to monitor state changes and\n+                            // read incoming frames\n+                            connection.addListener(new ResolConnectorAdapter());\n+                        }\n+                    }\n+                    // Establish the connection\n+                    if (connection != null) {\n+                        try {\n+                            connection.connect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.useConnection(connection);\n+                                }\n+                            }\n+                        } catch (IOException e) {\n+                            logger.warn(\"Connection failed: {}\", e.getMessage());\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                            isConnected = false;\n+                        }\n+\n+                        try {\n+                            Thread.sleep(3000); // after a reconnect wait 3 sec\n+                        } catch (InterruptedException e) {\n+                            /* ignore interruptions */\n+                        }\n+                        isConnected = connection.getConnectionState().equals(Connection.ConnectionState.CONNECTED);\n+                    } else {\n+                        isConnected = false;\n+                    }\n+                    if (!isConnected) {\n+                        logger.debug(\"Cannot establish connection to {} ({})\", ipAddress, unconnectedReason);\n+                    } else {\n+                        unconnectedReason = \"\";\n+                    }\n+                    updateStatus();\n+                }\n+            }\n+        }\n+    };\n+\n+    /* check if the given value is a special one like 888.8 or 999.9 for shortcut or open load on a sensor wire */\n+    private boolean isSpecialValue(Double dd) {\n+        if ((Math.abs(dd - 888.8) < 0.1) || (Math.abs(dd - (-888.8)) < 0.1)) {\n+            /* value out of range */\n+            return true;\n+        }\n+        if (Math.abs(dd - 999.9) < 0.1) {\n+            /* sensor not reachable */\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private synchronized void startAutomaticRefresh() {\n+        ScheduledFuture<?> job = pollingJob;\n+        if (job == null || job.isCancelled()) {\n+            pollingJob = scheduler.scheduleWithFixedDelay(pollingRunnable, 0, refreshInterval, TimeUnit.SECONDS);", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMjIyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551022229", "bodyText": "You could move this into a separate class, as this class is already quite long.", "author": "fwolter", "createdAt": "2021-01-03T15:50:57Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();\n+\n+    private Map<Integer, @NonNull ResolEmuEMThingHandler> emThingHandlerMap = new HashMap<Integer, @NonNull ResolEmuEMThingHandler>();\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(locale);\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    // Managing Thing Discovery Service\n+\n+    @Nullable\n+    private ResolDiscoveryService discoveryService = null;\n+\n+    public void registerDiscoveryService(ResolDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    private void createThing(String thingType, String thingID, String name) {\n+        ResolDiscoveryService service = discoveryService;\n+        logger.trace(\"Create thing Type='{}' id='{}'\", thingType, thingID);\n+\n+        if (service != null) {\n+            service.addResolThing(thingType, thingID, name);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolThingHandler thingHandler) {\n+        Thing t = thingHandler.getThing();\n+\n+        String thingType = t.getUID().getId();\n+\n+        if (!thingHandlerMap.containsKey(thingType)) {\n+            thingHandlerMap.put(thingType, thingHandler);\n+            logger.trace(\"register thingHandler for thing: {}\", thingType);\n+            updateThingHandlerStatus(thingHandler, this.getStatus());\n+        } else {\n+            logger.trace(\"thingHandler for thing: '{}' allready registerd\", thingType);\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolThingHandler thingHandler) {\n+        String thingID = thingHandler.getThing().getUID().getId();\n+        if (!thingHandlerMap.containsKey(thingID)) {\n+            logger.warn(\"thingHandler for thing: {} not registered\", thingID);\n+        } else {\n+            thingHandler.updateStatus(ThingStatus.OFFLINE);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+\n+        emThingHandlerMap.put(resolEmuEMThingHandler.getVbusAddress(), resolEmuEMThingHandler);\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (isConnected && con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+                updateStatus();\n+            } else {\n+                resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            }\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        if (!emThingHandlerMap.containsKey(resolEmuEMThingHandler.getVbusAddress())) {\n+            logger.warn(\"thingHandler for vbus address {} not registered\", resolEmuEMThingHandler.getVbusAddress());\n+        } else {\n+            resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            emThingHandlerMap.remove(resolEmuEMThingHandler.getVbusAddress());\n+        }\n+    }\n+\n+    private void updateThingHandlerStatus(ResolThingHandler thingHandler, ThingStatus status) {\n+        thingHandler.updateStatus(status);\n+    }\n+\n+    private Runnable pollingRunnable = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (!isConnected) {\n+                synchronized (ResolBridgeHandler.this) {\n+                    Connection connection = tcpConnection;\n+                    /* first cleanup in case there is an old but failed TCP connection around */\n+                    try {\n+                        if (connection != null) {\n+                            connection.disconnect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.stop();\n+                                }\n+                            }\n+\n+                            connection = null;\n+                            tcpConnection = null;\n+                        }\n+                    } catch (IOException e) {\n+                        logger.warn(\"TCP disconnect failed\", e);\n+                    }\n+                    TcpDataSource source = null;\n+                    /* now try to establish a new TCP connection */\n+                    try {\n+                        source = TcpDataSourceProvider.fetchInformation(InetAddress.getByName(ipAddress), 500);\n+                        if (source != null) {\n+                            source.setLivePassword(password);\n+                        }\n+                    } catch (IOException e) {\n+                        isConnected = false;\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                    }\n+                    if (source != null) {\n+                        try {\n+                            logger.debug(\"Opening a new connection...\");\n+                            connection = source.connectLive(0, 0x0020);\n+                            tcpConnection = connection;\n+                        } catch (Exception e) {\n+                            // this generic Exception catch is required, as TcpDataSource.connectLive throws this\n+                            // generic\n+                            // type\n+                            logger.debug(\"... failed.\");\n+                            isConnected = false;\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                        }\n+                        logger.debug(\"... succeeded.\");\n+\n+                        if (connection != null) {\n+                            try {\n+                                Thread.sleep(3000); // Wait for connection...\n+                            } catch (InterruptedException e) {\n+                                isConnected = (connection.getConnectionState()\n+                                        .equals(Connection.ConnectionState.CONNECTED));\n+                            }\n+\n+                            // Add a listener to the Connection to monitor state changes and\n+                            // read incoming frames\n+                            connection.addListener(new ResolConnectorAdapter());\n+                        }\n+                    }\n+                    // Establish the connection\n+                    if (connection != null) {\n+                        try {\n+                            connection.connect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.useConnection(connection);\n+                                }\n+                            }\n+                        } catch (IOException e) {\n+                            logger.warn(\"Connection failed: {}\", e.getMessage());\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                            isConnected = false;\n+                        }\n+\n+                        try {\n+                            Thread.sleep(3000); // after a reconnect wait 3 sec\n+                        } catch (InterruptedException e) {\n+                            /* ignore interruptions */\n+                        }\n+                        isConnected = connection.getConnectionState().equals(Connection.ConnectionState.CONNECTED);\n+                    } else {\n+                        isConnected = false;\n+                    }\n+                    if (!isConnected) {\n+                        logger.debug(\"Cannot establish connection to {} ({})\", ipAddress, unconnectedReason);\n+                    } else {\n+                        unconnectedReason = \"\";\n+                    }\n+                    updateStatus();\n+                }\n+            }\n+        }\n+    };\n+\n+    /* check if the given value is a special one like 888.8 or 999.9 for shortcut or open load on a sensor wire */\n+    private boolean isSpecialValue(Double dd) {\n+        if ((Math.abs(dd - 888.8) < 0.1) || (Math.abs(dd - (-888.8)) < 0.1)) {\n+            /* value out of range */\n+            return true;\n+        }\n+        if (Math.abs(dd - 999.9) < 0.1) {\n+            /* sensor not reachable */\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private synchronized void startAutomaticRefresh() {\n+        ScheduledFuture<?> job = pollingJob;\n+        if (job == null || job.isCancelled()) {\n+            pollingJob = scheduler.scheduleWithFixedDelay(pollingRunnable, 0, refreshInterval, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    public ThingStatus getStatus() {\n+        return getThing().getStatus();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // No commands supported - nothing to do\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus();\n+        ResolBridgeConfiguration configuration = getConfigAs(ResolBridgeConfiguration.class);\n+        ipAddress = configuration.ipAddress;\n+        refreshInterval = configuration.refreshInterval;\n+        password = configuration.password;\n+        startAutomaticRefresh();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> job = pollingJob;\n+        if (job != null) {\n+            job.cancel(true);\n+            pollingJob = null;\n+        }\n+        try {\n+            Connection connection = tcpConnection;\n+            if (connection != null) {\n+                connection.disconnect();\n+                for (int x : emThingHandlerMap.keySet()) {\n+                    ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                    if (emu != null) {\n+                        emu.stop();\n+                    }\n+                }\n+            }\n+        } catch (IOException ioe) {\n+            // we don't care about exceptions on disconnect in dispose\n+        }\n+    }\n+\n+    /* adapter to react on connection state changes and handle received packets */\n+    private class ResolConnectorAdapter extends ConnectionAdapter {", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU2MTMyNg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551561326", "bodyText": "This will get quite a big refactoring. Do you think it is worth it?", "author": "ramack", "createdAt": "2021-01-04T20:50:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMjIyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU3NTgxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551575814", "bodyText": "It's only three clicks in Eclipse. It was only a suggestion. I won't insist on changing it.", "author": "fwolter", "createdAt": "2021-01-04T21:21:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMjIyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4MjUxNg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551582516", "bodyText": "I tried that, but it failed. And the inner class accesses quite some outer class fields - maybe that is also not the nicest design but I would not want to change that without a strong need \ud83d\ude00", "author": "ramack", "createdAt": "2021-01-04T21:36:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMjIyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMjU1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551022558", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.", "author": "fwolter", "createdAt": "2021-01-03T15:53:56Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();\n+\n+    private Map<Integer, @NonNull ResolEmuEMThingHandler> emThingHandlerMap = new HashMap<Integer, @NonNull ResolEmuEMThingHandler>();\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(locale);\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    // Managing Thing Discovery Service\n+\n+    @Nullable\n+    private ResolDiscoveryService discoveryService = null;\n+\n+    public void registerDiscoveryService(ResolDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    private void createThing(String thingType, String thingID, String name) {\n+        ResolDiscoveryService service = discoveryService;\n+        logger.trace(\"Create thing Type='{}' id='{}'\", thingType, thingID);\n+\n+        if (service != null) {\n+            service.addResolThing(thingType, thingID, name);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolThingHandler thingHandler) {\n+        Thing t = thingHandler.getThing();\n+\n+        String thingType = t.getUID().getId();\n+\n+        if (!thingHandlerMap.containsKey(thingType)) {\n+            thingHandlerMap.put(thingType, thingHandler);\n+            logger.trace(\"register thingHandler for thing: {}\", thingType);\n+            updateThingHandlerStatus(thingHandler, this.getStatus());\n+        } else {\n+            logger.trace(\"thingHandler for thing: '{}' allready registerd\", thingType);\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolThingHandler thingHandler) {\n+        String thingID = thingHandler.getThing().getUID().getId();\n+        if (!thingHandlerMap.containsKey(thingID)) {\n+            logger.warn(\"thingHandler for thing: {} not registered\", thingID);\n+        } else {\n+            thingHandler.updateStatus(ThingStatus.OFFLINE);\n+        }\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+\n+        emThingHandlerMap.put(resolEmuEMThingHandler.getVbusAddress(), resolEmuEMThingHandler);\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (isConnected && con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+                updateStatus();\n+            } else {\n+                resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            }\n+        }\n+    }\n+\n+    public void unregisterThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        if (!emThingHandlerMap.containsKey(resolEmuEMThingHandler.getVbusAddress())) {\n+            logger.warn(\"thingHandler for vbus address {} not registered\", resolEmuEMThingHandler.getVbusAddress());\n+        } else {\n+            resolEmuEMThingHandler.updateStatus(ThingStatus.OFFLINE);\n+            emThingHandlerMap.remove(resolEmuEMThingHandler.getVbusAddress());\n+        }\n+    }\n+\n+    private void updateThingHandlerStatus(ResolThingHandler thingHandler, ThingStatus status) {\n+        thingHandler.updateStatus(status);\n+    }\n+\n+    private Runnable pollingRunnable = new Runnable() {\n+        @Override\n+        public void run() {\n+            if (!isConnected) {\n+                synchronized (ResolBridgeHandler.this) {\n+                    Connection connection = tcpConnection;\n+                    /* first cleanup in case there is an old but failed TCP connection around */\n+                    try {\n+                        if (connection != null) {\n+                            connection.disconnect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.stop();\n+                                }\n+                            }\n+\n+                            connection = null;\n+                            tcpConnection = null;\n+                        }\n+                    } catch (IOException e) {\n+                        logger.warn(\"TCP disconnect failed\", e);\n+                    }\n+                    TcpDataSource source = null;\n+                    /* now try to establish a new TCP connection */\n+                    try {\n+                        source = TcpDataSourceProvider.fetchInformation(InetAddress.getByName(ipAddress), 500);\n+                        if (source != null) {\n+                            source.setLivePassword(password);\n+                        }\n+                    } catch (IOException e) {\n+                        isConnected = false;\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                    }\n+                    if (source != null) {\n+                        try {\n+                            logger.debug(\"Opening a new connection...\");\n+                            connection = source.connectLive(0, 0x0020);\n+                            tcpConnection = connection;\n+                        } catch (Exception e) {\n+                            // this generic Exception catch is required, as TcpDataSource.connectLive throws this\n+                            // generic\n+                            // type\n+                            logger.debug(\"... failed.\");\n+                            isConnected = false;\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                        }\n+                        logger.debug(\"... succeeded.\");\n+\n+                        if (connection != null) {\n+                            try {\n+                                Thread.sleep(3000); // Wait for connection...\n+                            } catch (InterruptedException e) {\n+                                isConnected = (connection.getConnectionState()\n+                                        .equals(Connection.ConnectionState.CONNECTED));\n+                            }\n+\n+                            // Add a listener to the Connection to monitor state changes and\n+                            // read incoming frames\n+                            connection.addListener(new ResolConnectorAdapter());\n+                        }\n+                    }\n+                    // Establish the connection\n+                    if (connection != null) {\n+                        try {\n+                            connection.connect();\n+                            for (int x : emThingHandlerMap.keySet()) {\n+                                ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                                if (emu != null) {\n+                                    emu.useConnection(connection);\n+                                }\n+                            }\n+                        } catch (IOException e) {\n+                            logger.warn(\"Connection failed: {}\", e.getMessage());\n+                            unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                            isConnected = false;\n+                        }\n+\n+                        try {\n+                            Thread.sleep(3000); // after a reconnect wait 3 sec\n+                        } catch (InterruptedException e) {\n+                            /* ignore interruptions */\n+                        }\n+                        isConnected = connection.getConnectionState().equals(Connection.ConnectionState.CONNECTED);\n+                    } else {\n+                        isConnected = false;\n+                    }\n+                    if (!isConnected) {\n+                        logger.debug(\"Cannot establish connection to {} ({})\", ipAddress, unconnectedReason);\n+                    } else {\n+                        unconnectedReason = \"\";\n+                    }\n+                    updateStatus();\n+                }\n+            }\n+        }\n+    };\n+\n+    /* check if the given value is a special one like 888.8 or 999.9 for shortcut or open load on a sensor wire */\n+    private boolean isSpecialValue(Double dd) {\n+        if ((Math.abs(dd - 888.8) < 0.1) || (Math.abs(dd - (-888.8)) < 0.1)) {\n+            /* value out of range */\n+            return true;\n+        }\n+        if (Math.abs(dd - 999.9) < 0.1) {\n+            /* sensor not reachable */\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private synchronized void startAutomaticRefresh() {\n+        ScheduledFuture<?> job = pollingJob;\n+        if (job == null || job.isCancelled()) {\n+            pollingJob = scheduler.scheduleWithFixedDelay(pollingRunnable, 0, refreshInterval, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    public ThingStatus getStatus() {\n+        return getThing().getStatus();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // No commands supported - nothing to do\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus();\n+        ResolBridgeConfiguration configuration = getConfigAs(ResolBridgeConfiguration.class);\n+        ipAddress = configuration.ipAddress;\n+        refreshInterval = configuration.refreshInterval;\n+        password = configuration.password;\n+        startAutomaticRefresh();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> job = pollingJob;\n+        if (job != null) {\n+            job.cancel(true);\n+            pollingJob = null;\n+        }\n+        try {\n+            Connection connection = tcpConnection;\n+            if (connection != null) {\n+                connection.disconnect();\n+                for (int x : emThingHandlerMap.keySet()) {\n+                    ResolEmuEMThingHandler emu = emThingHandlerMap.get(x);\n+                    if (emu != null) {\n+                        emu.stop();\n+                    }\n+                }\n+            }\n+        } catch (IOException ioe) {\n+            // we don't care about exceptions on disconnect in dispose\n+        }\n+    }\n+\n+    /* adapter to react on connection state changes and handle received packets */\n+    private class ResolConnectorAdapter extends ConnectionAdapter {\n+        @Override\n+        public void connectionStateChanged(@Nullable Connection connection) {\n+            synchronized (ResolBridgeHandler.this) {\n+                if (connection == null) {\n+                    isConnected = false;\n+                } else {\n+                    ConnectionState connState = connection.getConnectionState();\n+                    isConnected = ConnectionState.CONNECTED.equals(connState);\n+                    logger.info(\"Connection state changed to: {}\", connState.toString());\n+\n+                    if (isConnected) {\n+                        unconnectedReason = \"\";\n+                    } else {\n+                        unconnectedReason = \"TCP connection failed: \" + connState.toString();\n+                    }\n+                }\n+                updateStatus();\n+            }\n+        }\n+\n+        @Override\n+        public void packetReceived(@Nullable Connection connection, @Nullable Packet packet) {\n+            if (connection == null || packet == null) {\n+                return;\n+            }\n+            String thingType = spec.getSourceDeviceSpec(packet).getName(); // use En here\n+\n+            thingType = thingType.replace(\" [\", \"-\");\n+            thingType = thingType.replace(\"]\", \"\");\n+            thingType = thingType.replace(\" #\", \"-\");\n+            thingType = thingType.replace(\" \", \"_\");\n+            thingType = thingType.replace(\"/\", \"_\");\n+            thingType = thingType.replaceAll(\"[^A-Za-z0-9_-]+\", \"_\");\n+\n+            /*\n+             * It would be nice for the combination of MX and EM devices to filter only those with a peerAddress of\n+             * 0x10, because the MX redelivers the data from the EM to the DFA.\n+             * But the MX is the exception in this case and many other controllers do not redeliver data, so we keep it.\n+             */\n+            logger.trace(\"Received Data from {} (0x{}/0x{}) naming it {}\",\n+                    spec.getSourceDeviceSpec(packet).getName(lang),\n+                    Integer.toHexString(spec.getSourceDeviceSpec(packet).getSelfAddress()),\n+                    Integer.toHexString(spec.getSourceDeviceSpec(packet).getPeerAddress()), thingType);\n+\n+            if (emThingHandlerMap.containsKey(spec.getSourceDeviceSpec(packet).getPeerAddress())) {\n+                ResolEmuEMThingHandler emThingHandler = emThingHandlerMap\n+                        .get(spec.getSourceDeviceSpec(packet).getPeerAddress());\n+                if (emThingHandler != null) {\n+                    emThingHandler.handle(packet);\n+                }\n+            } else {\n+                // a generic packet was received, so let's handle it here\n+                if (!availableDevices.contains(thingType)) {\n+                    // register the seen device\n+                    createThing(ResolBindingConstants.THING_ID_DEVICE, thingType,\n+                            spec.getSourceDeviceSpec(packet).getName(lang));\n+                    availableDevices.add(thingType);\n+                }\n+\n+                PacketFieldValue[] pfvs = spec.getPacketFieldValuesForHeaders(new Packet[] { packet });\n+                for (PacketFieldValue pfv : pfvs) {\n+                    logger.trace(\"Id: {}, Name: {}, Raw: {}, Text: {}\", pfv.getPacketFieldId(), pfv.getName(lang),\n+                            pfv.getRawValueDouble(), pfv.formatTextValue(null, Locale.getDefault()));\n+                    ResolThingHandler thingHandler = thingHandlerMap.get(thingType);\n+                    if (thingHandler != null) {\n+                        String channelId = pfv.getName(); // use English here\n+                        channelId = channelId.replace(\" [\", \"-\");\n+                        channelId = channelId.replace(\"]\", \"\");\n+                        channelId = channelId.replace(\"(\", \"-\");\n+                        channelId = channelId.replace(\")\", \"\");\n+                        channelId = channelId.replace(\" #\", \"-\");\n+                        channelId = channelId.replaceAll(\"[^A-Za-z0-9_-]+\", \"_\");\n+\n+                        ChannelTypeUID channelTypeUID;\n+\n+                        if (pfv.getPacketFieldSpec().getUnit().getUnitId() >= 0) {\n+                            channelTypeUID = new ChannelTypeUID(ResolBindingConstants.BINDING_ID,\n+                                    pfv.getPacketFieldSpec().getUnit().getUnitCodeText());\n+                        } else if (pfv.getPacketFieldSpec().getType() == SpecificationFile.Type.Number) {\n+                            if (pfv.getEnumVariant() != null) {\n+                                // Do not auto-link the numeric value, if there is an enum for it\n+                                channelTypeUID = new ChannelTypeUID(ResolBindingConstants.BINDING_ID, \"NoneHidden\");\n+                            } else {\n+                                channelTypeUID = new ChannelTypeUID(ResolBindingConstants.BINDING_ID, \"None\");\n+                            }\n+\n+                        } else if (pfv.getPacketFieldSpec().getType() == SpecificationFile.Type.DateTime) {\n+                            channelTypeUID = new ChannelTypeUID(ResolBindingConstants.BINDING_ID, \"DateTime\");\n+                        } else {\n+                            channelTypeUID = new ChannelTypeUID(ResolBindingConstants.BINDING_ID, \"None\");\n+                        }\n+\n+                        String acceptedItemType = \"String\";\n+\n+                        Thing thing = thingHandler.getThing();\n+                        switch (pfv.getPacketFieldSpec().getType()) {\n+                            case DateTime:\n+                                acceptedItemType = \"DateTime\";\n+                                break;\n+                            case WeekTime:\n+                            case Number:\n+                                acceptedItemType = ResolChannelTypeProvider\n+                                        .itemTypeForUnit(pfv.getPacketFieldSpec().getUnit());\n+                                break;\n+                            case Time:\n+                            default:\n+                                acceptedItemType = \"String\";\n+                                break;\n+                        }\n+                        Channel a = thing.getChannel(channelId);\n+\n+                        if (a == null && pfv.getRawValueDouble() != null) {\n+                            ThingBuilder thingBuilder = thingHandler.editThing();\n+\n+                            ChannelUID channelUID = new ChannelUID(thing.getUID(), channelId);\n+                            Channel channel = ChannelBuilder.create(channelUID, acceptedItemType)\n+                                    .withType(channelTypeUID).withLabel(pfv.getName(lang)).build();\n+\n+                            thingBuilder.withChannel(channel).withLabel(thing.getLabel());\n+\n+                            thingHandler.updateThing(thingBuilder.build());\n+                        }\n+\n+                        switch (pfv.getPacketFieldSpec().getType()) {\n+                            case Number:\n+                                Double dd = pfv.getRawValueDouble();\n+                                if (dd != null) {\n+                                    if (isSpecialValue(dd)) {\n+                                        /* some error occurred in the measurement - ignore the value */\n+                                    } else {\n+                                        thingHandler.setChannelValue(channelId, dd.doubleValue());\n+                                    }\n+                                } else {\n+                                    /*\n+                                     * field not available in this packet, e. g. old firmware version\n+                                     * not (yet) transmitting it\n+                                     */\n+                                }\n+                                break;\n+                            case DateTime:\n+                                thingHandler.setChannelValue(channelId, pfv.getRawValueDate());\n+                                break;\n+                            case WeekTime:\n+                            case Time:\n+                            default:\n+                                thingHandler.setChannelValue(channelId,\n+                                        pfv.formatTextValue(pfv.getPacketFieldSpec().getUnit(), locale));\n+                        }\n+\n+                        if (pfv.getEnumVariant() != null) {\n+                            // if we have an enum, we additionally add that as channel\n+                            String enumChannelId = channelId + \"-str\";\n+                            if (thing.getChannel(enumChannelId) == null) {\n+                                ChannelTypeUID enumChannelTypeUID = new ChannelTypeUID(ResolBindingConstants.BINDING_ID,\n+                                        \"None\");\n+                                ThingBuilder thingBuilder = thingHandler.editThing();\n+\n+                                ChannelUID enumChannelUID = new ChannelUID(thing.getUID(), enumChannelId);\n+                                Channel channel = ChannelBuilder.create(enumChannelUID, \"String\")\n+                                        .withType(enumChannelTypeUID).withLabel(pfv.getName(lang)).build();\n+\n+                                thingBuilder.withChannel(channel).withLabel(thing.getLabel());\n+\n+                                thingHandler.updateThing(thingBuilder.build());\n+                            }\n+\n+                            thingHandler.setChannelValue(enumChannelId, pfv.getEnumVariant().getText(lang));\n+                        }\n+                    } else {\n+                        logger.info(\"ThingHandler for {} not registered.\", thingType);", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMjY4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551022686", "bodyText": "See above. Method.", "author": "fwolter", "createdAt": "2021-01-03T15:55:09Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends BaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay\";\n+    public static final String CHANNEL_TEMP = \"temperature\";\n+    public static final String CHANNEL_RESIST = \"resitor\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+\n+    private int deviceId = 1;\n+\n+    @Nullable\n+    ResolBridgeHandler bridgeHandler;\n+\n+    @Nullable\n+    private EmDeviceEmulator device;\n+\n+    // Background Runables\n+    @Nullable\n+    private ScheduledFuture<?> updateJob;\n+\n+    Pattern relayPattern = Pattern.compile(\"Pump speed relay (\\\\d*).1\");\n+\n+    public ResolEmuEMThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolEmuEMConfiguration configuration = getConfigAs(ResolEmuEMConfiguration.class);\n+        deviceId = configuration.deviceId;\n+        vbusAddress = 0x6650 + deviceId;\n+\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        EmDeviceEmulator dev = device;\n+        if (dev != null) {\n+            dev.stop();\n+            dev.removePropertyChangeListener(this);\n+        }\n+        unregisterResolThingListener(bridgeHandler);\n+    }\n+\n+    private Runnable updateRunnable = new Runnable() {\n+\n+        private long lastTime = System.currentTimeMillis();\n+\n+        @Override\n+        public void run() {", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMjgwOA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551022808", "bodyText": "What's the purpose of this method?", "author": "fwolter", "createdAt": "2021-01-03T15:56:04Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends BaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay\";\n+    public static final String CHANNEL_TEMP = \"temperature\";\n+    public static final String CHANNEL_RESIST = \"resitor\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+\n+    private int deviceId = 1;\n+\n+    @Nullable\n+    ResolBridgeHandler bridgeHandler;\n+\n+    @Nullable\n+    private EmDeviceEmulator device;\n+\n+    // Background Runables\n+    @Nullable\n+    private ScheduledFuture<?> updateJob;\n+\n+    Pattern relayPattern = Pattern.compile(\"Pump speed relay (\\\\d*).1\");\n+\n+    public ResolEmuEMThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolEmuEMConfiguration configuration = getConfigAs(ResolEmuEMConfiguration.class);\n+        deviceId = configuration.deviceId;\n+        vbusAddress = 0x6650 + deviceId;\n+\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        EmDeviceEmulator dev = device;\n+        if (dev != null) {\n+            dev.stop();\n+            dev.removePropertyChangeListener(this);\n+        }\n+        unregisterResolThingListener(bridgeHandler);\n+    }\n+\n+    private Runnable updateRunnable = new Runnable() {\n+\n+        private long lastTime = System.currentTimeMillis();\n+\n+        @Override\n+        public void run() {\n+            EmDeviceEmulator d = device;\n+            if (d != null) {\n+                long now = System.currentTimeMillis();\n+                int diff = (int) (now - lastTime);\n+                lastTime = now;\n+\n+                d.update(diff);\n+            }\n+        }\n+    };\n+\n+    private void startAutomaticUpdate() {\n+        ScheduledFuture<?> job = updateJob;\n+        if (job == null || job.isCancelled()) {\n+            updateJob = scheduler.scheduleWithFixedDelay(updateRunnable, 0, 1, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for thing {}.\", thing.getThingTypeUID());\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    private void registerResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.registerResolThingListener(this);\n+        } else {\n+            logger.debug(\"Can't register {} at bridge as bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    private void unregisterResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.unregisterThingListener(this);\n+        } else {\n+            logger.debug(\"Can't unregister {} at bridge as bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    @Override\n+    public void updateStatus(ThingStatus status) {\n+        super.updateStatus(status);\n+    }", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU2Mjg5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551562897", "bodyText": "OMG - what did I do here? For sure this shall vanish.", "author": "ramack", "createdAt": "2021-01-04T20:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMjgwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYwODgxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551608818", "bodyText": "ah, now as I removed it the compiler reminds me why it is there... actually it changes the access from protected to public to allow the call from ResolBridgeHandler.registerResolThingListener()", "author": "ramack", "createdAt": "2021-01-04T22:33:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMjgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzEyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551023125", "bodyText": "What's the purpose of these?", "author": "fwolter", "createdAt": "2021-01-03T15:58:42Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolThingHandler.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.Objects;\n+import java.util.TimeZone;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ResolThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolThingHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolThingHandler.class);\n+\n+    @Nullable\n+    ResolBridgeHandler bridgeHandler;\n+\n+    public ResolThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        /* we ignore the commands for now on purpose */\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public ThingBuilder editThing() {\n+        return super.editThing();\n+    }\n+\n+    @Override\n+    public void updateStatus(ThingStatus status) {\n+        super.updateStatus(status);\n+    }\n+\n+    @Override\n+    public void updateThing(Thing thing) {\n+        super.updateThing(thing);\n+    }", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYwOTA2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551609069", "bodyText": "same here to extend the access", "author": "ramack", "createdAt": "2021-01-04T22:33:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzEyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzMwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551023309", "bodyText": "You could make this a field to save resources.", "author": "fwolter", "createdAt": "2021-01-03T15:59:33Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolThingHandler.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.Objects;\n+import java.util.TimeZone;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ResolThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolThingHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolThingHandler.class);\n+\n+    @Nullable\n+    ResolBridgeHandler bridgeHandler;\n+\n+    public ResolThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        /* we ignore the commands for now on purpose */\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public ThingBuilder editThing() {\n+        return super.editThing();\n+    }\n+\n+    @Override\n+    public void updateStatus(ThingStatus status) {\n+        super.updateStatus(status);\n+    }\n+\n+    @Override\n+    public void updateThing(Thing thing) {\n+        super.updateThing(thing);\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for device.\");\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    private void registerResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.registerResolThingListener(this);\n+        } else {\n+            logger.debug(\"Can't register {} at bridge bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    private void unregisterResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.unregisterThingListener(this);\n+        } else {\n+            logger.debug(\"Can't unregister {} at bridge bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    public void setChannelValue(String channelId, String value) {\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            logger.warn(\"Channel '{}:{}' not implemented\", getThing().getUID().getId(), channelId);\n+        } else if (!\"String\".contentEquals(Objects.requireNonNullElse(channel.getAcceptedItemType(), \"\"))) {\n+            logger.trace(\"Channel '{}:{}' expected to have a String type for parameters '{}'\",\n+                    getThing().getUID().getId(), channelId, value.toString());\n+        } else {\n+            this.updateState(channelId, new StringType(value));\n+        }\n+    }\n+\n+    public void setChannelValue(String channelId, Date value) {\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            logger.warn(\"Channel '{}:{}' not implemented\", getThing().getUID().getId(), channelId);\n+        } else if (!\"DateTime\".equals(channel.getAcceptedItemType())) {\n+            logger.trace(\"Channel '{}:{}' expected to have a DateTime type for parameters '{}'\",\n+                    getThing().getUID().getId(), channelId, value.toString());\n+        } else {\n+            SimpleDateFormat s = new SimpleDateFormat(DateTimeType.DATE_PATTERN_WITH_TZ_AND_MS_GENERAL);", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzM1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551023353", "bodyText": "Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.unmodifiableSet(\n          \n          \n            \n                        Stream.of(THING_TYPE_UID_BRIDGE, THING_TYPE_UID_DEVICE, THING_TYPE_UID_EMU_EM).collect(Collectors.toSet()));\n          \n          \n            \n                public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Set.of(THING_TYPE_UID_BRIDGE, THING_TYPE_UID_DEVICE, THING_TYPE_UID_EMU_EM);", "author": "fwolter", "createdAt": "2021-01-03T16:00:05Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/ResolBindingConstants.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link ResolBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBindingConstants {\n+\n+    private static final String BRIDGE_VBUSLAN = \"vbuslan\";\n+\n+    public static final String BINDING_ID = \"resol\";\n+\n+    // List of all ChannelTypeUIDs is empty, as we got totally rid of static channel types.\n+    // ChannelTypeUIDs are constructed from the BINDING_ID and the UnitCodeTextIndex from the VSF\n+\n+    // List of all Thing Type\n+    public static final String THING_ID_DEVICE = \"device\";\n+    public static final String THING_ID_EMU_EM = \"emulatedEM\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_UID_BRIDGE = new ThingTypeUID(BINDING_ID, BRIDGE_VBUSLAN);\n+\n+    public static final ThingTypeUID THING_TYPE_UID_DEVICE = new ThingTypeUID(BINDING_ID, THING_ID_DEVICE);\n+\n+    public static final ThingTypeUID THING_TYPE_UID_EMU_EM = new ThingTypeUID(BINDING_ID, THING_ID_EMU_EM);\n+\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.unmodifiableSet(\n+            Stream.of(THING_TYPE_UID_BRIDGE, THING_TYPE_UID_DEVICE, THING_TYPE_UID_EMU_EM).collect(Collectors.toSet()));", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzQxMw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551023413", "bodyText": "You could inject it into the constructor of this class to get rid of the Nullable annotation.", "author": "fwolter", "createdAt": "2021-01-03T16:00:57Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/ResolHandlerFactory.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal;\n+\n+import static org.openhab.binding.resol.internal.ResolBindingConstants.SUPPORTED_THING_TYPES_UIDS;\n+\n+import java.util.Hashtable;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.handler.ResolBridgeHandler;\n+import org.openhab.binding.resol.handler.ResolEmuEMThingHandler;\n+import org.openhab.binding.resol.handler.ResolThingHandler;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ResolHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.resol\", service = ThingHandlerFactory.class)\n+public class ResolHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolHandlerFactory.class);\n+\n+    private @Nullable LocaleProvider localeProvider;\n+\n+    @Reference\n+    protected void setLocaleProvider(final LocaleProvider localeProvider) {", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzUzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551023535", "bodyText": "Can you add the representation property?", "author": "fwolter", "createdAt": "2021-01-03T16:02:17Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolDiscoveryService.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.resol.handler.ResolBridgeHandler;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ResolDiscoveryService} class handles the discovery of things.\n+ * with broadcasting and put it to inbox, if found.\n+ *\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolDiscoveryService.class);\n+\n+    private ResolBridgeHandler resolBridgeHandler;\n+\n+    public ResolDiscoveryService(ResolBridgeHandler resolBridgeHandler) throws IllegalArgumentException {\n+        super(ResolBindingConstants.SUPPORTED_THING_TYPES_UIDS, 10, false);\n+        this.resolBridgeHandler = resolBridgeHandler;\n+    }\n+\n+    private void addThing(ThingUID bridgeUID, String thingType, String type, String name) {\n+        logger.trace(\"Adding new Resol thing: {}\", type);\n+        ThingUID thingUID = null;\n+        switch (thingType) {\n+            case ResolBindingConstants.THING_ID_DEVICE:\n+                thingUID = new ThingUID(ResolBindingConstants.THING_TYPE_UID_DEVICE, bridgeUID, type);\n+                break;\n+        }\n+\n+        if (thingUID != null) {\n+            logger.trace(\"Adding new Discovery thingType: {} bridgeType: {}\", thingUID.getAsString(),\n+                    bridgeUID.getAsString());\n+\n+            Map<String, Object> properties = new HashMap<>(1);\n+            properties.put(\"type\", type);\n+\n+            DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID).withBridge(bridgeUID)\n+                    .withProperties(properties).withLabel(name).build();", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYxNzc4NA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r554617784", "bodyText": "For the thing \"device\" it there is only one of each type on each VBUS and therefore with the bridge unique. Can you please check whether I understood it right, now to do it then?", "author": "ramack", "createdAt": "2021-01-10T20:22:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzUzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc4MzExMg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r556783112", "bodyText": "You've done it right!", "author": "fwolter", "createdAt": "2021-01-13T19:42:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzUzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzYwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551023609", "bodyText": "See above. Method.", "author": "fwolter", "createdAt": "2021-01-03T16:03:13Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolVBusBridgeDiscovery.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolVBusBridgeDiscovery} class provides the DiscoverySerivce to\n+ * discover Resol VBus-LAN adapters\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class ResolVBusBridgeDiscovery extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(ResolVBusBridgeDiscovery.class);\n+\n+    public ResolVBusBridgeDiscovery() throws IllegalArgumentException {\n+        super(ResolBindingConstants.SUPPORTED_BRIDGE_THING_TYPES_UIDS, 35, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"Start discovery of Resol VBus-LAN Adapter\");\n+        scheduler.execute(searchRunnable);\n+    }\n+\n+    /*\n+     * The runnable for the search routine.\n+     */\n+    private Runnable searchRunnable = new Runnable() {\n+\n+        @Override\n+        public void run() {", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzczMA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551023730", "bodyText": "Can you add the representation property?", "author": "fwolter", "createdAt": "2021-01-03T16:04:09Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolVBusBridgeDiscovery.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolVBusBridgeDiscovery} class provides the DiscoverySerivce to\n+ * discover Resol VBus-LAN adapters\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class ResolVBusBridgeDiscovery extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(ResolVBusBridgeDiscovery.class);\n+\n+    public ResolVBusBridgeDiscovery() throws IllegalArgumentException {\n+        super(ResolBindingConstants.SUPPORTED_BRIDGE_THING_TYPES_UIDS, 35, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"Start discovery of Resol VBus-LAN Adapter\");\n+        scheduler.execute(searchRunnable);\n+    }\n+\n+    /*\n+     * The runnable for the search routine.\n+     */\n+    private Runnable searchRunnable = new Runnable() {\n+\n+        @Override\n+        public void run() {\n+            logger.trace(\"Start adapter discovery...\");\n+\n+            try {\n+                InetAddress broadcastAddress = InetAddress\n+                        .getByAddress(new byte[] { (byte) 255, (byte) 255, (byte) 255, (byte) 255 });\n+\n+                TcpDataSource[] dataSources = TcpDataSourceProvider.discoverDataSources(broadcastAddress, 3, 500,\n+                        false);\n+\n+                HashMap<String, TcpDataSource> currentDataSourceById = new HashMap<String, TcpDataSource>();\n+                for (TcpDataSource ds : dataSources) {\n+                    InetAddress address = ds.getAddress();\n+                    String addressId = address.getHostAddress();\n+                    TcpDataSource dsWithInfo;\n+                    try {\n+                        dsWithInfo = TcpDataSourceProvider.fetchInformation(address, 1500);\n+                        logger.trace(\"Discovered Resol VBus-LAN interface @{} {} ({})\", addressId,\n+                                dsWithInfo.getDeviceName(), dsWithInfo.getSerial());\n+\n+                        currentDataSourceById.put(addressId, dsWithInfo);\n+                        addAdapter(addressId, dsWithInfo);\n+                        // here we can add the detection of Multi-Channel interfaces like DL3\n+                    } catch (IOException ex) {\n+                        /* address is no valid adapter */\n+                    }\n+\n+                }\n+            } catch (UnknownHostException e) {\n+                logger.debug(\"Could not resolve IPv4 broadcast address\");\n+            }\n+        }\n+    };\n+\n+    private void addAdapter(String remoteIP, TcpDataSource dsWithInfo) {\n+        String adapterSerial = dsWithInfo.getSerial();\n+        Map<String, Object> properties = new HashMap<>(3);\n+        properties.put(\"ipAddress\", remoteIP);\n+        properties.put(\"port\", dsWithInfo.getLivePort());\n+        properties.put(\"adapterSerial\", adapterSerial);\n+\n+        ThingUID uid = new ThingUID(ResolBindingConstants.THING_TYPE_UID_BRIDGE, adapterSerial);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(uid).withProperties(properties).withLabel(dsWithInfo.getName()).build());", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYxNzgwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r554617801", "bodyText": "The bridge is uniquely identified by the adapterSerial, which is read on discovery, but not required in file based configuration.\nIf I add a bridge manually in the configuration files the very same one is still autodetected, as long as I don't give the optional parameter adapterSerial. - Wouldn't it be better in this case to use the IP address as representation property?", "author": "ramack", "createdAt": "2021-01-10T20:22:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzczMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc4NDQwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r556784405", "bodyText": "Not sure. I would go for the IP address.", "author": "fwolter", "createdAt": "2021-01-13T19:44:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzczMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTE5NjYwNA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r559196604", "bodyText": "I though I read that it should be a not-changing property and the IP would even not be recommended. But 1. I don't find that statement anymore, 2 the scenario that a bridge is using DHCP and getting a changed IP is quite unlikely.", "author": "ramack", "createdAt": "2021-01-17T15:25:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMzczMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU1MzY2NA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551553664", "bodyText": "You probably should not keep a map of things. The bridge already tracks this itself via children. So you're re-implementing part of what is already available, making this code more complex than needed. See if you can change the code to make use of this functionality.", "author": "Hilbrand", "createdAt": "2021-01-04T20:34:31Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runables\n+\n+    @Nullable\n+    private ScheduledFuture<?> pollingJob;\n+\n+    @Nullable\n+    private Connection tcpConnection;\n+    private Specification spec;\n+    private Set<String> availableDevices = new HashSet<String>();\n+\n+    private Map<String, ResolThingHandler> thingHandlerMap = new HashMap<String, ResolThingHandler>();", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYxODk3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r554618975", "bodyText": "I feel stupid or blind right now \ud83d\ude00, can you please point me to it?", "author": "ramack", "createdAt": "2021-01-10T20:33:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU1MzY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYyNjc4OA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r554626788", "bodyText": "You can get it via getThing().getThings() see for example \n  \n    \n      openhab-addons/bundles/org.openhab.binding.spotify/src/main/java/org/openhab/binding/spotify/internal/handler/SpotifyBridgeHandler.java\n    \n    \n         Line 427\n      in\n      b6eea71\n    \n    \n    \n    \n\n        \n          \n           getThing().getThings().stream() //", "author": "Hilbrand", "createdAt": "2021-01-10T21:41:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU1MzY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU1NjY4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551556682", "bodyText": "This is not allowed. This service should be in control of when scanning is done. What you can do is instead of in activate  register to the bridge here and in stopScan unregister. Or keep a list of unknown things in the bridge and let discovery get (and clear) the list when discovery is started here.", "author": "Hilbrand", "createdAt": "2021-01-04T20:40:46Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolDiscoveryService.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.resol.handler.ResolBridgeHandler;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ResolDiscoveryService} class handles the discovery of things.\n+ * with broadcasting and put it to inbox, if found.\n+ *\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolDiscoveryService.class);\n+\n+    private ResolBridgeHandler resolBridgeHandler;\n+\n+    public ResolDiscoveryService(ResolBridgeHandler resolBridgeHandler) throws IllegalArgumentException {\n+        super(ResolBindingConstants.SUPPORTED_THING_TYPES_UIDS, 10, false);\n+        this.resolBridgeHandler = resolBridgeHandler;\n+    }\n+\n+    private void addThing(ThingUID bridgeUID, String thingType, String type, String name) {\n+        logger.trace(\"Adding new Resol thing: {}\", type);\n+        ThingUID thingUID = null;\n+        switch (thingType) {\n+            case ResolBindingConstants.THING_ID_DEVICE:\n+                thingUID = new ThingUID(ResolBindingConstants.THING_TYPE_UID_DEVICE, bridgeUID, type);\n+                break;\n+        }\n+\n+        if (thingUID != null) {\n+            logger.trace(\"Adding new Discovery thingType: {} bridgeType: {}\", thingUID.getAsString(),\n+                    bridgeUID.getAsString());\n+\n+            Map<String, Object> properties = new HashMap<>(1);\n+            properties.put(\"type\", type);\n+\n+            DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID).withBridge(bridgeUID)\n+                    .withProperties(properties).withLabel(name).build();\n+            logger.trace(\"call register: {} label: {}\", discoveryResult.getBindingId(), discoveryResult.getLabel());\n+            thingDiscovered(discoveryResult);\n+        } else {\n+            logger.debug(\"Discovered Thing is unsupported: type '{}'\", type);\n+        }\n+    }\n+\n+    public void addResolThing(String thingType, String thingID, String name) {\n+\n+        addThing(resolBridgeHandler.getThing().getUID(), thingType, thingID, name);\n+    }\n+\n+    public void activate() {\n+        resolBridgeHandler.registerDiscoveryService(this);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        resolBridgeHandler.unregisterDiscoveryService();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        // Scan will be done by bridge", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU1Nzc3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r551557777", "bodyText": "Can you implement registering the discovery bound to a bridge as a ThingHandlerService. See this preliminary documentation on how to do that: https://deploy-preview-1262--openhab-docs-preview.netlify.app/docs/developer/bindings/#discovery-that-is-bound-to-a-thing", "author": "Hilbrand", "createdAt": "2021-01-04T20:43:18Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/ResolHandlerFactory.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal;\n+\n+import static org.openhab.binding.resol.internal.ResolBindingConstants.SUPPORTED_THING_TYPES_UIDS;\n+\n+import java.util.Hashtable;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.handler.ResolBridgeHandler;\n+import org.openhab.binding.resol.handler.ResolEmuEMThingHandler;\n+import org.openhab.binding.resol.handler.ResolThingHandler;\n+import org.openhab.binding.resol.internal.discovery.ResolDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ResolHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.resol\", service = ThingHandlerFactory.class)\n+public class ResolHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolHandlerFactory.class);\n+\n+    private @Nullable LocaleProvider localeProvider;\n+\n+    @Reference\n+    protected void setLocaleProvider(final LocaleProvider localeProvider) {\n+        this.localeProvider = localeProvider;\n+    }\n+\n+    protected void unsetLocaleProvider(final LocaleProvider localeProvider) {\n+        this.localeProvider = null;\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (thingTypeUID.equals(ResolBindingConstants.THING_TYPE_UID_DEVICE)) {\n+            return new ResolThingHandler(thing);\n+        }\n+\n+        if (thingTypeUID.equals(ResolBindingConstants.THING_TYPE_UID_EMU_EM)) {\n+            return new ResolEmuEMThingHandler(thing);\n+        }\n+\n+        if (thingTypeUID.equals(ResolBindingConstants.THING_TYPE_UID_BRIDGE)) {\n+            ResolBridgeHandler handler = new ResolBridgeHandler((Bridge) thing, localeProvider);\n+            registerThingDiscovery(handler);\n+            return handler;\n+        }\n+\n+        return null;\n+    }\n+\n+    private synchronized void registerThingDiscovery(ResolBridgeHandler bridgeHandler) {\n+        ResolDiscoveryService discoveryService = new ResolDiscoveryService(bridgeHandler);\n+        logger.trace(\"Try to register VBUS Discovery service on BundleID: {} Service: {}\",\n+                bundleContext.getBundle().getBundleId(), DiscoveryService.class.getName());\n+\n+        Hashtable<@Nullable String, String> prop = new Hashtable<@Nullable String, String>();\n+\n+        bundleContext.registerService(DiscoveryService.class.getName(), discoveryService, prop);\n+        discoveryService.activate();\n+    }", "originalCommit": "4663c5b90ee9191b4aab75ea4035d62b5d6da317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDUwMDkyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r560500921", "bodyText": "ok, I tried that, can you please check it? What I recognized, was that bridge defined in a thing file was still detected (even though I changed the representationproperty to the ipAddress) but when I added the discovered one it magically disappeared... So maybe I didn't do it right fully.", "author": "ramack", "createdAt": "2021-01-19T21:16:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU1Nzc3Nw=="}], "type": "inlineReview"}, {"oid": "9cdc0854dfcca08120b7529c147190822d8dffe2", "url": "https://github.com/openhab/openhab-addons/commit/9cdc0854dfcca08120b7529c147190822d8dffe2", "message": "add representation-property\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-01-10T20:40:19Z", "type": "forcePushed"}, {"oid": "e6d17062d2261669c552226c5ec427956764f8c6", "url": "https://github.com/openhab/openhab-addons/commit/e6d17062d2261669c552226c5ec427956764f8c6", "message": "remove warnings\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-01-30T22:30:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1NDA5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570554092", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.", "author": "fwolter", "createdAt": "2021-02-04T21:26:13Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDeviceDiscoveryService;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runnable\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable Connection tcpConnection;\n+    private Specification spec;\n+\n+    // Managing Thing Discovery Service\n+    private @Nullable ResolDeviceDiscoveryService discoveryService = null;\n+\n+    private boolean scanning;\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(getLocale());\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    public void registerDiscoveryService(ResolDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(ResolDeviceDiscoveryService.class);\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+            }\n+        }\n+    }\n+\n+    private void pollingRunnable() {\n+        if (!isConnected) {\n+            synchronized (ResolBridgeHandler.this) {\n+                Connection connection = tcpConnection;\n+                /* first cleanup in case there is an old but failed TCP connection around */\n+                try {\n+                    if (connection != null) {\n+                        connection.disconnect();\n+\n+                        getThing().getThings().stream().forEach(thing -> {\n+                            ThingHandler th = thing.getHandler();\n+                            if (th instanceof ResolEmuEMThingHandler) {\n+                                ((ResolEmuEMThingHandler) th).stop();\n+                            }\n+                        });\n+\n+                        connection = null;\n+                        tcpConnection = null;\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"TCP disconnect failed: {}\", e.getMessage());\n+                }\n+                TcpDataSource source = null;\n+                /* now try to establish a new TCP connection */\n+                try {\n+                    source = TcpDataSourceProvider.fetchInformation(InetAddress.getByName(ipAddress), 500);\n+                    if (source != null) {\n+                        source.setLivePassword(password);\n+                    }\n+                } catch (IOException e) {\n+                    isConnected = false;\n+                    unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                }\n+                if (source != null) {\n+                    try {\n+                        logger.debug(\"Opening a new connection to {} {} @{}\", source.getProduct(),\n+                                source.getDeviceName(), source.getAddress());\n+                        connection = source.connectLive(0, 0x0020);\n+                        tcpConnection = connection;\n+                    } catch (Exception e) {\n+                        // this generic Exception catch is required, as TcpDataSource.connectLive throws this\n+                        // generic type\n+                        isConnected = false;\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                    }\n+\n+                    if (connection != null) {\n+                        // Add a listener to the Connection to monitor state changes and\n+                        // read incoming frames\n+                        connection.addListener(new ResolConnectorAdapter());\n+                    }\n+                }\n+                // Establish the connection\n+                if (connection != null) {\n+                    try {\n+                        connection.connect();\n+                        final Connection c = connection;\n+                        // now set the connection the thing handlers for the emulated EMs\n+\n+                        getThing().getThings().stream().forEach(thing -> {\n+                            ThingHandler th = thing.getHandler();\n+                            if (th instanceof ResolEmuEMThingHandler) {\n+                                ((ResolEmuEMThingHandler) th).useConnection(c);\n+                            }\n+                        });\n+                    } catch (IOException e) {\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                        isConnected = false;\n+                    }\n+                } else {\n+                    isConnected = false;\n+                }\n+                if (!isConnected) {\n+                    logger.debug(\"Cannot establish connection to {} ({})\", ipAddress, unconnectedReason);\n+                } else {\n+                    unconnectedReason = \"\";\n+                }\n+                updateStatus();\n+            }\n+        }\n+    }\n+\n+    private synchronized void startAutomaticRefresh() {\n+        ScheduledFuture<?> job = pollingJob;\n+        if (job == null || job.isCancelled()) {\n+            pollingJob = scheduler.scheduleWithFixedDelay(this::pollingRunnable, 0, refreshInterval, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    public ThingStatus getStatus() {\n+        return getThing().getStatus();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // No commands supported - nothing to do\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus();\n+        ResolBridgeConfiguration configuration = getConfigAs(ResolBridgeConfiguration.class);\n+        ipAddress = configuration.ipAddress;\n+        refreshInterval = configuration.refreshInterval;\n+        password = configuration.password;\n+        startAutomaticRefresh();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> job = pollingJob;\n+        if (job != null) {\n+            job.cancel(true);\n+            pollingJob = null;\n+        }\n+        try {\n+            Connection connection = tcpConnection;\n+            if (connection != null) {\n+                connection.disconnect();\n+                getThing().getThings().stream().forEach(thing -> {\n+                    ThingHandler th = thing.getHandler();\n+                    if (th instanceof ResolEmuEMThingHandler) {\n+                        ((ResolEmuEMThingHandler) th).stop();\n+                    }\n+                });\n+\n+            }\n+        } catch (IOException ioe) {\n+            // we don't care about exceptions on disconnect in dispose\n+        }\n+    }\n+\n+    Locale getLocale() {\n+        return locale;\n+    }\n+\n+    /* adapter to react on connection state changes and handle received packets */\n+    private class ResolConnectorAdapter extends ConnectionAdapter {\n+        @Override\n+        public void connectionStateChanged(@Nullable Connection connection) {\n+            synchronized (ResolBridgeHandler.this) {\n+                if (connection == null) {\n+                    isConnected = false;\n+                } else {\n+                    ConnectionState connState = connection.getConnectionState();\n+                    if (ConnectionState.CONNECTED.equals(connState)) {\n+                        isConnected = true;\n+                    } else if (ConnectionState.DISCONNECTED.equals(connState)\n+                            || ConnectionState.INTERRUPTED.equals(connState)) {\n+                        isConnected = false;\n+                    }\n+                    logger.info(\"Connection state changed to: {}\", connState.toString());", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1Njc5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570556796", "bodyText": "You could enclose this with an if, that the data is not calculated when running in normal logging mode.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.trace(\"Received Data from {} (0x{}/0x{}) naming it {}\",\n          \n          \n            \n                        if (logger.isTraceEnabled()) {\n          \n          \n            \n                            logger.trace(\"Received Data from {} (0x{}/0x{}) naming it {}\",", "author": "fwolter", "createdAt": "2021-02-04T21:30:51Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDeviceDiscoveryService;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runnable\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable Connection tcpConnection;\n+    private Specification spec;\n+\n+    // Managing Thing Discovery Service\n+    private @Nullable ResolDeviceDiscoveryService discoveryService = null;\n+\n+    private boolean scanning;\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(getLocale());\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }\n+    }\n+\n+    public void updateStatus() {\n+        if (isConnected) {\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, unconnectedReason);\n+        }\n+    }\n+\n+    public void registerDiscoveryService(ResolDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public void unregisterDiscoveryService() {\n+        discoveryService = null;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(ResolDeviceDiscoveryService.class);\n+    }\n+\n+    public void registerResolThingListener(ResolEmuEMThingHandler resolEmuEMThingHandler) {\n+        synchronized (this) {\n+            Connection con = tcpConnection;\n+            if (con != null) {\n+                resolEmuEMThingHandler.useConnection(con);\n+            }\n+        }\n+    }\n+\n+    private void pollingRunnable() {\n+        if (!isConnected) {\n+            synchronized (ResolBridgeHandler.this) {\n+                Connection connection = tcpConnection;\n+                /* first cleanup in case there is an old but failed TCP connection around */\n+                try {\n+                    if (connection != null) {\n+                        connection.disconnect();\n+\n+                        getThing().getThings().stream().forEach(thing -> {\n+                            ThingHandler th = thing.getHandler();\n+                            if (th instanceof ResolEmuEMThingHandler) {\n+                                ((ResolEmuEMThingHandler) th).stop();\n+                            }\n+                        });\n+\n+                        connection = null;\n+                        tcpConnection = null;\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"TCP disconnect failed: {}\", e.getMessage());\n+                }\n+                TcpDataSource source = null;\n+                /* now try to establish a new TCP connection */\n+                try {\n+                    source = TcpDataSourceProvider.fetchInformation(InetAddress.getByName(ipAddress), 500);\n+                    if (source != null) {\n+                        source.setLivePassword(password);\n+                    }\n+                } catch (IOException e) {\n+                    isConnected = false;\n+                    unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                }\n+                if (source != null) {\n+                    try {\n+                        logger.debug(\"Opening a new connection to {} {} @{}\", source.getProduct(),\n+                                source.getDeviceName(), source.getAddress());\n+                        connection = source.connectLive(0, 0x0020);\n+                        tcpConnection = connection;\n+                    } catch (Exception e) {\n+                        // this generic Exception catch is required, as TcpDataSource.connectLive throws this\n+                        // generic type\n+                        isConnected = false;\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                    }\n+\n+                    if (connection != null) {\n+                        // Add a listener to the Connection to monitor state changes and\n+                        // read incoming frames\n+                        connection.addListener(new ResolConnectorAdapter());\n+                    }\n+                }\n+                // Establish the connection\n+                if (connection != null) {\n+                    try {\n+                        connection.connect();\n+                        final Connection c = connection;\n+                        // now set the connection the thing handlers for the emulated EMs\n+\n+                        getThing().getThings().stream().forEach(thing -> {\n+                            ThingHandler th = thing.getHandler();\n+                            if (th instanceof ResolEmuEMThingHandler) {\n+                                ((ResolEmuEMThingHandler) th).useConnection(c);\n+                            }\n+                        });\n+                    } catch (IOException e) {\n+                        unconnectedReason = Objects.requireNonNullElse(e.getMessage(), \"\");\n+                        isConnected = false;\n+                    }\n+                } else {\n+                    isConnected = false;\n+                }\n+                if (!isConnected) {\n+                    logger.debug(\"Cannot establish connection to {} ({})\", ipAddress, unconnectedReason);\n+                } else {\n+                    unconnectedReason = \"\";\n+                }\n+                updateStatus();\n+            }\n+        }\n+    }\n+\n+    private synchronized void startAutomaticRefresh() {\n+        ScheduledFuture<?> job = pollingJob;\n+        if (job == null || job.isCancelled()) {\n+            pollingJob = scheduler.scheduleWithFixedDelay(this::pollingRunnable, 0, refreshInterval, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    public ThingStatus getStatus() {\n+        return getThing().getStatus();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // No commands supported - nothing to do\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus();\n+        ResolBridgeConfiguration configuration = getConfigAs(ResolBridgeConfiguration.class);\n+        ipAddress = configuration.ipAddress;\n+        refreshInterval = configuration.refreshInterval;\n+        password = configuration.password;\n+        startAutomaticRefresh();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> job = pollingJob;\n+        if (job != null) {\n+            job.cancel(true);\n+            pollingJob = null;\n+        }\n+        try {\n+            Connection connection = tcpConnection;\n+            if (connection != null) {\n+                connection.disconnect();\n+                getThing().getThings().stream().forEach(thing -> {\n+                    ThingHandler th = thing.getHandler();\n+                    if (th instanceof ResolEmuEMThingHandler) {\n+                        ((ResolEmuEMThingHandler) th).stop();\n+                    }\n+                });\n+\n+            }\n+        } catch (IOException ioe) {\n+            // we don't care about exceptions on disconnect in dispose\n+        }\n+    }\n+\n+    Locale getLocale() {\n+        return locale;\n+    }\n+\n+    /* adapter to react on connection state changes and handle received packets */\n+    private class ResolConnectorAdapter extends ConnectionAdapter {\n+        @Override\n+        public void connectionStateChanged(@Nullable Connection connection) {\n+            synchronized (ResolBridgeHandler.this) {\n+                if (connection == null) {\n+                    isConnected = false;\n+                } else {\n+                    ConnectionState connState = connection.getConnectionState();\n+                    if (ConnectionState.CONNECTED.equals(connState)) {\n+                        isConnected = true;\n+                    } else if (ConnectionState.DISCONNECTED.equals(connState)\n+                            || ConnectionState.INTERRUPTED.equals(connState)) {\n+                        isConnected = false;\n+                    }\n+                    logger.info(\"Connection state changed to: {}\", connState.toString());\n+\n+                    if (isConnected) {\n+                        unconnectedReason = \"\";\n+                    } else {\n+                        unconnectedReason = \"TCP connection failed: \" + connState.toString();\n+                    }\n+                }\n+                updateStatus();\n+            }\n+        }\n+\n+        @Override\n+        public void packetReceived(@Nullable Connection connection, @Nullable Packet packet) {\n+            if (connection == null || packet == null) {\n+                return;\n+            }\n+            boolean packetHandled = false;\n+            String thingType = spec.getSourceDeviceSpec(packet).getName(); // use En here\n+\n+            thingType = thingType.replace(\" [\", \"-\");\n+            thingType = thingType.replace(\"]\", \"\");\n+            thingType = thingType.replace(\" #\", \"-\");\n+            thingType = thingType.replace(\" \", \"_\");\n+            thingType = thingType.replace(\"/\", \"_\");\n+            thingType = thingType.replaceAll(\"[^A-Za-z0-9_-]+\", \"_\");\n+\n+            /*\n+             * It would be nice for the combination of MX and EM devices to filter only those with a peerAddress of\n+             * 0x10, because the MX redelivers the data from the EM to the DFA.\n+             * But the MX is the exception in this case and many other controllers do not redeliver data, so we keep it.\n+             */\n+            logger.trace(\"Received Data from {} (0x{}/0x{}) naming it {}\",", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1NzU4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570557587", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private ScheduledFuture<?> updateJob;\n          \n          \n            \n                private @Nullable ScheduledFuture<?> updateJob;", "author": "fwolter", "createdAt": "2021-02-04T21:32:19Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends ResolBaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay_\";\n+    public static final String CHANNEL_TEMP = \"temperature_\";\n+    public static final String CHANNEL_RESIST = \"resistor_\";\n+    public static final String CHANNEL_SWITCH = \"switch_\";\n+    public static final String CHANNEL_TEMP_ADJUST = \"bas_temp_adjust_\";\n+    public static final String CHANNEL_MODE = \"bas_mode_\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+    private int deviceId = 1;\n+    private @Nullable EmDeviceEmulator device;\n+\n+    private @Nullable ResolBridgeHandler bridgeHandler;\n+\n+    private class BasSetting {\n+        float temperatureOffset = 0.0f;\n+        int mode = 4;\n+    }\n+\n+    private BasSetting[] basValues = { new BasSetting(), new BasSetting(), new BasSetting(), new BasSetting(),\n+            new BasSetting(), new BasSetting() };\n+    private long lastTime = System.currentTimeMillis();\n+\n+    // Background Runnable\n+    @Nullable\n+    private ScheduledFuture<?> updateJob;", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1OTU3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570559573", "bodyText": "This will convert to the current quantity's unit. E.g. if the user uses Fahrenheit, it will convert to the Fahrenheit value. You can use command.toUnit() to convert it to the expected value.", "author": "fwolter", "createdAt": "2021-02-04T21:35:59Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends ResolBaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay_\";\n+    public static final String CHANNEL_TEMP = \"temperature_\";\n+    public static final String CHANNEL_RESIST = \"resistor_\";\n+    public static final String CHANNEL_SWITCH = \"switch_\";\n+    public static final String CHANNEL_TEMP_ADJUST = \"bas_temp_adjust_\";\n+    public static final String CHANNEL_MODE = \"bas_mode_\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+    private int deviceId = 1;\n+    private @Nullable EmDeviceEmulator device;\n+\n+    private @Nullable ResolBridgeHandler bridgeHandler;\n+\n+    private class BasSetting {\n+        float temperatureOffset = 0.0f;\n+        int mode = 4;\n+    }\n+\n+    private BasSetting[] basValues = { new BasSetting(), new BasSetting(), new BasSetting(), new BasSetting(),\n+            new BasSetting(), new BasSetting() };\n+    private long lastTime = System.currentTimeMillis();\n+\n+    // Background Runnable\n+    @Nullable\n+    private ScheduledFuture<?> updateJob;\n+\n+    public ResolEmuEMThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolEmuEMConfiguration configuration = getConfigAs(ResolEmuEMConfiguration.class);\n+        deviceId = configuration.deviceId;\n+        vbusAddress = 0x6650 + deviceId;\n+\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        EmDeviceEmulator dev = device;\n+        if (dev != null) {\n+            dev.stop();\n+            dev.removePropertyChangeListener(this);\n+        }\n+    }\n+\n+    private void updateRunnable() {\n+        EmDeviceEmulator d = device;\n+        if (d != null) {\n+            long now = System.currentTimeMillis();\n+            int diff = (int) (now - lastTime);\n+            lastTime = now;\n+\n+            d.update(diff);\n+        }\n+    }\n+\n+    private void startAutomaticUpdate() {\n+        ScheduledFuture<?> job = updateJob;\n+        if (job == null || job.isCancelled()) {\n+            updateJob = scheduler.scheduleWithFixedDelay(this::updateRunnable, 0, 1, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for thing {}.\", thing.getThingTypeUID());\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    private void registerResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.registerResolThingListener(this);\n+        } else {\n+            logger.debug(\"Can't register {} at bridge as bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    public int getVbusAddress() {\n+        return vbusAddress;\n+    }\n+\n+    public void useConnection(Connection connection) {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+            device.removePropertyChangeListener(this);\n+        }\n+        device = new EmDeviceEmulator(connection, deviceId);\n+        this.device = device;\n+        device.addPropertyChangeListener(this);\n+        device.start();\n+        for (int i = 1; i <= 5; i++) {\n+            setRelayChannelValue(i, device.getRelayValueByNr(i));\n+        }\n+        startAutomaticUpdate();\n+    }\n+\n+    public void stop() {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+        }\n+        ScheduledFuture<?> updateJob = this.updateJob;\n+        if (updateJob != null) {\n+            updateJob.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String chID = channelUID.getId();\n+        boolean update = false;\n+        int channel = chID.charAt(chID.length() - 1) - '0';\n+        float value = 0;\n+        int intValue = 0;\n+\n+        if (command instanceof QuantityType<?>) {\n+            value = ((QuantityType<?>) command).floatValue();", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2MTMxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570561314", "bodyText": "Can you set the status detail message, that the user gets a clue what is wrong?", "author": "fwolter", "createdAt": "2021-02-04T21:39:05Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends ResolBaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay_\";\n+    public static final String CHANNEL_TEMP = \"temperature_\";\n+    public static final String CHANNEL_RESIST = \"resistor_\";\n+    public static final String CHANNEL_SWITCH = \"switch_\";\n+    public static final String CHANNEL_TEMP_ADJUST = \"bas_temp_adjust_\";\n+    public static final String CHANNEL_MODE = \"bas_mode_\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+    private int deviceId = 1;\n+    private @Nullable EmDeviceEmulator device;\n+\n+    private @Nullable ResolBridgeHandler bridgeHandler;\n+\n+    private class BasSetting {\n+        float temperatureOffset = 0.0f;\n+        int mode = 4;\n+    }\n+\n+    private BasSetting[] basValues = { new BasSetting(), new BasSetting(), new BasSetting(), new BasSetting(),\n+            new BasSetting(), new BasSetting() };\n+    private long lastTime = System.currentTimeMillis();\n+\n+    // Background Runnable\n+    @Nullable\n+    private ScheduledFuture<?> updateJob;\n+\n+    public ResolEmuEMThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolEmuEMConfiguration configuration = getConfigAs(ResolEmuEMConfiguration.class);\n+        deviceId = configuration.deviceId;\n+        vbusAddress = 0x6650 + deviceId;\n+\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        EmDeviceEmulator dev = device;\n+        if (dev != null) {\n+            dev.stop();\n+            dev.removePropertyChangeListener(this);\n+        }\n+    }\n+\n+    private void updateRunnable() {\n+        EmDeviceEmulator d = device;\n+        if (d != null) {\n+            long now = System.currentTimeMillis();\n+            int diff = (int) (now - lastTime);\n+            lastTime = now;\n+\n+            d.update(diff);\n+        }\n+    }\n+\n+    private void startAutomaticUpdate() {\n+        ScheduledFuture<?> job = updateJob;\n+        if (job == null || job.isCancelled()) {\n+            updateJob = scheduler.scheduleWithFixedDelay(this::updateRunnable, 0, 1, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for thing {}.\", thing.getThingTypeUID());\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    private void registerResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.registerResolThingListener(this);\n+        } else {\n+            logger.debug(\"Can't register {} at bridge as bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    public int getVbusAddress() {\n+        return vbusAddress;\n+    }\n+\n+    public void useConnection(Connection connection) {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+            device.removePropertyChangeListener(this);\n+        }\n+        device = new EmDeviceEmulator(connection, deviceId);\n+        this.device = device;\n+        device.addPropertyChangeListener(this);\n+        device.start();\n+        for (int i = 1; i <= 5; i++) {\n+            setRelayChannelValue(i, device.getRelayValueByNr(i));\n+        }\n+        startAutomaticUpdate();\n+    }\n+\n+    public void stop() {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+        }\n+        ScheduledFuture<?> updateJob = this.updateJob;\n+        if (updateJob != null) {\n+            updateJob.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String chID = channelUID.getId();\n+        boolean update = false;\n+        int channel = chID.charAt(chID.length() - 1) - '0';\n+        float value = 0;\n+        int intValue = 0;\n+\n+        if (command instanceof QuantityType<?>) {\n+            value = ((QuantityType<?>) command).floatValue();\n+            update = true;\n+        } else if (command instanceof OnOffType) {\n+            intValue = ((OnOffType) command).equals(OnOffType.ON) ? 1 : 0;\n+            update = true;\n+        } else if (command instanceof DecimalType) {\n+            intValue = ((DecimalType) command).intValue();\n+            value = intValue;\n+            update = true;\n+        } else {\n+            update = false;\n+        }\n+\n+        if (update) {\n+            EmDeviceEmulator dev = device;\n+            if (dev != null) {\n+                if (chID.startsWith(CHANNEL_TEMP)) {\n+                    dev.setResistorValueByNrAndPt1000Temperatur(channel, value);\n+                    updateState(channelUID, new DecimalType(value));\n+                } else if (chID.startsWith(CHANNEL_SWITCH)) {\n+                    if (intValue == 0) {\n+                        /* switch is open => 1 megaohm */\n+                        dev.setResistorValueByNr(channel, 1000000000);\n+                        updateState(channelUID, OnOffType.OFF);\n+                    } else {\n+                        /* switch is closed */\n+                        dev.setResistorValueByNr(channel, 0);\n+                        updateState(channelUID, OnOffType.ON);\n+                    }\n+                } else if (chID.startsWith(CHANNEL_RESIST)) {\n+                    dev.setResistorValueByNr(channel, (int) (value * 1000.0));\n+                    updateState(channelUID, new QuantityType<>(intValue, Units.OHM));\n+                } else if (chID.startsWith(CHANNEL_TEMP_ADJUST)) {\n+                    basValues[channel - 1].temperatureOffset = value;\n+                    updateBas(channel);\n+                    updateState(channelUID, new DecimalType(value));\n+                } else if (chID.startsWith(CHANNEL_MODE)) {\n+                    basValues[channel - 1].mode = intValue;\n+                    updateBas(channel);\n+                    updateState(channelUID, new DecimalType(intValue));\n+                } else {\n+                    /* set resistor value for Open Connection, 1 megaohm */\n+                    dev.setResistorValueByNr(channel, 1000000000);\n+                    updateState(channelUID, new QuantityType<>(1000000, Units.OHM));\n+                }\n+            }\n+        }\n+    }\n+\n+    private void updateBas(int channel) {\n+        int resistor = 0; /* in milliohm */\n+        int delta = (int) ((basValues[channel - 1].temperatureOffset * 210.0f / 15.0f) * 1000.0f);\n+        switch (basValues[channel - 1].mode) {\n+            case 4: /* Automatic range 76 - 496 ohm */\n+                resistor = 286 * 1000 + delta;\n+                break;\n+            case 0: /* OFF range 1840 - 2260 ohm */\n+                resistor = 2050 * 1000 + delta;\n+                break;\n+            case 2: /* Night range 660 - 1080 ohm */\n+                resistor = 870 * 1000 + delta;\n+                break;\n+            case 3: /* Party is automatic mode with +15K */\n+                resistor = 286 * 1000 + 210 * 1000;\n+                break;\n+            case 1: /* Summer range 1240 - 1660 ohm */\n+                resistor = 1450 * 1000 + delta;\n+                break;\n+            default:\n+                /* signal a shortcut as error */\n+                resistor = 0;\n+                break;\n+        }\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.setResistorValueByNr(channel, resistor);\n+        }\n+    }\n+\n+    @Override\n+    public void propertyChange(@Nullable PropertyChangeEvent evt) {\n+        if (evt != null) {\n+            String s = evt.getPropertyName();\n+            if (s.startsWith(\"relay\") && s.endsWith(\"Value\")) {\n+                int v = (Integer) evt.getNewValue();\n+                int i = Integer.parseInt(s.substring(5, 6));\n+                setRelayChannelValue(i, v);\n+            } else if (s.contentEquals(\"connectionState\")) {\n+                ConnectionState ste = (ConnectionState) evt.getNewValue();\n+                if (ste.equals(ConnectionState.CONNECTED)) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2MTcwNg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570561706", "bodyText": "Can this be a constant?", "author": "fwolter", "createdAt": "2021-02-04T21:39:48Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolThingHandler.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.TimeZone;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolStateDescriptionOptionProvider;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldSpec;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Enum;\n+import de.resol.vbus.SpecificationFile.EnumVariant;\n+import de.resol.vbus.SpecificationFile.Language;\n+\n+/**\n+ * The {@link ResolThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolThingHandler extends ResolBaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolThingHandler.class);\n+\n+    @Nullable\n+    ResolBridgeHandler bridgeHandler;\n+    private ResolStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private SimpleDateFormat dateFormat = new SimpleDateFormat(DateTimeType.DATE_PATTERN_WITH_TZ_AND_MS_GENERAL);", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTI0NjU5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r571246599", "bodyText": "Do you mean to make it final?", "author": "ramack", "createdAt": "2021-02-05T20:58:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2MTcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTQwMjQ1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r571402451", "bodyText": "Yes, and make it static. SimpleDateFormat is also not thread-safe. You need to synchronize access if it can be accessed by multiple threads concurrently.", "author": "fwolter", "createdAt": "2021-02-06T10:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2MTcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTU4NzU0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r571587546", "bodyText": "ok. I don't see any reason here to have multithreaded calls here, so I'd not add synchronized.", "author": "ramack", "createdAt": "2021-02-07T09:37:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2MTcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2MzA3MA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570563070", "bodyText": "Can the comment be removed?", "author": "fwolter", "createdAt": "2021-02-04T21:42:23Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolThingHandler.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.TimeZone;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolStateDescriptionOptionProvider;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldSpec;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Enum;\n+import de.resol.vbus.SpecificationFile.EnumVariant;\n+import de.resol.vbus.SpecificationFile.Language;\n+\n+/**\n+ * The {@link ResolThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolThingHandler extends ResolBaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolThingHandler.class);\n+\n+    @Nullable\n+    ResolBridgeHandler bridgeHandler;\n+    private ResolStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private SimpleDateFormat dateFormat = new SimpleDateFormat(DateTimeType.DATE_PATTERN_WITH_TZ_AND_MS_GENERAL);\n+\n+    public ResolThingHandler(Thing thing, ResolStateDescriptionOptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        dateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        /* we ignore the commands for now on purpose */\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolBridgeHandler bridgeHandler = getBridgeHandler();\n+        this.bridgeHandler = bridgeHandler;\n+        if (bridgeHandler != null) {\n+            updateStatus(bridgeHandler.getStatus());\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for device.\");\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    public void setChannelValue(String channelId, String value) {\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            logger.warn(\"Channel '{}:{}' not implemented\", getThing().getUID().getId(), channelId);\n+        } else if (!\"String\".contentEquals(Objects.requireNonNullElse(channel.getAcceptedItemType(), \"\"))) {\n+            logger.trace(\"Channel '{}:{}' expected to have a String type for parameters '{}'\",\n+                    getThing().getUID().getId(), channelId, value.toString());\n+        } else {\n+            this.updateState(channelId, new StringType(value));\n+        }\n+    }\n+\n+    public void setChannelValue(String channelId, long value) {\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            logger.warn(\"Channel '{}:{}' not implemented\", getThing().getUID().getId(), channelId);\n+        } else if (!\"Number\".contentEquals(Objects.requireNonNullElse(channel.getAcceptedItemType(), \"\"))) {\n+            logger.trace(\"Channel '{}:{}' expected to have a String type for parameters '{}'\",\n+                    getThing().getUID().getId(), channelId, value);\n+        } else {\n+            this.updateState(channelId, new StringType(Long.toString(value)));\n+        }\n+    }\n+\n+    public void setChannelValue(String channelId, Date value) {\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            logger.warn(\"Channel '{}:{}' not implemented\", getThing().getUID().getId(), channelId);\n+        } else if (!\"DateTime\".equals(channel.getAcceptedItemType())) {\n+            logger.trace(\"Channel '{}:{}' expected to have a DateTime type for parameters '{}'\",\n+                    getThing().getUID().getId(), channelId, value.toString());\n+        } else {\n+            this.updateState(channelId, new DateTimeType(dateFormat.format(value)));\n+        }\n+    }\n+\n+    public void setChannelValue(String channelId, double value) {\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            logger.warn(\"Channel '{}:{}' not implemented\", getThing().getUID().getId(), channelId);\n+            return;\n+        }\n+\n+        String itmType = channel.getAcceptedItemType();\n+        if (itmType != null && itmType.startsWith(\"Number\")) {\n+            this.updateState(channelId, new DecimalType(value));\n+        } else {\n+            logger.warn(\"ItemType '{}' for channel '{}' not matching parameter type double\",\n+                    channel.getAcceptedItemType(), channelId);\n+        }\n+    }\n+\n+    @Override\n+    public void packetReceived(Specification spec, Language lang, Packet packet) {\n+        PacketFieldValue[] pfvs = spec.getPacketFieldValuesForHeaders(new Packet[] { packet });\n+        for (PacketFieldValue pfv : pfvs) {\n+            logger.trace(\"Id: {}, Name: {}, Raw: {}, Text: {}\", pfv.getPacketFieldId(), pfv.getName(lang),\n+                    pfv.getRawValueDouble(), pfv.formatTextValue(null, Locale.getDefault()));\n+\n+            String channelId = pfv.getName(); // use English name as channel\n+            channelId = channelId.replace(\" [\", \"-\");\n+            channelId = channelId.replace(\"]\", \"\");\n+            channelId = channelId.replace(\"(\", \"-\");\n+            channelId = channelId.replace(\")\", \"\");\n+            channelId = channelId.replace(\" #\", \"-\");\n+            channelId = channelId.replaceAll(\"[^A-Za-z0-9_-]+\", \"_\");\n+\n+            channelId = channelId.toLowerCase(Locale.ENGLISH);\n+\n+            ChannelTypeUID channelTypeUID;\n+\n+            if (pfv.getPacketFieldSpec().getUnit().getUnitId() >= 0) {\n+                channelTypeUID = new ChannelTypeUID(ResolBindingConstants.BINDING_ID,\n+                        pfv.getPacketFieldSpec().getUnit().getUnitCodeText());\n+            } else if (pfv.getPacketFieldSpec().getType() == SpecificationFile.Type.DateTime) {\n+                channelTypeUID = new ChannelTypeUID(ResolBindingConstants.BINDING_ID, \"DateTime\");\n+            } else {\n+                /* used for enums and the numeric types without unit */\n+                channelTypeUID = new ChannelTypeUID(ResolBindingConstants.BINDING_ID, \"None\");\n+            }\n+\n+            String acceptedItemType;\n+\n+            Thing thing = getThing();\n+            switch (pfv.getPacketFieldSpec().getType()) {\n+                case DateTime:\n+                    acceptedItemType = \"DateTime\";\n+                    break;\n+                case WeekTime:\n+                case Number:\n+                    acceptedItemType = ResolChannelTypeProvider.itemTypeForUnit(pfv.getPacketFieldSpec().getUnit());\n+                    break;\n+                case Time:\n+                default:\n+                    acceptedItemType = \"String\";\n+                    break;\n+            }\n+            Channel a = thing.getChannel(channelId);\n+\n+            if (a == null) {\n+                /* channel doesn't exit, let's create it */\n+                ThingBuilder thingBuilder = editThing();\n+                ChannelUID channelUID = new ChannelUID(thing.getUID(), channelId);\n+\n+                if (pfv.getEnumVariant() != null) {\n+                    /* create a state option channel */\n+                    List<StateOption> options = new ArrayList<>();\n+                    PacketFieldSpec ff = pfv.getPacketFieldSpec();\n+                    Enum e = ff.getEnum();\n+                    for (long l : e.getValues()) {\n+                        EnumVariant v = e.getEnumVariantForValue(l);\n+                        options.add(new StateOption(Long.toString(l), v.getText(lang)));\n+                    }\n+\n+                    stateDescriptionProvider.setStateOptions(channelUID, options);\n+\n+                    Channel channel = ChannelBuilder.create(channelUID, \"Number\").withType(channelTypeUID)\n+                            .withLabel(pfv.getName(lang)).build();\n+\n+                    thingBuilder.withChannel(channel).withLabel(thing.getLabel());\n+                    updateThing(thingBuilder.build());\n+                } else if (pfv.getRawValueDouble() != null) {\n+                    /* a number channel */\n+                    Channel channel = ChannelBuilder.create(channelUID, acceptedItemType).withType(channelTypeUID)\n+                            .withLabel(pfv.getName(lang)).build();\n+\n+                    thingBuilder.withChannel(channel).withLabel(thing.getLabel());\n+                    updateThing(thingBuilder.build());\n+                }\n+                logger.debug(\"Creating channel: {}\", channelUID);\n+            }\n+\n+            if (pfv.getEnumVariant() != null) {\n+                /* update the enum / State channel */\n+                setChannelValue(channelId, pfv.getRawValueLong()); // pfv.getEnumVariant().getText(lang));", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTI0NzgyNw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r571247827", "bodyText": "it can not only, it shall be removed \ud83d\ude00", "author": "ramack", "createdAt": "2021-02-05T21:01:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2MzA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2NDA4NA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570564084", "bodyText": "Fields should be placed at the top of the class.", "author": "fwolter", "createdAt": "2021-02-04T21:44:13Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolDeviceDiscoveryService.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.handler.ResolBridgeHandler;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ResolDeviceDiscoveryService} class handles the discovery of things.\n+ *\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class ResolDeviceDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+\n+    public ResolDeviceDiscoveryService() throws IllegalArgumentException {\n+        super(Set.of(ResolBindingConstants.THING_TYPE_UID_DEVICE), 15, false);\n+    }\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolDeviceDiscoveryService.class);\n+\n+    private @Nullable ResolBridgeHandler resolBridgeHandler;", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2NDgxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570564814", "bodyText": "This should be cancelled if stopScan() is invoked.", "author": "fwolter", "createdAt": "2021-02-04T21:45:30Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolVBusBridgeDiscovery.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolVBusBridgeDiscovery} class provides the DiscoverySerivce to\n+ * discover Resol VBus-LAN adapters\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class ResolVBusBridgeDiscovery extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(ResolVBusBridgeDiscovery.class);\n+\n+    public ResolVBusBridgeDiscovery() throws IllegalArgumentException {\n+        super(ResolBindingConstants.SUPPORTED_BRIDGE_THING_TYPES_UIDS, 35, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        scheduler.execute(this::searchRunnable);", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2NTM5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570565391", "bodyText": "Better make ipAddress a constant.", "author": "fwolter", "createdAt": "2021-02-04T21:46:26Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolVBusBridgeDiscovery.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolVBusBridgeDiscovery} class provides the DiscoverySerivce to\n+ * discover Resol VBus-LAN adapters\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class ResolVBusBridgeDiscovery extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(ResolVBusBridgeDiscovery.class);\n+\n+    public ResolVBusBridgeDiscovery() throws IllegalArgumentException {\n+        super(ResolBindingConstants.SUPPORTED_BRIDGE_THING_TYPES_UIDS, 35, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        scheduler.execute(this::searchRunnable);\n+    }\n+\n+    /*\n+     * The runnable for the search routine.\n+     */\n+    public void searchRunnable() {\n+        try {\n+            InetAddress broadcastAddress = InetAddress\n+                    .getByAddress(new byte[] { (byte) 255, (byte) 255, (byte) 255, (byte) 255 });\n+\n+            TcpDataSource[] dataSources = TcpDataSourceProvider.discoverDataSources(broadcastAddress, 3, 500, false);\n+\n+            HashMap<String, TcpDataSource> currentDataSourceById = new HashMap<String, TcpDataSource>();\n+            for (TcpDataSource ds : dataSources) {\n+                InetAddress address = ds.getAddress();\n+                String addressId = address.getHostAddress();\n+                TcpDataSource dsWithInfo;\n+                try {\n+                    dsWithInfo = TcpDataSourceProvider.fetchInformation(address, 1500);\n+                    logger.trace(\"Discovered Resol VBus-LAN interface @{} {} ({})\", addressId,\n+                            dsWithInfo.getDeviceName(), dsWithInfo.getSerial());\n+\n+                    currentDataSourceById.put(addressId, dsWithInfo);\n+                    addAdapter(addressId, dsWithInfo);\n+                    // here we can add the detection of Multi-Channel interfaces like DL3\n+                } catch (IOException ex) {\n+                    /* address is no valid adapter */\n+                }\n+\n+            }\n+        } catch (UnknownHostException e) {\n+            logger.debug(\"Could not resolve IPv4 broadcast address\");\n+        }\n+    }\n+\n+    private void addAdapter(String remoteIP, TcpDataSource dsWithInfo) {\n+        String adapterSerial = dsWithInfo.getSerial();\n+        Map<String, Object> properties = new HashMap<>(3);\n+        properties.put(\"ipAddress\", remoteIP);\n+        properties.put(\"port\", dsWithInfo.getLivePort());\n+        properties.put(\"adapterSerial\", adapterSerial);\n+\n+        ThingUID uid = new ThingUID(ResolBindingConstants.THING_TYPE_UID_BRIDGE, adapterSerial);\n+        thingDiscovered(DiscoveryResultBuilder.create(uid).withRepresentationProperty(\"ipAddress\")", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2NTUwMg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r570565502", "bodyText": "Better make type a constant.", "author": "fwolter", "createdAt": "2021-02-04T21:46:38Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolDeviceDiscoveryService.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.handler.ResolBridgeHandler;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ResolDeviceDiscoveryService} class handles the discovery of things.\n+ *\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class ResolDeviceDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+\n+    public ResolDeviceDiscoveryService() throws IllegalArgumentException {\n+        super(Set.of(ResolBindingConstants.THING_TYPE_UID_DEVICE), 15, false);\n+    }\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolDeviceDiscoveryService.class);\n+\n+    private @Nullable ResolBridgeHandler resolBridgeHandler;\n+\n+    public void addThing(ThingUID bridgeUID, String thingType, String type, String name) {\n+        logger.trace(\"Adding new Resol thing: {}\", type);\n+        ThingUID thingUID = null;\n+        switch (thingType) {\n+            case ResolBindingConstants.THING_ID_DEVICE:\n+                thingUID = new ThingUID(ResolBindingConstants.THING_TYPE_UID_DEVICE, bridgeUID, type);\n+                break;\n+        }\n+\n+        if (thingUID != null) {\n+            logger.trace(\"Adding new Discovery thingType: {} bridgeType: {}\", thingUID.getAsString(),\n+                    bridgeUID.getAsString());\n+\n+            Map<String, Object> properties = new HashMap<>(1);\n+            properties.put(\"type\", type);\n+\n+            DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID).withBridge(bridgeUID)\n+                    .withRepresentationProperty(\"type\").withProperties(properties).withLabel(name).build();", "originalCommit": "540db7e4955f6bdfc95401dc7fe2768362474adc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "da565c563c24e29007c9ee5877916fd49b175527", "url": "https://github.com/openhab/openhab-addons/commit/da565c563c24e29007c9ee5877916fd49b175527", "message": "Update bundles/org.openhab.binding.resol/README.md\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T20:22:10Z", "type": "forcePushed"}, {"oid": "906f0f7d00b63050bbc9e0d650314b6d97663e7d", "url": "https://github.com/openhab/openhab-addons/commit/906f0f7d00b63050bbc9e0d650314b6d97663e7d", "message": "swap to OH3, improve docs and some minor fixes\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:13Z", "type": "commit"}, {"oid": "0b7efbf4ae71312d78fd51669be4101e57469362", "url": "https://github.com/openhab/openhab-addons/commit/0b7efbf4ae71312d78fd51669be4101e57469362", "message": "fix typos\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:13Z", "type": "commit"}, {"oid": "2a174df64c2675f03f93371faacd66766d9807e8", "url": "https://github.com/openhab/openhab-addons/commit/2a174df64c2675f03f93371faacd66766d9807e8", "message": "first version with EM emulation\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:13Z", "type": "commit"}, {"oid": "dca50edf01387832f89d06563e6568d4ec405426", "url": "https://github.com/openhab/openhab-addons/commit/dca50edf01387832f89d06563e6568d4ec405426", "message": "bump version and remove useless logging\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:13Z", "type": "commit"}, {"oid": "be63c2cef2e7475a7dfe8b44a394cf78ff708360", "url": "https://github.com/openhab/openhab-addons/commit/be63c2cef2e7475a7dfe8b44a394cf78ff708360", "message": "improve logging, threadsafety and detection of special values\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:13Z", "type": "commit"}, {"oid": "d9a5ed6e7db3bc16214c7b9070f268a0fb8a53fa", "url": "https://github.com/openhab/openhab-addons/commit/d9a5ed6e7db3bc16214c7b9070f268a0fb8a53fa", "message": "bump version, remove resource file which is included in the mvn dependency, rework from reviews and finalize Emulated EM with BAD support\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:14Z", "type": "commit"}, {"oid": "a36cb66970e8a319616b8c47dcaf127008982ab4", "url": "https://github.com/openhab/openhab-addons/commit/a36cb66970e8a319616b8c47dcaf127008982ab4", "message": "fix style errors\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:14Z", "type": "commit"}, {"oid": "f3b363a0308a44d7a9ea3f901be6189cd1d89bab", "url": "https://github.com/openhab/openhab-addons/commit/f3b363a0308a44d7a9ea3f901be6189cd1d89bab", "message": "use state options for enum values\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:14Z", "type": "commit"}, {"oid": "19af86c98af764575a97029b12f28f8858915428", "url": "https://github.com/openhab/openhab-addons/commit/19af86c98af764575a97029b12f28f8858915428", "message": "inject LocaleProvider in constructor\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:14Z", "type": "commit"}, {"oid": "8f893f0531f743f9c60d349f0c7abb06488fb1eb", "url": "https://github.com/openhab/openhab-addons/commit/8f893f0531f743f9c60d349f0c7abb06488fb1eb", "message": "add representation-property\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:14Z", "type": "commit"}, {"oid": "e8e78bf0086e1bc83d4e48d719fe6d3140579090", "url": "https://github.com/openhab/openhab-addons/commit/e8e78bf0086e1bc83d4e48d719fe6d3140579090", "message": "update documentation and German translation\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:14Z", "type": "commit"}, {"oid": "5f64874d3ab01aa6fcdca8f3e15f61423e4793bc", "url": "https://github.com/openhab/openhab-addons/commit/5f64874d3ab01aa6fcdca8f3e15f61423e4793bc", "message": "make the BAS mode a state with options\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:15Z", "type": "commit"}, {"oid": "3849287e24bdd8f213016c76949106f7c1219624", "url": "https://github.com/openhab/openhab-addons/commit/3849287e24bdd8f213016c76949106f7c1219624", "message": "implement the thing discovery as ThingHandlerService\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:15Z", "type": "commit"}, {"oid": "ae9d68ef3b3ec5ccb7bbfd1abbecd79095591304", "url": "https://github.com/openhab/openhab-addons/commit/ae9d68ef3b3ec5ccb7bbfd1abbecd79095591304", "message": "bump version\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:15Z", "type": "commit"}, {"oid": "a385bdeeb783c74b19686713ea03c2989d60dacd", "url": "https://github.com/openhab/openhab-addons/commit/a385bdeeb783c74b19686713ea03c2989d60dacd", "message": "refactor and improve the design by moving the work into ThingHandlers and more rewort from the review\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:15Z", "type": "commit"}, {"oid": "a790f286f7e6b035476db5c7cd3121b215ec1922", "url": "https://github.com/openhab/openhab-addons/commit/a790f286f7e6b035476db5c7cd3121b215ec1922", "message": "remove warnings\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:15Z", "type": "commit"}, {"oid": "0085f144bf750058e42b9d11c5a5ea85cba4fa67", "url": "https://github.com/openhab/openhab-addons/commit/0085f144bf750058e42b9d11c5a5ea85cba4fa67", "message": "fix typo in translation\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:15Z", "type": "commit"}, {"oid": "68a09453342ead392f7ae47b75d2bf67fe3ee2ad", "url": "https://github.com/openhab/openhab-addons/commit/68a09453342ead392f7ae47b75d2bf67fe3ee2ad", "message": "add missing translation for state options\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:15Z", "type": "commit"}, {"oid": "89d890c443d40862480fb4866e94a0a64c2eb9f9", "url": "https://github.com/openhab/openhab-addons/commit/89d890c443d40862480fb4866e94a0a64c2eb9f9", "message": "fix channel names in README\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:16Z", "type": "commit"}, {"oid": "7895616c8c977c4652120a3979d89d082c498f12", "url": "https://github.com/openhab/openhab-addons/commit/7895616c8c977c4652120a3979d89d082c498f12", "message": "Update bundles/org.openhab.binding.resol/README.md\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:16Z", "type": "commit"}, {"oid": "57f1835919feef6549c5774231d35fccaff5fe1d", "url": "https://github.com/openhab/openhab-addons/commit/57f1835919feef6549c5774231d35fccaff5fe1d", "message": "rework after review\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:16Z", "type": "commit"}, {"oid": "57f1835919feef6549c5774231d35fccaff5fe1d", "url": "https://github.com/openhab/openhab-addons/commit/57f1835919feef6549c5774231d35fccaff5fe1d", "message": "rework after review\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-05T22:15:16Z", "type": "forcePushed"}, {"oid": "102ef689eadbcf16adae4029cda440bd43bdf18f", "url": "https://github.com/openhab/openhab-addons/commit/102ef689eadbcf16adae4029cda440bd43bdf18f", "message": "further rework and reduce visibilibty of some methods\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-07T09:38:55Z", "type": "commit"}, {"oid": "e3977c70f3b4268e9494d9989cf1167c9de57cf9", "url": "https://github.com/openhab/openhab-addons/commit/e3977c70f3b4268e9494d9989cf1167c9de57cf9", "message": "fix typo\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-07T16:23:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY0NTYwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r571645609", "bodyText": "What is the meaning of the value of 888.8\u00b0C? You could log a warning if the unit cannot be converted. This occurs if the user sent an invalid command.", "author": "fwolter", "createdAt": "2021-02-07T16:51:59Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends ResolBaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay_\";\n+    public static final String CHANNEL_TEMP = \"temperature_\";\n+    public static final String CHANNEL_RESIST = \"resistor_\";\n+    public static final String CHANNEL_SWITCH = \"switch_\";\n+    public static final String CHANNEL_TEMP_ADJUST = \"bas_temp_adjust_\";\n+    public static final String CHANNEL_MODE = \"bas_mode_\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+    private int deviceId = 1;\n+    private @Nullable EmDeviceEmulator device;\n+\n+    private @Nullable ResolBridgeHandler bridgeHandler;\n+\n+    private class BasSetting {\n+        float temperatureOffset = 0.0f;\n+        int mode = 4;\n+    }\n+\n+    private BasSetting[] basValues = { new BasSetting(), new BasSetting(), new BasSetting(), new BasSetting(),\n+            new BasSetting(), new BasSetting() };\n+    private long lastTime = System.currentTimeMillis();\n+\n+    // Background Runnable\n+    private @Nullable ScheduledFuture<?> updateJob;\n+\n+    public ResolEmuEMThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolEmuEMConfiguration configuration = getConfigAs(ResolEmuEMConfiguration.class);\n+        deviceId = configuration.deviceId;\n+        vbusAddress = 0x6650 + deviceId;\n+\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        EmDeviceEmulator dev = device;\n+        if (dev != null) {\n+            dev.stop();\n+            dev.removePropertyChangeListener(this);\n+        }\n+    }\n+\n+    private void updateRunnable() {\n+        EmDeviceEmulator d = device;\n+        if (d != null) {\n+            long now = System.currentTimeMillis();\n+            int diff = (int) (now - lastTime);\n+            lastTime = now;\n+\n+            d.update(diff);\n+        }\n+    }\n+\n+    private void startAutomaticUpdate() {\n+        ScheduledFuture<?> job = updateJob;\n+        if (job == null || job.isCancelled()) {\n+            updateJob = scheduler.scheduleWithFixedDelay(this::updateRunnable, 0, 1, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for thing {}.\", thing.getThingTypeUID());\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    private void registerResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.registerResolThingListener(this);\n+        } else {\n+            logger.debug(\"Can't register {} at bridge as bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    public int getVbusAddress() {\n+        return vbusAddress;\n+    }\n+\n+    public void useConnection(Connection connection) {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+            device.removePropertyChangeListener(this);\n+        }\n+        device = new EmDeviceEmulator(connection, deviceId);\n+        this.device = device;\n+        device.addPropertyChangeListener(this);\n+        device.start();\n+        for (int i = 1; i <= 5; i++) {\n+            setRelayChannelValue(i, device.getRelayValueByNr(i));\n+        }\n+        startAutomaticUpdate();\n+    }\n+\n+    public void stop() {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+        }\n+        ScheduledFuture<?> updateJob = this.updateJob;\n+        if (updateJob != null) {\n+            updateJob.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String chID = channelUID.getId();\n+        boolean update = false;\n+        int channel = chID.charAt(chID.length() - 1) - '0';\n+        float value = 0;\n+        int intValue = 0;\n+\n+        if (command instanceof QuantityType<?>) {\n+            value = Objects.requireNonNullElse(((QuantityType<?>) command).toUnit(SIUnits.CELSIUS),\n+                    new QuantityType<>(888.8, SIUnits.CELSIUS)).floatValue();", "originalCommit": "e3977c70f3b4268e9494d9989cf1167c9de57cf9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY0NzI1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r571647258", "bodyText": "888.8 is used in the VBUS in case of not available values - e. g. if the sensor wire would be broken. So in my eyes it fits quite well to the illegal input case here.", "author": "ramack", "createdAt": "2021-02-07T17:05:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY0NTYwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY1MTIxMw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r571651213", "bodyText": "Me as a user would be happy about a hint what went wrong. I leave it up to you how to handle that case.", "author": "fwolter", "createdAt": "2021-02-07T17:35:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY0NTYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY0NTczNA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r571645734", "bodyText": "As it is a constant now, the name should be all upper case.", "author": "fwolter", "createdAt": "2021-02-07T16:53:15Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolThingHandler.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.TimeZone;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolStateDescriptionOptionProvider;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldSpec;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Enum;\n+import de.resol.vbus.SpecificationFile.EnumVariant;\n+import de.resol.vbus.SpecificationFile.Language;\n+\n+/**\n+ * The {@link ResolThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolThingHandler extends ResolBaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolThingHandler.class);\n+\n+    @Nullable\n+    ResolBridgeHandler bridgeHandler;\n+    private ResolStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private static final SimpleDateFormat dateFormat = new SimpleDateFormat(", "originalCommit": "e3977c70f3b4268e9494d9989cf1167c9de57cf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "52b1d0663a6639a30907fd78636fe850b62644d9", "url": "https://github.com/openhab/openhab-addons/commit/52b1d0663a6639a30907fd78636fe850b62644d9", "message": "rework from review: fix typos, make constant upper case\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-07T17:10:54Z", "type": "commit"}, {"oid": "188f95e41f90cc591e83636f52cbed2f1d2173e3", "url": "https://github.com/openhab/openhab-addons/commit/188f95e41f90cc591e83636f52cbed2f1d2173e3", "message": "rework checkstyle warnings\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-07T19:14:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM0MjIzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577342235", "bodyText": "This should be part of static initialization.", "author": "cpmeister", "createdAt": "2021-02-17T05:50:00Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolThingHandler.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.TimeZone;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolStateDescriptionOptionProvider;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldSpec;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Enum;\n+import de.resol.vbus.SpecificationFile.EnumVariant;\n+import de.resol.vbus.SpecificationFile.Language;\n+\n+/**\n+ * The {@link ResolThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolThingHandler extends ResolBaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolThingHandler.class);\n+\n+    @Nullable\n+    ResolBridgeHandler bridgeHandler;\n+    private ResolStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(\n+            DateTimeType.DATE_PATTERN_WITH_TZ_AND_MS_GENERAL);\n+\n+    public ResolThingHandler(Thing thing, ResolStateDescriptionOptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        synchronized (DATE_FORMAT) {\n+            DATE_FORMAT.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+        }", "originalCommit": "188f95e41f90cc591e83636f52cbed2f1d2173e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM1NjkxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577356911", "bodyText": "makes sense, yes. But do I need to keep the synchronized block in the static initializer? Without having that deep experience in Java I would expect, that the static init is ensured to be executed completely before any other thread accesses methods of objects of this class. - Is that true, or should I keep the synchronized even there?", "author": "ramack", "createdAt": "2021-02-17T06:32:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM0MjIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDE4ODYxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r584188611", "bodyText": "@cpmeister any more comment on this one? Keep the synchronized in the static initialization or is it not needed there?", "author": "ramack", "createdAt": "2021-02-27T20:44:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM0MjIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTIxMDMxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r585210318", "bodyText": "The synchronized isn't needed here but synchronizing access to the SimpleDateFormat sets a good precedent since few realize that it isn't thread-safe in general. Keep or remove it I'm fine either way.", "author": "cpmeister", "createdAt": "2021-03-02T02:55:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM0MjIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM0NDIzMg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577344232", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        HashMap<String, TcpDataSource> currentDataSourceById = new HashMap<String, TcpDataSource>();\n          \n          \n            \n                        Map<String, TcpDataSource> currentDataSourceById = new HashMap<>();", "author": "cpmeister", "createdAt": "2021-02-17T05:55:50Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolVBusBridgeDiscovery.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolVBusBridgeDiscovery} class provides the DiscoverySerivce to\n+ * discover Resol VBus-LAN adapters\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class ResolVBusBridgeDiscovery extends AbstractDiscoveryService {\n+    public static final String THING_PROPERTY_IPADDRESS = \"ipAddress\";\n+    public static final String THING_PROPERTY_PORT = \"port\";\n+    public static final String THING_PROPERTY_ADAPTER_SERIAL = \"adapterSerial\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolVBusBridgeDiscovery.class);\n+\n+    private boolean discoveryRunning = false;\n+\n+    public ResolVBusBridgeDiscovery() throws IllegalArgumentException {\n+        super(ResolBindingConstants.SUPPORTED_BRIDGE_THING_TYPES_UIDS, 35, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        discoveryRunning = true;\n+        scheduler.execute(this::searchRunnable);\n+    }\n+\n+    @Override\n+    protected void stopScan() {\n+        discoveryRunning = false;\n+    }\n+\n+    /*\n+     * The runnable for the search routine.\n+     */\n+    public void searchRunnable() {\n+        try {\n+            InetAddress broadcastAddress = InetAddress\n+                    .getByAddress(new byte[] { (byte) 255, (byte) 255, (byte) 255, (byte) 255 });\n+\n+            TcpDataSource[] dataSources = TcpDataSourceProvider.discoverDataSources(broadcastAddress, 3, 500, false);\n+\n+            HashMap<String, TcpDataSource> currentDataSourceById = new HashMap<String, TcpDataSource>();", "originalCommit": "188f95e41f90cc591e83636f52cbed2f1d2173e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM0NDQxMg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577344412", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean discoveryRunning = false;\n          \n          \n            \n                private volatile boolean discoveryRunning = false;", "author": "cpmeister", "createdAt": "2021-02-17T05:56:17Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolVBusBridgeDiscovery.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolVBusBridgeDiscovery} class provides the DiscoverySerivce to\n+ * discover Resol VBus-LAN adapters\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class ResolVBusBridgeDiscovery extends AbstractDiscoveryService {\n+    public static final String THING_PROPERTY_IPADDRESS = \"ipAddress\";\n+    public static final String THING_PROPERTY_PORT = \"port\";\n+    public static final String THING_PROPERTY_ADAPTER_SERIAL = \"adapterSerial\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolVBusBridgeDiscovery.class);\n+\n+    private boolean discoveryRunning = false;", "originalCommit": "188f95e41f90cc591e83636f52cbed2f1d2173e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM0NjIyMA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577346220", "bodyText": "The @Component annotation isn't compatible with ThingHandlerService atm.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = DiscoveryService.class)\n          \n          \n            \n            @NonNullByDefault\n          \n          \n            \n            public class ResolDeviceDiscoveryService extends AbstractDiscoveryService\n          \n          \n            \n                    implements DiscoveryService, ThingHandlerService {\n          \n          \n            \n            @NonNullByDefault\n          \n          \n            \n            public class ResolDeviceDiscoveryService extends AbstractDiscoveryService\n          \n          \n            \n                    implements DiscoveryService, ThingHandlerService {", "author": "cpmeister", "createdAt": "2021-02-17T06:01:17Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolDeviceDiscoveryService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.handler.ResolBridgeHandler;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ResolDeviceDiscoveryService} class handles the discovery of things.\n+ *\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class ResolDeviceDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {", "originalCommit": "188f95e41f90cc591e83636f52cbed2f1d2173e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM3NDQzNw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577374437", "bodyText": "The code looks pretty good to be honest. Only a few changes I'd suggest.\n\nThanks, that is due to the valuable review comments from @fwolter and @Hilbrand!", "author": "ramack", "createdAt": "2021-02-17T07:16:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM0NjIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM0NjU2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577346561", "bodyText": "Is there a reason this needs to be package private?", "author": "cpmeister", "createdAt": "2021-02-17T06:02:25Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolThingHandler.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.TimeZone;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolStateDescriptionOptionProvider;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldSpec;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Enum;\n+import de.resol.vbus.SpecificationFile.EnumVariant;\n+import de.resol.vbus.SpecificationFile.Language;\n+\n+/**\n+ * The {@link ResolThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolThingHandler extends ResolBaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolThingHandler.class);\n+\n+    @Nullable\n+    ResolBridgeHandler bridgeHandler;", "originalCommit": "188f95e41f90cc591e83636f52cbed2f1d2173e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM2OTk3OA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577369978", "bodyText": "no, and we even can get rid of this completely.", "author": "ramack", "createdAt": "2021-02-17T07:05:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM0NjU2MQ=="}], "type": "inlineReview"}, {"oid": "7c5f2d62fc9d7a90a811d1b463a525c2c1d6462b", "url": "https://github.com/openhab/openhab-addons/commit/7c5f2d62fc9d7a90a811d1b463a525c2c1d6462b", "message": "rework after review\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-17T07:06:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzkxNDkwMA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577914900", "bodyText": "Why update the channels here? at this point it gets a command because the value of the channel changed. So this update changes the value to the value the channel already contains? So it seems redundant to do this.", "author": "Hilbrand", "createdAt": "2021-02-17T20:17:12Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends ResolBaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay_\";\n+    public static final String CHANNEL_TEMP = \"temperature_\";\n+    public static final String CHANNEL_RESIST = \"resistor_\";\n+    public static final String CHANNEL_SWITCH = \"switch_\";\n+    public static final String CHANNEL_TEMP_ADJUST = \"bas_temp_adjust_\";\n+    public static final String CHANNEL_MODE = \"bas_mode_\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+    private int deviceId = 1;\n+    private @Nullable EmDeviceEmulator device;\n+\n+    private @Nullable ResolBridgeHandler bridgeHandler;\n+\n+    private class BasSetting {\n+        float temperatureOffset = 0.0f;\n+        int mode = 4;\n+    }\n+\n+    private BasSetting[] basValues = { new BasSetting(), new BasSetting(), new BasSetting(), new BasSetting(),\n+            new BasSetting(), new BasSetting() };\n+    private long lastTime = System.currentTimeMillis();\n+\n+    // Background Runnable\n+    private @Nullable ScheduledFuture<?> updateJob;\n+\n+    public ResolEmuEMThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolEmuEMConfiguration configuration = getConfigAs(ResolEmuEMConfiguration.class);\n+        deviceId = configuration.deviceId;\n+        vbusAddress = 0x6650 + deviceId;\n+\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        EmDeviceEmulator dev = device;\n+        if (dev != null) {\n+            dev.stop();\n+            dev.removePropertyChangeListener(this);\n+        }\n+    }\n+\n+    private void updateRunnable() {\n+        EmDeviceEmulator d = device;\n+        if (d != null) {\n+            long now = System.currentTimeMillis();\n+            int diff = (int) (now - lastTime);\n+            lastTime = now;\n+\n+            d.update(diff);\n+        }\n+    }\n+\n+    private void startAutomaticUpdate() {\n+        ScheduledFuture<?> job = updateJob;\n+        if (job == null || job.isCancelled()) {\n+            updateJob = scheduler.scheduleWithFixedDelay(this::updateRunnable, 0, 1, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for thing {}.\", thing.getThingTypeUID());\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    private void registerResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.registerResolThingListener(this);\n+        } else {\n+            logger.debug(\"Can't register {} at bridge as bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    public int getVbusAddress() {\n+        return vbusAddress;\n+    }\n+\n+    public void useConnection(Connection connection) {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+            device.removePropertyChangeListener(this);\n+        }\n+        device = new EmDeviceEmulator(connection, deviceId);\n+        this.device = device;\n+        device.addPropertyChangeListener(this);\n+        device.start();\n+        for (int i = 1; i <= 5; i++) {\n+            setRelayChannelValue(i, device.getRelayValueByNr(i));\n+        }\n+        startAutomaticUpdate();\n+    }\n+\n+    public void stop() {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+        }\n+        ScheduledFuture<?> updateJob = this.updateJob;\n+        if (updateJob != null) {\n+            updateJob.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String chID = channelUID.getId();\n+        boolean update = false;\n+        int channel = chID.charAt(chID.length() - 1) - '0';\n+        float value = 0;\n+        int intValue = 0;\n+\n+        if (command instanceof QuantityType<?>) {\n+            value = Objects.requireNonNullElse(((QuantityType<?>) command).toUnit(SIUnits.CELSIUS),\n+                    new QuantityType<>(888.8, SIUnits.CELSIUS)).floatValue();\n+            update = true;\n+        } else if (command instanceof OnOffType) {\n+            intValue = ((OnOffType) command).equals(OnOffType.ON) ? 1 : 0;\n+            update = true;\n+        } else if (command instanceof DecimalType) {\n+            intValue = ((DecimalType) command).intValue();\n+            value = intValue;\n+            update = true;\n+        } else {\n+            update = false;\n+        }\n+\n+        if (update) {\n+            EmDeviceEmulator dev = device;\n+            if (dev != null) {\n+                if (chID.startsWith(CHANNEL_TEMP)) {\n+                    dev.setResistorValueByNrAndPt1000Temperatur(channel, value);\n+                    updateState(channelUID, new DecimalType(value));\n+                } else if (chID.startsWith(CHANNEL_SWITCH)) {\n+                    if (intValue == 0) {\n+                        /* switch is open => 1 megaohm */\n+                        dev.setResistorValueByNr(channel, 1000000000);\n+                        updateState(channelUID, OnOffType.OFF);", "originalCommit": "7c5f2d62fc9d7a90a811d1b463a525c2c1d6462b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzkyNzQ2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577927463", "bodyText": "I added these updates, because otherwise the MainUI did not correctly update the view (of the widget I tried with). Maybe I just did something wrong as I am not yet used to MainUI or whatever. Let me know if I should remove it.", "author": "ramack", "createdAt": "2021-02-17T20:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzkxNDkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDE4ODkxMA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r584188910", "bodyText": "@Hilbrand any remark on that? - I have added the update here to have the MainUI showing the update. Should I remove it?", "author": "ramack", "createdAt": "2021-02-27T20:46:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzkxNDkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzkxNjgxNw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r577916817", "bodyText": "These fields can be final", "author": "Hilbrand", "createdAt": "2021-02-17T20:20:14Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/ResolHandlerFactory.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal;\n+\n+import static org.openhab.binding.resol.internal.ResolBindingConstants.SUPPORTED_THING_TYPES_UIDS;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.handler.ResolBridgeHandler;\n+import org.openhab.binding.resol.handler.ResolEmuEMThingHandler;\n+import org.openhab.binding.resol.handler.ResolThingHandler;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link ResolHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.resol\", service = ThingHandlerFactory.class)\n+public class ResolHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private LocaleProvider localeProvider;", "originalCommit": "7c5f2d62fc9d7a90a811d1b463a525c2c1d6462b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "10373f36be67c9514348b055fc7b91ff4a314eb1", "url": "https://github.com/openhab/openhab-addons/commit/10373f36be67c9514348b055fc7b91ff4a314eb1", "message": "rework after review\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-17T21:48:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA3MzEzMw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583073133", "bodyText": "Since the locale can be changed during runtime, it would be better to retrieve locale information from the provider on demand instead of trying to cache it in fields.", "author": "cpmeister", "createdAt": "2021-02-25T18:37:09Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDeviceDiscoveryService;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runnable\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable Connection tcpConnection;\n+    private Specification spec;\n+\n+    // Managing Thing Discovery Service\n+    private @Nullable ResolDeviceDiscoveryService discoveryService = null;\n+\n+    private boolean scanning;\n+\n+    public ResolBridgeHandler(Bridge bridge, @Nullable LocaleProvider localeProvider) {\n+        super(bridge);\n+        spec = Specification.getDefaultSpecification();\n+\n+        if (localeProvider != null) {\n+            locale = localeProvider.getLocale();\n+            lang = SpecificationFile.getLanguageForLocale(getLocale());\n+\n+        } else {\n+            locale = Locale.getDefault();\n+            lang = Language.En;\n+        }", "originalCommit": "10373f36be67c9514348b055fc7b91ff4a314eb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzIxODU0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583218545", "bodyText": "Is it worth to increase the depth of the call tree for each received packet for checking the locale only for this rather seldom use case? As a user, I personally would favor runtime performance over this. Or is there at least a callback that I can register to get notified on the locale update?", "author": "ramack", "createdAt": "2021-02-25T21:36:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA3MzEzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mzk3MDgxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583970818", "bodyText": "The performance impact would be negligible and would allow the user to change the locale in openhab without having to restart your binding.\nThat said I don't know what the performance impact of calling SpecificationFile.getLanguageForLocale would be. So it might be worth caching the return value from that method and only changing it when the returned locale from the provider changes.", "author": "cpmeister", "createdAt": "2021-02-26T22:59:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA3MzEzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDE4NzYyOA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r584187628", "bodyText": "SpecificationFile.getLanguageForLocale looks also quite fast, so I changed to read the locale dynamically.", "author": "ramack", "createdAt": "2021-02-27T20:34:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA3MzEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MDIxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583080218", "bodyText": "I second @fwolter's recommendation to cancel the async task with an interrupt when stopScan is called. Setting discoveryRunning = false is not sufficient.", "author": "cpmeister", "createdAt": "2021-02-25T18:47:08Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolVBusBridgeDiscovery.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolVBusBridgeDiscovery} class provides the DiscoverySerivce to\n+ * discover Resol VBus-LAN adapters\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class ResolVBusBridgeDiscovery extends AbstractDiscoveryService {\n+    public static final String THING_PROPERTY_IPADDRESS = \"ipAddress\";\n+    public static final String THING_PROPERTY_PORT = \"port\";\n+    public static final String THING_PROPERTY_ADAPTER_SERIAL = \"adapterSerial\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolVBusBridgeDiscovery.class);\n+\n+    private volatile boolean discoveryRunning = false;\n+\n+    public ResolVBusBridgeDiscovery() throws IllegalArgumentException {\n+        super(ResolBindingConstants.SUPPORTED_BRIDGE_THING_TYPES_UIDS, 35, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        discoveryRunning = true;\n+        scheduler.execute(this::searchRunnable);", "originalCommit": "10373f36be67c9514348b055fc7b91ff4a314eb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzIwNjcxMw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583206713", "bodyText": "Can you point me to an example? Since I was requested to use directly the execute() with the method as parameter I don't have any object anymore that could be canceled...", "author": "ramack", "createdAt": "2021-02-25T21:17:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mzk3MTExMw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583971113", "bodyText": "If you use submit instead then it would return a Future which you could store to a field and then cancel that future as part of stopScan.", "author": "cpmeister", "createdAt": "2021-02-26T23:00:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MDIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MTM5NA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583081394", "bodyText": "You should make sure to exit early if you catch an InterruptedIOException.", "author": "cpmeister", "createdAt": "2021-02-25T18:48:54Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/discovery/ResolVBusBridgeDiscovery.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal.discovery;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolVBusBridgeDiscovery} class provides the DiscoverySerivce to\n+ * discover Resol VBus-LAN adapters\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class ResolVBusBridgeDiscovery extends AbstractDiscoveryService {\n+    public static final String THING_PROPERTY_IPADDRESS = \"ipAddress\";\n+    public static final String THING_PROPERTY_PORT = \"port\";\n+    public static final String THING_PROPERTY_ADAPTER_SERIAL = \"adapterSerial\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolVBusBridgeDiscovery.class);\n+\n+    private volatile boolean discoveryRunning = false;\n+\n+    public ResolVBusBridgeDiscovery() throws IllegalArgumentException {\n+        super(ResolBindingConstants.SUPPORTED_BRIDGE_THING_TYPES_UIDS, 35, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        discoveryRunning = true;\n+        scheduler.execute(this::searchRunnable);\n+    }\n+\n+    @Override\n+    protected void stopScan() {\n+        discoveryRunning = false;\n+    }\n+\n+    /*\n+     * The runnable for the search routine.\n+     */\n+    public void searchRunnable() {\n+        try {\n+            InetAddress broadcastAddress = InetAddress\n+                    .getByAddress(new byte[] { (byte) 255, (byte) 255, (byte) 255, (byte) 255 });\n+\n+            TcpDataSource[] dataSources = TcpDataSourceProvider.discoverDataSources(broadcastAddress, 3, 500, false);\n+\n+            Map<String, TcpDataSource> currentDataSourceById = new HashMap<String, TcpDataSource>();\n+            for (TcpDataSource ds : dataSources) {\n+                if (!discoveryRunning) {\n+                    break;\n+                }\n+                InetAddress address = ds.getAddress();\n+                String addressId = address.getHostAddress();\n+                TcpDataSource dsWithInfo;\n+                try {\n+                    dsWithInfo = TcpDataSourceProvider.fetchInformation(address, 1500);\n+                    logger.trace(\"Discovered Resol VBus-LAN interface @{} {} ({})\", addressId,\n+                            dsWithInfo.getDeviceName(), dsWithInfo.getSerial());\n+\n+                    currentDataSourceById.put(addressId, dsWithInfo);\n+                    addAdapter(addressId, dsWithInfo);\n+                    // here we can add the detection of Multi-Channel interfaces like DL3\n+                } catch (IOException ex) {\n+                    /* address is no valid adapter */\n+                }", "originalCommit": "10373f36be67c9514348b055fc7b91ff4a314eb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzIwNzc4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583207781", "bodyText": "you mean by adding a break statement?", "author": "ramack", "createdAt": "2021-02-25T21:19:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MTM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzIyMzYxNg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583223616", "bodyText": "and why should we even? If for one of the TcpDataSource's that we get from the discovery in the library one is faulty, why should we not try the next one?", "author": "ramack", "createdAt": "2021-02-25T21:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MTM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mzk3MzQyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583973421", "bodyText": "I meant that you should add an extra catch statement for InterruptedIOException which is a type of IOException which is thrown when the thread doing IO is interrupted. The reason for requiring this is to make sure that the thread actually exits as fast as possible when an interrupt occurs. When a thread receives and interrupts it should be assumed that the system is trying to shutdown and typically complete shutdown can't occur until all of the non-daemon threads have stopped running. Since the running thread might be non-daemon it prevent the system from shutting down as long as it is running.", "author": "cpmeister", "createdAt": "2021-02-26T23:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MTM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDE4OTQ3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r584189472", "bodyText": "ok, this way I think I got it! Thanks for the explanation.", "author": "ramack", "createdAt": "2021-02-27T20:51:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MTM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MjAwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583082005", "bodyText": "Instead of using an update flag, why not just exit early here?", "author": "cpmeister", "createdAt": "2021-02-25T18:49:47Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends ResolBaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay_\";\n+    public static final String CHANNEL_TEMP = \"temperature_\";\n+    public static final String CHANNEL_RESIST = \"resistor_\";\n+    public static final String CHANNEL_SWITCH = \"switch_\";\n+    public static final String CHANNEL_TEMP_ADJUST = \"bas_temp_adjust_\";\n+    public static final String CHANNEL_MODE = \"bas_mode_\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+    private int deviceId = 1;\n+    private @Nullable EmDeviceEmulator device;\n+\n+    private @Nullable ResolBridgeHandler bridgeHandler;\n+\n+    private class BasSetting {\n+        float temperatureOffset = 0.0f;\n+        int mode = 4;\n+    }\n+\n+    private BasSetting[] basValues = { new BasSetting(), new BasSetting(), new BasSetting(), new BasSetting(),\n+            new BasSetting(), new BasSetting() };\n+    private long lastTime = System.currentTimeMillis();\n+\n+    // Background Runnable\n+    private @Nullable ScheduledFuture<?> updateJob;\n+\n+    public ResolEmuEMThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolEmuEMConfiguration configuration = getConfigAs(ResolEmuEMConfiguration.class);\n+        deviceId = configuration.deviceId;\n+        vbusAddress = 0x6650 + deviceId;\n+\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        EmDeviceEmulator dev = device;\n+        if (dev != null) {\n+            dev.stop();\n+            dev.removePropertyChangeListener(this);\n+        }\n+    }\n+\n+    private void updateRunnable() {\n+        EmDeviceEmulator d = device;\n+        if (d != null) {\n+            long now = System.currentTimeMillis();\n+            int diff = (int) (now - lastTime);\n+            lastTime = now;\n+\n+            d.update(diff);\n+        }\n+    }\n+\n+    private void startAutomaticUpdate() {\n+        ScheduledFuture<?> job = updateJob;\n+        if (job == null || job.isCancelled()) {\n+            updateJob = scheduler.scheduleWithFixedDelay(this::updateRunnable, 0, 1, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for thing {}.\", thing.getThingTypeUID());\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    private void registerResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.registerResolThingListener(this);\n+        } else {\n+            logger.debug(\"Can't register {} at bridge as bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    public int getVbusAddress() {\n+        return vbusAddress;\n+    }\n+\n+    public void useConnection(Connection connection) {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+            device.removePropertyChangeListener(this);\n+        }\n+        device = new EmDeviceEmulator(connection, deviceId);\n+        this.device = device;\n+        device.addPropertyChangeListener(this);\n+        device.start();\n+        for (int i = 1; i <= 5; i++) {\n+            setRelayChannelValue(i, device.getRelayValueByNr(i));\n+        }\n+        startAutomaticUpdate();\n+    }\n+\n+    public void stop() {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+        }\n+        ScheduledFuture<?> updateJob = this.updateJob;\n+        if (updateJob != null) {\n+            updateJob.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String chID = channelUID.getId();\n+        boolean update = false;\n+        int channel = chID.charAt(chID.length() - 1) - '0';\n+        float value = 0;\n+        int intValue = 0;\n+\n+        if (command instanceof QuantityType<?>) {\n+            value = Objects.requireNonNullElse(((QuantityType<?>) command).toUnit(SIUnits.CELSIUS),\n+                    new QuantityType<>(888.8, SIUnits.CELSIUS)).floatValue();\n+            update = true;\n+        } else if (command instanceof OnOffType) {\n+            intValue = ((OnOffType) command).equals(OnOffType.ON) ? 1 : 0;\n+            update = true;\n+        } else if (command instanceof DecimalType) {\n+            intValue = ((DecimalType) command).intValue();\n+            value = intValue;\n+            update = true;\n+        } else {\n+            update = false;", "originalCommit": "10373f36be67c9514348b055fc7b91ff4a314eb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzIwOTY2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583209669", "bodyText": "By a return you mean? Is that really better or purely a matter of taste?", "author": "ramack", "createdAt": "2021-02-25T21:22:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MjAwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mzk2ODc3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583968773", "bodyText": "Well by returning early you don't need to use an update variable. I'd say that less variables would make the code more maintainable.", "author": "cpmeister", "createdAt": "2021-02-26T22:53:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MjAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MjY4NA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583082684", "bodyText": "updateJob should be canceled here as well.", "author": "cpmeister", "createdAt": "2021-02-25T18:50:47Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends ResolBaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay_\";\n+    public static final String CHANNEL_TEMP = \"temperature_\";\n+    public static final String CHANNEL_RESIST = \"resistor_\";\n+    public static final String CHANNEL_SWITCH = \"switch_\";\n+    public static final String CHANNEL_TEMP_ADJUST = \"bas_temp_adjust_\";\n+    public static final String CHANNEL_MODE = \"bas_mode_\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+    private int deviceId = 1;\n+    private @Nullable EmDeviceEmulator device;\n+\n+    private @Nullable ResolBridgeHandler bridgeHandler;\n+\n+    private class BasSetting {\n+        float temperatureOffset = 0.0f;\n+        int mode = 4;\n+    }\n+\n+    private BasSetting[] basValues = { new BasSetting(), new BasSetting(), new BasSetting(), new BasSetting(),\n+            new BasSetting(), new BasSetting() };\n+    private long lastTime = System.currentTimeMillis();\n+\n+    // Background Runnable\n+    private @Nullable ScheduledFuture<?> updateJob;\n+\n+    public ResolEmuEMThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolEmuEMConfiguration configuration = getConfigAs(ResolEmuEMConfiguration.class);\n+        deviceId = configuration.deviceId;\n+        vbusAddress = 0x6650 + deviceId;\n+\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        EmDeviceEmulator dev = device;\n+        if (dev != null) {\n+            dev.stop();\n+            dev.removePropertyChangeListener(this);\n+        }\n+    }", "originalCommit": "10373f36be67c9514348b055fc7b91ff4a314eb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzIwOTgzNA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583209834", "bodyText": "how do I do that?", "author": "ramack", "createdAt": "2021-02-25T21:22:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MjY4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mzk2ODM1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583968353", "bodyText": "You already do the canceling as part of ResolEmuEMThingHandler.stop() so you either need to call that method or make a common method that does the canceling logic and call that instead.", "author": "cpmeister", "createdAt": "2021-02-26T22:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4MjY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4NDI2NA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583084264", "bodyText": "If this updated anywhere then you should make this final.", "author": "cpmeister", "createdAt": "2021-02-25T18:53:06Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolBridgeHandler.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolBridgeConfiguration;\n+import org.openhab.binding.resol.internal.discovery.ResolDeviceDiscoveryService;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.ConnectionAdapter;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.TcpDataSource;\n+import de.resol.vbus.TcpDataSourceProvider;\n+\n+/**\n+ * The {@link ResolBridgeHandler} class handles the connection to the VBUS/LAN adapter.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolBridgeHandler.class);\n+\n+    private Language lang;\n+    private Locale locale;\n+\n+    private String ipAddress = \"\";\n+    private String password = \"\";\n+    private int refreshInterval;\n+    private boolean isConnected = false;\n+    private String unconnectedReason = \"\";\n+\n+    // Background Runnable\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable Connection tcpConnection;\n+    private Specification spec;", "originalCommit": "10373f36be67c9514348b055fc7b91ff4a314eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA4ODkxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583088918", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private class BasSetting {\n          \n          \n            \n                private static class BasSetting {", "author": "cpmeister", "createdAt": "2021-02-25T18:59:59Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends ResolBaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay_\";\n+    public static final String CHANNEL_TEMP = \"temperature_\";\n+    public static final String CHANNEL_RESIST = \"resistor_\";\n+    public static final String CHANNEL_SWITCH = \"switch_\";\n+    public static final String CHANNEL_TEMP_ADJUST = \"bas_temp_adjust_\";\n+    public static final String CHANNEL_MODE = \"bas_mode_\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+    private int deviceId = 1;\n+    private @Nullable EmDeviceEmulator device;\n+\n+    private @Nullable ResolBridgeHandler bridgeHandler;\n+\n+    private class BasSetting {", "originalCommit": "10373f36be67c9514348b055fc7b91ff4a314eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA5MDA3MA==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583090070", "bodyText": "Can you also handle refresh commands?", "author": "cpmeister", "createdAt": "2021-02-25T19:01:53Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends ResolBaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay_\";\n+    public static final String CHANNEL_TEMP = \"temperature_\";\n+    public static final String CHANNEL_RESIST = \"resistor_\";\n+    public static final String CHANNEL_SWITCH = \"switch_\";\n+    public static final String CHANNEL_TEMP_ADJUST = \"bas_temp_adjust_\";\n+    public static final String CHANNEL_MODE = \"bas_mode_\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+    private int deviceId = 1;\n+    private @Nullable EmDeviceEmulator device;\n+\n+    private @Nullable ResolBridgeHandler bridgeHandler;\n+\n+    private class BasSetting {\n+        float temperatureOffset = 0.0f;\n+        int mode = 4;\n+    }\n+\n+    private BasSetting[] basValues = { new BasSetting(), new BasSetting(), new BasSetting(), new BasSetting(),\n+            new BasSetting(), new BasSetting() };\n+    private long lastTime = System.currentTimeMillis();\n+\n+    // Background Runnable\n+    private @Nullable ScheduledFuture<?> updateJob;\n+\n+    public ResolEmuEMThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolEmuEMConfiguration configuration = getConfigAs(ResolEmuEMConfiguration.class);\n+        deviceId = configuration.deviceId;\n+        vbusAddress = 0x6650 + deviceId;\n+\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        EmDeviceEmulator dev = device;\n+        if (dev != null) {\n+            dev.stop();\n+            dev.removePropertyChangeListener(this);\n+        }\n+    }\n+\n+    private void updateRunnable() {\n+        EmDeviceEmulator d = device;\n+        if (d != null) {\n+            long now = System.currentTimeMillis();\n+            int diff = (int) (now - lastTime);\n+            lastTime = now;\n+\n+            d.update(diff);\n+        }\n+    }\n+\n+    private void startAutomaticUpdate() {\n+        ScheduledFuture<?> job = updateJob;\n+        if (job == null || job.isCancelled()) {\n+            updateJob = scheduler.scheduleWithFixedDelay(this::updateRunnable, 0, 1, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for thing {}.\", thing.getThingTypeUID());\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    private void registerResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.registerResolThingListener(this);\n+        } else {\n+            logger.debug(\"Can't register {} at bridge as bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    public int getVbusAddress() {\n+        return vbusAddress;\n+    }\n+\n+    public void useConnection(Connection connection) {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+            device.removePropertyChangeListener(this);\n+        }\n+        device = new EmDeviceEmulator(connection, deviceId);\n+        this.device = device;\n+        device.addPropertyChangeListener(this);\n+        device.start();\n+        for (int i = 1; i <= 5; i++) {\n+            setRelayChannelValue(i, device.getRelayValueByNr(i));\n+        }\n+        startAutomaticUpdate();\n+    }\n+\n+    public void stop() {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+        }\n+        ScheduledFuture<?> updateJob = this.updateJob;\n+        if (updateJob != null) {\n+            updateJob.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {", "originalCommit": "10373f36be67c9514348b055fc7b91ff4a314eb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzIyMDA2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583220062", "bodyText": "I don't think so, as there is no polling mechanism on the VBUS, we have to wait until the packets are transmitted the next time.", "author": "ramack", "createdAt": "2021-02-25T21:38:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA5MDA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzA5MDk4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r583090982", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        ResolBridgeHandler handler = new ResolBridgeHandler((Bridge) thing, localeProvider);\n          \n          \n            \n                        return handler;\n          \n          \n            \n                        return new ResolBridgeHandler((Bridge) thing, localeProvider);", "author": "cpmeister", "createdAt": "2021-02-25T19:03:28Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/internal/ResolHandlerFactory.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.internal;\n+\n+import static org.openhab.binding.resol.internal.ResolBindingConstants.SUPPORTED_THING_TYPES_UIDS;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.handler.ResolBridgeHandler;\n+import org.openhab.binding.resol.handler.ResolEmuEMThingHandler;\n+import org.openhab.binding.resol.handler.ResolThingHandler;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link ResolHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.resol\", service = ThingHandlerFactory.class)\n+public class ResolHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final LocaleProvider localeProvider;\n+\n+    private final ResolStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    @Activate\n+    public ResolHandlerFactory(final @Reference ResolStateDescriptionOptionProvider stateDescriptionProvider,\n+            final @Reference LocaleProvider localeProvider) {\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.localeProvider = localeProvider;\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (thingTypeUID.equals(ResolBindingConstants.THING_TYPE_UID_DEVICE)) {\n+            return new ResolThingHandler(thing, stateDescriptionProvider);\n+        }\n+\n+        if (thingTypeUID.equals(ResolBindingConstants.THING_TYPE_UID_EMU_EM)) {\n+            return new ResolEmuEMThingHandler(thing);\n+        }\n+\n+        if (thingTypeUID.equals(ResolBindingConstants.THING_TYPE_UID_BRIDGE)) {\n+            ResolBridgeHandler handler = new ResolBridgeHandler((Bridge) thing, localeProvider);\n+            return handler;", "originalCommit": "10373f36be67c9514348b055fc7b91ff4a314eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "20dad9db5b5f7d0c6b61eca50d9d24b5a0757155", "url": "https://github.com/openhab/openhab-addons/commit/20dad9db5b5f7d0c6b61eca50d9d24b5a0757155", "message": "further rework\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-25T21:41:09Z", "type": "commit"}, {"oid": "811349f225a2305270ff073d2ed4f25faf3d7fa1", "url": "https://github.com/openhab/openhab-addons/commit/811349f225a2305270ff073d2ed4f25faf3d7fa1", "message": "further rework\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-02-27T21:14:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTIxMTYxMg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r585211612", "bodyText": "You should make sure that the quantity channels are using QuantityType instead of DecimalType.", "author": "cpmeister", "createdAt": "2021-03-02T02:59:05Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolThingHandler.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.TimeZone;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolBindingConstants;\n+import org.openhab.binding.resol.internal.ResolStateDescriptionOptionProvider;\n+import org.openhab.binding.resol.internal.providers.ResolChannelTypeProvider;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.Specification.PacketFieldSpec;\n+import de.resol.vbus.Specification.PacketFieldValue;\n+import de.resol.vbus.SpecificationFile;\n+import de.resol.vbus.SpecificationFile.Enum;\n+import de.resol.vbus.SpecificationFile.EnumVariant;\n+import de.resol.vbus.SpecificationFile.Language;\n+\n+/**\n+ * The {@link ResolThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolThingHandler extends ResolBaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolThingHandler.class);\n+\n+    private ResolStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(\n+            DateTimeType.DATE_PATTERN_WITH_TZ_AND_MS_GENERAL);\n+\n+    static {\n+        synchronized (DATE_FORMAT) {\n+            DATE_FORMAT.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+        }\n+    }\n+\n+    public ResolThingHandler(Thing thing, ResolStateDescriptionOptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        /* we ignore the commands for now on purpose */\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolBridgeHandler bridgeHandler = getBridgeHandler();\n+        if (bridgeHandler != null) {\n+            updateStatus(bridgeHandler.getStatus());\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for device.\");\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    protected void setChannelValue(String channelId, String value) {\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            logger.warn(\"Channel '{}:{}' not implemented\", getThing().getUID().getId(), channelId);\n+        } else if (!\"String\".contentEquals(Objects.requireNonNullElse(channel.getAcceptedItemType(), \"\"))) {\n+            logger.trace(\"Channel '{}:{}' expected to have a String type for parameters '{}'\",\n+                    getThing().getUID().getId(), channelId, value.toString());\n+        } else {\n+            this.updateState(channelId, new StringType(value));\n+        }\n+    }\n+\n+    protected void setChannelValue(String channelId, long value) {\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            logger.warn(\"Channel '{}:{}' not implemented\", getThing().getUID().getId(), channelId);\n+        } else if (!\"Number\".contentEquals(Objects.requireNonNullElse(channel.getAcceptedItemType(), \"\"))) {\n+            logger.trace(\"Channel '{}:{}' expected to have a String type for parameters '{}'\",\n+                    getThing().getUID().getId(), channelId, value);\n+        } else {\n+            this.updateState(channelId, new StringType(Long.toString(value)));\n+        }\n+    }\n+\n+    protected void setChannelValue(String channelId, Date value) {\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            logger.warn(\"Channel '{}:{}' not implemented\", getThing().getUID().getId(), channelId);\n+        } else if (!\"DateTime\".equals(channel.getAcceptedItemType())) {\n+            logger.trace(\"Channel '{}:{}' expected to have a DateTime type for parameters '{}'\",\n+                    getThing().getUID().getId(), channelId, value.toString());\n+        } else {\n+            synchronized (DATE_FORMAT) {\n+                this.updateState(channelId, new DateTimeType(DATE_FORMAT.format(value)));\n+            }\n+        }\n+    }\n+\n+    protected void setChannelValue(String channelId, double value) {\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            logger.warn(\"Channel '{}:{}' not implemented\", getThing().getUID().getId(), channelId);\n+            return;\n+        }\n+\n+        String itmType = channel.getAcceptedItemType();\n+        if (itmType != null && itmType.startsWith(\"Number\")) {\n+            this.updateState(channelId, new DecimalType(value));", "originalCommit": "811349f225a2305270ff073d2ed4f25faf3d7fa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTIxMjMzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r585212335", "bodyText": "You should be using QuantityType here.", "author": "cpmeister", "createdAt": "2021-03-02T03:01:16Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends ResolBaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay_\";\n+    public static final String CHANNEL_TEMP = \"temperature_\";\n+    public static final String CHANNEL_RESIST = \"resistor_\";\n+    public static final String CHANNEL_SWITCH = \"switch_\";\n+    public static final String CHANNEL_TEMP_ADJUST = \"bas_temp_adjust_\";\n+    public static final String CHANNEL_MODE = \"bas_mode_\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+    private int deviceId = 1;\n+    private @Nullable EmDeviceEmulator device;\n+\n+    private @Nullable ResolBridgeHandler bridgeHandler;\n+\n+    private static class BasSetting {\n+        float temperatureOffset = 0.0f;\n+        int mode = 4;\n+    }\n+\n+    private BasSetting[] basValues = { new BasSetting(), new BasSetting(), new BasSetting(), new BasSetting(),\n+            new BasSetting(), new BasSetting() };\n+    private long lastTime = System.currentTimeMillis();\n+\n+    // Background Runnable\n+    private @Nullable ScheduledFuture<?> updateJob;\n+\n+    public ResolEmuEMThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolEmuEMConfiguration configuration = getConfigAs(ResolEmuEMConfiguration.class);\n+        deviceId = configuration.deviceId;\n+        vbusAddress = 0x6650 + deviceId;\n+\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        EmDeviceEmulator dev = device;\n+        ScheduledFuture<?> job = updateJob;\n+        if (job != null) {\n+            job.cancel(true);\n+        }\n+        if (dev != null) {\n+            dev.stop();\n+            dev.removePropertyChangeListener(this);\n+        }\n+    }\n+\n+    private void updateRunnable() {\n+        EmDeviceEmulator d = device;\n+        if (d != null) {\n+            long now = System.currentTimeMillis();\n+            int diff = (int) (now - lastTime);\n+            lastTime = now;\n+\n+            d.update(diff);\n+        }\n+    }\n+\n+    private void startAutomaticUpdate() {\n+        ScheduledFuture<?> job = updateJob;\n+        if (job == null || job.isCancelled()) {\n+            updateJob = scheduler.scheduleWithFixedDelay(this::updateRunnable, 0, 1, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for thing {}.\", thing.getThingTypeUID());\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    private void registerResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.registerResolThingListener(this);\n+        } else {\n+            logger.debug(\"Can't register {} at bridge as bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    public int getVbusAddress() {\n+        return vbusAddress;\n+    }\n+\n+    public void useConnection(Connection connection) {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+            device.removePropertyChangeListener(this);\n+        }\n+        device = new EmDeviceEmulator(connection, deviceId);\n+        this.device = device;\n+        device.addPropertyChangeListener(this);\n+        device.start();\n+        for (int i = 1; i <= 5; i++) {\n+            setRelayChannelValue(i, device.getRelayValueByNr(i));\n+        }\n+        startAutomaticUpdate();\n+    }\n+\n+    public void stop() {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+        }\n+        ScheduledFuture<?> updateJob = this.updateJob;\n+        if (updateJob != null) {\n+            updateJob.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String chID = channelUID.getId();\n+        int channel = chID.charAt(chID.length() - 1) - '0';\n+        float value = 0;\n+        int intValue = 0;\n+\n+        if (command instanceof QuantityType<?>) {\n+            value = Objects.requireNonNullElse(((QuantityType<?>) command).toUnit(SIUnits.CELSIUS),\n+                    new QuantityType<>(888.8, SIUnits.CELSIUS)).floatValue();\n+        } else if (command instanceof OnOffType) {\n+            intValue = ((OnOffType) command).equals(OnOffType.ON) ? 1 : 0;\n+        } else if (command instanceof DecimalType) {\n+            intValue = ((DecimalType) command).intValue();\n+            value = intValue;\n+        } else {\n+            /* nothing to do */\n+            return;\n+        }\n+\n+        EmDeviceEmulator dev = device;\n+        if (dev != null) {\n+            if (chID.startsWith(CHANNEL_TEMP)) {\n+                dev.setResistorValueByNrAndPt1000Temperatur(channel, value);\n+                updateState(channelUID, new DecimalType(value));", "originalCommit": "811349f225a2305270ff073d2ed4f25faf3d7fa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTIxMjc0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9449#discussion_r585212742", "bodyText": "and here", "author": "cpmeister", "createdAt": "2021-03-02T03:02:31Z", "path": "bundles/org.openhab.binding.resol/src/main/java/org/openhab/binding/resol/handler/ResolEmuEMThingHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.resol.handler;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.resol.internal.ResolEmuEMConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import de.resol.vbus.Connection;\n+import de.resol.vbus.Connection.ConnectionState;\n+import de.resol.vbus.Packet;\n+import de.resol.vbus.Specification;\n+import de.resol.vbus.SpecificationFile.Language;\n+import de.resol.vbus.deviceemulators.EmDeviceEmulator;\n+\n+/**\n+ * The {@link ResolEmuEMThingHandler} is responsible for emulating a EM device\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ResolEmuEMThingHandler extends ResolBaseThingHandler implements PropertyChangeListener {\n+    public static final String CHANNEL_RELAY = \"relay_\";\n+    public static final String CHANNEL_TEMP = \"temperature_\";\n+    public static final String CHANNEL_RESIST = \"resistor_\";\n+    public static final String CHANNEL_SWITCH = \"switch_\";\n+    public static final String CHANNEL_TEMP_ADJUST = \"bas_temp_adjust_\";\n+    public static final String CHANNEL_MODE = \"bas_mode_\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ResolEmuEMThingHandler.class);\n+\n+    private int vbusAddress = 0x6650;\n+    private int deviceId = 1;\n+    private @Nullable EmDeviceEmulator device;\n+\n+    private @Nullable ResolBridgeHandler bridgeHandler;\n+\n+    private static class BasSetting {\n+        float temperatureOffset = 0.0f;\n+        int mode = 4;\n+    }\n+\n+    private BasSetting[] basValues = { new BasSetting(), new BasSetting(), new BasSetting(), new BasSetting(),\n+            new BasSetting(), new BasSetting() };\n+    private long lastTime = System.currentTimeMillis();\n+\n+    // Background Runnable\n+    private @Nullable ScheduledFuture<?> updateJob;\n+\n+    public ResolEmuEMThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ResolEmuEMConfiguration configuration = getConfigAs(ResolEmuEMConfiguration.class);\n+        deviceId = configuration.deviceId;\n+        vbusAddress = 0x6650 + deviceId;\n+\n+        bridgeHandler = getBridgeHandler();\n+        registerResolThingListener(bridgeHandler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        EmDeviceEmulator dev = device;\n+        ScheduledFuture<?> job = updateJob;\n+        if (job != null) {\n+            job.cancel(true);\n+        }\n+        if (dev != null) {\n+            dev.stop();\n+            dev.removePropertyChangeListener(this);\n+        }\n+    }\n+\n+    private void updateRunnable() {\n+        EmDeviceEmulator d = device;\n+        if (d != null) {\n+            long now = System.currentTimeMillis();\n+            int diff = (int) (now - lastTime);\n+            lastTime = now;\n+\n+            d.update(diff);\n+        }\n+    }\n+\n+    private void startAutomaticUpdate() {\n+        ScheduledFuture<?> job = updateJob;\n+        if (job == null || job.isCancelled()) {\n+            updateJob = scheduler.scheduleWithFixedDelay(this::updateRunnable, 0, 1, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Required bridge not defined for thing {}.\", thing.getThingTypeUID());\n+            return null;\n+        } else {\n+            return getBridgeHandler(bridge);\n+        }\n+    }\n+\n+    private synchronized @Nullable ResolBridgeHandler getBridgeHandler(Bridge bridge) {\n+        ResolBridgeHandler bridgeHandler = null;\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler instanceof ResolBridgeHandler) {\n+            bridgeHandler = (ResolBridgeHandler) handler;\n+        } else {\n+            logger.debug(\"No available bridge handler found yet. Bridge: {} .\", bridge.getUID());\n+        }\n+        return bridgeHandler;\n+    }\n+\n+    private void registerResolThingListener(@Nullable ResolBridgeHandler bridgeHandler) {\n+        if (bridgeHandler != null) {\n+            bridgeHandler.registerResolThingListener(this);\n+        } else {\n+            logger.debug(\"Can't register {} at bridge as bridgeHandler is null.\", this.getThing().getUID());\n+        }\n+    }\n+\n+    public int getVbusAddress() {\n+        return vbusAddress;\n+    }\n+\n+    public void useConnection(Connection connection) {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+            device.removePropertyChangeListener(this);\n+        }\n+        device = new EmDeviceEmulator(connection, deviceId);\n+        this.device = device;\n+        device.addPropertyChangeListener(this);\n+        device.start();\n+        for (int i = 1; i <= 5; i++) {\n+            setRelayChannelValue(i, device.getRelayValueByNr(i));\n+        }\n+        startAutomaticUpdate();\n+    }\n+\n+    public void stop() {\n+        EmDeviceEmulator device = this.device;\n+        if (device != null) {\n+            device.stop();\n+        }\n+        ScheduledFuture<?> updateJob = this.updateJob;\n+        if (updateJob != null) {\n+            updateJob.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String chID = channelUID.getId();\n+        int channel = chID.charAt(chID.length() - 1) - '0';\n+        float value = 0;\n+        int intValue = 0;\n+\n+        if (command instanceof QuantityType<?>) {\n+            value = Objects.requireNonNullElse(((QuantityType<?>) command).toUnit(SIUnits.CELSIUS),\n+                    new QuantityType<>(888.8, SIUnits.CELSIUS)).floatValue();\n+        } else if (command instanceof OnOffType) {\n+            intValue = ((OnOffType) command).equals(OnOffType.ON) ? 1 : 0;\n+        } else if (command instanceof DecimalType) {\n+            intValue = ((DecimalType) command).intValue();\n+            value = intValue;\n+        } else {\n+            /* nothing to do */\n+            return;\n+        }\n+\n+        EmDeviceEmulator dev = device;\n+        if (dev != null) {\n+            if (chID.startsWith(CHANNEL_TEMP)) {\n+                dev.setResistorValueByNrAndPt1000Temperatur(channel, value);\n+                updateState(channelUID, new DecimalType(value));\n+            } else if (chID.startsWith(CHANNEL_SWITCH)) {\n+                if (intValue == 0) {\n+                    /* switch is open => 1 megaohm */\n+                    dev.setResistorValueByNr(channel, 1000000000);\n+                    updateState(channelUID, OnOffType.OFF);\n+                } else {\n+                    /* switch is closed */\n+                    dev.setResistorValueByNr(channel, 0);\n+                    updateState(channelUID, OnOffType.ON);\n+                }\n+            } else if (chID.startsWith(CHANNEL_RESIST)) {\n+                dev.setResistorValueByNr(channel, (int) (value * 1000.0));\n+                updateState(channelUID, new QuantityType<>(intValue, Units.OHM));\n+            } else if (chID.startsWith(CHANNEL_TEMP_ADJUST)) {\n+                basValues[channel - 1].temperatureOffset = value;\n+                updateBas(channel);\n+                updateState(channelUID, new DecimalType(value));", "originalCommit": "811349f225a2305270ff073d2ed4f25faf3d7fa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1afec52f316203b281ecf811c622c12646fd729a", "url": "https://github.com/openhab/openhab-addons/commit/1afec52f316203b281ecf811c622c12646fd729a", "message": "remove warnings\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-03-18T22:20:55Z", "type": "forcePushed"}, {"oid": "bcfff1edd846e8ac5b4be48d276da663ed2ae821", "url": "https://github.com/openhab/openhab-addons/commit/bcfff1edd846e8ac5b4be48d276da663ed2ae821", "message": "use UoM\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-03-18T22:25:59Z", "type": "commit"}, {"oid": "bcfff1edd846e8ac5b4be48d276da663ed2ae821", "url": "https://github.com/openhab/openhab-addons/commit/bcfff1edd846e8ac5b4be48d276da663ed2ae821", "message": "use UoM\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2021-03-18T22:25:59Z", "type": "forcePushed"}]}