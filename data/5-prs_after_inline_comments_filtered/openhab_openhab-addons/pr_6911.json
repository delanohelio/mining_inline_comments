{"pr_number": 6911, "pr_title": "[insteon] initial commit of insteon binding (#2982)", "pr_createdAt": "2020-01-26T23:19:58Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/6911", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwMDYyNw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371100627", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        pollingJob = scheduler.scheduleWithFixedDelay(new Runnable() {\n          \n          \n            \n                            @Override\n          \n          \n            \n                            public void run() {\n          \n          \n            \n                                insteonBinding.logDeviceStatistics();\n          \n          \n            \n                            }\n          \n          \n            \n                        }, 0, insteonBinding.getDeviceStatisticsInterval(), TimeUnit.SECONDS);\n          \n          \n            \n                        pollingJob = scheduler.scheduleWithFixedDelay(insteonBinding::logDeviceStatistics,\n          \n          \n            \n                            0, insteonBinding.getDeviceStatisticsInterval(), TimeUnit.SECONDS);", "author": "Hilbrand", "createdAt": "2020-01-27T08:02:45Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonNetworkHandler.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.discovery.InsteonDeviceDiscoveryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonNetworkHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InsteonNetworkHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonNetworkHandler.class);\n+\n+    private @Nullable InsteonNetworkConfiguration config;\n+    private @Nullable InsteonBinding insteonBinding;\n+    private @Nullable InsteonDeviceDiscoveryService insteonDeviceDiscoveryService;\n+    private @Nullable ScheduledFuture<?> pollingJob = null;\n+\n+    public static ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+\n+    public InsteonNetworkHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Starting Insteon bridge\");\n+        config = getConfigAs(InsteonNetworkConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            insteonBinding = new InsteonBinding(this, config.getPort(), config.getDeviceStatisticsInterval(),\n+                    config.getDeviceDeadCount(), config.getDevicePollInterval(), config.getAdditionalDevices(),\n+                    config.getAdditionalFeatures(), config.getModemDbRetryTimeout());\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (!insteonBinding.startPollingWhenReady()) {\n+                String msg = \"Initialization failed, unable to start the Insteon bridge with the port '\"\n+                        + config.getPort() + \"'.\";\n+                logger.error(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            pollingJob = scheduler.scheduleWithFixedDelay(new Runnable() {\n+                @Override\n+                public void run() {\n+                    insteonBinding.logDeviceStatistics();\n+                }\n+            }, 0, insteonBinding.getDeviceStatisticsInterval(), TimeUnit.SECONDS);", "originalCommit": "d8407f4d3e56f93dadba66a086ab0d3e70ef5b95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2NzE3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371567179", "bodyText": "I coded this a bit differently, hopefully it's OK.", "author": "robnielsen", "createdAt": "2020-01-28T01:09:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwMDYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwMTA2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371101065", "bodyText": "There is a lot of logging to error in the code. Logging to error should only be done if it's a fatal bug. For example here it should log to debug as already the status is set. Can you check all loggings and change it to the appropriate level. See also https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "Hilbrand", "createdAt": "2020-01-27T08:04:19Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonNetworkHandler.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.discovery.InsteonDeviceDiscoveryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonNetworkHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InsteonNetworkHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonNetworkHandler.class);\n+\n+    private @Nullable InsteonNetworkConfiguration config;\n+    private @Nullable InsteonBinding insteonBinding;\n+    private @Nullable InsteonDeviceDiscoveryService insteonDeviceDiscoveryService;\n+    private @Nullable ScheduledFuture<?> pollingJob = null;\n+\n+    public static ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+\n+    public InsteonNetworkHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Starting Insteon bridge\");\n+        config = getConfigAs(InsteonNetworkConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            insteonBinding = new InsteonBinding(this, config.getPort(), config.getDeviceStatisticsInterval(),\n+                    config.getDeviceDeadCount(), config.getDevicePollInterval(), config.getAdditionalDevices(),\n+                    config.getAdditionalFeatures(), config.getModemDbRetryTimeout());\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (!insteonBinding.startPollingWhenReady()) {\n+                String msg = \"Initialization failed, unable to start the Insteon bridge with the port '\"\n+                        + config.getPort() + \"'.\";\n+                logger.error(msg);", "originalCommit": "d8407f4d3e56f93dadba66a086ab0d3e70ef5b95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI2ODM4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371268387", "bodyText": "logger.error has been changed to logger.warning", "author": "robnielsen", "createdAt": "2020-01-27T14:25:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwMTA2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwMTUzNg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371101536", "bodyText": "This sleep is really bad. The scheduled threads of all bindings use a shared thread pool. If you sleep for 5 seconds it means you block a thread to be used by other bindings for 5 seconds. You should reschedule here to start after 5 seconds.", "author": "Hilbrand", "createdAt": "2020-01-27T08:05:53Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,517 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<String, org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollInterval = 300000; // in milliseconds\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_deviceStatisticsInterval = 600; // in seconds\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, String port, @Nullable Integer deviceStatisticsInterval,\n+            @Nullable Integer deviceDeadCount, @Nullable Integer devicePollInterval, @Nullable String additionalDevices,\n+            @Nullable String additionalFeatures, @Nullable Integer modemDbRetryTimeout) {\n+\n+        this.m_handler = handler;\n+\n+        if (deviceStatisticsInterval != null) {\n+            m_deviceStatisticsInterval = deviceStatisticsInterval;\n+            logger.info(\"device statistics interval set to {} seconds\", m_deviceStatisticsInterval);\n+        }\n+\n+        int deadDeviceCount = 10;\n+        if (deviceDeadCount != null) {\n+            deadDeviceCount = deviceDeadCount;\n+            logger.info(\"device dead co- Initial contributionunt set to {}\", deadDeviceCount);\n+        }\n+\n+        if (devicePollInterval != null) {\n+            m_devicePollInterval = devicePollInterval;\n+            logger.info(\"device poll interval set to {} milliseconds\", m_devicePollInterval);\n+        }\n+\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (Exception e) {\n+                logger.error(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        if (additionalFeatures != null) {\n+            logger.info(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.s_readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        if (modemDbRetryTimeout != null) {\n+            int timeout = modemDbRetryTimeout;\n+            m_driver.setModemDBRetryTimeout(timeout * 1000);\n+            logger.info(\"setting modem db retry timeout to {} seconds\", timeout);\n+        }\n+\n+        m_deadDeviceTimeout = m_devicePollInterval * deadDeviceCount;\n+        logger.info(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);\n+\n+        logger.info(\"port = '{}'\", port);\n+        m_driver.addPort(\"port\", port);\n+        m_driver.addMsgListener(m_portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        m_driver.setDriverListener(m_portListener);\n+    }\n+\n+    public boolean startPollingWhenReady() {\n+        // hold off on starting to poll until devices have been added From the Things file\n+        int settleTime = 5000;\n+        for (int i = -1; i != m_devices.size(); i = m_devices.size()) {\n+            try {\n+                logger.debug(\"sleeping {} milliseconds...\", settleTime);\n+                Thread.sleep(settleTime);", "originalCommit": "d8407f4d3e56f93dadba66a086ab0d3e70ef5b95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI2OTIzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371269239", "bodyText": "The code has been refactored to remove Thread.sleep.", "author": "robnielsen", "createdAt": "2020-01-27T14:27:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwMTUzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwMjA5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371102096", "bodyText": "Put the unit in the name of the variable to make it clear in the rest of the cod how it should be handled.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private int m_devicePollInterval = 300000; // in milliseconds\n          \n          \n            \n                private int devicePollIntervalMilliseconds = 300000; // in milliseconds", "author": "Hilbrand", "createdAt": "2020-01-27T08:07:40Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,517 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<String, org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollInterval = 300000; // in milliseconds", "originalCommit": "d8407f4d3e56f93dadba66a086ab0d3e70ef5b95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI2MTkyMw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371261923", "bodyText": "This has been changed.", "author": "robnielsen", "createdAt": "2020-01-27T14:14:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwMjA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwMzk3NA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371103974", "bodyText": "If the timeout is used in seconds it might as well be set in seconds instead of milliseconds?", "author": "Hilbrand", "createdAt": "2020-01-27T08:13:33Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,517 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<String, org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollInterval = 300000; // in milliseconds\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_deviceStatisticsInterval = 600; // in seconds\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, String port, @Nullable Integer deviceStatisticsInterval,\n+            @Nullable Integer deviceDeadCount, @Nullable Integer devicePollInterval, @Nullable String additionalDevices,\n+            @Nullable String additionalFeatures, @Nullable Integer modemDbRetryTimeout) {\n+\n+        this.m_handler = handler;\n+\n+        if (deviceStatisticsInterval != null) {\n+            m_deviceStatisticsInterval = deviceStatisticsInterval;\n+            logger.info(\"device statistics interval set to {} seconds\", m_deviceStatisticsInterval);\n+        }\n+\n+        int deadDeviceCount = 10;\n+        if (deviceDeadCount != null) {\n+            deadDeviceCount = deviceDeadCount;\n+            logger.info(\"device dead co- Initial contributionunt set to {}\", deadDeviceCount);\n+        }\n+\n+        if (devicePollInterval != null) {\n+            m_devicePollInterval = devicePollInterval;\n+            logger.info(\"device poll interval set to {} milliseconds\", m_devicePollInterval);\n+        }\n+\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (Exception e) {\n+                logger.error(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        if (additionalFeatures != null) {\n+            logger.info(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.s_readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        if (modemDbRetryTimeout != null) {\n+            int timeout = modemDbRetryTimeout;\n+            m_driver.setModemDBRetryTimeout(timeout * 1000);", "originalCommit": "d8407f4d3e56f93dadba66a086ab0d3e70ef5b95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1NjIwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371256209", "bodyText": "This was removed since it was a undocumented configuration from the old binding.", "author": "robnielsen", "createdAt": "2020-01-27T14:03:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwMzk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwNDE3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371104172", "bodyText": "A general comment. A lot of fields use the convention <character>_. This is not very common.", "author": "Hilbrand", "createdAt": "2020-01-27T08:14:14Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,517 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();", "originalCommit": "d8407f4d3e56f93dadba66a086ab0d3e70ef5b95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1ODQ4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371258487", "bodyText": "Yes I agree. That is the convention that the original developers used, m_ indicates member.", "author": "robnielsen", "createdAt": "2020-01-27T14:08:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwNDE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMxMjk3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390312972", "bodyText": "<character>_ has been refactored and doesn't exist anymore", "author": "robnielsen", "createdAt": "2020-03-10T13:31:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwNDE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwNDQ2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371104466", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private ConcurrentHashMap<String, org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<String, org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration>();\n          \n          \n            \n                private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs\n          \n          \n            \n                     = new ConcurrentHashMap<>();", "author": "Hilbrand", "createdAt": "2020-01-27T08:15:11Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,517 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<String, org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration>();", "originalCommit": "d8407f4d3e56f93dadba66a086ab0d3e70ef5b95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMxNTYwOA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390315608", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-10T13:35:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwNDQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI5Nzc2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371297765", "bodyText": "Accidental global replace error?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.info(\"device dead co- Initial contributionunt set to {}\", deadDeviceCount);\n          \n          \n            \n                        logger.info(\"device dead count set to {}\", deadDeviceCount);", "author": "Hilbrand", "createdAt": "2020-01-27T15:13:57Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs\n+         = new ConcurrentHashMap<>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollInterval = 300000; // in milliseconds\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_deviceStatisticsInterval = 600; // in seconds\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, String port, @Nullable Integer deviceStatisticsInterval,\n+            @Nullable Integer deviceDeadCount, @Nullable Integer devicePollInterval, @Nullable String additionalDevices,\n+            @Nullable String additionalFeatures, @Nullable Integer modemDbRetryTimeout) {\n+\n+        this.m_handler = handler;\n+\n+        if (deviceStatisticsInterval != null) {\n+            m_deviceStatisticsInterval = deviceStatisticsInterval;\n+            logger.info(\"device statistics interval set to {} seconds\", m_deviceStatisticsInterval);\n+        }\n+\n+        int deadDeviceCount = 10;\n+        if (deviceDeadCount != null) {\n+            deadDeviceCount = deviceDeadCount;\n+            logger.info(\"device dead co- Initial contributionunt set to {}\", deadDeviceCount);", "originalCommit": "7c41f7e5886c00f3db03596111e39057f9b8c467", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMxNjYxMw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390316613", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-10T13:36:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI5Nzc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI5ODk1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371298956", "bodyText": "Does this throw a generic Exception or can it be the specific checked exception or RuntimeException?", "author": "Hilbrand", "createdAt": "2020-01-27T15:15:49Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs\n+         = new ConcurrentHashMap<>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollInterval = 300000; // in milliseconds\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_deviceStatisticsInterval = 600; // in seconds\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, String port, @Nullable Integer deviceStatisticsInterval,\n+            @Nullable Integer deviceDeadCount, @Nullable Integer devicePollInterval, @Nullable String additionalDevices,\n+            @Nullable String additionalFeatures, @Nullable Integer modemDbRetryTimeout) {\n+\n+        this.m_handler = handler;\n+\n+        if (deviceStatisticsInterval != null) {\n+            m_deviceStatisticsInterval = deviceStatisticsInterval;\n+            logger.info(\"device statistics interval set to {} seconds\", m_deviceStatisticsInterval);\n+        }\n+\n+        int deadDeviceCount = 10;\n+        if (deviceDeadCount != null) {\n+            deadDeviceCount = deviceDeadCount;\n+            logger.info(\"device dead co- Initial contributionunt set to {}\", deadDeviceCount);\n+        }\n+\n+        if (devicePollInterval != null) {\n+            m_devicePollInterval = devicePollInterval;\n+            logger.info(\"device poll interval set to {} milliseconds\", m_devicePollInterval);\n+        }\n+\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (Exception e) {", "originalCommit": "7c41f7e5886c00f3db03596111e39057f9b8c467", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMxMTExNA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371311114", "bodyText": "Fixed to use specific checked exceptions", "author": "robnielsen", "createdAt": "2020-01-27T15:35:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI5ODk1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwMTQ4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386701483", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(GroupMessageStateMachine.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(GroupMessageStateMachine.class);", "author": "cpmeister", "createdAt": "2020-03-02T22:56:10Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/GroupMessageStateMachine.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Ideally, Insteon ALL LINK messages are received in this order, and\n+ * only a single one of each:\n+ *\n+ * BCAST (a broadcast message from the device to all group members)\n+ * CLEAN (a cleanup point-to-point message to ensure more reliable transmission)\n+ * SUCCESS (a broadcast report of success or failure of cleanup, with cmd1=0x06)\n+ *\n+ * But often, the BCAST, CLEAN and SUCCESS messages are retransmitted multiple times,\n+ * or (less frequently) messages are lost. The present state machine was developed\n+ * to remove duplicates, yet make sure that a single lost message does not cause\n+ * the binding to miss an update.\n+ *\n+ *\n+ * \"SUCCESS\"\n+ * EXPECT_BCAST\n+ * ^ / ^ \\\n+ * SUCCESS / / \\ \\ [BCAST]\n+ * / /['CLEAN'] 'SUCCESS'\\ \\\n+ * / / \\ \\\n+ * / V CLEAN \\ V\n+ * \"CLEAN\" EXPECT_SUCCESS <-------------- EXPECT_CLEAN \"BCAST\"\n+ * -------------->\n+ * ['BCAST']\n+ *\n+ * How to read this diagram:\n+ *\n+ * Regular, expected, non-duplicate messages do not have any quotes around them,\n+ * and lead to the obvious state transitions.\n+ *\n+ * The actions in [square brackets] are transitions that cause a state\n+ * update to be published when they occur.\n+ *\n+ * The presence of double quotes indicates a duplicate that does not lead\n+ * to any state transitions, i.e. it is simply ignored.\n+ *\n+ * Single quotes indicate a message that is the result of a single dropped\n+ * message, and leads to a state transition, in some cases even to a state\n+ * update to be published.\n+ *\n+ * For instance at the top of the diagram, if a \"SUCCESS\" message is received\n+ * when in state EXPECT_BCAST, it is considered a duplicate (it has \"\").\n+ *\n+ * When in state EXPECT_SUCCESS though, receiving a ['BCAST'] is most likely because\n+ * the SUCCESS message was missed, and therefore it is considered the result\n+ * of a single lost message (has '' around it). The state changes to EXPECT_CLEAN,\n+ * and the message should lead to publishing of a state update (it has [] around it).\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class GroupMessageStateMachine {\n+    private static final Logger logger = LoggerFactory.getLogger(GroupMessageStateMachine.class);", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0MzMzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387043339", "bodyText": "what's wrong with the way it is?", "author": "robnielsen", "createdAt": "2020-03-03T14:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwMTQ4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzODI2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387338267", "bodyText": "changed", "author": "robnielsen", "createdAt": "2020-03-03T22:40:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwMTQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwMjA5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386702096", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(CommandHandler.class);", "author": "cpmeister", "createdAt": "2020-03-02T22:57:41Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/CommandHandler.java", "diffHunk": "@@ -0,0 +1,912 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A command handler translates an openHAB command into a insteon message\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public abstract class CommandHandler {\n+    private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0MzQwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387043405", "bodyText": "what's wrong with the way it is?", "author": "robnielsen", "createdAt": "2020-03-03T14:11:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwMjA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzODQ1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387338459", "bodyText": "This can't be changed since it's used in static methods", "author": "robnielsen", "createdAt": "2020-03-03T22:40:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwMjA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM2MDE3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387360175", "bodyText": "making it protected final should work", "author": "cpmeister", "createdAt": "2020-03-03T23:39:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwMjA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM4OTkwMA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387389900", "bodyText": "It has to remain static it is used in a static method", "author": "robnielsen", "createdAt": "2020-03-04T01:08:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwMjA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNDM5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386704395", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(DeviceFeatureListener.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(DeviceFeatureListener.class);", "author": "cpmeister", "createdAt": "2020-03-02T23:03:08Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceFeatureListener.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A DeviceFeatureListener essentially represents an OpenHAB item that\n+ * listens to a particular feature of an Insteon device\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class DeviceFeatureListener {\n+    private static final Logger logger = LoggerFactory.getLogger(DeviceFeatureListener.class);", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0MzQ0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387043447", "bodyText": "what's wrong with the way it is?", "author": "robnielsen", "createdAt": "2020-03-03T14:11:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNDM5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzODU4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387338583", "bodyText": "changed", "author": "robnielsen", "createdAt": "2020-03-03T22:41:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNDM5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNTAyNg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386705026", "bodyText": "I don't think that synchronized is doing anything useful here.", "author": "cpmeister", "createdAt": "2020-03-02T23:04:56Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceFeature.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils.ParsingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A DeviceFeature represents a certain feature (trait) of a given Insteon device, e.g. something\n+ * operating under a given InsteonAddress that can be manipulated (relay) or read (sensor).\n+ *\n+ * The DeviceFeature does the processing of incoming messages, and handles commands for the\n+ * particular feature it represents.\n+ *\n+ * It uses four mechanisms for that:\n+ *\n+ * 1) MessageDispatcher: makes high level decisions about an incoming message and then runs the\n+ * 2) MessageHandler: further processes the message, updates state etc\n+ * 3) CommandHandler: translates commands from the openhab bus into an Insteon message.\n+ * 4) PollHandler: creates an Insteon message to query the DeviceFeature\n+ *\n+ * Lastly, DeviceFeatureListeners can register with the DeviceFeature to get notifications when\n+ * the state of a feature has changed. In practice, a DeviceFeatureListener corresponds to an\n+ * OpenHAB item.\n+ *\n+ * The character of a DeviceFeature is thus given by a set of message and command handlers.\n+ * A FeatureTemplate captures exactly that: it says what set of handlers make up a DeviceFeature.\n+ *\n+ * DeviceFeatures are added to a new device by referencing a FeatureTemplate (defined in device_features.xml)\n+ * from the Device definition file (device_types.xml).\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class DeviceFeature {\n+    public static enum QueryStatus {\n+        NEVER_QUERIED,\n+        QUERY_PENDING,\n+        QUERY_ANSWERED\n+    }\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DeviceFeature.class);\n+\n+    private static HashMap<String, FeatureTemplate> s_features = new HashMap<String, FeatureTemplate>();\n+\n+    private InsteonDevice m_device = new InsteonDevice();\n+    private String m_name = \"INVALID_FEATURE_NAME\";\n+    private boolean m_isStatus = false;\n+    private int m_directAckTimeout = 6000;\n+    private QueryStatus m_queryStatus = QueryStatus.NEVER_QUERIED;\n+\n+    private @Nullable MessageHandler m_defaultMsgHandler = new MessageHandler.DefaultMsgHandler(this);\n+    private @Nullable CommandHandler m_defaultCommandHandler = new CommandHandler.WarnCommandHandler(this);\n+    private @Nullable PollHandler m_pollHandler = null;\n+    private @Nullable MessageDispatcher m_dispatcher = null;\n+\n+    private HashMap<Integer, @Nullable MessageHandler> m_msgHandlers = new HashMap<Integer, @Nullable MessageHandler>();\n+    private HashMap<Class<? extends Command>, @Nullable CommandHandler> m_commandHandlers = new HashMap<Class<? extends Command>, @Nullable CommandHandler>();\n+    private ArrayList<DeviceFeatureListener> m_listeners = new ArrayList<DeviceFeatureListener>();\n+    private ArrayList<DeviceFeature> m_connectedFeatures = new ArrayList<DeviceFeature>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param device Insteon device to which this feature belongs\n+     * @param name descriptive name for that feature\n+     */\n+    public DeviceFeature(InsteonDevice device, String name) {\n+        m_name = name;\n+        setDevice(device);\n+    }\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param name descriptive name of the feature\n+     */\n+    public DeviceFeature(String name) {\n+        m_name = name;\n+    }\n+\n+    // various simple getters\n+    public String getName() {\n+        return m_name;\n+    }\n+\n+    public synchronized QueryStatus getQueryStatus() {\n+        return m_queryStatus;", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0MjEwMw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387042103", "bodyText": "The getter is also synchronized, this is necessary.", "author": "robnielsen", "createdAt": "2020-03-03T14:09:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNTAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI5ODA4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387298087", "bodyText": "synchronization is only useful when attempting to executing multiple statements of code in an atomic fashion. The code above is already atomic just by virtue of it being a return statement without an any addition logic.\nA proper way to handle this would be to make m_queryStatus volatile and remove synchronized from the getter and setter.", "author": "cpmeister", "createdAt": "2020-03-03T21:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNTAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzODAzMg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387338032", "bodyText": "I'm going to leave this as it. I has been this way forever.", "author": "robnielsen", "createdAt": "2020-03-03T22:39:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNTAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM0NjE3OA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387346178", "bodyText": "That is fine, it is harmless the way it is.", "author": "cpmeister", "createdAt": "2020-03-03T22:58:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNTAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNTUzMw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386705533", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(DeviceFeature.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(DeviceFeature.class);", "author": "cpmeister", "createdAt": "2020-03-02T23:06:16Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceFeature.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils.ParsingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A DeviceFeature represents a certain feature (trait) of a given Insteon device, e.g. something\n+ * operating under a given InsteonAddress that can be manipulated (relay) or read (sensor).\n+ *\n+ * The DeviceFeature does the processing of incoming messages, and handles commands for the\n+ * particular feature it represents.\n+ *\n+ * It uses four mechanisms for that:\n+ *\n+ * 1) MessageDispatcher: makes high level decisions about an incoming message and then runs the\n+ * 2) MessageHandler: further processes the message, updates state etc\n+ * 3) CommandHandler: translates commands from the openhab bus into an Insteon message.\n+ * 4) PollHandler: creates an Insteon message to query the DeviceFeature\n+ *\n+ * Lastly, DeviceFeatureListeners can register with the DeviceFeature to get notifications when\n+ * the state of a feature has changed. In practice, a DeviceFeatureListener corresponds to an\n+ * OpenHAB item.\n+ *\n+ * The character of a DeviceFeature is thus given by a set of message and command handlers.\n+ * A FeatureTemplate captures exactly that: it says what set of handlers make up a DeviceFeature.\n+ *\n+ * DeviceFeatures are added to a new device by referencing a FeatureTemplate (defined in device_features.xml)\n+ * from the Device definition file (device_types.xml).\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class DeviceFeature {\n+    public static enum QueryStatus {\n+        NEVER_QUERIED,\n+        QUERY_PENDING,\n+        QUERY_ANSWERED\n+    }\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DeviceFeature.class);", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0MzUxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387043519", "bodyText": "what's wrong with the way it is?", "author": "robnielsen", "createdAt": "2020-03-03T14:11:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNTUzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE4OTU1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387189556", "bodyText": "OH coding guidelines state that loggers should be non-static", "author": "cpmeister", "createdAt": "2020-03-03T17:49:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNTUzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzODg0MA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387338840", "bodyText": "This can't be changed since it's used in static methods", "author": "robnielsen", "createdAt": "2020-03-03T22:41:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNTUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNzMyOA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386707328", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(DeviceTypeLoader.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(DeviceTypeLoader.class);", "author": "cpmeister", "createdAt": "2020-03-02T23:10:56Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceTypeLoader.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.HashMap;\n+import java.util.Map.Entry;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.DeviceType.FeatureGroup;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * Reads the device types from an xml file.\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class DeviceTypeLoader {\n+    private static final Logger logger = LoggerFactory.getLogger(DeviceTypeLoader.class);", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2MzEzMg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387663132", "bodyText": "This is referenced in static methods, can't change", "author": "robnielsen", "createdAt": "2020-03-04T13:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNzMyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwODEwOA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386708108", "bodyText": "move fields above constructor", "author": "cpmeister", "createdAt": "2020-03-02T23:13:09Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/HandlerEntry.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Ugly little helper class to facilitate late instantiation of handlers\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class HandlerEntry {\n+    HandlerEntry(String name, HashMap<String, @Nullable String> params) {\n+        m_hname = name;\n+        m_params = params;\n+    }\n+\n+    HashMap<String, @Nullable String> m_params;\n+    String m_hname;", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2NDMyMg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387664322", "bodyText": "This passes the code analysis checks leaving as is.", "author": "robnielsen", "createdAt": "2020-03-04T13:26:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwODEwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwODQ4NA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386708484", "bodyText": "Everything in this class is package protected. Why not the class itself?", "author": "cpmeister", "createdAt": "2020-03-02T23:14:15Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/HandlerEntry.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Ugly little helper class to facilitate late instantiation of handlers\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class HandlerEntry {", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY5MTA3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r388691072", "bodyText": "leaving as is", "author": "robnielsen", "createdAt": "2020-03-06T03:02:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwODQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwOTE0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386709142", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch (Exception e) {\n          \n          \n            \n                    } catch (NumberFormatException e) {", "author": "cpmeister", "createdAt": "2020-03-02T23:16:09Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/InsteonAddress.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+\n+/**\n+ * This class wraps an Insteon Address 'xx.xx.xx'\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonAddress {\n+    private byte highByte;\n+    private byte middleByte;\n+    private byte lowByte;\n+    private boolean x10;\n+\n+    public InsteonAddress() {\n+        highByte = 0x00;\n+        middleByte = 0x00;\n+        lowByte = 0x00;\n+        x10 = false;\n+    }\n+\n+    public InsteonAddress(InsteonAddress a) {\n+        highByte = a.highByte;\n+        middleByte = a.middleByte;\n+        lowByte = a.lowByte;\n+        x10 = a.x10;\n+    }\n+\n+    public InsteonAddress(byte high, byte middle, byte low) {\n+        highByte = high;\n+        middleByte = middle;\n+        lowByte = low;\n+        x10 = false;\n+    }\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param address string must have format of e.g. '2a.3c.40' or (for X10) 'H.UU'\n+     */\n+    public InsteonAddress(String address) throws IllegalArgumentException {\n+        if (X10.s_isValidAddress(address)) {\n+            highByte = 0;\n+            middleByte = 0;\n+            lowByte = X10.s_addressToByte(address);\n+            x10 = true;\n+        } else {\n+            String[] parts = address.split(\"\\\\.\");\n+            if (parts.length != 3) {\n+                throw new IllegalArgumentException(\"Address string must have 3 bytes, has: \" + parts.length);\n+            }\n+            highByte = (byte) Utils.fromHexString(parts[0]);\n+            middleByte = (byte) Utils.fromHexString(parts[1]);\n+            lowByte = (byte) Utils.fromHexString(parts[2]);\n+            x10 = false;\n+        }\n+    }\n+\n+    /**\n+     * Constructor for an InsteonAddress that wraps an X10 address.\n+     * Simply stuff the X10 address into the lowest byte.\n+     *\n+     * @param aX10HouseUnit the house & unit number as encoded by the X10 protocol\n+     */\n+    public InsteonAddress(byte aX10HouseUnit) {\n+        highByte = 0;\n+        middleByte = 0;\n+        lowByte = aX10HouseUnit;\n+        x10 = true;\n+    }\n+\n+    public void setHighByte(byte h) {\n+        highByte = h;\n+    }\n+\n+    public void setMiddleByte(byte m) {\n+        middleByte = m;\n+    }\n+\n+    public void setLowByte(byte l) {\n+        lowByte = l;\n+    }\n+\n+    public byte getHighByte() {\n+        return highByte;\n+    }\n+\n+    public byte getMiddleByte() {\n+        return middleByte;\n+    }\n+\n+    public byte getLowByte() {\n+        return lowByte;\n+    }\n+\n+    public byte getX10HouseCode() {\n+        return (byte) ((lowByte & 0xf0) >> 4);\n+    }\n+\n+    public byte getX10UnitCode() {\n+        return (byte) ((lowByte & 0x0f));\n+    }\n+\n+    public boolean isX10() {\n+        return x10;\n+    }\n+\n+    public void storeBytes(byte[] bytes, int offset) {\n+        bytes[offset] = getHighByte();\n+        bytes[offset + 1] = getMiddleByte();\n+        bytes[offset + 2] = getLowByte();\n+    }\n+\n+    public void loadBytes(byte[] bytes, int offset) {\n+        setHighByte(bytes[offset]);\n+        setMiddleByte(bytes[offset + 1]);\n+        setLowByte(bytes[offset + 2]);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String s = null;\n+        if (isX10()) {\n+            byte house = (byte) (((getLowByte() & 0xf0) >> 4) & 0xff);\n+            byte unit = (byte) ((getLowByte() & 0x0f) & 0xff);\n+            s = X10.s_houseToString(house) + \".\" + X10.s_unitToInt(unit);\n+            // s = Utils.getHexString(lowByte);\n+        } else {\n+            s = Utils.getHexString(highByte) + \".\" + Utils.getHexString(middleByte) + \".\" + Utils.getHexString(lowByte);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public boolean equals(@Nullable Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        InsteonAddress other = (InsteonAddress) obj;\n+        if (highByte != other.highByte) {\n+            return false;\n+        }\n+        if (lowByte != other.lowByte) {\n+            return false;\n+        }\n+        if (middleByte != other.middleByte) {\n+            return false;\n+        }\n+        if (x10 != other.x10) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result + highByte;\n+        result = prime * result + lowByte;\n+        result = prime * result + middleByte;\n+        result = prime * result + (x10 ? 1231 : 1237);\n+        return result;\n+    }\n+\n+    /**\n+     * Test if Insteon address is valid\n+     *\n+     * @return true if address is in valid AB.CD.EF or (for X10) H.UU format\n+     */\n+    public static boolean s_isValid(@Nullable String addr) {\n+        if (addr == null) {\n+            return false;\n+        }\n+        if (X10.s_isValidAddress(addr)) {\n+            return true;\n+        }\n+        String[] fields = addr.split(\"\\\\.\");\n+        if (fields.length != 3) {\n+            return false;\n+        }\n+        try {\n+            // convert the insteon xx.xx.xx address to integer to test\n+            @SuppressWarnings(\"unused\")\n+            int test = Integer.parseInt(fields[2], 16) * 65536 + Integer.parseInt(fields[1], 16) * 256\n+                    + +Integer.parseInt(fields[0], 16);\n+        } catch (Exception e) {", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY5MTE0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r388691149", "bodyText": "fixed", "author": "robnielsen", "createdAt": "2020-03-06T03:02:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwOTE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwOTQxNA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386709414", "bodyText": "either put this in a unit test or remove it", "author": "cpmeister", "createdAt": "2020-03-02T23:16:50Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/InsteonAddress.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+\n+/**\n+ * This class wraps an Insteon Address 'xx.xx.xx'\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonAddress {\n+    private byte highByte;\n+    private byte middleByte;\n+    private byte lowByte;\n+    private boolean x10;\n+\n+    public InsteonAddress() {\n+        highByte = 0x00;\n+        middleByte = 0x00;\n+        lowByte = 0x00;\n+        x10 = false;\n+    }\n+\n+    public InsteonAddress(InsteonAddress a) {\n+        highByte = a.highByte;\n+        middleByte = a.middleByte;\n+        lowByte = a.lowByte;\n+        x10 = a.x10;\n+    }\n+\n+    public InsteonAddress(byte high, byte middle, byte low) {\n+        highByte = high;\n+        middleByte = middle;\n+        lowByte = low;\n+        x10 = false;\n+    }\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param address string must have format of e.g. '2a.3c.40' or (for X10) 'H.UU'\n+     */\n+    public InsteonAddress(String address) throws IllegalArgumentException {\n+        if (X10.s_isValidAddress(address)) {\n+            highByte = 0;\n+            middleByte = 0;\n+            lowByte = X10.s_addressToByte(address);\n+            x10 = true;\n+        } else {\n+            String[] parts = address.split(\"\\\\.\");\n+            if (parts.length != 3) {\n+                throw new IllegalArgumentException(\"Address string must have 3 bytes, has: \" + parts.length);\n+            }\n+            highByte = (byte) Utils.fromHexString(parts[0]);\n+            middleByte = (byte) Utils.fromHexString(parts[1]);\n+            lowByte = (byte) Utils.fromHexString(parts[2]);\n+            x10 = false;\n+        }\n+    }\n+\n+    /**\n+     * Constructor for an InsteonAddress that wraps an X10 address.\n+     * Simply stuff the X10 address into the lowest byte.\n+     *\n+     * @param aX10HouseUnit the house & unit number as encoded by the X10 protocol\n+     */\n+    public InsteonAddress(byte aX10HouseUnit) {\n+        highByte = 0;\n+        middleByte = 0;\n+        lowByte = aX10HouseUnit;\n+        x10 = true;\n+    }\n+\n+    public void setHighByte(byte h) {\n+        highByte = h;\n+    }\n+\n+    public void setMiddleByte(byte m) {\n+        middleByte = m;\n+    }\n+\n+    public void setLowByte(byte l) {\n+        lowByte = l;\n+    }\n+\n+    public byte getHighByte() {\n+        return highByte;\n+    }\n+\n+    public byte getMiddleByte() {\n+        return middleByte;\n+    }\n+\n+    public byte getLowByte() {\n+        return lowByte;\n+    }\n+\n+    public byte getX10HouseCode() {\n+        return (byte) ((lowByte & 0xf0) >> 4);\n+    }\n+\n+    public byte getX10UnitCode() {\n+        return (byte) ((lowByte & 0x0f));\n+    }\n+\n+    public boolean isX10() {\n+        return x10;\n+    }\n+\n+    public void storeBytes(byte[] bytes, int offset) {\n+        bytes[offset] = getHighByte();\n+        bytes[offset + 1] = getMiddleByte();\n+        bytes[offset + 2] = getLowByte();\n+    }\n+\n+    public void loadBytes(byte[] bytes, int offset) {\n+        setHighByte(bytes[offset]);\n+        setMiddleByte(bytes[offset + 1]);\n+        setLowByte(bytes[offset + 2]);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String s = null;\n+        if (isX10()) {\n+            byte house = (byte) (((getLowByte() & 0xf0) >> 4) & 0xff);\n+            byte unit = (byte) ((getLowByte() & 0x0f) & 0xff);\n+            s = X10.s_houseToString(house) + \".\" + X10.s_unitToInt(unit);\n+            // s = Utils.getHexString(lowByte);\n+        } else {\n+            s = Utils.getHexString(highByte) + \".\" + Utils.getHexString(middleByte) + \".\" + Utils.getHexString(lowByte);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public boolean equals(@Nullable Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        InsteonAddress other = (InsteonAddress) obj;\n+        if (highByte != other.highByte) {\n+            return false;\n+        }\n+        if (lowByte != other.lowByte) {\n+            return false;\n+        }\n+        if (middleByte != other.middleByte) {\n+            return false;\n+        }\n+        if (x10 != other.x10) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result + highByte;\n+        result = prime * result + lowByte;\n+        result = prime * result + middleByte;\n+        result = prime * result + (x10 ? 1231 : 1237);\n+        return result;\n+    }\n+\n+    /**\n+     * Test if Insteon address is valid\n+     *\n+     * @return true if address is in valid AB.CD.EF or (for X10) H.UU format\n+     */\n+    public static boolean s_isValid(@Nullable String addr) {\n+        if (addr == null) {\n+            return false;\n+        }\n+        if (X10.s_isValidAddress(addr)) {\n+            return true;\n+        }\n+        String[] fields = addr.split(\"\\\\.\");\n+        if (fields.length != 3) {\n+            return false;\n+        }\n+        try {\n+            // convert the insteon xx.xx.xx address to integer to test\n+            @SuppressWarnings(\"unused\")\n+            int test = Integer.parseInt(fields[2], 16) * 65536 + Integer.parseInt(fields[1], 16) * 256\n+                    + +Integer.parseInt(fields[0], 16);\n+        } catch (Exception e) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Turn string into address\n+     *\n+     * @param val the string to convert\n+     * @return the corresponding insteon address\n+     */\n+    public static InsteonAddress s_parseAddress(String val) {\n+        return new InsteonAddress(val);\n+    }\n+\n+    // /**\n+    // * Function for unit testing\n+    // *\n+    // * @param args ignored\n+    // */\n+    // public static void main(String[] args) {\n+    // // debug/test code\n+    // InsteonAddress a1 = new InsteonAddress();\n+    // InsteonAddress a2 = new InsteonAddress();\n+    // System.out.println(a1.equals(a2));\n+    // System.out.println(new InsteonAddress(\"0f.0f.0a\"));\n+    // }", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2NDY0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387664645", "bodyText": "Doesn't hurt anything, I'm leaving it.", "author": "robnielsen", "createdAt": "2020-03-04T13:27:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwOTQxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMxODA0NA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390318044", "bodyText": "this was removed", "author": "robnielsen", "createdAt": "2020-03-10T13:38:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwOTQxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwOTUxMg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386709512", "bodyText": "either put this in a unit test or remove it", "author": "cpmeister", "createdAt": "2020-03-02T23:17:09Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/FeatureTemplateLoader.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.openhab.binding.insteon.internal.utils.Utils.ParsingException;\n+import org.w3c.dom.DOMException;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.NamedNodeMap;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * Class that loads the device feature templates from an xml stream\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class FeatureTemplateLoader {\n+    public static ArrayList<FeatureTemplate> s_readTemplates(InputStream input) throws IOException, ParsingException {\n+        ArrayList<FeatureTemplate> features = new ArrayList<FeatureTemplate>();\n+        try {\n+            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n+            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n+            // Parse it!\n+            Document doc = dBuilder.parse(input);\n+            doc.getDocumentElement().normalize();\n+\n+            Element root = doc.getDocumentElement();\n+\n+            NodeList nodes = root.getChildNodes();\n+\n+            for (int i = 0; i < nodes.getLength(); i++) {\n+                Node node = nodes.item(i);\n+                if (node.getNodeType() == Node.ELEMENT_NODE) {\n+                    Element e = (Element) node;\n+                    if (e.getTagName().equals(\"feature\")) {\n+                        features.add(s_parseFeature(e));\n+                    }\n+                }\n+            }\n+        } catch (SAXException e) {\n+            throw new ParsingException(\"Failed to parse XML!\", e);\n+        } catch (ParserConfigurationException e) {\n+            throw new ParsingException(\"Got parser config exception! \", e);\n+        }\n+        return features;\n+    }\n+\n+    private static FeatureTemplate s_parseFeature(Element e) throws ParsingException {\n+        String name = e.getAttribute(\"name\");\n+        boolean statusFeature = e.getAttribute(\"statusFeature\").equals(\"true\");\n+        FeatureTemplate feature = new FeatureTemplate(name, statusFeature, e.getAttribute(\"timeout\"));\n+\n+        NodeList nodes = e.getChildNodes();\n+\n+        for (int i = 0; i < nodes.getLength(); i++) {\n+            Node node = nodes.item(i);\n+            if (node.getNodeType() == Node.ELEMENT_NODE) {\n+                Element child = (Element) node;\n+                if (child.getTagName().equals(\"message-handler\")) {\n+                    s_parseMessageHandler(child, feature);\n+                } else if (child.getTagName().equals(\"command-handler\")) {\n+                    s_parseCommandHandler(child, feature);\n+                } else if (child.getTagName().equals(\"message-dispatcher\")) {\n+                    s_parseMessageDispatcher(child, feature);\n+                } else if (child.getTagName().equals(\"poll-handler\")) {\n+                    s_parsePollHandler(child, feature);\n+                }\n+            }\n+        }\n+\n+        return feature;\n+    }\n+\n+    private static HandlerEntry s_makeHandlerEntry(Element e) throws ParsingException {\n+        String handler = e.getTextContent();\n+        if (handler == null) {\n+            throw new ParsingException(\"Could not find Handler for: \" + e.getTextContent());\n+        }\n+\n+        NamedNodeMap attributes = e.getAttributes();\n+        HashMap<String, @Nullable String> params = new HashMap<String, @Nullable String>();\n+        for (int i = 0; i < attributes.getLength(); i++) {\n+            Node n = attributes.item(i);\n+            params.put(n.getNodeName(), n.getNodeValue());\n+        }\n+        return new HandlerEntry(handler, params);\n+    }\n+\n+    private static void s_parseMessageHandler(Element e, FeatureTemplate f) throws DOMException, ParsingException {\n+        HandlerEntry he = s_makeHandlerEntry(e);\n+        if (e.getAttribute(\"default\").equals(\"true\")) {\n+            f.setDefaultMessageHandler(he);\n+        } else {\n+            String attr = e.getAttribute(\"cmd\");\n+            int command = (attr == null) ? 0 : Utils.from0xHexString(attr);\n+            f.addMessageHandler(command, he);\n+        }\n+    }\n+\n+    private static void s_parseCommandHandler(Element e, FeatureTemplate f) throws ParsingException {\n+        HandlerEntry he = s_makeHandlerEntry(e);\n+        if (e.getAttribute(\"default\").equals(\"true\")) {\n+            f.setDefaultCommandHandler(he);\n+        } else {\n+            Class<? extends Command> command = s_parseCommandClass(e.getAttribute(\"command\"));\n+            f.addCommandHandler(command, he);\n+        }\n+    }\n+\n+    private static void s_parseMessageDispatcher(Element e, FeatureTemplate f) throws DOMException, ParsingException {\n+        HandlerEntry he = s_makeHandlerEntry(e);\n+        f.setMessageDispatcher(he);\n+    }\n+\n+    private static void s_parsePollHandler(Element e, FeatureTemplate f) throws ParsingException {\n+        HandlerEntry he = s_makeHandlerEntry(e);\n+        f.setPollHandler(he);\n+    }\n+\n+    private static Class<? extends Command> s_parseCommandClass(String c) throws ParsingException {\n+        if (c.equals(\"OnOffType\")) {\n+            return OnOffType.class;\n+        } else if (c.equals(\"PercentType\")) {\n+            return PercentType.class;\n+        } else if (c.equals(\"DecimalType\")) {\n+            return DecimalType.class;\n+        } else if (c.equals(\"IncreaseDecreaseType\")) {\n+            return IncreaseDecreaseType.class;\n+        } else {\n+            throw new ParsingException(\"Unknown Command Type\");\n+        }\n+    }\n+\n+    // public static void main(String[] args) throws Exception {\n+    // File f = new File(System.getProperty(\"user.home\")\n+    // + \"/workspace/openhab/bundles/binding/org.openhab.binding.insteonplm/src/main/resources/device_features.xml\");\n+    // InputStream s = new FileInputStream(f);\n+    // ArrayList<FeatureTemplate> features = s_readTemplates(s);\n+    // for (FeatureTemplate feature : features) {\n+    // System.out.println(feature);\n+    // System.out.println(\n+    // \"\\tPOLL: \" + feature.getPollHandler() + \"\\n\\tDISPATCH: \" + feature.getDispatcher().getName());\n+    // System.out.println(\n+    // \"\\tDCH: \" + feature.getDefaultCommandHandler() + \"\\n\\tDMH: \" + feature.getDefaultMessageHandler());\n+    // System.out.println(\"\\tMSG HANDLERS: \" + feature.getMessageHandlers().size());\n+    // System.out.println(\"\\tCMD HANDLERS: \" + feature.getCommandHandlers());\n+    // }\n+    // }", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2NDEyNA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387664124", "bodyText": "Removed", "author": "robnielsen", "createdAt": "2020-03-04T13:26:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwOTUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxMjQyMA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386712420", "bodyText": "Isn't this class just implementing what a Scheduler already does? Why not delete this class and use a scheduler instead?", "author": "cpmeister", "createdAt": "2020-03-02T23:25:32Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/RequestQueueManager.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.util.HashMap;\n+import java.util.PriorityQueue;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that manages all the per-device request queues using a single thread.\n+ *\n+ * - Each device has its own request queue, and the RequestQueueManager keeps a\n+ * queue of queues.\n+ * - Each entry in m_requestQueues corresponds to a single device's request queue.\n+ * A device should never be more than once in m_requestQueues.\n+ * - A hash map (m_requestQueueHash) is kept in sync with m_requestQueues for\n+ * faster lookup in case a request queue is modified and needs to be\n+ * rescheduled.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class RequestQueueManager {", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2NTAxMA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387665010", "bodyText": "What's here works and has been successfully working for years.", "author": "robnielsen", "createdAt": "2020-03-04T13:28:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxMjQyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNTAzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386715035", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    super(new HashSet<>(Arrays.asList(InsteonBindingConstants.NETWORK_THING_TYPE)), DISCOVER_TIMEOUT_SECONDS, true);\n          \n          \n            \n                    super(Collections.singleton(InsteonBindingConstants.NETWORK_THING_TYPE), DISCOVER_TIMEOUT_SECONDS, true);", "author": "cpmeister", "createdAt": "2020-03-02T23:32:49Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/discovery/InsteonNetworkDiscoveryService.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.discovery;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.insteon.internal.InsteonBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonNetworkDiscoveryService} is responsible for device discovery.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.insteon\")\n+public class InsteonNetworkDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(InsteonNetworkDiscoveryService.class);\n+\n+    private static final ThingUID LOCAL_THING = new ThingUID(InsteonBindingConstants.NETWORK_THING_TYPE, \"local\");\n+\n+    private static final int DISCOVER_TIMEOUT_SECONDS = 2;\n+\n+    public InsteonNetworkDiscoveryService() {\n+        super(new HashSet<>(Arrays.asList(InsteonBindingConstants.NETWORK_THING_TYPE)), DISCOVER_TIMEOUT_SECONDS, true);", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2NTU3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387665571", "bodyText": "This works, going to leave as is.", "author": "robnielsen", "createdAt": "2020-03-04T13:29:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNTAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNTE3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386715175", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    super(new HashSet<>(Arrays.asList(InsteonBindingConstants.DEVICE_THING_TYPE)), 0, false);\n          \n          \n            \n                    super(Collections.singleton(InsteonBindingConstants.DEVICE_THING_TYPE), 0, false);", "author": "cpmeister", "createdAt": "2020-03-02T23:33:14Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/discovery/InsteonDeviceDiscoveryService.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.discovery;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.insteon.internal.InsteonBindingConstants;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonDeviceDiscoveryService} is responsible for device discovery.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InsteonDeviceDiscoveryService extends AbstractDiscoveryService {\n+    private static final String ADDRESS = \"address\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonDeviceDiscoveryService.class);\n+\n+    public InsteonDeviceDiscoveryService(InsteonNetworkHandler handler) {\n+        super(new HashSet<>(Arrays.asList(InsteonBindingConstants.DEVICE_THING_TYPE)), 0, false);", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2NTMzNA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387665334", "bodyText": "This works, I'm going to leave as is.", "author": "robnielsen", "createdAt": "2020-03-04T13:28:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNTE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNTM3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386715371", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(Driver.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(Driver.class);", "author": "cpmeister", "createdAt": "2020-03-02T23:33:46Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/Driver.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The driver class manages the modem ports.\n+ * XXX: at this time, only a single modem has ever been used. Expect\n+ * the worst if you connect multiple modems. When multiple modems\n+ * are required, this code needs to be tested and fixed.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class Driver {\n+    private static final Logger logger = LoggerFactory.getLogger(Driver.class);", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzNTQwNw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390035407", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-10T00:39:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNTM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNTg2NA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386715864", "bodyText": "locking has to be done with try/finally", "author": "cpmeister", "createdAt": "2020-03-02T23:35:19Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollIntervalMilliseconds = 300000;\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config) {\n+        this.m_handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            m_devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.info(\"device poll interval set to {} seconds\", m_devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.info(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            m_driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.info(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.s_readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        m_deadDeviceTimeout = m_devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.info(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", port);\n+        m_driver.addPort(\"port\", port);\n+        m_driver.addMsgListener(m_portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        m_driver.setDriverListener(m_portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", m_driver.getNumberOfPorts());\n+\n+        m_driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (m_driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", m_driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        m_isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!m_isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = m_bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(m_driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuffer buf = new StringBuffer();\n+            ArrayList<String> names = new ArrayList<String>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        m_bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = m_devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        m_handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.s_instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.s_makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(m_driver);\n+        dev.addPort(m_driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(m_devicePollIntervalMilliseconds);\n+        }\n+        if (m_driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.s_instance().startPolling(dev, ndev);\n+            }\n+        }\n+        m_devices.put(addr, dev);\n+\n+        m_handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = m_devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.s_instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        InsteonAddress addr = dev.getAddress();\n+        HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = m_driver.lockModemDBEntries();\n+        if (dbes.containsKey(addr)) {\n+            if (!dev.hasModemDBEntry()) {\n+                logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                dev.setHasModemDBEntry(true);\n+            }\n+        } else {\n+            if (m_driver.isModemDBComplete() && !addr.isX10()) {\n+                logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+            }\n+        }\n+        int ndev = dbes.size();\n+        m_driver.unlockModemDBEntries();", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0Nzk0OA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387447948", "bodyText": "missed this", "author": "cpmeister", "createdAt": "2020-03-04T04:52:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNTg2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMTcyOA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390001728", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-09T22:43:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNTg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNjAxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386716015", "bodyText": "locking needs to be done in a try/finally", "author": "cpmeister", "createdAt": "2020-03-02T23:35:48Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollIntervalMilliseconds = 300000;\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config) {\n+        this.m_handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            m_devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.info(\"device poll interval set to {} seconds\", m_devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.info(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            m_driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.info(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.s_readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        m_deadDeviceTimeout = m_devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.info(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", port);\n+        m_driver.addPort(\"port\", port);\n+        m_driver.addMsgListener(m_portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        m_driver.setDriverListener(m_portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", m_driver.getNumberOfPorts());\n+\n+        m_driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (m_driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", m_driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        m_isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!m_isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = m_bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(m_driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuffer buf = new StringBuffer();\n+            ArrayList<String> names = new ArrayList<String>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        m_bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = m_devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        m_handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.s_instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.s_makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(m_driver);\n+        dev.addPort(m_driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(m_devicePollIntervalMilliseconds);\n+        }\n+        if (m_driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.s_instance().startPolling(dev, ndev);\n+            }\n+        }\n+        m_devices.put(addr, dev);\n+\n+        m_handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = m_devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.s_instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        InsteonAddress addr = dev.getAddress();\n+        HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = m_driver.lockModemDBEntries();\n+        if (dbes.containsKey(addr)) {\n+            if (!dev.hasModemDBEntry()) {\n+                logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                dev.setHasModemDBEntry(true);\n+            }\n+        } else {\n+            if (m_driver.isModemDBComplete() && !addr.isX10()) {\n+                logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+            }\n+        }\n+        int ndev = dbes.size();\n+        m_driver.unlockModemDBEntries();\n+        return ndev;\n+    }\n+\n+    /**\n+     * Everything below was copied from Insteon PLM v1\n+     */\n+\n+    /**\n+     * Clean up all state.\n+     */\n+    public void shutdown() {\n+        logger.debug(\"shutting down Insteon bridge\");\n+        m_driver.stopAllPorts();\n+        m_devices.clear();\n+        RequestQueueManager.s_destroyInstance();\n+        Poller.s_instance().stop();\n+        m_isActive = false;\n+    }\n+\n+    /**\n+     * Method to find a device by address\n+     *\n+     * @param aAddr the insteon address to search for\n+     * @return reference to the device, or null if not found\n+     */\n+    public @Nullable InsteonDevice getDevice(@Nullable InsteonAddress aAddr) {\n+        InsteonDevice dev = (aAddr == null) ? null : m_devices.get(aAddr);\n+        return (dev);\n+    }\n+\n+    private String getLinkInfo(HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes, InsteonAddress a) {\n+        ModemDBEntry dbe = dbes.get(a);\n+        ArrayList<Byte> controls = dbe.getControls();\n+        ArrayList<Byte> responds = dbe.getRespondsTo();\n+\n+        StringBuffer buf = new StringBuffer(\"the modem\");\n+        if (!controls.isEmpty()) {\n+            buf.append(\" controls groups [\");\n+            buf.append(toGroupString(controls));\n+            buf.append(\"]\");\n+        }\n+\n+        if (!responds.isEmpty()) {\n+            if (!controls.isEmpty()) {\n+                buf.append(\" and\");\n+            }\n+\n+            buf.append(\" responds to groups [\");\n+            buf.append(toGroupString(responds));\n+            buf.append(\"]\");\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<Byte>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuffer buf = new StringBuffer();\n+        for (Byte b : sorted) {\n+            if (buf.length() > 0) {\n+                buf.append(\",\");\n+            }\n+            buf.append(\"0x\");\n+            buf.append(Utils.getHexString(b));\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    public void logDeviceStatistics() {\n+        String msg = String.format(\"devices: %3d configured, %3d polling, msgs received: %5d\", m_devices.size(),\n+                Poller.s_instance().getSizeOfQueue(), m_messagesReceived);\n+        logger.info(\"{}\", msg);\n+        m_messagesReceived = 0;\n+        for (InsteonDevice dev : m_devices.values()) {\n+            if (dev.isModem()) {\n+                continue;\n+            }\n+            if (m_deadDeviceTimeout > 0 && dev.getPollOverDueTime() > m_deadDeviceTimeout) {\n+                logger.info(\"device {} has not responded to polls for {} sec\", dev.toString(),\n+                        dev.getPollOverDueTime() / 3600);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles messages that come in from the ports.\n+     * Will only process one message at a time.\n+     */\n+    @NonNullByDefault\n+    private class PortListener implements MsgListener, DriverListener {\n+        @Override\n+        public void msg(Msg msg, String fromPort) {\n+            if (msg.isEcho() || msg.isPureNack()) {\n+                return;\n+            }\n+            m_messagesReceived++;\n+            logger.debug(\"got msg: {}\", msg);\n+            if (msg.isX10()) {\n+                handleX10Message(msg, fromPort);\n+            } else {\n+                handleInsteonMessage(msg, fromPort);\n+            }\n+\n+        }\n+\n+        @Override\n+        public void driverCompletelyInitialized() {\n+            HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = m_driver.lockModemDBEntries();", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0ODE3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387448179", "bodyText": "missed this", "author": "cpmeister", "createdAt": "2020-03-04T04:53:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNjAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMjA1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390002055", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-09T22:44:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNjAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNjMwNg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386716306", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    StringBuffer buf = new StringBuffer();\n          \n          \n            \n                    StringBuilder buf = new StringBuilder();", "author": "cpmeister", "createdAt": "2020-03-02T23:36:40Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollIntervalMilliseconds = 300000;\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config) {\n+        this.m_handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            m_devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.info(\"device poll interval set to {} seconds\", m_devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.info(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            m_driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.info(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.s_readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        m_deadDeviceTimeout = m_devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.info(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", port);\n+        m_driver.addPort(\"port\", port);\n+        m_driver.addMsgListener(m_portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        m_driver.setDriverListener(m_portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", m_driver.getNumberOfPorts());\n+\n+        m_driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (m_driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", m_driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        m_isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!m_isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = m_bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(m_driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuffer buf = new StringBuffer();\n+            ArrayList<String> names = new ArrayList<String>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        m_bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = m_devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        m_handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.s_instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.s_makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(m_driver);\n+        dev.addPort(m_driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(m_devicePollIntervalMilliseconds);\n+        }\n+        if (m_driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.s_instance().startPolling(dev, ndev);\n+            }\n+        }\n+        m_devices.put(addr, dev);\n+\n+        m_handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = m_devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.s_instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        InsteonAddress addr = dev.getAddress();\n+        HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = m_driver.lockModemDBEntries();\n+        if (dbes.containsKey(addr)) {\n+            if (!dev.hasModemDBEntry()) {\n+                logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                dev.setHasModemDBEntry(true);\n+            }\n+        } else {\n+            if (m_driver.isModemDBComplete() && !addr.isX10()) {\n+                logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+            }\n+        }\n+        int ndev = dbes.size();\n+        m_driver.unlockModemDBEntries();\n+        return ndev;\n+    }\n+\n+    /**\n+     * Everything below was copied from Insteon PLM v1\n+     */\n+\n+    /**\n+     * Clean up all state.\n+     */\n+    public void shutdown() {\n+        logger.debug(\"shutting down Insteon bridge\");\n+        m_driver.stopAllPorts();\n+        m_devices.clear();\n+        RequestQueueManager.s_destroyInstance();\n+        Poller.s_instance().stop();\n+        m_isActive = false;\n+    }\n+\n+    /**\n+     * Method to find a device by address\n+     *\n+     * @param aAddr the insteon address to search for\n+     * @return reference to the device, or null if not found\n+     */\n+    public @Nullable InsteonDevice getDevice(@Nullable InsteonAddress aAddr) {\n+        InsteonDevice dev = (aAddr == null) ? null : m_devices.get(aAddr);\n+        return (dev);\n+    }\n+\n+    private String getLinkInfo(HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes, InsteonAddress a) {\n+        ModemDBEntry dbe = dbes.get(a);\n+        ArrayList<Byte> controls = dbe.getControls();\n+        ArrayList<Byte> responds = dbe.getRespondsTo();\n+\n+        StringBuffer buf = new StringBuffer(\"the modem\");\n+        if (!controls.isEmpty()) {\n+            buf.append(\" controls groups [\");\n+            buf.append(toGroupString(controls));\n+            buf.append(\"]\");\n+        }\n+\n+        if (!responds.isEmpty()) {\n+            if (!controls.isEmpty()) {\n+                buf.append(\" and\");\n+            }\n+\n+            buf.append(\" responds to groups [\");\n+            buf.append(toGroupString(responds));\n+            buf.append(\"]\");\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<Byte>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuffer buf = new StringBuffer();", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0MTUyMA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390041520", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-10T01:03:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNjMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxODA4MA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386718080", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    StringBuffer buf = new StringBuffer(\"the modem\");\n          \n          \n            \n                    StringBuilder buf = new StringBuilder(\"the modem\");", "author": "cpmeister", "createdAt": "2020-03-02T23:41:48Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollIntervalMilliseconds = 300000;\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config) {\n+        this.m_handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            m_devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.info(\"device poll interval set to {} seconds\", m_devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.info(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            m_driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.info(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.s_readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        m_deadDeviceTimeout = m_devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.info(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", port);\n+        m_driver.addPort(\"port\", port);\n+        m_driver.addMsgListener(m_portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        m_driver.setDriverListener(m_portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", m_driver.getNumberOfPorts());\n+\n+        m_driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (m_driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", m_driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        m_isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!m_isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = m_bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(m_driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuffer buf = new StringBuffer();\n+            ArrayList<String> names = new ArrayList<String>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        m_bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = m_devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        m_handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.s_instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.s_makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(m_driver);\n+        dev.addPort(m_driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(m_devicePollIntervalMilliseconds);\n+        }\n+        if (m_driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.s_instance().startPolling(dev, ndev);\n+            }\n+        }\n+        m_devices.put(addr, dev);\n+\n+        m_handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = m_devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.s_instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        InsteonAddress addr = dev.getAddress();\n+        HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = m_driver.lockModemDBEntries();\n+        if (dbes.containsKey(addr)) {\n+            if (!dev.hasModemDBEntry()) {\n+                logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                dev.setHasModemDBEntry(true);\n+            }\n+        } else {\n+            if (m_driver.isModemDBComplete() && !addr.isX10()) {\n+                logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+            }\n+        }\n+        int ndev = dbes.size();\n+        m_driver.unlockModemDBEntries();\n+        return ndev;\n+    }\n+\n+    /**\n+     * Everything below was copied from Insteon PLM v1\n+     */\n+\n+    /**\n+     * Clean up all state.\n+     */\n+    public void shutdown() {\n+        logger.debug(\"shutting down Insteon bridge\");\n+        m_driver.stopAllPorts();\n+        m_devices.clear();\n+        RequestQueueManager.s_destroyInstance();\n+        Poller.s_instance().stop();\n+        m_isActive = false;\n+    }\n+\n+    /**\n+     * Method to find a device by address\n+     *\n+     * @param aAddr the insteon address to search for\n+     * @return reference to the device, or null if not found\n+     */\n+    public @Nullable InsteonDevice getDevice(@Nullable InsteonAddress aAddr) {\n+        InsteonDevice dev = (aAddr == null) ? null : m_devices.get(aAddr);\n+        return (dev);\n+    }\n+\n+    private String getLinkInfo(HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes, InsteonAddress a) {\n+        ModemDBEntry dbe = dbes.get(a);\n+        ArrayList<Byte> controls = dbe.getControls();\n+        ArrayList<Byte> responds = dbe.getRespondsTo();\n+\n+        StringBuffer buf = new StringBuffer(\"the modem\");", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0MTYxNw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390041617", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-10T01:03:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxODA4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxODI0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386718247", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"{}\", msg);\n          \n          \n            \n                    logger.debug(\"{}\", msg);", "author": "cpmeister", "createdAt": "2020-03-02T23:42:19Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollIntervalMilliseconds = 300000;\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config) {\n+        this.m_handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            m_devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.info(\"device poll interval set to {} seconds\", m_devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.info(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            m_driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.info(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.s_readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        m_deadDeviceTimeout = m_devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.info(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", port);\n+        m_driver.addPort(\"port\", port);\n+        m_driver.addMsgListener(m_portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        m_driver.setDriverListener(m_portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", m_driver.getNumberOfPorts());\n+\n+        m_driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (m_driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", m_driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        m_isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!m_isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = m_bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(m_driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuffer buf = new StringBuffer();\n+            ArrayList<String> names = new ArrayList<String>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        m_bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = m_devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        m_handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.s_instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.s_makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(m_driver);\n+        dev.addPort(m_driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(m_devicePollIntervalMilliseconds);\n+        }\n+        if (m_driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.s_instance().startPolling(dev, ndev);\n+            }\n+        }\n+        m_devices.put(addr, dev);\n+\n+        m_handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = m_devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.s_instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        InsteonAddress addr = dev.getAddress();\n+        HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = m_driver.lockModemDBEntries();\n+        if (dbes.containsKey(addr)) {\n+            if (!dev.hasModemDBEntry()) {\n+                logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                dev.setHasModemDBEntry(true);\n+            }\n+        } else {\n+            if (m_driver.isModemDBComplete() && !addr.isX10()) {\n+                logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+            }\n+        }\n+        int ndev = dbes.size();\n+        m_driver.unlockModemDBEntries();\n+        return ndev;\n+    }\n+\n+    /**\n+     * Everything below was copied from Insteon PLM v1\n+     */\n+\n+    /**\n+     * Clean up all state.\n+     */\n+    public void shutdown() {\n+        logger.debug(\"shutting down Insteon bridge\");\n+        m_driver.stopAllPorts();\n+        m_devices.clear();\n+        RequestQueueManager.s_destroyInstance();\n+        Poller.s_instance().stop();\n+        m_isActive = false;\n+    }\n+\n+    /**\n+     * Method to find a device by address\n+     *\n+     * @param aAddr the insteon address to search for\n+     * @return reference to the device, or null if not found\n+     */\n+    public @Nullable InsteonDevice getDevice(@Nullable InsteonAddress aAddr) {\n+        InsteonDevice dev = (aAddr == null) ? null : m_devices.get(aAddr);\n+        return (dev);\n+    }\n+\n+    private String getLinkInfo(HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes, InsteonAddress a) {\n+        ModemDBEntry dbe = dbes.get(a);\n+        ArrayList<Byte> controls = dbe.getControls();\n+        ArrayList<Byte> responds = dbe.getRespondsTo();\n+\n+        StringBuffer buf = new StringBuffer(\"the modem\");\n+        if (!controls.isEmpty()) {\n+            buf.append(\" controls groups [\");\n+            buf.append(toGroupString(controls));\n+            buf.append(\"]\");\n+        }\n+\n+        if (!responds.isEmpty()) {\n+            if (!controls.isEmpty()) {\n+                buf.append(\" and\");\n+            }\n+\n+            buf.append(\" responds to groups [\");\n+            buf.append(toGroupString(responds));\n+            buf.append(\"]\");\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<Byte>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuffer buf = new StringBuffer();\n+        for (Byte b : sorted) {\n+            if (buf.length() > 0) {\n+                buf.append(\",\");\n+            }\n+            buf.append(\"0x\");\n+            buf.append(Utils.getHexString(b));\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    public void logDeviceStatistics() {\n+        String msg = String.format(\"devices: %3d configured, %3d polling, msgs received: %5d\", m_devices.size(),\n+                Poller.s_instance().getSizeOfQueue(), m_messagesReceived);\n+        logger.info(\"{}\", msg);", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3ODI0NA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389978244", "bodyText": "please do this change", "author": "kaikreuzer", "createdAt": "2020-03-09T21:42:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxODI0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMTI1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390001253", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-09T22:42:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxODI0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxOTA2MA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386719060", "bodyText": "default port is random?", "author": "cpmeister", "createdAt": "2020-03-02T23:44:56Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/Driver.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The driver class manages the modem ports.\n+ * XXX: at this time, only a single modem has ever been used. Expect\n+ * the worst if you connect multiple modems. When multiple modems\n+ * are required, this code needs to be tested and fixed.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class Driver {\n+    private static final Logger logger = LoggerFactory.getLogger(Driver.class);\n+\n+    // maps device name to serial port, i.e /dev/insteon -> Port object\n+    private HashMap<String, Port> m_ports = new HashMap<String, Port>();\n+    private @Nullable DriverListener m_listener = null; // single listener for notifications\n+    private HashMap<InsteonAddress, @Nullable ModemDBEntry> m_modemDBEntries = new HashMap<InsteonAddress, @Nullable ModemDBEntry>();\n+    private ReentrantLock m_modemDBEntriesLock = new ReentrantLock();\n+    private int m_modemDBRetryTimeout = 120000; // in milliseconds\n+\n+    public void setDriverListener(DriverListener listener) {\n+        m_listener = listener;\n+    }\n+\n+    public void setModemDBRetryTimeout(int timeout) {\n+        m_modemDBRetryTimeout = timeout;\n+        for (Port p : m_ports.values()) {\n+            p.setModemDBRetryTimeout(m_modemDBRetryTimeout);\n+        }\n+    }\n+\n+    public boolean isReady() {\n+        for (Port p : m_ports.values()) {\n+            if (!p.isRunning()) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public HashMap<InsteonAddress, @Nullable ModemDBEntry> lockModemDBEntries() {\n+        m_modemDBEntriesLock.lock();\n+        return m_modemDBEntries;\n+    }\n+\n+    public void unlockModemDBEntries() {\n+        m_modemDBEntriesLock.unlock();\n+    }\n+\n+    /**\n+     * Add new port (modem) to the driver\n+     *\n+     * @param name the name of the port (from the config file, e.g. port_0, port_1, etc\n+     * @param port the device name, e.g. /dev/insteon, /dev/ttyUSB0 etc\n+     */\n+    public void addPort(String name, String port) {\n+        if (m_ports.keySet().contains(port)) {\n+            logger.warn(\"ignored attempt to add duplicate port: {} {}\", name, port);\n+        } else {\n+            Port p = new Port(port, this);\n+            p.setModemDBRetryTimeout(m_modemDBRetryTimeout);\n+            m_ports.put(port, p);\n+            logger.debug(\"added new port: {} {}\", name, port);\n+        }\n+    }\n+\n+    /**\n+     * Register a message listener with a port\n+     *\n+     * @param listener the listener who wants to listen to port messages\n+     * @param port the port (e.g. /dev/ttyUSB0) to which the listener listens\n+     */\n+    public void addMsgListener(MsgListener listener, String port) {\n+        if (m_ports.keySet().contains(port)) {\n+            m_ports.get(port).addListener(listener);\n+        } else {\n+            logger.warn(\"referencing unknown port {}!\", port);\n+        }\n+    }\n+\n+    public void startAllPorts() {\n+        for (Port p : m_ports.values()) {\n+            p.start();\n+        }\n+    }\n+\n+    public void stopAllPorts() {\n+        for (Port p : m_ports.values()) {\n+            p.stop();\n+        }\n+    }\n+\n+    /**\n+     * Write message to a port\n+     *\n+     * @param port name of the port to write to (e.g. '/dev/ttyUSB0')\n+     * @param m the message to write\n+     * @throws IOException\n+     */\n+    public void writeMessage(String port, Msg m) throws IOException {\n+        Port p = getPort(port);\n+        if (p == null) {\n+            logger.warn(\"cannot write to unknown port {}\", port);\n+            throw new IOException();\n+        }\n+        p.writeMessage(m);\n+    }\n+\n+    public @Nullable String getDefaultPort() {\n+        return (m_ports.isEmpty() ? null : m_ports.keySet().iterator().next());", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2NjExOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387666119", "bodyText": "This works, going to leave as is.", "author": "robnielsen", "createdAt": "2020-03-04T13:30:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxOTA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxOTI2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386719266", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(IOStream.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(IOStream.class);", "author": "cpmeister", "createdAt": "2020-03-02T23:45:35Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/IOStream.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.driver.hub.HubIOStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for implementation for I/O stream with anything that looks\n+ * like a PLM (e.g. the insteon hubs, serial/usb connection etc)\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public abstract class IOStream {\n+    private static final Logger logger = LoggerFactory.getLogger(IOStream.class);", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMxOTcxNg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390319716", "bodyText": "logger is used in a static method, this can't change", "author": "robnielsen", "createdAt": "2020-03-10T13:41:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxOTI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyMDIzMw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386720233", "bodyText": "This is really dangerous, you aren't properly handling the case when the underlying stream is closed by something other than you (e.g. hardware problem or other fault) which could result in an infinite loop.\nAlso, find a way to implement this without Thread.sleep!", "author": "cpmeister", "createdAt": "2020-03-02T23:48:38Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/IOStream.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.driver.hub.HubIOStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for implementation for I/O stream with anything that looks\n+ * like a PLM (e.g. the insteon hubs, serial/usb connection etc)\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public abstract class IOStream {\n+    private static final Logger logger = LoggerFactory.getLogger(IOStream.class);\n+    protected @Nullable InputStream m_in = null;\n+    protected @Nullable OutputStream m_out = null;\n+    private boolean stopped = false;\n+\n+    public void stop() {\n+        stopped = true;\n+    }\n+\n+    /**\n+     * read data from iostream\n+     *\n+     * @param b byte array (output)\n+     * @param offset offset for placement into byte array\n+     * @param readSize size to read\n+     * @return number of bytes read\n+     */\n+    public int read(byte[] b, int offset, int readSize) throws InterruptedException {\n+        int len = 0;\n+        while (!stopped && len < 1) {\n+            try {\n+                len = m_in.read(b, offset, readSize);\n+                if (Thread.interrupted()) {\n+                    throw new InterruptedException();\n+                }\n+            } catch (IOException e) {\n+                logger.trace(\"got exception while reading: {}\", e.getMessage());\n+                while (!stopped && !reconnect()) {\n+                    logger.trace(\"sleeping before reconnecting\");\n+                    Thread.sleep(10000);\n+                }\n+            }", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2NjY4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387666683", "bodyText": "This is the way it was written, it has worked for years not worth changing.", "author": "robnielsen", "createdAt": "2020-03-04T13:31:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyMDIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyMTM1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386721352", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    StringBuffer buf = new StringBuffer();\n          \n          \n            \n                    StringBuilder buf = new StringBuilder();", "author": "cpmeister", "createdAt": "2020-03-02T23:51:59Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/ModemDBEntry.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+\n+/**\n+ * The ModemDBEntry class holds a modem device type record\n+ * an xml file.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class ModemDBEntry {\n+    private @Nullable InsteonAddress m_address = null;\n+    private @Nullable Port m_port = null;\n+    private ArrayList<Msg> m_linkRecords = new ArrayList<Msg>();\n+    private ArrayList<Byte> m_controls = new ArrayList<Byte>();\n+    private ArrayList<Byte> m_respondsTo = new ArrayList<Byte>();\n+\n+    public ModemDBEntry(InsteonAddress aAddr) {\n+        m_address = aAddr;\n+    }\n+\n+    public ArrayList<Msg> getLinkRecords() {\n+        return m_linkRecords;\n+    }\n+\n+    public void addLinkRecord(Msg m) {\n+        m_linkRecords.add(m);\n+    }\n+\n+    public void addControls(byte c) {\n+        m_controls.add(c);\n+    }\n+\n+    public ArrayList<Byte> getControls() {\n+        return m_controls;\n+    }\n+\n+    public void addRespondsTo(byte r) {\n+        m_respondsTo.add(r);\n+    }\n+\n+    public ArrayList<Byte> getRespondsTo() {\n+        return m_respondsTo;\n+    }\n+\n+    public void setPort(Port p) {\n+        m_port = p;\n+    }\n+\n+    public @Nullable Port getPort() {\n+        return m_port;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String s = \"addr:\" + m_address + \"|controls:[\" + toGroupString(m_controls) + \"]|responds_to:[\"\n+                + toGroupString(m_respondsTo) + \"]|link_recors\";\n+        for (Msg m : m_linkRecords) {\n+            s += \":(\" + m + \")\";\n+        }\n+        return s;\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<Byte>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuffer buf = new StringBuffer();", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0MDM4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387440385", "bodyText": "missed this one", "author": "cpmeister", "createdAt": "2020-03-04T04:13:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyMTM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMyMDAxNg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390320016", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-10T13:41:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyMTM1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyMjk1MA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386722950", "bodyText": "Change this to use a CopyOnWriteArraySet, then remove all the synchronization around this field.", "author": "cpmeister", "createdAt": "2020-03-02T23:57:19Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/Port.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.ModemDBBuilder;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgFactory;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Port class represents a port, that is a connection to either an Insteon modem either through\n+ * a serial or USB port, or via an Insteon Hub.\n+ * It does the initialization of the port, and (via its inner classes IOStreamReader and IOStreamWriter)\n+ * manages the reading/writing of messages on the Insteon network.\n+ *\n+ * The IOStreamReader and IOStreamWriter class combined implement the somewhat tricky flow control protocol.\n+ * In combination with the MsgFactory class, the incoming data stream is turned into a Msg structure\n+ * for further processing by the upper layers (MsgListeners).\n+ *\n+ * A write queue is maintained to pace the flow of outgoing messages. Sending messages back-to-back\n+ * can lead to dropped messages.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class Port {\n+    private static final Logger logger = LoggerFactory.getLogger(Port.class);\n+\n+    /**\n+     * The ReplyType is used to keep track of the state of the serial port receiver\n+     */\n+    enum ReplyType {\n+        GOT_ACK,\n+        WAITING_FOR_ACK,\n+        GOT_NACK\n+    }\n+\n+    private IOStream m_ioStream;\n+    private String m_devName;\n+    private String m_logName;\n+    private Modem m_modem;\n+    private IOStreamReader m_reader;\n+    private IOStreamWriter m_writer;\n+    private final int m_readSize = 1024; // read buffer size\n+    private @Nullable Thread m_readThread = null;\n+    private @Nullable Thread m_writeThread = null;\n+    private boolean m_running = false;\n+    private boolean m_modemDBComplete = false;\n+    private MsgFactory m_msgFactory = new MsgFactory();\n+    private Driver m_driver;\n+    private ModemDBBuilder m_mdbb;\n+    private ArrayList<MsgListener> m_listeners = new ArrayList<MsgListener>();", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0MTA2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390041065", "bodyText": "This works, I'm going to leave as is since it's always been this way.", "author": "robnielsen", "createdAt": "2020-03-10T01:01:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyMjk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyMzA1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386723055", "bodyText": "don't use clone()", "author": "cpmeister", "createdAt": "2020-03-02T23:57:41Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/Port.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.ModemDBBuilder;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgFactory;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Port class represents a port, that is a connection to either an Insteon modem either through\n+ * a serial or USB port, or via an Insteon Hub.\n+ * It does the initialization of the port, and (via its inner classes IOStreamReader and IOStreamWriter)\n+ * manages the reading/writing of messages on the Insteon network.\n+ *\n+ * The IOStreamReader and IOStreamWriter class combined implement the somewhat tricky flow control protocol.\n+ * In combination with the MsgFactory class, the incoming data stream is turned into a Msg structure\n+ * for further processing by the upper layers (MsgListeners).\n+ *\n+ * A write queue is maintained to pace the flow of outgoing messages. Sending messages back-to-back\n+ * can lead to dropped messages.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class Port {\n+    private static final Logger logger = LoggerFactory.getLogger(Port.class);\n+\n+    /**\n+     * The ReplyType is used to keep track of the state of the serial port receiver\n+     */\n+    enum ReplyType {\n+        GOT_ACK,\n+        WAITING_FOR_ACK,\n+        GOT_NACK\n+    }\n+\n+    private IOStream m_ioStream;\n+    private String m_devName;\n+    private String m_logName;\n+    private Modem m_modem;\n+    private IOStreamReader m_reader;\n+    private IOStreamWriter m_writer;\n+    private final int m_readSize = 1024; // read buffer size\n+    private @Nullable Thread m_readThread = null;\n+    private @Nullable Thread m_writeThread = null;\n+    private boolean m_running = false;\n+    private boolean m_modemDBComplete = false;\n+    private MsgFactory m_msgFactory = new MsgFactory();\n+    private Driver m_driver;\n+    private ModemDBBuilder m_mdbb;\n+    private ArrayList<MsgListener> m_listeners = new ArrayList<MsgListener>();\n+    private LinkedBlockingQueue<Msg> m_writeQueue = new LinkedBlockingQueue<Msg>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param devName the name of the port, i.e. '/dev/insteon'\n+     * @param d The Driver object that manages this port\n+     */\n+    public Port(String devName, Driver d) {\n+        m_devName = devName;\n+        m_driver = d;\n+        m_logName = devName;\n+        m_modem = new Modem();\n+        addListener(m_modem);\n+        m_ioStream = IOStream.s_create(devName);\n+        m_reader = new IOStreamReader();\n+        m_writer = new IOStreamWriter();\n+        m_mdbb = new ModemDBBuilder(this);\n+    }\n+\n+    public synchronized boolean isModemDBComplete() {\n+        return (m_modemDBComplete);\n+    }\n+\n+    public boolean isRunning() {\n+        return m_running;\n+    }\n+\n+    public InsteonAddress getAddress() {\n+        return m_modem.getAddress();\n+    }\n+\n+    public String getDeviceName() {\n+        return m_devName;\n+    }\n+\n+    public Driver getDriver() {\n+        return m_driver;\n+    }\n+\n+    public void setModemDBRetryTimeout(int timeout) {\n+        m_mdbb.setRetryTimeout(timeout);\n+    }\n+\n+    public void addListener(MsgListener l) {\n+        synchronized (m_listeners) {\n+            if (!m_listeners.contains(l)) {\n+                m_listeners.add(l);\n+            }\n+        }\n+    }\n+\n+    public void removeListener(MsgListener l) {\n+        synchronized (m_listeners) {\n+            if (m_listeners.remove(l)) {\n+                // logger.debug(\"removed listener from port\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Clear modem database that has been queried so far.\n+     */\n+    public void clearModemDB() {\n+        logger.debug(\"clearing modem db!\");\n+        HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = getDriver().lockModemDBEntries();\n+        dbes.clear();\n+        getDriver().unlockModemDBEntries();\n+    }\n+\n+    /**\n+     * Starts threads necessary for reading and writing\n+     */\n+    public void start() {\n+        logger.debug(\"starting port {}\", m_logName);\n+        if (m_running) {\n+            logger.debug(\"port {} already running, not started again\", m_logName);\n+        }\n+        if (!m_ioStream.open()) {\n+            logger.debug(\"failed to open port {}\", m_logName);\n+            return;\n+        }\n+        m_readThread = new Thread(m_reader);\n+        m_writeThread = new Thread(m_writer);\n+        m_readThread.setName(m_logName + \" Reader\");\n+        m_writeThread.setName(m_logName + \" Writer\");\n+        m_readThread.start();\n+        m_writeThread.start();\n+        m_modem.initialize();\n+        m_mdbb.start(); // start downloading the device list\n+        m_running = true;\n+    }\n+\n+    /**\n+     * Stops all threads\n+     */\n+    public void stop() {\n+        if (!m_running) {\n+            logger.debug(\"port {} not running, no need to stop it\", m_logName);\n+            return;\n+        }\n+\n+        m_running = false;\n+        m_ioStream.stop();\n+        m_ioStream.close();\n+\n+        if (m_readThread != null) {\n+            m_readThread.interrupt();\n+        }\n+        if (m_writeThread != null) {\n+            m_writeThread.interrupt();\n+        }\n+        logger.debug(\"waiting for read thread to exit for port {}\", m_logName);\n+        try {\n+            if (m_readThread != null) {\n+                m_readThread.join();\n+            }\n+        } catch (InterruptedException e) {\n+            logger.debug(\"got interrupted waiting for read thread to exit.\");\n+        }\n+        logger.debug(\"waiting for write thread to exit for port {}\", m_logName);\n+        try {\n+            if (m_writeThread != null) {\n+                m_writeThread.join();\n+            }\n+        } catch (InterruptedException e) {\n+            logger.debug(\"got interrupted waiting for write thread to exit.\");\n+        }\n+        logger.debug(\"all threads for port {} stopped.\", m_logName);\n+        synchronized (m_listeners) {\n+            m_listeners.clear();\n+        }\n+    }\n+\n+    /**\n+     * Adds message to the write queue\n+     *\n+     * @param m message to be added to the write queue\n+     * @throws IOException\n+     */\n+    public void writeMessage(@Nullable Msg m) throws IOException {\n+        if (m == null) {\n+            logger.warn(\"trying to write null message!\");\n+            throw new IOException(\"trying to write null message!\");\n+        }\n+        if (m.getData() == null) {\n+            logger.warn(\"trying to write message without data!\");\n+            throw new IOException(\"trying to write message without data!\");\n+        }\n+        try {\n+            m_writeQueue.add(m);\n+            logger.trace(\"enqueued msg: {}\", m);\n+        } catch (IllegalStateException e) {\n+            logger.warn(\"cannot write message {}, write queue is full!\", m);\n+        }\n+\n+    }\n+\n+    /**\n+     * Gets called by the modem database builder when the modem database is complete\n+     */\n+    public void modemDBComplete() {\n+        synchronized (this) {\n+            m_modemDBComplete = true;\n+        }\n+        m_driver.modemDBComplete(this);\n+    }\n+\n+    /**\n+     * The IOStreamReader uses the MsgFactory to turn the incoming bytes into\n+     * Msgs for the listeners. It also communicates with the IOStreamWriter\n+     * to implement flow control (tell the IOStreamWriter that it needs to retransmit,\n+     * or the reply message has been received correctly).\n+     *\n+     * @author Bernd Pfrommer - Initial contribution\n+     */\n+    @NonNullByDefault\n+    class IOStreamReader implements Runnable {\n+\n+        private ReplyType m_reply = ReplyType.GOT_ACK;\n+        private Object m_replyLock = new Object();\n+        private boolean m_dropRandomBytes = false; // set to true for fault injection\n+\n+        /**\n+         * Helper function for implementing synchronization between reader and writer\n+         *\n+         * @return reference to the RequesReplyLock\n+         */\n+        public Object getRequestReplyLock() {\n+            return m_replyLock;\n+        }\n+\n+        @Override\n+        public void run() {\n+            logger.debug(\"starting reader...\");\n+            byte[] buffer = new byte[2 * m_readSize];\n+            Random rng = new Random();\n+            try {\n+                for (int len = -1; (len = m_ioStream.read(buffer, 0, m_readSize)) > 0;) {\n+                    if (m_dropRandomBytes && rng.nextInt(100) < 20) {\n+                        len = dropBytes(buffer, len);\n+                    }\n+                    m_msgFactory.addData(buffer, len);\n+                    processMessages();\n+                }\n+            } catch (InterruptedException e) {\n+                logger.debug(\"reader thread got interrupted!\");\n+            }\n+            logger.info(\"reader thread exiting!\");\n+        }\n+\n+        private void processMessages() {\n+            try {\n+                // must call processData() until we get a null pointer back\n+                for (Msg m = m_msgFactory.processData(); m != null; m = m_msgFactory.processData()) {\n+                    toAllListeners(m);\n+                    notifyWriter(m);\n+                }\n+            } catch (IOException e) {\n+                // got bad data from modem,\n+                // unblock those waiting for ack\n+                logger.warn(\"bad data received: {}\", e.getMessage());\n+                synchronized (getRequestReplyLock()) {\n+                    if (m_reply == ReplyType.WAITING_FOR_ACK) {\n+                        logger.warn(\"got bad data back, must assume message was acked.\");\n+                        m_reply = ReplyType.GOT_ACK;\n+                        getRequestReplyLock().notify();\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void notifyWriter(Msg msg) {\n+            synchronized (getRequestReplyLock()) {\n+                if (m_reply == ReplyType.WAITING_FOR_ACK) {\n+                    if (!msg.isUnsolicited()) {\n+                        m_reply = (msg.isPureNack() ? ReplyType.GOT_NACK : ReplyType.GOT_ACK);\n+                        logger.trace(\"signaling receipt of ack: {}\", (m_reply == ReplyType.GOT_ACK));\n+                        getRequestReplyLock().notify();\n+                    } else if (msg.isPureNack()) {\n+                        m_reply = ReplyType.GOT_NACK;\n+                        logger.trace(\"signaling receipt of pure nack\");\n+                        getRequestReplyLock().notify();\n+                    } else {\n+                        logger.trace(\"got unsolicited message\");\n+                    }\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Drops bytes randomly from buffer to simulate errors seen\n+         * from the InsteonHub using the raw interface\n+         *\n+         * @param buffer byte buffer from which to drop bytes\n+         * @param len original number of valid bytes in buffer\n+         * @return length of byte buffer after dropping from it\n+         */\n+        private int dropBytes(byte[] buffer, int len) {\n+            final int DROP_RATE = 2; // in percent\n+            Random rng = new Random();\n+            ArrayList<Byte> l = new ArrayList<Byte>();\n+            for (int i = 0; i < len; i++) {\n+                if (rng.nextInt(100) >= DROP_RATE) {\n+                    l.add(new Byte(buffer[i]));\n+                }\n+            }\n+            for (int i = 0; i < l.size(); i++) {\n+                buffer[i] = l.get(i);\n+            }\n+            return (l.size());\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private void toAllListeners(Msg msg) {\n+            // When we deliver the message, the recipient\n+            // may in turn call removeListener() or addListener(),\n+            // thereby corrupting the very same list we are iterating\n+            // through. That's why we make a copy of it, and\n+            // iterate through the copy.\n+            ArrayList<MsgListener> tempList = null;\n+            synchronized (m_listeners) {\n+                tempList = (ArrayList<MsgListener>) m_listeners.clone();", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0MTE1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390041157", "bodyText": "This works and has always been this way. I'm going to leave as is.", "author": "robnielsen", "createdAt": "2020-03-10T01:01:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyMzA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyOTIyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386729221", "bodyText": "This should be changed to use org.eclipse.smarthome.io.transport.serial.SerialPort instead", "author": "cpmeister", "createdAt": "2020-03-03T00:16:31Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/SerialIOStream.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import gnu.io.CommPort;\n+import gnu.io.CommPortIdentifier;\n+import gnu.io.NoSuchPortException;\n+import gnu.io.PortInUseException;\n+import gnu.io.SerialPort;\n+import gnu.io.UnsupportedCommOperationException;", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2NzY5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387667692", "bodyText": "This works, and many other bindings do this as well", "author": "robnielsen", "createdAt": "2020-03-04T13:33:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyOTIyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2Nzk1OA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387667958", "bodyText": "I agree, would be great to have it moved away from using gnu.io directly. The change should be pretty simple and straight-forward.", "author": "kaikreuzer", "createdAt": "2020-03-04T13:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyOTIyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzNTcwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390035701", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-10T00:40:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyOTIyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyOTM4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386729385", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(SerialIOStream.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(SerialIOStream.class);", "author": "cpmeister", "createdAt": "2020-03-03T00:17:04Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/SerialIOStream.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import gnu.io.CommPort;\n+import gnu.io.CommPortIdentifier;\n+import gnu.io.NoSuchPortException;\n+import gnu.io.PortInUseException;\n+import gnu.io.SerialPort;\n+import gnu.io.UnsupportedCommOperationException;\n+\n+/**\n+ * Implements IOStream for serial devices.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class SerialIOStream extends IOStream {\n+    private static final Logger logger = LoggerFactory.getLogger(SerialIOStream.class);", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0MDg2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390040869", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-10T01:00:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyOTM4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczMDE2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386730167", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(TcpIOStream.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(TcpIOStream.class);", "author": "cpmeister", "createdAt": "2020-03-03T00:19:34Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/TcpIOStream.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.io.IOException;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implements IOStream for the older hubs (pre 2014).\n+ * Also works for serial ports exposed via tcp, eg. ser2net\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ *\n+ */\n+@NonNullByDefault\n+public class TcpIOStream extends IOStream {\n+    private static final Logger logger = LoggerFactory.getLogger(TcpIOStream.class);", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzODk2MA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390038960", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-10T00:52:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczMDE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczMTI1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386731254", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean done = false;\n          \n          \n            \n                private volatile boolean done = false;", "author": "cpmeister", "createdAt": "2020-03-03T00:23:13Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/hub/ReadByteBuffer.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver.hub;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * ReadByteBuffer buffer class\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class ReadByteBuffer {\n+    private byte m_buf[]; // the actual buffer\n+    private int m_count; // number of valid bytes\n+    private int m_index = 0; // current read index\n+    private boolean done = false;", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2ODI0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387668243", "bodyText": "This passes the code analysis checks leaving as is.", "author": "robnielsen", "createdAt": "2020-03-04T13:34:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczMTI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczMTMyNw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386731327", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private byte m_buf[]; // the actual buffer\n          \n          \n            \n                private byte[] m_buf; // the actual buffer", "author": "cpmeister", "createdAt": "2020-03-03T00:23:25Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/hub/ReadByteBuffer.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver.hub;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * ReadByteBuffer buffer class\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class ReadByteBuffer {\n+    private byte m_buf[]; // the actual buffer", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2ODE3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387668171", "bodyText": "This passes the code analysis checks leaving as is.", "author": "robnielsen", "createdAt": "2020-03-04T13:33:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczMTMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MDczMA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386740730", "bodyText": "Usage of this thread should be replaced with a scheduler", "author": "cpmeister", "createdAt": "2020-03-03T00:55:16Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/hub/HubIOStream.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver.hub;\n+\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.driver.IOStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implements IOStream for a Hub 2014 device\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ *\n+ */\n+@NonNullByDefault\n+public class HubIOStream extends IOStream implements Runnable {\n+    private static final Logger logger = LoggerFactory.getLogger(HubIOStream.class);\n+\n+    private static final String BS_START = \"<BS>\";\n+    private static final String BS_END = \"</BS>\";\n+\n+    /** time between polls (in milliseconds */\n+    private int m_pollTime = 1000;\n+\n+    private String baseUrl;\n+    private @Nullable String auth = null;\n+\n+    private @Nullable Thread m_pollThread = null;", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2NzkyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387667925", "bodyText": "This works and not worth the effort to change", "author": "robnielsen", "createdAt": "2020-03-04T13:33:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MDczMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MDk3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386740973", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(HubIOStream.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(HubIOStream.class);", "author": "cpmeister", "createdAt": "2020-03-03T00:56:00Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/hub/HubIOStream.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver.hub;\n+\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.driver.IOStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implements IOStream for a Hub 2014 device\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ *\n+ */\n+@NonNullByDefault\n+public class HubIOStream extends IOStream implements Runnable {\n+    private static final Logger logger = LoggerFactory.getLogger(HubIOStream.class);", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzOTA2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390039069", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-10T00:53:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MDk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MTQ4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386741482", "bodyText": "Couldn't this whole class be replaced with a scheduler?", "author": "cpmeister", "createdAt": "2020-03-03T00:57:41Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/Poller.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.sql.Date;\n+import java.util.Iterator;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class manages the polling of all devices.\n+ * Between successive polls of a any device there is a quiet time of\n+ * at least MIN_MSEC_BETWEEN_POLLS. This avoids bunching up of poll messages\n+ * and keeps the network bandwidth open for other messages.\n+ *\n+ * - An entry in the poll queue corresponds to a single device, i.e. each device should\n+ * have exactly one entry in the poll queue. That entry is created when startPolling()\n+ * is called, and then re-enqueued whenever it expires.\n+ * - When a device comes up for polling, its doPoll() method is called, which in turn\n+ * puts an entry into that devices request queue. So the Poller class actually never\n+ * sends out messages directly. That is done by the device itself via its request\n+ * queue. The poller just reminds the device to poll.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class Poller {", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2NzM5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387667393", "bodyText": "This works and has been this way forever, not worth changing and breaking something", "author": "robnielsen", "createdAt": "2020-03-04T13:32:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MTQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NDk3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386744971", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.info(\"reader thread exiting!\");\n          \n          \n            \n                        logger.debug(\"reader thread exiting!\");", "author": "cpmeister", "createdAt": "2020-03-03T01:09:39Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/Port.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.ModemDBBuilder;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgFactory;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Port class represents a port, that is a connection to either an Insteon modem either through\n+ * a serial or USB port, or via an Insteon Hub.\n+ * It does the initialization of the port, and (via its inner classes IOStreamReader and IOStreamWriter)\n+ * manages the reading/writing of messages on the Insteon network.\n+ *\n+ * The IOStreamReader and IOStreamWriter class combined implement the somewhat tricky flow control protocol.\n+ * In combination with the MsgFactory class, the incoming data stream is turned into a Msg structure\n+ * for further processing by the upper layers (MsgListeners).\n+ *\n+ * A write queue is maintained to pace the flow of outgoing messages. Sending messages back-to-back\n+ * can lead to dropped messages.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class Port {\n+    private static final Logger logger = LoggerFactory.getLogger(Port.class);\n+\n+    /**\n+     * The ReplyType is used to keep track of the state of the serial port receiver\n+     */\n+    enum ReplyType {\n+        GOT_ACK,\n+        WAITING_FOR_ACK,\n+        GOT_NACK\n+    }\n+\n+    private IOStream m_ioStream;\n+    private String m_devName;\n+    private String m_logName;\n+    private Modem m_modem;\n+    private IOStreamReader m_reader;\n+    private IOStreamWriter m_writer;\n+    private final int m_readSize = 1024; // read buffer size\n+    private @Nullable Thread m_readThread = null;\n+    private @Nullable Thread m_writeThread = null;\n+    private boolean m_running = false;\n+    private boolean m_modemDBComplete = false;\n+    private MsgFactory m_msgFactory = new MsgFactory();\n+    private Driver m_driver;\n+    private ModemDBBuilder m_mdbb;\n+    private ArrayList<MsgListener> m_listeners = new ArrayList<MsgListener>();\n+    private LinkedBlockingQueue<Msg> m_writeQueue = new LinkedBlockingQueue<Msg>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param devName the name of the port, i.e. '/dev/insteon'\n+     * @param d The Driver object that manages this port\n+     */\n+    public Port(String devName, Driver d) {\n+        m_devName = devName;\n+        m_driver = d;\n+        m_logName = devName;\n+        m_modem = new Modem();\n+        addListener(m_modem);\n+        m_ioStream = IOStream.s_create(devName);\n+        m_reader = new IOStreamReader();\n+        m_writer = new IOStreamWriter();\n+        m_mdbb = new ModemDBBuilder(this);\n+    }\n+\n+    public synchronized boolean isModemDBComplete() {\n+        return (m_modemDBComplete);\n+    }\n+\n+    public boolean isRunning() {\n+        return m_running;\n+    }\n+\n+    public InsteonAddress getAddress() {\n+        return m_modem.getAddress();\n+    }\n+\n+    public String getDeviceName() {\n+        return m_devName;\n+    }\n+\n+    public Driver getDriver() {\n+        return m_driver;\n+    }\n+\n+    public void setModemDBRetryTimeout(int timeout) {\n+        m_mdbb.setRetryTimeout(timeout);\n+    }\n+\n+    public void addListener(MsgListener l) {\n+        synchronized (m_listeners) {\n+            if (!m_listeners.contains(l)) {\n+                m_listeners.add(l);\n+            }\n+        }\n+    }\n+\n+    public void removeListener(MsgListener l) {\n+        synchronized (m_listeners) {\n+            if (m_listeners.remove(l)) {\n+                // logger.debug(\"removed listener from port\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Clear modem database that has been queried so far.\n+     */\n+    public void clearModemDB() {\n+        logger.debug(\"clearing modem db!\");\n+        HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = getDriver().lockModemDBEntries();\n+        dbes.clear();\n+        getDriver().unlockModemDBEntries();\n+    }\n+\n+    /**\n+     * Starts threads necessary for reading and writing\n+     */\n+    public void start() {\n+        logger.debug(\"starting port {}\", m_logName);\n+        if (m_running) {\n+            logger.debug(\"port {} already running, not started again\", m_logName);\n+        }\n+        if (!m_ioStream.open()) {\n+            logger.debug(\"failed to open port {}\", m_logName);\n+            return;\n+        }\n+        m_readThread = new Thread(m_reader);\n+        m_writeThread = new Thread(m_writer);\n+        m_readThread.setName(m_logName + \" Reader\");\n+        m_writeThread.setName(m_logName + \" Writer\");\n+        m_readThread.start();\n+        m_writeThread.start();\n+        m_modem.initialize();\n+        m_mdbb.start(); // start downloading the device list\n+        m_running = true;\n+    }\n+\n+    /**\n+     * Stops all threads\n+     */\n+    public void stop() {\n+        if (!m_running) {\n+            logger.debug(\"port {} not running, no need to stop it\", m_logName);\n+            return;\n+        }\n+\n+        m_running = false;\n+        m_ioStream.stop();\n+        m_ioStream.close();\n+\n+        if (m_readThread != null) {\n+            m_readThread.interrupt();\n+        }\n+        if (m_writeThread != null) {\n+            m_writeThread.interrupt();\n+        }\n+        logger.debug(\"waiting for read thread to exit for port {}\", m_logName);\n+        try {\n+            if (m_readThread != null) {\n+                m_readThread.join();\n+            }\n+        } catch (InterruptedException e) {\n+            logger.debug(\"got interrupted waiting for read thread to exit.\");\n+        }\n+        logger.debug(\"waiting for write thread to exit for port {}\", m_logName);\n+        try {\n+            if (m_writeThread != null) {\n+                m_writeThread.join();\n+            }\n+        } catch (InterruptedException e) {\n+            logger.debug(\"got interrupted waiting for write thread to exit.\");\n+        }\n+        logger.debug(\"all threads for port {} stopped.\", m_logName);\n+        synchronized (m_listeners) {\n+            m_listeners.clear();\n+        }\n+    }\n+\n+    /**\n+     * Adds message to the write queue\n+     *\n+     * @param m message to be added to the write queue\n+     * @throws IOException\n+     */\n+    public void writeMessage(@Nullable Msg m) throws IOException {\n+        if (m == null) {\n+            logger.warn(\"trying to write null message!\");\n+            throw new IOException(\"trying to write null message!\");\n+        }\n+        if (m.getData() == null) {\n+            logger.warn(\"trying to write message without data!\");\n+            throw new IOException(\"trying to write message without data!\");\n+        }\n+        try {\n+            m_writeQueue.add(m);\n+            logger.trace(\"enqueued msg: {}\", m);\n+        } catch (IllegalStateException e) {\n+            logger.warn(\"cannot write message {}, write queue is full!\", m);\n+        }\n+\n+    }\n+\n+    /**\n+     * Gets called by the modem database builder when the modem database is complete\n+     */\n+    public void modemDBComplete() {\n+        synchronized (this) {\n+            m_modemDBComplete = true;\n+        }\n+        m_driver.modemDBComplete(this);\n+    }\n+\n+    /**\n+     * The IOStreamReader uses the MsgFactory to turn the incoming bytes into\n+     * Msgs for the listeners. It also communicates with the IOStreamWriter\n+     * to implement flow control (tell the IOStreamWriter that it needs to retransmit,\n+     * or the reply message has been received correctly).\n+     *\n+     * @author Bernd Pfrommer - Initial contribution\n+     */\n+    @NonNullByDefault\n+    class IOStreamReader implements Runnable {\n+\n+        private ReplyType m_reply = ReplyType.GOT_ACK;\n+        private Object m_replyLock = new Object();\n+        private boolean m_dropRandomBytes = false; // set to true for fault injection\n+\n+        /**\n+         * Helper function for implementing synchronization between reader and writer\n+         *\n+         * @return reference to the RequesReplyLock\n+         */\n+        public Object getRequestReplyLock() {\n+            return m_replyLock;\n+        }\n+\n+        @Override\n+        public void run() {\n+            logger.debug(\"starting reader...\");\n+            byte[] buffer = new byte[2 * m_readSize];\n+            Random rng = new Random();\n+            try {\n+                for (int len = -1; (len = m_ioStream.read(buffer, 0, m_readSize)) > 0;) {\n+                    if (m_dropRandomBytes && rng.nextInt(100) < 20) {\n+                        len = dropBytes(buffer, len);\n+                    }\n+                    m_msgFactory.addData(buffer, len);\n+                    processMessages();\n+                }\n+            } catch (InterruptedException e) {\n+                logger.debug(\"reader thread got interrupted!\");\n+            }\n+            logger.info(\"reader thread exiting!\");", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzNjA4NA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390036084", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-10T00:41:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NDk3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NzIyMw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386747223", "bodyText": "An InterruptException might clear the interrupt flag of the running thread and you can't expect that the running thread is going to be interrupted multiple times. I would change this logic to make sure that if it gets interrupted while joining the m_readThread that it either reinterrupts itself or it bails out early.", "author": "cpmeister", "createdAt": "2020-03-03T01:17:02Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/Port.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.ModemDBBuilder;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgFactory;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Port class represents a port, that is a connection to either an Insteon modem either through\n+ * a serial or USB port, or via an Insteon Hub.\n+ * It does the initialization of the port, and (via its inner classes IOStreamReader and IOStreamWriter)\n+ * manages the reading/writing of messages on the Insteon network.\n+ *\n+ * The IOStreamReader and IOStreamWriter class combined implement the somewhat tricky flow control protocol.\n+ * In combination with the MsgFactory class, the incoming data stream is turned into a Msg structure\n+ * for further processing by the upper layers (MsgListeners).\n+ *\n+ * A write queue is maintained to pace the flow of outgoing messages. Sending messages back-to-back\n+ * can lead to dropped messages.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class Port {\n+    private static final Logger logger = LoggerFactory.getLogger(Port.class);\n+\n+    /**\n+     * The ReplyType is used to keep track of the state of the serial port receiver\n+     */\n+    enum ReplyType {\n+        GOT_ACK,\n+        WAITING_FOR_ACK,\n+        GOT_NACK\n+    }\n+\n+    private IOStream m_ioStream;\n+    private String m_devName;\n+    private String m_logName;\n+    private Modem m_modem;\n+    private IOStreamReader m_reader;\n+    private IOStreamWriter m_writer;\n+    private final int m_readSize = 1024; // read buffer size\n+    private @Nullable Thread m_readThread = null;\n+    private @Nullable Thread m_writeThread = null;\n+    private boolean m_running = false;\n+    private boolean m_modemDBComplete = false;\n+    private MsgFactory m_msgFactory = new MsgFactory();\n+    private Driver m_driver;\n+    private ModemDBBuilder m_mdbb;\n+    private ArrayList<MsgListener> m_listeners = new ArrayList<MsgListener>();\n+    private LinkedBlockingQueue<Msg> m_writeQueue = new LinkedBlockingQueue<Msg>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param devName the name of the port, i.e. '/dev/insteon'\n+     * @param d The Driver object that manages this port\n+     */\n+    public Port(String devName, Driver d) {\n+        m_devName = devName;\n+        m_driver = d;\n+        m_logName = devName;\n+        m_modem = new Modem();\n+        addListener(m_modem);\n+        m_ioStream = IOStream.s_create(devName);\n+        m_reader = new IOStreamReader();\n+        m_writer = new IOStreamWriter();\n+        m_mdbb = new ModemDBBuilder(this);\n+    }\n+\n+    public synchronized boolean isModemDBComplete() {\n+        return (m_modemDBComplete);\n+    }\n+\n+    public boolean isRunning() {\n+        return m_running;\n+    }\n+\n+    public InsteonAddress getAddress() {\n+        return m_modem.getAddress();\n+    }\n+\n+    public String getDeviceName() {\n+        return m_devName;\n+    }\n+\n+    public Driver getDriver() {\n+        return m_driver;\n+    }\n+\n+    public void setModemDBRetryTimeout(int timeout) {\n+        m_mdbb.setRetryTimeout(timeout);\n+    }\n+\n+    public void addListener(MsgListener l) {\n+        synchronized (m_listeners) {\n+            if (!m_listeners.contains(l)) {\n+                m_listeners.add(l);\n+            }\n+        }\n+    }\n+\n+    public void removeListener(MsgListener l) {\n+        synchronized (m_listeners) {\n+            if (m_listeners.remove(l)) {\n+                // logger.debug(\"removed listener from port\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Clear modem database that has been queried so far.\n+     */\n+    public void clearModemDB() {\n+        logger.debug(\"clearing modem db!\");\n+        HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = getDriver().lockModemDBEntries();\n+        dbes.clear();\n+        getDriver().unlockModemDBEntries();\n+    }\n+\n+    /**\n+     * Starts threads necessary for reading and writing\n+     */\n+    public void start() {\n+        logger.debug(\"starting port {}\", m_logName);\n+        if (m_running) {\n+            logger.debug(\"port {} already running, not started again\", m_logName);\n+        }\n+        if (!m_ioStream.open()) {\n+            logger.debug(\"failed to open port {}\", m_logName);\n+            return;\n+        }\n+        m_readThread = new Thread(m_reader);\n+        m_writeThread = new Thread(m_writer);\n+        m_readThread.setName(m_logName + \" Reader\");\n+        m_writeThread.setName(m_logName + \" Writer\");\n+        m_readThread.start();\n+        m_writeThread.start();\n+        m_modem.initialize();\n+        m_mdbb.start(); // start downloading the device list\n+        m_running = true;\n+    }\n+\n+    /**\n+     * Stops all threads\n+     */\n+    public void stop() {\n+        if (!m_running) {\n+            logger.debug(\"port {} not running, no need to stop it\", m_logName);\n+            return;\n+        }\n+\n+        m_running = false;\n+        m_ioStream.stop();\n+        m_ioStream.close();\n+\n+        if (m_readThread != null) {\n+            m_readThread.interrupt();\n+        }\n+        if (m_writeThread != null) {\n+            m_writeThread.interrupt();\n+        }\n+        logger.debug(\"waiting for read thread to exit for port {}\", m_logName);\n+        try {\n+            if (m_readThread != null) {\n+                m_readThread.join();\n+            }\n+        } catch (InterruptedException e) {\n+            logger.debug(\"got interrupted waiting for read thread to exit.\");\n+        }\n+        logger.debug(\"waiting for write thread to exit for port {}\", m_logName);\n+        try {\n+            if (m_writeThread != null) {\n+                m_writeThread.join();\n+            }\n+        } catch (InterruptedException e) {\n+            logger.debug(\"got interrupted waiting for write thread to exit.\");\n+        }", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzOTQ2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390039467", "bodyText": "I'm going to leave as is. The threads will exit since the streams were closed.", "author": "robnielsen", "createdAt": "2020-03-10T00:54:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NzIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0OTAzMw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386749033", "bodyText": "shouldn't this be?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        InputStream input = DeviceTypeLoader.class.getResourceAsStream(\"/device_types.xml\");\n          \n          \n            \n                        InputStream input = FrameworkUtil.getBundle(DeviceTypeLoader.class).getResource(\"/device_types.xml\").openStream();", "author": "cpmeister", "createdAt": "2020-03-03T01:23:07Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceTypeLoader.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.HashMap;\n+import java.util.Map.Entry;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.DeviceType.FeatureGroup;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * Reads the device types from an xml file.\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class DeviceTypeLoader {\n+    private static final Logger logger = LoggerFactory.getLogger(DeviceTypeLoader.class);\n+    private HashMap<String, DeviceType> m_deviceTypes = new HashMap<String, DeviceType>();\n+    private @Nullable static DeviceTypeLoader s_deviceTypeLoader = null;\n+\n+    private DeviceTypeLoader() {\n+    } // private so nobody can call it\n+\n+    /**\n+     * Finds the device type for a given product key\n+     *\n+     * @param aProdKey product key to search for\n+     * @return the device type, or null if not found\n+     */\n+    public @Nullable DeviceType getDeviceType(String aProdKey) {\n+        return (m_deviceTypes.get(aProdKey));\n+    }\n+\n+    /**\n+     * Must call loadDeviceTypesXML() before calling this function!\n+     *\n+     * @return currently known device types\n+     */\n+    public HashMap<String, DeviceType> getDeviceTypes() {\n+        return (m_deviceTypes);\n+    }\n+\n+    /**\n+     * Reads the device types from input stream and stores them in memory for\n+     * later access.\n+     *\n+     * @param is the input stream from which to read\n+     */\n+    public void loadDeviceTypesXML(InputStream in) throws ParserConfigurationException, SAXException, IOException {\n+        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n+        Document doc = dBuilder.parse(in);\n+        doc.getDocumentElement().normalize();\n+        Node root = doc.getDocumentElement();\n+        NodeList nodes = root.getChildNodes();\n+        for (int i = 0; i < nodes.getLength(); i++) {\n+            Node node = nodes.item(i);\n+            if (node.getNodeType() == Node.ELEMENT_NODE && node.getNodeName().equals(\"device\")) {\n+                processDevice((Element) node);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reads the device types from file and stores them in memory for later access.\n+     *\n+     * @param aFileName The name of the file to read from\n+     * @throws ParserConfigurationException\n+     * @throws SAXException\n+     * @throws IOException\n+     */\n+    public void loadDeviceTypesXML(String aFileName) throws ParserConfigurationException, SAXException, IOException {\n+        File file = new File(aFileName);\n+        InputStream in = new FileInputStream(file);\n+        loadDeviceTypesXML(in);\n+    }\n+\n+    /**\n+     * Process device node\n+     *\n+     * @param e name of the element to process\n+     * @throws SAXException\n+     */\n+    private void processDevice(Element e) throws SAXException {\n+        String productKey = e.getAttribute(\"productKey\");\n+        if (productKey.equals(\"\")) {\n+            throw new SAXException(\"device in device_types file has no product key!\");\n+        }\n+        if (m_deviceTypes.containsKey(productKey)) {\n+            logger.warn(\"overwriting previous definition of device {}\", productKey);\n+            m_deviceTypes.remove(productKey);\n+        }\n+        DeviceType devType = new DeviceType(productKey);\n+\n+        NodeList nodes = e.getChildNodes();\n+        for (int i = 0; i < nodes.getLength(); i++) {\n+            Node node = nodes.item(i);\n+            if (node.getNodeType() != Node.ELEMENT_NODE) {\n+                continue;\n+            }\n+            Element subElement = (Element) node;\n+            if (subElement.getNodeName().equals(\"model\")) {\n+                devType.setModel(subElement.getTextContent());\n+            } else if (subElement.getNodeName().equals(\"description\")) {\n+                devType.setDescription(subElement.getTextContent());\n+            } else if (subElement.getNodeName().equals(\"feature\")) {\n+                processFeature(devType, subElement);\n+            } else if (subElement.getNodeName().equals(\"feature_group\")) {\n+                processFeatureGroup(devType, subElement);\n+            }\n+            m_deviceTypes.put(productKey, devType);\n+        }\n+    }\n+\n+    private String processFeature(DeviceType devType, Element e) throws SAXException {\n+        String name = e.getAttribute(\"name\");\n+        if (name.equals(\"\")) {\n+            throw new SAXException(\"feature \" + e.getNodeName() + \" has feature without name!\");\n+        }\n+        if (!name.equals(name.toLowerCase())) {\n+            throw new SAXException(\"feature name '\" + name + \"' must be lower case\");\n+        }\n+        if (!devType.addFeature(name, e.getTextContent())) {\n+            throw new SAXException(\"duplicate feature: \" + name);\n+        }\n+        return (name);\n+    }\n+\n+    private String processFeatureGroup(DeviceType devType, Element e) throws SAXException {\n+        String name = e.getAttribute(\"name\");\n+        if (name.equals(\"\")) {\n+            throw new SAXException(\"feature group \" + e.getNodeName() + \" has no name attr!\");\n+        }\n+        String type = e.getAttribute(\"type\");\n+        if (type.equals(\"\")) {\n+            throw new SAXException(\"feature group \" + e.getNodeName() + \" has no type attr!\");\n+        }\n+        FeatureGroup fg = new FeatureGroup(name, type);\n+        NodeList nodes = e.getChildNodes();\n+        for (int i = 0; i < nodes.getLength(); i++) {\n+            Node node = nodes.item(i);\n+            if (node.getNodeType() != Node.ELEMENT_NODE) {\n+                continue;\n+            }\n+            Element subElement = (Element) node;\n+            if (subElement.getNodeName().equals(\"feature\")) {\n+                fg.addFeature(processFeature(devType, subElement));\n+            } else if (subElement.getNodeName().equals(\"feature_group\")) {\n+                fg.addFeature(processFeatureGroup(devType, subElement));\n+            }\n+        }\n+        if (!devType.addFeatureGroup(name, fg)) {\n+            throw new SAXException(\"duplicate feature group \" + name);\n+        }\n+        return (name);\n+    }\n+\n+    /**\n+     * Helper function for debugging\n+     */\n+    private void logDeviceTypes() {\n+        for (Entry<String, DeviceType> dt : getDeviceTypes().entrySet()) {\n+            String msg = String.format(\"%-10s->\", dt.getKey()) + dt.getValue();\n+            logger.debug(\"{}\", msg);\n+        }\n+    }\n+\n+    /**\n+     * Singleton instance function, creates DeviceTypeLoader\n+     *\n+     * @return DeviceTypeLoader singleton reference\n+     */\n+    @Nullable\n+    public static synchronized DeviceTypeLoader s_instance() {\n+        if (s_deviceTypeLoader == null) {\n+            s_deviceTypeLoader = new DeviceTypeLoader();\n+            InputStream input = DeviceTypeLoader.class.getResourceAsStream(\"/device_types.xml\");", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNTgwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387435805", "bodyText": "I found your post regarding getResourceAsStream issues. Did you never experience the same issue here?", "author": "cpmeister", "createdAt": "2020-03-04T03:50:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0OTAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2MzU5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387663596", "bodyText": "This works, so doesn't need to be changed.", "author": "robnielsen", "createdAt": "2020-03-04T13:25:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0OTAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0OTM3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386749376", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"channel {} unlinked \", channelUID.getAsString());\n          \n          \n            \n                    logger.debug(\"channel {} unlinked \", channelUID.getAsString());", "author": "cpmeister", "createdAt": "2020-03-03T01:24:20Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonDeviceHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.InsteonBindingConstants;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonDeviceConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InsteonDeviceHandler extends BaseThingHandler {\n+\n+    private static final Set<String> DEFINED_CHANNELS = Collections.unmodifiableSet(Stream.of(\n+            InsteonBindingConstants.AC_DELAY, InsteonBindingConstants.BACKLIGHT_DURATION,\n+            InsteonBindingConstants.BATTERY_LEVEL, InsteonBindingConstants.BATTERY_WATERMARK_LEVEL,\n+            InsteonBindingConstants.BOTTOM_OUTLET, InsteonBindingConstants.BUTTON_A, InsteonBindingConstants.BUTTON_B,\n+            InsteonBindingConstants.BUTTON_C, InsteonBindingConstants.BUTTON_D, InsteonBindingConstants.BUTTON_E,\n+            InsteonBindingConstants.BUTTON_F, InsteonBindingConstants.BUTTON_G, InsteonBindingConstants.BUTTON_H,\n+            InsteonBindingConstants.BROADCAST_ON_OFF, InsteonBindingConstants.CONTACT,\n+            InsteonBindingConstants.COOL_SET_POINT, InsteonBindingConstants.DIMMER, InsteonBindingConstants.FAN,\n+            InsteonBindingConstants.FAN_MODE, InsteonBindingConstants.FAST_ON_OFF,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_A, InsteonBindingConstants.FAST_ON_OFF_BUTTON_B,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_C, InsteonBindingConstants.FAST_ON_OFF_BUTTON_D,\n+            InsteonBindingConstants.HEAT_SET_POINT, InsteonBindingConstants.HUMIDITY,\n+            InsteonBindingConstants.HUMIDITY_HIGH, InsteonBindingConstants.HUMIDITY_LOW,\n+            InsteonBindingConstants.IS_COOLING, InsteonBindingConstants.IS_HEATING,\n+            InsteonBindingConstants.KEYPAD_BUTTON_A, InsteonBindingConstants.KEYPAD_BUTTON_B,\n+            InsteonBindingConstants.KEYPAD_BUTTON_C, InsteonBindingConstants.KEYPAD_BUTTON_D,\n+            InsteonBindingConstants.KEYPAD_BUTTON_E, InsteonBindingConstants.KEYPAD_BUTTON_F,\n+            InsteonBindingConstants.KEYPAD_BUTTON_G, InsteonBindingConstants.KEYPAD_BUTTON_H,\n+            InsteonBindingConstants.KWH, InsteonBindingConstants.LAST_HEARD_FROM,\n+            InsteonBindingConstants.LED_BRIGHTNESS, InsteonBindingConstants.LIGHT_DIMMER,\n+            InsteonBindingConstants.LIGHT_LEVEL, InsteonBindingConstants.LOAD_DIMMER,\n+            InsteonBindingConstants.LOAD_SWITCH, InsteonBindingConstants.LOAD_SWITCH_FAST_ON_OFF,\n+            InsteonBindingConstants.LOAD_SWITCH_MANUAL_CHANGE, InsteonBindingConstants.MANUAL_CHANGE,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_A, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_B,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_C, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_D,\n+            InsteonBindingConstants.NOTIFICATION, InsteonBindingConstants.ON_LEVEL, InsteonBindingConstants.RAMP_DIMMER,\n+            InsteonBindingConstants.RAMP_RATE, InsteonBindingConstants.RESET, InsteonBindingConstants.STAGE1_DURATION,\n+            InsteonBindingConstants.SWITCH, InsteonBindingConstants.SYSTEM_MODE, InsteonBindingConstants.TEMP_CELSIUS,\n+            InsteonBindingConstants.TEMP_FAHRENHEIT, InsteonBindingConstants.TOP_OUTLET, InsteonBindingConstants.UPDATE,\n+            InsteonBindingConstants.WATTS).collect(Collectors.toSet()));\n+\n+    private static final String BROADCAST_ON_OFF = \"broadcastonoff\";\n+    private static final String CMD = \"cmd\";\n+    private static final String CMD_RESET = \"reset\";\n+    private static final String CMD_UPDATE = \"update\";\n+    private static final String DATA = \"data\";\n+    private static final String FIELD = \"field\";\n+    private static final String FIELD_BATTERY_LEVEL = \"battery_level\";\n+    private static final String FIELD_BATTERY_WATERMARK_LEVEL = \"battery_watermark_level\";\n+    private static final String FIELD_KWH = \"kwh\";\n+    private static final String FIELD_LIGHT_LEVEL = \"light_level\";\n+    private static final String FIELD_WATTS = \"watts\";\n+    private static final String GROUP = \"group\";\n+    private static final String METER = \"meter\";\n+\n+    private static final String HIDDEN_DOOR_SENSOR_PRODUCT_KEY = \"F00.00.03\";\n+    private static final String MOTION_SENSOR_PRODUCT_KEY = \"0x00004A\";\n+    private static final String PLM_PRODUCT_KEY = \"0x000045\";\n+    private static final String POWER_METER_PRODUCT_KEY = \"F00.00.17\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonDeviceHandler.class);\n+\n+    private @Nullable InsteonDeviceConfiguration config;\n+\n+    public InsteonDeviceHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(InsteonDeviceConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            if (getBridge() == null) {\n+                String msg = \"An Insteon network bridge has not been selected for this device.\";\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String address = config.getAddress();\n+            if (!InsteonAddress.s_isValid(address)) {\n+                String msg = \"Unable to start Insteon device, the insteon or X10 address '\" + address\n+                        + \"' is invalid. It must be in the format 'AB.CD.EF' or 'H.U' (X10).\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String productKey = config.getProductKey();\n+            if (DeviceTypeLoader.s_instance().getDeviceType(productKey) == null) {\n+                String msg = \"Unable to start Insteon device, invalid product key '\" + productKey + \"'.\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            InsteonBinding insteonBinding = getInsteonBinding();\n+            InsteonAddress insteonAddress = new InsteonAddress(address);\n+            if (insteonBinding.getDevice(insteonAddress) != null) {\n+                String msg = \"a device already exists with the address '\" + address + \"'.\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            InsteonDevice device = insteonBinding.makeNewDevice(insteonAddress, productKey);\n+\n+            // By default the device is assigned all channels. Channels are associated with a feature, cull the ones\n+            // that are supported by this device.\n+            StringBuffer channelList = new StringBuffer();\n+            List<Channel> supportedChannels = new ArrayList<Channel>();\n+            List<Channel> initialChannels = getThing().getChannels();\n+            String thingId = getThing().getUID().getAsString();\n+            for (Channel channel : initialChannels) {\n+                String channelId = channel.getUID().getId();\n+                String feature = channelId.toLowerCase();\n+\n+                if (productKey.equals(HIDDEN_DOOR_SENSOR_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_WATERMARK_LEVEL)) {\n+\n+                        feature = DATA;\n+                    }\n+                } else if (productKey.equals(MOTION_SENSOR_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.LIGHT_LEVEL)) {\n+\n+                        feature = DATA;\n+                    }\n+                } else if (productKey.equals(PLM_PRODUCT_KEY)) {\n+                    String parts[] = feature.split(\"#\");\n+                    if (parts.length == 2 && parts[0].equalsIgnoreCase(InsteonBindingConstants.BROADCAST_ON_OFF)\n+                            && parts[1].matches(\"^\\\\d+$\")) {\n+                        feature = BROADCAST_ON_OFF;\n+                    }\n+                } else if (productKey.equals(POWER_METER_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.KWH)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.RESET)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.UPDATE)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.WATTS)) {\n+\n+                        feature = METER;\n+                    }\n+                }\n+\n+                DeviceFeature f = device.getFeature(feature);\n+                if (f == null) {\n+                    if (!DEFINED_CHANNELS.contains(channelId)) {\n+                        logger.warn(\"{} includes channel {}, it is not a valid feature for {}. It has been removed.\",\n+                                thingId, channelId, productKey);\n+                    }\n+                } else if (f.isFeatureGroup()) {\n+                    logger.warn(\"{} includes channel {}, it is a feature group for {}. It has been removed.\", thingId,\n+                            channelId, productKey);\n+                } else {\n+                    supportedChannels.add(channel);\n+\n+                    if (channelList.length() > 0) {\n+                        channelList.append(\", \");\n+                    }\n+                    channelList.append(channelId);\n+\n+                    if (!DEFINED_CHANNELS.contains(channelId)) {\n+                        for (String c : DEFINED_CHANNELS) {\n+                            if (channelId.equalsIgnoreCase(c)) {\n+                                logger.warn(\"{} includes channel {}, should it be {}?\", thingId, channelId, c);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // only update if channels were culled\n+            if (initialChannels.size() != supportedChannels.size()) {\n+                ThingBuilder thingBuilder = editThing();\n+                thingBuilder.withChannels(supportedChannels);\n+                updateThing(thingBuilder.build());\n+            }\n+\n+            logger.info(\"{} address = {} productKey = {} channels = {}\", thingId, address, productKey,\n+                    channelList.toString());\n+\n+            updateStatus(ThingStatus.ONLINE);\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        String address = config.getAddress();\n+        if (getBridge() != null && InsteonAddress.s_isValid(address)) {\n+            getInsteonBinding().removeDevice(new InsteonAddress(address));\n+\n+            logger.info(\"removed {} address = {}\", getThing().getUID().getAsString(), address);\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.info(\"channel {} was triggered with the command {}\", channelUID.getAsString(), command);\n+\n+        getInsteonBinding().sendCommand(channelUID.getAsString(), command);\n+    }\n+\n+    @Override\n+    public void channelLinked(ChannelUID channelUID) {\n+        HashMap<String, @Nullable String> params = new HashMap<String, @Nullable String>();\n+        Channel channel = getThing().getChannel(channelUID.getId());\n+\n+        Map<String, Object> channelProperties = channel.getConfiguration().getProperties();\n+        for (String key : channelProperties.keySet()) {\n+            Object value = channelProperties.get(key);\n+            if (value instanceof String) {\n+                params.put(key, (String) value);\n+            } else if (value instanceof BigDecimal) {\n+                String s = ((BigDecimal) value).toPlainString();\n+                params.put(key, s);\n+            } else {\n+                logger.warn(\"not a string or big decimal value key '{}' value '{}' {}\", key, value,\n+                        value.getClass().getName());\n+            }\n+        }\n+\n+        String feature = channelUID.getId().toLowerCase();\n+        String productKey = config.getProductKey();\n+        if (productKey.equals(HIDDEN_DOOR_SENSOR_PRODUCT_KEY)) {\n+            if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)) {\n+                params.put(FIELD, FIELD_BATTERY_LEVEL);\n+                feature = DATA;\n+            } else if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_WATERMARK_LEVEL)) {\n+                params.put(FIELD, FIELD_BATTERY_WATERMARK_LEVEL);\n+                feature = DATA;\n+            }\n+        } else if (productKey.equals(MOTION_SENSOR_PRODUCT_KEY)) {\n+            if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)) {\n+                params.put(FIELD, FIELD_BATTERY_LEVEL);\n+                feature = DATA;\n+            } else if (feature.equalsIgnoreCase(InsteonBindingConstants.LIGHT_LEVEL)) {\n+                params.put(FIELD, FIELD_LIGHT_LEVEL);\n+                feature = DATA;\n+            }\n+        } else if (productKey.equals(PLM_PRODUCT_KEY)) {\n+            String parts[] = feature.split(\"#\");\n+            if (parts.length == 2 && parts[0].equalsIgnoreCase(InsteonBindingConstants.BROADCAST_ON_OFF)\n+                    && parts[1].matches(\"^\\\\d+$\")) {\n+                params.put(GROUP, parts[1]);\n+                feature = BROADCAST_ON_OFF;\n+            }\n+        } else if (productKey.equals(POWER_METER_PRODUCT_KEY)) {\n+            if (feature.equalsIgnoreCase(InsteonBindingConstants.KWH)) {\n+                params.put(FIELD, FIELD_KWH);\n+            } else if (feature.equalsIgnoreCase(InsteonBindingConstants.WATTS)) {\n+                params.put(FIELD, FIELD_WATTS);\n+            } else if (feature.equalsIgnoreCase(InsteonBindingConstants.RESET)) {\n+                params.put(CMD, CMD_RESET);\n+            } else if (feature.equalsIgnoreCase(InsteonBindingConstants.UPDATE)) {\n+                params.put(CMD, CMD_UPDATE);\n+            }\n+\n+            feature = METER;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = new InsteonChannelConfiguration(channelUID, feature,\n+                new InsteonAddress(config.getAddress()), productKey, params);\n+        getInsteonBinding().addFeatureListener(bindingConfig);\n+\n+        logger.info(\"channel {} linked with the feature: {} parameters: {}\", channelUID.getAsString(), feature, params);\n+    }\n+\n+    @Override\n+    public void channelUnlinked(ChannelUID channelUID) {\n+        getInsteonBinding().removeFeatureListener(channelUID);\n+\n+        logger.info(\"channel {} unlinked \", channelUID.getAsString());", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzNjI1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390036252", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-10T00:42:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0OTM3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0OTU4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386749589", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"channel {} linked with the feature: {} parameters: {}\", channelUID.getAsString(), feature, params);\n          \n          \n            \n                    logger.debug(\"channel {} linked with the feature: {} parameters: {}\", channelUID.getAsString(), feature, params);", "author": "cpmeister", "createdAt": "2020-03-03T01:25:04Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonDeviceHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.InsteonBindingConstants;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonDeviceConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InsteonDeviceHandler extends BaseThingHandler {\n+\n+    private static final Set<String> DEFINED_CHANNELS = Collections.unmodifiableSet(Stream.of(\n+            InsteonBindingConstants.AC_DELAY, InsteonBindingConstants.BACKLIGHT_DURATION,\n+            InsteonBindingConstants.BATTERY_LEVEL, InsteonBindingConstants.BATTERY_WATERMARK_LEVEL,\n+            InsteonBindingConstants.BOTTOM_OUTLET, InsteonBindingConstants.BUTTON_A, InsteonBindingConstants.BUTTON_B,\n+            InsteonBindingConstants.BUTTON_C, InsteonBindingConstants.BUTTON_D, InsteonBindingConstants.BUTTON_E,\n+            InsteonBindingConstants.BUTTON_F, InsteonBindingConstants.BUTTON_G, InsteonBindingConstants.BUTTON_H,\n+            InsteonBindingConstants.BROADCAST_ON_OFF, InsteonBindingConstants.CONTACT,\n+            InsteonBindingConstants.COOL_SET_POINT, InsteonBindingConstants.DIMMER, InsteonBindingConstants.FAN,\n+            InsteonBindingConstants.FAN_MODE, InsteonBindingConstants.FAST_ON_OFF,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_A, InsteonBindingConstants.FAST_ON_OFF_BUTTON_B,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_C, InsteonBindingConstants.FAST_ON_OFF_BUTTON_D,\n+            InsteonBindingConstants.HEAT_SET_POINT, InsteonBindingConstants.HUMIDITY,\n+            InsteonBindingConstants.HUMIDITY_HIGH, InsteonBindingConstants.HUMIDITY_LOW,\n+            InsteonBindingConstants.IS_COOLING, InsteonBindingConstants.IS_HEATING,\n+            InsteonBindingConstants.KEYPAD_BUTTON_A, InsteonBindingConstants.KEYPAD_BUTTON_B,\n+            InsteonBindingConstants.KEYPAD_BUTTON_C, InsteonBindingConstants.KEYPAD_BUTTON_D,\n+            InsteonBindingConstants.KEYPAD_BUTTON_E, InsteonBindingConstants.KEYPAD_BUTTON_F,\n+            InsteonBindingConstants.KEYPAD_BUTTON_G, InsteonBindingConstants.KEYPAD_BUTTON_H,\n+            InsteonBindingConstants.KWH, InsteonBindingConstants.LAST_HEARD_FROM,\n+            InsteonBindingConstants.LED_BRIGHTNESS, InsteonBindingConstants.LIGHT_DIMMER,\n+            InsteonBindingConstants.LIGHT_LEVEL, InsteonBindingConstants.LOAD_DIMMER,\n+            InsteonBindingConstants.LOAD_SWITCH, InsteonBindingConstants.LOAD_SWITCH_FAST_ON_OFF,\n+            InsteonBindingConstants.LOAD_SWITCH_MANUAL_CHANGE, InsteonBindingConstants.MANUAL_CHANGE,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_A, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_B,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_C, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_D,\n+            InsteonBindingConstants.NOTIFICATION, InsteonBindingConstants.ON_LEVEL, InsteonBindingConstants.RAMP_DIMMER,\n+            InsteonBindingConstants.RAMP_RATE, InsteonBindingConstants.RESET, InsteonBindingConstants.STAGE1_DURATION,\n+            InsteonBindingConstants.SWITCH, InsteonBindingConstants.SYSTEM_MODE, InsteonBindingConstants.TEMP_CELSIUS,\n+            InsteonBindingConstants.TEMP_FAHRENHEIT, InsteonBindingConstants.TOP_OUTLET, InsteonBindingConstants.UPDATE,\n+            InsteonBindingConstants.WATTS).collect(Collectors.toSet()));\n+\n+    private static final String BROADCAST_ON_OFF = \"broadcastonoff\";\n+    private static final String CMD = \"cmd\";\n+    private static final String CMD_RESET = \"reset\";\n+    private static final String CMD_UPDATE = \"update\";\n+    private static final String DATA = \"data\";\n+    private static final String FIELD = \"field\";\n+    private static final String FIELD_BATTERY_LEVEL = \"battery_level\";\n+    private static final String FIELD_BATTERY_WATERMARK_LEVEL = \"battery_watermark_level\";\n+    private static final String FIELD_KWH = \"kwh\";\n+    private static final String FIELD_LIGHT_LEVEL = \"light_level\";\n+    private static final String FIELD_WATTS = \"watts\";\n+    private static final String GROUP = \"group\";\n+    private static final String METER = \"meter\";\n+\n+    private static final String HIDDEN_DOOR_SENSOR_PRODUCT_KEY = \"F00.00.03\";\n+    private static final String MOTION_SENSOR_PRODUCT_KEY = \"0x00004A\";\n+    private static final String PLM_PRODUCT_KEY = \"0x000045\";\n+    private static final String POWER_METER_PRODUCT_KEY = \"F00.00.17\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonDeviceHandler.class);\n+\n+    private @Nullable InsteonDeviceConfiguration config;\n+\n+    public InsteonDeviceHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(InsteonDeviceConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            if (getBridge() == null) {\n+                String msg = \"An Insteon network bridge has not been selected for this device.\";\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String address = config.getAddress();\n+            if (!InsteonAddress.s_isValid(address)) {\n+                String msg = \"Unable to start Insteon device, the insteon or X10 address '\" + address\n+                        + \"' is invalid. It must be in the format 'AB.CD.EF' or 'H.U' (X10).\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String productKey = config.getProductKey();\n+            if (DeviceTypeLoader.s_instance().getDeviceType(productKey) == null) {\n+                String msg = \"Unable to start Insteon device, invalid product key '\" + productKey + \"'.\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            InsteonBinding insteonBinding = getInsteonBinding();\n+            InsteonAddress insteonAddress = new InsteonAddress(address);\n+            if (insteonBinding.getDevice(insteonAddress) != null) {\n+                String msg = \"a device already exists with the address '\" + address + \"'.\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            InsteonDevice device = insteonBinding.makeNewDevice(insteonAddress, productKey);\n+\n+            // By default the device is assigned all channels. Channels are associated with a feature, cull the ones\n+            // that are supported by this device.\n+            StringBuffer channelList = new StringBuffer();\n+            List<Channel> supportedChannels = new ArrayList<Channel>();\n+            List<Channel> initialChannels = getThing().getChannels();\n+            String thingId = getThing().getUID().getAsString();\n+            for (Channel channel : initialChannels) {\n+                String channelId = channel.getUID().getId();\n+                String feature = channelId.toLowerCase();\n+\n+                if (productKey.equals(HIDDEN_DOOR_SENSOR_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_WATERMARK_LEVEL)) {\n+\n+                        feature = DATA;\n+                    }\n+                } else if (productKey.equals(MOTION_SENSOR_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.LIGHT_LEVEL)) {\n+\n+                        feature = DATA;\n+                    }\n+                } else if (productKey.equals(PLM_PRODUCT_KEY)) {\n+                    String parts[] = feature.split(\"#\");\n+                    if (parts.length == 2 && parts[0].equalsIgnoreCase(InsteonBindingConstants.BROADCAST_ON_OFF)\n+                            && parts[1].matches(\"^\\\\d+$\")) {\n+                        feature = BROADCAST_ON_OFF;\n+                    }\n+                } else if (productKey.equals(POWER_METER_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.KWH)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.RESET)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.UPDATE)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.WATTS)) {\n+\n+                        feature = METER;\n+                    }\n+                }\n+\n+                DeviceFeature f = device.getFeature(feature);\n+                if (f == null) {\n+                    if (!DEFINED_CHANNELS.contains(channelId)) {\n+                        logger.warn(\"{} includes channel {}, it is not a valid feature for {}. It has been removed.\",\n+                                thingId, channelId, productKey);\n+                    }\n+                } else if (f.isFeatureGroup()) {\n+                    logger.warn(\"{} includes channel {}, it is a feature group for {}. It has been removed.\", thingId,\n+                            channelId, productKey);\n+                } else {\n+                    supportedChannels.add(channel);\n+\n+                    if (channelList.length() > 0) {\n+                        channelList.append(\", \");\n+                    }\n+                    channelList.append(channelId);\n+\n+                    if (!DEFINED_CHANNELS.contains(channelId)) {\n+                        for (String c : DEFINED_CHANNELS) {\n+                            if (channelId.equalsIgnoreCase(c)) {\n+                                logger.warn(\"{} includes channel {}, should it be {}?\", thingId, channelId, c);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // only update if channels were culled\n+            if (initialChannels.size() != supportedChannels.size()) {\n+                ThingBuilder thingBuilder = editThing();\n+                thingBuilder.withChannels(supportedChannels);\n+                updateThing(thingBuilder.build());\n+            }\n+\n+            logger.info(\"{} address = {} productKey = {} channels = {}\", thingId, address, productKey,\n+                    channelList.toString());\n+\n+            updateStatus(ThingStatus.ONLINE);\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        String address = config.getAddress();\n+        if (getBridge() != null && InsteonAddress.s_isValid(address)) {\n+            getInsteonBinding().removeDevice(new InsteonAddress(address));\n+\n+            logger.info(\"removed {} address = {}\", getThing().getUID().getAsString(), address);\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.info(\"channel {} was triggered with the command {}\", channelUID.getAsString(), command);\n+\n+        getInsteonBinding().sendCommand(channelUID.getAsString(), command);\n+    }\n+\n+    @Override\n+    public void channelLinked(ChannelUID channelUID) {\n+        HashMap<String, @Nullable String> params = new HashMap<String, @Nullable String>();\n+        Channel channel = getThing().getChannel(channelUID.getId());\n+\n+        Map<String, Object> channelProperties = channel.getConfiguration().getProperties();\n+        for (String key : channelProperties.keySet()) {\n+            Object value = channelProperties.get(key);\n+            if (value instanceof String) {\n+                params.put(key, (String) value);\n+            } else if (value instanceof BigDecimal) {\n+                String s = ((BigDecimal) value).toPlainString();\n+                params.put(key, s);\n+            } else {\n+                logger.warn(\"not a string or big decimal value key '{}' value '{}' {}\", key, value,\n+                        value.getClass().getName());\n+            }\n+        }\n+\n+        String feature = channelUID.getId().toLowerCase();\n+        String productKey = config.getProductKey();\n+        if (productKey.equals(HIDDEN_DOOR_SENSOR_PRODUCT_KEY)) {\n+            if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)) {\n+                params.put(FIELD, FIELD_BATTERY_LEVEL);\n+                feature = DATA;\n+            } else if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_WATERMARK_LEVEL)) {\n+                params.put(FIELD, FIELD_BATTERY_WATERMARK_LEVEL);\n+                feature = DATA;\n+            }\n+        } else if (productKey.equals(MOTION_SENSOR_PRODUCT_KEY)) {\n+            if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)) {\n+                params.put(FIELD, FIELD_BATTERY_LEVEL);\n+                feature = DATA;\n+            } else if (feature.equalsIgnoreCase(InsteonBindingConstants.LIGHT_LEVEL)) {\n+                params.put(FIELD, FIELD_LIGHT_LEVEL);\n+                feature = DATA;\n+            }\n+        } else if (productKey.equals(PLM_PRODUCT_KEY)) {\n+            String parts[] = feature.split(\"#\");\n+            if (parts.length == 2 && parts[0].equalsIgnoreCase(InsteonBindingConstants.BROADCAST_ON_OFF)\n+                    && parts[1].matches(\"^\\\\d+$\")) {\n+                params.put(GROUP, parts[1]);\n+                feature = BROADCAST_ON_OFF;\n+            }\n+        } else if (productKey.equals(POWER_METER_PRODUCT_KEY)) {\n+            if (feature.equalsIgnoreCase(InsteonBindingConstants.KWH)) {\n+                params.put(FIELD, FIELD_KWH);\n+            } else if (feature.equalsIgnoreCase(InsteonBindingConstants.WATTS)) {\n+                params.put(FIELD, FIELD_WATTS);\n+            } else if (feature.equalsIgnoreCase(InsteonBindingConstants.RESET)) {\n+                params.put(CMD, CMD_RESET);\n+            } else if (feature.equalsIgnoreCase(InsteonBindingConstants.UPDATE)) {\n+                params.put(CMD, CMD_UPDATE);\n+            }\n+\n+            feature = METER;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = new InsteonChannelConfiguration(channelUID, feature,\n+                new InsteonAddress(config.getAddress()), productKey, params);\n+        getInsteonBinding().addFeatureListener(bindingConfig);\n+\n+        logger.info(\"channel {} linked with the feature: {} parameters: {}\", channelUID.getAsString(), feature, params);", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzNjMzNw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390036337", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-10T00:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0OTU4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0OTc4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386749782", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.info(\"{} address = {} productKey = {} channels = {}\", thingId, address, productKey,\n          \n          \n            \n                        logger.debug(\"{} address = {} productKey = {} channels = {}\", thingId, address, productKey,", "author": "cpmeister", "createdAt": "2020-03-03T01:25:37Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonDeviceHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.InsteonBindingConstants;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonDeviceConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InsteonDeviceHandler extends BaseThingHandler {\n+\n+    private static final Set<String> DEFINED_CHANNELS = Collections.unmodifiableSet(Stream.of(\n+            InsteonBindingConstants.AC_DELAY, InsteonBindingConstants.BACKLIGHT_DURATION,\n+            InsteonBindingConstants.BATTERY_LEVEL, InsteonBindingConstants.BATTERY_WATERMARK_LEVEL,\n+            InsteonBindingConstants.BOTTOM_OUTLET, InsteonBindingConstants.BUTTON_A, InsteonBindingConstants.BUTTON_B,\n+            InsteonBindingConstants.BUTTON_C, InsteonBindingConstants.BUTTON_D, InsteonBindingConstants.BUTTON_E,\n+            InsteonBindingConstants.BUTTON_F, InsteonBindingConstants.BUTTON_G, InsteonBindingConstants.BUTTON_H,\n+            InsteonBindingConstants.BROADCAST_ON_OFF, InsteonBindingConstants.CONTACT,\n+            InsteonBindingConstants.COOL_SET_POINT, InsteonBindingConstants.DIMMER, InsteonBindingConstants.FAN,\n+            InsteonBindingConstants.FAN_MODE, InsteonBindingConstants.FAST_ON_OFF,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_A, InsteonBindingConstants.FAST_ON_OFF_BUTTON_B,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_C, InsteonBindingConstants.FAST_ON_OFF_BUTTON_D,\n+            InsteonBindingConstants.HEAT_SET_POINT, InsteonBindingConstants.HUMIDITY,\n+            InsteonBindingConstants.HUMIDITY_HIGH, InsteonBindingConstants.HUMIDITY_LOW,\n+            InsteonBindingConstants.IS_COOLING, InsteonBindingConstants.IS_HEATING,\n+            InsteonBindingConstants.KEYPAD_BUTTON_A, InsteonBindingConstants.KEYPAD_BUTTON_B,\n+            InsteonBindingConstants.KEYPAD_BUTTON_C, InsteonBindingConstants.KEYPAD_BUTTON_D,\n+            InsteonBindingConstants.KEYPAD_BUTTON_E, InsteonBindingConstants.KEYPAD_BUTTON_F,\n+            InsteonBindingConstants.KEYPAD_BUTTON_G, InsteonBindingConstants.KEYPAD_BUTTON_H,\n+            InsteonBindingConstants.KWH, InsteonBindingConstants.LAST_HEARD_FROM,\n+            InsteonBindingConstants.LED_BRIGHTNESS, InsteonBindingConstants.LIGHT_DIMMER,\n+            InsteonBindingConstants.LIGHT_LEVEL, InsteonBindingConstants.LOAD_DIMMER,\n+            InsteonBindingConstants.LOAD_SWITCH, InsteonBindingConstants.LOAD_SWITCH_FAST_ON_OFF,\n+            InsteonBindingConstants.LOAD_SWITCH_MANUAL_CHANGE, InsteonBindingConstants.MANUAL_CHANGE,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_A, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_B,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_C, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_D,\n+            InsteonBindingConstants.NOTIFICATION, InsteonBindingConstants.ON_LEVEL, InsteonBindingConstants.RAMP_DIMMER,\n+            InsteonBindingConstants.RAMP_RATE, InsteonBindingConstants.RESET, InsteonBindingConstants.STAGE1_DURATION,\n+            InsteonBindingConstants.SWITCH, InsteonBindingConstants.SYSTEM_MODE, InsteonBindingConstants.TEMP_CELSIUS,\n+            InsteonBindingConstants.TEMP_FAHRENHEIT, InsteonBindingConstants.TOP_OUTLET, InsteonBindingConstants.UPDATE,\n+            InsteonBindingConstants.WATTS).collect(Collectors.toSet()));\n+\n+    private static final String BROADCAST_ON_OFF = \"broadcastonoff\";\n+    private static final String CMD = \"cmd\";\n+    private static final String CMD_RESET = \"reset\";\n+    private static final String CMD_UPDATE = \"update\";\n+    private static final String DATA = \"data\";\n+    private static final String FIELD = \"field\";\n+    private static final String FIELD_BATTERY_LEVEL = \"battery_level\";\n+    private static final String FIELD_BATTERY_WATERMARK_LEVEL = \"battery_watermark_level\";\n+    private static final String FIELD_KWH = \"kwh\";\n+    private static final String FIELD_LIGHT_LEVEL = \"light_level\";\n+    private static final String FIELD_WATTS = \"watts\";\n+    private static final String GROUP = \"group\";\n+    private static final String METER = \"meter\";\n+\n+    private static final String HIDDEN_DOOR_SENSOR_PRODUCT_KEY = \"F00.00.03\";\n+    private static final String MOTION_SENSOR_PRODUCT_KEY = \"0x00004A\";\n+    private static final String PLM_PRODUCT_KEY = \"0x000045\";\n+    private static final String POWER_METER_PRODUCT_KEY = \"F00.00.17\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonDeviceHandler.class);\n+\n+    private @Nullable InsteonDeviceConfiguration config;\n+\n+    public InsteonDeviceHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(InsteonDeviceConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            if (getBridge() == null) {\n+                String msg = \"An Insteon network bridge has not been selected for this device.\";\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String address = config.getAddress();\n+            if (!InsteonAddress.s_isValid(address)) {\n+                String msg = \"Unable to start Insteon device, the insteon or X10 address '\" + address\n+                        + \"' is invalid. It must be in the format 'AB.CD.EF' or 'H.U' (X10).\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String productKey = config.getProductKey();\n+            if (DeviceTypeLoader.s_instance().getDeviceType(productKey) == null) {\n+                String msg = \"Unable to start Insteon device, invalid product key '\" + productKey + \"'.\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            InsteonBinding insteonBinding = getInsteonBinding();\n+            InsteonAddress insteonAddress = new InsteonAddress(address);\n+            if (insteonBinding.getDevice(insteonAddress) != null) {\n+                String msg = \"a device already exists with the address '\" + address + \"'.\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            InsteonDevice device = insteonBinding.makeNewDevice(insteonAddress, productKey);\n+\n+            // By default the device is assigned all channels. Channels are associated with a feature, cull the ones\n+            // that are supported by this device.\n+            StringBuffer channelList = new StringBuffer();\n+            List<Channel> supportedChannels = new ArrayList<Channel>();\n+            List<Channel> initialChannels = getThing().getChannels();\n+            String thingId = getThing().getUID().getAsString();\n+            for (Channel channel : initialChannels) {\n+                String channelId = channel.getUID().getId();\n+                String feature = channelId.toLowerCase();\n+\n+                if (productKey.equals(HIDDEN_DOOR_SENSOR_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_WATERMARK_LEVEL)) {\n+\n+                        feature = DATA;\n+                    }\n+                } else if (productKey.equals(MOTION_SENSOR_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.LIGHT_LEVEL)) {\n+\n+                        feature = DATA;\n+                    }\n+                } else if (productKey.equals(PLM_PRODUCT_KEY)) {\n+                    String parts[] = feature.split(\"#\");\n+                    if (parts.length == 2 && parts[0].equalsIgnoreCase(InsteonBindingConstants.BROADCAST_ON_OFF)\n+                            && parts[1].matches(\"^\\\\d+$\")) {\n+                        feature = BROADCAST_ON_OFF;\n+                    }\n+                } else if (productKey.equals(POWER_METER_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.KWH)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.RESET)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.UPDATE)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.WATTS)) {\n+\n+                        feature = METER;\n+                    }\n+                }\n+\n+                DeviceFeature f = device.getFeature(feature);\n+                if (f == null) {\n+                    if (!DEFINED_CHANNELS.contains(channelId)) {\n+                        logger.warn(\"{} includes channel {}, it is not a valid feature for {}. It has been removed.\",\n+                                thingId, channelId, productKey);\n+                    }\n+                } else if (f.isFeatureGroup()) {\n+                    logger.warn(\"{} includes channel {}, it is a feature group for {}. It has been removed.\", thingId,\n+                            channelId, productKey);\n+                } else {\n+                    supportedChannels.add(channel);\n+\n+                    if (channelList.length() > 0) {\n+                        channelList.append(\", \");\n+                    }\n+                    channelList.append(channelId);\n+\n+                    if (!DEFINED_CHANNELS.contains(channelId)) {\n+                        for (String c : DEFINED_CHANNELS) {\n+                            if (channelId.equalsIgnoreCase(c)) {\n+                                logger.warn(\"{} includes channel {}, should it be {}?\", thingId, channelId, c);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // only update if channels were culled\n+            if (initialChannels.size() != supportedChannels.size()) {\n+                ThingBuilder thingBuilder = editThing();\n+                thingBuilder.withChannels(supportedChannels);\n+                updateThing(thingBuilder.build());\n+            }\n+\n+            logger.info(\"{} address = {} productKey = {} channels = {}\", thingId, address, productKey,", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzNjQyMA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390036420", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-10T00:43:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0OTc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MDA5MA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386750090", "bodyText": "see above", "author": "cpmeister", "createdAt": "2020-03-03T01:26:41Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonDeviceHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.InsteonBindingConstants;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonDeviceConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InsteonDeviceHandler extends BaseThingHandler {\n+\n+    private static final Set<String> DEFINED_CHANNELS = Collections.unmodifiableSet(Stream.of(\n+            InsteonBindingConstants.AC_DELAY, InsteonBindingConstants.BACKLIGHT_DURATION,\n+            InsteonBindingConstants.BATTERY_LEVEL, InsteonBindingConstants.BATTERY_WATERMARK_LEVEL,\n+            InsteonBindingConstants.BOTTOM_OUTLET, InsteonBindingConstants.BUTTON_A, InsteonBindingConstants.BUTTON_B,\n+            InsteonBindingConstants.BUTTON_C, InsteonBindingConstants.BUTTON_D, InsteonBindingConstants.BUTTON_E,\n+            InsteonBindingConstants.BUTTON_F, InsteonBindingConstants.BUTTON_G, InsteonBindingConstants.BUTTON_H,\n+            InsteonBindingConstants.BROADCAST_ON_OFF, InsteonBindingConstants.CONTACT,\n+            InsteonBindingConstants.COOL_SET_POINT, InsteonBindingConstants.DIMMER, InsteonBindingConstants.FAN,\n+            InsteonBindingConstants.FAN_MODE, InsteonBindingConstants.FAST_ON_OFF,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_A, InsteonBindingConstants.FAST_ON_OFF_BUTTON_B,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_C, InsteonBindingConstants.FAST_ON_OFF_BUTTON_D,\n+            InsteonBindingConstants.HEAT_SET_POINT, InsteonBindingConstants.HUMIDITY,\n+            InsteonBindingConstants.HUMIDITY_HIGH, InsteonBindingConstants.HUMIDITY_LOW,\n+            InsteonBindingConstants.IS_COOLING, InsteonBindingConstants.IS_HEATING,\n+            InsteonBindingConstants.KEYPAD_BUTTON_A, InsteonBindingConstants.KEYPAD_BUTTON_B,\n+            InsteonBindingConstants.KEYPAD_BUTTON_C, InsteonBindingConstants.KEYPAD_BUTTON_D,\n+            InsteonBindingConstants.KEYPAD_BUTTON_E, InsteonBindingConstants.KEYPAD_BUTTON_F,\n+            InsteonBindingConstants.KEYPAD_BUTTON_G, InsteonBindingConstants.KEYPAD_BUTTON_H,\n+            InsteonBindingConstants.KWH, InsteonBindingConstants.LAST_HEARD_FROM,\n+            InsteonBindingConstants.LED_BRIGHTNESS, InsteonBindingConstants.LIGHT_DIMMER,\n+            InsteonBindingConstants.LIGHT_LEVEL, InsteonBindingConstants.LOAD_DIMMER,\n+            InsteonBindingConstants.LOAD_SWITCH, InsteonBindingConstants.LOAD_SWITCH_FAST_ON_OFF,\n+            InsteonBindingConstants.LOAD_SWITCH_MANUAL_CHANGE, InsteonBindingConstants.MANUAL_CHANGE,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_A, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_B,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_C, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_D,\n+            InsteonBindingConstants.NOTIFICATION, InsteonBindingConstants.ON_LEVEL, InsteonBindingConstants.RAMP_DIMMER,\n+            InsteonBindingConstants.RAMP_RATE, InsteonBindingConstants.RESET, InsteonBindingConstants.STAGE1_DURATION,\n+            InsteonBindingConstants.SWITCH, InsteonBindingConstants.SYSTEM_MODE, InsteonBindingConstants.TEMP_CELSIUS,\n+            InsteonBindingConstants.TEMP_FAHRENHEIT, InsteonBindingConstants.TOP_OUTLET, InsteonBindingConstants.UPDATE,\n+            InsteonBindingConstants.WATTS).collect(Collectors.toSet()));\n+\n+    private static final String BROADCAST_ON_OFF = \"broadcastonoff\";\n+    private static final String CMD = \"cmd\";\n+    private static final String CMD_RESET = \"reset\";\n+    private static final String CMD_UPDATE = \"update\";\n+    private static final String DATA = \"data\";\n+    private static final String FIELD = \"field\";\n+    private static final String FIELD_BATTERY_LEVEL = \"battery_level\";\n+    private static final String FIELD_BATTERY_WATERMARK_LEVEL = \"battery_watermark_level\";\n+    private static final String FIELD_KWH = \"kwh\";\n+    private static final String FIELD_LIGHT_LEVEL = \"light_level\";\n+    private static final String FIELD_WATTS = \"watts\";\n+    private static final String GROUP = \"group\";\n+    private static final String METER = \"meter\";\n+\n+    private static final String HIDDEN_DOOR_SENSOR_PRODUCT_KEY = \"F00.00.03\";\n+    private static final String MOTION_SENSOR_PRODUCT_KEY = \"0x00004A\";\n+    private static final String PLM_PRODUCT_KEY = \"0x000045\";\n+    private static final String POWER_METER_PRODUCT_KEY = \"F00.00.17\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonDeviceHandler.class);\n+\n+    private @Nullable InsteonDeviceConfiguration config;\n+\n+    public InsteonDeviceHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(InsteonDeviceConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            if (getBridge() == null) {\n+                String msg = \"An Insteon network bridge has not been selected for this device.\";\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String address = config.getAddress();\n+            if (!InsteonAddress.s_isValid(address)) {\n+                String msg = \"Unable to start Insteon device, the insteon or X10 address '\" + address\n+                        + \"' is invalid. It must be in the format 'AB.CD.EF' or 'H.U' (X10).\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String productKey = config.getProductKey();\n+            if (DeviceTypeLoader.s_instance().getDeviceType(productKey) == null) {\n+                String msg = \"Unable to start Insteon device, invalid product key '\" + productKey + \"'.\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            InsteonBinding insteonBinding = getInsteonBinding();\n+            InsteonAddress insteonAddress = new InsteonAddress(address);\n+            if (insteonBinding.getDevice(insteonAddress) != null) {\n+                String msg = \"a device already exists with the address '\" + address + \"'.\";\n+                logger.warn(msg);", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0MDc1MA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390040750", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-10T00:59:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MDA5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MDI1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386750252", "bodyText": "Please use standard slf4j log formatting", "author": "cpmeister", "createdAt": "2020-03-03T01:27:16Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonDeviceHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.InsteonBindingConstants;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonDeviceConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InsteonDeviceHandler extends BaseThingHandler {\n+\n+    private static final Set<String> DEFINED_CHANNELS = Collections.unmodifiableSet(Stream.of(\n+            InsteonBindingConstants.AC_DELAY, InsteonBindingConstants.BACKLIGHT_DURATION,\n+            InsteonBindingConstants.BATTERY_LEVEL, InsteonBindingConstants.BATTERY_WATERMARK_LEVEL,\n+            InsteonBindingConstants.BOTTOM_OUTLET, InsteonBindingConstants.BUTTON_A, InsteonBindingConstants.BUTTON_B,\n+            InsteonBindingConstants.BUTTON_C, InsteonBindingConstants.BUTTON_D, InsteonBindingConstants.BUTTON_E,\n+            InsteonBindingConstants.BUTTON_F, InsteonBindingConstants.BUTTON_G, InsteonBindingConstants.BUTTON_H,\n+            InsteonBindingConstants.BROADCAST_ON_OFF, InsteonBindingConstants.CONTACT,\n+            InsteonBindingConstants.COOL_SET_POINT, InsteonBindingConstants.DIMMER, InsteonBindingConstants.FAN,\n+            InsteonBindingConstants.FAN_MODE, InsteonBindingConstants.FAST_ON_OFF,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_A, InsteonBindingConstants.FAST_ON_OFF_BUTTON_B,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_C, InsteonBindingConstants.FAST_ON_OFF_BUTTON_D,\n+            InsteonBindingConstants.HEAT_SET_POINT, InsteonBindingConstants.HUMIDITY,\n+            InsteonBindingConstants.HUMIDITY_HIGH, InsteonBindingConstants.HUMIDITY_LOW,\n+            InsteonBindingConstants.IS_COOLING, InsteonBindingConstants.IS_HEATING,\n+            InsteonBindingConstants.KEYPAD_BUTTON_A, InsteonBindingConstants.KEYPAD_BUTTON_B,\n+            InsteonBindingConstants.KEYPAD_BUTTON_C, InsteonBindingConstants.KEYPAD_BUTTON_D,\n+            InsteonBindingConstants.KEYPAD_BUTTON_E, InsteonBindingConstants.KEYPAD_BUTTON_F,\n+            InsteonBindingConstants.KEYPAD_BUTTON_G, InsteonBindingConstants.KEYPAD_BUTTON_H,\n+            InsteonBindingConstants.KWH, InsteonBindingConstants.LAST_HEARD_FROM,\n+            InsteonBindingConstants.LED_BRIGHTNESS, InsteonBindingConstants.LIGHT_DIMMER,\n+            InsteonBindingConstants.LIGHT_LEVEL, InsteonBindingConstants.LOAD_DIMMER,\n+            InsteonBindingConstants.LOAD_SWITCH, InsteonBindingConstants.LOAD_SWITCH_FAST_ON_OFF,\n+            InsteonBindingConstants.LOAD_SWITCH_MANUAL_CHANGE, InsteonBindingConstants.MANUAL_CHANGE,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_A, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_B,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_C, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_D,\n+            InsteonBindingConstants.NOTIFICATION, InsteonBindingConstants.ON_LEVEL, InsteonBindingConstants.RAMP_DIMMER,\n+            InsteonBindingConstants.RAMP_RATE, InsteonBindingConstants.RESET, InsteonBindingConstants.STAGE1_DURATION,\n+            InsteonBindingConstants.SWITCH, InsteonBindingConstants.SYSTEM_MODE, InsteonBindingConstants.TEMP_CELSIUS,\n+            InsteonBindingConstants.TEMP_FAHRENHEIT, InsteonBindingConstants.TOP_OUTLET, InsteonBindingConstants.UPDATE,\n+            InsteonBindingConstants.WATTS).collect(Collectors.toSet()));\n+\n+    private static final String BROADCAST_ON_OFF = \"broadcastonoff\";\n+    private static final String CMD = \"cmd\";\n+    private static final String CMD_RESET = \"reset\";\n+    private static final String CMD_UPDATE = \"update\";\n+    private static final String DATA = \"data\";\n+    private static final String FIELD = \"field\";\n+    private static final String FIELD_BATTERY_LEVEL = \"battery_level\";\n+    private static final String FIELD_BATTERY_WATERMARK_LEVEL = \"battery_watermark_level\";\n+    private static final String FIELD_KWH = \"kwh\";\n+    private static final String FIELD_LIGHT_LEVEL = \"light_level\";\n+    private static final String FIELD_WATTS = \"watts\";\n+    private static final String GROUP = \"group\";\n+    private static final String METER = \"meter\";\n+\n+    private static final String HIDDEN_DOOR_SENSOR_PRODUCT_KEY = \"F00.00.03\";\n+    private static final String MOTION_SENSOR_PRODUCT_KEY = \"0x00004A\";\n+    private static final String PLM_PRODUCT_KEY = \"0x000045\";\n+    private static final String POWER_METER_PRODUCT_KEY = \"F00.00.17\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonDeviceHandler.class);\n+\n+    private @Nullable InsteonDeviceConfiguration config;\n+\n+    public InsteonDeviceHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(InsteonDeviceConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            if (getBridge() == null) {\n+                String msg = \"An Insteon network bridge has not been selected for this device.\";\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String address = config.getAddress();\n+            if (!InsteonAddress.s_isValid(address)) {\n+                String msg = \"Unable to start Insteon device, the insteon or X10 address '\" + address\n+                        + \"' is invalid. It must be in the format 'AB.CD.EF' or 'H.U' (X10).\";\n+                logger.warn(msg);", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODE1MA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389318150", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            String msg = \"Unable to start Insteon device, the insteon or X10 address '\" + address\n          \n          \n            \n                                    + \"' is invalid. It must be in the format 'AB.CD.EF' or 'H.U' (X10).\";\n          \n          \n            \n                            logger.warn(msg);\n          \n          \n            \n                            String msg = \"Unable to start Insteon device, the insteon or X10 address '\" + address\n          \n          \n            \n                                    + \"' is invalid. It must be in the format 'AB.CD.EF' or 'H.U' (X10).\";\n          \n          \n            \n                            logger.warn(\"{}\", msg);", "author": "kaikreuzer", "createdAt": "2020-03-07T22:52:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MDI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0MDM5OA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390040398", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-10T00:58:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MDI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MDMwMw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386750303", "bodyText": "see above", "author": "cpmeister", "createdAt": "2020-03-03T01:27:31Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonDeviceHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.InsteonBindingConstants;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonDeviceConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InsteonDeviceHandler extends BaseThingHandler {\n+\n+    private static final Set<String> DEFINED_CHANNELS = Collections.unmodifiableSet(Stream.of(\n+            InsteonBindingConstants.AC_DELAY, InsteonBindingConstants.BACKLIGHT_DURATION,\n+            InsteonBindingConstants.BATTERY_LEVEL, InsteonBindingConstants.BATTERY_WATERMARK_LEVEL,\n+            InsteonBindingConstants.BOTTOM_OUTLET, InsteonBindingConstants.BUTTON_A, InsteonBindingConstants.BUTTON_B,\n+            InsteonBindingConstants.BUTTON_C, InsteonBindingConstants.BUTTON_D, InsteonBindingConstants.BUTTON_E,\n+            InsteonBindingConstants.BUTTON_F, InsteonBindingConstants.BUTTON_G, InsteonBindingConstants.BUTTON_H,\n+            InsteonBindingConstants.BROADCAST_ON_OFF, InsteonBindingConstants.CONTACT,\n+            InsteonBindingConstants.COOL_SET_POINT, InsteonBindingConstants.DIMMER, InsteonBindingConstants.FAN,\n+            InsteonBindingConstants.FAN_MODE, InsteonBindingConstants.FAST_ON_OFF,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_A, InsteonBindingConstants.FAST_ON_OFF_BUTTON_B,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_C, InsteonBindingConstants.FAST_ON_OFF_BUTTON_D,\n+            InsteonBindingConstants.HEAT_SET_POINT, InsteonBindingConstants.HUMIDITY,\n+            InsteonBindingConstants.HUMIDITY_HIGH, InsteonBindingConstants.HUMIDITY_LOW,\n+            InsteonBindingConstants.IS_COOLING, InsteonBindingConstants.IS_HEATING,\n+            InsteonBindingConstants.KEYPAD_BUTTON_A, InsteonBindingConstants.KEYPAD_BUTTON_B,\n+            InsteonBindingConstants.KEYPAD_BUTTON_C, InsteonBindingConstants.KEYPAD_BUTTON_D,\n+            InsteonBindingConstants.KEYPAD_BUTTON_E, InsteonBindingConstants.KEYPAD_BUTTON_F,\n+            InsteonBindingConstants.KEYPAD_BUTTON_G, InsteonBindingConstants.KEYPAD_BUTTON_H,\n+            InsteonBindingConstants.KWH, InsteonBindingConstants.LAST_HEARD_FROM,\n+            InsteonBindingConstants.LED_BRIGHTNESS, InsteonBindingConstants.LIGHT_DIMMER,\n+            InsteonBindingConstants.LIGHT_LEVEL, InsteonBindingConstants.LOAD_DIMMER,\n+            InsteonBindingConstants.LOAD_SWITCH, InsteonBindingConstants.LOAD_SWITCH_FAST_ON_OFF,\n+            InsteonBindingConstants.LOAD_SWITCH_MANUAL_CHANGE, InsteonBindingConstants.MANUAL_CHANGE,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_A, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_B,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_C, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_D,\n+            InsteonBindingConstants.NOTIFICATION, InsteonBindingConstants.ON_LEVEL, InsteonBindingConstants.RAMP_DIMMER,\n+            InsteonBindingConstants.RAMP_RATE, InsteonBindingConstants.RESET, InsteonBindingConstants.STAGE1_DURATION,\n+            InsteonBindingConstants.SWITCH, InsteonBindingConstants.SYSTEM_MODE, InsteonBindingConstants.TEMP_CELSIUS,\n+            InsteonBindingConstants.TEMP_FAHRENHEIT, InsteonBindingConstants.TOP_OUTLET, InsteonBindingConstants.UPDATE,\n+            InsteonBindingConstants.WATTS).collect(Collectors.toSet()));\n+\n+    private static final String BROADCAST_ON_OFF = \"broadcastonoff\";\n+    private static final String CMD = \"cmd\";\n+    private static final String CMD_RESET = \"reset\";\n+    private static final String CMD_UPDATE = \"update\";\n+    private static final String DATA = \"data\";\n+    private static final String FIELD = \"field\";\n+    private static final String FIELD_BATTERY_LEVEL = \"battery_level\";\n+    private static final String FIELD_BATTERY_WATERMARK_LEVEL = \"battery_watermark_level\";\n+    private static final String FIELD_KWH = \"kwh\";\n+    private static final String FIELD_LIGHT_LEVEL = \"light_level\";\n+    private static final String FIELD_WATTS = \"watts\";\n+    private static final String GROUP = \"group\";\n+    private static final String METER = \"meter\";\n+\n+    private static final String HIDDEN_DOOR_SENSOR_PRODUCT_KEY = \"F00.00.03\";\n+    private static final String MOTION_SENSOR_PRODUCT_KEY = \"0x00004A\";\n+    private static final String PLM_PRODUCT_KEY = \"0x000045\";\n+    private static final String POWER_METER_PRODUCT_KEY = \"F00.00.17\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonDeviceHandler.class);\n+\n+    private @Nullable InsteonDeviceConfiguration config;\n+\n+    public InsteonDeviceHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(InsteonDeviceConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            if (getBridge() == null) {\n+                String msg = \"An Insteon network bridge has not been selected for this device.\";\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String address = config.getAddress();\n+            if (!InsteonAddress.s_isValid(address)) {\n+                String msg = \"Unable to start Insteon device, the insteon or X10 address '\" + address\n+                        + \"' is invalid. It must be in the format 'AB.CD.EF' or 'H.U' (X10).\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String productKey = config.getProductKey();\n+            if (DeviceTypeLoader.s_instance().getDeviceType(productKey) == null) {\n+                String msg = \"Unable to start Insteon device, invalid product key '\" + productKey + \"'.\";\n+                logger.warn(msg);", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0MDc4OA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390040788", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-10T01:00:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MDMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MTAzNw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386751037", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.info(\"removed {} address = {}\", getThing().getUID().getAsString(), address);\n          \n          \n            \n                        logger.debug(\"removed {} address = {}\", getThing().getUID().getAsString(), address);", "author": "cpmeister", "createdAt": "2020-03-03T01:30:08Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonDeviceHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.InsteonBindingConstants;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonDeviceConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InsteonDeviceHandler extends BaseThingHandler {\n+\n+    private static final Set<String> DEFINED_CHANNELS = Collections.unmodifiableSet(Stream.of(\n+            InsteonBindingConstants.AC_DELAY, InsteonBindingConstants.BACKLIGHT_DURATION,\n+            InsteonBindingConstants.BATTERY_LEVEL, InsteonBindingConstants.BATTERY_WATERMARK_LEVEL,\n+            InsteonBindingConstants.BOTTOM_OUTLET, InsteonBindingConstants.BUTTON_A, InsteonBindingConstants.BUTTON_B,\n+            InsteonBindingConstants.BUTTON_C, InsteonBindingConstants.BUTTON_D, InsteonBindingConstants.BUTTON_E,\n+            InsteonBindingConstants.BUTTON_F, InsteonBindingConstants.BUTTON_G, InsteonBindingConstants.BUTTON_H,\n+            InsteonBindingConstants.BROADCAST_ON_OFF, InsteonBindingConstants.CONTACT,\n+            InsteonBindingConstants.COOL_SET_POINT, InsteonBindingConstants.DIMMER, InsteonBindingConstants.FAN,\n+            InsteonBindingConstants.FAN_MODE, InsteonBindingConstants.FAST_ON_OFF,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_A, InsteonBindingConstants.FAST_ON_OFF_BUTTON_B,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_C, InsteonBindingConstants.FAST_ON_OFF_BUTTON_D,\n+            InsteonBindingConstants.HEAT_SET_POINT, InsteonBindingConstants.HUMIDITY,\n+            InsteonBindingConstants.HUMIDITY_HIGH, InsteonBindingConstants.HUMIDITY_LOW,\n+            InsteonBindingConstants.IS_COOLING, InsteonBindingConstants.IS_HEATING,\n+            InsteonBindingConstants.KEYPAD_BUTTON_A, InsteonBindingConstants.KEYPAD_BUTTON_B,\n+            InsteonBindingConstants.KEYPAD_BUTTON_C, InsteonBindingConstants.KEYPAD_BUTTON_D,\n+            InsteonBindingConstants.KEYPAD_BUTTON_E, InsteonBindingConstants.KEYPAD_BUTTON_F,\n+            InsteonBindingConstants.KEYPAD_BUTTON_G, InsteonBindingConstants.KEYPAD_BUTTON_H,\n+            InsteonBindingConstants.KWH, InsteonBindingConstants.LAST_HEARD_FROM,\n+            InsteonBindingConstants.LED_BRIGHTNESS, InsteonBindingConstants.LIGHT_DIMMER,\n+            InsteonBindingConstants.LIGHT_LEVEL, InsteonBindingConstants.LOAD_DIMMER,\n+            InsteonBindingConstants.LOAD_SWITCH, InsteonBindingConstants.LOAD_SWITCH_FAST_ON_OFF,\n+            InsteonBindingConstants.LOAD_SWITCH_MANUAL_CHANGE, InsteonBindingConstants.MANUAL_CHANGE,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_A, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_B,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_C, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_D,\n+            InsteonBindingConstants.NOTIFICATION, InsteonBindingConstants.ON_LEVEL, InsteonBindingConstants.RAMP_DIMMER,\n+            InsteonBindingConstants.RAMP_RATE, InsteonBindingConstants.RESET, InsteonBindingConstants.STAGE1_DURATION,\n+            InsteonBindingConstants.SWITCH, InsteonBindingConstants.SYSTEM_MODE, InsteonBindingConstants.TEMP_CELSIUS,\n+            InsteonBindingConstants.TEMP_FAHRENHEIT, InsteonBindingConstants.TOP_OUTLET, InsteonBindingConstants.UPDATE,\n+            InsteonBindingConstants.WATTS).collect(Collectors.toSet()));\n+\n+    private static final String BROADCAST_ON_OFF = \"broadcastonoff\";\n+    private static final String CMD = \"cmd\";\n+    private static final String CMD_RESET = \"reset\";\n+    private static final String CMD_UPDATE = \"update\";\n+    private static final String DATA = \"data\";\n+    private static final String FIELD = \"field\";\n+    private static final String FIELD_BATTERY_LEVEL = \"battery_level\";\n+    private static final String FIELD_BATTERY_WATERMARK_LEVEL = \"battery_watermark_level\";\n+    private static final String FIELD_KWH = \"kwh\";\n+    private static final String FIELD_LIGHT_LEVEL = \"light_level\";\n+    private static final String FIELD_WATTS = \"watts\";\n+    private static final String GROUP = \"group\";\n+    private static final String METER = \"meter\";\n+\n+    private static final String HIDDEN_DOOR_SENSOR_PRODUCT_KEY = \"F00.00.03\";\n+    private static final String MOTION_SENSOR_PRODUCT_KEY = \"0x00004A\";\n+    private static final String PLM_PRODUCT_KEY = \"0x000045\";\n+    private static final String POWER_METER_PRODUCT_KEY = \"F00.00.17\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonDeviceHandler.class);\n+\n+    private @Nullable InsteonDeviceConfiguration config;\n+\n+    public InsteonDeviceHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(InsteonDeviceConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            if (getBridge() == null) {\n+                String msg = \"An Insteon network bridge has not been selected for this device.\";\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String address = config.getAddress();\n+            if (!InsteonAddress.s_isValid(address)) {\n+                String msg = \"Unable to start Insteon device, the insteon or X10 address '\" + address\n+                        + \"' is invalid. It must be in the format 'AB.CD.EF' or 'H.U' (X10).\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String productKey = config.getProductKey();\n+            if (DeviceTypeLoader.s_instance().getDeviceType(productKey) == null) {\n+                String msg = \"Unable to start Insteon device, invalid product key '\" + productKey + \"'.\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            InsteonBinding insteonBinding = getInsteonBinding();\n+            InsteonAddress insteonAddress = new InsteonAddress(address);\n+            if (insteonBinding.getDevice(insteonAddress) != null) {\n+                String msg = \"a device already exists with the address '\" + address + \"'.\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            InsteonDevice device = insteonBinding.makeNewDevice(insteonAddress, productKey);\n+\n+            // By default the device is assigned all channels. Channels are associated with a feature, cull the ones\n+            // that are supported by this device.\n+            StringBuffer channelList = new StringBuffer();\n+            List<Channel> supportedChannels = new ArrayList<Channel>();\n+            List<Channel> initialChannels = getThing().getChannels();\n+            String thingId = getThing().getUID().getAsString();\n+            for (Channel channel : initialChannels) {\n+                String channelId = channel.getUID().getId();\n+                String feature = channelId.toLowerCase();\n+\n+                if (productKey.equals(HIDDEN_DOOR_SENSOR_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_WATERMARK_LEVEL)) {\n+\n+                        feature = DATA;\n+                    }\n+                } else if (productKey.equals(MOTION_SENSOR_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.LIGHT_LEVEL)) {\n+\n+                        feature = DATA;\n+                    }\n+                } else if (productKey.equals(PLM_PRODUCT_KEY)) {\n+                    String parts[] = feature.split(\"#\");\n+                    if (parts.length == 2 && parts[0].equalsIgnoreCase(InsteonBindingConstants.BROADCAST_ON_OFF)\n+                            && parts[1].matches(\"^\\\\d+$\")) {\n+                        feature = BROADCAST_ON_OFF;\n+                    }\n+                } else if (productKey.equals(POWER_METER_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.KWH)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.RESET)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.UPDATE)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.WATTS)) {\n+\n+                        feature = METER;\n+                    }\n+                }\n+\n+                DeviceFeature f = device.getFeature(feature);\n+                if (f == null) {\n+                    if (!DEFINED_CHANNELS.contains(channelId)) {\n+                        logger.warn(\"{} includes channel {}, it is not a valid feature for {}. It has been removed.\",\n+                                thingId, channelId, productKey);\n+                    }\n+                } else if (f.isFeatureGroup()) {\n+                    logger.warn(\"{} includes channel {}, it is a feature group for {}. It has been removed.\", thingId,\n+                            channelId, productKey);\n+                } else {\n+                    supportedChannels.add(channel);\n+\n+                    if (channelList.length() > 0) {\n+                        channelList.append(\", \");\n+                    }\n+                    channelList.append(channelId);\n+\n+                    if (!DEFINED_CHANNELS.contains(channelId)) {\n+                        for (String c : DEFINED_CHANNELS) {\n+                            if (channelId.equalsIgnoreCase(c)) {\n+                                logger.warn(\"{} includes channel {}, should it be {}?\", thingId, channelId, c);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // only update if channels were culled\n+            if (initialChannels.size() != supportedChannels.size()) {\n+                ThingBuilder thingBuilder = editThing();\n+                thingBuilder.withChannels(supportedChannels);\n+                updateThing(thingBuilder.build());\n+            }\n+\n+            logger.info(\"{} address = {} productKey = {} channels = {}\", thingId, address, productKey,\n+                    channelList.toString());\n+\n+            updateStatus(ThingStatus.ONLINE);\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        String address = config.getAddress();\n+        if (getBridge() != null && InsteonAddress.s_isValid(address)) {\n+            getInsteonBinding().removeDevice(new InsteonAddress(address));\n+\n+            logger.info(\"removed {} address = {}\", getThing().getUID().getAsString(), address);", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0MDQ3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390040479", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-10T00:58:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MTAzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MjE1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386752154", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Integer i = new Integer((b & 0xe0));\n          \n          \n            \n                    int i = b & 0xe0;", "author": "cpmeister", "createdAt": "2020-03-03T01:34:09Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/message/MsgType.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.message;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Represents insteon message type flags\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public enum MsgType {\n+    /*\n+     * From the official Insteon docs: the message flags are as follows:\n+     *\n+     * Bit 0 max hops low bit\n+     * Bit 1 max hops high bit\n+     * Bit 2 hops left low bit\n+     * Bit 3 hops left high bit\n+     * Bit 4 0: is standard message, 1: is extended message\n+     * Bit 5 ACK\n+     * Bit 6 0: not link related, 1: is ALL-Link message\n+     * Bit 7 Broadcast/NAK\n+     */\n+    BROADCAST(0x80),\n+    DIRECT(0x00),\n+    ACK_OF_DIRECT(0x20),\n+    NACK_OF_DIRECT(0xa0),\n+    ALL_LINK_BROADCAST(0xc0),\n+    ALL_LINK_CLEANUP(0x40),\n+    ALL_LINK_CLEANUP_ACK(0x60),\n+    ALL_LINK_CLEANUP_NACK(0xe0),\n+    INVALID(0xff); // should never happen\n+\n+    private static HashMap<Integer, @Nullable MsgType> s_hash = new HashMap<Integer, @Nullable MsgType>();\n+\n+    private byte m_byteValue = 0;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param b byte with insteon message type flags set\n+     */\n+    MsgType(int b) {\n+        m_byteValue = (byte) b;\n+    }\n+\n+    static {\n+        for (MsgType t : MsgType.values()) {\n+            Integer i = new Integer(t.getByteValue() & 0xff);\n+            s_hash.put(i, t);\n+        }\n+    }\n+\n+    private int getByteValue() {\n+        return m_byteValue;\n+    }\n+\n+    public static MsgType s_fromValue(byte b) throws IllegalArgumentException {\n+        Integer i = new Integer((b & 0xe0));", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2ODc1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387668759", "bodyText": "this works going to leave as is", "author": "robnielsen", "createdAt": "2020-03-04T13:35:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MjE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MjQxMA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386752410", "bodyText": "move to unit test or remove", "author": "cpmeister", "createdAt": "2020-03-03T01:35:04Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/message/XMLMessageReader.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.message;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map.Entry;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.utils.Pair;\n+import org.openhab.binding.insteon.internal.utils.Utils.DataTypeParser;\n+import org.openhab.binding.insteon.internal.utils.Utils.ParsingException;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * Reads the Msg definitions from an XML file\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class XMLMessageReader {\n+    /**\n+     * Reads the message definitions from an xml file\n+     *\n+     * @param input input stream from which to read\n+     * @return what was read from file: the map between clear text string and Msg objects\n+     * @throws IOException couldn't read file etc\n+     * @throws ParsingException something wrong with the file format\n+     * @throws FieldException something wrong with the field definition\n+     */\n+    public static HashMap<String, Msg> s_readMessageDefinitions(InputStream input)\n+            throws IOException, ParsingException, FieldException {\n+        HashMap<String, Msg> messageMap = new HashMap<String, Msg>();\n+        try {\n+            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n+            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n+            // Parse it!\n+            Document doc = dBuilder.parse(input);\n+            doc.getDocumentElement().normalize();\n+\n+            Node root = doc.getDocumentElement();\n+\n+            NodeList nodes = root.getChildNodes();\n+\n+            for (int i = 0; i < nodes.getLength(); i++) {\n+                Node node = nodes.item(i);\n+                if (node.getNodeType() == Node.ELEMENT_NODE) {\n+                    if (node.getNodeName().equals(\"msg\")) {\n+                        Pair<String, Msg> msgDef = s_readMessageDefinition((Element) node);\n+                        messageMap.put(msgDef.getKey(), msgDef.getValue());\n+                    }\n+                }\n+            }\n+        } catch (SAXException e) {\n+            throw new ParsingException(\"Failed to parse XML!\", e);\n+        } catch (ParserConfigurationException e) {\n+            throw new ParsingException(\"Got parser config exception! \", e);\n+        }\n+        return messageMap;\n+    }\n+\n+    private static Pair<String, Msg> s_readMessageDefinition(Element msg) throws FieldException, ParsingException {\n+        int length = 0;\n+        int hlength = 0;\n+        LinkedHashMap<Field, Object> fieldMap = new LinkedHashMap<Field, Object>();\n+        String dir = msg.getAttribute(\"direction\");\n+        String name = msg.getAttribute(\"name\");\n+        Msg.Direction direction = Msg.Direction.s_getDirectionFromString(dir);\n+\n+        if (msg.hasAttribute(\"length\")) {\n+            length = Integer.parseInt(msg.getAttribute(\"length\"));\n+        }\n+\n+        NodeList nodes = msg.getChildNodes();\n+\n+        int offset = 0;\n+\n+        for (int i = 0; i < nodes.getLength(); i++) {\n+            Node node = nodes.item(i);\n+            if (node.getNodeType() == Node.ELEMENT_NODE) {\n+                if (node.getNodeName().equals(\"header\")) {\n+                    int o = s_readHeaderElement((Element) node, fieldMap);\n+                    hlength = o;\n+                    // Increment the offset by the header length\n+                    offset += o;\n+                } else {\n+                    Pair<Field, Object> field = s_readField((Element) node, offset);\n+                    fieldMap.put(field.getKey(), field.getValue());\n+                    // Increment the offset\n+                    offset += field.getKey().getType().getSize();\n+                }\n+            }\n+        }\n+        if (offset != length) {\n+            throw new ParsingException(\n+                    \"Actual msg length \" + offset + \" differs from given msg length \" + length + \"!\");\n+        }\n+        if (length == 0) {\n+            length = offset;\n+        }\n+\n+        return new Pair<String, Msg>(name, s_createMsg(fieldMap, length, hlength, direction));\n+    }\n+\n+    private static int s_readHeaderElement(Element header, LinkedHashMap<Field, Object> fields)\n+            throws ParsingException {\n+        int offset = 0;\n+        int headerLen = Integer.parseInt(header.getAttribute(\"length\"));\n+\n+        NodeList nodes = header.getChildNodes();\n+        for (int i = 0; i < nodes.getLength(); i++) {\n+            Node node = nodes.item(i);\n+            if (node.getNodeType() == Node.ELEMENT_NODE) {\n+                @Nullable\n+                Pair<Field, Object> definition = s_readField((Element) node, offset);\n+                if (definition != null) {\n+                    offset += definition.getKey().getType().getSize();\n+                    fields.put(definition.getKey(), definition.getValue());\n+                }\n+            }\n+        }\n+        if (headerLen != offset) {\n+            throw new ParsingException(\n+                    \"Actual header length \" + offset + \" differs from given length \" + headerLen + \"!\");\n+        }\n+        return headerLen;\n+    }\n+\n+    private static Pair<Field, Object> s_readField(Element field, int offset) {\n+        DataType dType = DataType.s_getDataType(field.getTagName());\n+        // Will return blank if no name attribute\n+        String name = field.getAttribute(\"name\");\n+        Field f = new Field(name, dType, offset);\n+        // Now we have field, only need value\n+        String sVal = field.getTextContent();\n+        Object val = DataTypeParser.s_parseDataType(dType, sVal);\n+        Pair<Field, Object> pair = new Pair<Field, Object>(f, val);\n+        return pair;\n+    }\n+\n+    private static Msg s_createMsg(HashMap<Field, Object> values, int length, int headerLength, Msg.Direction dir)\n+            throws FieldException {\n+        Msg msg = new Msg(headerLength, new byte[length], length, dir);\n+        for (Entry<Field, Object> e : values.entrySet()) {\n+            Field f = e.getKey();\n+            f.set(msg.getData(), e.getValue());\n+            if (f.getName() != null && !f.getName().equals(\"\")) {\n+                msg.addField(f);\n+            }\n+        }\n+        return msg;\n+    }\n+\n+    // public static void main(String[] args) throws Exception {\n+    // // for local testing\n+    // File f = new File(System.getProperty(\"user.home\")\n+    // + \"/workspace/openhab/bundles/binding/org.openhab.binding.insteonplm/src/main/resources/msg_definitions.xml\");\n+    // InputStream s = new FileInputStream(f);\n+    // HashMap<String, Msg> msgs = XMLMessageReader.s_readMessageDefinitions(s);\n+    // for (Msg msg : msgs.values()) {\n+    // System.out.println(msg);\n+    // }\n+    // }", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2OTE0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387669149", "bodyText": "It doesn't hurt to leave it in", "author": "robnielsen", "createdAt": "2020-03-04T13:35:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MjQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY3MDY1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387670659", "bodyText": "We don't have such commented code for debug purposes in our code base, so please just remove it.", "author": "kaikreuzer", "createdAt": "2020-03-04T13:38:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MjQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY5MjI1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r388692252", "bodyText": "I removed the commented out code.", "author": "robnielsen", "createdAt": "2020-03-06T03:07:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MjQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MzQ2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386753461", "bodyText": "might be useful to format the byte as hex in the exception", "author": "cpmeister", "createdAt": "2020-03-03T01:38:59Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/message/MsgType.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.message;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Represents insteon message type flags\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public enum MsgType {\n+    /*\n+     * From the official Insteon docs: the message flags are as follows:\n+     *\n+     * Bit 0 max hops low bit\n+     * Bit 1 max hops high bit\n+     * Bit 2 hops left low bit\n+     * Bit 3 hops left high bit\n+     * Bit 4 0: is standard message, 1: is extended message\n+     * Bit 5 ACK\n+     * Bit 6 0: not link related, 1: is ALL-Link message\n+     * Bit 7 Broadcast/NAK\n+     */\n+    BROADCAST(0x80),\n+    DIRECT(0x00),\n+    ACK_OF_DIRECT(0x20),\n+    NACK_OF_DIRECT(0xa0),\n+    ALL_LINK_BROADCAST(0xc0),\n+    ALL_LINK_CLEANUP(0x40),\n+    ALL_LINK_CLEANUP_ACK(0x60),\n+    ALL_LINK_CLEANUP_NACK(0xe0),\n+    INVALID(0xff); // should never happen\n+\n+    private static HashMap<Integer, @Nullable MsgType> s_hash = new HashMap<Integer, @Nullable MsgType>();\n+\n+    private byte m_byteValue = 0;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param b byte with insteon message type flags set\n+     */\n+    MsgType(int b) {\n+        m_byteValue = (byte) b;\n+    }\n+\n+    static {\n+        for (MsgType t : MsgType.values()) {\n+            Integer i = new Integer(t.getByteValue() & 0xff);\n+            s_hash.put(i, t);\n+        }\n+    }\n+\n+    private int getByteValue() {\n+        return m_byteValue;\n+    }\n+\n+    public static MsgType s_fromValue(byte b) throws IllegalArgumentException {\n+        Integer i = new Integer((b & 0xe0));\n+        @Nullable\n+        MsgType mt = s_hash.get(i);\n+        if (mt == null) {\n+            throw new IllegalArgumentException(\"msg type of byte value \" + i + \" not found\");", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2ODk5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387668996", "bodyText": "this works, going to leave as is", "author": "robnielsen", "createdAt": "2020-03-04T13:35:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MzQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MzYxNg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386753616", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Integer i = new Integer(t.getByteValue() & 0xff);\n          \n          \n            \n                        int i = t.getByteValue() & 0xff;", "author": "cpmeister", "createdAt": "2020-03-03T01:39:33Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/message/MsgType.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.message;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Represents insteon message type flags\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public enum MsgType {\n+    /*\n+     * From the official Insteon docs: the message flags are as follows:\n+     *\n+     * Bit 0 max hops low bit\n+     * Bit 1 max hops high bit\n+     * Bit 2 hops left low bit\n+     * Bit 3 hops left high bit\n+     * Bit 4 0: is standard message, 1: is extended message\n+     * Bit 5 ACK\n+     * Bit 6 0: not link related, 1: is ALL-Link message\n+     * Bit 7 Broadcast/NAK\n+     */\n+    BROADCAST(0x80),\n+    DIRECT(0x00),\n+    ACK_OF_DIRECT(0x20),\n+    NACK_OF_DIRECT(0xa0),\n+    ALL_LINK_BROADCAST(0xc0),\n+    ALL_LINK_CLEANUP(0x40),\n+    ALL_LINK_CLEANUP_ACK(0x60),\n+    ALL_LINK_CLEANUP_NACK(0xe0),\n+    INVALID(0xff); // should never happen\n+\n+    private static HashMap<Integer, @Nullable MsgType> s_hash = new HashMap<Integer, @Nullable MsgType>();\n+\n+    private byte m_byteValue = 0;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param b byte with insteon message type flags set\n+     */\n+    MsgType(int b) {\n+        m_byteValue = (byte) b;\n+    }\n+\n+    static {\n+        for (MsgType t : MsgType.values()) {\n+            Integer i = new Integer(t.getByteValue() & 0xff);", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2ODYwOA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387668608", "bodyText": "going to leave as is", "author": "robnielsen", "createdAt": "2020-03-04T13:34:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MzYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1NDEzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386754139", "bodyText": "Please change this to use StringBuilder instead", "author": "cpmeister", "createdAt": "2020-03-03T01:41:31Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/ModemDBEntry.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+\n+/**\n+ * The ModemDBEntry class holds a modem device type record\n+ * an xml file.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class ModemDBEntry {\n+    private @Nullable InsteonAddress m_address = null;\n+    private @Nullable Port m_port = null;\n+    private ArrayList<Msg> m_linkRecords = new ArrayList<Msg>();\n+    private ArrayList<Byte> m_controls = new ArrayList<Byte>();\n+    private ArrayList<Byte> m_respondsTo = new ArrayList<Byte>();\n+\n+    public ModemDBEntry(InsteonAddress aAddr) {\n+        m_address = aAddr;\n+    }\n+\n+    public ArrayList<Msg> getLinkRecords() {\n+        return m_linkRecords;\n+    }\n+\n+    public void addLinkRecord(Msg m) {\n+        m_linkRecords.add(m);\n+    }\n+\n+    public void addControls(byte c) {\n+        m_controls.add(c);\n+    }\n+\n+    public ArrayList<Byte> getControls() {\n+        return m_controls;\n+    }\n+\n+    public void addRespondsTo(byte r) {\n+        m_respondsTo.add(r);\n+    }\n+\n+    public ArrayList<Byte> getRespondsTo() {\n+        return m_respondsTo;\n+    }\n+\n+    public void setPort(Port p) {\n+        m_port = p;\n+    }\n+\n+    public @Nullable Port getPort() {\n+        return m_port;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String s = \"addr:\" + m_address + \"|controls:[\" + toGroupString(m_controls) + \"]|responds_to:[\"\n+                + toGroupString(m_respondsTo) + \"]|link_recors\";\n+        for (Msg m : m_linkRecords) {\n+            s += \":(\" + m + \")\";\n+        }\n+        return s;", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY5MTY0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r388691641", "bodyText": "leaving as is.", "author": "robnielsen", "createdAt": "2020-03-06T03:04:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1NDEzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1NzMyNw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386757327", "bodyText": "This makes me sad\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String s = \"\";\n          \n          \n            \n                        for (String g : m_features) {\n          \n          \n            \n                            s += g + \",\";\n          \n          \n            \n                        }\n          \n          \n            \n                        return (s.replaceAll(\",$\", \"\"));\n          \n          \n            \n                        return StringUtils.join(m_features, \",\");", "author": "cpmeister", "createdAt": "2020-03-03T01:52:54Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceType.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The DeviceType class holds device type definitions that are read from\n+ * an xml file.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class DeviceType {\n+    private String m_productKey;\n+    private String m_model = \"\";\n+    private String m_description = \"\";\n+    private HashMap<String, String> m_features = new HashMap<String, String>();\n+    private HashMap<String, FeatureGroup> m_featureGroups = new HashMap<String, FeatureGroup>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param aProductKey the product key for this device type\n+     */\n+    public DeviceType(String aProductKey) {\n+        m_productKey = aProductKey;\n+    }\n+\n+    /**\n+     * Get supported features\n+     *\n+     * @return all features that this device type supports\n+     */\n+    public HashMap<String, String> getFeatures() {\n+        return m_features;\n+    }\n+\n+    /**\n+     * Get all feature groups\n+     *\n+     * @return all feature groups of this device type\n+     */\n+    public HashMap<String, FeatureGroup> getFeatureGroups() {\n+        return m_featureGroups;\n+    }\n+\n+    /**\n+     * Sets the descriptive model string\n+     *\n+     * @param aModel descriptive model string\n+     */\n+    public void setModel(String aModel) {\n+        m_model = aModel;\n+    }\n+\n+    /**\n+     * Sets free text description\n+     *\n+     * @param aDesc free text description\n+     */\n+    public void setDescription(String aDesc) {\n+        m_description = aDesc;\n+    }\n+\n+    /**\n+     * Adds feature to this device type\n+     *\n+     * @param aKey the key (e.g. \"switch\") under which this feature can be referenced in the item binding config\n+     * @param aFeatureName the name (e.g. \"GenericSwitch\") under which the feature has been defined\n+     * @return false if feature was already there\n+     */\n+    public boolean addFeature(String aKey, String aFeatureName) {\n+        if (m_features.containsKey(aKey)) {\n+            return false;\n+        }\n+        m_features.put(aKey, aFeatureName);\n+        return true;\n+    }\n+\n+    /**\n+     * Adds feature group to device type\n+     *\n+     * @param aKey name of the feature group, which acts as key for lookup later\n+     * @param fg feature group to add\n+     * @return true if add succeeded, false if group was already there\n+     */\n+    public boolean addFeatureGroup(String aKey, FeatureGroup fg) {\n+        if (m_features.containsKey(aKey)) {\n+            return false;\n+        }\n+        m_featureGroups.put(aKey, fg);\n+        return true;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String s = \"pk:\" + m_productKey + \"|model:\" + m_model + \"|desc:\" + m_description + \"|features\";\n+        for (Entry<String, String> f : m_features.entrySet()) {\n+            s += \":\" + f.getKey() + \"=\" + f.getValue();\n+        }\n+        s += \"|groups\";\n+        for (Entry<String, FeatureGroup> f : m_featureGroups.entrySet()) {\n+            s += \":\" + f.getKey() + \"=\" + f.getValue();\n+        }\n+        return s;\n+    }\n+\n+    /**\n+     * Class that reflects feature group association\n+     *\n+     * @author Bernd Pfrommer - Initial contribution\n+     */\n+    @NonNullByDefault\n+    public static class FeatureGroup {\n+        private String m_name;\n+        private String m_type;\n+        private ArrayList<String> m_features = new ArrayList<String>();\n+\n+        FeatureGroup(String name, String type) {\n+            m_name = name;\n+            m_type = type;\n+        }\n+\n+        public void addFeature(String f) {\n+            m_features.add(f);\n+        }\n+\n+        public ArrayList<String> getFeatures() {\n+            return m_features;\n+        }\n+\n+        public String getName() {\n+            return m_name;\n+        }\n+\n+        public String getType() {\n+            return m_type;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String s = \"\";\n+            for (String g : m_features) {\n+                s += g + \",\";\n+            }\n+            return (s.replaceAll(\",$\", \"\"));", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1ODA1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386758051", "bodyText": "Can't you make this final?", "author": "cpmeister", "createdAt": "2020-03-03T01:55:34Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceFeature.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils.ParsingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A DeviceFeature represents a certain feature (trait) of a given Insteon device, e.g. something\n+ * operating under a given InsteonAddress that can be manipulated (relay) or read (sensor).\n+ *\n+ * The DeviceFeature does the processing of incoming messages, and handles commands for the\n+ * particular feature it represents.\n+ *\n+ * It uses four mechanisms for that:\n+ *\n+ * 1) MessageDispatcher: makes high level decisions about an incoming message and then runs the\n+ * 2) MessageHandler: further processes the message, updates state etc\n+ * 3) CommandHandler: translates commands from the openhab bus into an Insteon message.\n+ * 4) PollHandler: creates an Insteon message to query the DeviceFeature\n+ *\n+ * Lastly, DeviceFeatureListeners can register with the DeviceFeature to get notifications when\n+ * the state of a feature has changed. In practice, a DeviceFeatureListener corresponds to an\n+ * OpenHAB item.\n+ *\n+ * The character of a DeviceFeature is thus given by a set of message and command handlers.\n+ * A FeatureTemplate captures exactly that: it says what set of handlers make up a DeviceFeature.\n+ *\n+ * DeviceFeatures are added to a new device by referencing a FeatureTemplate (defined in device_features.xml)\n+ * from the Device definition file (device_types.xml).\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class DeviceFeature {\n+    public static enum QueryStatus {\n+        NEVER_QUERIED,\n+        QUERY_PENDING,\n+        QUERY_ANSWERED\n+    }\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DeviceFeature.class);\n+\n+    private static HashMap<String, FeatureTemplate> s_features = new HashMap<String, FeatureTemplate>();\n+\n+    private InsteonDevice m_device = new InsteonDevice();\n+    private String m_name = \"INVALID_FEATURE_NAME\";", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzNTAzNg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387335036", "bodyText": "This is actually assigned a value in the constructor so it has to stay as is.", "author": "robnielsen", "createdAt": "2020-03-03T22:32:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1ODA1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM0MjUzMA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387342530", "bodyText": "I understand that it is assigned, the \"INVALID_FEATURE_NAME\" value is always written over in the constructor.", "author": "cpmeister", "createdAt": "2020-03-03T22:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1ODA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1ODM4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386758385", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return (m_parameters.get(key) == null ? def : m_parameters.get(key));\n          \n          \n            \n                    return m_parameters.getOrDefault(key, def);", "author": "cpmeister", "createdAt": "2020-03-03T01:56:49Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/CommandHandler.java", "diffHunk": "@@ -0,0 +1,912 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A command handler translates an openHAB command into a insteon message\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public abstract class CommandHandler {\n+    private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);\n+    DeviceFeature m_feature; // related DeviceFeature\n+    @Nullable\n+    HashMap<String, @Nullable String> m_parameters = new HashMap<String, @Nullable String>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param feature The DeviceFeature for which this command was intended.\n+     *            The openHAB commands are issued on an openhab item. The .items files bind\n+     *            an openHAB item to a DeviceFeature.\n+     */\n+    CommandHandler(DeviceFeature feature) {\n+        m_feature = feature;\n+    }\n+\n+    /**\n+     * Implements what to do when an openHAB command is received\n+     *\n+     * @param config the configuration for the item that generated the command\n+     * @param cmd the openhab command issued\n+     * @param device the Insteon device to which this command applies\n+     */\n+    public abstract void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice device);\n+\n+    /**\n+     * Returns parameter as integer\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected int getIntParameter(String key, int def) {\n+        String val = m_parameters.get(key);\n+        if (val == null) {\n+            return (def); // param not found\n+        }\n+        int ret = def;\n+        try {\n+            ret = Utils.strToInt(val);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in command handler: {}\", key);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns parameter as String\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected @Nullable String getStringParameter(String key, String def) {\n+        return (m_parameters.get(key) == null ? def : m_parameters.get(key));", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzNjM0NA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387336344", "bodyText": "I'm going to leave as is.", "author": "robnielsen", "createdAt": "2020-03-03T22:35:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1ODM4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM1ODA5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387358096", "bodyText": "It's fine either way.", "author": "cpmeister", "createdAt": "2020-03-03T23:32:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1ODM4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc3NjA4OA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386776088", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        StringBuffer buf = new StringBuffer();\n          \n          \n            \n                        StringBuilder buf = new StringBuilder();", "author": "cpmeister", "createdAt": "2020-03-03T03:06:43Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollIntervalMilliseconds = 300000;\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config) {\n+        this.m_handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            m_devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.info(\"device poll interval set to {} seconds\", m_devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.info(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            m_driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.info(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.s_readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        m_deadDeviceTimeout = m_devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.info(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", port);\n+        m_driver.addPort(\"port\", port);\n+        m_driver.addMsgListener(m_portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        m_driver.setDriverListener(m_portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", m_driver.getNumberOfPorts());\n+\n+        m_driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (m_driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", m_driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        m_isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!m_isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = m_bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(m_driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuffer buf = new StringBuffer();", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzODkzNg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387338936", "bodyText": "changed", "author": "robnielsen", "createdAt": "2020-03-03T22:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc3NjA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc3NjIwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386776205", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);\n          \n          \n            \n                    logger.debug(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);", "author": "cpmeister", "createdAt": "2020-03-03T03:07:21Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollIntervalMilliseconds = 300000;\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config) {\n+        this.m_handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            m_devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.info(\"device poll interval set to {} seconds\", m_devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.info(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            m_driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.info(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.s_readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        m_deadDeviceTimeout = m_devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.info(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMyMjIxNg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390322216", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-10T13:44:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc3NjIwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc3NzQ1OA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386777458", "bodyText": "needs try/finally for locking", "author": "cpmeister", "createdAt": "2020-03-03T03:12:57Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/ModemDBBuilder.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Port;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Builds the modem database from incoming link record messages\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class ModemDBBuilder implements MsgListener, Runnable {\n+    private static final Logger logger = LoggerFactory.getLogger(ModemDBBuilder.class);\n+    private boolean m_isComplete = false;\n+    private Port m_port;\n+    private @Nullable Thread m_writeThread = null;\n+    private int m_timeoutMillis = 120000;\n+\n+    public ModemDBBuilder(Port port) {\n+        m_port = port;\n+    }\n+\n+    public void setRetryTimeout(int timeout) {\n+        m_timeoutMillis = timeout;\n+    }\n+\n+    public void start() {\n+        m_port.addListener(this);\n+        m_writeThread = new Thread(this);\n+        m_writeThread.setName(\"DBBuilder\");\n+        m_writeThread.start();\n+        logger.debug(\"querying port for first link record\");\n+    }\n+\n+    public void startDownload() {\n+        logger.trace(\"starting modem database download\");\n+        m_port.clearModemDB();\n+        getFirstLinkRecord();\n+    }\n+\n+    public synchronized boolean isComplete() {\n+        return (m_isComplete);\n+    }\n+\n+    @Override\n+    public void run() {\n+        logger.trace(\"starting modem db builder thread\");\n+        while (!isComplete()) {\n+            startDownload();\n+            try {\n+                Thread.sleep(m_timeoutMillis); // wait for download to complete\n+            } catch (InterruptedException e) {\n+                logger.warn(\"modem db builder thread interrupted\");\n+                break;\n+            }\n+            if (!isComplete()) {\n+                logger.warn(\"modem database download unsuccessful, restarting!\");\n+            }\n+        }\n+        logger.trace(\"exiting modem db builder thread\");\n+    }\n+\n+    private void getFirstLinkRecord() {\n+        try {\n+            m_port.writeMessage(Msg.s_makeMessage(\"GetFirstALLLinkRecord\"));\n+        } catch (IOException e) {\n+            logger.warn(\"error sending link record query \", e);\n+        }\n+\n+    }\n+\n+    /**\n+     * processes link record messages from the modem to build database\n+     * and request more link records if not finished.\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void msg(Msg msg, String fromPort) {\n+        if (msg.isPureNack()) {\n+            return;\n+        }\n+        try {\n+            if (msg.getByte(\"Cmd\") == 0x69 || msg.getByte(\"Cmd\") == 0x6a) {\n+                // If the flag is \"ACK/NACK\", a record response\n+                // will follow, so we do nothing here.\n+                // If its \"NACK\", there are none\n+                if (msg.getByte(\"ACK/NACK\") == 0x15) {\n+                    logger.debug(\"got all link records.\");\n+                    done();\n+                }\n+            } else if (msg.getByte(\"Cmd\") == 0x57) {\n+                // we got the link record response\n+                updateModemDB(msg.getAddress(\"LinkAddr\"), m_port, msg);\n+                m_port.writeMessage(Msg.s_makeMessage(\"GetNextALLLinkRecord\"));\n+            }\n+        } catch (FieldException e) {\n+            logger.debug(\"bad field handling link records {}\", e.getMessage());\n+        } catch (IOException e) {\n+            logger.debug(\"got IO exception handling link records {}\", e.getMessage());\n+        } catch (IllegalStateException e) {\n+            logger.debug(\"got exception requesting link records {}\", e.getMessage());\n+        }\n+    }\n+\n+    private synchronized void done() {\n+        m_isComplete = true;\n+        logModemDB();\n+        m_port.removeListener(this);\n+        m_port.modemDBComplete();\n+    }\n+\n+    private void logModemDB() {\n+        try {\n+            logger.debug(\"MDB ------- start of modem link records ------------------\");\n+            HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = m_port.getDriver().lockModemDBEntries();\n+            for (Entry<InsteonAddress, @Nullable ModemDBEntry> db : dbes.entrySet()) {\n+                ArrayList<Msg> lrs = db.getValue().getLinkRecords();\n+                for (Msg m : lrs) {\n+                    int recordFlags = m.getByte(\"RecordFlags\") & 0xff;\n+                    String ms = ((recordFlags & (0x1 << 6)) != 0) ? \"CTRL\" : \"RESP\";\n+                    logger.debug(\"MDB {}: {} group: {} data1: {} data2: {} data3: {}\", db.getKey(), ms,\n+                            toHex(m.getByte(\"ALLLinkGroup\")), toHex(m.getByte(\"LinkData1\")),\n+                            toHex(m.getByte(\"LinkData2\")), toHex(m.getByte(\"LinkData2\")));\n+                }\n+                logger.debug(\"MDB -----\");\n+            }\n+            logger.debug(\"MDB ---------------- end of modem link records -----------\");\n+        } catch (FieldException e) {\n+            logger.warn(\"cannot access field:\", e);\n+        } finally {\n+            m_port.getDriver().unlockModemDBEntries();\n+        }\n+    }\n+\n+    public static String toHex(byte b) {\n+        return Utils.getHexString(b);\n+    }\n+\n+    public void updateModemDB(InsteonAddress linkAddr, Port port, @Nullable Msg m) {\n+        HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = port.getDriver().lockModemDBEntries();\n+        ModemDBEntry dbe = dbes.get(linkAddr);\n+        if (dbe == null) {\n+            dbe = new ModemDBEntry(linkAddr);\n+            dbes.put(linkAddr, dbe);\n+        }\n+        dbe.setPort(port);\n+        if (m != null) {\n+            dbe.addLinkRecord(m);\n+            try {\n+                byte group = m.getByte(\"ALLLinkGroup\");\n+                int recordFlags = m.getByte(\"RecordFlags\") & 0xff;\n+                if ((recordFlags & (0x1 << 6)) != 0) {\n+                    dbe.addControls(group);\n+                } else {\n+                    dbe.addRespondsTo(group);\n+                }\n+            } catch (FieldException e) {\n+                logger.warn(\"cannot access field:\", e);\n+            }\n+        }\n+        port.getDriver().unlockModemDBEntries();", "originalCommit": "ed93353c47fa5d457223c66d8f91b1c168a57e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzOTIxNg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387339216", "bodyText": "changed", "author": "robnielsen", "createdAt": "2020-03-03T22:42:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc3NzQ1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNDY4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387434681", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private HashMap<String, DeviceType> m_deviceTypes = new HashMap<String, DeviceType>();\n          \n          \n            \n                private final HashMap<String, DeviceType> m_deviceTypes = new HashMap<String, DeviceType>();", "author": "cpmeister", "createdAt": "2020-03-04T03:45:15Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceTypeLoader.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.HashMap;\n+import java.util.Map.Entry;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.DeviceType.FeatureGroup;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * Reads the device types from an xml file.\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public class DeviceTypeLoader {\n+    private static final Logger logger = LoggerFactory.getLogger(DeviceTypeLoader.class);\n+    private HashMap<String, DeviceType> m_deviceTypes = new HashMap<String, DeviceType>();", "originalCommit": "c7145825da480ffe00ceee1c54e253bfc879b555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2MDIwMA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387660200", "bodyText": "This passes the code analysis checks leaving as is.", "author": "robnielsen", "createdAt": "2020-03-04T13:19:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNDY4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNjg2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387436862", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private String m_name;\n          \n          \n            \n                    private String m_type;\n          \n          \n            \n                    private final String m_name;\n          \n          \n            \n                    private final String m_type;", "author": "cpmeister", "createdAt": "2020-03-04T03:55:27Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceType.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The DeviceType class holds device type definitions that are read from\n+ * an xml file.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public class DeviceType {\n+    private String m_productKey;\n+    private String m_model = \"\";\n+    private String m_description = \"\";\n+    private HashMap<String, String> m_features = new HashMap<String, String>();\n+    private HashMap<String, FeatureGroup> m_featureGroups = new HashMap<String, FeatureGroup>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param aProductKey the product key for this device type\n+     */\n+    public DeviceType(String aProductKey) {\n+        m_productKey = aProductKey;\n+    }\n+\n+    /**\n+     * Get supported features\n+     *\n+     * @return all features that this device type supports\n+     */\n+    public HashMap<String, String> getFeatures() {\n+        return m_features;\n+    }\n+\n+    /**\n+     * Get all feature groups\n+     *\n+     * @return all feature groups of this device type\n+     */\n+    public HashMap<String, FeatureGroup> getFeatureGroups() {\n+        return m_featureGroups;\n+    }\n+\n+    /**\n+     * Sets the descriptive model string\n+     *\n+     * @param aModel descriptive model string\n+     */\n+    public void setModel(String aModel) {\n+        m_model = aModel;\n+    }\n+\n+    /**\n+     * Sets free text description\n+     *\n+     * @param aDesc free text description\n+     */\n+    public void setDescription(String aDesc) {\n+        m_description = aDesc;\n+    }\n+\n+    /**\n+     * Adds feature to this device type\n+     *\n+     * @param aKey the key (e.g. \"switch\") under which this feature can be referenced in the item binding config\n+     * @param aFeatureName the name (e.g. \"GenericSwitch\") under which the feature has been defined\n+     * @return false if feature was already there\n+     */\n+    public boolean addFeature(String aKey, String aFeatureName) {\n+        if (m_features.containsKey(aKey)) {\n+            return false;\n+        }\n+        m_features.put(aKey, aFeatureName);\n+        return true;\n+    }\n+\n+    /**\n+     * Adds feature group to device type\n+     *\n+     * @param aKey name of the feature group, which acts as key for lookup later\n+     * @param fg feature group to add\n+     * @return true if add succeeded, false if group was already there\n+     */\n+    public boolean addFeatureGroup(String aKey, FeatureGroup fg) {\n+        if (m_features.containsKey(aKey)) {\n+            return false;\n+        }\n+        m_featureGroups.put(aKey, fg);\n+        return true;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String s = \"pk:\" + m_productKey + \"|model:\" + m_model + \"|desc:\" + m_description + \"|features\";\n+        for (Entry<String, String> f : m_features.entrySet()) {\n+            s += \":\" + f.getKey() + \"=\" + f.getValue();\n+        }\n+        s += \"|groups\";\n+        for (Entry<String, FeatureGroup> f : m_featureGroups.entrySet()) {\n+            s += \":\" + f.getKey() + \"=\" + f.getValue();\n+        }\n+        return s;\n+    }\n+\n+    /**\n+     * Class that reflects feature group association\n+     *\n+     * @author Bernd Pfrommer - Initial contribution\n+     */\n+    @NonNullByDefault\n+    public static class FeatureGroup {\n+        private String m_name;\n+        private String m_type;", "originalCommit": "c7145825da480ffe00ceee1c54e253bfc879b555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2MDMyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387660329", "bodyText": "This passes the code analysis checks leaving as is.", "author": "robnielsen", "createdAt": "2020-03-04T13:19:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNjg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNjk0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387436942", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String m_productKey;\n          \n          \n            \n                private final String m_productKey;", "author": "cpmeister", "createdAt": "2020-03-04T03:55:46Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceType.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The DeviceType class holds device type definitions that are read from\n+ * an xml file.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public class DeviceType {\n+    private String m_productKey;", "originalCommit": "c7145825da480ffe00ceee1c54e253bfc879b555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2MDQzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387660435", "bodyText": "This passes the code analysis checks leaving as is.", "author": "robnielsen", "createdAt": "2020-03-04T13:19:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNjk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNzEyOA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387437128", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private HashMap<String, String> m_features = new HashMap<String, String>();\n          \n          \n            \n                private HashMap<String, FeatureGroup> m_featureGroups = new HashMap<String, FeatureGroup>();\n          \n          \n            \n                private final HashMap<String, String> m_features = new HashMap<String, String>();\n          \n          \n            \n                private final HashMap<String, FeatureGroup> m_featureGroups = new HashMap<String, FeatureGroup>();", "author": "cpmeister", "createdAt": "2020-03-04T03:56:46Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceType.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The DeviceType class holds device type definitions that are read from\n+ * an xml file.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public class DeviceType {\n+    private String m_productKey;\n+    private String m_model = \"\";\n+    private String m_description = \"\";\n+    private HashMap<String, String> m_features = new HashMap<String, String>();\n+    private HashMap<String, FeatureGroup> m_featureGroups = new HashMap<String, FeatureGroup>();", "originalCommit": "c7145825da480ffe00ceee1c54e253bfc879b555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2MDUwMA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387660500", "bodyText": "This passes the code analysis checks leaving as is.", "author": "robnielsen", "createdAt": "2020-03-04T13:19:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNzEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNzMwMA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387437300", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String m_itemName;\n          \n          \n            \n                private ChannelUID m_channelUID;\n          \n          \n            \n                private HashMap<String, @Nullable String> m_parameters = new HashMap<String, @Nullable String>();\n          \n          \n            \n                private HashMap<Class<?>, @Nullable State> m_state = new HashMap<Class<?>, @Nullable State>();\n          \n          \n            \n                private ArrayList<InsteonAddress> m_relatedDevices = new ArrayList<InsteonAddress>();\n          \n          \n            \n                private InsteonBinding m_binding;\n          \n          \n            \n                private final String m_itemName;\n          \n          \n            \n                private final ChannelUID m_channelUID;\n          \n          \n            \n                private final HashMap<String, @Nullable String> m_parameters = new HashMap<String, @Nullable String>();\n          \n          \n            \n                private final HashMap<Class<?>, @Nullable State> m_state = new HashMap<Class<?>, @Nullable State>();\n          \n          \n            \n                private final ArrayList<InsteonAddress> m_relatedDevices = new ArrayList<InsteonAddress>();\n          \n          \n            \n                private final InsteonBinding m_binding;", "author": "cpmeister", "createdAt": "2020-03-04T03:57:46Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceFeatureListener.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A DeviceFeatureListener essentially represents an OpenHAB item that\n+ * listens to a particular feature of an Insteon device\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class DeviceFeatureListener {\n+    private final Logger logger = LoggerFactory.getLogger(DeviceFeatureListener.class);\n+\n+    public enum StateChangeType {\n+        ALWAYS,\n+        CHANGED\n+    };\n+\n+    private String m_itemName;\n+    private ChannelUID m_channelUID;\n+    private HashMap<String, @Nullable String> m_parameters = new HashMap<String, @Nullable String>();\n+    private HashMap<Class<?>, @Nullable State> m_state = new HashMap<Class<?>, @Nullable State>();\n+    private ArrayList<InsteonAddress> m_relatedDevices = new ArrayList<InsteonAddress>();\n+    private InsteonBinding m_binding;", "originalCommit": "c7145825da480ffe00ceee1c54e253bfc879b555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2MjE1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387662153", "bodyText": "This passes the code analysis checks leaving as is.", "author": "robnielsen", "createdAt": "2020-03-04T13:22:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNzMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzOTE2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387439166", "bodyText": "you forgot to call setDaemon(true) on the threads", "author": "cpmeister", "createdAt": "2020-03-04T04:07:37Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/Port.java", "diffHunk": "@@ -161,10 +161,10 @@ public void start() {\n             return;\n         }\n         m_readThread = new Thread(m_reader);\n-        m_writeThread = new Thread(m_writer);\n-        m_readThread.setName(m_logName + \" Reader\");\n-        m_writeThread.setName(m_logName + \" Writer\");\n+        m_readThread.setName(\"Insteon \" + m_logName + \" Reader\");\n         m_readThread.start();\n+        m_writeThread = new Thread(m_writer);\n+        m_writeThread.setName(\"Insteon \" + m_logName + \" Writer\");\n         m_writeThread.start();", "originalCommit": "9c45d84e5fc09e1ff59474c5e9a2f5dde141d337", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY5Njk3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r388696972", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-06T03:30:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzOTE2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzOTI5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387439291", "bodyText": "set thread to daemon too", "author": "cpmeister", "createdAt": "2020-03-04T04:08:20Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/hub/HubIOStream.java", "diffHunk": "@@ -95,6 +95,7 @@ public boolean open() {\n \n         polling = true;\n         m_pollThread = new Thread(this);\n+        m_pollThread.setName(\"Insteon Hub Poller\");", "originalCommit": "9c45d84e5fc09e1ff59474c5e9a2f5dde141d337", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY5MTg2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r388691867", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-06T03:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzOTI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzOTYzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387439631", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String m_name;\n          \n          \n            \n                private String m_timeout;\n          \n          \n            \n                private boolean m_isStatus;\n          \n          \n            \n                private @Nullable HandlerEntry m_dispatcher = null;\n          \n          \n            \n                private @Nullable HandlerEntry m_pollHandler = null;\n          \n          \n            \n                private @Nullable HandlerEntry m_defaultMsgHandler = null;\n          \n          \n            \n                private @Nullable HandlerEntry m_defaultCmdHandler = null;\n          \n          \n            \n                private HashMap<Integer, HandlerEntry> m_messageHandlers = new HashMap<Integer, HandlerEntry>();\n          \n          \n            \n                private HashMap<Class<? extends Command>, HandlerEntry> m_commandHandlers = new HashMap<Class<? extends Command>, HandlerEntry>();\n          \n          \n            \n                private final String m_name;\n          \n          \n            \n                private final String m_timeout;\n          \n          \n            \n                private final boolean m_isStatus;\n          \n          \n            \n                private @Nullable HandlerEntry m_dispatcher = null;\n          \n          \n            \n                private @Nullable HandlerEntry m_pollHandler = null;\n          \n          \n            \n                private @Nullable HandlerEntry m_defaultMsgHandler = null;\n          \n          \n            \n                private @Nullable HandlerEntry m_defaultCmdHandler = null;\n          \n          \n            \n                private final HashMap<Integer, HandlerEntry> m_messageHandlers = new HashMap<Integer, HandlerEntry>();\n          \n          \n            \n                private final HashMap<Class<? extends Command>, HandlerEntry> m_commandHandlers = new HashMap<Class<? extends Command>, HandlerEntry>();", "author": "cpmeister", "createdAt": "2020-03-04T04:10:03Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/FeatureTemplate.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.util.HashMap;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.Command;\n+\n+/**\n+ * A simple class which contains the basic info needed to create a device feature.\n+ * Here, all handlers are represented as strings. The actual device feature\n+ * is then instantiated from the template by calling the build() function.\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public class FeatureTemplate {\n+    private String m_name;\n+    private String m_timeout;\n+    private boolean m_isStatus;\n+    private @Nullable HandlerEntry m_dispatcher = null;\n+    private @Nullable HandlerEntry m_pollHandler = null;\n+    private @Nullable HandlerEntry m_defaultMsgHandler = null;\n+    private @Nullable HandlerEntry m_defaultCmdHandler = null;\n+    private HashMap<Integer, HandlerEntry> m_messageHandlers = new HashMap<Integer, HandlerEntry>();\n+    private HashMap<Class<? extends Command>, HandlerEntry> m_commandHandlers = new HashMap<Class<? extends Command>, HandlerEntry>();", "originalCommit": "c7145825da480ffe00ceee1c54e253bfc879b555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2MzcxOA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387663718", "bodyText": "This passes the code analysis checks leaving as is.", "author": "robnielsen", "createdAt": "2020-03-04T13:25:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzOTYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MDU1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389160552", "bodyText": "Could you please do a bulk search+replace to fix the spelling of \"OpenHAB\" to the correct \"openHAB\"? Thanks!", "author": "kaikreuzer", "createdAt": "2020-03-06T21:48:03Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceFeatureListener.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A DeviceFeatureListener essentially represents an OpenHAB item that\n+ * listens to a particular feature of an Insteon device\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding", "originalCommit": "94f7f27e5dc60b3961fd689b57f8c0c54fd764b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2Mjg5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389162897", "bodyText": "No problem, updated and pushed out.", "author": "robnielsen", "createdAt": "2020-03-06T21:54:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MDU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzEzMA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317130", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"device {} has not responded to polls for {} sec\", dev.toString(),\n          \n          \n            \n                            logger.debug(\"device {} has not responded to polls for {} sec\", dev.toString(),", "author": "kaikreuzer", "createdAt": "2020-03-07T22:33:37Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the openHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings({ \"null\", \"unused\" })\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> devices = new ConcurrentHashMap<>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener portListener = new PortListener();\n+    private int devicePollIntervalMilliseconds = 300000;\n+    private int deadDeviceTimeout = -1;\n+    private int messagesReceived = 0;\n+    private boolean isActive = false; // state of binding\n+    private int x10HouseUnit = -1;\n+    private InsteonNetworkHandler handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config,\n+            @Nullable SerialPortManager serialPortManager) {\n+        this.handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.debug(\"device poll interval set to {} seconds\", devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.debug(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.instance().loadDeviceTypesXML(additionalDevices);\n+                logger.debug(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.debug(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        deadDeviceTimeout = devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.debug(\"dead device timeout set to {} seconds\", deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", Utils.redactPassword(port));\n+        driver.addPort(\"port\", port, serialPortManager);\n+        driver.addMsgListener(portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        driver.setDriverListener(portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", driver.getNumberOfPorts());\n+\n+        driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        this.isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuilder buf = new StringBuilder();\n+            ArrayList<String> names = new ArrayList<>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(driver);\n+        dev.addPort(driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(devicePollIntervalMilliseconds);\n+        }\n+        if (driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.instance().startPolling(dev, ndev);\n+            }\n+        }\n+        devices.put(addr, dev);\n+\n+        handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        try {\n+            InsteonAddress addr = dev.getAddress();\n+            HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = driver.lockModemDBEntries();\n+            if (dbes.containsKey(addr)) {\n+                if (!dev.hasModemDBEntry()) {\n+                    logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                    dev.setHasModemDBEntry(true);\n+                }\n+            } else {\n+                if (driver.isModemDBComplete() && !addr.isX10()) {\n+                    logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+                }\n+            }\n+            return dbes.size();\n+        } finally {\n+            driver.unlockModemDBEntries();\n+        }\n+    }\n+\n+    /**\n+     * Everything below was copied from Insteon PLM v1\n+     */\n+\n+    /**\n+     * Clean up all state.\n+     */\n+    public void shutdown() {\n+        logger.debug(\"shutting down Insteon bridge\");\n+        driver.stopAllPorts();\n+        devices.clear();\n+        RequestQueueManager.destroyInstance();\n+        Poller.instance().stop();\n+        isActive = false;\n+    }\n+\n+    /**\n+     * Method to find a device by address\n+     *\n+     * @param aAddr the insteon address to search for\n+     * @return reference to the device, or null if not found\n+     */\n+    public @Nullable InsteonDevice getDevice(@Nullable InsteonAddress aAddr) {\n+        InsteonDevice dev = (aAddr == null) ? null : devices.get(aAddr);\n+        return (dev);\n+    }\n+\n+    private String getLinkInfo(HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes, InsteonAddress a) {\n+        ModemDBEntry dbe = dbes.get(a);\n+        ArrayList<Byte> controls = dbe.getControls();\n+        ArrayList<Byte> responds = dbe.getRespondsTo();\n+\n+        StringBuilder buf = new StringBuilder(\"the modem\");\n+        if (!controls.isEmpty()) {\n+            buf.append(\" controls groups [\");\n+            buf.append(toGroupString(controls));\n+            buf.append(\"]\");\n+        }\n+\n+        if (!responds.isEmpty()) {\n+            if (!controls.isEmpty()) {\n+                buf.append(\" and\");\n+            }\n+\n+            buf.append(\" responds to groups [\");\n+            buf.append(toGroupString(responds));\n+            buf.append(\"]\");\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuilder buf = new StringBuilder();\n+        for (Byte b : sorted) {\n+            if (buf.length() > 0) {\n+                buf.append(\",\");\n+            }\n+            buf.append(\"0x\");\n+            buf.append(Utils.getHexString(b));\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    public void logDeviceStatistics() {\n+        String msg = String.format(\"devices: %3d configured, %3d polling, msgs received: %5d\", devices.size(),\n+                Poller.instance().getSizeOfQueue(), messagesReceived);\n+        logger.info(\"{}\", msg);\n+        messagesReceived = 0;\n+        for (InsteonDevice dev : devices.values()) {\n+            if (dev.isModem()) {\n+                continue;\n+            }\n+            if (deadDeviceTimeout > 0 && dev.getPollOverDueTime() > deadDeviceTimeout) {\n+                logger.warn(\"device {} has not responded to polls for {} sec\", dev.toString(),", "originalCommit": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMyNTM3MA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389325370", "bodyText": "This is actually a useful message, sometimes devices stop responding to polling, and then they start to work again.", "author": "robnielsen", "createdAt": "2020-03-08T01:14:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzEzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3NTkzNg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389375936", "bodyText": "It doesn't happen very often, but I occasionally see a few in the log file.", "author": "robnielsen", "createdAt": "2020-03-08T14:47:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzEzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3OTE0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389979141", "bodyText": "In that situation, you should change the thing status to OFFLINE with an according message. Logging should be debug, unless there's a fatal misconfiguration or a bug in the code that should be reported.", "author": "kaikreuzer", "createdAt": "2020-03-09T21:44:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzEzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NTk0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389995946", "bodyText": "The device is still working, but sometimes the messages sent to it are missed. It's a situation that would be good to let a user know, how do you do that?", "author": "robnielsen", "createdAt": "2020-03-09T22:27:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzEzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NjgwMw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389996803", "bodyText": "The device is still working\n\nCan you be sure of that?\n\nhow do you do that?\n\nBy updating the thing status with a message. You can also do this on an ONLINE status. The status change will be available in the log and the message can also be seen in the UI.", "author": "kaikreuzer", "createdAt": "2020-03-09T22:30:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzEzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyNDMwMA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390024300", "bodyText": "I changed it to debug, and will address it later when I implement the console commands.", "author": "robnielsen", "createdAt": "2020-03-09T23:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzEzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzE0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317145", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.info(\"modem database has {} entries!\", dbes.size());\n          \n          \n            \n                            logger.debug(\"modem database has {} entries!\", dbes.size());", "author": "kaikreuzer", "createdAt": "2020-03-07T22:33:56Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the openHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings({ \"null\", \"unused\" })\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> devices = new ConcurrentHashMap<>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener portListener = new PortListener();\n+    private int devicePollIntervalMilliseconds = 300000;\n+    private int deadDeviceTimeout = -1;\n+    private int messagesReceived = 0;\n+    private boolean isActive = false; // state of binding\n+    private int x10HouseUnit = -1;\n+    private InsteonNetworkHandler handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config,\n+            @Nullable SerialPortManager serialPortManager) {\n+        this.handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.debug(\"device poll interval set to {} seconds\", devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.debug(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.instance().loadDeviceTypesXML(additionalDevices);\n+                logger.debug(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.debug(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        deadDeviceTimeout = devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.debug(\"dead device timeout set to {} seconds\", deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", Utils.redactPassword(port));\n+        driver.addPort(\"port\", port, serialPortManager);\n+        driver.addMsgListener(portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        driver.setDriverListener(portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", driver.getNumberOfPorts());\n+\n+        driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        this.isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuilder buf = new StringBuilder();\n+            ArrayList<String> names = new ArrayList<>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(driver);\n+        dev.addPort(driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(devicePollIntervalMilliseconds);\n+        }\n+        if (driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.instance().startPolling(dev, ndev);\n+            }\n+        }\n+        devices.put(addr, dev);\n+\n+        handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        try {\n+            InsteonAddress addr = dev.getAddress();\n+            HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = driver.lockModemDBEntries();\n+            if (dbes.containsKey(addr)) {\n+                if (!dev.hasModemDBEntry()) {\n+                    logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                    dev.setHasModemDBEntry(true);\n+                }\n+            } else {\n+                if (driver.isModemDBComplete() && !addr.isX10()) {\n+                    logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+                }\n+            }\n+            return dbes.size();\n+        } finally {\n+            driver.unlockModemDBEntries();\n+        }\n+    }\n+\n+    /**\n+     * Everything below was copied from Insteon PLM v1\n+     */\n+\n+    /**\n+     * Clean up all state.\n+     */\n+    public void shutdown() {\n+        logger.debug(\"shutting down Insteon bridge\");\n+        driver.stopAllPorts();\n+        devices.clear();\n+        RequestQueueManager.destroyInstance();\n+        Poller.instance().stop();\n+        isActive = false;\n+    }\n+\n+    /**\n+     * Method to find a device by address\n+     *\n+     * @param aAddr the insteon address to search for\n+     * @return reference to the device, or null if not found\n+     */\n+    public @Nullable InsteonDevice getDevice(@Nullable InsteonAddress aAddr) {\n+        InsteonDevice dev = (aAddr == null) ? null : devices.get(aAddr);\n+        return (dev);\n+    }\n+\n+    private String getLinkInfo(HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes, InsteonAddress a) {\n+        ModemDBEntry dbe = dbes.get(a);\n+        ArrayList<Byte> controls = dbe.getControls();\n+        ArrayList<Byte> responds = dbe.getRespondsTo();\n+\n+        StringBuilder buf = new StringBuilder(\"the modem\");\n+        if (!controls.isEmpty()) {\n+            buf.append(\" controls groups [\");\n+            buf.append(toGroupString(controls));\n+            buf.append(\"]\");\n+        }\n+\n+        if (!responds.isEmpty()) {\n+            if (!controls.isEmpty()) {\n+                buf.append(\" and\");\n+            }\n+\n+            buf.append(\" responds to groups [\");\n+            buf.append(toGroupString(responds));\n+            buf.append(\"]\");\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuilder buf = new StringBuilder();\n+        for (Byte b : sorted) {\n+            if (buf.length() > 0) {\n+                buf.append(\",\");\n+            }\n+            buf.append(\"0x\");\n+            buf.append(Utils.getHexString(b));\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    public void logDeviceStatistics() {\n+        String msg = String.format(\"devices: %3d configured, %3d polling, msgs received: %5d\", devices.size(),\n+                Poller.instance().getSizeOfQueue(), messagesReceived);\n+        logger.info(\"{}\", msg);\n+        messagesReceived = 0;\n+        for (InsteonDevice dev : devices.values()) {\n+            if (dev.isModem()) {\n+                continue;\n+            }\n+            if (deadDeviceTimeout > 0 && dev.getPollOverDueTime() > deadDeviceTimeout) {\n+                logger.warn(\"device {} has not responded to polls for {} sec\", dev.toString(),\n+                        dev.getPollOverDueTime() / 3600);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles messages that come in from the ports.\n+     * Will only process one message at a time.\n+     */\n+    @NonNullByDefault\n+    private class PortListener implements MsgListener, DriverListener {\n+        @Override\n+        public void msg(Msg msg, String fromPort) {\n+            if (msg.isEcho() || msg.isPureNack()) {\n+                return;\n+            }\n+            messagesReceived++;\n+            logger.debug(\"got msg: {}\", msg);\n+            if (msg.isX10()) {\n+                handleX10Message(msg, fromPort);\n+            } else {\n+                handleInsteonMessage(msg, fromPort);\n+            }\n+\n+        }\n+\n+        @Override\n+        public void driverCompletelyInitialized() {\n+            List<String> missing = new ArrayList<String>();\n+            try {\n+                HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = driver.lockModemDBEntries();\n+                logger.info(\"modem database has {} entries!\", dbes.size());", "originalCommit": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3NjU1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389376552", "bodyText": "After this PR is approved, I plan on implement something similar to what Powermax does (https://www.openhab.org/addons/bindings/powermax/#console-commands). Can I leave as is until I get it implemented?  It's bascially there for support.", "author": "robnielsen", "createdAt": "2020-03-08T14:53:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzE0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3OTkyNg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389979926", "bodyText": "No, please change it - history tells us that it otherwise will easily be forgotten...", "author": "kaikreuzer", "createdAt": "2020-03-09T21:46:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzE0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMDAyNw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390000027", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-09T22:38:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzE0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzE4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317185", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        logger.info(\"device {} found in the modem database and {}.\", a, getLinkInfo(dbes, a));\n          \n          \n            \n                                        logger.debug(\"device {} found in the modem database and {}.\", a, getLinkInfo(dbes, a));", "author": "kaikreuzer", "createdAt": "2020-03-07T22:34:25Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the openHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings({ \"null\", \"unused\" })\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> devices = new ConcurrentHashMap<>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener portListener = new PortListener();\n+    private int devicePollIntervalMilliseconds = 300000;\n+    private int deadDeviceTimeout = -1;\n+    private int messagesReceived = 0;\n+    private boolean isActive = false; // state of binding\n+    private int x10HouseUnit = -1;\n+    private InsteonNetworkHandler handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config,\n+            @Nullable SerialPortManager serialPortManager) {\n+        this.handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.debug(\"device poll interval set to {} seconds\", devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.debug(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.instance().loadDeviceTypesXML(additionalDevices);\n+                logger.debug(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.debug(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        deadDeviceTimeout = devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.debug(\"dead device timeout set to {} seconds\", deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", Utils.redactPassword(port));\n+        driver.addPort(\"port\", port, serialPortManager);\n+        driver.addMsgListener(portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        driver.setDriverListener(portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", driver.getNumberOfPorts());\n+\n+        driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        this.isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuilder buf = new StringBuilder();\n+            ArrayList<String> names = new ArrayList<>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(driver);\n+        dev.addPort(driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(devicePollIntervalMilliseconds);\n+        }\n+        if (driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.instance().startPolling(dev, ndev);\n+            }\n+        }\n+        devices.put(addr, dev);\n+\n+        handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        try {\n+            InsteonAddress addr = dev.getAddress();\n+            HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = driver.lockModemDBEntries();\n+            if (dbes.containsKey(addr)) {\n+                if (!dev.hasModemDBEntry()) {\n+                    logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                    dev.setHasModemDBEntry(true);\n+                }\n+            } else {\n+                if (driver.isModemDBComplete() && !addr.isX10()) {\n+                    logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+                }\n+            }\n+            return dbes.size();\n+        } finally {\n+            driver.unlockModemDBEntries();\n+        }\n+    }\n+\n+    /**\n+     * Everything below was copied from Insteon PLM v1\n+     */\n+\n+    /**\n+     * Clean up all state.\n+     */\n+    public void shutdown() {\n+        logger.debug(\"shutting down Insteon bridge\");\n+        driver.stopAllPorts();\n+        devices.clear();\n+        RequestQueueManager.destroyInstance();\n+        Poller.instance().stop();\n+        isActive = false;\n+    }\n+\n+    /**\n+     * Method to find a device by address\n+     *\n+     * @param aAddr the insteon address to search for\n+     * @return reference to the device, or null if not found\n+     */\n+    public @Nullable InsteonDevice getDevice(@Nullable InsteonAddress aAddr) {\n+        InsteonDevice dev = (aAddr == null) ? null : devices.get(aAddr);\n+        return (dev);\n+    }\n+\n+    private String getLinkInfo(HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes, InsteonAddress a) {\n+        ModemDBEntry dbe = dbes.get(a);\n+        ArrayList<Byte> controls = dbe.getControls();\n+        ArrayList<Byte> responds = dbe.getRespondsTo();\n+\n+        StringBuilder buf = new StringBuilder(\"the modem\");\n+        if (!controls.isEmpty()) {\n+            buf.append(\" controls groups [\");\n+            buf.append(toGroupString(controls));\n+            buf.append(\"]\");\n+        }\n+\n+        if (!responds.isEmpty()) {\n+            if (!controls.isEmpty()) {\n+                buf.append(\" and\");\n+            }\n+\n+            buf.append(\" responds to groups [\");\n+            buf.append(toGroupString(responds));\n+            buf.append(\"]\");\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuilder buf = new StringBuilder();\n+        for (Byte b : sorted) {\n+            if (buf.length() > 0) {\n+                buf.append(\",\");\n+            }\n+            buf.append(\"0x\");\n+            buf.append(Utils.getHexString(b));\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    public void logDeviceStatistics() {\n+        String msg = String.format(\"devices: %3d configured, %3d polling, msgs received: %5d\", devices.size(),\n+                Poller.instance().getSizeOfQueue(), messagesReceived);\n+        logger.info(\"{}\", msg);\n+        messagesReceived = 0;\n+        for (InsteonDevice dev : devices.values()) {\n+            if (dev.isModem()) {\n+                continue;\n+            }\n+            if (deadDeviceTimeout > 0 && dev.getPollOverDueTime() > deadDeviceTimeout) {\n+                logger.warn(\"device {} has not responded to polls for {} sec\", dev.toString(),\n+                        dev.getPollOverDueTime() / 3600);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles messages that come in from the ports.\n+     * Will only process one message at a time.\n+     */\n+    @NonNullByDefault\n+    private class PortListener implements MsgListener, DriverListener {\n+        @Override\n+        public void msg(Msg msg, String fromPort) {\n+            if (msg.isEcho() || msg.isPureNack()) {\n+                return;\n+            }\n+            messagesReceived++;\n+            logger.debug(\"got msg: {}\", msg);\n+            if (msg.isX10()) {\n+                handleX10Message(msg, fromPort);\n+            } else {\n+                handleInsteonMessage(msg, fromPort);\n+            }\n+\n+        }\n+\n+        @Override\n+        public void driverCompletelyInitialized() {\n+            List<String> missing = new ArrayList<String>();\n+            try {\n+                HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = driver.lockModemDBEntries();\n+                logger.info(\"modem database has {} entries!\", dbes.size());\n+                if (dbes.isEmpty()) {\n+                    logger.warn(\"the modem link database is empty!\");\n+                }\n+                for (InsteonAddress k : dbes.keySet()) {\n+                    logger.debug(\"modem db entry: {}\", k);\n+                }\n+                HashSet<InsteonAddress> addrs = new HashSet<>();\n+                for (InsteonDevice dev : devices.values()) {\n+                    InsteonAddress a = dev.getAddress();\n+                    if (!dbes.containsKey(a)) {\n+                        if (!a.isX10()) {\n+                            logger.warn(\"device {} not found in the modem database. Did you forget to link?\", a);\n+                        }\n+                    } else {\n+                        if (!dev.hasModemDBEntry()) {\n+                            addrs.add(a);\n+                            logger.info(\"device {} found in the modem database and {}.\", a, getLinkInfo(dbes, a));", "originalCommit": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3NjU3NA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389376574", "bodyText": "After this PR is approved, I plan on implement something similar to what Powermax does (https://www.openhab.org/addons/bindings/powermax/#console-commands). Can I leave as is until I get it implemented?  It's bascially there for support.", "author": "robnielsen", "createdAt": "2020-03-08T14:53:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzE4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4MDAyNw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389980027", "bodyText": "dito", "author": "kaikreuzer", "createdAt": "2020-03-09T21:46:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzE4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMzE1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390003157", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-09T22:47:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzE5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317195", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    logger.info(\"device {} found in the modem database, but is not configured as a thing and {}.\",\n          \n          \n            \n                                    logger.debug(\"device {} found in the modem database, but is not configured as a thing and {}.\",", "author": "kaikreuzer", "createdAt": "2020-03-07T22:34:42Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the openHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings({ \"null\", \"unused\" })\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> devices = new ConcurrentHashMap<>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener portListener = new PortListener();\n+    private int devicePollIntervalMilliseconds = 300000;\n+    private int deadDeviceTimeout = -1;\n+    private int messagesReceived = 0;\n+    private boolean isActive = false; // state of binding\n+    private int x10HouseUnit = -1;\n+    private InsteonNetworkHandler handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config,\n+            @Nullable SerialPortManager serialPortManager) {\n+        this.handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.debug(\"device poll interval set to {} seconds\", devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.debug(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.instance().loadDeviceTypesXML(additionalDevices);\n+                logger.debug(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.debug(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        deadDeviceTimeout = devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.debug(\"dead device timeout set to {} seconds\", deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", Utils.redactPassword(port));\n+        driver.addPort(\"port\", port, serialPortManager);\n+        driver.addMsgListener(portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        driver.setDriverListener(portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", driver.getNumberOfPorts());\n+\n+        driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        this.isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuilder buf = new StringBuilder();\n+            ArrayList<String> names = new ArrayList<>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(driver);\n+        dev.addPort(driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(devicePollIntervalMilliseconds);\n+        }\n+        if (driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.instance().startPolling(dev, ndev);\n+            }\n+        }\n+        devices.put(addr, dev);\n+\n+        handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        try {\n+            InsteonAddress addr = dev.getAddress();\n+            HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = driver.lockModemDBEntries();\n+            if (dbes.containsKey(addr)) {\n+                if (!dev.hasModemDBEntry()) {\n+                    logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                    dev.setHasModemDBEntry(true);\n+                }\n+            } else {\n+                if (driver.isModemDBComplete() && !addr.isX10()) {\n+                    logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+                }\n+            }\n+            return dbes.size();\n+        } finally {\n+            driver.unlockModemDBEntries();\n+        }\n+    }\n+\n+    /**\n+     * Everything below was copied from Insteon PLM v1\n+     */\n+\n+    /**\n+     * Clean up all state.\n+     */\n+    public void shutdown() {\n+        logger.debug(\"shutting down Insteon bridge\");\n+        driver.stopAllPorts();\n+        devices.clear();\n+        RequestQueueManager.destroyInstance();\n+        Poller.instance().stop();\n+        isActive = false;\n+    }\n+\n+    /**\n+     * Method to find a device by address\n+     *\n+     * @param aAddr the insteon address to search for\n+     * @return reference to the device, or null if not found\n+     */\n+    public @Nullable InsteonDevice getDevice(@Nullable InsteonAddress aAddr) {\n+        InsteonDevice dev = (aAddr == null) ? null : devices.get(aAddr);\n+        return (dev);\n+    }\n+\n+    private String getLinkInfo(HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes, InsteonAddress a) {\n+        ModemDBEntry dbe = dbes.get(a);\n+        ArrayList<Byte> controls = dbe.getControls();\n+        ArrayList<Byte> responds = dbe.getRespondsTo();\n+\n+        StringBuilder buf = new StringBuilder(\"the modem\");\n+        if (!controls.isEmpty()) {\n+            buf.append(\" controls groups [\");\n+            buf.append(toGroupString(controls));\n+            buf.append(\"]\");\n+        }\n+\n+        if (!responds.isEmpty()) {\n+            if (!controls.isEmpty()) {\n+                buf.append(\" and\");\n+            }\n+\n+            buf.append(\" responds to groups [\");\n+            buf.append(toGroupString(responds));\n+            buf.append(\"]\");\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuilder buf = new StringBuilder();\n+        for (Byte b : sorted) {\n+            if (buf.length() > 0) {\n+                buf.append(\",\");\n+            }\n+            buf.append(\"0x\");\n+            buf.append(Utils.getHexString(b));\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    public void logDeviceStatistics() {\n+        String msg = String.format(\"devices: %3d configured, %3d polling, msgs received: %5d\", devices.size(),\n+                Poller.instance().getSizeOfQueue(), messagesReceived);\n+        logger.info(\"{}\", msg);\n+        messagesReceived = 0;\n+        for (InsteonDevice dev : devices.values()) {\n+            if (dev.isModem()) {\n+                continue;\n+            }\n+            if (deadDeviceTimeout > 0 && dev.getPollOverDueTime() > deadDeviceTimeout) {\n+                logger.warn(\"device {} has not responded to polls for {} sec\", dev.toString(),\n+                        dev.getPollOverDueTime() / 3600);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles messages that come in from the ports.\n+     * Will only process one message at a time.\n+     */\n+    @NonNullByDefault\n+    private class PortListener implements MsgListener, DriverListener {\n+        @Override\n+        public void msg(Msg msg, String fromPort) {\n+            if (msg.isEcho() || msg.isPureNack()) {\n+                return;\n+            }\n+            messagesReceived++;\n+            logger.debug(\"got msg: {}\", msg);\n+            if (msg.isX10()) {\n+                handleX10Message(msg, fromPort);\n+            } else {\n+                handleInsteonMessage(msg, fromPort);\n+            }\n+\n+        }\n+\n+        @Override\n+        public void driverCompletelyInitialized() {\n+            List<String> missing = new ArrayList<String>();\n+            try {\n+                HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = driver.lockModemDBEntries();\n+                logger.info(\"modem database has {} entries!\", dbes.size());\n+                if (dbes.isEmpty()) {\n+                    logger.warn(\"the modem link database is empty!\");\n+                }\n+                for (InsteonAddress k : dbes.keySet()) {\n+                    logger.debug(\"modem db entry: {}\", k);\n+                }\n+                HashSet<InsteonAddress> addrs = new HashSet<>();\n+                for (InsteonDevice dev : devices.values()) {\n+                    InsteonAddress a = dev.getAddress();\n+                    if (!dbes.containsKey(a)) {\n+                        if (!a.isX10()) {\n+                            logger.warn(\"device {} not found in the modem database. Did you forget to link?\", a);\n+                        }\n+                    } else {\n+                        if (!dev.hasModemDBEntry()) {\n+                            addrs.add(a);\n+                            logger.info(\"device {} found in the modem database and {}.\", a, getLinkInfo(dbes, a));\n+                            dev.setHasModemDBEntry(true);\n+                        }\n+                        if (dev.getStatus() != DeviceStatus.POLLING) {\n+                            Poller.instance().startPolling(dev, dbes.size());\n+                        }\n+                    }\n+                }\n+\n+                for (InsteonAddress k : dbes.keySet()) {\n+                    if (!addrs.contains(k) && !k.equals(dbes.get(k).getPort().getAddress())) {\n+                        logger.info(\"device {} found in the modem database, but is not configured as a thing and {}.\",", "originalCommit": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3NjU4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389376581", "bodyText": "After this PR is approved, I plan on implement something similar to what Powermax does (https://www.openhab.org/addons/bindings/powermax/#console-commands). Can I leave as is until I get it implemented?  It's bascially there for support.", "author": "robnielsen", "createdAt": "2020-03-08T14:53:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzE5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4MDE2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389980161", "bodyText": "dito", "author": "kaikreuzer", "createdAt": "2020-03-09T21:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzE5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMDA4OA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390000088", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-09T22:38:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzE5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzM2MA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317360", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"{}: command send i/o error: \", nm(), e);\n          \n          \n            \n                            logger.debug(\"{}: command send i/o error: \", nm(), e);\n          \n      \n    \n    \n  \n\nInstead of logging warnings, you should set the Thing Status to OFFLINE, when the communication didn't work.", "author": "kaikreuzer", "createdAt": "2020-03-07T22:38:04Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/CommandHandler.java", "diffHunk": "@@ -0,0 +1,912 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A command handler translates an openHAB command into a insteon message\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public abstract class CommandHandler {\n+    private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);\n+    DeviceFeature feature; // related DeviceFeature\n+    @Nullable\n+    HashMap<String, @Nullable String> parameters = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param feature The DeviceFeature for which this command was intended.\n+     *            The openHAB commands are issued on an openhab item. The .items files bind\n+     *            an openHAB item to a DeviceFeature.\n+     */\n+    CommandHandler(DeviceFeature feature) {\n+        this.feature = feature;\n+    }\n+\n+    /**\n+     * Implements what to do when an openHAB command is received\n+     *\n+     * @param config the configuration for the item that generated the command\n+     * @param cmd the openhab command issued\n+     * @param device the Insteon device to which this command applies\n+     */\n+    public abstract void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice device);\n+\n+    /**\n+     * Returns parameter as integer\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected int getIntParameter(String key, int def) {\n+        String val = parameters.get(key);\n+        if (val == null) {\n+            return (def); // param not found\n+        }\n+        int ret = def;\n+        try {\n+            ret = Utils.strToInt(val);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in command handler: {}\", key);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns parameter as String\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected @Nullable String getStringParameter(String key, String def) {\n+        return (parameters.get(key) == null ? def : parameters.get(key));\n+    }\n+\n+    /**\n+     * Shorthand to return class name for logging purposes\n+     *\n+     * @return name of the class\n+     */\n+    protected String nm() {\n+        return (this.getClass().getSimpleName());\n+    }\n+\n+    protected int getMaxLightLevel(InsteonChannelConfiguration conf, int defaultLevel) {\n+        HashMap<String, @Nullable String> params = conf.getParameters();\n+        if (conf.getFeature().contains(\"dimmer\") && params.containsKey(\"dimmermax\")) {\n+            String item = conf.getChannelName();\n+            String dimmerMax = params.get(\"dimmermax\");\n+            try {\n+                int i = Integer.parseInt(dimmerMax);\n+                if (i > 1 && i <= 99) {\n+                    int level = (int) Math.ceil((i * 255.0) / 100); // round up\n+                    if (level < defaultLevel) {\n+                        logger.debug(\"item {}: using dimmermax value of {}\", item, dimmerMax);\n+                        return level;\n+                    }\n+                } else {\n+                    logger.warn(\"item {}: dimmermax must be between 1-99 inclusive: {}\", item, dimmerMax);\n+                }\n+            } catch (NumberFormatException e) {\n+                logger.warn(\"item {}: invalid int value for dimmermax: {}\", item, dimmerMax);\n+            }\n+        }\n+\n+        return defaultLevel;\n+    }\n+\n+    void setParameters(HashMap<String, @Nullable String> hm) {\n+        parameters = hm;\n+    }\n+\n+    /**\n+     * Helper function to extract the group parameter from the binding config,\n+     *\n+     * @param c the binding configuration to test\n+     * @return the value of the \"group\" parameter, or -1 if none\n+     */\n+    protected static int getGroup(InsteonChannelConfiguration c) {\n+        String v = c.getParameters().get(\"group\");\n+        int iv = -1;\n+        try {\n+            iv = (v == null) ? -1 : Utils.strToInt(v);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in for item {}\", c.getChannelName());\n+        }\n+        return iv;\n+    }\n+\n+    @NonNullByDefault\n+    public static class WarnCommandHandler extends CommandHandler {\n+        WarnCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            logger.warn(\"{}: command {} is not implemented yet!\", nm(), cmd);\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class NoOpCommandHandler extends CommandHandler {\n+        NoOpCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            // do nothing, not even log\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class LightOnOffCommandHandler extends CommandHandler {\n+        LightOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int ext = getIntParameter(\"ext\", 0);\n+                int direc = 0x00;\n+                int level = 0x00;\n+                Msg m = null;\n+                if (cmd == OnOffType.ON) {\n+                    level = getMaxLightLevel(conf, 0xff);\n+                    direc = 0x11;\n+                    logger.debug(\"{}: sent msg to switch {} to {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    direc = 0x13;\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+                if (ext == 1 || ext == 2) {\n+                    byte[] data = new byte[] { (byte) getIntParameter(\"d1\", 0), (byte) getIntParameter(\"d2\", 0),\n+                            (byte) getIntParameter(\"d3\", 0) };\n+                    m = dev.makeExtendedMessage((byte) 0x0f, (byte) direc, (byte) level, data);\n+                    logger.debug(\"{}: was an extended message for device {}\", nm(), dev.getAddress());\n+                    if (ext == 1) {\n+                        m.setCRC();\n+                    } else if (ext == 2) {\n+                        m.setCRC2();\n+                    }\n+                } else {\n+                    m = dev.makeStandardMessage((byte) 0x0f, (byte) direc, (byte) level, getGroup(conf));\n+                }\n+                logger.debug(\"Sending message to {}\", dev.getAddress());\n+                dev.enqueueMessage(m, feature);\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);", "originalCommit": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3Mjk0MA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389372940", "bodyText": "This is actually here because Msg.makeMessage() throws an IOException if it can't find the message. This should never happen, except during development. Can I leave as is?", "author": "robnielsen", "createdAt": "2020-03-08T14:11:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4MTk1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389981953", "bodyText": "Can you link to the place in the code where this exception is thrown? As we are in a \"handleCommand\" method and the exception is about I/O, it very much seemed to me to be thrown if some communication with the device isn't working as expected. The FieldException below rather looks like an exception that is thrown on missing fields or similar.", "author": "kaikreuzer", "createdAt": "2020-03-09T21:51:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5Mzk1OA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389993958", "bodyText": "It's at https://github.com/robnielsen/openhab-addons/blob/insteon/bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/message/Msg.java#L590. Maybe it should throw a different exception.", "author": "robnielsen", "createdAt": "2020-03-09T22:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NTcwNA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389995704", "bodyText": "Ok, thanks. Yes, an IllegalArgumentException might be better for this situation.\nBut with that, I agree that this case should not happen and if it does, the user should report it as a bug, so a warn log is fine.", "author": "kaikreuzer", "createdAt": "2020-03-09T22:26:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMDk5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390010997", "bodyText": "I thought about using IllegalArgumentException, but it is a unchecked exception. Any other suggestions? I want to make sure the exception is caught.", "author": "robnielsen", "createdAt": "2020-03-09T23:12:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNTA2NA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390015064", "bodyText": "You could create a custom checked exception. Call it InvalidResponseException or some such.", "author": "cpmeister", "createdAt": "2020-03-09T23:25:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyMDg1MA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390020850", "bodyText": "Yes, that is what I was thinking but was checking first to see if there was a different one I could use.", "author": "robnielsen", "createdAt": "2020-03-09T23:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzNDQ0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390034441", "bodyText": "done, created custom exception to replace IOException and left as warn.", "author": "robnielsen", "createdAt": "2020-03-10T00:35:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQxNA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317414", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"{}: command send i/o error: \", nm(), e);\n          \n          \n            \n                            logger.debug(\"{}: command send i/o error: \", nm(), e);\n          \n      \n    \n    \n  \n\nInstead of logging warnings, you should set the Thing Status to OFFLINE, when the communication didn't work.", "author": "kaikreuzer", "createdAt": "2020-03-07T22:38:47Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/CommandHandler.java", "diffHunk": "@@ -0,0 +1,912 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A command handler translates an openHAB command into a insteon message\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public abstract class CommandHandler {\n+    private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);\n+    DeviceFeature feature; // related DeviceFeature\n+    @Nullable\n+    HashMap<String, @Nullable String> parameters = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param feature The DeviceFeature for which this command was intended.\n+     *            The openHAB commands are issued on an openhab item. The .items files bind\n+     *            an openHAB item to a DeviceFeature.\n+     */\n+    CommandHandler(DeviceFeature feature) {\n+        this.feature = feature;\n+    }\n+\n+    /**\n+     * Implements what to do when an openHAB command is received\n+     *\n+     * @param config the configuration for the item that generated the command\n+     * @param cmd the openhab command issued\n+     * @param device the Insteon device to which this command applies\n+     */\n+    public abstract void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice device);\n+\n+    /**\n+     * Returns parameter as integer\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected int getIntParameter(String key, int def) {\n+        String val = parameters.get(key);\n+        if (val == null) {\n+            return (def); // param not found\n+        }\n+        int ret = def;\n+        try {\n+            ret = Utils.strToInt(val);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in command handler: {}\", key);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns parameter as String\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected @Nullable String getStringParameter(String key, String def) {\n+        return (parameters.get(key) == null ? def : parameters.get(key));\n+    }\n+\n+    /**\n+     * Shorthand to return class name for logging purposes\n+     *\n+     * @return name of the class\n+     */\n+    protected String nm() {\n+        return (this.getClass().getSimpleName());\n+    }\n+\n+    protected int getMaxLightLevel(InsteonChannelConfiguration conf, int defaultLevel) {\n+        HashMap<String, @Nullable String> params = conf.getParameters();\n+        if (conf.getFeature().contains(\"dimmer\") && params.containsKey(\"dimmermax\")) {\n+            String item = conf.getChannelName();\n+            String dimmerMax = params.get(\"dimmermax\");\n+            try {\n+                int i = Integer.parseInt(dimmerMax);\n+                if (i > 1 && i <= 99) {\n+                    int level = (int) Math.ceil((i * 255.0) / 100); // round up\n+                    if (level < defaultLevel) {\n+                        logger.debug(\"item {}: using dimmermax value of {}\", item, dimmerMax);\n+                        return level;\n+                    }\n+                } else {\n+                    logger.warn(\"item {}: dimmermax must be between 1-99 inclusive: {}\", item, dimmerMax);\n+                }\n+            } catch (NumberFormatException e) {\n+                logger.warn(\"item {}: invalid int value for dimmermax: {}\", item, dimmerMax);\n+            }\n+        }\n+\n+        return defaultLevel;\n+    }\n+\n+    void setParameters(HashMap<String, @Nullable String> hm) {\n+        parameters = hm;\n+    }\n+\n+    /**\n+     * Helper function to extract the group parameter from the binding config,\n+     *\n+     * @param c the binding configuration to test\n+     * @return the value of the \"group\" parameter, or -1 if none\n+     */\n+    protected static int getGroup(InsteonChannelConfiguration c) {\n+        String v = c.getParameters().get(\"group\");\n+        int iv = -1;\n+        try {\n+            iv = (v == null) ? -1 : Utils.strToInt(v);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in for item {}\", c.getChannelName());\n+        }\n+        return iv;\n+    }\n+\n+    @NonNullByDefault\n+    public static class WarnCommandHandler extends CommandHandler {\n+        WarnCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            logger.warn(\"{}: command {} is not implemented yet!\", nm(), cmd);\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class NoOpCommandHandler extends CommandHandler {\n+        NoOpCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            // do nothing, not even log\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class LightOnOffCommandHandler extends CommandHandler {\n+        LightOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int ext = getIntParameter(\"ext\", 0);\n+                int direc = 0x00;\n+                int level = 0x00;\n+                Msg m = null;\n+                if (cmd == OnOffType.ON) {\n+                    level = getMaxLightLevel(conf, 0xff);\n+                    direc = 0x11;\n+                    logger.debug(\"{}: sent msg to switch {} to {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    direc = 0x13;\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+                if (ext == 1 || ext == 2) {\n+                    byte[] data = new byte[] { (byte) getIntParameter(\"d1\", 0), (byte) getIntParameter(\"d2\", 0),\n+                            (byte) getIntParameter(\"d3\", 0) };\n+                    m = dev.makeExtendedMessage((byte) 0x0f, (byte) direc, (byte) level, data);\n+                    logger.debug(\"{}: was an extended message for device {}\", nm(), dev.getAddress());\n+                    if (ext == 1) {\n+                        m.setCRC();\n+                    } else if (ext == 2) {\n+                        m.setCRC2();\n+                    }\n+                } else {\n+                    m = dev.makeStandardMessage((byte) 0x0f, (byte) direc, (byte) level, getGroup(conf));\n+                }\n+                logger.debug(\"Sending message to {}\", dev.getAddress());\n+                dev.enqueueMessage(m, feature);\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class FastOnOffCommandHandler extends CommandHandler {\n+        FastOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    int level = getMaxLightLevel(conf, 0xff);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x12, (byte) level, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast on to switch {} level {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x14, (byte) 0x00, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast off to switch {}\", nm(), dev.getAddress());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);", "originalCommit": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3Mjk1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389372955", "bodyText": "This is actually here because Msg.makeMessage() throws an IOException if it can't find the message. This should never happen, except during development. Can I leave as is?", "author": "robnielsen", "createdAt": "2020-03-08T14:11:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzNDU3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390034576", "bodyText": "done, created custom exception to replace IOException and left as warn.", "author": "robnielsen", "createdAt": "2020-03-10T00:36:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317425", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"{}: command send i/o error: \", nm(), e);\n          \n          \n            \n                            logger.debug(\"{}: command send i/o error: \", nm(), e);\n          \n      \n    \n    \n  \n\nInstead of logging warnings, you should set the Thing Status to OFFLINE, when the communication didn't work.", "author": "kaikreuzer", "createdAt": "2020-03-07T22:39:02Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/CommandHandler.java", "diffHunk": "@@ -0,0 +1,912 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A command handler translates an openHAB command into a insteon message\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public abstract class CommandHandler {\n+    private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);\n+    DeviceFeature feature; // related DeviceFeature\n+    @Nullable\n+    HashMap<String, @Nullable String> parameters = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param feature The DeviceFeature for which this command was intended.\n+     *            The openHAB commands are issued on an openhab item. The .items files bind\n+     *            an openHAB item to a DeviceFeature.\n+     */\n+    CommandHandler(DeviceFeature feature) {\n+        this.feature = feature;\n+    }\n+\n+    /**\n+     * Implements what to do when an openHAB command is received\n+     *\n+     * @param config the configuration for the item that generated the command\n+     * @param cmd the openhab command issued\n+     * @param device the Insteon device to which this command applies\n+     */\n+    public abstract void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice device);\n+\n+    /**\n+     * Returns parameter as integer\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected int getIntParameter(String key, int def) {\n+        String val = parameters.get(key);\n+        if (val == null) {\n+            return (def); // param not found\n+        }\n+        int ret = def;\n+        try {\n+            ret = Utils.strToInt(val);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in command handler: {}\", key);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns parameter as String\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected @Nullable String getStringParameter(String key, String def) {\n+        return (parameters.get(key) == null ? def : parameters.get(key));\n+    }\n+\n+    /**\n+     * Shorthand to return class name for logging purposes\n+     *\n+     * @return name of the class\n+     */\n+    protected String nm() {\n+        return (this.getClass().getSimpleName());\n+    }\n+\n+    protected int getMaxLightLevel(InsteonChannelConfiguration conf, int defaultLevel) {\n+        HashMap<String, @Nullable String> params = conf.getParameters();\n+        if (conf.getFeature().contains(\"dimmer\") && params.containsKey(\"dimmermax\")) {\n+            String item = conf.getChannelName();\n+            String dimmerMax = params.get(\"dimmermax\");\n+            try {\n+                int i = Integer.parseInt(dimmerMax);\n+                if (i > 1 && i <= 99) {\n+                    int level = (int) Math.ceil((i * 255.0) / 100); // round up\n+                    if (level < defaultLevel) {\n+                        logger.debug(\"item {}: using dimmermax value of {}\", item, dimmerMax);\n+                        return level;\n+                    }\n+                } else {\n+                    logger.warn(\"item {}: dimmermax must be between 1-99 inclusive: {}\", item, dimmerMax);\n+                }\n+            } catch (NumberFormatException e) {\n+                logger.warn(\"item {}: invalid int value for dimmermax: {}\", item, dimmerMax);\n+            }\n+        }\n+\n+        return defaultLevel;\n+    }\n+\n+    void setParameters(HashMap<String, @Nullable String> hm) {\n+        parameters = hm;\n+    }\n+\n+    /**\n+     * Helper function to extract the group parameter from the binding config,\n+     *\n+     * @param c the binding configuration to test\n+     * @return the value of the \"group\" parameter, or -1 if none\n+     */\n+    protected static int getGroup(InsteonChannelConfiguration c) {\n+        String v = c.getParameters().get(\"group\");\n+        int iv = -1;\n+        try {\n+            iv = (v == null) ? -1 : Utils.strToInt(v);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in for item {}\", c.getChannelName());\n+        }\n+        return iv;\n+    }\n+\n+    @NonNullByDefault\n+    public static class WarnCommandHandler extends CommandHandler {\n+        WarnCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            logger.warn(\"{}: command {} is not implemented yet!\", nm(), cmd);\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class NoOpCommandHandler extends CommandHandler {\n+        NoOpCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            // do nothing, not even log\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class LightOnOffCommandHandler extends CommandHandler {\n+        LightOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int ext = getIntParameter(\"ext\", 0);\n+                int direc = 0x00;\n+                int level = 0x00;\n+                Msg m = null;\n+                if (cmd == OnOffType.ON) {\n+                    level = getMaxLightLevel(conf, 0xff);\n+                    direc = 0x11;\n+                    logger.debug(\"{}: sent msg to switch {} to {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    direc = 0x13;\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+                if (ext == 1 || ext == 2) {\n+                    byte[] data = new byte[] { (byte) getIntParameter(\"d1\", 0), (byte) getIntParameter(\"d2\", 0),\n+                            (byte) getIntParameter(\"d3\", 0) };\n+                    m = dev.makeExtendedMessage((byte) 0x0f, (byte) direc, (byte) level, data);\n+                    logger.debug(\"{}: was an extended message for device {}\", nm(), dev.getAddress());\n+                    if (ext == 1) {\n+                        m.setCRC();\n+                    } else if (ext == 2) {\n+                        m.setCRC2();\n+                    }\n+                } else {\n+                    m = dev.makeStandardMessage((byte) 0x0f, (byte) direc, (byte) level, getGroup(conf));\n+                }\n+                logger.debug(\"Sending message to {}\", dev.getAddress());\n+                dev.enqueueMessage(m, feature);\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class FastOnOffCommandHandler extends CommandHandler {\n+        FastOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    int level = getMaxLightLevel(conf, 0xff);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x12, (byte) level, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast on to switch {} level {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x14, (byte) 0x00, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast off to switch {}\", nm(), dev.getAddress());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class RampOnOffCommandHandler extends RampCommandHandler {\n+        RampOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 100);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOnCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp on to switch {} time {} level {} cmd1 {}\", nm(), dev.getAddress(),\n+                            ramptime, ramplevel, getOnCmd());\n+                } else if (cmd == OnOffType.OFF) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 0 /* ignored */);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOffCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp off to switch {} time {} cmd1 {}\", nm(), dev.getAddress(), ramptime,\n+                            getOffCmd());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);", "originalCommit": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3Mjk2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389372961", "bodyText": "This is actually here because Msg.makeMessage() throws an IOException if it can't find the message. This should never happen, except during development. Can I leave as is?", "author": "robnielsen", "createdAt": "2020-03-08T14:11:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzNDQ5OA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390034498", "bodyText": "done, created custom exception to replace IOException and left as warn.", "author": "robnielsen", "createdAt": "2020-03-10T00:35:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317439", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"{}: command send i/o error: \", nm(), e);\n          \n          \n            \n                            logger.debug(\"{}: command send i/o error: \", nm(), e);\n          \n      \n    \n    \n  \n\nInstead of logging warnings, you should set the Thing Status to OFFLINE, when the communication didn't work.", "author": "kaikreuzer", "createdAt": "2020-03-07T22:39:22Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/CommandHandler.java", "diffHunk": "@@ -0,0 +1,912 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A command handler translates an openHAB command into a insteon message\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public abstract class CommandHandler {\n+    private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);\n+    DeviceFeature feature; // related DeviceFeature\n+    @Nullable\n+    HashMap<String, @Nullable String> parameters = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param feature The DeviceFeature for which this command was intended.\n+     *            The openHAB commands are issued on an openhab item. The .items files bind\n+     *            an openHAB item to a DeviceFeature.\n+     */\n+    CommandHandler(DeviceFeature feature) {\n+        this.feature = feature;\n+    }\n+\n+    /**\n+     * Implements what to do when an openHAB command is received\n+     *\n+     * @param config the configuration for the item that generated the command\n+     * @param cmd the openhab command issued\n+     * @param device the Insteon device to which this command applies\n+     */\n+    public abstract void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice device);\n+\n+    /**\n+     * Returns parameter as integer\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected int getIntParameter(String key, int def) {\n+        String val = parameters.get(key);\n+        if (val == null) {\n+            return (def); // param not found\n+        }\n+        int ret = def;\n+        try {\n+            ret = Utils.strToInt(val);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in command handler: {}\", key);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns parameter as String\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected @Nullable String getStringParameter(String key, String def) {\n+        return (parameters.get(key) == null ? def : parameters.get(key));\n+    }\n+\n+    /**\n+     * Shorthand to return class name for logging purposes\n+     *\n+     * @return name of the class\n+     */\n+    protected String nm() {\n+        return (this.getClass().getSimpleName());\n+    }\n+\n+    protected int getMaxLightLevel(InsteonChannelConfiguration conf, int defaultLevel) {\n+        HashMap<String, @Nullable String> params = conf.getParameters();\n+        if (conf.getFeature().contains(\"dimmer\") && params.containsKey(\"dimmermax\")) {\n+            String item = conf.getChannelName();\n+            String dimmerMax = params.get(\"dimmermax\");\n+            try {\n+                int i = Integer.parseInt(dimmerMax);\n+                if (i > 1 && i <= 99) {\n+                    int level = (int) Math.ceil((i * 255.0) / 100); // round up\n+                    if (level < defaultLevel) {\n+                        logger.debug(\"item {}: using dimmermax value of {}\", item, dimmerMax);\n+                        return level;\n+                    }\n+                } else {\n+                    logger.warn(\"item {}: dimmermax must be between 1-99 inclusive: {}\", item, dimmerMax);\n+                }\n+            } catch (NumberFormatException e) {\n+                logger.warn(\"item {}: invalid int value for dimmermax: {}\", item, dimmerMax);\n+            }\n+        }\n+\n+        return defaultLevel;\n+    }\n+\n+    void setParameters(HashMap<String, @Nullable String> hm) {\n+        parameters = hm;\n+    }\n+\n+    /**\n+     * Helper function to extract the group parameter from the binding config,\n+     *\n+     * @param c the binding configuration to test\n+     * @return the value of the \"group\" parameter, or -1 if none\n+     */\n+    protected static int getGroup(InsteonChannelConfiguration c) {\n+        String v = c.getParameters().get(\"group\");\n+        int iv = -1;\n+        try {\n+            iv = (v == null) ? -1 : Utils.strToInt(v);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in for item {}\", c.getChannelName());\n+        }\n+        return iv;\n+    }\n+\n+    @NonNullByDefault\n+    public static class WarnCommandHandler extends CommandHandler {\n+        WarnCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            logger.warn(\"{}: command {} is not implemented yet!\", nm(), cmd);\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class NoOpCommandHandler extends CommandHandler {\n+        NoOpCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            // do nothing, not even log\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class LightOnOffCommandHandler extends CommandHandler {\n+        LightOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int ext = getIntParameter(\"ext\", 0);\n+                int direc = 0x00;\n+                int level = 0x00;\n+                Msg m = null;\n+                if (cmd == OnOffType.ON) {\n+                    level = getMaxLightLevel(conf, 0xff);\n+                    direc = 0x11;\n+                    logger.debug(\"{}: sent msg to switch {} to {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    direc = 0x13;\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+                if (ext == 1 || ext == 2) {\n+                    byte[] data = new byte[] { (byte) getIntParameter(\"d1\", 0), (byte) getIntParameter(\"d2\", 0),\n+                            (byte) getIntParameter(\"d3\", 0) };\n+                    m = dev.makeExtendedMessage((byte) 0x0f, (byte) direc, (byte) level, data);\n+                    logger.debug(\"{}: was an extended message for device {}\", nm(), dev.getAddress());\n+                    if (ext == 1) {\n+                        m.setCRC();\n+                    } else if (ext == 2) {\n+                        m.setCRC2();\n+                    }\n+                } else {\n+                    m = dev.makeStandardMessage((byte) 0x0f, (byte) direc, (byte) level, getGroup(conf));\n+                }\n+                logger.debug(\"Sending message to {}\", dev.getAddress());\n+                dev.enqueueMessage(m, feature);\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class FastOnOffCommandHandler extends CommandHandler {\n+        FastOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    int level = getMaxLightLevel(conf, 0xff);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x12, (byte) level, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast on to switch {} level {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x14, (byte) 0x00, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast off to switch {}\", nm(), dev.getAddress());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class RampOnOffCommandHandler extends RampCommandHandler {\n+        RampOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 100);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOnCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp on to switch {} time {} level {} cmd1 {}\", nm(), dev.getAddress(),\n+                            ramptime, ramplevel, getOnCmd());\n+                } else if (cmd == OnOffType.OFF) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 0 /* ignored */);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOffCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp off to switch {} time {} cmd1 {}\", nm(), dev.getAddress(), ramptime,\n+                            getOffCmd());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+\n+        private int getRampLevel(InsteonChannelConfiguration conf, int defaultValue) {\n+            HashMap<String, @Nullable String> params = conf.getParameters();\n+            return params.containsKey(\"ramplevel\") ? Integer.parseInt(params.get(\"ramplevel\")) : defaultValue;\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class ManualChangeCommandHandler extends CommandHandler {\n+        ManualChangeCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd instanceof DecimalType) {\n+                    int v = ((DecimalType) cmd).intValue();\n+                    int cmd1 = (v != 1) ? 0x17 : 0x18; // start or stop\n+                    int cmd2 = (v == 2) ? 0x01 : 0; // up or down\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) cmd1, (byte) cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: cmd {} sent manual change {} {} to {}\", nm(), v,\n+                            (cmd1 == 0x17) ? \"START\" : \"STOP\", (cmd2 == 0x01) ? \"UP\" : \"DOWN\", dev.getAddress());\n+                } else {\n+                    logger.warn(\"{}: invalid command type: {}\", nm(), cmd);\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);", "originalCommit": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3Mjk2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389372967", "bodyText": "This is actually here because Msg.makeMessage() throws an IOException if it can't find the message. This should never happen, except during development. Can I leave as is?", "author": "robnielsen", "createdAt": "2020-03-08T14:12:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzNDY3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390034676", "bodyText": "done, created custom exception to replace IOException and left as warn.", "author": "robnielsen", "createdAt": "2020-03-10T00:36:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQ0OA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317448", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"{}: command send i/o error: \", nm(), e);\n          \n          \n            \n                            logger.debug(\"{}: command send i/o error: \", nm(), e);\n          \n      \n    \n    \n  \n\nInstead of logging warnings, you should set the Thing Status to OFFLINE, when the communication didn't work.", "author": "kaikreuzer", "createdAt": "2020-03-07T22:39:44Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/CommandHandler.java", "diffHunk": "@@ -0,0 +1,912 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A command handler translates an openHAB command into a insteon message\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public abstract class CommandHandler {\n+    private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);\n+    DeviceFeature feature; // related DeviceFeature\n+    @Nullable\n+    HashMap<String, @Nullable String> parameters = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param feature The DeviceFeature for which this command was intended.\n+     *            The openHAB commands are issued on an openhab item. The .items files bind\n+     *            an openHAB item to a DeviceFeature.\n+     */\n+    CommandHandler(DeviceFeature feature) {\n+        this.feature = feature;\n+    }\n+\n+    /**\n+     * Implements what to do when an openHAB command is received\n+     *\n+     * @param config the configuration for the item that generated the command\n+     * @param cmd the openhab command issued\n+     * @param device the Insteon device to which this command applies\n+     */\n+    public abstract void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice device);\n+\n+    /**\n+     * Returns parameter as integer\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected int getIntParameter(String key, int def) {\n+        String val = parameters.get(key);\n+        if (val == null) {\n+            return (def); // param not found\n+        }\n+        int ret = def;\n+        try {\n+            ret = Utils.strToInt(val);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in command handler: {}\", key);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns parameter as String\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected @Nullable String getStringParameter(String key, String def) {\n+        return (parameters.get(key) == null ? def : parameters.get(key));\n+    }\n+\n+    /**\n+     * Shorthand to return class name for logging purposes\n+     *\n+     * @return name of the class\n+     */\n+    protected String nm() {\n+        return (this.getClass().getSimpleName());\n+    }\n+\n+    protected int getMaxLightLevel(InsteonChannelConfiguration conf, int defaultLevel) {\n+        HashMap<String, @Nullable String> params = conf.getParameters();\n+        if (conf.getFeature().contains(\"dimmer\") && params.containsKey(\"dimmermax\")) {\n+            String item = conf.getChannelName();\n+            String dimmerMax = params.get(\"dimmermax\");\n+            try {\n+                int i = Integer.parseInt(dimmerMax);\n+                if (i > 1 && i <= 99) {\n+                    int level = (int) Math.ceil((i * 255.0) / 100); // round up\n+                    if (level < defaultLevel) {\n+                        logger.debug(\"item {}: using dimmermax value of {}\", item, dimmerMax);\n+                        return level;\n+                    }\n+                } else {\n+                    logger.warn(\"item {}: dimmermax must be between 1-99 inclusive: {}\", item, dimmerMax);\n+                }\n+            } catch (NumberFormatException e) {\n+                logger.warn(\"item {}: invalid int value for dimmermax: {}\", item, dimmerMax);\n+            }\n+        }\n+\n+        return defaultLevel;\n+    }\n+\n+    void setParameters(HashMap<String, @Nullable String> hm) {\n+        parameters = hm;\n+    }\n+\n+    /**\n+     * Helper function to extract the group parameter from the binding config,\n+     *\n+     * @param c the binding configuration to test\n+     * @return the value of the \"group\" parameter, or -1 if none\n+     */\n+    protected static int getGroup(InsteonChannelConfiguration c) {\n+        String v = c.getParameters().get(\"group\");\n+        int iv = -1;\n+        try {\n+            iv = (v == null) ? -1 : Utils.strToInt(v);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in for item {}\", c.getChannelName());\n+        }\n+        return iv;\n+    }\n+\n+    @NonNullByDefault\n+    public static class WarnCommandHandler extends CommandHandler {\n+        WarnCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            logger.warn(\"{}: command {} is not implemented yet!\", nm(), cmd);\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class NoOpCommandHandler extends CommandHandler {\n+        NoOpCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            // do nothing, not even log\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class LightOnOffCommandHandler extends CommandHandler {\n+        LightOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int ext = getIntParameter(\"ext\", 0);\n+                int direc = 0x00;\n+                int level = 0x00;\n+                Msg m = null;\n+                if (cmd == OnOffType.ON) {\n+                    level = getMaxLightLevel(conf, 0xff);\n+                    direc = 0x11;\n+                    logger.debug(\"{}: sent msg to switch {} to {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    direc = 0x13;\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+                if (ext == 1 || ext == 2) {\n+                    byte[] data = new byte[] { (byte) getIntParameter(\"d1\", 0), (byte) getIntParameter(\"d2\", 0),\n+                            (byte) getIntParameter(\"d3\", 0) };\n+                    m = dev.makeExtendedMessage((byte) 0x0f, (byte) direc, (byte) level, data);\n+                    logger.debug(\"{}: was an extended message for device {}\", nm(), dev.getAddress());\n+                    if (ext == 1) {\n+                        m.setCRC();\n+                    } else if (ext == 2) {\n+                        m.setCRC2();\n+                    }\n+                } else {\n+                    m = dev.makeStandardMessage((byte) 0x0f, (byte) direc, (byte) level, getGroup(conf));\n+                }\n+                logger.debug(\"Sending message to {}\", dev.getAddress());\n+                dev.enqueueMessage(m, feature);\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class FastOnOffCommandHandler extends CommandHandler {\n+        FastOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    int level = getMaxLightLevel(conf, 0xff);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x12, (byte) level, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast on to switch {} level {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x14, (byte) 0x00, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast off to switch {}\", nm(), dev.getAddress());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class RampOnOffCommandHandler extends RampCommandHandler {\n+        RampOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 100);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOnCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp on to switch {} time {} level {} cmd1 {}\", nm(), dev.getAddress(),\n+                            ramptime, ramplevel, getOnCmd());\n+                } else if (cmd == OnOffType.OFF) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 0 /* ignored */);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOffCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp off to switch {} time {} cmd1 {}\", nm(), dev.getAddress(), ramptime,\n+                            getOffCmd());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+\n+        private int getRampLevel(InsteonChannelConfiguration conf, int defaultValue) {\n+            HashMap<String, @Nullable String> params = conf.getParameters();\n+            return params.containsKey(\"ramplevel\") ? Integer.parseInt(params.get(\"ramplevel\")) : defaultValue;\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class ManualChangeCommandHandler extends CommandHandler {\n+        ManualChangeCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd instanceof DecimalType) {\n+                    int v = ((DecimalType) cmd).intValue();\n+                    int cmd1 = (v != 1) ? 0x17 : 0x18; // start or stop\n+                    int cmd2 = (v == 2) ? 0x01 : 0; // up or down\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) cmd1, (byte) cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: cmd {} sent manual change {} {} to {}\", nm(), v,\n+                            (cmd1 == 0x17) ? \"START\" : \"STOP\", (cmd2 == 0x01) ? \"UP\" : \"DOWN\", dev.getAddress());\n+                } else {\n+                    logger.warn(\"{}: invalid command type: {}\", nm(), cmd);\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sends ALLLink broadcast commands to group\n+     */\n+    @NonNullByDefault\n+    public static class GroupBroadcastCommandHandler extends CommandHandler {\n+        GroupBroadcastCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON || cmd == OnOffType.OFF) {\n+                    byte cmd1 = (byte) ((cmd == OnOffType.ON) ? 0x11 : 0x13);\n+                    byte value = (byte) ((cmd == OnOffType.ON) ? 0xFF : 0x00);\n+                    int group = getGroup(conf);\n+                    if (group == -1) {\n+                        logger.warn(\"no group=xx specified in item {}\", conf.getChannelName());\n+                        return;\n+                    }\n+                    logger.debug(\"{}: sending {} broadcast to group {}\", nm(), (cmd1 == 0x11) ? \"ON\" : \"OFF\",\n+                            getGroup(conf));\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, cmd1, value, group);\n+                    dev.enqueueMessage(m, feature);\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);", "originalCommit": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3Mjk3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389372973", "bodyText": "This is actually here because Msg.makeMessage() throws an IOException if it can't find the message. This should never happen, except during development. Can I leave as is?", "author": "robnielsen", "createdAt": "2020-03-08T14:12:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQ0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzNDc0OA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390034748", "bodyText": "done, created custom exception to replace IOException and left as warn.", "author": "robnielsen", "createdAt": "2020-03-10T00:36:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQ0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQ1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317456", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"{}: command send i/o error: \", nm(), e);\n          \n          \n            \n                            logger.debug(\"{}: command send i/o error: \", nm(), e);\n          \n      \n    \n    \n  \n\nInstead of logging warnings, you should set the Thing Status to OFFLINE, when the communication didn't work.", "author": "kaikreuzer", "createdAt": "2020-03-07T22:39:59Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/CommandHandler.java", "diffHunk": "@@ -0,0 +1,912 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A command handler translates an openHAB command into a insteon message\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public abstract class CommandHandler {\n+    private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);\n+    DeviceFeature feature; // related DeviceFeature\n+    @Nullable\n+    HashMap<String, @Nullable String> parameters = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param feature The DeviceFeature for which this command was intended.\n+     *            The openHAB commands are issued on an openhab item. The .items files bind\n+     *            an openHAB item to a DeviceFeature.\n+     */\n+    CommandHandler(DeviceFeature feature) {\n+        this.feature = feature;\n+    }\n+\n+    /**\n+     * Implements what to do when an openHAB command is received\n+     *\n+     * @param config the configuration for the item that generated the command\n+     * @param cmd the openhab command issued\n+     * @param device the Insteon device to which this command applies\n+     */\n+    public abstract void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice device);\n+\n+    /**\n+     * Returns parameter as integer\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected int getIntParameter(String key, int def) {\n+        String val = parameters.get(key);\n+        if (val == null) {\n+            return (def); // param not found\n+        }\n+        int ret = def;\n+        try {\n+            ret = Utils.strToInt(val);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in command handler: {}\", key);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns parameter as String\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected @Nullable String getStringParameter(String key, String def) {\n+        return (parameters.get(key) == null ? def : parameters.get(key));\n+    }\n+\n+    /**\n+     * Shorthand to return class name for logging purposes\n+     *\n+     * @return name of the class\n+     */\n+    protected String nm() {\n+        return (this.getClass().getSimpleName());\n+    }\n+\n+    protected int getMaxLightLevel(InsteonChannelConfiguration conf, int defaultLevel) {\n+        HashMap<String, @Nullable String> params = conf.getParameters();\n+        if (conf.getFeature().contains(\"dimmer\") && params.containsKey(\"dimmermax\")) {\n+            String item = conf.getChannelName();\n+            String dimmerMax = params.get(\"dimmermax\");\n+            try {\n+                int i = Integer.parseInt(dimmerMax);\n+                if (i > 1 && i <= 99) {\n+                    int level = (int) Math.ceil((i * 255.0) / 100); // round up\n+                    if (level < defaultLevel) {\n+                        logger.debug(\"item {}: using dimmermax value of {}\", item, dimmerMax);\n+                        return level;\n+                    }\n+                } else {\n+                    logger.warn(\"item {}: dimmermax must be between 1-99 inclusive: {}\", item, dimmerMax);\n+                }\n+            } catch (NumberFormatException e) {\n+                logger.warn(\"item {}: invalid int value for dimmermax: {}\", item, dimmerMax);\n+            }\n+        }\n+\n+        return defaultLevel;\n+    }\n+\n+    void setParameters(HashMap<String, @Nullable String> hm) {\n+        parameters = hm;\n+    }\n+\n+    /**\n+     * Helper function to extract the group parameter from the binding config,\n+     *\n+     * @param c the binding configuration to test\n+     * @return the value of the \"group\" parameter, or -1 if none\n+     */\n+    protected static int getGroup(InsteonChannelConfiguration c) {\n+        String v = c.getParameters().get(\"group\");\n+        int iv = -1;\n+        try {\n+            iv = (v == null) ? -1 : Utils.strToInt(v);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in for item {}\", c.getChannelName());\n+        }\n+        return iv;\n+    }\n+\n+    @NonNullByDefault\n+    public static class WarnCommandHandler extends CommandHandler {\n+        WarnCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            logger.warn(\"{}: command {} is not implemented yet!\", nm(), cmd);\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class NoOpCommandHandler extends CommandHandler {\n+        NoOpCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            // do nothing, not even log\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class LightOnOffCommandHandler extends CommandHandler {\n+        LightOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int ext = getIntParameter(\"ext\", 0);\n+                int direc = 0x00;\n+                int level = 0x00;\n+                Msg m = null;\n+                if (cmd == OnOffType.ON) {\n+                    level = getMaxLightLevel(conf, 0xff);\n+                    direc = 0x11;\n+                    logger.debug(\"{}: sent msg to switch {} to {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    direc = 0x13;\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+                if (ext == 1 || ext == 2) {\n+                    byte[] data = new byte[] { (byte) getIntParameter(\"d1\", 0), (byte) getIntParameter(\"d2\", 0),\n+                            (byte) getIntParameter(\"d3\", 0) };\n+                    m = dev.makeExtendedMessage((byte) 0x0f, (byte) direc, (byte) level, data);\n+                    logger.debug(\"{}: was an extended message for device {}\", nm(), dev.getAddress());\n+                    if (ext == 1) {\n+                        m.setCRC();\n+                    } else if (ext == 2) {\n+                        m.setCRC2();\n+                    }\n+                } else {\n+                    m = dev.makeStandardMessage((byte) 0x0f, (byte) direc, (byte) level, getGroup(conf));\n+                }\n+                logger.debug(\"Sending message to {}\", dev.getAddress());\n+                dev.enqueueMessage(m, feature);\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class FastOnOffCommandHandler extends CommandHandler {\n+        FastOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    int level = getMaxLightLevel(conf, 0xff);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x12, (byte) level, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast on to switch {} level {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x14, (byte) 0x00, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast off to switch {}\", nm(), dev.getAddress());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class RampOnOffCommandHandler extends RampCommandHandler {\n+        RampOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 100);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOnCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp on to switch {} time {} level {} cmd1 {}\", nm(), dev.getAddress(),\n+                            ramptime, ramplevel, getOnCmd());\n+                } else if (cmd == OnOffType.OFF) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 0 /* ignored */);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOffCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp off to switch {} time {} cmd1 {}\", nm(), dev.getAddress(), ramptime,\n+                            getOffCmd());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+\n+        private int getRampLevel(InsteonChannelConfiguration conf, int defaultValue) {\n+            HashMap<String, @Nullable String> params = conf.getParameters();\n+            return params.containsKey(\"ramplevel\") ? Integer.parseInt(params.get(\"ramplevel\")) : defaultValue;\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class ManualChangeCommandHandler extends CommandHandler {\n+        ManualChangeCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd instanceof DecimalType) {\n+                    int v = ((DecimalType) cmd).intValue();\n+                    int cmd1 = (v != 1) ? 0x17 : 0x18; // start or stop\n+                    int cmd2 = (v == 2) ? 0x01 : 0; // up or down\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) cmd1, (byte) cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: cmd {} sent manual change {} {} to {}\", nm(), v,\n+                            (cmd1 == 0x17) ? \"START\" : \"STOP\", (cmd2 == 0x01) ? \"UP\" : \"DOWN\", dev.getAddress());\n+                } else {\n+                    logger.warn(\"{}: invalid command type: {}\", nm(), cmd);\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sends ALLLink broadcast commands to group\n+     */\n+    @NonNullByDefault\n+    public static class GroupBroadcastCommandHandler extends CommandHandler {\n+        GroupBroadcastCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON || cmd == OnOffType.OFF) {\n+                    byte cmd1 = (byte) ((cmd == OnOffType.ON) ? 0x11 : 0x13);\n+                    byte value = (byte) ((cmd == OnOffType.ON) ? 0xFF : 0x00);\n+                    int group = getGroup(conf);\n+                    if (group == -1) {\n+                        logger.warn(\"no group=xx specified in item {}\", conf.getChannelName());\n+                        return;\n+                    }\n+                    logger.debug(\"{}: sending {} broadcast to group {}\", nm(), (cmd1 == 0x11) ? \"ON\" : \"OFF\",\n+                            getGroup(conf));\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, cmd1, value, group);\n+                    dev.enqueueMessage(m, feature);\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This Handler was supposed to set the LEDs of the 2487S, but it doesn't work.\n+     * The parameters were modeled after the 2486D, it may work for that one,\n+     * leaving it in for now.\n+     *\n+     * From the HouseLinc PLM traffic log, the following commands (in the D2 data field)\n+     * of the 2486D are supported:\n+     *\n+     * 0x02: LED follow mask may work or not\n+     * 0x03: LED OFF mask\n+     * 0x04: X10 addr setting\n+     * 0x05: ramp rate\n+     * 0x06: on Level for button\n+     * 0x07: global LED brightness (could not see any effect during testing)\n+     * 0x0B: set nontoggle on/off command\n+     *\n+     * crucially, the 0x09 command does not work (NACK from device)\n+     *\n+     * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+     */\n+    @NonNullByDefault\n+    public static class LEDOnOffCommandHandler extends CommandHandler {\n+        LEDOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int button = this.getIntParameter(\"button\", -1);\n+                if (cmd == OnOffType.ON) {\n+                    Msg m = dev.makeExtendedMessage((byte) 0x1f, (byte) 0x2e, (byte) 0x00,\n+                            new byte[] { (byte) button, (byte) 0x09, (byte) 0x01 });\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent msg to switch {} on\", nm(), dev.getAddress());\n+                } else if (cmd == OnOffType.OFF) {\n+                    Msg m = dev.makeExtendedMessage((byte) 0x1f, (byte) 0x2e, (byte) 0x00,\n+                            new byte[] { (byte) button, (byte) 0x09, (byte) 0x00 });\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);", "originalCommit": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3Mjk4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389372983", "bodyText": "This is actually here because Msg.makeMessage() throws an IOException if it can't find the message. This should never happen, except during development. Can I leave as is?", "author": "robnielsen", "createdAt": "2020-03-08T14:12:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzNDgwMA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390034800", "bodyText": "done, created custom exception to replace IOException and left as warn.", "author": "robnielsen", "createdAt": "2020-03-10T00:36:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQ2MA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317460", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"{}: command send i/o error: \", nm(), e);\n          \n          \n            \n                            logger.debug(\"{}: command send i/o error: \", nm(), e);\n          \n      \n    \n    \n  \n\nInstead of logging warnings, you should set the Thing Status to OFFLINE, when the communication didn't work.", "author": "kaikreuzer", "createdAt": "2020-03-07T22:40:12Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/CommandHandler.java", "diffHunk": "@@ -0,0 +1,912 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A command handler translates an openHAB command into a insteon message\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public abstract class CommandHandler {\n+    private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);\n+    DeviceFeature feature; // related DeviceFeature\n+    @Nullable\n+    HashMap<String, @Nullable String> parameters = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param feature The DeviceFeature for which this command was intended.\n+     *            The openHAB commands are issued on an openhab item. The .items files bind\n+     *            an openHAB item to a DeviceFeature.\n+     */\n+    CommandHandler(DeviceFeature feature) {\n+        this.feature = feature;\n+    }\n+\n+    /**\n+     * Implements what to do when an openHAB command is received\n+     *\n+     * @param config the configuration for the item that generated the command\n+     * @param cmd the openhab command issued\n+     * @param device the Insteon device to which this command applies\n+     */\n+    public abstract void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice device);\n+\n+    /**\n+     * Returns parameter as integer\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected int getIntParameter(String key, int def) {\n+        String val = parameters.get(key);\n+        if (val == null) {\n+            return (def); // param not found\n+        }\n+        int ret = def;\n+        try {\n+            ret = Utils.strToInt(val);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in command handler: {}\", key);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns parameter as String\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected @Nullable String getStringParameter(String key, String def) {\n+        return (parameters.get(key) == null ? def : parameters.get(key));\n+    }\n+\n+    /**\n+     * Shorthand to return class name for logging purposes\n+     *\n+     * @return name of the class\n+     */\n+    protected String nm() {\n+        return (this.getClass().getSimpleName());\n+    }\n+\n+    protected int getMaxLightLevel(InsteonChannelConfiguration conf, int defaultLevel) {\n+        HashMap<String, @Nullable String> params = conf.getParameters();\n+        if (conf.getFeature().contains(\"dimmer\") && params.containsKey(\"dimmermax\")) {\n+            String item = conf.getChannelName();\n+            String dimmerMax = params.get(\"dimmermax\");\n+            try {\n+                int i = Integer.parseInt(dimmerMax);\n+                if (i > 1 && i <= 99) {\n+                    int level = (int) Math.ceil((i * 255.0) / 100); // round up\n+                    if (level < defaultLevel) {\n+                        logger.debug(\"item {}: using dimmermax value of {}\", item, dimmerMax);\n+                        return level;\n+                    }\n+                } else {\n+                    logger.warn(\"item {}: dimmermax must be between 1-99 inclusive: {}\", item, dimmerMax);\n+                }\n+            } catch (NumberFormatException e) {\n+                logger.warn(\"item {}: invalid int value for dimmermax: {}\", item, dimmerMax);\n+            }\n+        }\n+\n+        return defaultLevel;\n+    }\n+\n+    void setParameters(HashMap<String, @Nullable String> hm) {\n+        parameters = hm;\n+    }\n+\n+    /**\n+     * Helper function to extract the group parameter from the binding config,\n+     *\n+     * @param c the binding configuration to test\n+     * @return the value of the \"group\" parameter, or -1 if none\n+     */\n+    protected static int getGroup(InsteonChannelConfiguration c) {\n+        String v = c.getParameters().get(\"group\");\n+        int iv = -1;\n+        try {\n+            iv = (v == null) ? -1 : Utils.strToInt(v);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in for item {}\", c.getChannelName());\n+        }\n+        return iv;\n+    }\n+\n+    @NonNullByDefault\n+    public static class WarnCommandHandler extends CommandHandler {\n+        WarnCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            logger.warn(\"{}: command {} is not implemented yet!\", nm(), cmd);\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class NoOpCommandHandler extends CommandHandler {\n+        NoOpCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            // do nothing, not even log\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class LightOnOffCommandHandler extends CommandHandler {\n+        LightOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int ext = getIntParameter(\"ext\", 0);\n+                int direc = 0x00;\n+                int level = 0x00;\n+                Msg m = null;\n+                if (cmd == OnOffType.ON) {\n+                    level = getMaxLightLevel(conf, 0xff);\n+                    direc = 0x11;\n+                    logger.debug(\"{}: sent msg to switch {} to {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    direc = 0x13;\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+                if (ext == 1 || ext == 2) {\n+                    byte[] data = new byte[] { (byte) getIntParameter(\"d1\", 0), (byte) getIntParameter(\"d2\", 0),\n+                            (byte) getIntParameter(\"d3\", 0) };\n+                    m = dev.makeExtendedMessage((byte) 0x0f, (byte) direc, (byte) level, data);\n+                    logger.debug(\"{}: was an extended message for device {}\", nm(), dev.getAddress());\n+                    if (ext == 1) {\n+                        m.setCRC();\n+                    } else if (ext == 2) {\n+                        m.setCRC2();\n+                    }\n+                } else {\n+                    m = dev.makeStandardMessage((byte) 0x0f, (byte) direc, (byte) level, getGroup(conf));\n+                }\n+                logger.debug(\"Sending message to {}\", dev.getAddress());\n+                dev.enqueueMessage(m, feature);\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class FastOnOffCommandHandler extends CommandHandler {\n+        FastOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    int level = getMaxLightLevel(conf, 0xff);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x12, (byte) level, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast on to switch {} level {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x14, (byte) 0x00, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast off to switch {}\", nm(), dev.getAddress());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class RampOnOffCommandHandler extends RampCommandHandler {\n+        RampOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 100);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOnCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp on to switch {} time {} level {} cmd1 {}\", nm(), dev.getAddress(),\n+                            ramptime, ramplevel, getOnCmd());\n+                } else if (cmd == OnOffType.OFF) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 0 /* ignored */);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOffCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp off to switch {} time {} cmd1 {}\", nm(), dev.getAddress(), ramptime,\n+                            getOffCmd());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+\n+        private int getRampLevel(InsteonChannelConfiguration conf, int defaultValue) {\n+            HashMap<String, @Nullable String> params = conf.getParameters();\n+            return params.containsKey(\"ramplevel\") ? Integer.parseInt(params.get(\"ramplevel\")) : defaultValue;\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class ManualChangeCommandHandler extends CommandHandler {\n+        ManualChangeCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd instanceof DecimalType) {\n+                    int v = ((DecimalType) cmd).intValue();\n+                    int cmd1 = (v != 1) ? 0x17 : 0x18; // start or stop\n+                    int cmd2 = (v == 2) ? 0x01 : 0; // up or down\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) cmd1, (byte) cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: cmd {} sent manual change {} {} to {}\", nm(), v,\n+                            (cmd1 == 0x17) ? \"START\" : \"STOP\", (cmd2 == 0x01) ? \"UP\" : \"DOWN\", dev.getAddress());\n+                } else {\n+                    logger.warn(\"{}: invalid command type: {}\", nm(), cmd);\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sends ALLLink broadcast commands to group\n+     */\n+    @NonNullByDefault\n+    public static class GroupBroadcastCommandHandler extends CommandHandler {\n+        GroupBroadcastCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON || cmd == OnOffType.OFF) {\n+                    byte cmd1 = (byte) ((cmd == OnOffType.ON) ? 0x11 : 0x13);\n+                    byte value = (byte) ((cmd == OnOffType.ON) ? 0xFF : 0x00);\n+                    int group = getGroup(conf);\n+                    if (group == -1) {\n+                        logger.warn(\"no group=xx specified in item {}\", conf.getChannelName());\n+                        return;\n+                    }\n+                    logger.debug(\"{}: sending {} broadcast to group {}\", nm(), (cmd1 == 0x11) ? \"ON\" : \"OFF\",\n+                            getGroup(conf));\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, cmd1, value, group);\n+                    dev.enqueueMessage(m, feature);\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This Handler was supposed to set the LEDs of the 2487S, but it doesn't work.\n+     * The parameters were modeled after the 2486D, it may work for that one,\n+     * leaving it in for now.\n+     *\n+     * From the HouseLinc PLM traffic log, the following commands (in the D2 data field)\n+     * of the 2486D are supported:\n+     *\n+     * 0x02: LED follow mask may work or not\n+     * 0x03: LED OFF mask\n+     * 0x04: X10 addr setting\n+     * 0x05: ramp rate\n+     * 0x06: on Level for button\n+     * 0x07: global LED brightness (could not see any effect during testing)\n+     * 0x0B: set nontoggle on/off command\n+     *\n+     * crucially, the 0x09 command does not work (NACK from device)\n+     *\n+     * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+     */\n+    @NonNullByDefault\n+    public static class LEDOnOffCommandHandler extends CommandHandler {\n+        LEDOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int button = this.getIntParameter(\"button\", -1);\n+                if (cmd == OnOffType.ON) {\n+                    Msg m = dev.makeExtendedMessage((byte) 0x1f, (byte) 0x2e, (byte) 0x00,\n+                            new byte[] { (byte) button, (byte) 0x09, (byte) 0x01 });\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent msg to switch {} on\", nm(), dev.getAddress());\n+                } else if (cmd == OnOffType.OFF) {\n+                    Msg m = dev.makeExtendedMessage((byte) 0x1f, (byte) 0x2e, (byte) 0x00,\n+                            new byte[] { (byte) button, (byte) 0x09, (byte) 0x00 });\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class X10OnOffCommandHandler extends CommandHandler {\n+        X10OnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                byte houseCode = dev.getX10HouseCode();\n+                byte houseUnitCode = (byte) (houseCode << 4 | dev.getX10UnitCode());\n+                if (cmd == OnOffType.ON || cmd == OnOffType.OFF) {\n+                    byte houseCommandCode = (byte) (houseCode << 4\n+                            | (cmd == OnOffType.ON ? X10.Command.ON.code() : X10.Command.OFF.code()));\n+                    Msg munit = dev.makeX10Message(houseUnitCode, (byte) 0x00); // send unit code\n+                    dev.enqueueMessage(munit, feature);\n+                    Msg mcmd = dev.makeX10Message(houseCommandCode, (byte) 0x80); // send command code\n+                    dev.enqueueMessage(mcmd, feature);\n+                    String onOff = cmd == OnOffType.ON ? \"ON\" : \"OFF\";\n+                    logger.debug(\"{}: sent msg to switch {} {}\", nm(), dev.getAddress(), onOff);\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);", "originalCommit": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3Mjk4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389372989", "bodyText": "This is actually here because Msg.makeMessage() throws an IOException if it can't find the message. This should never happen, except during development. Can I leave as is?", "author": "robnielsen", "createdAt": "2020-03-08T14:12:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQ2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzNDg0OA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390034848", "bodyText": "done, created custom exception to replace IOException and left as warn.", "author": "robnielsen", "createdAt": "2020-03-10T00:37:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQ4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317489", "bodyText": "Ok, I won't repeat me anymore...", "author": "kaikreuzer", "createdAt": "2020-03-07T22:40:35Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/CommandHandler.java", "diffHunk": "@@ -0,0 +1,912 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A command handler translates an openHAB command into a insteon message\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public abstract class CommandHandler {\n+    private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);\n+    DeviceFeature feature; // related DeviceFeature\n+    @Nullable\n+    HashMap<String, @Nullable String> parameters = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param feature The DeviceFeature for which this command was intended.\n+     *            The openHAB commands are issued on an openhab item. The .items files bind\n+     *            an openHAB item to a DeviceFeature.\n+     */\n+    CommandHandler(DeviceFeature feature) {\n+        this.feature = feature;\n+    }\n+\n+    /**\n+     * Implements what to do when an openHAB command is received\n+     *\n+     * @param config the configuration for the item that generated the command\n+     * @param cmd the openhab command issued\n+     * @param device the Insteon device to which this command applies\n+     */\n+    public abstract void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice device);\n+\n+    /**\n+     * Returns parameter as integer\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected int getIntParameter(String key, int def) {\n+        String val = parameters.get(key);\n+        if (val == null) {\n+            return (def); // param not found\n+        }\n+        int ret = def;\n+        try {\n+            ret = Utils.strToInt(val);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in command handler: {}\", key);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns parameter as String\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected @Nullable String getStringParameter(String key, String def) {\n+        return (parameters.get(key) == null ? def : parameters.get(key));\n+    }\n+\n+    /**\n+     * Shorthand to return class name for logging purposes\n+     *\n+     * @return name of the class\n+     */\n+    protected String nm() {\n+        return (this.getClass().getSimpleName());\n+    }\n+\n+    protected int getMaxLightLevel(InsteonChannelConfiguration conf, int defaultLevel) {\n+        HashMap<String, @Nullable String> params = conf.getParameters();\n+        if (conf.getFeature().contains(\"dimmer\") && params.containsKey(\"dimmermax\")) {\n+            String item = conf.getChannelName();\n+            String dimmerMax = params.get(\"dimmermax\");\n+            try {\n+                int i = Integer.parseInt(dimmerMax);\n+                if (i > 1 && i <= 99) {\n+                    int level = (int) Math.ceil((i * 255.0) / 100); // round up\n+                    if (level < defaultLevel) {\n+                        logger.debug(\"item {}: using dimmermax value of {}\", item, dimmerMax);\n+                        return level;\n+                    }\n+                } else {\n+                    logger.warn(\"item {}: dimmermax must be between 1-99 inclusive: {}\", item, dimmerMax);\n+                }\n+            } catch (NumberFormatException e) {\n+                logger.warn(\"item {}: invalid int value for dimmermax: {}\", item, dimmerMax);\n+            }\n+        }\n+\n+        return defaultLevel;\n+    }\n+\n+    void setParameters(HashMap<String, @Nullable String> hm) {\n+        parameters = hm;\n+    }\n+\n+    /**\n+     * Helper function to extract the group parameter from the binding config,\n+     *\n+     * @param c the binding configuration to test\n+     * @return the value of the \"group\" parameter, or -1 if none\n+     */\n+    protected static int getGroup(InsteonChannelConfiguration c) {\n+        String v = c.getParameters().get(\"group\");\n+        int iv = -1;\n+        try {\n+            iv = (v == null) ? -1 : Utils.strToInt(v);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in for item {}\", c.getChannelName());\n+        }\n+        return iv;\n+    }\n+\n+    @NonNullByDefault\n+    public static class WarnCommandHandler extends CommandHandler {\n+        WarnCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            logger.warn(\"{}: command {} is not implemented yet!\", nm(), cmd);\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class NoOpCommandHandler extends CommandHandler {\n+        NoOpCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            // do nothing, not even log\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class LightOnOffCommandHandler extends CommandHandler {\n+        LightOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int ext = getIntParameter(\"ext\", 0);\n+                int direc = 0x00;\n+                int level = 0x00;\n+                Msg m = null;\n+                if (cmd == OnOffType.ON) {\n+                    level = getMaxLightLevel(conf, 0xff);\n+                    direc = 0x11;\n+                    logger.debug(\"{}: sent msg to switch {} to {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    direc = 0x13;\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+                if (ext == 1 || ext == 2) {\n+                    byte[] data = new byte[] { (byte) getIntParameter(\"d1\", 0), (byte) getIntParameter(\"d2\", 0),\n+                            (byte) getIntParameter(\"d3\", 0) };\n+                    m = dev.makeExtendedMessage((byte) 0x0f, (byte) direc, (byte) level, data);\n+                    logger.debug(\"{}: was an extended message for device {}\", nm(), dev.getAddress());\n+                    if (ext == 1) {\n+                        m.setCRC();\n+                    } else if (ext == 2) {\n+                        m.setCRC2();\n+                    }\n+                } else {\n+                    m = dev.makeStandardMessage((byte) 0x0f, (byte) direc, (byte) level, getGroup(conf));\n+                }\n+                logger.debug(\"Sending message to {}\", dev.getAddress());\n+                dev.enqueueMessage(m, feature);\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class FastOnOffCommandHandler extends CommandHandler {\n+        FastOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    int level = getMaxLightLevel(conf, 0xff);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x12, (byte) level, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast on to switch {} level {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x14, (byte) 0x00, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast off to switch {}\", nm(), dev.getAddress());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class RampOnOffCommandHandler extends RampCommandHandler {\n+        RampOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 100);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOnCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp on to switch {} time {} level {} cmd1 {}\", nm(), dev.getAddress(),\n+                            ramptime, ramplevel, getOnCmd());\n+                } else if (cmd == OnOffType.OFF) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 0 /* ignored */);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOffCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp off to switch {} time {} cmd1 {}\", nm(), dev.getAddress(), ramptime,\n+                            getOffCmd());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+\n+        private int getRampLevel(InsteonChannelConfiguration conf, int defaultValue) {\n+            HashMap<String, @Nullable String> params = conf.getParameters();\n+            return params.containsKey(\"ramplevel\") ? Integer.parseInt(params.get(\"ramplevel\")) : defaultValue;\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class ManualChangeCommandHandler extends CommandHandler {\n+        ManualChangeCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd instanceof DecimalType) {\n+                    int v = ((DecimalType) cmd).intValue();\n+                    int cmd1 = (v != 1) ? 0x17 : 0x18; // start or stop\n+                    int cmd2 = (v == 2) ? 0x01 : 0; // up or down\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) cmd1, (byte) cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: cmd {} sent manual change {} {} to {}\", nm(), v,\n+                            (cmd1 == 0x17) ? \"START\" : \"STOP\", (cmd2 == 0x01) ? \"UP\" : \"DOWN\", dev.getAddress());\n+                } else {\n+                    logger.warn(\"{}: invalid command type: {}\", nm(), cmd);\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sends ALLLink broadcast commands to group\n+     */\n+    @NonNullByDefault\n+    public static class GroupBroadcastCommandHandler extends CommandHandler {\n+        GroupBroadcastCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON || cmd == OnOffType.OFF) {\n+                    byte cmd1 = (byte) ((cmd == OnOffType.ON) ? 0x11 : 0x13);\n+                    byte value = (byte) ((cmd == OnOffType.ON) ? 0xFF : 0x00);\n+                    int group = getGroup(conf);\n+                    if (group == -1) {\n+                        logger.warn(\"no group=xx specified in item {}\", conf.getChannelName());\n+                        return;\n+                    }\n+                    logger.debug(\"{}: sending {} broadcast to group {}\", nm(), (cmd1 == 0x11) ? \"ON\" : \"OFF\",\n+                            getGroup(conf));\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, cmd1, value, group);\n+                    dev.enqueueMessage(m, feature);\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This Handler was supposed to set the LEDs of the 2487S, but it doesn't work.\n+     * The parameters were modeled after the 2486D, it may work for that one,\n+     * leaving it in for now.\n+     *\n+     * From the HouseLinc PLM traffic log, the following commands (in the D2 data field)\n+     * of the 2486D are supported:\n+     *\n+     * 0x02: LED follow mask may work or not\n+     * 0x03: LED OFF mask\n+     * 0x04: X10 addr setting\n+     * 0x05: ramp rate\n+     * 0x06: on Level for button\n+     * 0x07: global LED brightness (could not see any effect during testing)\n+     * 0x0B: set nontoggle on/off command\n+     *\n+     * crucially, the 0x09 command does not work (NACK from device)\n+     *\n+     * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+     */\n+    @NonNullByDefault\n+    public static class LEDOnOffCommandHandler extends CommandHandler {\n+        LEDOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int button = this.getIntParameter(\"button\", -1);\n+                if (cmd == OnOffType.ON) {\n+                    Msg m = dev.makeExtendedMessage((byte) 0x1f, (byte) 0x2e, (byte) 0x00,\n+                            new byte[] { (byte) button, (byte) 0x09, (byte) 0x01 });\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent msg to switch {} on\", nm(), dev.getAddress());\n+                } else if (cmd == OnOffType.OFF) {\n+                    Msg m = dev.makeExtendedMessage((byte) 0x1f, (byte) 0x2e, (byte) 0x00,\n+                            new byte[] { (byte) button, (byte) 0x09, (byte) 0x00 });\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class X10OnOffCommandHandler extends CommandHandler {\n+        X10OnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                byte houseCode = dev.getX10HouseCode();\n+                byte houseUnitCode = (byte) (houseCode << 4 | dev.getX10UnitCode());\n+                if (cmd == OnOffType.ON || cmd == OnOffType.OFF) {\n+                    byte houseCommandCode = (byte) (houseCode << 4\n+                            | (cmd == OnOffType.ON ? X10.Command.ON.code() : X10.Command.OFF.code()));\n+                    Msg munit = dev.makeX10Message(houseUnitCode, (byte) 0x00); // send unit code\n+                    dev.enqueueMessage(munit, feature);\n+                    Msg mcmd = dev.makeX10Message(houseCommandCode, (byte) 0x80); // send command code\n+                    dev.enqueueMessage(mcmd, feature);\n+                    String onOff = cmd == OnOffType.ON ? \"ON\" : \"OFF\";\n+                    logger.debug(\"{}: sent msg to switch {} {}\", nm(), dev.getAddress(), onOff);\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class X10PercentCommandHandler extends CommandHandler {\n+        X10PercentCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                //\n+                // I did not have hardware that would respond to the PRESET_DIM codes.\n+                // This code path needs testing.\n+                //\n+                byte houseCode = dev.getX10HouseCode();\n+                byte houseUnitCode = (byte) (houseCode << 4 | dev.getX10UnitCode());\n+                Msg munit = dev.makeX10Message(houseUnitCode, (byte) 0x00); // send unit code\n+                dev.enqueueMessage(munit, feature);\n+                PercentType pc = (PercentType) cmd;\n+                logger.debug(\"{}: changing level of {} to {}\", nm(), dev.getAddress(), pc.intValue());\n+                int level = (pc.intValue() * 32) / 100;\n+                byte cmdCode = (level >= 16) ? X10.Command.PRESET_DIM_2.code() : X10.Command.PRESET_DIM_1.code();\n+                level = level % 16;\n+                if (level <= 0) {\n+                    level = 0;\n+                }\n+                houseCode = (byte) x10CodeForLevel[level];\n+                cmdCode |= (houseCode << 4);\n+                Msg mcmd = dev.makeX10Message(cmdCode, (byte) 0x80); // send command code\n+                dev.enqueueMessage(mcmd, feature);\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);", "originalCommit": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3Mjk5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389372992", "bodyText": "This is actually here because Msg.makeMessage() throws an IOException if it can't find the message. This should never happen, except during development. Can I leave as is?", "author": "robnielsen", "createdAt": "2020-03-08T14:12:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzNDkwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390034901", "bodyText": "done, created custom exception to replace IOException and left as warn.", "author": "robnielsen", "createdAt": "2020-03-10T00:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzg3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317871", "bodyText": "This I do not understand. You clearly cannot know whether one of those exist, so why do you add a discovery result?\nCan't you check for their physical presence? If not, the user should add a bridge manually.", "author": "kaikreuzer", "createdAt": "2020-03-07T22:46:33Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/discovery/InsteonNetworkDiscoveryService.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.discovery;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.insteon.internal.InsteonBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonNetworkDiscoveryService} is responsible for device discovery.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.insteon\")\n+public class InsteonNetworkDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(InsteonNetworkDiscoveryService.class);\n+\n+    private static final ThingUID LOCAL_THING = new ThingUID(InsteonBindingConstants.NETWORK_THING_TYPE, \"local\");\n+\n+    private static final int DISCOVER_TIMEOUT_SECONDS = 2;\n+\n+    public InsteonNetworkDiscoveryService() {\n+        super(new HashSet<>(Arrays.asList(InsteonBindingConstants.NETWORK_THING_TYPE)), DISCOVER_TIMEOUT_SECONDS, true);\n+\n+        logger.debug(\"Initializing InsteonNetworkDiscoveryService\");\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        startScan();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting scan for Insteon network\");\n+\n+        thingDiscovered(DiscoveryResultBuilder.create(LOCAL_THING).withLabel(\"Insteon PLM or Hub\").build());", "originalCommit": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3NDEzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389374139", "bodyText": "I used the pattern that astro and a few other bindings use. Its more of a helper for somebody to get started.\nDuring testing, a couple of people commented on how easy it made for them to configure the Insteon nework because insteon:network:local was in the inbox.", "author": "robnielsen", "createdAt": "2020-03-08T14:24:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzg3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4MzI3MA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389983270", "bodyText": "Astro is an exception, because we know that sun and moon exist.\nJust because misusing a feature makes some people happy, we must not go down that path.\nAnd the new UI is guiding people anyhow much better in the setup process, so the inbox should stay what it is: The place where discovered devices are found.", "author": "kaikreuzer", "createdAt": "2020-03-09T21:54:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzg3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwNjk1MA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390006950", "bodyText": "Removed", "author": "robnielsen", "createdAt": "2020-03-09T23:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzg3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODIzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389318239", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"Starting Insteon bridge\");\n          \n          \n            \n                    logger.debug(\"Starting Insteon bridge\");", "author": "kaikreuzer", "createdAt": "2020-03-07T22:54:07Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonNetworkHandler.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.discovery.InsteonDeviceDiscoveryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonNetworkHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public class InsteonNetworkHandler extends BaseBridgeHandler {\n+\n+    private static final int LOG_DEVICE_STATISTICS_DELAY_IN_SECONDS = 600;\n+    private static final int SETTLE_TIME_IN_SECONDS = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonNetworkHandler.class);\n+\n+    private @Nullable InsteonNetworkConfiguration config;\n+    private @Nullable InsteonBinding insteonBinding;\n+    private @Nullable InsteonDeviceDiscoveryService insteonDeviceDiscoveryService;\n+    private @Nullable ScheduledFuture<?> pollingJob = null;\n+    private @Nullable ScheduledFuture<?> settleJob = null;\n+    private long lastInsteonDeviceCreatedTimestamp = 0;\n+    private @Nullable SerialPortManager serialPortManager;\n+\n+    public static ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+\n+    public InsteonNetworkHandler(Bridge bridge, @Nullable SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Starting Insteon bridge\");", "originalCommit": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3NTc1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389375755", "bodyText": "done.", "author": "robnielsen", "createdAt": "2020-03-08T14:45:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODI1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389318254", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        updateStatus(ThingStatus.ONLINE);\n          \n          \n            \n                        updateStatus(ThingStatus.UNKOWN);\n          \n      \n    \n    \n  \n\nYou didn't have any successful communication with the bridge here, did you?", "author": "kaikreuzer", "createdAt": "2020-03-07T22:54:50Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonNetworkHandler.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.discovery.InsteonDeviceDiscoveryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonNetworkHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public class InsteonNetworkHandler extends BaseBridgeHandler {\n+\n+    private static final int LOG_DEVICE_STATISTICS_DELAY_IN_SECONDS = 600;\n+    private static final int SETTLE_TIME_IN_SECONDS = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonNetworkHandler.class);\n+\n+    private @Nullable InsteonNetworkConfiguration config;\n+    private @Nullable InsteonBinding insteonBinding;\n+    private @Nullable InsteonDeviceDiscoveryService insteonDeviceDiscoveryService;\n+    private @Nullable ScheduledFuture<?> pollingJob = null;\n+    private @Nullable ScheduledFuture<?> settleJob = null;\n+    private long lastInsteonDeviceCreatedTimestamp = 0;\n+    private @Nullable SerialPortManager serialPortManager;\n+\n+    public static ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+\n+    public InsteonNetworkHandler(Bridge bridge, @Nullable SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Starting Insteon bridge\");\n+        config = getConfigAs(InsteonNetworkConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            insteonBinding = new InsteonBinding(this, config, serialPortManager);\n+\n+            updateStatus(ThingStatus.ONLINE);", "originalCommit": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3NTUxOA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389375518", "bodyText": "No yet, but this is needed due to the way the original binding was written. Changing it would be a major refactoring that I was trying to avoid doing with the port of the binding.", "author": "robnielsen", "createdAt": "2020-03-08T14:42:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3NTgzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389375835", "bodyText": "The above warn message was changed as suggested.", "author": "robnielsen", "createdAt": "2020-03-08T14:46:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4NDMxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389984311", "bodyText": "Could you please elaborate on the reason why this is needed? If you cannot determine whether it is ONLINE or OFFLINE, you should rather keep it as UNKNOWN all the time.", "author": "kaikreuzer", "createdAt": "2020-03-09T21:56:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA1MDQzMA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390050430", "bodyText": "Setting to UNKNOWN didn't break anything. implemented as suggested.", "author": "robnielsen", "createdAt": "2020-03-10T01:41:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODI4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389318287", "bodyText": "here you can set it to ONLINE", "author": "kaikreuzer", "createdAt": "2020-03-07T22:55:17Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonNetworkHandler.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.discovery.InsteonDeviceDiscoveryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonNetworkHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public class InsteonNetworkHandler extends BaseBridgeHandler {\n+\n+    private static final int LOG_DEVICE_STATISTICS_DELAY_IN_SECONDS = 600;\n+    private static final int SETTLE_TIME_IN_SECONDS = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonNetworkHandler.class);\n+\n+    private @Nullable InsteonNetworkConfiguration config;\n+    private @Nullable InsteonBinding insteonBinding;\n+    private @Nullable InsteonDeviceDiscoveryService insteonDeviceDiscoveryService;\n+    private @Nullable ScheduledFuture<?> pollingJob = null;\n+    private @Nullable ScheduledFuture<?> settleJob = null;\n+    private long lastInsteonDeviceCreatedTimestamp = 0;\n+    private @Nullable SerialPortManager serialPortManager;\n+\n+    public static ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+\n+    public InsteonNetworkHandler(Bridge bridge, @Nullable SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Starting Insteon bridge\");\n+        config = getConfigAs(InsteonNetworkConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            insteonBinding = new InsteonBinding(this, config, serialPortManager);\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            // hold off on starting to poll until devices that already are defined as things are added.\n+            // wait SETTLE_TIME_IN_SECONDS to start then check every second afterwards until it has been at\n+            // least SETTLE_TIME_IN_SECONDS since last device was created.\n+            settleJob = scheduler.scheduleWithFixedDelay(() -> {\n+                // check to see if it has been at least SETTLE_TIME_IN_SECONDS since last device was created\n+                if (System.currentTimeMillis() - lastInsteonDeviceCreatedTimestamp > SETTLE_TIME_IN_SECONDS * 1000) {\n+                    // settle time has expired start polling\n+                    if (insteonBinding.startPolling()) {\n+                        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                            insteonBinding.logDeviceStatistics();\n+                        }, 0, LOG_DEVICE_STATISTICS_DELAY_IN_SECONDS, TimeUnit.SECONDS);\n+\n+                        insteonBinding.setIsActive(true);", "originalCommit": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3NTUzNg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389375536", "bodyText": "see above comment.", "author": "robnielsen", "createdAt": "2020-03-08T14:42:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODI4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA1MDQ3MA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390050470", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-10T01:41:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODI5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389318292", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"Shutting down Insteon bridge\");\n          \n          \n            \n                    logger.debug(\"Shutting down Insteon bridge\");", "author": "kaikreuzer", "createdAt": "2020-03-07T22:55:32Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonNetworkHandler.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.discovery.InsteonDeviceDiscoveryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonNetworkHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public class InsteonNetworkHandler extends BaseBridgeHandler {\n+\n+    private static final int LOG_DEVICE_STATISTICS_DELAY_IN_SECONDS = 600;\n+    private static final int SETTLE_TIME_IN_SECONDS = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonNetworkHandler.class);\n+\n+    private @Nullable InsteonNetworkConfiguration config;\n+    private @Nullable InsteonBinding insteonBinding;\n+    private @Nullable InsteonDeviceDiscoveryService insteonDeviceDiscoveryService;\n+    private @Nullable ScheduledFuture<?> pollingJob = null;\n+    private @Nullable ScheduledFuture<?> settleJob = null;\n+    private long lastInsteonDeviceCreatedTimestamp = 0;\n+    private @Nullable SerialPortManager serialPortManager;\n+\n+    public static ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+\n+    public InsteonNetworkHandler(Bridge bridge, @Nullable SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Starting Insteon bridge\");\n+        config = getConfigAs(InsteonNetworkConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            insteonBinding = new InsteonBinding(this, config, serialPortManager);\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            // hold off on starting to poll until devices that already are defined as things are added.\n+            // wait SETTLE_TIME_IN_SECONDS to start then check every second afterwards until it has been at\n+            // least SETTLE_TIME_IN_SECONDS since last device was created.\n+            settleJob = scheduler.scheduleWithFixedDelay(() -> {\n+                // check to see if it has been at least SETTLE_TIME_IN_SECONDS since last device was created\n+                if (System.currentTimeMillis() - lastInsteonDeviceCreatedTimestamp > SETTLE_TIME_IN_SECONDS * 1000) {\n+                    // settle time has expired start polling\n+                    if (insteonBinding.startPolling()) {\n+                        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                            insteonBinding.logDeviceStatistics();\n+                        }, 0, LOG_DEVICE_STATISTICS_DELAY_IN_SECONDS, TimeUnit.SECONDS);\n+\n+                        insteonBinding.setIsActive(true);\n+                    } else {\n+                        String msg = \"Initialization failed, unable to start the Insteon bridge with the port '\"\n+                                + config.getPort() + \"'.\";\n+                        logger.warn(msg);\n+\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                    }\n+\n+                    settleJob.cancel(true);\n+                    settleJob = null;\n+                }\n+            }, SETTLE_TIME_IN_SECONDS, 1, TimeUnit.SECONDS);\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.info(\"Shutting down Insteon bridge\");", "originalCommit": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3MTc1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389371756", "bodyText": "done", "author": "robnielsen", "createdAt": "2020-03-08T13:56:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODI5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA2MjM3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390062376", "bodyText": "I would move this to before the scheduler executes. It is generally expected that a call to initialize() would update the ThingStatus, even if just to UNKNOWN.", "author": "cpmeister", "createdAt": "2020-03-10T02:29:09Z", "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonNetworkHandler.java", "diffHunk": "@@ -74,7 +74,7 @@ public void initialize() {\n         scheduler.execute(() -> {\n             insteonBinding = new InsteonBinding(this, config, serialPortManager);\n \n-            updateStatus(ThingStatus.ONLINE);\n+            updateStatus(ThingStatus.UNKNOWN);", "originalCommit": "2438b6bca04cc38379e830e874ef9f7a54f06e72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA2NDMzMg==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390064332", "bodyText": "I made the change per Kai's suggestion above:\nkaikreuzer 2 days ago Member\nSuggested change\nupdateStatus(ThingStatus.ONLINE);\nupdateStatus(ThingStatus.UNKOWN);\nYou didn't have any successful communication with the bridge here, did you?", "author": "robnielsen", "createdAt": "2020-03-10T02:38:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA2MjM3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA2ODA2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390068069", "bodyText": "No I have been keeping up with the conversations, but I have been keeping my input to a minimum since you seem to reject most of my suggestions. I'm sure Kai will weigh in anyway.", "author": "cpmeister", "createdAt": "2020-03-10T02:52:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA2MjM3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA4NTg3OA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390085878", "bodyText": "I've made a fair number of your suggestions, and for this one I did what Kai suggested as well.", "author": "robnielsen", "createdAt": "2020-03-10T04:10:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA2MjM3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYyMzAzNA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r392623034", "bodyText": "@robnielsen My request was to change ONLINE to UNKNOWN, I wasn't saying that it has to be done in exactly this line.\nI agree with @cpmeister that the better place is before the scheduler code, so if you'd move it, it'd be nice. It won't really harm to leave it here either, though.\nIn general, doing it early in the code (and in the same thread) is safer, because you are expected to set the Thing status and the later you do it, the higher the risk is that you run some code that for some reason throws an exception or does any other unexpected flow.", "author": "kaikreuzer", "createdAt": "2020-03-14T22:06:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA2MjM3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYyNDU4NA==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r392624584", "bodyText": "@cpmeister, @kaikreuzer I moved it. Just a suggestion maybe this would be good to add to some sort of implementation guide?", "author": "robnielsen", "createdAt": "2020-03-14T22:34:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA2MjM3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYyNDgwMw==", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r392624803", "bodyText": "It is documented in detail directly in the code that is provided as a skeleton, including an example: https://github.com/openhab/openhab-core/blob/master/tools/archetype/binding/src/main/resources/archetype-resources/src/main/java/internal/__bindingIdCamelCase__Handler.java#L70-L91", "author": "kaikreuzer", "createdAt": "2020-03-14T22:37:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA2MjM3Ng=="}], "type": "inlineReview"}, {"oid": "e848835fd1b728fd30be7024541421d28781a13c", "url": "https://github.com/openhab/openhab-addons/commit/e848835fd1b728fd30be7024541421d28781a13c", "message": "[insteon] initial commit of insteon binding\n\nSigned-off-by: Rob Nielsen <rob.nielsen@yahoo.com>", "committedDate": "2020-03-15T20:14:55Z", "type": "commit"}]}