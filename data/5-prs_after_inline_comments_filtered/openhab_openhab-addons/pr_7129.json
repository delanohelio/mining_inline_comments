{"pr_number": 7129, "pr_title": "[bluetooth] Refactor and unify BluetoothAdapter implementation logic", "pr_createdAt": "2020-03-08T21:31:16Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7129", "timeline": [{"oid": "c791a4c8e31e4c2ade4348ae1b9cd4f3838dedb0", "url": "https://github.com/openhab/openhab-addons/commit/c791a4c8e31e4c2ade4348ae1b9cd4f3838dedb0", "message": "Refactor and unify BluetoothAdapter implementation logic\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>", "committedDate": "2020-03-08T20:58:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxNTMzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7129#discussion_r401815336", "bodyText": "Nice. Didn't know about that.", "author": "J-N-K", "createdAt": "2020-04-01T18:16:50Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/handler/BlueZBridgeHandler.java", "diffHunk": "@@ -167,70 +112,36 @@ private void startDiscovery() {\n     }\n \n     private void refreshDevices() {\n-        try {\n+        refreshTry: try {\n             logger.debug(\"Refreshing Bluetooth device list...\");\n             List<tinyb.BluetoothDevice> tinybDevices = adapter.getDevices();\n             logger.debug(\"Found {} Bluetooth devices.\", tinybDevices.size());\n             for (tinyb.BluetoothDevice tinybDevice : tinybDevices) {\n                 BlueZBluetoothDevice device = getDevice(new BluetoothAddress(tinybDevice.getAddress()));\n                 device.updateTinybDevice(tinybDevice);\n-                notifyDiscoveryListeners(device);\n-            }\n-            // clean up orphaned entries\n-            synchronized (devices) {\n-                for (BlueZBluetoothDevice device : devices.values()) {\n-                    if (shouldRemove(device)) {\n-                        logger.debug(\"Removing device '{}' due to inactivity\", device.getAddress());\n-                        device.dispose();\n-                        devices.remove(device.getAddress());\n-                        discoveryListeners.forEach(listener -> listener.deviceRemoved(device));\n-                    }\n-                }\n+                deviceDiscovered(device);\n             }\n             // For whatever reason, bluez will sometimes turn off scanning. So we just make sure it keeps running.\n             startDiscovery();\n-            // everything went fine, so lets switch to online\n-            updateStatus(ThingStatus.ONLINE);\n         } catch (BluetoothException ex) {\n             String message = ex.getMessage();\n             if (message != null) {\n                 if (message.contains(\"Operation already in progress\")) {\n                     // we shouldn't go offline in this case\n-                    return;\n+                    break refreshTry;", "originalCommit": "079e219b8db08132c0a80e80b0983ccba18546a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkzODQyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7129#discussion_r401938423", "bodyText": "I was surprised when I first found out about that too.\nUsing labels allows you to break out of any code block.\nI rarely find the need to use it though but it does come in handy on occasion.", "author": "cpmeister", "createdAt": "2020-04-01T22:07:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxNTMzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxNTY1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7129#discussion_r401815659", "bodyText": "I think you can omit the check and let the framework do that work.", "author": "J-N-K", "createdAt": "2020-04-01T18:17:23Z", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/handler/BlueZBridgeHandler.java", "diffHunk": "@@ -167,70 +112,36 @@ private void startDiscovery() {\n     }\n \n     private void refreshDevices() {\n-        try {\n+        refreshTry: try {\n             logger.debug(\"Refreshing Bluetooth device list...\");\n             List<tinyb.BluetoothDevice> tinybDevices = adapter.getDevices();\n             logger.debug(\"Found {} Bluetooth devices.\", tinybDevices.size());\n             for (tinyb.BluetoothDevice tinybDevice : tinybDevices) {\n                 BlueZBluetoothDevice device = getDevice(new BluetoothAddress(tinybDevice.getAddress()));\n                 device.updateTinybDevice(tinybDevice);\n-                notifyDiscoveryListeners(device);\n-            }\n-            // clean up orphaned entries\n-            synchronized (devices) {\n-                for (BlueZBluetoothDevice device : devices.values()) {\n-                    if (shouldRemove(device)) {\n-                        logger.debug(\"Removing device '{}' due to inactivity\", device.getAddress());\n-                        device.dispose();\n-                        devices.remove(device.getAddress());\n-                        discoveryListeners.forEach(listener -> listener.deviceRemoved(device));\n-                    }\n-                }\n+                deviceDiscovered(device);\n             }\n             // For whatever reason, bluez will sometimes turn off scanning. So we just make sure it keeps running.\n             startDiscovery();\n-            // everything went fine, so lets switch to online\n-            updateStatus(ThingStatus.ONLINE);\n         } catch (BluetoothException ex) {\n             String message = ex.getMessage();\n             if (message != null) {\n                 if (message.contains(\"Operation already in progress\")) {\n                     // we shouldn't go offline in this case\n-                    return;\n+                    break refreshTry;\n                 }\n                 int idx = message.lastIndexOf(':');\n                 if (idx != -1) {\n                     message = message.substring(idx).trim();\n                 }\n             }\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+            return;\n         }\n-    }\n-\n-    private boolean shouldRemove(BlueZBluetoothDevice device) {\n-        // we can't remove devices with listeners since that means they have a handler.\n-        if (device.hasListeners()) {\n-            return false;\n-        }\n-        // devices that are connected won't receive any scan notifications so we can't remove them for being idle\n-        if (device.getConnectionState() == ConnectionState.CONNECTED) {\n-            return false;\n+        // everything went fine, so lets switch to online if not already\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {", "originalCommit": "079e219b8db08132c0a80e80b0983ccba18546a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkzNjIwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7129#discussion_r401936200", "bodyText": "done", "author": "cpmeister", "createdAt": "2020-04-01T22:01:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxNTY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxOTM0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7129#discussion_r401819341", "bodyText": "why not use computeIfAbsent here? ConcurrentHashMap implements that atomically.", "author": "J-N-K", "createdAt": "2020-04-01T18:23:41Z", "path": "bundles/org.openhab.binding.bluetooth/src/main/java/org/openhab/binding/bluetooth/AbstractBluetoothBridgeHandler.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth;\n+\n+import java.time.ZonedDateTime;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a abstract superclass for BluetoothAdapter implementations. This class takes care of inactive device cleanup\n+ * as well as handling background and active discovery logic.\n+ *\n+ * Subclasses will primarily be responsible for device discovery\n+ *\n+ * @author Connor Petty - Initial contribution from refactored code\n+ */\n+@NonNullByDefault\n+public abstract class AbstractBluetoothBridgeHandler<BD extends BluetoothDevice> extends BaseBridgeHandler\n+        implements BluetoothAdapter {\n+\n+    protected final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    // Set of discovery listeners\n+    private final Set<BluetoothDiscoveryListener> discoveryListeners = new CopyOnWriteArraySet<>();\n+\n+    // Map of Bluetooth devices known to this bridge.\n+    // This contains the devices from the most recent scan\n+    private final Map<BluetoothAddress, BD> devices = new ConcurrentHashMap<>();\n+\n+    // Actual discovery status.\n+    protected volatile boolean activeScanEnabled = false;\n+\n+    private BaseBluetoothBridgeHandlerConfiguration config = new BaseBluetoothBridgeHandlerConfiguration();\n+\n+    private @Nullable ScheduledFuture<?> inactiveRemovalJob;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public AbstractBluetoothBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public ThingUID getUID() {\n+        return getThing().getUID();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(BaseBluetoothBridgeHandlerConfiguration.class);\n+\n+        int intervalSecs = config.inactiveDeviceCleanupIntervalSecs;\n+        inactiveRemovalJob = scheduler.scheduleWithFixedDelay(this::removeInactiveDevices, intervalSecs, intervalSecs,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> inactiveRemovalJob = this.inactiveRemovalJob;\n+        if (inactiveRemovalJob != null) {\n+            inactiveRemovalJob.cancel(true);\n+        }\n+        this.inactiveRemovalJob = null;\n+\n+        synchronized (devices) {\n+            for (BD device : devices.values()) {\n+                removeDevice(device);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    private void removeInactiveDevices() {\n+        // clean up orphaned entries\n+        synchronized (devices) {\n+            for (BD device : devices.values()) {\n+                if (shouldRemove(device)) {\n+                    logger.debug(\"Removing device '{}' due to inactivity\", device.getAddress());\n+                    removeDevice(device);\n+                }\n+            }\n+        }\n+    }\n+\n+    protected void removeDevice(BluetoothDevice device) {\n+        device.dispose();\n+        synchronized (devices) {\n+            devices.remove(device.getAddress());\n+        }\n+        discoveryListeners.forEach(listener -> listener.deviceRemoved(device));\n+    }\n+\n+    private boolean shouldRemove(BluetoothDevice device) {\n+        // we can't remove devices with listeners since that means they have a handler.\n+        if (device.hasListeners()) {\n+            return false;\n+        }\n+        // devices that are connected won't receive any scan notifications so we can't remove them for being idle\n+        if (device.getConnectionState() == ConnectionState.CONNECTED) {\n+            return false;\n+        }\n+\n+        // we remove devices we haven't seen in a while\n+        return ZonedDateTime.now().minusSeconds(config.inactiveDeviceCleanupThresholdSecs)\n+                .isAfter(device.getLastSeenTime());\n+    }\n+\n+    @Override\n+    public void addDiscoveryListener(BluetoothDiscoveryListener listener) {\n+        discoveryListeners.add(listener);\n+    }\n+\n+    @Override\n+    public void removeDiscoveryListener(@Nullable BluetoothDiscoveryListener listener) {\n+        discoveryListeners.remove(listener);\n+    }\n+\n+    @Override\n+    public void scanStart() {\n+        // Enable scanning even while discovery is disabled in config. This allows manual starting discovery.\n+        activeScanEnabled = true;\n+        refreshDiscoveredDevices();\n+    }\n+\n+    protected void refreshDiscoveredDevices() {\n+        logger.debug(\"Refreshing Bluetooth device list...\");\n+        synchronized (devices) {\n+            devices.values().forEach(this::deviceDiscovered);\n+        }\n+    }\n+\n+    @Override\n+    public void scanStop() {\n+        // Set active discovery state back to the configured discovery state.\n+        activeScanEnabled = false;\n+        // We need to keep the adapter in discovery mode as we otherwise won't get any RSSI updates either\n+    }\n+\n+    @Override\n+    public BD getDevice(BluetoothAddress address) {\n+        synchronized (devices) {", "originalCommit": "079e219b8db08132c0a80e80b0983ccba18546a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxOTM3OA==", "url": "https://github.com/openhab/openhab-addons/pull/7129#discussion_r401919378", "bodyText": "I toyed with the idea, but the atomic behavior is already handled by the synchronized blocks and computeIfAbsent saves at most 2 lines of code while at the same having to utilize the overhead of a multi-statement lambda. I typically use computeIfAbsent if the lambda can fit on a single line.\nSo to answer your question: I didn't implement it for stylistic reasons.\nBut you did bring up a good point the I'm using a ConcurrentHashMap which is overkill in this particular case, so I'll change it to a HashMap.", "author": "cpmeister", "createdAt": "2020-04-01T21:26:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxOTM0MQ=="}], "type": "inlineReview"}, {"oid": "05c648de62fdf832dd392624b4ad947d6372f93d", "url": "https://github.com/openhab/openhab-addons/commit/05c648de62fdf832dd392624b4ad947d6372f93d", "message": "Review changes.\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>", "committedDate": "2020-04-01T21:19:41Z", "type": "commit"}, {"oid": "73237afebaf0531194f89464cd3ee6400573c1e5", "url": "https://github.com/openhab/openhab-addons/commit/73237afebaf0531194f89464cd3ee6400573c1e5", "message": "Merge branch '2.5.x' of https://github.com/openhab/openhab-addons into\n6919\n\n# Conflicts:\n#\tbundles/org.openhab.binding.bluetooth.bluegiga/src/main/java/org/openhab/binding/bluetooth/bluegiga/BlueGigaBluetoothDevice.java\n#\tbundles/org.openhab.binding.bluetooth.bluegiga/src/main/java/org/openhab/binding/bluetooth/bluegiga/handler/BlueGigaBridgeHandler.java\n\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>", "committedDate": "2020-04-01T21:53:08Z", "type": "commit"}, {"oid": "73237afebaf0531194f89464cd3ee6400573c1e5", "url": "https://github.com/openhab/openhab-addons/commit/73237afebaf0531194f89464cd3ee6400573c1e5", "message": "Merge branch '2.5.x' of https://github.com/openhab/openhab-addons into\n6919\n\n# Conflicts:\n#\tbundles/org.openhab.binding.bluetooth.bluegiga/src/main/java/org/openhab/binding/bluetooth/bluegiga/BlueGigaBluetoothDevice.java\n#\tbundles/org.openhab.binding.bluetooth.bluegiga/src/main/java/org/openhab/binding/bluetooth/bluegiga/handler/BlueGigaBridgeHandler.java\n\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>", "committedDate": "2020-04-01T21:53:08Z", "type": "forcePushed"}]}