{"pr_number": 8723, "pr_title": "[irobot] iRobot binding", "pr_createdAt": "2020-10-10T20:36:01Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8723", "timeline": [{"oid": "d77f202096dea64b3c7d4d1522eb1e5366cc13b5", "url": "https://github.com/openhab/openhab-addons/commit/d77f202096dea64b3c7d4d1522eb1e5366cc13b5", "message": "[irobot] iRobot binding\n\nSupports iRobot Roomba and probably some other iRobots (in parts where they\nare compatible)\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>", "committedDate": "2020-10-10T21:06:08Z", "type": "forcePushed"}, {"oid": "32ea7853fadb002835ca873084e580fc095caf58", "url": "https://github.com/openhab/openhab-addons/commit/32ea7853fadb002835ca873084e580fc095caf58", "message": "[irobot] iRobot binding\n\nSupports iRobot Roomba and probably some other iRobots (in parts where they\nare compatible)\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>", "committedDate": "2020-10-10T21:20:09Z", "type": "forcePushed"}, {"oid": "d2dcfc6f54af2fa0b98a693024dddc894f587d53", "url": "https://github.com/openhab/openhab-addons/commit/d2dcfc6f54af2fa0b98a693024dddc894f587d53", "message": "[irobot] iRobot binding\n\nSupports iRobot Roomba and probably some other iRobots (in parts where they\nare compatible)\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>", "committedDate": "2020-10-10T21:49:32Z", "type": "forcePushed"}, {"oid": "37a6e5cfb8b51c89572f2b3f1c3e01b315942a97", "url": "https://github.com/openhab/openhab-addons/commit/37a6e5cfb8b51c89572f2b3f1c3e01b315942a97", "message": "[irobot] iRobot binding\n\nSupports iRobot Roomba and probably some other iRobots (in parts where they\nare compatible)\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>", "committedDate": "2020-10-10T21:59:39Z", "type": "forcePushed"}, {"oid": "8eae90c83ae45eaa5f9124109e91aa780618552b", "url": "https://github.com/openhab/openhab-addons/commit/8eae90c83ae45eaa5f9124109e91aa780618552b", "message": "[irobot] iRobot binding\n\nSupports iRobot Roomba and probably some other iRobots (in parts where they\nare compatible)\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>", "committedDate": "2020-10-10T22:14:22Z", "type": "forcePushed"}, {"oid": "2e27cc9f94715728aeae020c731840e290a68de6", "url": "https://github.com/openhab/openhab-addons/commit/2e27cc9f94715728aeae020c731840e290a68de6", "message": "[irobot] iRobot binding\n\nSupports iRobot Roomba and probably some other iRobots (in parts where they\nare compatible)\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>", "committedDate": "2020-10-11T07:13:20Z", "type": "forcePushed"}, {"oid": "9feec0893825684abd42a879fe117fbc98754431", "url": "https://github.com/openhab/openhab-addons/commit/9feec0893825684abd42a879fe117fbc98754431", "message": "[irobot] iRobot binding\n\nSupports iRobot Roomba and probably some other iRobots (in parts where they\nare compatible)\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>", "committedDate": "2020-10-11T07:43:25Z", "type": "forcePushed"}, {"oid": "8a7d769113697e238c7be8a91eaa7fbc60bedf80", "url": "https://github.com/openhab/openhab-addons/commit/8a7d769113697e238c7be8a91eaa7fbc60bedf80", "message": "[irobot] iRobot binding\n\nSupports iRobot Roomba and probably some other iRobots (in parts where they\nare compatible)\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>", "committedDate": "2020-10-11T07:53:11Z", "type": "forcePushed"}, {"oid": "e8e51c813a669118f325818983e0a1f1571ba090", "url": "https://github.com/openhab/openhab-addons/commit/e8e51c813a669118f325818983e0a1f1571ba090", "message": "[irobot] iRobot binding\n\nSupports iRobot Roomba and probably some other iRobots (in parts where they\nare compatible)\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>", "committedDate": "2020-10-11T08:05:59Z", "type": "forcePushed"}, {"oid": "5b0a32f1b5c550a08dc7487a2dc1ef8a22fbc0f5", "url": "https://github.com/openhab/openhab-addons/commit/5b0a32f1b5c550a08dc7487a2dc1ef8a22fbc0f5", "message": "[irobot] iRobot binding\n\nSupports iRobot Roomba and probably some other iRobots (in parts where they\nare compatible)\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>", "committedDate": "2020-10-11T09:29:25Z", "type": "forcePushed"}, {"oid": "4bec6a71d8dd6b06ac1444032f1c487cc4d9d423", "url": "https://github.com/openhab/openhab-addons/commit/4bec6a71d8dd6b06ac1444032f1c487cc4d9d423", "message": "[irobot] iRobot binding\n\nSupports iRobot Roomba and probably some other iRobots (in parts where they\nare compatible)\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>", "committedDate": "2020-10-13T19:45:57Z", "type": "forcePushed"}, {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b", "url": "https://github.com/openhab/openhab-addons/commit/a38f97cb3c7d7e3e94161bfaed485b4de24f498b", "message": "[irobot] iRobot binding\n\nSupports iRobot Roomba and probably some other iRobots (in parts where they\nare compatible)\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>", "committedDate": "2020-10-13T20:02:19Z", "type": "forcePushed"}, {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "url": "https://github.com/openhab/openhab-addons/commit/e9674556c16225cbbe635a06414cbf94eda1ea4c", "message": "[irobot] iRobot binding\n\nSupports iRobot Roomba and probably some other iRobots (in parts where they\nare compatible)\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>", "committedDate": "2020-10-21T21:04:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxODYzMw==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r508818633", "bodyText": "Please remove the email adress.", "author": "fwolter", "createdAt": "2020-10-20T20:29:11Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.json.JSONException;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution", "originalCommit": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5MjQ4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511392489", "bodyText": "ACK", "author": "Sonic-Amiga", "createdAt": "2020-10-24T10:52:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxODYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxODczOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r508818739", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Discovery service for iRobot's\n          \n          \n            \n             * Discovery service for iRobots", "author": "fwolter", "createdAt": "2020-10-20T20:29:22Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.json.JSONException;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Discovery service for iRobot's", "originalCommit": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxOTI5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r508819291", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-10-20T20:30:20Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.json.JSONException;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");", "originalCommit": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5MzcwMg==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511393702", "bodyText": "Yes, i remember this. To tell the truth i don't know framework's own logging facilities, and there could be tons of other output there, so for debugging it's just easier to have this here. And this line does not produce a lot of output, it's triggered only on startup. Also it helps to make sure that everything is OK on user's side, you can simply ask to crank up your binding logs to TRACE.\nBut, OK, i'll remove it because this is the requirement.", "author": "Sonic-Amiga", "createdAt": "2020-10-24T10:55:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxOTI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxOTUwMA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r508819500", "bodyText": "No harm in canceling a task that is already cancelled.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (scan != null && !scan.isDone()) {\n          \n          \n            \n                    if (scan != null) {", "author": "fwolter", "createdAt": "2020-10-20T20:30:43Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.json.JSONException;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {", "originalCommit": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3MzEzMg==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510973132", "bodyText": "Are you logging the stack trace by intention? Also, network errors should be treated as expected behavior, so this could be debug.", "author": "fwolter", "createdAt": "2020-10-23T15:40:40Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5NTM2MA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511395360", "bodyText": "In formatting an exception via {} doesn't dump the full trace on my side, just the message\nThe address is supposed to be raw IP, not a hostname, like 192.168.0.255. Getting UnknownHost on it would be totally strange, some internal system error. I wrote it here only because the IDE forces me to do so.\nI will add the comment in the code.", "author": "Sonic-Amiga", "createdAt": "2020-10-24T10:59:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3MzEzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5NjQ0MA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511396440", "bodyText": "1. In formatting an exception via {} doesn't dump the full trace on my side, just the message\n\n\nThe third parameter e will lead to dumping the full stack trace.\n\n2. The address is supposed to be raw IP, not a hostname, like 192.168.0.255. Getting UnknownHost on it would be totally strange, some internal system error. I wrote it here only because the IDE forces me to do so.\n   I will add the comment in the code.\n\n\nOK", "author": "fwolter", "createdAt": "2020-10-24T11:02:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3MzEzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQyNTgxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511425815", "bodyText": "The third parameter e will lead to dumping the full stack trace.\nWell, may be i never got this exception so i was just thinking so... Thanks for teaching me some Java :)", "author": "Sonic-Amiga", "createdAt": "2020-10-24T12:19:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3MzEzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgyNDcxMg==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r518824712", "bodyText": "The third parameter is still there.", "author": "fwolter", "createdAt": "2020-11-06T15:27:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3MzEzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3NjAzNw==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510976037", "bodyText": "See above. Use the debugger.", "author": "fwolter", "createdAt": "2020-10-23T15:45:23Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);\n+            }\n+        }\n+\n+        return addresses;\n+    }\n+\n+    private boolean receivePacketAndDiscover(DatagramSocket socket) {\n+        DatagramPacket incomingPacket;\n+\n+        try {\n+            incomingPacket = IdentProtocol.receiveResponse(socket);\n+        } catch (Exception e) {\n+            // This is not really an error, eventually we get a timeout\n+            // due to a loop in the caller\n+            return false;\n+        }\n+\n+        String host = incomingPacket.getAddress().toString().substring(1);\n+\n+        logger.debug(\"Received reply from {}\", host);\n+        logger.trace(\"{}\", new String(incomingPacket.getData()));", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3NjQ0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510976444", "bodyText": "Bindings should only log to error if something severe happened, like the detection of a bug in your code. This could be warn. See this link for a description of the log levels: https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-10-23T15:46:03Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);\n+            }\n+        }\n+\n+        return addresses;\n+    }\n+\n+    private boolean receivePacketAndDiscover(DatagramSocket socket) {\n+        DatagramPacket incomingPacket;\n+\n+        try {\n+            incomingPacket = IdentProtocol.receiveResponse(socket);\n+        } catch (Exception e) {\n+            // This is not really an error, eventually we get a timeout\n+            // due to a loop in the caller\n+            return false;\n+        }\n+\n+        String host = incomingPacket.getAddress().toString().substring(1);\n+\n+        logger.debug(\"Received reply from {}\", host);\n+        logger.trace(\"{}\", new String(incomingPacket.getData()));\n+\n+        IdentProtocol.IdentData ident;\n+\n+        try {\n+            ident = IdentProtocol.decodeResponse(incomingPacket);\n+        } catch (JsonParseException e) {\n+            logger.error(\"Malformed IDENT reply from {}!\", host);", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5NzIwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511397201", "bodyText": "Ok", "author": "Sonic-Amiga", "createdAt": "2020-10-24T11:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3NjQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3NjYxMA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510976610", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.", "author": "fwolter", "createdAt": "2020-10-23T15:46:21Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);\n+            }\n+        }\n+\n+        return addresses;\n+    }\n+\n+    private boolean receivePacketAndDiscover(DatagramSocket socket) {\n+        DatagramPacket incomingPacket;\n+\n+        try {\n+            incomingPacket = IdentProtocol.receiveResponse(socket);\n+        } catch (Exception e) {\n+            // This is not really an error, eventually we get a timeout\n+            // due to a loop in the caller\n+            return false;\n+        }\n+\n+        String host = incomingPacket.getAddress().toString().substring(1);\n+\n+        logger.debug(\"Received reply from {}\", host);\n+        logger.trace(\"{}\", new String(incomingPacket.getData()));\n+\n+        IdentProtocol.IdentData ident;\n+\n+        try {\n+            ident = IdentProtocol.decodeResponse(incomingPacket);\n+        } catch (JsonParseException e) {\n+            logger.error(\"Malformed IDENT reply from {}!\", host);\n+            return true;\n+        }\n+\n+        // This check comes from Roomba980-Python\n+        if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+            logger.info(\"Found unsupported iRobot \\\"{}\\\" version {} at {}\", ident.robotname, ident.ver, host);", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5ODMzNg==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511398336", "bodyText": "This is also a way to tell the user that the robot is there but unsupported. This check comes from Roomba980Python, to tell the truth i don't even know why exactly it cannot be supported. Perhaps some protocol differences. Could be figured out if someone actually steps on it.\nIf you're insisting, tell me, i'll change.", "author": "Sonic-Amiga", "createdAt": "2020-10-24T11:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3NjYxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5OTgwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511399807", "bodyText": "I leave it up to you choosing debug or warn. In any case, info is slightly incorrect.", "author": "fwolter", "createdAt": "2020-10-24T11:10:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3NjYxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQyNjUwMw==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511426503", "bodyText": "warn because debug is disabled by default on user's side.", "author": "Sonic-Amiga", "createdAt": "2020-10-24T12:21:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3NjYxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3Njc5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510976792", "bodyText": "Can you add the representation property?", "author": "fwolter", "createdAt": "2020-10-23T15:46:36Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);\n+            }\n+        }\n+\n+        return addresses;\n+    }\n+\n+    private boolean receivePacketAndDiscover(DatagramSocket socket) {\n+        DatagramPacket incomingPacket;\n+\n+        try {\n+            incomingPacket = IdentProtocol.receiveResponse(socket);\n+        } catch (Exception e) {\n+            // This is not really an error, eventually we get a timeout\n+            // due to a loop in the caller\n+            return false;\n+        }\n+\n+        String host = incomingPacket.getAddress().toString().substring(1);\n+\n+        logger.debug(\"Received reply from {}\", host);\n+        logger.trace(\"{}\", new String(incomingPacket.getData()));\n+\n+        IdentProtocol.IdentData ident;\n+\n+        try {\n+            ident = IdentProtocol.decodeResponse(incomingPacket);\n+        } catch (JsonParseException e) {\n+            logger.error(\"Malformed IDENT reply from {}!\", host);\n+            return true;\n+        }\n+\n+        // This check comes from Roomba980-Python\n+        if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+            logger.info(\"Found unsupported iRobot \\\"{}\\\" version {} at {}\", ident.robotname, ident.ver, host);\n+            return true;\n+        }\n+\n+        if (ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+            ThingUID thingUID = new ThingUID(IRobotBindingConstants.THING_TYPE_ROOMBA, host.replace('.', '_'));\n+            DiscoveryResult result = DiscoveryResultBuilder.create(thingUID)\n+                    .withProperty(RoombaConfiguration.FIELD_IPADDRESS, host).withLabel(\"iRobot \" + ident.robotname)\n+                    .build();", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5ODQxNg==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511398416", "bodyText": "Sorry for dumb question, what is it ?", "author": "Sonic-Amiga", "createdAt": "2020-10-24T11:07:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3Njc5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQwMDY0MA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511400640", "bodyText": "See https://www.openhab.org/docs/developer/bindings/thing-xml.html#representation-property", "author": "fwolter", "createdAt": "2020-10-24T11:11:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3Njc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3ODEwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510978107", "bodyText": "You should specify the concrete exception you want to catch, since catching Exception catches also all runtime exceptions.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch (Exception e) {\n          \n          \n            \n                    } catch (IOException e) {", "author": "fwolter", "createdAt": "2020-10-23T15:48:48Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);\n+            }\n+        }\n+\n+        return addresses;\n+    }\n+\n+    private boolean receivePacketAndDiscover(DatagramSocket socket) {\n+        DatagramPacket incomingPacket;\n+\n+        try {\n+            incomingPacket = IdentProtocol.receiveResponse(socket);\n+        } catch (Exception e) {", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5NjAwOA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511396008", "bodyText": "I know, overlooked, sorrry", "author": "Sonic-Amiga", "createdAt": "2020-10-24T11:00:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3ODEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3OTE5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510979193", "bodyText": "Is there a reason why you don't use the scheduler of BaseThingHandler?", "author": "fwolter", "createdAt": "2020-10-23T15:50:34Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5OTM5OA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511399398", "bodyText": "Because i want to be sure that all the commands are serialized and come in order, and \"scheduler\" doesn't guarantee that, it can execute multiple requests in parallel in different threads. And i'm not sure if HiveMQ calls are reentrant.", "author": "Sonic-Amiga", "createdAt": "2020-10-24T11:09:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3OTE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3OTYwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510979605", "bodyText": "It's good practice to append the unit to the field name e.g. TIMEOUT_SEC.\nAlso, static fields should be all upper case.", "author": "fwolter", "createdAt": "2020-10-23T15:51:13Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5OTg0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511399848", "bodyText": "Enjoy", "author": "Sonic-Amiga", "createdAt": "2020-10-24T11:10:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3OTYwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3OTg2OA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510979868", "bodyText": "Syntactical sugar\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Hashtable<String, State> lastState = new Hashtable<String, State>();\n          \n          \n            \n                private Hashtable<String, State> lastState = new Hashtable<>();", "author": "fwolter", "createdAt": "2020-10-23T15:51:38Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MDEyMA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510980120", "bodyText": "Please use camelCase.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean auto_passes = true;\n          \n          \n            \n                private boolean autoPasses = true;", "author": "fwolter", "createdAt": "2020-10-23T15:52:02Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MDQzMg==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510980432", "bodyText": "This is already logged by the framework and could be removed.", "author": "fwolter", "createdAt": "2020-10-23T15:52:33Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MDU1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510980557", "bodyText": "See above.", "author": "fwolter", "createdAt": "2020-10-23T15:52:46Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MDc1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510980759", "bodyText": "Why is this executed asynchronously?", "author": "fwolter", "createdAt": "2020-10-23T15:53:08Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQwMTI4NA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511401284", "bodyText": "In order to run in the same thread where connect requests are handled, in order to avoid race conditions. Is it OK to call connection.stop() while connection.start() is running? I suggest the MQTT client would badly screw up\nPerhaps Java has a different view on it, then teach me please. I come from C world, and there this would be the right way to do things, if you don't know where initial requests come from.", "author": "Sonic-Amiga", "createdAt": "2020-10-24T11:13:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MDc1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwNDE4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512204181", "bodyText": "Invoking it asynchronsously doesn't prevent start() and stop() to be run concurrently. You could make the two methods synchronized in RoombaMqttBrokerConnection to achieve this.", "author": "fwolter", "createdAt": "2020-10-26T19:09:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MDc1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkxOTYzNg==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512919636", "bodyText": "How comes? They are called only from within singleThreadExecutor. It's supposed to be single thread, isn't it ?", "author": "Sonic-Amiga", "createdAt": "2020-10-27T18:09:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MDc1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYxMjg5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r515612896", "bodyText": "You're right, but spawning a thread only to achieve synchronization is a bit unreasonable. Bindings should only create new threads if necessary. In this case you could simply add the synchronized modifier to the methods you want to synchronize.", "author": "fwolter", "createdAt": "2020-11-01T11:58:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MDc1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgwNDQwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r520804409", "bodyText": "As far as i understand, scheduler provided by the base class does the same, but it can run more than one thread if it feels up to, as it doesn't guarantee any ordering of scheduled tasks. But OK, as you wish, here's your synchronized, let's learn some java :)", "author": "Sonic-Amiga", "createdAt": "2020-11-10T19:01:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MDc1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4Mjc2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510982767", "bodyText": "You could invoke equals() directly on command. No need to call toString().", "author": "fwolter", "createdAt": "2020-10-23T15:56:28Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQwMTQ4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511401489", "bodyText": "Thanks for hinting, i was not sure.", "author": "Sonic-Amiga", "createdAt": "2020-10-24T11:14:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4Mjc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQzMTAzMw==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511431033", "bodyText": "By the way, Eclipse starts complaining:\nUnlikely argument type for equals(): String seems to be unrelated to Command", "author": "Sonic-Amiga", "createdAt": "2020-10-24T12:33:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4Mjc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwODE1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512208151", "bodyText": "Yes, I see. But it's only an information, not a warning.\nYou could remove the instanceof check, too.", "author": "fwolter", "createdAt": "2020-10-26T19:16:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4Mjc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkyNDYyNw==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512924627", "bodyText": "Done", "author": "Sonic-Amiga", "createdAt": "2020-10-27T18:16:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4Mjc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MzQ3NA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510983474", "bodyText": "You could store the Gson object to a final member variable to save resources.", "author": "fwolter", "createdAt": "2020-10-23T15:57:37Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQwMTk1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511401955", "bodyText": "Is it thread-safe, just in case ?", "author": "Sonic-Amiga", "createdAt": "2020-10-24T11:15:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MzQ3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwNDczNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512204735", "bodyText": "Yes, it is.", "author": "fwolter", "createdAt": "2020-10-26T19:10:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MzQ3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MzY5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510983693", "bodyText": "See above. Logging to info.", "author": "fwolter", "createdAt": "2020-10-23T15:57:57Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQwMzE5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511403197", "bodyText": "Well, it is newly started connection, it is sparse, it will not flood. Are you insisting ?", "author": "Sonic-Amiga", "createdAt": "2020-10-24T11:18:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MzY5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwNjEwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512206107", "bodyText": "It isn't compliant to the coding guidelines, as a \"newly started component\" is very different from the initiation of a network connection. See https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-10-26T19:13:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MzY5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkyMTIzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512921239", "bodyText": "Ok, you're the Boss here. I hope it's OK to have debug level here.", "author": "Sonic-Amiga", "createdAt": "2020-10-27T18:11:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MzY5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NDkwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510984904", "bodyText": "Is it secure to write the password into the logs?", "author": "fwolter", "createdAt": "2020-10-23T15:59:54Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQwNDU3MA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511404570", "bodyText": "Well, it can be looked up in Thing configuration anyways.\nThis is not a password in traditional sense. It's not defined by the user, neither it can be changed. It is hardcoded inside the robot instead, and it is supposed to be discovered. The robot gives it away when a button on it is pressed. Official app also used this discovery algorithm. The password is considered \"technical\", it's not written anywhere in the manual, on some card or on the robot itself.\nBut OK, your wish...", "author": "Sonic-Amiga", "createdAt": "2020-10-24T11:21:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NDkwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwNjU2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512206565", "bodyText": "Just asking. It's up to you.", "author": "fwolter", "createdAt": "2020-10-26T19:14:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NDkwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkyMjc5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512922792", "bodyText": "Meanwhile removed :)", "author": "Sonic-Amiga", "createdAt": "2020-10-27T18:13:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NDkwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NTE1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510985152", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            error = e.toString();\n          \n          \n            \n                            error = e.getMessage();", "author": "fwolter", "createdAt": "2020-10-23T16:00:16Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);\n+\n+                // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+                connection = new RoombaMqttBrokerConnection(config.ipaddress, blid, this);\n+                connection.start(blid, config.password);\n+\n+            } catch (IOException e) {\n+                error = e.toString();", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NTM0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510985346", "bodyText": "The log message could be removed, as the status update is already logged by the framework.", "author": "fwolter", "createdAt": "2020-10-23T16:00:36Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);\n+\n+                // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+                connection = new RoombaMqttBrokerConnection(config.ipaddress, blid, this);\n+                connection.start(blid, config.password);\n+\n+            } catch (IOException e) {\n+                error = e.toString();\n+            }\n+\n+            if (error != null) {\n+                logger.error(error);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ3MDc2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511470767", "bodyText": "I'll still leave it under debug level, it has just helped me to find and debug one issue, and it could be used to resolve possible problems on user's side.\nThere seems to be a firmware quirk or bug in Roomba", "author": "Sonic-Amiga", "createdAt": "2020-10-24T14:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NTM0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwOTExMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512209111", "bodyText": "This is a redundant log message. The state change originated by updateStatus() is logged to events.log. Including the status detail message.", "author": "fwolter", "createdAt": "2020-10-26T19:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NTM0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkyNjI0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512926243", "bodyText": "Ok, removed, have fun.\nBy the way, what level do they use? I don't know because i never see them. At least on developer's console. But i muted a lot of stuff that deemed unrelated to me.", "author": "Sonic-Amiga", "createdAt": "2020-10-27T18:18:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NTM0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYxMjkwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r515612907", "bodyText": "Adding <logger name=\"smarthome.event.ThingStatusInfoChangedEvent\" level=\"INFO\" /> to logback.xml should make these visible.", "author": "fwolter", "createdAt": "2020-11-01T11:59:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NTM0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NjYzMw==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510986633", "bodyText": "Syntactical sugar.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    reconnectReq = scheduler.schedule(() -> {\n          \n          \n            \n                        connect();\n          \n          \n            \n                    }, reconnectDelay, TimeUnit.SECONDS);\n          \n          \n            \n                    reconnectReq = scheduler.schedule(this::connect, reconnectDelay, TimeUnit.SECONDS);", "author": "fwolter", "createdAt": "2020-10-23T16:02:48Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);\n+\n+                // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+                connection = new RoombaMqttBrokerConnection(config.ipaddress, blid, this);\n+                connection.start(blid, config.password);\n+\n+            } catch (IOException e) {\n+                error = e.toString();\n+            }\n+\n+            if (error != null) {\n+                logger.error(error);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                scheduleReconnect();\n+            }\n+        });\n+    }\n+\n+    private void scheduleReconnect() {\n+        reconnectReq = scheduler.schedule(() -> {\n+            connect();\n+        }, reconnectDelay, TimeUnit.SECONDS);", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4Njg5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510986892", "bodyText": "See above. Logging to error.", "author": "fwolter", "createdAt": "2020-10-23T16:03:16Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);\n+\n+                // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+                connection = new RoombaMqttBrokerConnection(config.ipaddress, blid, this);\n+                connection.start(blid, config.password);\n+\n+            } catch (IOException e) {\n+                error = e.toString();\n+            }\n+\n+            if (error != null) {\n+                logger.error(error);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                scheduleReconnect();\n+            }\n+        });\n+    }\n+\n+    private void scheduleReconnect() {\n+        reconnectReq = scheduler.schedule(() -> {\n+            connect();\n+        }, reconnectDelay, TimeUnit.SECONDS);\n+    }\n+\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public void onDisconnected(Throwable error) {\n+        String message = error.getMessage();\n+\n+        logger.error(\"MQTT connection failed: {}\", message);", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NzYxNA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510987614", "bodyText": "This could be moved into the catch block.", "author": "fwolter", "createdAt": "2020-10-23T16:04:35Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);\n+\n+                // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+                connection = new RoombaMqttBrokerConnection(config.ipaddress, blid, this);\n+                connection.start(blid, config.password);\n+\n+            } catch (IOException e) {\n+                error = e.toString();\n+            }\n+\n+            if (error != null) {", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4Nzk3OA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510987978", "bodyText": "See above. Store Gson to member.", "author": "fwolter", "createdAt": "2020-10-23T16:05:11Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);\n+\n+                // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+                connection = new RoombaMqttBrokerConnection(config.ipaddress, blid, this);\n+                connection.start(blid, config.password);\n+\n+            } catch (IOException e) {\n+                error = e.toString();\n+            }\n+\n+            if (error != null) {\n+                logger.error(error);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                scheduleReconnect();\n+            }\n+        });\n+    }\n+\n+    private void scheduleReconnect() {\n+        reconnectReq = scheduler.schedule(() -> {\n+            connect();\n+        }, reconnectDelay, TimeUnit.SECONDS);\n+    }\n+\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public void onDisconnected(Throwable error) {\n+        String message = error.getMessage();\n+\n+        logger.error(\"MQTT connection failed: {}\", message);\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+        scheduleReconnect();\n+    }\n+\n+    public void processMessage(String topic, byte[] payload) {\n+        String jsonStr = new String(payload);\n+        MQTTProtocol.StateMessage msg;\n+\n+        logger.trace(\"Got topic {} data {}\", topic, jsonStr);\n+\n+        try {\n+            // We are not consuming all the fields, so we have to create the reader explicitly\n+            // If we use fromJson(String) or fromJson(java.util.reader), it will throw\n+            // \"JSON not fully consumed\" exception, because not all the reader's content has been\n+            // used up. We want to avoid that also for compatibility reasons because newer iRobot\n+            // versions may add fields.\n+            JsonReader jsonReader = new JsonReader(new StringReader(jsonStr));\n+            msg = new Gson().fromJson(jsonReader, IdentData.class);", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4ODMwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510988304", "bodyText": "See above logging to error.", "author": "fwolter", "createdAt": "2020-10-23T16:05:42Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);\n+\n+                // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+                connection = new RoombaMqttBrokerConnection(config.ipaddress, blid, this);\n+                connection.start(blid, config.password);\n+\n+            } catch (IOException e) {\n+                error = e.toString();\n+            }\n+\n+            if (error != null) {\n+                logger.error(error);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                scheduleReconnect();\n+            }\n+        });\n+    }\n+\n+    private void scheduleReconnect() {\n+        reconnectReq = scheduler.schedule(() -> {\n+            connect();\n+        }, reconnectDelay, TimeUnit.SECONDS);\n+    }\n+\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public void onDisconnected(Throwable error) {\n+        String message = error.getMessage();\n+\n+        logger.error(\"MQTT connection failed: {}\", message);\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+        scheduleReconnect();\n+    }\n+\n+    public void processMessage(String topic, byte[] payload) {\n+        String jsonStr = new String(payload);\n+        MQTTProtocol.StateMessage msg;\n+\n+        logger.trace(\"Got topic {} data {}\", topic, jsonStr);\n+\n+        try {\n+            // We are not consuming all the fields, so we have to create the reader explicitly\n+            // If we use fromJson(String) or fromJson(java.util.reader), it will throw\n+            // \"JSON not fully consumed\" exception, because not all the reader's content has been\n+            // used up. We want to avoid that also for compatibility reasons because newer iRobot\n+            // versions may add fields.\n+            JsonReader jsonReader = new JsonReader(new StringReader(jsonStr));\n+            msg = new Gson().fromJson(jsonReader, IdentData.class);\n+        } catch (JsonParseException e) {\n+            logger.error(\"Failed to parse JSON message from {}: {}\", config.ipaddress, e.toString());\n+            logger.error(\"Raw contents: {}\", payload);", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4OTY2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510989669", "bodyText": "What's the purpose of this method?", "author": "fwolter", "createdAt": "2020-10-23T16:07:55Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/IRobotHandlerFactory.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.THING_TYPE_ROOMBA;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.handler.RoombaHandler;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link IRobotHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - rename and update\n+ */\n+@Component(configurationPid = \"binding.irobot\", service = ThingHandlerFactory.class)\n+@NonNullByDefault\n+public class IRobotHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final static Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_ROOMBA);\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Activate\n+    protected void activate(ComponentContext componentContext, Map<String, Object> config) {\n+        super.activate(componentContext);\n+    }", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQwOTc3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511409779", "bodyText": "I don't remember. :) Probably i was puzzled by the fact that superclass' method has only one argument and subclass' one apparently has two. I have no idea how OSGi figures out what to supply. To me OSGi is a huge magical pandora's box, unbelievably badly documented. Their main page starts with some enterprise blather,  They have a \"Developer\" page, on attempt to download anything they ask me to fill in my personal data and subscribe to god knows what and why. And simple entering \"@activate\" in the search box in the header yields \"Not found\".\nSo i don't know how to navigate their docs, sorry for that.\nOr may be i just don't know what a Java annotation really is and how it maps to some classes / objects / whatever\nAnyways, removed.", "author": "Sonic-Amiga", "createdAt": "2020-10-24T11:33:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4OTY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5MDU1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510990559", "bodyText": "See above. Gson object.", "author": "fwolter", "createdAt": "2020-10-23T16:09:35Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/IdentProtocol.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * iRobot discovery and identification protocol\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+public class IdentProtocol {\n+\n+    private static final String UDP_PACKET_CONTENTS = \"irobotmcs\";\n+    private static final int REMOTE_UDP_PORT = 5678;\n+\n+    public static DatagramSocket sendRequest(InetAddress host) throws IOException {\n+        DatagramSocket socket = new DatagramSocket();\n+\n+        socket.setBroadcast(true);\n+        socket.setReuseAddress(true);\n+\n+        byte[] packetContents = UDP_PACKET_CONTENTS.getBytes(StandardCharsets.UTF_8);\n+        DatagramPacket packet = new DatagramPacket(packetContents, packetContents.length, host, REMOTE_UDP_PORT);\n+\n+        socket.send(packet);\n+        return socket;\n+    }\n+\n+    public static DatagramPacket receiveResponse(DatagramSocket socket) throws IOException {\n+        byte[] buffer = new byte[1024];\n+        DatagramPacket incomingPacket = new DatagramPacket(buffer, buffer.length);\n+\n+        socket.setSoTimeout(1000 /* one second */);\n+        socket.receive(incomingPacket);\n+\n+        return incomingPacket;\n+    }\n+\n+    public static IdentData decodeResponse(DatagramPacket packet) throws JsonParseException, ClassCastException {\n+        /*\n+         * packet is a JSON of the following contents (addresses are undisclosed):\n+         * @formatter:off\n+         * {\n+         *   \"ver\":\"3\",\n+         *   \"hostname\":\"Roomba-3168820480607740\",\n+         *   \"robotname\":\"Roomba\",\n+         *   \"ip\":\"XXX.XXX.XXX.XXX\",\n+         *   \"mac\":\"XX:XX:XX:XX:XX:XX\",\n+         *   \"sw\":\"v2.4.6-3\",\n+         *   \"sku\":\"R981040\",\n+         *   \"nc\":0,\n+         *   \"proto\":\"mqtt\",\n+         *   \"cap\":{\n+         *     \"pose\":1,\n+         *     \"ota\":2,\n+         *     \"multiPass\":2,\n+         *     \"carpetBoost\":1,\n+         *     \"pp\":1,\n+         *     \"binFullDetect\":1,\n+         *     \"langOta\":1,\n+         *     \"maps\":1,\n+         *     \"edge\":1,\n+         *     \"eco\":1,\n+         *     \"svcConf\":1\n+         *   }\n+         * }\n+         * @formatter:on\n+         */\n+        String reply = new String(packet.getData());\n+        // We are not consuming all the fields, so we have to create the reader explicitly\n+        // If we use fromJson(String) or fromJson(java.util.reader), it will throw\n+        // \"JSON not fully consumed\" exception, because not all the reader's content has been\n+        // used up. We want to avoid that for compatibility reasons because newer iRobot versions\n+        // may add fields.\n+        JsonReader jsonReader = new JsonReader(new StringReader(reply));\n+        IdentData data = new Gson().fromJson(jsonReader, IdentData.class);", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5MTI0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510991241", "bodyText": "What is throwing a ClassCastException here?", "author": "fwolter", "createdAt": "2020-10-23T16:10:45Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/IdentProtocol.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * iRobot discovery and identification protocol\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+public class IdentProtocol {\n+\n+    private static final String UDP_PACKET_CONTENTS = \"irobotmcs\";\n+    private static final int REMOTE_UDP_PORT = 5678;\n+\n+    public static DatagramSocket sendRequest(InetAddress host) throws IOException {\n+        DatagramSocket socket = new DatagramSocket();\n+\n+        socket.setBroadcast(true);\n+        socket.setReuseAddress(true);\n+\n+        byte[] packetContents = UDP_PACKET_CONTENTS.getBytes(StandardCharsets.UTF_8);\n+        DatagramPacket packet = new DatagramPacket(packetContents, packetContents.length, host, REMOTE_UDP_PORT);\n+\n+        socket.send(packet);\n+        return socket;\n+    }\n+\n+    public static DatagramPacket receiveResponse(DatagramSocket socket) throws IOException {\n+        byte[] buffer = new byte[1024];\n+        DatagramPacket incomingPacket = new DatagramPacket(buffer, buffer.length);\n+\n+        socket.setSoTimeout(1000 /* one second */);\n+        socket.receive(incomingPacket);\n+\n+        return incomingPacket;\n+    }\n+\n+    public static IdentData decodeResponse(DatagramPacket packet) throws JsonParseException, ClassCastException {", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQwOTkzMw==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511409933", "bodyText": "Old version of the parser, which doesn't exist any more. :) Thanks for pointing out.", "author": "Sonic-Amiga", "createdAt": "2020-10-24T11:34:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5MTI0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5MTM2NA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510991364", "bodyText": "Can you specify the encoding you expect? E.g. StandardCharsets.UTF_8", "author": "fwolter", "createdAt": "2020-10-23T16:10:56Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/IdentProtocol.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * iRobot discovery and identification protocol\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+public class IdentProtocol {\n+\n+    private static final String UDP_PACKET_CONTENTS = \"irobotmcs\";\n+    private static final int REMOTE_UDP_PORT = 5678;\n+\n+    public static DatagramSocket sendRequest(InetAddress host) throws IOException {\n+        DatagramSocket socket = new DatagramSocket();\n+\n+        socket.setBroadcast(true);\n+        socket.setReuseAddress(true);\n+\n+        byte[] packetContents = UDP_PACKET_CONTENTS.getBytes(StandardCharsets.UTF_8);\n+        DatagramPacket packet = new DatagramPacket(packetContents, packetContents.length, host, REMOTE_UDP_PORT);\n+\n+        socket.send(packet);\n+        return socket;\n+    }\n+\n+    public static DatagramPacket receiveResponse(DatagramSocket socket) throws IOException {\n+        byte[] buffer = new byte[1024];\n+        DatagramPacket incomingPacket = new DatagramPacket(buffer, buffer.length);\n+\n+        socket.setSoTimeout(1000 /* one second */);\n+        socket.receive(incomingPacket);\n+\n+        return incomingPacket;\n+    }\n+\n+    public static IdentData decodeResponse(DatagramPacket packet) throws JsonParseException, ClassCastException {\n+        /*\n+         * packet is a JSON of the following contents (addresses are undisclosed):\n+         * @formatter:off\n+         * {\n+         *   \"ver\":\"3\",\n+         *   \"hostname\":\"Roomba-3168820480607740\",\n+         *   \"robotname\":\"Roomba\",\n+         *   \"ip\":\"XXX.XXX.XXX.XXX\",\n+         *   \"mac\":\"XX:XX:XX:XX:XX:XX\",\n+         *   \"sw\":\"v2.4.6-3\",\n+         *   \"sku\":\"R981040\",\n+         *   \"nc\":0,\n+         *   \"proto\":\"mqtt\",\n+         *   \"cap\":{\n+         *     \"pose\":1,\n+         *     \"ota\":2,\n+         *     \"multiPass\":2,\n+         *     \"carpetBoost\":1,\n+         *     \"pp\":1,\n+         *     \"binFullDetect\":1,\n+         *     \"langOta\":1,\n+         *     \"maps\":1,\n+         *     \"edge\":1,\n+         *     \"eco\":1,\n+         *     \"svcConf\":1\n+         *   }\n+         * }\n+         * @formatter:on\n+         */\n+        String reply = new String(packet.getData());\n+        // We are not consuming all the fields, so we have to create the reader explicitly\n+        // If we use fromJson(String) or fromJson(java.util.reader), it will throw\n+        // \"JSON not fully consumed\" exception, because not all the reader's content has been\n+        // used up. We want to avoid that for compatibility reasons because newer iRobot versions\n+        // may add fields.\n+        JsonReader jsonReader = new JsonReader(new StringReader(reply));", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQxMjk4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511412981", "bodyText": "Done", "author": "Sonic-Amiga", "createdAt": "2020-10-24T11:42:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5MTM2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5MjUwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510992507", "bodyText": "See above. Encoding.", "author": "fwolter", "createdAt": "2020-10-23T16:12:54Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/RawMQTT.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * A \"raw MQTT\" client for sending custom \"get password\" request.\n+ * Seems pretty much reinventing a bicycle, but it looks like HiveMq\n+ * doesn't provide for sending and receiving custom packets.\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class RawMQTT {\n+    public static final int ROOMBA_MQTT_PORT = 8883;\n+\n+    private Socket socket;\n+\n+    public static class Packet {\n+        public byte message;\n+        public byte[] payload;\n+\n+        Packet(byte msg, byte[] data) {\n+            message = msg;\n+            payload = data;\n+        }\n+\n+        public boolean isValidPasswdPacket() {\n+            return message == PasswdPacket.MESSAGE && payload.length >= PasswdPacket.HEADER_SIZE;\n+        }\n+    };\n+\n+    public static class PasswdPacket extends Packet {\n+        static final byte MESSAGE = (byte) 0xF0; // MQTT Reserved\n+        static final int MAGIC = 0x293bccef;\n+        static final byte HEADER_SIZE = 5;\n+        private ByteBuffer buffer;\n+\n+        public PasswdPacket(Packet raw) {\n+            super(raw.message, raw.payload);\n+            buffer = ByteBuffer.wrap(payload).order(ByteOrder.LITTLE_ENDIAN);\n+        }\n+\n+        public int getMagic() {\n+            return buffer.getInt(0);\n+        }\n+\n+        public byte getStatus() {\n+            return buffer.get(4);\n+        }\n+\n+        public @Nullable String getPassword() {\n+            if (getStatus() != 0) {\n+                return null;\n+            }\n+\n+            int length = payload.length - HEADER_SIZE;\n+            byte[] passwd = new byte[length];\n+\n+            buffer.position(HEADER_SIZE);\n+            buffer.get(passwd);\n+\n+            return new String(passwd);", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5Mjg2NA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510992864", "bodyText": "Can you do this or remove the comment?", "author": "fwolter", "createdAt": "2020-10-23T16:13:29Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/RawMQTT.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * A \"raw MQTT\" client for sending custom \"get password\" request.\n+ * Seems pretty much reinventing a bicycle, but it looks like HiveMq\n+ * doesn't provide for sending and receiving custom packets.\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class RawMQTT {\n+    public static final int ROOMBA_MQTT_PORT = 8883;\n+\n+    private Socket socket;\n+\n+    public static class Packet {\n+        public byte message;\n+        public byte[] payload;\n+\n+        Packet(byte msg, byte[] data) {\n+            message = msg;\n+            payload = data;\n+        }\n+\n+        public boolean isValidPasswdPacket() {\n+            return message == PasswdPacket.MESSAGE && payload.length >= PasswdPacket.HEADER_SIZE;\n+        }\n+    };\n+\n+    public static class PasswdPacket extends Packet {\n+        static final byte MESSAGE = (byte) 0xF0; // MQTT Reserved\n+        static final int MAGIC = 0x293bccef;\n+        static final byte HEADER_SIZE = 5;\n+        private ByteBuffer buffer;\n+\n+        public PasswdPacket(Packet raw) {\n+            super(raw.message, raw.payload);\n+            buffer = ByteBuffer.wrap(payload).order(ByteOrder.LITTLE_ENDIAN);\n+        }\n+\n+        public int getMagic() {\n+            return buffer.getInt(0);\n+        }\n+\n+        public byte getStatus() {\n+            return buffer.get(4);\n+        }\n+\n+        public @Nullable String getPassword() {\n+            if (getStatus() != 0) {\n+                return null;\n+            }\n+\n+            int length = payload.length - HEADER_SIZE;\n+            byte[] passwd = new byte[length];\n+\n+            buffer.position(HEADER_SIZE);\n+            buffer.get(passwd);\n+\n+            return new String(passwd);\n+        }\n+    }\n+\n+    // Roomba MQTT is using SSL with custom root CA certificate.\n+    private static class MQTTTrustManager implements X509TrustManager {\n+        @Override\n+        public X509Certificate @Nullable [] getAcceptedIssuers() {\n+            return null;\n+        }\n+\n+        @Override\n+        public void checkClientTrusted(X509Certificate @Nullable [] arg0, @Nullable String arg1)\n+                throws CertificateException {\n+        }\n+\n+        @Override\n+        public void checkServerTrusted(X509Certificate @Nullable [] certs, @Nullable String authMethod)\n+                throws CertificateException {\n+            /*\n+             * TODO: Retrieve Roomba CA certificate and implement proper verification\n+             * logger.debug(\"Auth method: \" + authMethod);\n+             * for (X509Certificate cert : certs) {\n+             * logger.debug(\"Cert: \" + cert.toString());\n+             * }\n+             */", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQxNDE4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511414187", "bodyText": "Removed. It would take significant time to do it. Perhaps need to reverse engineer smartphone's app built-in check", "author": "Sonic-Amiga", "createdAt": "2020-10-24T11:45:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5Mjg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NDAwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510994009", "bodyText": "Please add the NonNullByDefault annotation.", "author": "fwolter", "createdAt": "2020-10-23T16:15:28Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/roomba/RoombaConfiguration.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.roomba;\n+\n+/**\n+ * Roomba Thing configuration\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+public class RoombaConfiguration {", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQxNjUwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511416504", "bodyText": "The official doc says that these are not mandatory for data-only classes like config. But enjoy.", "author": "Sonic-Amiga", "createdAt": "2020-10-24T11:52:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NDAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NDM5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510994390", "bodyText": "The Configuration class should only contain members that are part of the config.", "author": "fwolter", "createdAt": "2020-10-23T16:16:09Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/roomba/RoombaConfiguration.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.roomba;\n+\n+/**\n+ * Roomba Thing configuration\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+public class RoombaConfiguration {\n+    public static String FIELD_IPADDRESS = \"ipaddress\";\n+    public static String FIELD_PASSWORD = \"password\";", "originalCommit": "e9674556c16225cbbe635a06414cbf94eda1ea4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQxNTY5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511415696", "bodyText": "Some API calls refer to names of config fields in string form, i thought it would be very logical and convenient to have them here. But enjoy.", "author": "Sonic-Amiga", "createdAt": "2020-10-24T11:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NDM5MA=="}], "type": "inlineReview"}, {"oid": "336828c7004cc7555e8c6f11ffd5c3f0760fa4cc", "url": "https://github.com/openhab/openhab-addons/commit/336828c7004cc7555e8c6f11ffd5c3f0760fa4cc", "message": "[irobot] iRobot binding\n\nSupports iRobot Roomba and probably some other iRobots (in parts where they\nare compatible)\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-10-24T14:49:27Z", "type": "forcePushed"}, {"oid": "d8d060ba8abb82bb3531f1d274784cba0c603ae9", "url": "https://github.com/openhab/openhab-addons/commit/d8d060ba8abb82bb3531f1d274784cba0c603ae9", "message": "[irobot] iRobot binding\n\nSupports iRobot Roomba and probably some other iRobots (in parts where they\nare compatible)\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-10-24T15:06:49Z", "type": "forcePushed"}, {"oid": "12d1bc627f38ece34b5c0c2b3390787e69ad0cfd", "url": "https://github.com/openhab/openhab-addons/commit/12d1bc627f38ece34b5c0c2b3390787e69ad0cfd", "message": "[irobot] iRobot binding\n\nSupports iRobot Roomba and probably some other iRobots (in parts where they\nare compatible)\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-10-27T18:20:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgyMzM5NA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r518823394", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = DiscoveryService.class)\n          \n          \n            \n            @Component(service = DiscoveryService.class, configurationPid = \"discovery.irobot\")", "author": "fwolter", "createdAt": "2020-11-06T15:25:16Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobots\n+ *\n+ * @author Pavel Fedin - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)", "originalCommit": "12d1bc627f38ece34b5c0c2b3390787e69ad0cfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0180007cd7a889dd7b3a3444147efe255c656354", "url": "https://github.com/openhab/openhab-addons/commit/0180007cd7a889dd7b3a3444147efe255c656354", "message": "[irobot] iRobot binding\n\nSupports iRobot Roomba and probably some other iRobots (in parts where they\nare compatible)\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-11-10T19:05:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzczODA3MA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r523738070", "bodyText": "This sould be warn. You could also throw an unchecked exception like IllegalStateException if it's strange this would happen.", "author": "fwolter", "createdAt": "2020-11-15T10:17:12Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -503,4 +529,49 @@ private void reportProperty(String property, @Nullable String value) {\n             updateProperty(property, value);\n         }\n     }\n+\n+    @Override\n+    public void connectionStateChanged(MqttConnectionState state, @Nullable Throwable error) {\n+        if (state == MqttConnectionState.CONNECTED) {\n+            MqttBrokerConnection connection = this.connection;\n+\n+            if (connection == null) {\n+                // This would be very strange, but Eclipse forces us to do the check\n+                logger.error(\"Established connection without broker pointer\");\n+                return;", "originalCommit": "4657b930609f82d8ce25bb94ccb32b9c8c9eb7a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2MDQyNA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r525360424", "bodyText": "Done", "author": "Sonic-Amiga", "createdAt": "2020-11-17T17:45:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzczODA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzczODA5NA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r523738094", "bodyText": "This is already logged by the framework and could be removed.", "author": "fwolter", "createdAt": "2020-11-15T10:17:34Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -503,4 +529,49 @@ private void reportProperty(String property, @Nullable String value) {\n             updateProperty(property, value);\n         }\n     }\n+\n+    @Override\n+    public void connectionStateChanged(MqttConnectionState state, @Nullable Throwable error) {\n+        if (state == MqttConnectionState.CONNECTED) {\n+            MqttBrokerConnection connection = this.connection;\n+\n+            if (connection == null) {\n+                // This would be very strange, but Eclipse forces us to do the check\n+                logger.error(\"Established connection without broker pointer\");\n+                return;\n+            }\n+\n+            logger.debug(\"Connection established\");", "originalCommit": "4657b930609f82d8ce25bb94ccb32b9c8c9eb7a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2MDY1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r525360654", "bodyText": "Forgot, sorry", "author": "Sonic-Amiga", "createdAt": "2020-11-17T17:46:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzczODA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzczODEwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r523738104", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-11-15T10:17:53Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -503,4 +529,49 @@ private void reportProperty(String property, @Nullable String value) {\n             updateProperty(property, value);\n         }\n     }\n+\n+    @Override\n+    public void connectionStateChanged(MqttConnectionState state, @Nullable Throwable error) {\n+        if (state == MqttConnectionState.CONNECTED) {\n+            MqttBrokerConnection connection = this.connection;\n+\n+            if (connection == null) {\n+                // This would be very strange, but Eclipse forces us to do the check\n+                logger.error(\"Established connection without broker pointer\");\n+                return;\n+            }\n+\n+            logger.debug(\"Connection established\");\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            // Roomba sends us two topics:\n+            // \"wifistat\" - reports singnal strength and current robot position\n+            // \"$aws/things/<BLID>/shadow/update\" - the rest of messages\n+            // Subscribe to everything since we're interested in both\n+            connection.subscribe(\"#\", this).exceptionally(e -> {\n+                logger.warn(\"MQTT subscription failed: {}\", e.getMessage());\n+                return false;\n+            }).thenAccept(v -> {\n+                if (!v) {\n+                    logger.warn(\"Subscription timeout\");\n+                } else {\n+                    logger.trace(\"Subscription done\");\n+                }\n+            });\n+\n+        } else {\n+            // channelStateByChannelUID.values().forEach(c -> c.stop());", "originalCommit": "4657b930609f82d8ce25bb94ccb32b9c8c9eb7a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2MTM4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r525361386", "bodyText": "Yep, overlook, thanks", "author": "Sonic-Amiga", "createdAt": "2020-11-17T17:47:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzczODEwNA=="}], "type": "inlineReview"}, {"oid": "38e4469938e548437db8ccdab906544545c70c9d", "url": "https://github.com/openhab/openhab-addons/commit/38e4469938e548437db8ccdab906544545c70c9d", "message": "[irobot] Drop custom hivemq wrapper\n\nsetUnsubscribeOnStop() has been introduced in\norg.openhab.core.io.transport.mqtt.MqttBrokerConnection, so it can now handle\niRobot's quirks. The custom wrapper is no more needed, remove it\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>", "committedDate": "2020-11-17T17:49:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzNTM2MA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r527135360", "bodyText": "Please see all others.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n          \n          \n            \n             * @author Pavel Fedin - Rewrite for 900 series", "author": "fwolter", "createdAt": "2020-11-19T19:15:46Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.io.transport.mqtt.MqttBrokerConnection;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionObserver;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionState;\n+import org.openhab.core.io.transport.mqtt.MqttMessageSubscriber;\n+import org.openhab.core.io.transport.mqtt.reconnect.PeriodicReconnectStrategy;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series", "originalCommit": "38e4469938e548437db8ccdab906544545c70c9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4NTY3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r530585672", "bodyText": "Done", "author": "Sonic-Amiga", "createdAt": "2020-11-25T18:58:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzNTM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzNzc0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r527137746", "bodyText": "Please use camelCase.", "author": "fwolter", "createdAt": "2020-11-19T19:19:50Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.io.transport.mqtt.MqttBrokerConnection;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionObserver;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionState;\n+import org.openhab.core.io.transport.mqtt.MqttMessageSubscriber;\n+import org.openhab.core.io.transport.mqtt.reconnect.PeriodicReconnectStrategy;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler implements MqttConnectionObserver, MqttMessageSubscriber {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final Gson gson = new Gson();\n+    private static final int RECONNECT_DELAY_SEC = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable MqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean autoPasses = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;", "originalCommit": "38e4469938e548437db8ccdab906544545c70c9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4NTczMg==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r530585732", "bodyText": "Yep", "author": "Sonic-Amiga", "createdAt": "2020-11-25T18:59:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzNzc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE1ODk5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r527158990", "bodyText": "The compiler warning can be avoided by storing the reference to a local variable and do the null check on that. Same for below.", "author": "fwolter", "createdAt": "2020-11-19T19:55:02Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.io.transport.mqtt.MqttBrokerConnection;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionObserver;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionState;\n+import org.openhab.core.io.transport.mqtt.MqttMessageSubscriber;\n+import org.openhab.core.io.transport.mqtt.reconnect.PeriodicReconnectStrategy;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler implements MqttConnectionObserver, MqttMessageSubscriber {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final Gson gson = new Gson();\n+    private static final int RECONNECT_DELAY_SEC = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable MqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean autoPasses = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            connect();\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        scheduler.execute(() -> {\n+            disconnect();\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            sendDelta(new MQTTProtocol.PowerBoost(command.equals(BOOST_AUTO), command.equals(BOOST_PERFORMANCE)));\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            sendDelta(new MQTTProtocol.CleanPasses(!command.equals(PASSES_AUTO), command.equals(PASSES_2)));\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        MqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = gson.toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            // 1 here actually corresponds to MQTT qos 0 (AT_MOST_ONCE). Only this value is accepted\n+            // by Roomba, others just cause it to reject the command and drop the connection.\n+            conn.publish(request.getTopic(), json.getBytes(), 1, false);\n+        }\n+    }\n+\n+    // In order not to mess up our connection state we need to make sure\n+    // that connect() and disconnect() are never running concurrently, so\n+    // they are synchronized\n+    private synchronized void connect() {\n+        logger.debug(\"Connecting to {}\", config.ipaddress);\n+\n+        try {\n+            InetAddress host = InetAddress.getByName(config.ipaddress);\n+            String blid = this.blid;\n+\n+            if (blid == null) {\n+                DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                IdentProtocol.IdentData ident;\n+\n+                identSocket.close();\n+\n+                try {\n+                    ident = IdentProtocol.decodeResponse(identPacket);\n+                } catch (JsonParseException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Malformed IDENT response\");\n+                    return;\n+                }\n+\n+                if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Unsupported version \" + ident.ver);\n+                    return;\n+                }\n+\n+                if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Not a Roomba: \" + ident.product);\n+                    return;\n+                }\n+\n+                blid = ident.blid;\n+                this.blid = blid;\n+            }\n+\n+            logger.debug(\"BLID is: {}\", blid);\n+\n+            if (config.password.isEmpty()) {\n+                RawMQTT mqtt;\n+\n+                try {\n+                    mqtt = new RawMQTT(host, 8883);\n+                } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                    return; // This is internal system error, no retry\n+                }\n+\n+                mqtt.requestPassword();\n+                RawMQTT.Packet response = mqtt.readPacket();\n+                mqtt.close();\n+\n+                if (response != null && response.isValidPasswdPacket()) {\n+                    RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+                    String password = passwdPacket.getPassword();\n+\n+                    if (password != null) {\n+                        config.password = password;\n+\n+                        Configuration configuration = editConfiguration();\n+\n+                        configuration.put(\"password\", password);\n+                        updateConfiguration(configuration);\n+\n+                        logger.debug(\"Password successfully retrieved\");\n+                    }\n+                }\n+            }\n+\n+            if (config.password.isEmpty()) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                        \"Authentication on the robot is required\");\n+                scheduleReconnect();\n+                return;\n+            }\n+\n+            // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+            MqttBrokerConnection connection = new MqttBrokerConnection(config.ipaddress, RawMQTT.ROOMBA_MQTT_PORT, true,\n+                    blid);\n+\n+            this.connection = connection;\n+\n+            // Disable sending UNSUBSCRIBE request before disconnecting becuase Roomba doesn't like it.\n+            // It just swallows the request and never sends any response, so stop() method never completes.\n+            connection.setUnsubscribeOnStop(false);\n+            connection.setCredentials(blid, config.password);\n+            connection.setTrustManagers(RawMQTT.getTrustManagers());\n+            // 1 here actually corresponds to MQTT qos 0 (AT_MOST_ONCE). Only this value is accepted\n+            // by Roomba, others just cause it to reject the command and drop the connection.\n+            connection.setQos(1);\n+            // MQTT connection reconnects itself, so we don't have to call scheduleReconnect()\n+            // when it breaks. Just set the period in ms.\n+            connection.setReconnectStrategy(\n+                    new PeriodicReconnectStrategy(RECONNECT_DELAY_SEC * 1000, RECONNECT_DELAY_SEC * 1000));\n+            connection.start().exceptionally(e -> {\n+                connectionStateChanged(MqttConnectionState.DISCONNECTED, e);\n+                return false;\n+            }).thenAccept(v -> {\n+                if (!v) {\n+                    connectionStateChanged(MqttConnectionState.DISCONNECTED, new TimeoutException(\"Timeout\"));\n+                } else {\n+                    connectionStateChanged(MqttConnectionState.CONNECTED, null);\n+                }\n+            });\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            scheduleReconnect();\n+        }\n+    }\n+\n+    private synchronized void disconnect() {\n+        if (reconnectReq != null) {\n+            reconnectReq.cancel(false);", "originalCommit": "38e4469938e548437db8ccdab906544545c70c9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4NTgwOA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r530585808", "bodyText": "ACK", "author": "Sonic-Amiga", "createdAt": "2020-11-25T18:59:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE1ODk5MA=="}], "type": "inlineReview"}, {"oid": "09c40515b9036262a8982bfaf47f70740b4e49a2", "url": "https://github.com/openhab/openhab-addons/commit/09c40515b9036262a8982bfaf47f70740b4e49a2", "message": "[irobot] Drop custom hivemq wrapper\n\nsetUnsubscribeOnStop() has been introduced in\norg.openhab.core.io.transport.mqtt.MqttBrokerConnection, so it can now handle\niRobot's quirks. The custom wrapper is no more needed, remove it\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>", "committedDate": "2020-11-25T19:05:08Z", "type": "forcePushed"}, {"oid": "4aa3023158e1986e2bd0a015c11f9c108876486e", "url": "https://github.com/openhab/openhab-addons/commit/4aa3023158e1986e2bd0a015c11f9c108876486e", "message": "[irobot] Drop custom hivemq wrapper\n\nsetUnsubscribeOnStop() has been introduced in\norg.openhab.core.io.transport.mqtt.MqttBrokerConnection, so it can now handle\niRobot's quirks. The custom wrapper is no more needed, remove it\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>", "committedDate": "2020-11-26T18:18:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE4NTExNA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r531185114", "bodyText": "The SAT check complains about the order of the modifiers.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public final static ThingTypeUID THING_TYPE_ROOMBA = new ThingTypeUID(BINDING_ID, \"roomba\");\n          \n          \n            \n                public static final ThingTypeUID THING_TYPE_ROOMBA = new ThingTypeUID(BINDING_ID, \"roomba\");", "author": "fwolter", "createdAt": "2020-11-26T18:38:20Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/IRobotBindingConstants.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link VacuumBinding} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ */\n+public class IRobotBindingConstants {\n+\n+    public static final String BINDING_ID = \"irobot\";\n+\n+    // List of all Thing Type UIDs\n+    public final static ThingTypeUID THING_TYPE_ROOMBA = new ThingTypeUID(BINDING_ID, \"roomba\");", "originalCommit": "4aa3023158e1986e2bd0a015c11f9c108876486e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7c151658d2d58e8306a315f18c13a3b6aa15fa5f", "url": "https://github.com/openhab/openhab-addons/commit/7c151658d2d58e8306a315f18c13a3b6aa15fa5f", "message": "[irobot] Drop custom hivemq wrapper\n\nsetUnsubscribeOnStop() has been introduced in\norg.openhab.core.io.transport.mqtt.MqttBrokerConnection, so it can now handle\niRobot's quirks. The custom wrapper is no more needed, remove it\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>", "committedDate": "2020-11-27T21:39:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NDk2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r532154961", "bodyText": "You should close the socket when you are done with it. An easy way to do this is to define the socket variable in a try-with-resources statement.", "author": "cpmeister", "createdAt": "2020-11-29T04:46:20Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobots\n+ *\n+ * @author Pavel Fedin - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.irobot\")\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);", "originalCommit": "7c151658d2d58e8306a315f18c13a3b6aa15fa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NTEzNA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r532155134", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    scheduler.execute(() -> {\n          \n          \n            \n                        disconnect();\n          \n          \n            \n                    });\n          \n          \n            \n                    scheduler.execute(this::disconnect);", "author": "cpmeister", "createdAt": "2020-11-29T04:48:50Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal.handler;\n+\n+import static org.openhab.binding.irobot.internal.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.internal.RoombaConfiguration;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.io.transport.mqtt.MqttBrokerConnection;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionObserver;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionState;\n+import org.openhab.core.io.transport.mqtt.MqttMessageSubscriber;\n+import org.openhab.core.io.transport.mqtt.reconnect.PeriodicReconnectStrategy;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler implements MqttConnectionObserver, MqttMessageSubscriber {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final Gson gson = new Gson();\n+    private static final int RECONNECT_DELAY_SEC = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable MqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean autoPasses = true;\n+    private @Nullable Boolean twoPasses = null;\n+    private boolean carpetBoost = true;\n+    private @Nullable Boolean vacHigh = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            connect();\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        scheduler.execute(() -> {\n+            disconnect();\n+        });", "originalCommit": "7c151658d2d58e8306a315f18c13a3b6aa15fa5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM2MjA3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r533362073", "bodyText": "Done", "author": "Sonic-Amiga", "createdAt": "2020-12-01T12:11:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NTEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NTE1MA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r532155150", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    scheduler.execute(() -> {\n          \n          \n            \n                        connect();\n          \n          \n            \n                    });\n          \n          \n            \n                    scheduler.execute(this::connect);", "author": "cpmeister", "createdAt": "2020-11-29T04:49:07Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal.handler;\n+\n+import static org.openhab.binding.irobot.internal.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.internal.RoombaConfiguration;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.io.transport.mqtt.MqttBrokerConnection;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionObserver;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionState;\n+import org.openhab.core.io.transport.mqtt.MqttMessageSubscriber;\n+import org.openhab.core.io.transport.mqtt.reconnect.PeriodicReconnectStrategy;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler implements MqttConnectionObserver, MqttMessageSubscriber {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final Gson gson = new Gson();\n+    private static final int RECONNECT_DELAY_SEC = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable MqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean autoPasses = true;\n+    private @Nullable Boolean twoPasses = null;\n+    private boolean carpetBoost = true;\n+    private @Nullable Boolean vacHigh = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            connect();\n+        });", "originalCommit": "7c151658d2d58e8306a315f18c13a3b6aa15fa5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM2MjE3MA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r533362170", "bodyText": "Done", "author": "Sonic-Amiga", "createdAt": "2020-12-01T12:11:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NTE1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NTU3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r532155573", "bodyText": "Please add @NonNullByDefault", "author": "cpmeister", "createdAt": "2020-11-29T04:54:42Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/IdentProtocol.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * iRobot discovery and identification protocol\n+ *\n+ * @author Pavel Fedin - Initial contribution\n+ *\n+ */\n+public class IdentProtocol {", "originalCommit": "7c151658d2d58e8306a315f18c13a3b6aa15fa5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM1MjAxNg==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r533352016", "bodyText": "I can't because this also applies to inner IdentData class, which is deserialized from json, and is, by your own criteria, \"data only\".\nIn fact IdentData is used as a namespace, it doesn't contain any single data field and only static functions. Does @NonNullByDefault even make sense here ?", "author": "Sonic-Amiga", "createdAt": "2020-12-01T11:54:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NTU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NTU5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r532155590", "bodyText": "Please add @NonNullByDefault", "author": "cpmeister", "createdAt": "2020-11-29T04:54:51Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/MQTTProtocol.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+/**\n+ * iRobot MQTT protocol messages\n+ *\n+ * @author Pavel Fedin - Initial contribution\n+ *\n+ */\n+public class MQTTProtocol {", "originalCommit": "7c151658d2d58e8306a315f18c13a3b6aa15fa5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM1MjEyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r533352122", "bodyText": "The same as above.", "author": "Sonic-Amiga", "createdAt": "2020-12-01T11:54:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NTU5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NTY2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r532155666", "bodyText": "To deal with the @NonNullByDefault warnings you can do one of three things:\n\nAdd the @NonNullByDefault to the class.\nMake sure that your class name ends in DTO\nMake sure that your class is in a package or subpackage called dto.\n\nPlease do one of the three.", "author": "cpmeister", "createdAt": "2020-11-29T04:55:35Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/MQTTProtocol.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+/**\n+ * iRobot MQTT protocol messages\n+ *\n+ * @author Pavel Fedin - Initial contribution\n+ *\n+ */\n+public class MQTTProtocol {\n+    public interface Request {\n+        public String getTopic();\n+    }\n+\n+    public static class CommandRequest implements Request {\n+        public String command;\n+        public long time;\n+        public String initiator;\n+\n+        public CommandRequest(String cmd) {\n+            command = cmd;\n+            time = System.currentTimeMillis() / 1000;\n+            initiator = \"localApp\";\n+        }\n+\n+        @Override\n+        public String getTopic() {\n+            return \"cmd\";\n+        }\n+    }\n+\n+    public static class DeltaRequest implements Request {\n+        public StateValue state;\n+\n+        public DeltaRequest(StateValue state) {\n+            this.state = state;\n+        }\n+\n+        @Override\n+        public String getTopic() {\n+            return \"delta\";\n+        }\n+    }\n+\n+    public static class CleanMissionStatus {\n+        public String cycle;\n+        public String phase;\n+        public int error;\n+    }\n+\n+    public static class BinStatus {\n+        public boolean present;\n+        public boolean full;\n+    }\n+\n+    public static class SignalStrength {\n+        public int rssi;\n+        public int snr;\n+    }", "originalCommit": "7c151658d2d58e8306a315f18c13a3b6aa15fa5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM2MTk2MA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r533361960", "bodyText": "Well, have fun with dto package", "author": "Sonic-Amiga", "createdAt": "2020-12-01T12:11:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NTY2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NjA5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r532156090", "bodyText": "You need some way to prevent this from getting called if the handler is disposed.", "author": "cpmeister", "createdAt": "2020-11-29T05:01:11Z", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal.handler;\n+\n+import static org.openhab.binding.irobot.internal.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.internal.RoombaConfiguration;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.io.transport.mqtt.MqttBrokerConnection;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionObserver;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionState;\n+import org.openhab.core.io.transport.mqtt.MqttMessageSubscriber;\n+import org.openhab.core.io.transport.mqtt.reconnect.PeriodicReconnectStrategy;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler implements MqttConnectionObserver, MqttMessageSubscriber {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final Gson gson = new Gson();\n+    private static final int RECONNECT_DELAY_SEC = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable MqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean autoPasses = true;\n+    private @Nullable Boolean twoPasses = null;\n+    private boolean carpetBoost = true;\n+    private @Nullable Boolean vacHigh = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            connect();\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        scheduler.execute(() -> {\n+            disconnect();\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            sendDelta(new MQTTProtocol.PowerBoost(command.equals(BOOST_AUTO), command.equals(BOOST_PERFORMANCE)));\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            sendDelta(new MQTTProtocol.CleanPasses(!command.equals(PASSES_AUTO), command.equals(PASSES_2)));\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        MqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = gson.toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            // 1 here actually corresponds to MQTT qos 0 (AT_MOST_ONCE). Only this value is accepted\n+            // by Roomba, others just cause it to reject the command and drop the connection.\n+            conn.publish(request.getTopic(), json.getBytes(), 1, false);\n+        }\n+    }\n+\n+    // In order not to mess up our connection state we need to make sure\n+    // that connect() and disconnect() are never running concurrently, so\n+    // they are synchronized\n+    private synchronized void connect() {\n+        logger.debug(\"Connecting to {}\", config.ipaddress);\n+\n+        try {\n+            InetAddress host = InetAddress.getByName(config.ipaddress);\n+            String blid = this.blid;\n+\n+            if (blid == null) {\n+                DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                IdentProtocol.IdentData ident;\n+\n+                identSocket.close();\n+\n+                try {\n+                    ident = IdentProtocol.decodeResponse(identPacket);\n+                } catch (JsonParseException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Malformed IDENT response\");\n+                    return;\n+                }\n+\n+                if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Unsupported version \" + ident.ver);\n+                    return;\n+                }\n+\n+                if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Not a Roomba: \" + ident.product);\n+                    return;\n+                }\n+\n+                blid = ident.blid;\n+                this.blid = blid;\n+            }\n+\n+            logger.debug(\"BLID is: {}\", blid);\n+\n+            if (config.password.isEmpty()) {\n+                RawMQTT mqtt;\n+\n+                try {\n+                    mqtt = new RawMQTT(host, 8883);\n+                } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                    return; // This is internal system error, no retry\n+                }\n+\n+                mqtt.requestPassword();\n+                RawMQTT.Packet response = mqtt.readPacket();\n+                mqtt.close();\n+\n+                if (response != null && response.isValidPasswdPacket()) {\n+                    RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+                    String password = passwdPacket.getPassword();\n+\n+                    if (password != null) {\n+                        config.password = password;\n+\n+                        Configuration configuration = editConfiguration();\n+\n+                        configuration.put(\"password\", password);\n+                        updateConfiguration(configuration);\n+\n+                        logger.debug(\"Password successfully retrieved\");\n+                    }\n+                }\n+            }\n+\n+            if (config.password.isEmpty()) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                        \"Authentication on the robot is required\");\n+                scheduleReconnect();\n+                return;\n+            }\n+\n+            // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+            MqttBrokerConnection connection = new MqttBrokerConnection(config.ipaddress, RawMQTT.ROOMBA_MQTT_PORT, true,\n+                    blid);\n+\n+            this.connection = connection;\n+\n+            // Disable sending UNSUBSCRIBE request before disconnecting becuase Roomba doesn't like it.\n+            // It just swallows the request and never sends any response, so stop() method never completes.\n+            connection.setUnsubscribeOnStop(false);\n+            connection.setCredentials(blid, config.password);\n+            connection.setTrustManagers(RawMQTT.getTrustManagers());\n+            // 1 here actually corresponds to MQTT qos 0 (AT_MOST_ONCE). Only this value is accepted\n+            // by Roomba, others just cause it to reject the command and drop the connection.\n+            connection.setQos(1);\n+            // MQTT connection reconnects itself, so we don't have to call scheduleReconnect()\n+            // when it breaks. Just set the period in ms.\n+            connection.setReconnectStrategy(\n+                    new PeriodicReconnectStrategy(RECONNECT_DELAY_SEC * 1000, RECONNECT_DELAY_SEC * 1000));\n+            connection.start().exceptionally(e -> {\n+                connectionStateChanged(MqttConnectionState.DISCONNECTED, e);\n+                return false;\n+            }).thenAccept(v -> {\n+                if (!v) {\n+                    connectionStateChanged(MqttConnectionState.DISCONNECTED, new TimeoutException(\"Timeout\"));\n+                } else {\n+                    connectionStateChanged(MqttConnectionState.CONNECTED, null);\n+                }\n+            });\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            scheduleReconnect();\n+        }\n+    }\n+\n+    private synchronized void disconnect() {\n+        Future<?> reconnectReq = this.reconnectReq;\n+        MqttBrokerConnection connection = this.connection;\n+\n+        if (reconnectReq != null) {\n+            reconnectReq.cancel(false);\n+            this.reconnectReq = null;\n+        }\n+\n+        if (connection != null) {\n+            connection.stop();\n+            logger.trace(\"Closed connection to {}\", config.ipaddress);\n+            this.connection = null;\n+        }\n+    }\n+\n+    private void scheduleReconnect() {\n+        reconnectReq = scheduler.schedule(this::connect, RECONNECT_DELAY_SEC, TimeUnit.SECONDS);", "originalCommit": "7c151658d2d58e8306a315f18c13a3b6aa15fa5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM1ODQzMg==", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r533358432", "bodyText": "I can add \"boolean disposed\" flag and check it inside scheduleReconnect(), if you're insisting, however it's impossible because it's only called from within connect(), and connect() and disconnect() are synchronized. So disconnect() will wait for connect() to complete, then it will cancel any reconnect request if pending.", "author": "Sonic-Amiga", "createdAt": "2020-12-01T12:05:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NjA5MA=="}], "type": "inlineReview"}, {"oid": "73434a16d919d106947c802f665688be08ec40fa", "url": "https://github.com/openhab/openhab-addons/commit/73434a16d919d106947c802f665688be08ec40fa", "message": "[irobot] iRobot binding\n\nSupports iRobot Roomba and probably some other iRobots (in parts where they\nare compatible)\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>", "committedDate": "2020-12-01T12:08:25Z", "type": "commit"}, {"oid": "9fd6fc445027c9a4f414ba41d04594bab8806d0a", "url": "https://github.com/openhab/openhab-addons/commit/9fd6fc445027c9a4f414ba41d04594bab8806d0a", "message": "[irobot] Drop custom hivemq wrapper\n\nsetUnsubscribeOnStop() has been introduced in\norg.openhab.core.io.transport.mqtt.MqttBrokerConnection, so it can now handle\niRobot's quirks. The custom wrapper is no more needed, remove it\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>", "committedDate": "2020-12-01T12:08:42Z", "type": "commit"}, {"oid": "9fd6fc445027c9a4f414ba41d04594bab8806d0a", "url": "https://github.com/openhab/openhab-addons/commit/9fd6fc445027c9a4f414ba41d04594bab8806d0a", "message": "[irobot] Drop custom hivemq wrapper\n\nsetUnsubscribeOnStop() has been introduced in\norg.openhab.core.io.transport.mqtt.MqttBrokerConnection, so it can now handle\niRobot's quirks. The custom wrapper is no more needed, remove it\n\nSigned-off-by: Pavel Fedin <pavel_fedin@mail.ru>", "committedDate": "2020-12-01T12:08:42Z", "type": "forcePushed"}]}