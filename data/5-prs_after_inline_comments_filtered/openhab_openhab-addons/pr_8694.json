{"pr_number": 8694, "pr_title": "[intesis] - added IntesisBox support", "pr_createdAt": "2020-10-08T08:22:37Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8694", "timeline": [{"oid": "a31398ddd43fa418670904b7fd12835274c88f59", "url": "https://github.com/openhab/openhab-addons/commit/a31398ddd43fa418670904b7fd12835274c88f59", "message": "Intesis Binding - added IntesisBox support\n\nSigned-off-by: Hans-J\u00f6rg Merk <github@hmerk.de>", "committedDate": "2020-10-08T08:10:19Z", "type": "commit"}, {"oid": "8ea1d268bbd9b48e69875641212d0bc824aba056", "url": "https://github.com/openhab/openhab-addons/commit/8ea1d268bbd9b48e69875641212d0bc824aba056", "message": "applied spotless\n\nSigned-off-by: Hans-J\u00f6rg Merk <github@hmerk.de>", "committedDate": "2020-10-08T08:48:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyNzE2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r504127162", "bodyText": "Please split this in two classes if the Things have different configurations.", "author": "fwolter", "createdAt": "2020-10-13T17:17:37Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/IntesisConfiguration.java", "diffHunk": "@@ -23,4 +23,5 @@\n public class IntesisConfiguration {", "originalCommit": "8ea1d268bbd9b48e69875641212d0bc824aba056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc0NDEyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507744125", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-19T13:26:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyNzE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyNzQ0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r504127448", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public HashMap<String, String> value = new HashMap<String, String>();\n          \n          \n            \n                public HashMap<String, String> value = new HashMap<>();", "author": "fwolter", "createdAt": "2020-10-13T17:18:08Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/api/IntesisBoxIdentity.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.api;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * @author Rocky Amatulli - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IntesisBoxIdentity {\n+\n+    public HashMap<String, String> value = new HashMap<String, String>();", "originalCommit": "8ea1d268bbd9b48e69875641212d0bc824aba056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc0NDczOA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507744738", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-19T13:27:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyNzQ0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzMDA2MA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r504130060", "bodyText": "You could do this, to avoid the null warning.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    tcpSocket = new IntesisSocket();\n          \n          \n            \n                    IntesisSocket localSocket = tcpSocket = new IntesisSocket();", "author": "fwolter", "createdAt": "2020-10-13T17:22:37Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/api/IntesisBoxSocketApi.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.api;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.ThingStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class handling the Socket connections.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Hans-J\u00f6rg Merk - Moved Socket to it's own class\n+ */\n+@NonNullByDefault\n+public class IntesisBoxSocketApi {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxSocketApi.class);\n+\n+    private final String ipAddress;\n+    private final int port;\n+\n+    private @Nullable IntesisSocket tcpSocket = null;\n+    private @Nullable OutputStreamWriter tcpOutput = null;\n+    private @Nullable BufferedReader tcpInput = null;\n+\n+    private @Nullable IntesisBoxChangeListener changeListener;\n+\n+    private boolean connected = false;\n+\n+    public IntesisBoxSocketApi(final String ipAddress, final int port) {\n+        this.ipAddress = ipAddress;\n+        this.port = port;\n+    }\n+\n+    private class IntesisSocket {\n+        final Socket socket;\n+\n+        public IntesisSocket() throws UnknownHostException, IOException {\n+            socket = new Socket();\n+            SocketAddress tcpSocketAddress = new InetSocketAddress(ipAddress, port);\n+            socket.connect(tcpSocketAddress);\n+        }\n+\n+        public void close() throws IOException {\n+            socket.close();\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void openConnection() throws IOException {\n+        closeConnection();\n+\n+        logger.debug(\"openConnection(): Connecting to IntesisBox \");\n+\n+        IntesisBoxChangeListener listener = this.changeListener;\n+        if (listener != null) {\n+            logger.debug(\"IntesisBox listener added\");\n+        }\n+\n+        tcpSocket = new IntesisSocket();", "originalCommit": "8ea1d268bbd9b48e69875641212d0bc824aba056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc2NDU4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507764581", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-19T13:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzMDA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzMTE3MA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r504131170", "bodyText": "The field can be null at this point, because it isn't inittialized in the constructor. So, you need to check if it is not null before accessing it: if (job != null).But this would result in a compiler warning, as it is a field and could theoretically be modified by another thread exactly between the null check and the access in the next line.To mitigate this, you can store the field to a local variable before checking it:\n\nFuture<?> localPollingJob = pollingJob;\nif (localPollingJob != null) {\n    localPollingJob.cancel(true);\n}", "author": "fwolter", "createdAt": "2020-10-13T17:24:24Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/api/IntesisBoxSocketApi.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.api;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.ThingStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class handling the Socket connections.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Hans-J\u00f6rg Merk - Moved Socket to it's own class\n+ */\n+@NonNullByDefault\n+public class IntesisBoxSocketApi {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxSocketApi.class);\n+\n+    private final String ipAddress;\n+    private final int port;\n+\n+    private @Nullable IntesisSocket tcpSocket = null;\n+    private @Nullable OutputStreamWriter tcpOutput = null;\n+    private @Nullable BufferedReader tcpInput = null;\n+\n+    private @Nullable IntesisBoxChangeListener changeListener;\n+\n+    private boolean connected = false;\n+\n+    public IntesisBoxSocketApi(final String ipAddress, final int port) {\n+        this.ipAddress = ipAddress;\n+        this.port = port;\n+    }\n+\n+    private class IntesisSocket {\n+        final Socket socket;\n+\n+        public IntesisSocket() throws UnknownHostException, IOException {\n+            socket = new Socket();\n+            SocketAddress tcpSocketAddress = new InetSocketAddress(ipAddress, port);\n+            socket.connect(tcpSocketAddress);\n+        }\n+\n+        public void close() throws IOException {\n+            socket.close();\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void openConnection() throws IOException {\n+        closeConnection();\n+\n+        logger.debug(\"openConnection(): Connecting to IntesisBox \");\n+\n+        IntesisBoxChangeListener listener = this.changeListener;\n+        if (listener != null) {\n+            logger.debug(\"IntesisBox listener added\");\n+        }\n+\n+        tcpSocket = new IntesisSocket();\n+        tcpOutput = new OutputStreamWriter(tcpSocket.socket.getOutputStream(), \"US-ASCII\");\n+        tcpInput = new BufferedReader(new InputStreamReader(tcpSocket.socket.getInputStream()));\n+\n+        Thread tcpListener = new Thread(new TCPListener());\n+        tcpListener.start();\n+\n+        setConnected(true);\n+        if (listener != null) {\n+            listener.connectionStatusChanged(ThingStatus.ONLINE);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void closeConnection() {\n+        try {\n+            if (tcpSocket != null) {", "originalCommit": "8ea1d268bbd9b48e69875641212d0bc824aba056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc3MDY1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507770655", "bodyText": "Suppress Warning \"null\" is not needed any more.", "author": "hmerk", "createdAt": "2020-10-19T14:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzMTE3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzMTcwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r504131704", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-10-13T17:25:19Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/api/IntesisBoxSocketApi.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.api;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.ThingStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class handling the Socket connections.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Hans-J\u00f6rg Merk - Moved Socket to it's own class\n+ */\n+@NonNullByDefault\n+public class IntesisBoxSocketApi {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxSocketApi.class);\n+\n+    private final String ipAddress;\n+    private final int port;\n+\n+    private @Nullable IntesisSocket tcpSocket = null;\n+    private @Nullable OutputStreamWriter tcpOutput = null;\n+    private @Nullable BufferedReader tcpInput = null;\n+\n+    private @Nullable IntesisBoxChangeListener changeListener;\n+\n+    private boolean connected = false;\n+\n+    public IntesisBoxSocketApi(final String ipAddress, final int port) {\n+        this.ipAddress = ipAddress;\n+        this.port = port;\n+    }\n+\n+    private class IntesisSocket {\n+        final Socket socket;\n+\n+        public IntesisSocket() throws UnknownHostException, IOException {\n+            socket = new Socket();\n+            SocketAddress tcpSocketAddress = new InetSocketAddress(ipAddress, port);\n+            socket.connect(tcpSocketAddress);\n+        }\n+\n+        public void close() throws IOException {\n+            socket.close();\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void openConnection() throws IOException {\n+        closeConnection();\n+\n+        logger.debug(\"openConnection(): Connecting to IntesisBox \");\n+\n+        IntesisBoxChangeListener listener = this.changeListener;\n+        if (listener != null) {\n+            logger.debug(\"IntesisBox listener added\");\n+        }\n+\n+        tcpSocket = new IntesisSocket();\n+        tcpOutput = new OutputStreamWriter(tcpSocket.socket.getOutputStream(), \"US-ASCII\");\n+        tcpInput = new BufferedReader(new InputStreamReader(tcpSocket.socket.getInputStream()));\n+\n+        Thread tcpListener = new Thread(new TCPListener());\n+        tcpListener.start();\n+\n+        setConnected(true);\n+        if (listener != null) {\n+            listener.connectionStatusChanged(ThingStatus.ONLINE);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void closeConnection() {\n+        try {\n+            if (tcpSocket != null) {\n+                logger.debug(\"closeConnection(): Closing Socket!\");", "originalCommit": "8ea1d268bbd9b48e69875641212d0bc824aba056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc0OTY3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507749671", "bodyText": "Remove", "author": "hmerk", "createdAt": "2020-10-19T13:33:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzMTcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzMjA3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r504132072", "bodyText": "What type of exception do you expect here? Can you specify the concrete type? Same for below.", "author": "fwolter", "createdAt": "2020-10-13T17:25:54Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/api/IntesisBoxSocketApi.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.api;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.ThingStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class handling the Socket connections.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Hans-J\u00f6rg Merk - Moved Socket to it's own class\n+ */\n+@NonNullByDefault\n+public class IntesisBoxSocketApi {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxSocketApi.class);\n+\n+    private final String ipAddress;\n+    private final int port;\n+\n+    private @Nullable IntesisSocket tcpSocket = null;\n+    private @Nullable OutputStreamWriter tcpOutput = null;\n+    private @Nullable BufferedReader tcpInput = null;\n+\n+    private @Nullable IntesisBoxChangeListener changeListener;\n+\n+    private boolean connected = false;\n+\n+    public IntesisBoxSocketApi(final String ipAddress, final int port) {\n+        this.ipAddress = ipAddress;\n+        this.port = port;\n+    }\n+\n+    private class IntesisSocket {\n+        final Socket socket;\n+\n+        public IntesisSocket() throws UnknownHostException, IOException {\n+            socket = new Socket();\n+            SocketAddress tcpSocketAddress = new InetSocketAddress(ipAddress, port);\n+            socket.connect(tcpSocketAddress);\n+        }\n+\n+        public void close() throws IOException {\n+            socket.close();\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void openConnection() throws IOException {\n+        closeConnection();\n+\n+        logger.debug(\"openConnection(): Connecting to IntesisBox \");\n+\n+        IntesisBoxChangeListener listener = this.changeListener;\n+        if (listener != null) {\n+            logger.debug(\"IntesisBox listener added\");\n+        }\n+\n+        tcpSocket = new IntesisSocket();\n+        tcpOutput = new OutputStreamWriter(tcpSocket.socket.getOutputStream(), \"US-ASCII\");\n+        tcpInput = new BufferedReader(new InputStreamReader(tcpSocket.socket.getInputStream()));\n+\n+        Thread tcpListener = new Thread(new TCPListener());\n+        tcpListener.start();\n+\n+        setConnected(true);\n+        if (listener != null) {\n+            listener.connectionStatusChanged(ThingStatus.ONLINE);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void closeConnection() {\n+        try {\n+            if (tcpSocket != null) {\n+                logger.debug(\"closeConnection(): Closing Socket!\");\n+                tcpSocket.close();\n+                tcpSocket = null;\n+            }\n+            if (tcpInput != null) {\n+                logger.debug(\"closeConnection(): Closing Output Writer!\");\n+                tcpInput.close();\n+                tcpInput = null;\n+            }\n+            if (tcpOutput != null) {\n+                logger.debug(\"closeConnection(): Closing Input Reader!\");\n+                tcpOutput.close();\n+                tcpOutput = null;\n+            }\n+\n+            setConnected(false);\n+            logger.debug(\"closeConnection(): Closed TCP Connection!\");\n+        } catch (IOException ioException) {\n+            logger.debug(\"closeConnection(): Unable to close connection - {}\", ioException.getMessage());\n+        } catch (Exception exception) {\n+            logger.debug(\"closeConnection(): Error closing connection - {}\", exception.getMessage());\n+        }\n+    }\n+\n+    private class TCPListener implements Runnable {\n+        private final Logger logger = LoggerFactory.getLogger(TCPListener.class);\n+\n+        /**\n+         * Run method. Runs the MessageListener thread\n+         */\n+        @Override\n+        public void run() {\n+            try {\n+                while (isConnected()) {\n+                    String message = read();\n+                    try {\n+                        logger.trace(\"Calling readMessage()\");\n+                        readMessage(message);\n+                    } catch (Exception e) {", "originalCommit": "8ea1d268bbd9b48e69875641212d0bc824aba056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc5MTcwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507791704", "bodyText": "removed try catch here", "author": "hmerk", "createdAt": "2020-10-19T14:24:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzMjA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzMzEyMw==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r504133123", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-10-13T17:27:47Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/api/IntesisBoxSocketApi.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.api;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.ThingStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class handling the Socket connections.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Hans-J\u00f6rg Merk - Moved Socket to it's own class\n+ */\n+@NonNullByDefault\n+public class IntesisBoxSocketApi {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxSocketApi.class);\n+\n+    private final String ipAddress;\n+    private final int port;\n+\n+    private @Nullable IntesisSocket tcpSocket = null;\n+    private @Nullable OutputStreamWriter tcpOutput = null;\n+    private @Nullable BufferedReader tcpInput = null;\n+\n+    private @Nullable IntesisBoxChangeListener changeListener;\n+\n+    private boolean connected = false;\n+\n+    public IntesisBoxSocketApi(final String ipAddress, final int port) {\n+        this.ipAddress = ipAddress;\n+        this.port = port;\n+    }\n+\n+    private class IntesisSocket {\n+        final Socket socket;\n+\n+        public IntesisSocket() throws UnknownHostException, IOException {\n+            socket = new Socket();\n+            SocketAddress tcpSocketAddress = new InetSocketAddress(ipAddress, port);\n+            socket.connect(tcpSocketAddress);\n+        }\n+\n+        public void close() throws IOException {\n+            socket.close();\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void openConnection() throws IOException {\n+        closeConnection();\n+\n+        logger.debug(\"openConnection(): Connecting to IntesisBox \");\n+\n+        IntesisBoxChangeListener listener = this.changeListener;\n+        if (listener != null) {\n+            logger.debug(\"IntesisBox listener added\");\n+        }\n+\n+        tcpSocket = new IntesisSocket();\n+        tcpOutput = new OutputStreamWriter(tcpSocket.socket.getOutputStream(), \"US-ASCII\");\n+        tcpInput = new BufferedReader(new InputStreamReader(tcpSocket.socket.getInputStream()));\n+\n+        Thread tcpListener = new Thread(new TCPListener());\n+        tcpListener.start();\n+\n+        setConnected(true);\n+        if (listener != null) {\n+            listener.connectionStatusChanged(ThingStatus.ONLINE);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void closeConnection() {\n+        try {\n+            if (tcpSocket != null) {\n+                logger.debug(\"closeConnection(): Closing Socket!\");\n+                tcpSocket.close();\n+                tcpSocket = null;\n+            }\n+            if (tcpInput != null) {\n+                logger.debug(\"closeConnection(): Closing Output Writer!\");\n+                tcpInput.close();\n+                tcpInput = null;\n+            }\n+            if (tcpOutput != null) {\n+                logger.debug(\"closeConnection(): Closing Input Reader!\");\n+                tcpOutput.close();\n+                tcpOutput = null;\n+            }\n+\n+            setConnected(false);\n+            logger.debug(\"closeConnection(): Closed TCP Connection!\");\n+        } catch (IOException ioException) {\n+            logger.debug(\"closeConnection(): Unable to close connection - {}\", ioException.getMessage());\n+        } catch (Exception exception) {\n+            logger.debug(\"closeConnection(): Error closing connection - {}\", exception.getMessage());\n+        }\n+    }\n+\n+    private class TCPListener implements Runnable {\n+        private final Logger logger = LoggerFactory.getLogger(TCPListener.class);\n+\n+        /**\n+         * Run method. Runs the MessageListener thread\n+         */\n+        @Override\n+        public void run() {\n+            try {\n+                while (isConnected()) {\n+                    String message = read();\n+                    try {\n+                        logger.trace(\"Calling readMessage()\");\n+                        readMessage(message);\n+                    } catch (Exception e) {\n+                        logger.debug(\"TCPListener(): Message not handled by thing: {}\", e.getMessage());\n+                        closeConnection();\n+                    }\n+                }\n+            } catch (Exception e) {\n+                logger.debug(\"TCPListener(): Unable to read message: {} \", e.getMessage(), e);\n+                closeConnection();\n+            }\n+        }\n+    }\n+\n+    public void addIntesisBoxChangeListener(IntesisBoxChangeListener listener) {\n+        if (this.changeListener == null) {\n+            this.changeListener = listener;\n+        }\n+    }\n+\n+    private void write(String data) {\n+        try {\n+            if (tcpOutput != null) {\n+                tcpOutput.write(data);\n+            }\n+            if (tcpOutput != null) {\n+                tcpOutput.flush();\n+            }\n+        } catch (IOException ioException) {\n+            logger.debug(\"write(): {}\", ioException.getMessage());\n+            setConnected(false);\n+        } catch (Exception exception) {", "originalCommit": "8ea1d268bbd9b48e69875641212d0bc824aba056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc5NDA2OA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507794068", "bodyText": "removed second catch", "author": "hmerk", "createdAt": "2020-10-19T14:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzMzEyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzMzMzNg==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r504133336", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-10-13T17:28:06Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/api/IntesisBoxSocketApi.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.api;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.ThingStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class handling the Socket connections.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Hans-J\u00f6rg Merk - Moved Socket to it's own class\n+ */\n+@NonNullByDefault\n+public class IntesisBoxSocketApi {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxSocketApi.class);\n+\n+    private final String ipAddress;\n+    private final int port;\n+\n+    private @Nullable IntesisSocket tcpSocket = null;\n+    private @Nullable OutputStreamWriter tcpOutput = null;\n+    private @Nullable BufferedReader tcpInput = null;\n+\n+    private @Nullable IntesisBoxChangeListener changeListener;\n+\n+    private boolean connected = false;\n+\n+    public IntesisBoxSocketApi(final String ipAddress, final int port) {\n+        this.ipAddress = ipAddress;\n+        this.port = port;\n+    }\n+\n+    private class IntesisSocket {\n+        final Socket socket;\n+\n+        public IntesisSocket() throws UnknownHostException, IOException {\n+            socket = new Socket();\n+            SocketAddress tcpSocketAddress = new InetSocketAddress(ipAddress, port);\n+            socket.connect(tcpSocketAddress);\n+        }\n+\n+        public void close() throws IOException {\n+            socket.close();\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void openConnection() throws IOException {\n+        closeConnection();\n+\n+        logger.debug(\"openConnection(): Connecting to IntesisBox \");\n+\n+        IntesisBoxChangeListener listener = this.changeListener;\n+        if (listener != null) {\n+            logger.debug(\"IntesisBox listener added\");\n+        }\n+\n+        tcpSocket = new IntesisSocket();\n+        tcpOutput = new OutputStreamWriter(tcpSocket.socket.getOutputStream(), \"US-ASCII\");\n+        tcpInput = new BufferedReader(new InputStreamReader(tcpSocket.socket.getInputStream()));\n+\n+        Thread tcpListener = new Thread(new TCPListener());\n+        tcpListener.start();\n+\n+        setConnected(true);\n+        if (listener != null) {\n+            listener.connectionStatusChanged(ThingStatus.ONLINE);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void closeConnection() {\n+        try {\n+            if (tcpSocket != null) {\n+                logger.debug(\"closeConnection(): Closing Socket!\");\n+                tcpSocket.close();\n+                tcpSocket = null;\n+            }\n+            if (tcpInput != null) {\n+                logger.debug(\"closeConnection(): Closing Output Writer!\");\n+                tcpInput.close();\n+                tcpInput = null;\n+            }\n+            if (tcpOutput != null) {\n+                logger.debug(\"closeConnection(): Closing Input Reader!\");\n+                tcpOutput.close();\n+                tcpOutput = null;\n+            }\n+\n+            setConnected(false);\n+            logger.debug(\"closeConnection(): Closed TCP Connection!\");\n+        } catch (IOException ioException) {\n+            logger.debug(\"closeConnection(): Unable to close connection - {}\", ioException.getMessage());\n+        } catch (Exception exception) {\n+            logger.debug(\"closeConnection(): Error closing connection - {}\", exception.getMessage());\n+        }\n+    }\n+\n+    private class TCPListener implements Runnable {\n+        private final Logger logger = LoggerFactory.getLogger(TCPListener.class);\n+\n+        /**\n+         * Run method. Runs the MessageListener thread\n+         */\n+        @Override\n+        public void run() {\n+            try {\n+                while (isConnected()) {\n+                    String message = read();\n+                    try {\n+                        logger.trace(\"Calling readMessage()\");\n+                        readMessage(message);\n+                    } catch (Exception e) {\n+                        logger.debug(\"TCPListener(): Message not handled by thing: {}\", e.getMessage());\n+                        closeConnection();\n+                    }\n+                }\n+            } catch (Exception e) {\n+                logger.debug(\"TCPListener(): Unable to read message: {} \", e.getMessage(), e);\n+                closeConnection();\n+            }\n+        }\n+    }\n+\n+    public void addIntesisBoxChangeListener(IntesisBoxChangeListener listener) {\n+        if (this.changeListener == null) {\n+            this.changeListener = listener;\n+        }\n+    }\n+\n+    private void write(String data) {\n+        try {\n+            if (tcpOutput != null) {\n+                tcpOutput.write(data);\n+            }\n+            if (tcpOutput != null) {\n+                tcpOutput.flush();\n+            }\n+        } catch (IOException ioException) {\n+            logger.debug(\"write(): {}\", ioException.getMessage());\n+            setConnected(false);\n+        } catch (Exception exception) {\n+            logger.debug(\"write(): Unable to write to socket: {} \", exception.getMessage(), exception);\n+            setConnected(false);\n+        }\n+    }\n+\n+    public String read() {\n+        String message = \"\";\n+        try {\n+            if (tcpInput != null) {\n+                message = tcpInput.readLine();\n+                logger.debug(\"read(): Message Received: {}\", message);\n+            }\n+        } catch (IOException ioException) {\n+            logger.debug(\"read(): IO Exception: {}\", ioException.getMessage());\n+            setConnected(false);\n+        } catch (Exception exception) {", "originalCommit": "8ea1d268bbd9b48e69875641212d0bc824aba056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc5NDUzOA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507794538", "bodyText": "removed second catch", "author": "hmerk", "createdAt": "2020-10-19T14:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzMzMzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzMzc3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r504133779", "bodyText": "Can you update the Thing status with the exception's message? Same for the other occurrences.", "author": "fwolter", "createdAt": "2020-10-13T17:28:54Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/api/IntesisBoxSocketApi.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.api;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.ThingStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class handling the Socket connections.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Hans-J\u00f6rg Merk - Moved Socket to it's own class\n+ */\n+@NonNullByDefault\n+public class IntesisBoxSocketApi {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxSocketApi.class);\n+\n+    private final String ipAddress;\n+    private final int port;\n+\n+    private @Nullable IntesisSocket tcpSocket = null;\n+    private @Nullable OutputStreamWriter tcpOutput = null;\n+    private @Nullable BufferedReader tcpInput = null;\n+\n+    private @Nullable IntesisBoxChangeListener changeListener;\n+\n+    private boolean connected = false;\n+\n+    public IntesisBoxSocketApi(final String ipAddress, final int port) {\n+        this.ipAddress = ipAddress;\n+        this.port = port;\n+    }\n+\n+    private class IntesisSocket {\n+        final Socket socket;\n+\n+        public IntesisSocket() throws UnknownHostException, IOException {\n+            socket = new Socket();\n+            SocketAddress tcpSocketAddress = new InetSocketAddress(ipAddress, port);\n+            socket.connect(tcpSocketAddress);\n+        }\n+\n+        public void close() throws IOException {\n+            socket.close();\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void openConnection() throws IOException {\n+        closeConnection();\n+\n+        logger.debug(\"openConnection(): Connecting to IntesisBox \");\n+\n+        IntesisBoxChangeListener listener = this.changeListener;\n+        if (listener != null) {\n+            logger.debug(\"IntesisBox listener added\");\n+        }\n+\n+        tcpSocket = new IntesisSocket();\n+        tcpOutput = new OutputStreamWriter(tcpSocket.socket.getOutputStream(), \"US-ASCII\");\n+        tcpInput = new BufferedReader(new InputStreamReader(tcpSocket.socket.getInputStream()));\n+\n+        Thread tcpListener = new Thread(new TCPListener());\n+        tcpListener.start();\n+\n+        setConnected(true);\n+        if (listener != null) {\n+            listener.connectionStatusChanged(ThingStatus.ONLINE);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void closeConnection() {\n+        try {\n+            if (tcpSocket != null) {\n+                logger.debug(\"closeConnection(): Closing Socket!\");\n+                tcpSocket.close();\n+                tcpSocket = null;\n+            }\n+            if (tcpInput != null) {\n+                logger.debug(\"closeConnection(): Closing Output Writer!\");\n+                tcpInput.close();\n+                tcpInput = null;\n+            }\n+            if (tcpOutput != null) {\n+                logger.debug(\"closeConnection(): Closing Input Reader!\");\n+                tcpOutput.close();\n+                tcpOutput = null;\n+            }\n+\n+            setConnected(false);\n+            logger.debug(\"closeConnection(): Closed TCP Connection!\");\n+        } catch (IOException ioException) {\n+            logger.debug(\"closeConnection(): Unable to close connection - {}\", ioException.getMessage());\n+        } catch (Exception exception) {\n+            logger.debug(\"closeConnection(): Error closing connection - {}\", exception.getMessage());\n+        }\n+    }\n+\n+    private class TCPListener implements Runnable {\n+        private final Logger logger = LoggerFactory.getLogger(TCPListener.class);\n+\n+        /**\n+         * Run method. Runs the MessageListener thread\n+         */\n+        @Override\n+        public void run() {\n+            try {\n+                while (isConnected()) {\n+                    String message = read();\n+                    try {\n+                        logger.trace(\"Calling readMessage()\");\n+                        readMessage(message);\n+                    } catch (Exception e) {\n+                        logger.debug(\"TCPListener(): Message not handled by thing: {}\", e.getMessage());\n+                        closeConnection();\n+                    }\n+                }\n+            } catch (Exception e) {\n+                logger.debug(\"TCPListener(): Unable to read message: {} \", e.getMessage(), e);\n+                closeConnection();\n+            }\n+        }\n+    }\n+\n+    public void addIntesisBoxChangeListener(IntesisBoxChangeListener listener) {\n+        if (this.changeListener == null) {\n+            this.changeListener = listener;\n+        }\n+    }\n+\n+    private void write(String data) {\n+        try {\n+            if (tcpOutput != null) {\n+                tcpOutput.write(data);\n+            }\n+            if (tcpOutput != null) {\n+                tcpOutput.flush();\n+            }\n+        } catch (IOException ioException) {\n+            logger.debug(\"write(): {}\", ioException.getMessage());", "originalCommit": "8ea1d268bbd9b48e69875641212d0bc824aba056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc4NTA2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507785066", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-19T14:16:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzMzc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNTY3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r504135671", "bodyText": "Please significantly reduce the logging in this file. You can use the debugger to debug the code.", "author": "fwolter", "createdAt": "2020-10-13T17:32:13Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/api/IntesisBoxSocketApi.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.api;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.ThingStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class handling the Socket connections.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Hans-J\u00f6rg Merk - Moved Socket to it's own class\n+ */\n+@NonNullByDefault\n+public class IntesisBoxSocketApi {", "originalCommit": "8ea1d268bbd9b48e69875641212d0bc824aba056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc1NDQxOA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507754418", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-19T13:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNTY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNjcxNg==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r504136716", "bodyText": "Decimal numbers with point are double by default.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private double minTemp = 0.0d, maxTemp = 0.0d;\n          \n          \n            \n                private double minTemp = 0.0, maxTemp = 0.0;", "author": "fwolter", "createdAt": "2020-10-13T17:34:12Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/handler/IntesisBoxHandler.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.handler;\n+\n+import static org.openhab.binding.intesis.internal.IntesisBindingConstants.*;\n+import static org.openhab.binding.intesis.internal.api.IntesisBoxMessage.*;\n+import static org.openhab.core.thing.Thing.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.IntesisConfiguration;\n+import org.openhab.binding.intesis.internal.IntesisDynamicStateDescriptionProvider;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxChangeListener;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxIdentity;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxMessage;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxSocketApi;\n+import org.openhab.binding.intesis.internal.enums.IntesisBoxFunctionEnum;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link IntesisBoxHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Rocky Amatulli - additions to include id message handling, dynamic channel options based on limits.\n+ * @author Hans-J\u00f6rg Merk - refactored for openHAB 3.0 compatibility\n+ *\n+ */\n+@NonNullByDefault\n+public class IntesisBoxHandler extends BaseThingHandler implements IntesisBoxChangeListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxHandler.class);\n+    private @Nullable IntesisBoxSocketApi intesisBoxSocketApi;\n+\n+    private final Map<String, String> properties = new HashMap<>();\n+    private final Map<String, List<String>> limits = new HashMap<String, List<String>>();\n+\n+    private final IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider;\n+\n+    private IntesisConfiguration config = new IntesisConfiguration();\n+\n+    private double minTemp = 0.0d, maxTemp = 0.0d;", "originalCommit": "8ea1d268bbd9b48e69875641212d0bc824aba056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc1NDg4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507754887", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-19T13:40:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNjcxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNzE4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r504137187", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        ;", "author": "fwolter", "createdAt": "2020-10-13T17:35:08Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/handler/IntesisBoxHandler.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.handler;\n+\n+import static org.openhab.binding.intesis.internal.IntesisBindingConstants.*;\n+import static org.openhab.binding.intesis.internal.api.IntesisBoxMessage.*;\n+import static org.openhab.core.thing.Thing.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.IntesisConfiguration;\n+import org.openhab.binding.intesis.internal.IntesisDynamicStateDescriptionProvider;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxChangeListener;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxIdentity;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxMessage;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxSocketApi;\n+import org.openhab.binding.intesis.internal.enums.IntesisBoxFunctionEnum;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link IntesisBoxHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Rocky Amatulli - additions to include id message handling, dynamic channel options based on limits.\n+ * @author Hans-J\u00f6rg Merk - refactored for openHAB 3.0 compatibility\n+ *\n+ */\n+@NonNullByDefault\n+public class IntesisBoxHandler extends BaseThingHandler implements IntesisBoxChangeListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxHandler.class);\n+    private @Nullable IntesisBoxSocketApi intesisBoxSocketApi;\n+\n+    private final Map<String, String> properties = new HashMap<>();\n+    private final Map<String, List<String>> limits = new HashMap<String, List<String>>();\n+\n+    private final IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider;\n+\n+    private IntesisConfiguration config = new IntesisConfiguration();\n+\n+    private double minTemp = 0.0d, maxTemp = 0.0d;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+\n+    public IntesisBoxHandler(Thing thing, IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider) {\n+        super(thing);\n+        this.intesisStateDescriptionProvider = intesisStateDescriptionProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(IntesisConfiguration.class);\n+\n+        if (!config.ipAddress.isEmpty()) {\n+            intesisBoxSocketApi = new IntesisBoxSocketApi(config.ipAddress, config.port);\n+            intesisBoxSocketApi.addIntesisBoxChangeListener(this);\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+            scheduler.submit(() -> {\n+                try {\n+                    intesisBoxSocketApi.openConnection();\n+                    intesisBoxSocketApi.sendId();\n+                    intesisBoxSocketApi.sendLimitsQuery();\n+                    intesisBoxSocketApi.sendAlive();\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+                pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 3, 45, TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No IP address specified)\");\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> pollingTask = this.pollingTask;\n+\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+\n+        if (pollingTask != null) {\n+            pollingTask.cancel(true);\n+            this.pollingTask = null;\n+        }\n+        if (api != null) {\n+            api.closeConnection();\n+        }\n+        super.dispose();\n+    }\n+\n+    private synchronized void polling() {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                try {\n+                    api.openConnection();\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+            }\n+            api.sendAlive();\n+            ;", "originalCommit": "8ea1d268bbd9b48e69875641212d0bc824aba056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc1NTQzNw==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507755437", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-19T13:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNzE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNzUxMw==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r504137513", "bodyText": "This could be trace.", "author": "fwolter", "createdAt": "2020-10-13T17:35:46Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/handler/IntesisBoxHandler.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.handler;\n+\n+import static org.openhab.binding.intesis.internal.IntesisBindingConstants.*;\n+import static org.openhab.binding.intesis.internal.api.IntesisBoxMessage.*;\n+import static org.openhab.core.thing.Thing.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.IntesisConfiguration;\n+import org.openhab.binding.intesis.internal.IntesisDynamicStateDescriptionProvider;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxChangeListener;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxIdentity;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxMessage;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxSocketApi;\n+import org.openhab.binding.intesis.internal.enums.IntesisBoxFunctionEnum;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link IntesisBoxHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Rocky Amatulli - additions to include id message handling, dynamic channel options based on limits.\n+ * @author Hans-J\u00f6rg Merk - refactored for openHAB 3.0 compatibility\n+ *\n+ */\n+@NonNullByDefault\n+public class IntesisBoxHandler extends BaseThingHandler implements IntesisBoxChangeListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxHandler.class);\n+    private @Nullable IntesisBoxSocketApi intesisBoxSocketApi;\n+\n+    private final Map<String, String> properties = new HashMap<>();\n+    private final Map<String, List<String>> limits = new HashMap<String, List<String>>();\n+\n+    private final IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider;\n+\n+    private IntesisConfiguration config = new IntesisConfiguration();\n+\n+    private double minTemp = 0.0d, maxTemp = 0.0d;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+\n+    public IntesisBoxHandler(Thing thing, IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider) {\n+        super(thing);\n+        this.intesisStateDescriptionProvider = intesisStateDescriptionProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(IntesisConfiguration.class);\n+\n+        if (!config.ipAddress.isEmpty()) {\n+            intesisBoxSocketApi = new IntesisBoxSocketApi(config.ipAddress, config.port);\n+            intesisBoxSocketApi.addIntesisBoxChangeListener(this);\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+            scheduler.submit(() -> {\n+                try {\n+                    intesisBoxSocketApi.openConnection();\n+                    intesisBoxSocketApi.sendId();\n+                    intesisBoxSocketApi.sendLimitsQuery();\n+                    intesisBoxSocketApi.sendAlive();\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+                pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 3, 45, TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No IP address specified)\");\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> pollingTask = this.pollingTask;\n+\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+\n+        if (pollingTask != null) {\n+            pollingTask.cancel(true);\n+            this.pollingTask = null;\n+        }\n+        if (api != null) {\n+            api.closeConnection();\n+        }\n+        super.dispose();\n+    }\n+\n+    private synchronized void polling() {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                try {\n+                    api.openConnection();\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+            }\n+            api.sendAlive();\n+            ;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                logger.trace(\"Sending command failed, not connected\");\n+                return;\n+            }\n+            if (command instanceof RefreshType) {\n+                logger.warn(\"Refresh channel {}\", channelUID.getId());", "originalCommit": "8ea1d268bbd9b48e69875641212d0bc824aba056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc1NTgxMg==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507755812", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-19T13:42:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNzUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNzg3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r504137873", "bodyText": "Please handle the null compiler warning.", "author": "fwolter", "createdAt": "2020-10-13T17:36:24Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/handler/IntesisBoxHandler.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.handler;\n+\n+import static org.openhab.binding.intesis.internal.IntesisBindingConstants.*;\n+import static org.openhab.binding.intesis.internal.api.IntesisBoxMessage.*;\n+import static org.openhab.core.thing.Thing.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.IntesisConfiguration;\n+import org.openhab.binding.intesis.internal.IntesisDynamicStateDescriptionProvider;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxChangeListener;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxIdentity;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxMessage;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxSocketApi;\n+import org.openhab.binding.intesis.internal.enums.IntesisBoxFunctionEnum;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link IntesisBoxHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Rocky Amatulli - additions to include id message handling, dynamic channel options based on limits.\n+ * @author Hans-J\u00f6rg Merk - refactored for openHAB 3.0 compatibility\n+ *\n+ */\n+@NonNullByDefault\n+public class IntesisBoxHandler extends BaseThingHandler implements IntesisBoxChangeListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxHandler.class);\n+    private @Nullable IntesisBoxSocketApi intesisBoxSocketApi;\n+\n+    private final Map<String, String> properties = new HashMap<>();\n+    private final Map<String, List<String>> limits = new HashMap<String, List<String>>();\n+\n+    private final IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider;\n+\n+    private IntesisConfiguration config = new IntesisConfiguration();\n+\n+    private double minTemp = 0.0d, maxTemp = 0.0d;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+\n+    public IntesisBoxHandler(Thing thing, IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider) {\n+        super(thing);\n+        this.intesisStateDescriptionProvider = intesisStateDescriptionProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(IntesisConfiguration.class);\n+\n+        if (!config.ipAddress.isEmpty()) {\n+            intesisBoxSocketApi = new IntesisBoxSocketApi(config.ipAddress, config.port);\n+            intesisBoxSocketApi.addIntesisBoxChangeListener(this);\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+            scheduler.submit(() -> {\n+                try {\n+                    intesisBoxSocketApi.openConnection();\n+                    intesisBoxSocketApi.sendId();\n+                    intesisBoxSocketApi.sendLimitsQuery();\n+                    intesisBoxSocketApi.sendAlive();", "originalCommit": "8ea1d268bbd9b48e69875641212d0bc824aba056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc5ODYzMA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507798630", "bodyText": "done", "author": "hmerk", "createdAt": "2020-10-19T14:30:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNzg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzODE1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r504138157", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                value = ((OnOffType) command == OnOffType.ON) ? \"ON\" : \"OFF\";\n          \n          \n            \n                                value = command == OnOffType.ON ? \"ON\" : \"OFF\";", "author": "fwolter", "createdAt": "2020-10-13T17:36:50Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/handler/IntesisBoxHandler.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.handler;\n+\n+import static org.openhab.binding.intesis.internal.IntesisBindingConstants.*;\n+import static org.openhab.binding.intesis.internal.api.IntesisBoxMessage.*;\n+import static org.openhab.core.thing.Thing.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.IntesisConfiguration;\n+import org.openhab.binding.intesis.internal.IntesisDynamicStateDescriptionProvider;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxChangeListener;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxIdentity;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxMessage;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxSocketApi;\n+import org.openhab.binding.intesis.internal.enums.IntesisBoxFunctionEnum;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link IntesisBoxHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Rocky Amatulli - additions to include id message handling, dynamic channel options based on limits.\n+ * @author Hans-J\u00f6rg Merk - refactored for openHAB 3.0 compatibility\n+ *\n+ */\n+@NonNullByDefault\n+public class IntesisBoxHandler extends BaseThingHandler implements IntesisBoxChangeListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxHandler.class);\n+    private @Nullable IntesisBoxSocketApi intesisBoxSocketApi;\n+\n+    private final Map<String, String> properties = new HashMap<>();\n+    private final Map<String, List<String>> limits = new HashMap<String, List<String>>();\n+\n+    private final IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider;\n+\n+    private IntesisConfiguration config = new IntesisConfiguration();\n+\n+    private double minTemp = 0.0d, maxTemp = 0.0d;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+\n+    public IntesisBoxHandler(Thing thing, IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider) {\n+        super(thing);\n+        this.intesisStateDescriptionProvider = intesisStateDescriptionProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(IntesisConfiguration.class);\n+\n+        if (!config.ipAddress.isEmpty()) {\n+            intesisBoxSocketApi = new IntesisBoxSocketApi(config.ipAddress, config.port);\n+            intesisBoxSocketApi.addIntesisBoxChangeListener(this);\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+            scheduler.submit(() -> {\n+                try {\n+                    intesisBoxSocketApi.openConnection();\n+                    intesisBoxSocketApi.sendId();\n+                    intesisBoxSocketApi.sendLimitsQuery();\n+                    intesisBoxSocketApi.sendAlive();\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+                pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 3, 45, TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No IP address specified)\");\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> pollingTask = this.pollingTask;\n+\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+\n+        if (pollingTask != null) {\n+            pollingTask.cancel(true);\n+            this.pollingTask = null;\n+        }\n+        if (api != null) {\n+            api.closeConnection();\n+        }\n+        super.dispose();\n+    }\n+\n+    private synchronized void polling() {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                try {\n+                    api.openConnection();\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+            }\n+            api.sendAlive();\n+            ;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                logger.trace(\"Sending command failed, not connected\");\n+                return;\n+            }\n+            if (command instanceof RefreshType) {\n+                logger.warn(\"Refresh channel {}\", channelUID.getId());\n+                api.sendQuery(channelUID.getId());\n+                return;\n+            }\n+        }\n+        String value = \"\";\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TYPE_POWER:\n+                if (command instanceof OnOffType) {\n+                    value = ((OnOffType) command == OnOffType.ON) ? \"ON\" : \"OFF\";", "originalCommit": "8ea1d268bbd9b48e69875641212d0bc824aba056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc1Njk4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507756986", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-19T13:43:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzODE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzOTAzOA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r504139038", "bodyText": "You could use the Math function.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (doubleValue < minTemp) {\n          \n          \n            \n                                        doubleValue = minTemp;\n          \n          \n            \n                                    } else if (doubleValue > maxTemp) {\n          \n          \n            \n                                        doubleValue = maxTemp;\n          \n          \n            \n                                    }\n          \n          \n            \n                                    doubleValue = Math.max(minTemp, Math.min(maxTemp, doubleValue));", "author": "fwolter", "createdAt": "2020-10-13T17:38:31Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/handler/IntesisBoxHandler.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.handler;\n+\n+import static org.openhab.binding.intesis.internal.IntesisBindingConstants.*;\n+import static org.openhab.binding.intesis.internal.api.IntesisBoxMessage.*;\n+import static org.openhab.core.thing.Thing.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.IntesisConfiguration;\n+import org.openhab.binding.intesis.internal.IntesisDynamicStateDescriptionProvider;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxChangeListener;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxIdentity;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxMessage;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxSocketApi;\n+import org.openhab.binding.intesis.internal.enums.IntesisBoxFunctionEnum;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link IntesisBoxHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Rocky Amatulli - additions to include id message handling, dynamic channel options based on limits.\n+ * @author Hans-J\u00f6rg Merk - refactored for openHAB 3.0 compatibility\n+ *\n+ */\n+@NonNullByDefault\n+public class IntesisBoxHandler extends BaseThingHandler implements IntesisBoxChangeListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxHandler.class);\n+    private @Nullable IntesisBoxSocketApi intesisBoxSocketApi;\n+\n+    private final Map<String, String> properties = new HashMap<>();\n+    private final Map<String, List<String>> limits = new HashMap<String, List<String>>();\n+\n+    private final IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider;\n+\n+    private IntesisConfiguration config = new IntesisConfiguration();\n+\n+    private double minTemp = 0.0d, maxTemp = 0.0d;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+\n+    public IntesisBoxHandler(Thing thing, IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider) {\n+        super(thing);\n+        this.intesisStateDescriptionProvider = intesisStateDescriptionProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(IntesisConfiguration.class);\n+\n+        if (!config.ipAddress.isEmpty()) {\n+            intesisBoxSocketApi = new IntesisBoxSocketApi(config.ipAddress, config.port);\n+            intesisBoxSocketApi.addIntesisBoxChangeListener(this);\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+            scheduler.submit(() -> {\n+                try {\n+                    intesisBoxSocketApi.openConnection();\n+                    intesisBoxSocketApi.sendId();\n+                    intesisBoxSocketApi.sendLimitsQuery();\n+                    intesisBoxSocketApi.sendAlive();\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+                pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 3, 45, TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No IP address specified)\");\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> pollingTask = this.pollingTask;\n+\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+\n+        if (pollingTask != null) {\n+            pollingTask.cancel(true);\n+            this.pollingTask = null;\n+        }\n+        if (api != null) {\n+            api.closeConnection();\n+        }\n+        super.dispose();\n+    }\n+\n+    private synchronized void polling() {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                try {\n+                    api.openConnection();\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+            }\n+            api.sendAlive();\n+            ;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                logger.trace(\"Sending command failed, not connected\");\n+                return;\n+            }\n+            if (command instanceof RefreshType) {\n+                logger.warn(\"Refresh channel {}\", channelUID.getId());\n+                api.sendQuery(channelUID.getId());\n+                return;\n+            }\n+        }\n+        String value = \"\";\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TYPE_POWER:\n+                if (command instanceof OnOffType) {\n+                    value = ((OnOffType) command == OnOffType.ON) ? \"ON\" : \"OFF\";\n+                }\n+                break;\n+            case CHANNEL_TYPE_TARGETTEMP:\n+                if (command instanceof QuantityType) {\n+                    QuantityType<?> celsiusTemperature = (QuantityType<?>) command;\n+                    celsiusTemperature = celsiusTemperature.toUnit(SIUnits.CELSIUS);\n+                    if (celsiusTemperature != null) {\n+                        double doubleValue = celsiusTemperature.doubleValue();\n+                        if (doubleValue < minTemp) {\n+                            doubleValue = minTemp;\n+                        } else if (doubleValue > maxTemp) {\n+                            doubleValue = maxTemp;\n+                        }", "originalCommit": "8ea1d268bbd9b48e69875641212d0bc824aba056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc1Nzg4OA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507757888", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-19T13:44:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzOTAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE0MjE1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r504142151", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    value = String.valueOf((int) Math.round(doubleValue * 10));\n          \n          \n            \n                                    value = String.format(\"%.0f\", doubleValue * 10);", "author": "fwolter", "createdAt": "2020-10-13T17:44:19Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/handler/IntesisBoxHandler.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.handler;\n+\n+import static org.openhab.binding.intesis.internal.IntesisBindingConstants.*;\n+import static org.openhab.binding.intesis.internal.api.IntesisBoxMessage.*;\n+import static org.openhab.core.thing.Thing.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.IntesisConfiguration;\n+import org.openhab.binding.intesis.internal.IntesisDynamicStateDescriptionProvider;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxChangeListener;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxIdentity;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxMessage;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxSocketApi;\n+import org.openhab.binding.intesis.internal.enums.IntesisBoxFunctionEnum;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link IntesisBoxHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Rocky Amatulli - additions to include id message handling, dynamic channel options based on limits.\n+ * @author Hans-J\u00f6rg Merk - refactored for openHAB 3.0 compatibility\n+ *\n+ */\n+@NonNullByDefault\n+public class IntesisBoxHandler extends BaseThingHandler implements IntesisBoxChangeListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxHandler.class);\n+    private @Nullable IntesisBoxSocketApi intesisBoxSocketApi;\n+\n+    private final Map<String, String> properties = new HashMap<>();\n+    private final Map<String, List<String>> limits = new HashMap<String, List<String>>();\n+\n+    private final IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider;\n+\n+    private IntesisConfiguration config = new IntesisConfiguration();\n+\n+    private double minTemp = 0.0d, maxTemp = 0.0d;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+\n+    public IntesisBoxHandler(Thing thing, IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider) {\n+        super(thing);\n+        this.intesisStateDescriptionProvider = intesisStateDescriptionProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(IntesisConfiguration.class);\n+\n+        if (!config.ipAddress.isEmpty()) {\n+            intesisBoxSocketApi = new IntesisBoxSocketApi(config.ipAddress, config.port);\n+            intesisBoxSocketApi.addIntesisBoxChangeListener(this);\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+            scheduler.submit(() -> {\n+                try {\n+                    intesisBoxSocketApi.openConnection();\n+                    intesisBoxSocketApi.sendId();\n+                    intesisBoxSocketApi.sendLimitsQuery();\n+                    intesisBoxSocketApi.sendAlive();\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+                pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 3, 45, TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No IP address specified)\");\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> pollingTask = this.pollingTask;\n+\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+\n+        if (pollingTask != null) {\n+            pollingTask.cancel(true);\n+            this.pollingTask = null;\n+        }\n+        if (api != null) {\n+            api.closeConnection();\n+        }\n+        super.dispose();\n+    }\n+\n+    private synchronized void polling() {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                try {\n+                    api.openConnection();\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+            }\n+            api.sendAlive();\n+            ;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                logger.trace(\"Sending command failed, not connected\");\n+                return;\n+            }\n+            if (command instanceof RefreshType) {\n+                logger.warn(\"Refresh channel {}\", channelUID.getId());\n+                api.sendQuery(channelUID.getId());\n+                return;\n+            }\n+        }\n+        String value = \"\";\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TYPE_POWER:\n+                if (command instanceof OnOffType) {\n+                    value = ((OnOffType) command == OnOffType.ON) ? \"ON\" : \"OFF\";\n+                }\n+                break;\n+            case CHANNEL_TYPE_TARGETTEMP:\n+                if (command instanceof QuantityType) {\n+                    QuantityType<?> celsiusTemperature = (QuantityType<?>) command;\n+                    celsiusTemperature = celsiusTemperature.toUnit(SIUnits.CELSIUS);\n+                    if (celsiusTemperature != null) {\n+                        double doubleValue = celsiusTemperature.doubleValue();\n+                        if (doubleValue < minTemp) {\n+                            doubleValue = minTemp;\n+                        } else if (doubleValue > maxTemp) {\n+                            doubleValue = maxTemp;\n+                        }\n+                        value = String.valueOf((int) Math.round(doubleValue * 10));", "originalCommit": "8ea1d268bbd9b48e69875641212d0bc824aba056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc2MDQzOA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507760438", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-19T13:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE0MjE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE0MjY5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r504142699", "bodyText": "This could be warn", "author": "fwolter", "createdAt": "2020-10-13T17:45:17Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/handler/IntesisBoxHandler.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.handler;\n+\n+import static org.openhab.binding.intesis.internal.IntesisBindingConstants.*;\n+import static org.openhab.binding.intesis.internal.api.IntesisBoxMessage.*;\n+import static org.openhab.core.thing.Thing.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.IntesisConfiguration;\n+import org.openhab.binding.intesis.internal.IntesisDynamicStateDescriptionProvider;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxChangeListener;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxIdentity;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxMessage;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxSocketApi;\n+import org.openhab.binding.intesis.internal.enums.IntesisBoxFunctionEnum;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link IntesisBoxHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Rocky Amatulli - additions to include id message handling, dynamic channel options based on limits.\n+ * @author Hans-J\u00f6rg Merk - refactored for openHAB 3.0 compatibility\n+ *\n+ */\n+@NonNullByDefault\n+public class IntesisBoxHandler extends BaseThingHandler implements IntesisBoxChangeListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxHandler.class);\n+    private @Nullable IntesisBoxSocketApi intesisBoxSocketApi;\n+\n+    private final Map<String, String> properties = new HashMap<>();\n+    private final Map<String, List<String>> limits = new HashMap<String, List<String>>();\n+\n+    private final IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider;\n+\n+    private IntesisConfiguration config = new IntesisConfiguration();\n+\n+    private double minTemp = 0.0d, maxTemp = 0.0d;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+\n+    public IntesisBoxHandler(Thing thing, IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider) {\n+        super(thing);\n+        this.intesisStateDescriptionProvider = intesisStateDescriptionProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(IntesisConfiguration.class);\n+\n+        if (!config.ipAddress.isEmpty()) {\n+            intesisBoxSocketApi = new IntesisBoxSocketApi(config.ipAddress, config.port);\n+            intesisBoxSocketApi.addIntesisBoxChangeListener(this);\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+            scheduler.submit(() -> {\n+                try {\n+                    intesisBoxSocketApi.openConnection();\n+                    intesisBoxSocketApi.sendId();\n+                    intesisBoxSocketApi.sendLimitsQuery();\n+                    intesisBoxSocketApi.sendAlive();\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+                pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 3, 45, TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No IP address specified)\");\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> pollingTask = this.pollingTask;\n+\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+\n+        if (pollingTask != null) {\n+            pollingTask.cancel(true);\n+            this.pollingTask = null;\n+        }\n+        if (api != null) {\n+            api.closeConnection();\n+        }\n+        super.dispose();\n+    }\n+\n+    private synchronized void polling() {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                try {\n+                    api.openConnection();\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+            }\n+            api.sendAlive();\n+            ;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                logger.trace(\"Sending command failed, not connected\");\n+                return;\n+            }\n+            if (command instanceof RefreshType) {\n+                logger.warn(\"Refresh channel {}\", channelUID.getId());\n+                api.sendQuery(channelUID.getId());\n+                return;\n+            }\n+        }\n+        String value = \"\";\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TYPE_POWER:\n+                if (command instanceof OnOffType) {\n+                    value = ((OnOffType) command == OnOffType.ON) ? \"ON\" : \"OFF\";\n+                }\n+                break;\n+            case CHANNEL_TYPE_TARGETTEMP:\n+                if (command instanceof QuantityType) {\n+                    QuantityType<?> celsiusTemperature = (QuantityType<?>) command;\n+                    celsiusTemperature = celsiusTemperature.toUnit(SIUnits.CELSIUS);\n+                    if (celsiusTemperature != null) {\n+                        double doubleValue = celsiusTemperature.doubleValue();\n+                        if (doubleValue < minTemp) {\n+                            doubleValue = minTemp;\n+                        } else if (doubleValue > maxTemp) {\n+                            doubleValue = maxTemp;\n+                        }\n+                        value = String.valueOf((int) Math.round(doubleValue * 10));\n+                    }\n+                }\n+                break;\n+            case CHANNEL_TYPE_MODE:\n+            case CHANNEL_TYPE_FANSPEED:\n+            case CHANNEL_TYPE_VANESUD:\n+            case CHANNEL_TYPE_VANESLR:\n+                value = command.toString();\n+                break;\n+        }\n+        if (!value.isEmpty()) {\n+            String function = IntesisBoxFunctionEnum.valueOf(channelUID.getId()).getFunction();\n+            if (api != null) {\n+                logger.trace(\"Sending command {} to function {}\", value, function);\n+                api.sendCommand(function, value);\n+            } else {\n+                logger.trace(\"Sending command failed, could not get API\");", "originalCommit": "8ea1d268bbd9b48e69875641212d0bc824aba056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc1ODMwMA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507758300", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-19T13:45:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE0MjY5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE0NDE5NA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r504144194", "bodyText": "It's bad practice to modify method arguments. That's why the compiler complains. Better create a new local variable for it.", "author": "fwolter", "createdAt": "2020-10-13T17:47:33Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/handler/IntesisBoxHandler.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.handler;\n+\n+import static org.openhab.binding.intesis.internal.IntesisBindingConstants.*;\n+import static org.openhab.binding.intesis.internal.api.IntesisBoxMessage.*;\n+import static org.openhab.core.thing.Thing.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.IntesisConfiguration;\n+import org.openhab.binding.intesis.internal.IntesisDynamicStateDescriptionProvider;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxChangeListener;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxIdentity;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxMessage;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxSocketApi;\n+import org.openhab.binding.intesis.internal.enums.IntesisBoxFunctionEnum;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link IntesisBoxHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Rocky Amatulli - additions to include id message handling, dynamic channel options based on limits.\n+ * @author Hans-J\u00f6rg Merk - refactored for openHAB 3.0 compatibility\n+ *\n+ */\n+@NonNullByDefault\n+public class IntesisBoxHandler extends BaseThingHandler implements IntesisBoxChangeListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxHandler.class);\n+    private @Nullable IntesisBoxSocketApi intesisBoxSocketApi;\n+\n+    private final Map<String, String> properties = new HashMap<>();\n+    private final Map<String, List<String>> limits = new HashMap<String, List<String>>();\n+\n+    private final IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider;\n+\n+    private IntesisConfiguration config = new IntesisConfiguration();\n+\n+    private double minTemp = 0.0d, maxTemp = 0.0d;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+\n+    public IntesisBoxHandler(Thing thing, IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider) {\n+        super(thing);\n+        this.intesisStateDescriptionProvider = intesisStateDescriptionProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(IntesisConfiguration.class);\n+\n+        if (!config.ipAddress.isEmpty()) {\n+            intesisBoxSocketApi = new IntesisBoxSocketApi(config.ipAddress, config.port);\n+            intesisBoxSocketApi.addIntesisBoxChangeListener(this);\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+            scheduler.submit(() -> {\n+                try {\n+                    intesisBoxSocketApi.openConnection();\n+                    intesisBoxSocketApi.sendId();\n+                    intesisBoxSocketApi.sendLimitsQuery();\n+                    intesisBoxSocketApi.sendAlive();\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+                pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 3, 45, TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No IP address specified)\");\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> pollingTask = this.pollingTask;\n+\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+\n+        if (pollingTask != null) {\n+            pollingTask.cancel(true);\n+            this.pollingTask = null;\n+        }\n+        if (api != null) {\n+            api.closeConnection();\n+        }\n+        super.dispose();\n+    }\n+\n+    private synchronized void polling() {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                try {\n+                    api.openConnection();\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+            }\n+            api.sendAlive();\n+            ;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                logger.trace(\"Sending command failed, not connected\");\n+                return;\n+            }\n+            if (command instanceof RefreshType) {\n+                logger.warn(\"Refresh channel {}\", channelUID.getId());\n+                api.sendQuery(channelUID.getId());\n+                return;\n+            }\n+        }\n+        String value = \"\";\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TYPE_POWER:\n+                if (command instanceof OnOffType) {\n+                    value = ((OnOffType) command == OnOffType.ON) ? \"ON\" : \"OFF\";\n+                }\n+                break;\n+            case CHANNEL_TYPE_TARGETTEMP:\n+                if (command instanceof QuantityType) {\n+                    QuantityType<?> celsiusTemperature = (QuantityType<?>) command;\n+                    celsiusTemperature = celsiusTemperature.toUnit(SIUnits.CELSIUS);\n+                    if (celsiusTemperature != null) {\n+                        double doubleValue = celsiusTemperature.doubleValue();\n+                        if (doubleValue < minTemp) {\n+                            doubleValue = minTemp;\n+                        } else if (doubleValue > maxTemp) {\n+                            doubleValue = maxTemp;\n+                        }\n+                        value = String.valueOf((int) Math.round(doubleValue * 10));\n+                    }\n+                }\n+                break;\n+            case CHANNEL_TYPE_MODE:\n+            case CHANNEL_TYPE_FANSPEED:\n+            case CHANNEL_TYPE_VANESUD:\n+            case CHANNEL_TYPE_VANESLR:\n+                value = command.toString();\n+                break;\n+        }\n+        if (!value.isEmpty()) {\n+            String function = IntesisBoxFunctionEnum.valueOf(channelUID.getId()).getFunction();\n+            if (api != null) {\n+                logger.trace(\"Sending command {} to function {}\", value, function);\n+                api.sendCommand(function, value);\n+            } else {\n+                logger.trace(\"Sending command failed, could not get API\");\n+            }\n+        }\n+    }\n+\n+    private void receivedId(String function, String value) {\n+        logger.trace(\"receivedID(): {} {}\", function, value);\n+        properties.put(PROPERTY_VENDOR, \"Intesis\");\n+        switch (function) {\n+            case \"MODEL\":\n+                properties.put(PROPERTY_MODEL_ID, value);\n+                break;\n+            case \"MAC\":\n+                properties.put(PROPERTY_MAC_ADDRESS, value);\n+                break;\n+            case \"IP\":\n+                properties.put(\"ipAddress\", value);\n+            case \"PROTOCOL\":\n+                properties.put(\"protocol\", value);\n+                break;\n+            case \"VERSION\":\n+                properties.put(PROPERTY_FIRMWARE_VERSION, value);\n+                break;\n+            case \"RSSI\":\n+                properties.put(\"rssi\", value);\n+                break;\n+            case \"NAME\":\n+                properties.put(\"hostname\", value);\n+                break;\n+        }\n+    }\n+\n+    private void receivedUpdate(String function, String value) {\n+        logger.trace(\"receivedUpdate(): {} {}\", function, value);\n+        switch (function) {\n+            case \"ONOFF\":\n+                updateState(CHANNEL_TYPE_POWER, OnOffType.from(value));\n+                break;\n+\n+            case \"SETPTEMP\":\n+                if (value.equals(\"32768\")) {\n+                    value = \"0\";", "originalCommit": "8ea1d268bbd9b48e69875641212d0bc824aba056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc1OTc0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507759742", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-19T13:47:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE0NDE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE0NTEyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r504145129", "bodyText": "parse() returns Nullable. You could declare its return value as NonNull or do a null check here.", "author": "fwolter", "createdAt": "2020-10-13T17:48:37Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/handler/IntesisBoxHandler.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.handler;\n+\n+import static org.openhab.binding.intesis.internal.IntesisBindingConstants.*;\n+import static org.openhab.binding.intesis.internal.api.IntesisBoxMessage.*;\n+import static org.openhab.core.thing.Thing.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.IntesisConfiguration;\n+import org.openhab.binding.intesis.internal.IntesisDynamicStateDescriptionProvider;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxChangeListener;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxIdentity;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxMessage;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxSocketApi;\n+import org.openhab.binding.intesis.internal.enums.IntesisBoxFunctionEnum;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link IntesisBoxHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Rocky Amatulli - additions to include id message handling, dynamic channel options based on limits.\n+ * @author Hans-J\u00f6rg Merk - refactored for openHAB 3.0 compatibility\n+ *\n+ */\n+@NonNullByDefault\n+public class IntesisBoxHandler extends BaseThingHandler implements IntesisBoxChangeListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxHandler.class);\n+    private @Nullable IntesisBoxSocketApi intesisBoxSocketApi;\n+\n+    private final Map<String, String> properties = new HashMap<>();\n+    private final Map<String, List<String>> limits = new HashMap<String, List<String>>();\n+\n+    private final IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider;\n+\n+    private IntesisConfiguration config = new IntesisConfiguration();\n+\n+    private double minTemp = 0.0d, maxTemp = 0.0d;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+\n+    public IntesisBoxHandler(Thing thing, IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider) {\n+        super(thing);\n+        this.intesisStateDescriptionProvider = intesisStateDescriptionProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(IntesisConfiguration.class);\n+\n+        if (!config.ipAddress.isEmpty()) {\n+            intesisBoxSocketApi = new IntesisBoxSocketApi(config.ipAddress, config.port);\n+            intesisBoxSocketApi.addIntesisBoxChangeListener(this);\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+            scheduler.submit(() -> {\n+                try {\n+                    intesisBoxSocketApi.openConnection();\n+                    intesisBoxSocketApi.sendId();\n+                    intesisBoxSocketApi.sendLimitsQuery();\n+                    intesisBoxSocketApi.sendAlive();\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+                pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 3, 45, TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No IP address specified)\");\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> pollingTask = this.pollingTask;\n+\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+\n+        if (pollingTask != null) {\n+            pollingTask.cancel(true);\n+            this.pollingTask = null;\n+        }\n+        if (api != null) {\n+            api.closeConnection();\n+        }\n+        super.dispose();\n+    }\n+\n+    private synchronized void polling() {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                try {\n+                    api.openConnection();\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+            }\n+            api.sendAlive();\n+            ;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                logger.trace(\"Sending command failed, not connected\");\n+                return;\n+            }\n+            if (command instanceof RefreshType) {\n+                logger.warn(\"Refresh channel {}\", channelUID.getId());\n+                api.sendQuery(channelUID.getId());\n+                return;\n+            }\n+        }\n+        String value = \"\";\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TYPE_POWER:\n+                if (command instanceof OnOffType) {\n+                    value = ((OnOffType) command == OnOffType.ON) ? \"ON\" : \"OFF\";\n+                }\n+                break;\n+            case CHANNEL_TYPE_TARGETTEMP:\n+                if (command instanceof QuantityType) {\n+                    QuantityType<?> celsiusTemperature = (QuantityType<?>) command;\n+                    celsiusTemperature = celsiusTemperature.toUnit(SIUnits.CELSIUS);\n+                    if (celsiusTemperature != null) {\n+                        double doubleValue = celsiusTemperature.doubleValue();\n+                        if (doubleValue < minTemp) {\n+                            doubleValue = minTemp;\n+                        } else if (doubleValue > maxTemp) {\n+                            doubleValue = maxTemp;\n+                        }\n+                        value = String.valueOf((int) Math.round(doubleValue * 10));\n+                    }\n+                }\n+                break;\n+            case CHANNEL_TYPE_MODE:\n+            case CHANNEL_TYPE_FANSPEED:\n+            case CHANNEL_TYPE_VANESUD:\n+            case CHANNEL_TYPE_VANESLR:\n+                value = command.toString();\n+                break;\n+        }\n+        if (!value.isEmpty()) {\n+            String function = IntesisBoxFunctionEnum.valueOf(channelUID.getId()).getFunction();\n+            if (api != null) {\n+                logger.trace(\"Sending command {} to function {}\", value, function);\n+                api.sendCommand(function, value);\n+            } else {\n+                logger.trace(\"Sending command failed, could not get API\");\n+            }\n+        }\n+    }\n+\n+    private void receivedId(String function, String value) {\n+        logger.trace(\"receivedID(): {} {}\", function, value);\n+        properties.put(PROPERTY_VENDOR, \"Intesis\");\n+        switch (function) {\n+            case \"MODEL\":\n+                properties.put(PROPERTY_MODEL_ID, value);\n+                break;\n+            case \"MAC\":\n+                properties.put(PROPERTY_MAC_ADDRESS, value);\n+                break;\n+            case \"IP\":\n+                properties.put(\"ipAddress\", value);\n+            case \"PROTOCOL\":\n+                properties.put(\"protocol\", value);\n+                break;\n+            case \"VERSION\":\n+                properties.put(PROPERTY_FIRMWARE_VERSION, value);\n+                break;\n+            case \"RSSI\":\n+                properties.put(\"rssi\", value);\n+                break;\n+            case \"NAME\":\n+                properties.put(\"hostname\", value);\n+                break;\n+        }\n+    }\n+\n+    private void receivedUpdate(String function, String value) {\n+        logger.trace(\"receivedUpdate(): {} {}\", function, value);\n+        switch (function) {\n+            case \"ONOFF\":\n+                updateState(CHANNEL_TYPE_POWER, OnOffType.from(value));\n+                break;\n+\n+            case \"SETPTEMP\":\n+                if (value.equals(\"32768\")) {\n+                    value = \"0\";\n+                }\n+                updateState(CHANNEL_TYPE_TARGETTEMP,\n+                        new QuantityType<Temperature>(Double.valueOf(value) / 10.0d, SIUnits.CELSIUS));\n+                break;\n+            case \"AMBTEMP\":\n+                if (Double.valueOf(value).isNaN()) {\n+                    value = \"0\";\n+                }\n+                updateState(CHANNEL_TYPE_AMBIENTTEMP,\n+                        new QuantityType<Temperature>(Double.valueOf(value) / 10.0d, SIUnits.CELSIUS));\n+                break;\n+            case \"MODE\":\n+                updateState(CHANNEL_TYPE_MODE, new StringType(value));\n+                break;\n+            case \"FANSP\":\n+                updateState(CHANNEL_TYPE_FANSPEED, new StringType(value));\n+                break;\n+            case \"VANEUD\":\n+                updateState(CHANNEL_TYPE_VANESUD, new StringType(value));\n+                break;\n+            case \"VANELR\":\n+                updateState(CHANNEL_TYPE_VANESLR, new StringType(value));\n+                break;\n+            case \"ERRCODE\":\n+                properties.put(\"errorCode\", value);\n+                updateProperties(properties);\n+                break;\n+            case \"ERRSTATUS\":\n+                properties.put(\"errorStatus\", value);\n+                updateProperties(properties);\n+                if (\"ERR\".equals(value)) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"device reported an error\");\n+                }\n+                break;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    private void handleMessage(String data) {\n+        logger.trace(\"handleMessage(): Message received - {}\", data);\n+        if (data.equals(\"ACK\") || data.equals(\"\")) {\n+            return;\n+        }\n+        if (data.startsWith(ID + ':')) {\n+            synchronized (this) {\n+                new IntesisBoxIdentity(data).value.forEach((name, value) -> receivedId(name, value));\n+                return;\n+            }\n+        }\n+        IntesisBoxMessage message = IntesisBoxMessage.parse(data);\n+        switch (message.getCommand()) {", "originalCommit": "8ea1d268bbd9b48e69875641212d0bc824aba056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc2MjAwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507762005", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-19T13:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE0NTEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE0NzEyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r504147122", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        (mode.substring(0, 1).toUpperCase() + mode.substring(1).toLowerCase())));\n          \n          \n            \n                                        mode.substring(0, 1).toUpperCase() + mode.substring(1).toLowerCase()));", "author": "fwolter", "createdAt": "2020-10-13T17:52:12Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/handler/IntesisBoxHandler.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.handler;\n+\n+import static org.openhab.binding.intesis.internal.IntesisBindingConstants.*;\n+import static org.openhab.binding.intesis.internal.api.IntesisBoxMessage.*;\n+import static org.openhab.core.thing.Thing.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.IntesisConfiguration;\n+import org.openhab.binding.intesis.internal.IntesisDynamicStateDescriptionProvider;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxChangeListener;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxIdentity;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxMessage;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxSocketApi;\n+import org.openhab.binding.intesis.internal.enums.IntesisBoxFunctionEnum;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link IntesisBoxHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Rocky Amatulli - additions to include id message handling, dynamic channel options based on limits.\n+ * @author Hans-J\u00f6rg Merk - refactored for openHAB 3.0 compatibility\n+ *\n+ */\n+@NonNullByDefault\n+public class IntesisBoxHandler extends BaseThingHandler implements IntesisBoxChangeListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxHandler.class);\n+    private @Nullable IntesisBoxSocketApi intesisBoxSocketApi;\n+\n+    private final Map<String, String> properties = new HashMap<>();\n+    private final Map<String, List<String>> limits = new HashMap<String, List<String>>();\n+\n+    private final IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider;\n+\n+    private IntesisConfiguration config = new IntesisConfiguration();\n+\n+    private double minTemp = 0.0d, maxTemp = 0.0d;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+\n+    public IntesisBoxHandler(Thing thing, IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider) {\n+        super(thing);\n+        this.intesisStateDescriptionProvider = intesisStateDescriptionProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(IntesisConfiguration.class);\n+\n+        if (!config.ipAddress.isEmpty()) {\n+            intesisBoxSocketApi = new IntesisBoxSocketApi(config.ipAddress, config.port);\n+            intesisBoxSocketApi.addIntesisBoxChangeListener(this);\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+            scheduler.submit(() -> {\n+                try {\n+                    intesisBoxSocketApi.openConnection();\n+                    intesisBoxSocketApi.sendId();\n+                    intesisBoxSocketApi.sendLimitsQuery();\n+                    intesisBoxSocketApi.sendAlive();\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+                pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 3, 45, TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No IP address specified)\");\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> pollingTask = this.pollingTask;\n+\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+\n+        if (pollingTask != null) {\n+            pollingTask.cancel(true);\n+            this.pollingTask = null;\n+        }\n+        if (api != null) {\n+            api.closeConnection();\n+        }\n+        super.dispose();\n+    }\n+\n+    private synchronized void polling() {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                try {\n+                    api.openConnection();\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+            }\n+            api.sendAlive();\n+            ;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                logger.trace(\"Sending command failed, not connected\");\n+                return;\n+            }\n+            if (command instanceof RefreshType) {\n+                logger.warn(\"Refresh channel {}\", channelUID.getId());\n+                api.sendQuery(channelUID.getId());\n+                return;\n+            }\n+        }\n+        String value = \"\";\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TYPE_POWER:\n+                if (command instanceof OnOffType) {\n+                    value = ((OnOffType) command == OnOffType.ON) ? \"ON\" : \"OFF\";\n+                }\n+                break;\n+            case CHANNEL_TYPE_TARGETTEMP:\n+                if (command instanceof QuantityType) {\n+                    QuantityType<?> celsiusTemperature = (QuantityType<?>) command;\n+                    celsiusTemperature = celsiusTemperature.toUnit(SIUnits.CELSIUS);\n+                    if (celsiusTemperature != null) {\n+                        double doubleValue = celsiusTemperature.doubleValue();\n+                        if (doubleValue < minTemp) {\n+                            doubleValue = minTemp;\n+                        } else if (doubleValue > maxTemp) {\n+                            doubleValue = maxTemp;\n+                        }\n+                        value = String.valueOf((int) Math.round(doubleValue * 10));\n+                    }\n+                }\n+                break;\n+            case CHANNEL_TYPE_MODE:\n+            case CHANNEL_TYPE_FANSPEED:\n+            case CHANNEL_TYPE_VANESUD:\n+            case CHANNEL_TYPE_VANESLR:\n+                value = command.toString();\n+                break;\n+        }\n+        if (!value.isEmpty()) {\n+            String function = IntesisBoxFunctionEnum.valueOf(channelUID.getId()).getFunction();\n+            if (api != null) {\n+                logger.trace(\"Sending command {} to function {}\", value, function);\n+                api.sendCommand(function, value);\n+            } else {\n+                logger.trace(\"Sending command failed, could not get API\");\n+            }\n+        }\n+    }\n+\n+    private void receivedId(String function, String value) {\n+        logger.trace(\"receivedID(): {} {}\", function, value);\n+        properties.put(PROPERTY_VENDOR, \"Intesis\");\n+        switch (function) {\n+            case \"MODEL\":\n+                properties.put(PROPERTY_MODEL_ID, value);\n+                break;\n+            case \"MAC\":\n+                properties.put(PROPERTY_MAC_ADDRESS, value);\n+                break;\n+            case \"IP\":\n+                properties.put(\"ipAddress\", value);\n+            case \"PROTOCOL\":\n+                properties.put(\"protocol\", value);\n+                break;\n+            case \"VERSION\":\n+                properties.put(PROPERTY_FIRMWARE_VERSION, value);\n+                break;\n+            case \"RSSI\":\n+                properties.put(\"rssi\", value);\n+                break;\n+            case \"NAME\":\n+                properties.put(\"hostname\", value);\n+                break;\n+        }\n+    }\n+\n+    private void receivedUpdate(String function, String value) {\n+        logger.trace(\"receivedUpdate(): {} {}\", function, value);\n+        switch (function) {\n+            case \"ONOFF\":\n+                updateState(CHANNEL_TYPE_POWER, OnOffType.from(value));\n+                break;\n+\n+            case \"SETPTEMP\":\n+                if (value.equals(\"32768\")) {\n+                    value = \"0\";\n+                }\n+                updateState(CHANNEL_TYPE_TARGETTEMP,\n+                        new QuantityType<Temperature>(Double.valueOf(value) / 10.0d, SIUnits.CELSIUS));\n+                break;\n+            case \"AMBTEMP\":\n+                if (Double.valueOf(value).isNaN()) {\n+                    value = \"0\";\n+                }\n+                updateState(CHANNEL_TYPE_AMBIENTTEMP,\n+                        new QuantityType<Temperature>(Double.valueOf(value) / 10.0d, SIUnits.CELSIUS));\n+                break;\n+            case \"MODE\":\n+                updateState(CHANNEL_TYPE_MODE, new StringType(value));\n+                break;\n+            case \"FANSP\":\n+                updateState(CHANNEL_TYPE_FANSPEED, new StringType(value));\n+                break;\n+            case \"VANEUD\":\n+                updateState(CHANNEL_TYPE_VANESUD, new StringType(value));\n+                break;\n+            case \"VANELR\":\n+                updateState(CHANNEL_TYPE_VANESLR, new StringType(value));\n+                break;\n+            case \"ERRCODE\":\n+                properties.put(\"errorCode\", value);\n+                updateProperties(properties);\n+                break;\n+            case \"ERRSTATUS\":\n+                properties.put(\"errorStatus\", value);\n+                updateProperties(properties);\n+                if (\"ERR\".equals(value)) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"device reported an error\");\n+                }\n+                break;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    private void handleMessage(String data) {\n+        logger.trace(\"handleMessage(): Message received - {}\", data);\n+        if (data.equals(\"ACK\") || data.equals(\"\")) {\n+            return;\n+        }\n+        if (data.startsWith(ID + ':')) {\n+            synchronized (this) {\n+                new IntesisBoxIdentity(data).value.forEach((name, value) -> receivedId(name, value));\n+                return;\n+            }\n+        }\n+        IntesisBoxMessage message = IntesisBoxMessage.parse(data);\n+        switch (message.getCommand()) {\n+            case LIMITS:\n+                logger.trace(\"handleMessage(): Limits received - {}\", data);\n+                synchronized (this) {\n+                    String function = message.getFunction();\n+                    if (function.equals(\"SETPTEMP\")) {\n+                        List<Double> limits = message.getLimitsValue().stream().map(l -> Double.valueOf(l) / 10.0d)\n+                                .collect(Collectors.toList());\n+                        if (limits.size() == 2) {\n+                            minTemp = limits.get(0);\n+                            maxTemp = limits.get(1);\n+                        }\n+                        logger.trace(\"Property target temperatures {} added\", message.getValue());\n+                        properties.put(\"targetTemperature limits\", \"[\" + minTemp + \",\" + maxTemp + \"]\");\n+                        addChannel(CHANNEL_TYPE_TARGETTEMP, \"Number:Temperature\");\n+                    } else {\n+                        switch (function) {\n+                            case \"MODE\":\n+                                properties.put(\"supported modes\", message.getValue());\n+                                limits.put(CHANNEL_TYPE_MODE, message.getLimitsValue());\n+                                addChannel(CHANNEL_TYPE_MODE, \"String\");\n+                                break;\n+                            case \"FANSP\":\n+                                properties.put(\"supported fan levels\", message.getValue());\n+                                limits.put(CHANNEL_TYPE_FANSPEED, message.getLimitsValue());\n+                                addChannel(CHANNEL_TYPE_FANSPEED, \"String\");\n+                                break;\n+                            case \"VANEUD\":\n+                                properties.put(\"supported vane up/down modes\", message.getValue());\n+                                limits.put(CHANNEL_TYPE_VANESUD, message.getLimitsValue());\n+                                addChannel(CHANNEL_TYPE_VANESUD, \"String\");\n+                                break;\n+                            case \"VANELR\":\n+                                properties.put(\"supported vane left/right modes\", message.getValue());\n+                                limits.put(CHANNEL_TYPE_VANESLR, message.getLimitsValue());\n+                                addChannel(CHANNEL_TYPE_VANESLR, \"String\");\n+                                break;\n+                        }\n+                    }\n+                    addChannel(CHANNEL_TYPE_AMBIENTTEMP, \"Number:Temperature\");\n+\n+                }\n+                updateProperties(properties);\n+                break;\n+            case CHN:\n+                receivedUpdate(message.getFunction(), message.getValue());\n+                break;\n+        }\n+    }\n+\n+    public void addChannel(String channelId, String itemType) {\n+        if (thing.getChannel(channelId) == null) {\n+            logger.trace(\"Channel '{}' for UID to be added\", channelId);\n+            ThingBuilder thingBuilder = editThing();\n+            final ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelId);\n+            Channel channel = ChannelBuilder.create(new ChannelUID(getThing().getUID(), channelId), itemType)\n+                    .withType(channelTypeUID).withKind(ChannelKind.STATE).build();\n+            thingBuilder.withChannel(channel);\n+            updateThing(thingBuilder.build());\n+\n+            if (limits.containsKey(channelId)) {\n+                List<StateOption> options = new ArrayList<>();\n+                for (String mode : limits.get(channelId)) {\n+                    options.add(new StateOption(mode,\n+                            (mode.substring(0, 1).toUpperCase() + mode.substring(1).toLowerCase())));", "originalCommit": "8ea1d268bbd9b48e69875641212d0bc824aba056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc2MjU0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507762543", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-19T13:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE0NzEyMg=="}], "type": "inlineReview"}, {"oid": "b255eec678d0820e0a7f3d19899fb83b0917116b", "url": "https://github.com/openhab/openhab-addons/commit/b255eec678d0820e0a7f3d19899fb83b0917116b", "message": "Changes after first review\n\nSigned-off-by: Hans-J\u00f6rg Merk <github@hmerk.de>", "committedDate": "2020-10-19T14:49:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkyMDA0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507920043", "bodyText": "I don't see why you need this class. Just replace it with a utility function.", "author": "cpmeister", "createdAt": "2020-10-19T17:17:04Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/api/IntesisBoxIdentity.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.api;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * @author Rocky Amatulli - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IntesisBoxIdentity {", "originalCommit": "b255eec678d0820e0a7f3d19899fb83b0917116b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAyODkyOA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r509028928", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-21T06:50:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkyMDA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkyMzkwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507923909", "bodyText": "It would be better to parse out the command and function names in their entirety then check that the parsed values are acceptable. That way when you find a mismatch you can log the unexpected value vs not knowing what went wrong.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"^(ID|INFO|SET|CHN|GET|LOGIN|LOGOUT|CFG|LIMITS)(?:,(\\\\d+))?:(APPVERSION|RUNVERSION|CFGVERSION|HASH|ONOFF|MODE|SETPTEMP|FANSP|VANEUD|VANELR|AMBTEMP|ERRSTATUS|ERRCODE),([A-Z0-9.,\\\\[\\\\]]+)$\");\n          \n          \n            \n                        \"^([^,]+)(?:,(\\\\d+))?:([^,]+),([A-Z0-9.,\\\\[\\\\]]+)$\");", "author": "cpmeister", "createdAt": "2020-10-19T17:23:39Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/api/IntesisBoxMessage.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.api;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Cody Cutrer - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IntesisBoxMessage {\n+    public static final String ID = \"ID\";\n+    public static final String INFO = \"INFO\";\n+    public static final String SET = \"SET\";\n+    public static final String CHN = \"CHN\";\n+    public static final String GET = \"GET\";\n+    public static final String LOGIN = \"LOGIN\";\n+    public static final String LOGOUT = \"LOGOUT\";\n+    public static final String CFG = \"CFG\";\n+    public static final String LIMITS = \"LIMITS\";\n+    public static final String DISCOVER = \"DISCOVER\";\n+\n+    private static final Pattern REGEX = Pattern.compile(\n+            \"^(ID|INFO|SET|CHN|GET|LOGIN|LOGOUT|CFG|LIMITS)(?:,(\\\\d+))?:(APPVERSION|RUNVERSION|CFGVERSION|HASH|ONOFF|MODE|SETPTEMP|FANSP|VANEUD|VANELR|AMBTEMP|ERRSTATUS|ERRCODE),([A-Z0-9.,\\\\[\\\\]]+)$\");", "originalCommit": "b255eec678d0820e0a7f3d19899fb83b0917116b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAyOTIyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r509029221", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-21T06:50:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkyMzkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkyNTA1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507925055", "bodyText": "You shouldn't need to check if tcpOutput != null twice.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        if (tcpOutput != null) {", "author": "cpmeister", "createdAt": "2020-10-19T17:25:34Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/api/IntesisBoxSocketApi.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.api;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.ThingStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class handling the Socket connections.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Hans-J\u00f6rg Merk - Moved Socket to it's own class\n+ */\n+@NonNullByDefault\n+public class IntesisBoxSocketApi {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxSocketApi.class);\n+\n+    private final String ipAddress;\n+    private final int port;\n+\n+    private @Nullable IntesisSocket tcpSocket = null;\n+    private @Nullable OutputStreamWriter tcpOutput = null;\n+    private @Nullable BufferedReader tcpInput = null;\n+\n+    private @Nullable IntesisBoxChangeListener changeListener;\n+\n+    private boolean connected = false;\n+\n+    public IntesisBoxSocketApi(final String ipAddress, final int port) {\n+        this.ipAddress = ipAddress;\n+        this.port = port;\n+    }\n+\n+    private class IntesisSocket {\n+        final Socket socket;\n+\n+        public IntesisSocket() throws UnknownHostException, IOException {\n+            socket = new Socket();\n+            SocketAddress tcpSocketAddress = new InetSocketAddress(ipAddress, port);\n+            socket.connect(tcpSocketAddress);\n+        }\n+\n+        public void close() throws IOException {\n+            socket.close();\n+        }\n+    }\n+\n+    public void openConnection() throws IOException {\n+        closeConnection();\n+\n+        IntesisBoxChangeListener listener = this.changeListener;\n+        IntesisSocket localSocket = tcpSocket = new IntesisSocket();\n+        tcpOutput = new OutputStreamWriter(localSocket.socket.getOutputStream(), \"US-ASCII\");\n+        tcpInput = new BufferedReader(new InputStreamReader(localSocket.socket.getInputStream()));\n+\n+        Thread tcpListener = new Thread(new TCPListener());\n+        tcpListener.start();\n+\n+        setConnected(true);\n+        if (listener != null) {\n+            listener.connectionStatusChanged(ThingStatus.ONLINE, null);\n+        }\n+    }\n+\n+    public void closeConnection() {\n+        try {\n+            if (tcpSocket != null) {\n+                tcpSocket.close();\n+                tcpSocket = null;\n+            }\n+            if (tcpInput != null) {\n+                tcpInput.close();\n+                tcpInput = null;\n+            }\n+            if (tcpOutput != null) {\n+                tcpOutput.close();\n+                tcpOutput = null;\n+            }\n+            setConnected(false);\n+        } catch (IOException ioException) {\n+            logger.debug(\"closeConnection(): Unable to close connection - {}\", ioException.getMessage());\n+        } catch (Exception exception) {\n+            logger.debug(\"closeConnection(): Error closing connection - {}\", exception.getMessage());\n+        }\n+    }\n+\n+    private class TCPListener implements Runnable {\n+\n+        /**\n+         * Run method. Runs the MessageListener thread\n+         */\n+        @Override\n+        public void run() {\n+            while (isConnected()) {\n+                String message = read();\n+                readMessage(message);\n+            }\n+        }\n+    }\n+\n+    public void addIntesisBoxChangeListener(IntesisBoxChangeListener listener) {\n+        if (this.changeListener == null) {\n+            this.changeListener = listener;\n+        }\n+    }\n+\n+    private void write(String data) {\n+        IntesisBoxChangeListener listener = this.changeListener;\n+        try {\n+            if (tcpOutput != null) {\n+                tcpOutput.write(data);\n+            }\n+            if (tcpOutput != null) {", "originalCommit": "b255eec678d0820e0a7f3d19899fb83b0917116b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAyOTk0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r509029944", "bodyText": "If not checked again, Eclipse gives me a potential null pointer warning.", "author": "hmerk", "createdAt": "2020-10-21T06:52:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkyNTA1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzMjUxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r509932511", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-22T07:18:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkyNTA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkyNjMxMw==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507926313", "bodyText": "You should specify a character encoding for the InputStreamReader.", "author": "cpmeister", "createdAt": "2020-10-19T17:27:39Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/api/IntesisBoxSocketApi.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.api;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.ThingStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class handling the Socket connections.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Hans-J\u00f6rg Merk - Moved Socket to it's own class\n+ */\n+@NonNullByDefault\n+public class IntesisBoxSocketApi {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxSocketApi.class);\n+\n+    private final String ipAddress;\n+    private final int port;\n+\n+    private @Nullable IntesisSocket tcpSocket = null;\n+    private @Nullable OutputStreamWriter tcpOutput = null;\n+    private @Nullable BufferedReader tcpInput = null;\n+\n+    private @Nullable IntesisBoxChangeListener changeListener;\n+\n+    private boolean connected = false;\n+\n+    public IntesisBoxSocketApi(final String ipAddress, final int port) {\n+        this.ipAddress = ipAddress;\n+        this.port = port;\n+    }\n+\n+    private class IntesisSocket {\n+        final Socket socket;\n+\n+        public IntesisSocket() throws UnknownHostException, IOException {\n+            socket = new Socket();\n+            SocketAddress tcpSocketAddress = new InetSocketAddress(ipAddress, port);\n+            socket.connect(tcpSocketAddress);\n+        }\n+\n+        public void close() throws IOException {\n+            socket.close();\n+        }\n+    }\n+\n+    public void openConnection() throws IOException {\n+        closeConnection();\n+\n+        IntesisBoxChangeListener listener = this.changeListener;\n+        IntesisSocket localSocket = tcpSocket = new IntesisSocket();\n+        tcpOutput = new OutputStreamWriter(localSocket.socket.getOutputStream(), \"US-ASCII\");\n+        tcpInput = new BufferedReader(new InputStreamReader(localSocket.socket.getInputStream()));", "originalCommit": "b255eec678d0820e0a7f3d19899fb83b0917116b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAzMDY0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r509030645", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-21T06:53:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkyNjMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkyNzIyOA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507927228", "bodyText": "Please give the thread a name that allows debuggers to easily identify this binding as the creator of it.\nAlso please make the thread daemon.", "author": "cpmeister", "createdAt": "2020-10-19T17:29:05Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/api/IntesisBoxSocketApi.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.api;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.ThingStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class handling the Socket connections.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Hans-J\u00f6rg Merk - Moved Socket to it's own class\n+ */\n+@NonNullByDefault\n+public class IntesisBoxSocketApi {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxSocketApi.class);\n+\n+    private final String ipAddress;\n+    private final int port;\n+\n+    private @Nullable IntesisSocket tcpSocket = null;\n+    private @Nullable OutputStreamWriter tcpOutput = null;\n+    private @Nullable BufferedReader tcpInput = null;\n+\n+    private @Nullable IntesisBoxChangeListener changeListener;\n+\n+    private boolean connected = false;\n+\n+    public IntesisBoxSocketApi(final String ipAddress, final int port) {\n+        this.ipAddress = ipAddress;\n+        this.port = port;\n+    }\n+\n+    private class IntesisSocket {\n+        final Socket socket;\n+\n+        public IntesisSocket() throws UnknownHostException, IOException {\n+            socket = new Socket();\n+            SocketAddress tcpSocketAddress = new InetSocketAddress(ipAddress, port);\n+            socket.connect(tcpSocketAddress);\n+        }\n+\n+        public void close() throws IOException {\n+            socket.close();\n+        }\n+    }\n+\n+    public void openConnection() throws IOException {\n+        closeConnection();\n+\n+        IntesisBoxChangeListener listener = this.changeListener;\n+        IntesisSocket localSocket = tcpSocket = new IntesisSocket();\n+        tcpOutput = new OutputStreamWriter(localSocket.socket.getOutputStream(), \"US-ASCII\");\n+        tcpInput = new BufferedReader(new InputStreamReader(localSocket.socket.getInputStream()));\n+\n+        Thread tcpListener = new Thread(new TCPListener());\n+        tcpListener.start();", "originalCommit": "b255eec678d0820e0a7f3d19899fb83b0917116b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAzMzI3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r509033277", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-21T06:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkyNzIyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkyODY3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507928673", "bodyText": "Why is this class needed? It doesn't add any functionality so just keep track of the Socket instead.", "author": "cpmeister", "createdAt": "2020-10-19T17:31:01Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/api/IntesisBoxSocketApi.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.api;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.ThingStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class handling the Socket connections.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Hans-J\u00f6rg Merk - Moved Socket to it's own class\n+ */\n+@NonNullByDefault\n+public class IntesisBoxSocketApi {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxSocketApi.class);\n+\n+    private final String ipAddress;\n+    private final int port;\n+\n+    private @Nullable IntesisSocket tcpSocket = null;\n+    private @Nullable OutputStreamWriter tcpOutput = null;\n+    private @Nullable BufferedReader tcpInput = null;\n+\n+    private @Nullable IntesisBoxChangeListener changeListener;\n+\n+    private boolean connected = false;\n+\n+    public IntesisBoxSocketApi(final String ipAddress, final int port) {\n+        this.ipAddress = ipAddress;\n+        this.port = port;\n+    }\n+\n+    private class IntesisSocket {", "originalCommit": "b255eec678d0820e0a7f3d19899fb83b0917116b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA0MDMxNw==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r509040317", "bodyText": "That's how I saw it in the energenie Binding, which socket class was written by @Hilbrand .  I have no clue of socket handling, so it was simply copy and paste.", "author": "hmerk", "createdAt": "2020-10-21T07:12:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkyODY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkzNTc3MA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507935770", "bodyText": "If you are only using this enum for one-directional lookups, it would be better to define the function as part of the switch statement above. That way you can remove the use of the enum entirely.", "author": "cpmeister", "createdAt": "2020-10-19T17:40:34Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/handler/IntesisBoxHandler.java", "diffHunk": "@@ -0,0 +1,383 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.handler;\n+\n+import static org.openhab.binding.intesis.internal.IntesisBindingConstants.*;\n+import static org.openhab.binding.intesis.internal.api.IntesisBoxMessage.*;\n+import static org.openhab.core.thing.Thing.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.IntesisDynamicStateDescriptionProvider;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxChangeListener;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxIdentity;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxMessage;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxSocketApi;\n+import org.openhab.binding.intesis.internal.config.IntesisBoxConfiguration;\n+import org.openhab.binding.intesis.internal.enums.IntesisBoxFunctionEnum;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link IntesisBoxHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Rocky Amatulli - additions to include id message handling, dynamic channel options based on limits.\n+ * @author Hans-J\u00f6rg Merk - refactored for openHAB 3.0 compatibility\n+ *\n+ */\n+@NonNullByDefault\n+public class IntesisBoxHandler extends BaseThingHandler implements IntesisBoxChangeListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxHandler.class);\n+    private @Nullable IntesisBoxSocketApi intesisBoxSocketApi;\n+\n+    private final Map<String, String> properties = new HashMap<>();\n+    private final Map<String, List<String>> limits = new HashMap<String, List<String>>();\n+\n+    private final IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider;\n+\n+    private IntesisBoxConfiguration config = new IntesisBoxConfiguration();\n+\n+    private double minTemp = 0.0, maxTemp = 0.0;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+\n+    public IntesisBoxHandler(Thing thing, IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider) {\n+        super(thing);\n+        this.intesisStateDescriptionProvider = intesisStateDescriptionProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(IntesisBoxConfiguration.class);\n+\n+        if (!config.ipAddress.isEmpty()) {\n+            intesisBoxSocketApi = new IntesisBoxSocketApi(config.ipAddress, config.port);\n+            intesisBoxSocketApi.addIntesisBoxChangeListener(this);\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+            scheduler.submit(() -> {\n+                try {\n+                    if (intesisBoxSocketApi != null) {\n+                        intesisBoxSocketApi.openConnection();\n+                    }\n+                    if (intesisBoxSocketApi != null) {\n+                        intesisBoxSocketApi.sendId();\n+                    }\n+                    if (intesisBoxSocketApi != null) {\n+                        intesisBoxSocketApi.sendLimitsQuery();\n+                    }\n+                    if (intesisBoxSocketApi != null) {\n+                        intesisBoxSocketApi.sendAlive();\n+                    }\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+                pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 3, 45, TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No IP address specified)\");\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> pollingTask = this.pollingTask;\n+\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+\n+        if (pollingTask != null) {\n+            pollingTask.cancel(true);\n+            this.pollingTask = null;\n+        }\n+        if (api != null) {\n+            api.closeConnection();\n+        }\n+        super.dispose();\n+    }\n+\n+    private synchronized void polling() {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                try {\n+                    api.openConnection();\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+            }\n+            api.sendAlive();\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                logger.trace(\"Sending command failed, not connected\");\n+                return;\n+            }\n+            if (command instanceof RefreshType) {\n+                logger.trace(\"Refresh channel {}\", channelUID.getId());\n+                api.sendQuery(channelUID.getId());\n+                return;\n+            }\n+        }\n+        String value = \"\";\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TYPE_POWER:\n+                if (command instanceof OnOffType) {\n+                    value = command == OnOffType.ON ? \"ON\" : \"OFF\";\n+                }\n+                break;\n+            case CHANNEL_TYPE_TARGETTEMP:\n+                if (command instanceof QuantityType) {\n+                    QuantityType<?> celsiusTemperature = (QuantityType<?>) command;\n+                    celsiusTemperature = celsiusTemperature.toUnit(SIUnits.CELSIUS);\n+                    if (celsiusTemperature != null) {\n+                        double doubleValue = celsiusTemperature.doubleValue();\n+                        logger.trace(\"targetTemp double value = {}\", doubleValue);\n+                        doubleValue = Math.max(minTemp, Math.min(maxTemp, doubleValue));\n+                        value = String.format(\"%.0f\", doubleValue * 10);\n+                        logger.trace(\"targetTemp raw string = {}\", value);\n+                    }\n+                }\n+                break;\n+            case CHANNEL_TYPE_MODE:\n+            case CHANNEL_TYPE_FANSPEED:\n+            case CHANNEL_TYPE_VANESUD:\n+            case CHANNEL_TYPE_VANESLR:\n+                value = command.toString();\n+                break;\n+        }\n+        if (!value.isEmpty()) {\n+            String function = IntesisBoxFunctionEnum.valueOf(channelUID.getId()).getFunction();", "originalCommit": "b255eec678d0820e0a7f3d19899fb83b0917116b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAzNzY4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r509037682", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-21T07:08:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkzNTc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkzODY3OA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507938678", "bodyText": "Why are errorCode and errorStatus properties instead of channels?", "author": "cpmeister", "createdAt": "2020-10-19T17:43:07Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/handler/IntesisBoxHandler.java", "diffHunk": "@@ -0,0 +1,383 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.handler;\n+\n+import static org.openhab.binding.intesis.internal.IntesisBindingConstants.*;\n+import static org.openhab.binding.intesis.internal.api.IntesisBoxMessage.*;\n+import static org.openhab.core.thing.Thing.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.IntesisDynamicStateDescriptionProvider;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxChangeListener;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxIdentity;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxMessage;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxSocketApi;\n+import org.openhab.binding.intesis.internal.config.IntesisBoxConfiguration;\n+import org.openhab.binding.intesis.internal.enums.IntesisBoxFunctionEnum;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link IntesisBoxHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Rocky Amatulli - additions to include id message handling, dynamic channel options based on limits.\n+ * @author Hans-J\u00f6rg Merk - refactored for openHAB 3.0 compatibility\n+ *\n+ */\n+@NonNullByDefault\n+public class IntesisBoxHandler extends BaseThingHandler implements IntesisBoxChangeListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxHandler.class);\n+    private @Nullable IntesisBoxSocketApi intesisBoxSocketApi;\n+\n+    private final Map<String, String> properties = new HashMap<>();\n+    private final Map<String, List<String>> limits = new HashMap<String, List<String>>();\n+\n+    private final IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider;\n+\n+    private IntesisBoxConfiguration config = new IntesisBoxConfiguration();\n+\n+    private double minTemp = 0.0, maxTemp = 0.0;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+\n+    public IntesisBoxHandler(Thing thing, IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider) {\n+        super(thing);\n+        this.intesisStateDescriptionProvider = intesisStateDescriptionProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(IntesisBoxConfiguration.class);\n+\n+        if (!config.ipAddress.isEmpty()) {\n+            intesisBoxSocketApi = new IntesisBoxSocketApi(config.ipAddress, config.port);\n+            intesisBoxSocketApi.addIntesisBoxChangeListener(this);\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+            scheduler.submit(() -> {\n+                try {\n+                    if (intesisBoxSocketApi != null) {\n+                        intesisBoxSocketApi.openConnection();\n+                    }\n+                    if (intesisBoxSocketApi != null) {\n+                        intesisBoxSocketApi.sendId();\n+                    }\n+                    if (intesisBoxSocketApi != null) {\n+                        intesisBoxSocketApi.sendLimitsQuery();\n+                    }\n+                    if (intesisBoxSocketApi != null) {\n+                        intesisBoxSocketApi.sendAlive();\n+                    }\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+                pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 3, 45, TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No IP address specified)\");\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> pollingTask = this.pollingTask;\n+\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+\n+        if (pollingTask != null) {\n+            pollingTask.cancel(true);\n+            this.pollingTask = null;\n+        }\n+        if (api != null) {\n+            api.closeConnection();\n+        }\n+        super.dispose();\n+    }\n+\n+    private synchronized void polling() {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                try {\n+                    api.openConnection();\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+            }\n+            api.sendAlive();\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                logger.trace(\"Sending command failed, not connected\");\n+                return;\n+            }\n+            if (command instanceof RefreshType) {\n+                logger.trace(\"Refresh channel {}\", channelUID.getId());\n+                api.sendQuery(channelUID.getId());\n+                return;\n+            }\n+        }\n+        String value = \"\";\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TYPE_POWER:\n+                if (command instanceof OnOffType) {\n+                    value = command == OnOffType.ON ? \"ON\" : \"OFF\";\n+                }\n+                break;\n+            case CHANNEL_TYPE_TARGETTEMP:\n+                if (command instanceof QuantityType) {\n+                    QuantityType<?> celsiusTemperature = (QuantityType<?>) command;\n+                    celsiusTemperature = celsiusTemperature.toUnit(SIUnits.CELSIUS);\n+                    if (celsiusTemperature != null) {\n+                        double doubleValue = celsiusTemperature.doubleValue();\n+                        logger.trace(\"targetTemp double value = {}\", doubleValue);\n+                        doubleValue = Math.max(minTemp, Math.min(maxTemp, doubleValue));\n+                        value = String.format(\"%.0f\", doubleValue * 10);\n+                        logger.trace(\"targetTemp raw string = {}\", value);\n+                    }\n+                }\n+                break;\n+            case CHANNEL_TYPE_MODE:\n+            case CHANNEL_TYPE_FANSPEED:\n+            case CHANNEL_TYPE_VANESUD:\n+            case CHANNEL_TYPE_VANESLR:\n+                value = command.toString();\n+                break;\n+        }\n+        if (!value.isEmpty()) {\n+            String function = IntesisBoxFunctionEnum.valueOf(channelUID.getId()).getFunction();\n+            if (api != null) {\n+                logger.trace(\"Sending command {} to function {}\", value, function);\n+                api.sendCommand(function, value);\n+            } else {\n+                logger.warn(\"Sending command failed, could not get API\");\n+            }\n+        }\n+    }\n+\n+    private void receivedId(String function, String value) {\n+        logger.trace(\"receivedID(): {} {}\", function, value);\n+        properties.put(PROPERTY_VENDOR, \"Intesis\");\n+        switch (function) {\n+            case \"MODEL\":\n+                properties.put(PROPERTY_MODEL_ID, value);\n+                break;\n+            case \"MAC\":\n+                properties.put(PROPERTY_MAC_ADDRESS, value);\n+                break;\n+            case \"IP\":\n+                properties.put(\"ipAddress\", value);\n+            case \"PROTOCOL\":\n+                properties.put(\"protocol\", value);\n+                break;\n+            case \"VERSION\":\n+                properties.put(PROPERTY_FIRMWARE_VERSION, value);\n+                break;\n+            case \"RSSI\":\n+                properties.put(\"rssi\", value);\n+                break;\n+            case \"NAME\":\n+                properties.put(\"hostname\", value);\n+                break;\n+        }\n+        logger.trace(\"Update Properties for ID : {}\", properties);\n+    }\n+\n+    private void receivedUpdate(String function, String receivedValue) {\n+        String value = receivedValue;\n+        logger.trace(\"receivedUpdate(): {} {}\", function, value);\n+        switch (function) {\n+            case \"ONOFF\":\n+                updateState(CHANNEL_TYPE_POWER, OnOffType.from(value));\n+                break;\n+\n+            case \"SETPTEMP\":\n+                if (value.equals(\"32768\")) {\n+                    value = \"0\";\n+                }\n+                updateState(CHANNEL_TYPE_TARGETTEMP,\n+                        new QuantityType<Temperature>(Double.valueOf(value) / 10.0d, SIUnits.CELSIUS));\n+                break;\n+            case \"AMBTEMP\":\n+                if (Double.valueOf(value).isNaN()) {\n+                    value = \"0\";\n+                }\n+                updateState(CHANNEL_TYPE_AMBIENTTEMP,\n+                        new QuantityType<Temperature>(Double.valueOf(value) / 10.0d, SIUnits.CELSIUS));\n+                break;\n+            case \"MODE\":\n+                updateState(CHANNEL_TYPE_MODE, new StringType(value));\n+                break;\n+            case \"FANSP\":\n+                updateState(CHANNEL_TYPE_FANSPEED, new StringType(value));\n+                break;\n+            case \"VANEUD\":\n+                updateState(CHANNEL_TYPE_VANESUD, new StringType(value));\n+                break;\n+            case \"VANELR\":\n+                updateState(CHANNEL_TYPE_VANESLR, new StringType(value));\n+                break;\n+            case \"ERRCODE\":\n+                properties.put(\"errorCode\", value);\n+                updateProperties(properties);\n+                break;\n+            case \"ERRSTATUS\":\n+                properties.put(\"errorStatus\", value);", "originalCommit": "b255eec678d0820e0a7f3d19899fb83b0917116b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1MDY2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r509050663", "bodyText": "Changed to be channels", "author": "hmerk", "createdAt": "2020-10-21T07:31:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkzODY3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk0MTE5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r507941197", "bodyText": "Why are you synchronizing?", "author": "cpmeister", "createdAt": "2020-10-19T17:46:20Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/handler/IntesisBoxHandler.java", "diffHunk": "@@ -0,0 +1,383 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.handler;\n+\n+import static org.openhab.binding.intesis.internal.IntesisBindingConstants.*;\n+import static org.openhab.binding.intesis.internal.api.IntesisBoxMessage.*;\n+import static org.openhab.core.thing.Thing.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.IntesisDynamicStateDescriptionProvider;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxChangeListener;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxIdentity;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxMessage;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxSocketApi;\n+import org.openhab.binding.intesis.internal.config.IntesisBoxConfiguration;\n+import org.openhab.binding.intesis.internal.enums.IntesisBoxFunctionEnum;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link IntesisBoxHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Rocky Amatulli - additions to include id message handling, dynamic channel options based on limits.\n+ * @author Hans-J\u00f6rg Merk - refactored for openHAB 3.0 compatibility\n+ *\n+ */\n+@NonNullByDefault\n+public class IntesisBoxHandler extends BaseThingHandler implements IntesisBoxChangeListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxHandler.class);\n+    private @Nullable IntesisBoxSocketApi intesisBoxSocketApi;\n+\n+    private final Map<String, String> properties = new HashMap<>();\n+    private final Map<String, List<String>> limits = new HashMap<String, List<String>>();\n+\n+    private final IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider;\n+\n+    private IntesisBoxConfiguration config = new IntesisBoxConfiguration();\n+\n+    private double minTemp = 0.0, maxTemp = 0.0;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+\n+    public IntesisBoxHandler(Thing thing, IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider) {\n+        super(thing);\n+        this.intesisStateDescriptionProvider = intesisStateDescriptionProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(IntesisBoxConfiguration.class);\n+\n+        if (!config.ipAddress.isEmpty()) {\n+            intesisBoxSocketApi = new IntesisBoxSocketApi(config.ipAddress, config.port);\n+            intesisBoxSocketApi.addIntesisBoxChangeListener(this);\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+            scheduler.submit(() -> {\n+                try {\n+                    if (intesisBoxSocketApi != null) {\n+                        intesisBoxSocketApi.openConnection();\n+                    }\n+                    if (intesisBoxSocketApi != null) {\n+                        intesisBoxSocketApi.sendId();\n+                    }\n+                    if (intesisBoxSocketApi != null) {\n+                        intesisBoxSocketApi.sendLimitsQuery();\n+                    }\n+                    if (intesisBoxSocketApi != null) {\n+                        intesisBoxSocketApi.sendAlive();\n+                    }\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+                pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 3, 45, TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No IP address specified)\");\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> pollingTask = this.pollingTask;\n+\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+\n+        if (pollingTask != null) {\n+            pollingTask.cancel(true);\n+            this.pollingTask = null;\n+        }\n+        if (api != null) {\n+            api.closeConnection();\n+        }\n+        super.dispose();\n+    }\n+\n+    private synchronized void polling() {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                try {\n+                    api.openConnection();\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+            }\n+            api.sendAlive();\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+        if (api != null) {\n+            if (!api.isConnected()) {\n+                logger.trace(\"Sending command failed, not connected\");\n+                return;\n+            }\n+            if (command instanceof RefreshType) {\n+                logger.trace(\"Refresh channel {}\", channelUID.getId());\n+                api.sendQuery(channelUID.getId());\n+                return;\n+            }\n+        }\n+        String value = \"\";\n+        switch (channelUID.getId()) {\n+            case CHANNEL_TYPE_POWER:\n+                if (command instanceof OnOffType) {\n+                    value = command == OnOffType.ON ? \"ON\" : \"OFF\";\n+                }\n+                break;\n+            case CHANNEL_TYPE_TARGETTEMP:\n+                if (command instanceof QuantityType) {\n+                    QuantityType<?> celsiusTemperature = (QuantityType<?>) command;\n+                    celsiusTemperature = celsiusTemperature.toUnit(SIUnits.CELSIUS);\n+                    if (celsiusTemperature != null) {\n+                        double doubleValue = celsiusTemperature.doubleValue();\n+                        logger.trace(\"targetTemp double value = {}\", doubleValue);\n+                        doubleValue = Math.max(minTemp, Math.min(maxTemp, doubleValue));\n+                        value = String.format(\"%.0f\", doubleValue * 10);\n+                        logger.trace(\"targetTemp raw string = {}\", value);\n+                    }\n+                }\n+                break;\n+            case CHANNEL_TYPE_MODE:\n+            case CHANNEL_TYPE_FANSPEED:\n+            case CHANNEL_TYPE_VANESUD:\n+            case CHANNEL_TYPE_VANESLR:\n+                value = command.toString();\n+                break;\n+        }\n+        if (!value.isEmpty()) {\n+            String function = IntesisBoxFunctionEnum.valueOf(channelUID.getId()).getFunction();\n+            if (api != null) {\n+                logger.trace(\"Sending command {} to function {}\", value, function);\n+                api.sendCommand(function, value);\n+            } else {\n+                logger.warn(\"Sending command failed, could not get API\");\n+            }\n+        }\n+    }\n+\n+    private void receivedId(String function, String value) {\n+        logger.trace(\"receivedID(): {} {}\", function, value);\n+        properties.put(PROPERTY_VENDOR, \"Intesis\");\n+        switch (function) {\n+            case \"MODEL\":\n+                properties.put(PROPERTY_MODEL_ID, value);\n+                break;\n+            case \"MAC\":\n+                properties.put(PROPERTY_MAC_ADDRESS, value);\n+                break;\n+            case \"IP\":\n+                properties.put(\"ipAddress\", value);\n+            case \"PROTOCOL\":\n+                properties.put(\"protocol\", value);\n+                break;\n+            case \"VERSION\":\n+                properties.put(PROPERTY_FIRMWARE_VERSION, value);\n+                break;\n+            case \"RSSI\":\n+                properties.put(\"rssi\", value);\n+                break;\n+            case \"NAME\":\n+                properties.put(\"hostname\", value);\n+                break;\n+        }\n+        logger.trace(\"Update Properties for ID : {}\", properties);\n+    }\n+\n+    private void receivedUpdate(String function, String receivedValue) {\n+        String value = receivedValue;\n+        logger.trace(\"receivedUpdate(): {} {}\", function, value);\n+        switch (function) {\n+            case \"ONOFF\":\n+                updateState(CHANNEL_TYPE_POWER, OnOffType.from(value));\n+                break;\n+\n+            case \"SETPTEMP\":\n+                if (value.equals(\"32768\")) {\n+                    value = \"0\";\n+                }\n+                updateState(CHANNEL_TYPE_TARGETTEMP,\n+                        new QuantityType<Temperature>(Double.valueOf(value) / 10.0d, SIUnits.CELSIUS));\n+                break;\n+            case \"AMBTEMP\":\n+                if (Double.valueOf(value).isNaN()) {\n+                    value = \"0\";\n+                }\n+                updateState(CHANNEL_TYPE_AMBIENTTEMP,\n+                        new QuantityType<Temperature>(Double.valueOf(value) / 10.0d, SIUnits.CELSIUS));\n+                break;\n+            case \"MODE\":\n+                updateState(CHANNEL_TYPE_MODE, new StringType(value));\n+                break;\n+            case \"FANSP\":\n+                updateState(CHANNEL_TYPE_FANSPEED, new StringType(value));\n+                break;\n+            case \"VANEUD\":\n+                updateState(CHANNEL_TYPE_VANESUD, new StringType(value));\n+                break;\n+            case \"VANELR\":\n+                updateState(CHANNEL_TYPE_VANESLR, new StringType(value));\n+                break;\n+            case \"ERRCODE\":\n+                properties.put(\"errorCode\", value);\n+                updateProperties(properties);\n+                break;\n+            case \"ERRSTATUS\":\n+                properties.put(\"errorStatus\", value);\n+                updateProperties(properties);\n+                if (\"ERR\".equals(value)) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"device reported an error\");\n+                }\n+                break;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    private void handleMessage(String data) {\n+        logger.debug(\"handleMessage(): Message received - {}\", data);\n+        if (data.equals(\"ACK\") || data.equals(\"\")) {\n+            return;\n+        }\n+        if (data.startsWith(ID + ':')) {\n+            synchronized (this) {\n+                new IntesisBoxIdentity(data).value.forEach((name, value) -> receivedId(name, value));\n+                return;\n+            }\n+        }\n+        IntesisBoxMessage message = IntesisBoxMessage.parse(data);\n+        if (message.getCommand() != null) {\n+            switch (message.getCommand()) {\n+                case LIMITS:\n+                    logger.debug(\"handleMessage(): Limits received - {}\", data);\n+                    synchronized (this) {", "originalCommit": "b255eec678d0820e0a7f3d19899fb83b0917116b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAzODExNg==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r509038116", "bodyText": "Removed", "author": "hmerk", "createdAt": "2020-10-21T07:09:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk0MTE5Nw=="}], "type": "inlineReview"}, {"oid": "bf96a6ffe163d8fa1843ef8ec16f7cae1b84c2c2", "url": "https://github.com/openhab/openhab-addons/commit/bf96a6ffe163d8fa1843ef8ec16f7cae1b84c2c2", "message": "Changes after second review\n\nSigned-off-by: Hans-J\u00f6rg Merk <github@hmerk.de>", "committedDate": "2020-10-21T07:50:42Z", "type": "commit"}, {"oid": "5ede91867bed3cd5b6f32bfb2f060c28e924fad4", "url": "https://github.com/openhab/openhab-addons/commit/5ede91867bed3cd5b6f32bfb2f060c28e924fad4", "message": "Fix compiler warnings\n\nSigned-off-by: Hans-J\u00f6rg Merk <github@hmerk.de>", "committedDate": "2020-10-22T07:26:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ5NTUzMA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r510495530", "bodyText": "Doesn't rssi change over time? If it changes over time it should be a channel, not a property", "author": "cpmeister", "createdAt": "2020-10-22T22:33:26Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/handler/IntesisBoxHandler.java", "diffHunk": "@@ -203,32 +217,17 @@ public void handleCommand(ChannelUID channelUID, Command command) {\n         }\n     }\n \n-    private void receivedId(String function, String value) {\n-        logger.trace(\"receivedID(): {} {}\", function, value);\n+    private void populateProperties(String data) {\n+        String[] value = data.substring(3).split(\",\");\n         properties.put(PROPERTY_VENDOR, \"Intesis\");\n-        switch (function) {\n-            case \"MODEL\":\n-                properties.put(PROPERTY_MODEL_ID, value);\n-                break;\n-            case \"MAC\":\n-                properties.put(PROPERTY_MAC_ADDRESS, value);\n-                break;\n-            case \"IP\":\n-                properties.put(\"ipAddress\", value);\n-            case \"PROTOCOL\":\n-                properties.put(\"protocol\", value);\n-                break;\n-            case \"VERSION\":\n-                properties.put(PROPERTY_FIRMWARE_VERSION, value);\n-                break;\n-            case \"RSSI\":\n-                properties.put(\"rssi\", value);\n-                break;\n-            case \"NAME\":\n-                properties.put(\"hostname\", value);\n-                break;\n-        }\n-        logger.trace(\"Update Properties for ID : {}\", properties);\n+        properties.put(PROPERTY_MODEL_ID, value[0]);\n+        properties.put(PROPERTY_MAC_ADDRESS, value[1]);\n+        properties.put(\"ipAddress\", value[2]);\n+        properties.put(\"protocol\", value[3]);\n+        properties.put(PROPERTY_FIRMWARE_VERSION, value[4]);\n+        properties.put(\"rssi\", value[5]);", "originalCommit": "bf96a6ffe163d8fa1843ef8ec16f7cae1b84c2c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3NTk5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r510675991", "bodyText": "Will change that later, as I have to think how to block other properties from regular updates. Should be no big issue.", "author": "hmerk", "createdAt": "2020-10-23T07:03:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ5NTUzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk1MDY5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r510950691", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-23T15:08:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ5NTUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ5OTU5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r510499591", "bodyText": "Unless there are some kind of strict timing requirements, it would be better to start periodic tasks synchronously in initialize().\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 3, 45, TimeUnit.SECONDS);\n          \n          \n            \n                            updateStatus(ThingStatus.ONLINE);\n          \n          \n            \n                        });\n          \n          \n            \n                            updateStatus(ThingStatus.ONLINE);\n          \n          \n            \n                        });\n          \n          \n            \n                        pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 3, 45, TimeUnit.SECONDS);", "author": "cpmeister", "createdAt": "2020-10-22T22:45:47Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/handler/IntesisBoxHandler.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.handler;\n+\n+import static org.openhab.binding.intesis.internal.IntesisBindingConstants.*;\n+import static org.openhab.binding.intesis.internal.api.IntesisBoxMessage.*;\n+import static org.openhab.core.thing.Thing.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.IntesisDynamicStateDescriptionProvider;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxChangeListener;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxMessage;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxSocketApi;\n+import org.openhab.binding.intesis.internal.config.IntesisBoxConfiguration;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link IntesisBoxHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Rocky Amatulli - additions to include id message handling, dynamic channel options based on limits.\n+ * @author Hans-J\u00f6rg Merk - refactored for openHAB 3.0 compatibility\n+ *\n+ */\n+@NonNullByDefault\n+public class IntesisBoxHandler extends BaseThingHandler implements IntesisBoxChangeListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxHandler.class);\n+    private @Nullable IntesisBoxSocketApi intesisBoxSocketApi;\n+\n+    private final Map<String, String> properties = new HashMap<>();\n+    private final Map<String, List<String>> limits = new HashMap<String, List<String>>();\n+\n+    private final IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider;\n+\n+    private IntesisBoxConfiguration config = new IntesisBoxConfiguration();\n+\n+    private double minTemp = 0.0, maxTemp = 0.0;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+\n+    public IntesisBoxHandler(Thing thing, IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider) {\n+        super(thing);\n+        this.intesisStateDescriptionProvider = intesisStateDescriptionProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(IntesisBoxConfiguration.class);\n+\n+        if (!config.ipAddress.isEmpty()) {\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+            scheduler.submit(() -> {\n+                addChannel(CHANNEL_TYPE_AMBIENTTEMP, \"Number:Temperature\");\n+                addChannel(CHANNEL_TYPE_ERRORCODE, \"String\");\n+                addChannel(CHANNEL_TYPE_ERRORSTATUS, \"String\");\n+\n+                intesisBoxSocketApi = new IntesisBoxSocketApi(config.ipAddress, config.port);\n+                intesisBoxSocketApi.addIntesisBoxChangeListener(this);\n+                try {\n+                    IntesisBoxSocketApi intesisLocalApi = intesisBoxSocketApi;\n+                    if (intesisLocalApi != null) {\n+                        intesisLocalApi.openConnection();\n+                        intesisLocalApi.sendId();\n+                        intesisLocalApi.sendLimitsQuery();\n+                        intesisLocalApi.sendAlive();\n+                    }\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+                pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 3, 45, TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+            });", "originalCommit": "5ede91867bed3cd5b6f32bfb2f060c28e924fad4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3MjEyOA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r510672128", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-23T06:54:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ5OTU5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUwMDI1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r510500259", "bodyText": "Is there somewhere here you are calling intesisBoxSocketApi.removeIntesisBoxChangeListener(this);? If you aren't then you should.", "author": "cpmeister", "createdAt": "2020-10-22T22:47:46Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/handler/IntesisBoxHandler.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.handler;\n+\n+import static org.openhab.binding.intesis.internal.IntesisBindingConstants.*;\n+import static org.openhab.binding.intesis.internal.api.IntesisBoxMessage.*;\n+import static org.openhab.core.thing.Thing.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.IntesisDynamicStateDescriptionProvider;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxChangeListener;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxMessage;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxSocketApi;\n+import org.openhab.binding.intesis.internal.config.IntesisBoxConfiguration;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link IntesisBoxHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Rocky Amatulli - additions to include id message handling, dynamic channel options based on limits.\n+ * @author Hans-J\u00f6rg Merk - refactored for openHAB 3.0 compatibility\n+ *\n+ */\n+@NonNullByDefault\n+public class IntesisBoxHandler extends BaseThingHandler implements IntesisBoxChangeListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxHandler.class);\n+    private @Nullable IntesisBoxSocketApi intesisBoxSocketApi;\n+\n+    private final Map<String, String> properties = new HashMap<>();\n+    private final Map<String, List<String>> limits = new HashMap<String, List<String>>();\n+\n+    private final IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider;\n+\n+    private IntesisBoxConfiguration config = new IntesisBoxConfiguration();\n+\n+    private double minTemp = 0.0, maxTemp = 0.0;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+\n+    public IntesisBoxHandler(Thing thing, IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider) {\n+        super(thing);\n+        this.intesisStateDescriptionProvider = intesisStateDescriptionProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(IntesisBoxConfiguration.class);\n+\n+        if (!config.ipAddress.isEmpty()) {\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+            scheduler.submit(() -> {\n+                addChannel(CHANNEL_TYPE_AMBIENTTEMP, \"Number:Temperature\");\n+                addChannel(CHANNEL_TYPE_ERRORCODE, \"String\");\n+                addChannel(CHANNEL_TYPE_ERRORSTATUS, \"String\");\n+\n+                intesisBoxSocketApi = new IntesisBoxSocketApi(config.ipAddress, config.port);\n+                intesisBoxSocketApi.addIntesisBoxChangeListener(this);\n+                try {\n+                    IntesisBoxSocketApi intesisLocalApi = intesisBoxSocketApi;\n+                    if (intesisLocalApi != null) {\n+                        intesisLocalApi.openConnection();\n+                        intesisLocalApi.sendId();\n+                        intesisLocalApi.sendLimitsQuery();\n+                        intesisLocalApi.sendAlive();\n+                    }\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }\n+                pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 3, 45, TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No IP address specified)\");\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> pollingTask = this.pollingTask;\n+\n+        IntesisBoxSocketApi api = this.intesisBoxSocketApi;\n+\n+        if (pollingTask != null) {\n+            pollingTask.cancel(true);\n+            this.pollingTask = null;\n+        }\n+        if (api != null) {\n+            api.closeConnection();\n+        }", "originalCommit": "5ede91867bed3cd5b6f32bfb2f060c28e924fad4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3Mzg5NA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r510673894", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-23T06:58:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUwMDI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUwMTY5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r510501693", "bodyText": "Should these values also be reset as part of initialize()?", "author": "cpmeister", "createdAt": "2020-10-22T22:51:53Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/handler/IntesisBoxHandler.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.handler;\n+\n+import static org.openhab.binding.intesis.internal.IntesisBindingConstants.*;\n+import static org.openhab.binding.intesis.internal.api.IntesisBoxMessage.*;\n+import static org.openhab.core.thing.Thing.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.IntesisDynamicStateDescriptionProvider;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxChangeListener;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxMessage;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxSocketApi;\n+import org.openhab.binding.intesis.internal.config.IntesisBoxConfiguration;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link IntesisBoxHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Rocky Amatulli - additions to include id message handling, dynamic channel options based on limits.\n+ * @author Hans-J\u00f6rg Merk - refactored for openHAB 3.0 compatibility\n+ *\n+ */\n+@NonNullByDefault\n+public class IntesisBoxHandler extends BaseThingHandler implements IntesisBoxChangeListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxHandler.class);\n+    private @Nullable IntesisBoxSocketApi intesisBoxSocketApi;\n+\n+    private final Map<String, String> properties = new HashMap<>();\n+    private final Map<String, List<String>> limits = new HashMap<String, List<String>>();\n+\n+    private final IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider;\n+\n+    private IntesisBoxConfiguration config = new IntesisBoxConfiguration();\n+\n+    private double minTemp = 0.0, maxTemp = 0.0;", "originalCommit": "5ede91867bed3cd5b6f32bfb2f060c28e924fad4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3NTQ2MA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r510675460", "bodyText": "No, as they get updated in the polling task.", "author": "hmerk", "createdAt": "2020-10-23T07:01:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUwMTY5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUwMjIxNw==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r510502217", "bodyText": "You should return here otherwise your thing status will be set to ONLINE immediately after.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n          \n          \n            \n                            }\n          \n          \n            \n                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n          \n          \n            \n                                return;\n          \n          \n            \n                            }", "author": "cpmeister", "createdAt": "2020-10-22T22:53:33Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/handler/IntesisBoxHandler.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.handler;\n+\n+import static org.openhab.binding.intesis.internal.IntesisBindingConstants.*;\n+import static org.openhab.binding.intesis.internal.api.IntesisBoxMessage.*;\n+import static org.openhab.core.thing.Thing.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.IntesisDynamicStateDescriptionProvider;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxChangeListener;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxMessage;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxSocketApi;\n+import org.openhab.binding.intesis.internal.config.IntesisBoxConfiguration;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link IntesisBoxHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Rocky Amatulli - additions to include id message handling, dynamic channel options based on limits.\n+ * @author Hans-J\u00f6rg Merk - refactored for openHAB 3.0 compatibility\n+ *\n+ */\n+@NonNullByDefault\n+public class IntesisBoxHandler extends BaseThingHandler implements IntesisBoxChangeListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxHandler.class);\n+    private @Nullable IntesisBoxSocketApi intesisBoxSocketApi;\n+\n+    private final Map<String, String> properties = new HashMap<>();\n+    private final Map<String, List<String>> limits = new HashMap<String, List<String>>();\n+\n+    private final IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider;\n+\n+    private IntesisBoxConfiguration config = new IntesisBoxConfiguration();\n+\n+    private double minTemp = 0.0, maxTemp = 0.0;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+\n+    public IntesisBoxHandler(Thing thing, IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider) {\n+        super(thing);\n+        this.intesisStateDescriptionProvider = intesisStateDescriptionProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(IntesisBoxConfiguration.class);\n+\n+        if (!config.ipAddress.isEmpty()) {\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+            scheduler.submit(() -> {\n+                addChannel(CHANNEL_TYPE_AMBIENTTEMP, \"Number:Temperature\");\n+                addChannel(CHANNEL_TYPE_ERRORCODE, \"String\");\n+                addChannel(CHANNEL_TYPE_ERRORSTATUS, \"String\");\n+\n+                intesisBoxSocketApi = new IntesisBoxSocketApi(config.ipAddress, config.port);\n+                intesisBoxSocketApi.addIntesisBoxChangeListener(this);\n+                try {\n+                    IntesisBoxSocketApi intesisLocalApi = intesisBoxSocketApi;\n+                    if (intesisLocalApi != null) {\n+                        intesisLocalApi.openConnection();\n+                        intesisLocalApi.sendId();\n+                        intesisLocalApi.sendLimitsQuery();\n+                        intesisLocalApi.sendAlive();\n+                    }\n+                } catch (IOException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                }", "originalCommit": "5ede91867bed3cd5b6f32bfb2f060c28e924fad4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3NDQ1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r510674452", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-23T06:59:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUwMjIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUwMzIzMg==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r510503232", "bodyText": "If you assign the local variable at the same time you don't need to do null checks later on.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            intesisBoxSocketApi = new IntesisBoxSocketApi(config.ipAddress, config.port);\n          \n          \n            \n                            intesisBoxSocketApi.addIntesisBoxChangeListener(this);\n          \n          \n            \n                            try {\n          \n          \n            \n                                IntesisBoxSocketApi intesisLocalApi = intesisBoxSocketApi;\n          \n          \n            \n                                if (intesisLocalApi != null) {\n          \n          \n            \n                                    intesisLocalApi.openConnection();\n          \n          \n            \n                                    intesisLocalApi.sendId();\n          \n          \n            \n                                    intesisLocalApi.sendLimitsQuery();\n          \n          \n            \n                                    intesisLocalApi.sendAlive();\n          \n          \n            \n                                }\n          \n          \n            \n                            IntesisBoxSocketApi intesisLocalApi = intesisBoxSocketApi = new IntesisBoxSocketApi(config.ipAddress, config.port);\n          \n          \n            \n                            intesisLocalApi.addIntesisBoxChangeListener(this);\n          \n          \n            \n                            try {\n          \n          \n            \n                                intesisLocalApi.openConnection();\n          \n          \n            \n                                intesisLocalApi.sendId();\n          \n          \n            \n                                intesisLocalApi.sendLimitsQuery();\n          \n          \n            \n                                intesisLocalApi.sendAlive();", "author": "cpmeister", "createdAt": "2020-10-22T22:56:31Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/handler/IntesisBoxHandler.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.handler;\n+\n+import static org.openhab.binding.intesis.internal.IntesisBindingConstants.*;\n+import static org.openhab.binding.intesis.internal.api.IntesisBoxMessage.*;\n+import static org.openhab.core.thing.Thing.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.IntesisDynamicStateDescriptionProvider;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxChangeListener;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxMessage;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxSocketApi;\n+import org.openhab.binding.intesis.internal.config.IntesisBoxConfiguration;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link IntesisBoxHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Rocky Amatulli - additions to include id message handling, dynamic channel options based on limits.\n+ * @author Hans-J\u00f6rg Merk - refactored for openHAB 3.0 compatibility\n+ *\n+ */\n+@NonNullByDefault\n+public class IntesisBoxHandler extends BaseThingHandler implements IntesisBoxChangeListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxHandler.class);\n+    private @Nullable IntesisBoxSocketApi intesisBoxSocketApi;\n+\n+    private final Map<String, String> properties = new HashMap<>();\n+    private final Map<String, List<String>> limits = new HashMap<String, List<String>>();\n+\n+    private final IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider;\n+\n+    private IntesisBoxConfiguration config = new IntesisBoxConfiguration();\n+\n+    private double minTemp = 0.0, maxTemp = 0.0;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+\n+    public IntesisBoxHandler(Thing thing, IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider) {\n+        super(thing);\n+        this.intesisStateDescriptionProvider = intesisStateDescriptionProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(IntesisBoxConfiguration.class);\n+\n+        if (!config.ipAddress.isEmpty()) {\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+            scheduler.submit(() -> {\n+                addChannel(CHANNEL_TYPE_AMBIENTTEMP, \"Number:Temperature\");\n+                addChannel(CHANNEL_TYPE_ERRORCODE, \"String\");\n+                addChannel(CHANNEL_TYPE_ERRORSTATUS, \"String\");\n+\n+                intesisBoxSocketApi = new IntesisBoxSocketApi(config.ipAddress, config.port);\n+                intesisBoxSocketApi.addIntesisBoxChangeListener(this);\n+                try {\n+                    IntesisBoxSocketApi intesisLocalApi = intesisBoxSocketApi;\n+                    if (intesisLocalApi != null) {\n+                        intesisLocalApi.openConnection();\n+                        intesisLocalApi.sendId();\n+                        intesisLocalApi.sendLimitsQuery();\n+                        intesisLocalApi.sendAlive();\n+                    }", "originalCommit": "5ede91867bed3cd5b6f32bfb2f060c28e924fad4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3NTAxMg==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r510675012", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-23T07:00:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUwMzIzMg=="}], "type": "inlineReview"}, {"oid": "04cac768cfb05e18fd462a9cf5d28cec35bca6c2", "url": "https://github.com/openhab/openhab-addons/commit/04cac768cfb05e18fd462a9cf5d28cec35bca6c2", "message": "Changes after review\n\nSigned-off-by: Hans-J\u00f6rg Merk <github@hmerk.de>", "committedDate": "2020-10-23T07:05:45Z", "type": "commit"}, {"oid": "f9b0cba605d648a2505e99361c7c7f7c97bf3a07", "url": "https://github.com/openhab/openhab-addons/commit/f9b0cba605d648a2505e99361c7c7f7c97bf3a07", "message": "Changed RSSI from property to channel\n\nSigned-off-by: Hans-J\u00f6rg Merk <github@hmerk.de>", "committedDate": "2020-10-23T15:05:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxMTI2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r511011262", "bodyText": "This is logged by the framework an can therefore be removed.", "author": "fwolter", "createdAt": "2020-10-23T16:46:39Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/IntesisHandlerFactory.java", "diffHunk": "@@ -73,6 +77,11 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n             return new IntesisHomeHandler(thing, httpClient, intesisStateDescriptionProvider);\n         }\n \n+        if (THING_TYPE_INTESISBOX.equals(thingTypeUID)) {\n+            logger.debug(\"Creating a IntesisBoxHandler for thing '{}'\", thing.getUID());", "originalCommit": "f9b0cba605d648a2505e99361c7c7f7c97bf3a07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzMjk0MA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r511332940", "bodyText": "removed", "author": "hmerk", "createdAt": "2020-10-24T07:38:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxMTI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxMjcwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r511012705", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    tcpOutput = new OutputStreamWriter(localSocket.socket.getOutputStream(), \"US-ASCII\");\n          \n          \n            \n                    tcpInput = new BufferedReader(new InputStreamReader(localSocket.socket.getInputStream(), \"US-ASCII\"));\n          \n          \n            \n                    tcpOutput = new OutputStreamWriter(localSocket.socket.getOutputStream(), StandardCharsets.US_ASCII);\n          \n          \n            \n                    tcpInput = new BufferedReader(\n          \n          \n            \n                            new InputStreamReader(localSocket.socket.getInputStream(), StandardCharsets.US_ASCII));", "author": "fwolter", "createdAt": "2020-10-23T16:49:25Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/api/IntesisBoxSocketApi.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.api;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.handler.IntesisBoxHandler;\n+import org.openhab.core.thing.ThingStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class handling the Socket connections.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Hans-J\u00f6rg Merk - Moved Socket to it's own class\n+ */\n+@NonNullByDefault\n+public class IntesisBoxSocketApi {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxSocketApi.class);\n+\n+    private final String ipAddress;\n+    private final int port;\n+\n+    private @Nullable IntesisSocket tcpSocket = null;\n+    private @Nullable OutputStreamWriter tcpOutput = null;\n+    private @Nullable BufferedReader tcpInput = null;\n+\n+    private @Nullable IntesisBoxChangeListener changeListener;\n+\n+    private boolean connected = false;\n+\n+    public IntesisBoxSocketApi(final String ipAddress, final int port) {\n+        this.ipAddress = ipAddress;\n+        this.port = port;\n+    }\n+\n+    private class IntesisSocket {\n+        final Socket socket;\n+\n+        public IntesisSocket() throws UnknownHostException, IOException {\n+            socket = new Socket();\n+            SocketAddress tcpSocketAddress = new InetSocketAddress(ipAddress, port);\n+            socket.connect(tcpSocketAddress);\n+        }\n+\n+        public void close() throws IOException {\n+            socket.close();\n+        }\n+    }\n+\n+    public void openConnection() throws IOException {\n+        closeConnection();\n+\n+        IntesisBoxChangeListener listener = this.changeListener;\n+        IntesisSocket localSocket = tcpSocket = new IntesisSocket();\n+        tcpOutput = new OutputStreamWriter(localSocket.socket.getOutputStream(), \"US-ASCII\");\n+        tcpInput = new BufferedReader(new InputStreamReader(localSocket.socket.getInputStream(), \"US-ASCII\"));", "originalCommit": "f9b0cba605d648a2505e99361c7c7f7c97bf3a07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzMzA2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r511333062", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-24T07:39:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxMjcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxMzI4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r511013287", "bodyText": "Please use the naming scheme mentioned here #8216 .", "author": "fwolter", "createdAt": "2020-10-23T16:50:35Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/api/IntesisBoxSocketApi.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.api;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.handler.IntesisBoxHandler;\n+import org.openhab.core.thing.ThingStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class handling the Socket connections.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Hans-J\u00f6rg Merk - Moved Socket to it's own class\n+ */\n+@NonNullByDefault\n+public class IntesisBoxSocketApi {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxSocketApi.class);\n+\n+    private final String ipAddress;\n+    private final int port;\n+\n+    private @Nullable IntesisSocket tcpSocket = null;\n+    private @Nullable OutputStreamWriter tcpOutput = null;\n+    private @Nullable BufferedReader tcpInput = null;\n+\n+    private @Nullable IntesisBoxChangeListener changeListener;\n+\n+    private boolean connected = false;\n+\n+    public IntesisBoxSocketApi(final String ipAddress, final int port) {\n+        this.ipAddress = ipAddress;\n+        this.port = port;\n+    }\n+\n+    private class IntesisSocket {\n+        final Socket socket;\n+\n+        public IntesisSocket() throws UnknownHostException, IOException {\n+            socket = new Socket();\n+            SocketAddress tcpSocketAddress = new InetSocketAddress(ipAddress, port);\n+            socket.connect(tcpSocketAddress);\n+        }\n+\n+        public void close() throws IOException {\n+            socket.close();\n+        }\n+    }\n+\n+    public void openConnection() throws IOException {\n+        closeConnection();\n+\n+        IntesisBoxChangeListener listener = this.changeListener;\n+        IntesisSocket localSocket = tcpSocket = new IntesisSocket();\n+        tcpOutput = new OutputStreamWriter(localSocket.socket.getOutputStream(), \"US-ASCII\");\n+        tcpInput = new BufferedReader(new InputStreamReader(localSocket.socket.getInputStream(), \"US-ASCII\"));\n+\n+        Thread tcpListener = new Thread(new TCPListener());\n+        tcpListener.setName(\"IntesisBoxTCPListener\");", "originalCommit": "f9b0cba605d648a2505e99361c7c7f7c97bf3a07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzMzc5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r511333790", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-24T07:49:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxMzI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxMzg5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r511013896", "bodyText": "Syntactical sugar\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Map<String, List<String>> limits = new HashMap<String, List<String>>();\n          \n          \n            \n                private final Map<String, List<String>> limits = new HashMap<>();", "author": "fwolter", "createdAt": "2020-10-23T16:51:46Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/handler/IntesisBoxHandler.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.handler;\n+\n+import static org.openhab.binding.intesis.internal.IntesisBindingConstants.*;\n+import static org.openhab.binding.intesis.internal.api.IntesisBoxMessage.*;\n+import static org.openhab.core.thing.Thing.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.IntesisDynamicStateDescriptionProvider;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxChangeListener;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxMessage;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxSocketApi;\n+import org.openhab.binding.intesis.internal.config.IntesisBoxConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link IntesisBoxHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Rocky Amatulli - additions to include id message handling, dynamic channel options based on limits.\n+ * @author Hans-J\u00f6rg Merk - refactored for openHAB 3.0 compatibility\n+ *\n+ */\n+@NonNullByDefault\n+public class IntesisBoxHandler extends BaseThingHandler implements IntesisBoxChangeListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxHandler.class);\n+    private @Nullable IntesisBoxSocketApi intesisBoxSocketApi;\n+\n+    private final Map<String, String> properties = new HashMap<>();\n+    private final Map<String, List<String>> limits = new HashMap<String, List<String>>();", "originalCommit": "f9b0cba605d648a2505e99361c7c7f7c97bf3a07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzMzEzNw==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r511333137", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-24T07:40:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxMzg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxNDUyOA==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r511014528", "bodyText": "If they are always added, can't they be specified in the XML file?", "author": "fwolter", "createdAt": "2020-10-23T16:53:03Z", "path": "bundles/org.openhab.binding.intesis/src/main/java/org/openhab/binding/intesis/internal/handler/IntesisBoxHandler.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.intesis.internal.handler;\n+\n+import static org.openhab.binding.intesis.internal.IntesisBindingConstants.*;\n+import static org.openhab.binding.intesis.internal.api.IntesisBoxMessage.*;\n+import static org.openhab.core.thing.Thing.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.intesis.internal.IntesisDynamicStateDescriptionProvider;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxChangeListener;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxMessage;\n+import org.openhab.binding.intesis.internal.api.IntesisBoxSocketApi;\n+import org.openhab.binding.intesis.internal.config.IntesisBoxConfiguration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link IntesisBoxHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Cody Cutrer - Initial contribution\n+ * @author Rocky Amatulli - additions to include id message handling, dynamic channel options based on limits.\n+ * @author Hans-J\u00f6rg Merk - refactored for openHAB 3.0 compatibility\n+ *\n+ */\n+@NonNullByDefault\n+public class IntesisBoxHandler extends BaseThingHandler implements IntesisBoxChangeListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IntesisBoxHandler.class);\n+    private @Nullable IntesisBoxSocketApi intesisBoxSocketApi;\n+\n+    private final Map<String, String> properties = new HashMap<>();\n+    private final Map<String, List<String>> limits = new HashMap<String, List<String>>();\n+\n+    private final IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider;\n+\n+    private IntesisBoxConfiguration config = new IntesisBoxConfiguration();\n+\n+    private double minTemp = 0.0, maxTemp = 0.0;\n+\n+    private boolean hasProperties = false;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+\n+    public IntesisBoxHandler(Thing thing, IntesisDynamicStateDescriptionProvider intesisStateDescriptionProvider) {\n+        super(thing);\n+        this.intesisStateDescriptionProvider = intesisStateDescriptionProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(IntesisBoxConfiguration.class);\n+\n+        if (!config.ipAddress.isEmpty()) {\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+            scheduler.submit(() -> {\n+                addChannel(CHANNEL_TYPE_AMBIENTTEMP, \"Number:Temperature\");\n+                addChannel(CHANNEL_TYPE_ERRORCODE, \"String\");\n+                addChannel(CHANNEL_TYPE_ERRORSTATUS, \"String\");", "originalCommit": "f9b0cba605d648a2505e99361c7c7f7c97bf3a07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNDE1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8694#discussion_r511334159", "bodyText": "Done", "author": "hmerk", "createdAt": "2020-10-24T07:53:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxNDUyOA=="}], "type": "inlineReview"}, {"oid": "bab56ce7327ab0d96f457dfb4ac4273752e67f3b", "url": "https://github.com/openhab/openhab-addons/commit/bab56ce7327ab0d96f457dfb4ac4273752e67f3b", "message": "Changes after next review\n\nSigned-off-by: Hans-J\u00f6rg Merk <github@hmerk.de>", "committedDate": "2020-10-24T07:56:29Z", "type": "commit"}]}