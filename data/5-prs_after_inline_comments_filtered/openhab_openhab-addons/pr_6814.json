{"pr_number": 6814, "pr_title": "[danfossairunit] Danfoss AirUnit binding - initial commit", "pr_createdAt": "2020-01-12T02:28:00Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/6814", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxMTM4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385911387", "bodyText": "I would cache the hrv variable locally so that you don't need to do this assertion check.", "author": "cpmeister", "createdAt": "2020-02-28T20:38:39Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossHRV hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+\n+        } else {\n+            if (hrv == null) {\n+                return;\n+            }\n+            try {\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                hrv.connect();\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(assertNonNull(hrv), command));", "originalCommit": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxMjc1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385912757", "bodyText": "Please specify specific checked exceptions if possible, if not possible just catch RuntimeException", "author": "cpmeister", "createdAt": "2020-02-28T20:42:21Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossHRV hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+\n+        } else {\n+            if (hrv == null) {\n+                return;\n+            }\n+            try {\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                hrv.connect();\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(assertNonNull(hrv), command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            } finally {\n+                hrv.disconnect();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossHRV(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                hrv.connect();\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                hrv.disconnect();\n+                pollingJob = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 5, config.refreshInterval,\n+                        TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+            }\n+        });\n+    }\n+\n+    private void updateAllChannels() {\n+        if (hrv == null) {\n+            return;\n+        }\n+        logger.debug(\"Updating DanfossHRV data '{}'\", getThing().getUID());\n+\n+        try {\n+            hrv.connect();\n+\n+            for (Channel channel : Channel.values()) {\n+                if (Thread.interrupted()) {\n+                    logger.debug(\"Polling thread interrupted...\");\n+                    return;\n+                }\n+                try {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(),\n+                            channel.getReadAccessor().access(assertNonNull(hrv)));\n+                } catch (Exception e) {", "originalCommit": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxMzgxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385913815", "bodyText": "I would synchronize all hrv.connect()...hrv.disconnect() logic to prevent nasty multithreaded issues.", "author": "cpmeister", "createdAt": "2020-02-28T20:45:11Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossHRV hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+\n+        } else {\n+            if (hrv == null) {\n+                return;\n+            }\n+            try {\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                hrv.connect();\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(assertNonNull(hrv), command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            } finally {\n+                hrv.disconnect();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossHRV(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                hrv.connect();\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                hrv.disconnect();", "originalCommit": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxNDMwMw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385914303", "bodyText": "Do your TODO", "author": "cpmeister", "createdAt": "2020-02-28T20:46:27Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.*;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossHRV} class does the actual network communication with the air unit.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@NonNullByDefault\n+public class DanfossHRV implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossHRV.class);\n+\n+    private InetAddress inetAddr;\n+    private int port;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossHRV(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public void connect() throws IOException {\n+        socket = new Socket(inetAddr, port);\n+        oStream = socket.getOutputStream();\n+        iStream = socket.getInputStream();\n+    }\n+\n+    public void disconnect() {\n+        try {\n+            if (socket != null) {\n+                socket.close();\n+                socket = null;\n+                iStream = null;\n+                oStream = null;\n+            }\n+\n+        } catch (IOException ioe) {\n+            // TODO: handle exception", "originalCommit": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxNTM1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385915356", "bodyText": "ByteBuffer should not be used for something so trivial. Please write this logic without using ByteBuffer.", "author": "cpmeister", "createdAt": "2020-02-28T20:49:05Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.*;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossHRV} class does the actual network communication with the air unit.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@NonNullByDefault\n+public class DanfossHRV implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossHRV.class);\n+\n+    private InetAddress inetAddr;\n+    private int port;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossHRV(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public void connect() throws IOException {\n+        socket = new Socket(inetAddr, port);\n+        oStream = socket.getOutputStream();\n+        iStream = socket.getInputStream();\n+    }\n+\n+    public void disconnect() {\n+        try {\n+            if (socket != null) {\n+                socket.close();\n+                socket = null;\n+                iStream = null;\n+                oStream = null;\n+            }\n+\n+        } catch (IOException ioe) {\n+            // TODO: handle exception\n+        }\n+    }\n+\n+    private byte[] sendRobustRequest(byte[] operation, byte[] register) throws IOException {\n+        return sendRobustRequest(operation, register, EMPTY);\n+    }\n+\n+    private byte[] sendRobustRequest(byte[] operation, byte[] register, byte[] value) throws IOException {\n+        if (socket == null) {\n+            throw new DisconnectedException();\n+        }\n+        byte[] request = new byte[4 + value.length];\n+        System.arraycopy(operation, 0, request, 0, 2);\n+        System.arraycopy(register, 0, request, 2, 2);\n+        System.arraycopy(value, 0, request, 4, value.length);\n+\n+        try {\n+            return sendRequest(request);\n+        } catch (IOException exIo) {\n+            logger.info(\"Connection to the air unit has been lost, reconnecting ({}).\", exIo.getMessage());\n+            connect();\n+            return sendRequest(request);\n+        }\n+    }\n+\n+    private synchronized byte[] sendRequest(byte[] request) throws IOException {\n+\n+        oStream.write(request);\n+        oStream.flush();\n+\n+        byte[] result = new byte[63];\n+        iStream.read(result, 0, 63);\n+\n+        return result;\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = sendRobustRequest(operation, register);\n+        return ByteBuffer.wrap(new byte[] { resultBytes[0], resultBytes[1] }).getShort();", "originalCommit": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxNTQ3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385915471", "bodyText": "see comment above", "author": "cpmeister", "createdAt": "2020-02-28T20:49:25Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.*;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossHRV} class does the actual network communication with the air unit.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@NonNullByDefault\n+public class DanfossHRV implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossHRV.class);\n+\n+    private InetAddress inetAddr;\n+    private int port;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossHRV(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public void connect() throws IOException {\n+        socket = new Socket(inetAddr, port);\n+        oStream = socket.getOutputStream();\n+        iStream = socket.getInputStream();\n+    }\n+\n+    public void disconnect() {\n+        try {\n+            if (socket != null) {\n+                socket.close();\n+                socket = null;\n+                iStream = null;\n+                oStream = null;\n+            }\n+\n+        } catch (IOException ioe) {\n+            // TODO: handle exception\n+        }\n+    }\n+\n+    private byte[] sendRobustRequest(byte[] operation, byte[] register) throws IOException {\n+        return sendRobustRequest(operation, register, EMPTY);\n+    }\n+\n+    private byte[] sendRobustRequest(byte[] operation, byte[] register, byte[] value) throws IOException {\n+        if (socket == null) {\n+            throw new DisconnectedException();\n+        }\n+        byte[] request = new byte[4 + value.length];\n+        System.arraycopy(operation, 0, request, 0, 2);\n+        System.arraycopy(register, 0, request, 2, 2);\n+        System.arraycopy(value, 0, request, 4, value.length);\n+\n+        try {\n+            return sendRequest(request);\n+        } catch (IOException exIo) {\n+            logger.info(\"Connection to the air unit has been lost, reconnecting ({}).\", exIo.getMessage());\n+            connect();\n+            return sendRequest(request);\n+        }\n+    }\n+\n+    private synchronized byte[] sendRequest(byte[] request) throws IOException {\n+\n+        oStream.write(request);\n+        oStream.flush();\n+\n+        byte[] result = new byte[63];\n+        iStream.read(result, 0, 63);\n+\n+        return result;\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = sendRobustRequest(operation, register);\n+        return ByteBuffer.wrap(new byte[] { resultBytes[0], resultBytes[1] }).getShort();\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, byte value) throws IOException {\n+        byte[] valueArray = { value };\n+        sendRobustRequest(operation, register, valueArray);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, short value) throws IOException {\n+        ByteBuffer byteBuffer = ByteBuffer.allocate(2);\n+        byteBuffer.putShort(value);\n+        sendRobustRequest(operation, register, byteBuffer.array());", "originalCommit": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkyMjgwMA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385922800", "bodyText": "Rather than implementing your own cache. I would recommend using the one that already comes with the OH core.\nYou can find details here", "author": "cpmeister", "createdAt": "2020-02-28T21:08:22Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ValueCache.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.util.Calendar;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.types.State;\n+\n+/**\n+ * The {@link ValueCache} is responsible for holding the last value of the channels for a\n+ * certain amount of time {@link ValueCache#durationMs} to prevent unnecessary event bus updates if the value didn't\n+ * change.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ValueCache {", "originalCommit": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYxNzM2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390617366", "bodyText": "I think you might have missed this suggestion from my first review so I'll copy it here:\nRather than implementing your own cache. I would recommend using the one that already comes with the OH core.\nYou can find details here\nThe class I think would be most relevant to you would be org.eclipse.smarthome.core.cache.ExpiringCacheMap.", "author": "cpmeister", "createdAt": "2020-03-10T21:17:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkyMjgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkyNTAxMA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385925010", "bodyText": "Do you mean this?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            DiscoveryResult result = DiscoveryResultBuilder.create(uid).withRepresentationProperty(host)\n          \n          \n            \n                            DiscoveryResult result = DiscoveryResultBuilder.create(uid).withRepresentationProperty(\"host\")", "author": "cpmeister", "createdAt": "2020-02-28T21:14:19Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal.discovery;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Discovery service implementation to scan for available air units in the network via broadcast.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@Component(service = DiscoveryService.class, immediate = true)\n+@NonNullByDefault\n+public class DanfossAirUnitDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int BROADCAST_PORT = 30045;\n+    private static final byte[] DISCOVER_SEND = { 0x0c, 0x00, 0x30, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13 };\n+    private static final byte[] DISCOVER_RECEIVE = { 0x0d, 0x00, 0x07, 0x00, 0x02, 0x02, 0x00 };\n+\n+    private Logger logger = LoggerFactory.getLogger(DanfossAirUnitDiscoveryService.class);\n+\n+    public DanfossAirUnitDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 15, true);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Start Danfoss Air CCM background discovery\");\n+        scheduler.schedule(this::discover, 0, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        logger.debug(\"Start Danfoss Air CCM scan\");\n+        discover();\n+    }\n+\n+    private synchronized void discover() {\n+        logger.debug(\"Try to discover all Danfoss Air CCM devices\");\n+\n+        try (DatagramSocket socket = new DatagramSocket()) {\n+\n+            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n+            while (interfaces.hasMoreElements()) {\n+                NetworkInterface networkInterface = interfaces.nextElement();\n+                if (networkInterface == null || networkInterface.isLoopback() || !networkInterface.isUp()) {\n+                    continue;\n+                }\n+                for (InterfaceAddress interfaceAddress : networkInterface.getInterfaceAddresses()) {\n+                    if (interfaceAddress == null || interfaceAddress.getBroadcast() == null) {\n+                        continue;\n+                    }\n+                    logger.debug(\"Sending broadcast on interface {} to discover Danfoss Air CCM device...\",\n+                            interfaceAddress.getAddress().toString());\n+                    sendBroadcastToDiscoverThing(socket, interfaceAddress.getBroadcast());\n+                }\n+            }\n+\n+        } catch (IOException e) {\n+            logger.debug(\"No Danfoss Air CCM device found. Diagnostic: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void sendBroadcastToDiscoverThing(DatagramSocket socket, InetAddress broadcastAddress) throws IOException {\n+        socket.setBroadcast(true);\n+        socket.setSoTimeout(5000);\n+        // send discover\n+        byte[] sendBuffer = DISCOVER_SEND;\n+        DatagramPacket sendPacket = new DatagramPacket(sendBuffer, sendBuffer.length, broadcastAddress, BROADCAST_PORT);\n+        socket.send(sendPacket);\n+        logger.debug(\"Disover message sent\");\n+\n+        // wait for responses\n+        while (true) {\n+            byte[] receiveBuffer = new byte[7];\n+            DatagramPacket receivePacket = new DatagramPacket(receiveBuffer, receiveBuffer.length);\n+            try {\n+                socket.receive(receivePacket);\n+            } catch (SocketTimeoutException e) {\n+                break; // leave the endless loop\n+            }\n+\n+            byte[] data = receivePacket.getData();\n+            if (Arrays.equals(data, DISCOVER_RECEIVE)) {\n+                logger.debug(\"Disover received correct response\");\n+\n+                String host = receivePacket.getAddress().getHostName();\n+                Map<String, Object> properties = new HashMap<>();\n+                properties.put(\"host\", host);\n+\n+                logger.debug(\"Adding a new Danfoss Air Unit CCM '{}' to inbox\", host);\n+\n+                ThingUID uid = new ThingUID(THING_TYPE_AIRUNIT, String.valueOf(receivePacket.getAddress().hashCode()));\n+\n+                DiscoveryResult result = DiscoveryResultBuilder.create(uid).withRepresentationProperty(host)", "originalCommit": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNzA4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385937089", "bodyText": "This type of Exception isn't handled in any special way in the rest of the code. I would suggest using an IllegalArgumentException instead.", "author": "cpmeister", "createdAt": "2020-02-28T21:45:46Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/InvalidDateTimeException.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * An Exception thrown when a value received from the air unit cannot be interpreted as DateTime value.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InvalidDateTimeException extends RuntimeException {", "originalCommit": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNzM5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385937399", "bodyText": "This type of Exception isn't handled in any special way in the rest of the code. I would suggest using an IllegalArgumentException instead.", "author": "cpmeister", "createdAt": "2020-02-28T21:46:38Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/InvalidTemperatureException.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * An Exception thrown when a value received from the air unit cannot be interpreted as temperature value.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InvalidTemperatureException extends RuntimeException {", "originalCommit": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNzY2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385937661", "bodyText": "This type of Exception isn't handled in any special way in the rest of the code. I would suggest using an IOException instead.", "author": "cpmeister", "createdAt": "2020-02-28T21:47:24Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DisconnectedException.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Represents a communication failure with the air unit when it has not been connected.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DisconnectedException extends RuntimeException {", "originalCommit": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MjEyNw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389392127", "bodyText": "This exception isn't used anywhere now, please delete this class", "author": "cpmeister", "createdAt": "2020-03-08T18:06:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNzY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODU5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389208596", "bodyText": "Please make these fields private and final", "author": "cpmeister", "createdAt": "2020-03-07T00:53:40Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Channel.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+/**\n+ * This enum holds the available channels with their properties (name, ...) and read/write accessors to access\n+ * the corresponding values on the air unit.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+public enum Channel {\n+\n+    // Main Channels\n+\n+    CHANNEL_CURRENT_TIME(\"current_time\", ChannelGroup.MAIN, DanfossHRV::getCurrentTime),\n+    CHANNEL_MODE(\"mode\", ChannelGroup.MAIN, DanfossHRV::getMode, DanfossHRV::setMode),\n+    CHANNEL_MANUAL_FAN_SPEED(\"manual_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getManualFanSpeed,\n+            DanfossHRV::setManualFanSpeed),\n+    CHANNEL_EXTRACT_FAN_SPEED(\"extract_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getExtractFanSpeed),\n+    CHANNEL_SUPPLY_FAN_SPEED(\"supply_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getSupplyFanSpeed),\n+\n+    CHANNEL_BOOST(\"boost\", ChannelGroup.MAIN, DanfossHRV::getBoost, DanfossHRV::setBoost),\n+    CHANNEL_NIGHT_COOLING(\"night_cooling\", ChannelGroup.MAIN, DanfossHRV::getNightCooling, DanfossHRV::setNightCooling),\n+\n+    // Main Temperature Channels\n+    CHANNEL_ROOM_TEMP(\"room_temp\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperature),\n+    CHANNEL_ROOM_TEMP_CALCULATED(\"room_temp_calculated\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperatureCalculated),\n+    CHANNEL_OUTDOOR_TEMP(\"outdoor_temp\", ChannelGroup.TEMPS, DanfossHRV::getOutdoorTemperature),\n+\n+    // Humidity Channel\n+    CHANNEL_HUMIDITY(\"humidity\", ChannelGroup.HUMIDITY, DanfossHRV::getHumidity),\n+\n+    // recuperator channels\n+    CHANNEL_BYPASS(\"bypass\", ChannelGroup.RECUPERATOR, DanfossHRV::getBypass, DanfossHRV::setBypass),\n+    CHANNEL_SUPPLY_TEMP(\"supply_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getSupplyTemperature),\n+    CHANNEL_EXTRACT_TEMP(\"extract_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExtractTemperature),\n+    CHANNEL_EXHAUST_TEMP(\"exhaust_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExhaustTemperature),\n+\n+    // service channels\n+    CHANNEL_BATTERY_LIFE(\"battery_life\", ChannelGroup.SERVICE, DanfossHRV::getBatteryLife),\n+    CHANNEL_FILTER_LIFE(\"filter_life\", ChannelGroup.SERVICE, DanfossHRV::getFilterLife);\n+\n+    String channelName;\n+    ChannelGroup group;\n+    DanfossAirUnitReadAccessor readAccessor;\n+    DanfossAirUnitWriteAccessor writeAccessor = null;", "originalCommit": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODY0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389208643", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Channel(String channelName, ChannelGroup group, DanfossAirUnitReadAccessor readAccessor) {\n          \n          \n            \n                private Channel(String channelName, ChannelGroup group, DanfossAirUnitReadAccessor readAccessor) {", "author": "cpmeister", "createdAt": "2020-03-07T00:54:02Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Channel.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+/**\n+ * This enum holds the available channels with their properties (name, ...) and read/write accessors to access\n+ * the corresponding values on the air unit.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+public enum Channel {\n+\n+    // Main Channels\n+\n+    CHANNEL_CURRENT_TIME(\"current_time\", ChannelGroup.MAIN, DanfossHRV::getCurrentTime),\n+    CHANNEL_MODE(\"mode\", ChannelGroup.MAIN, DanfossHRV::getMode, DanfossHRV::setMode),\n+    CHANNEL_MANUAL_FAN_SPEED(\"manual_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getManualFanSpeed,\n+            DanfossHRV::setManualFanSpeed),\n+    CHANNEL_EXTRACT_FAN_SPEED(\"extract_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getExtractFanSpeed),\n+    CHANNEL_SUPPLY_FAN_SPEED(\"supply_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getSupplyFanSpeed),\n+\n+    CHANNEL_BOOST(\"boost\", ChannelGroup.MAIN, DanfossHRV::getBoost, DanfossHRV::setBoost),\n+    CHANNEL_NIGHT_COOLING(\"night_cooling\", ChannelGroup.MAIN, DanfossHRV::getNightCooling, DanfossHRV::setNightCooling),\n+\n+    // Main Temperature Channels\n+    CHANNEL_ROOM_TEMP(\"room_temp\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperature),\n+    CHANNEL_ROOM_TEMP_CALCULATED(\"room_temp_calculated\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperatureCalculated),\n+    CHANNEL_OUTDOOR_TEMP(\"outdoor_temp\", ChannelGroup.TEMPS, DanfossHRV::getOutdoorTemperature),\n+\n+    // Humidity Channel\n+    CHANNEL_HUMIDITY(\"humidity\", ChannelGroup.HUMIDITY, DanfossHRV::getHumidity),\n+\n+    // recuperator channels\n+    CHANNEL_BYPASS(\"bypass\", ChannelGroup.RECUPERATOR, DanfossHRV::getBypass, DanfossHRV::setBypass),\n+    CHANNEL_SUPPLY_TEMP(\"supply_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getSupplyTemperature),\n+    CHANNEL_EXTRACT_TEMP(\"extract_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExtractTemperature),\n+    CHANNEL_EXHAUST_TEMP(\"exhaust_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExhaustTemperature),\n+\n+    // service channels\n+    CHANNEL_BATTERY_LIFE(\"battery_life\", ChannelGroup.SERVICE, DanfossHRV::getBatteryLife),\n+    CHANNEL_FILTER_LIFE(\"filter_life\", ChannelGroup.SERVICE, DanfossHRV::getFilterLife);\n+\n+    String channelName;\n+    ChannelGroup group;\n+    DanfossAirUnitReadAccessor readAccessor;\n+    DanfossAirUnitWriteAccessor writeAccessor = null;\n+\n+    static Channel getByName(String name) {\n+        for (Channel channel : values()) {\n+            if (channel.getChannelName().equals(name)) {\n+                return channel;\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Unknown channel name: %s\", name));\n+    }\n+\n+    Channel(String channelName, ChannelGroup group, DanfossAirUnitReadAccessor readAccessor) {", "originalCommit": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI1MDAxMA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389250010", "bodyText": "Enum constructors are always private and thus this redundant.", "author": "pravussum", "createdAt": "2020-03-07T12:02:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODY2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389208665", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Channel(String channelName, ChannelGroup group, DanfossAirUnitReadAccessor readAccessor,\n          \n          \n            \n                private Channel(String channelName, ChannelGroup group, DanfossAirUnitReadAccessor readAccessor,", "author": "cpmeister", "createdAt": "2020-03-07T00:54:12Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Channel.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+/**\n+ * This enum holds the available channels with their properties (name, ...) and read/write accessors to access\n+ * the corresponding values on the air unit.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+public enum Channel {\n+\n+    // Main Channels\n+\n+    CHANNEL_CURRENT_TIME(\"current_time\", ChannelGroup.MAIN, DanfossHRV::getCurrentTime),\n+    CHANNEL_MODE(\"mode\", ChannelGroup.MAIN, DanfossHRV::getMode, DanfossHRV::setMode),\n+    CHANNEL_MANUAL_FAN_SPEED(\"manual_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getManualFanSpeed,\n+            DanfossHRV::setManualFanSpeed),\n+    CHANNEL_EXTRACT_FAN_SPEED(\"extract_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getExtractFanSpeed),\n+    CHANNEL_SUPPLY_FAN_SPEED(\"supply_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getSupplyFanSpeed),\n+\n+    CHANNEL_BOOST(\"boost\", ChannelGroup.MAIN, DanfossHRV::getBoost, DanfossHRV::setBoost),\n+    CHANNEL_NIGHT_COOLING(\"night_cooling\", ChannelGroup.MAIN, DanfossHRV::getNightCooling, DanfossHRV::setNightCooling),\n+\n+    // Main Temperature Channels\n+    CHANNEL_ROOM_TEMP(\"room_temp\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperature),\n+    CHANNEL_ROOM_TEMP_CALCULATED(\"room_temp_calculated\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperatureCalculated),\n+    CHANNEL_OUTDOOR_TEMP(\"outdoor_temp\", ChannelGroup.TEMPS, DanfossHRV::getOutdoorTemperature),\n+\n+    // Humidity Channel\n+    CHANNEL_HUMIDITY(\"humidity\", ChannelGroup.HUMIDITY, DanfossHRV::getHumidity),\n+\n+    // recuperator channels\n+    CHANNEL_BYPASS(\"bypass\", ChannelGroup.RECUPERATOR, DanfossHRV::getBypass, DanfossHRV::setBypass),\n+    CHANNEL_SUPPLY_TEMP(\"supply_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getSupplyTemperature),\n+    CHANNEL_EXTRACT_TEMP(\"extract_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExtractTemperature),\n+    CHANNEL_EXHAUST_TEMP(\"exhaust_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExhaustTemperature),\n+\n+    // service channels\n+    CHANNEL_BATTERY_LIFE(\"battery_life\", ChannelGroup.SERVICE, DanfossHRV::getBatteryLife),\n+    CHANNEL_FILTER_LIFE(\"filter_life\", ChannelGroup.SERVICE, DanfossHRV::getFilterLife);\n+\n+    String channelName;\n+    ChannelGroup group;\n+    DanfossAirUnitReadAccessor readAccessor;\n+    DanfossAirUnitWriteAccessor writeAccessor = null;\n+\n+    static Channel getByName(String name) {\n+        for (Channel channel : values()) {\n+            if (channel.getChannelName().equals(name)) {\n+                return channel;\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Unknown channel name: %s\", name));\n+    }\n+\n+    Channel(String channelName, ChannelGroup group, DanfossAirUnitReadAccessor readAccessor) {\n+        this.channelName = channelName;\n+        this.group = group;\n+        this.readAccessor = readAccessor;\n+    }\n+\n+    Channel(String channelName, ChannelGroup group, DanfossAirUnitReadAccessor readAccessor,", "originalCommit": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI1MDA4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389250089", "bodyText": "Enum constructors are always private, thus this is redundant (even a warning in IntelliJ)", "author": "pravussum", "createdAt": "2020-03-07T12:03:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODY2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODc0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389208749", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ChannelGroup(String groupName) {\n          \n          \n            \n                private ChannelGroup(String groupName) {", "author": "cpmeister", "createdAt": "2020-03-07T00:54:33Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ChannelGroup.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+/**\n+ * Represents a channel group, channels are divided into.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+public enum ChannelGroup {\n+    MAIN(\"main\"),\n+    TEMPS(\"temps\"),\n+    HUMIDITY(\"humidity\"),\n+    RECUPERATOR(\"recuperator\"),\n+    SERVICE(\"service\");\n+\n+    ChannelGroup(String groupName) {", "originalCommit": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwOTk2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389209969", "bodyText": "IOException shouldn't be ignored, you should log it at the very least.", "author": "cpmeister", "createdAt": "2020-03-07T01:02:26Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.*;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossHRV} class does the actual network communication with the air unit.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@NonNullByDefault\n+public class DanfossHRV implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossHRV.class);\n+\n+    private InetAddress inetAddr;\n+    private int port;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossHRV(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public synchronized void connect() throws IOException {\n+        socket = new Socket(inetAddr, port);\n+        oStream = socket.getOutputStream();\n+        iStream = socket.getInputStream();\n+    }\n+\n+    public synchronized void disconnect() {\n+        try {\n+            if (socket != null) {\n+                socket.close();\n+            }\n+        } catch (IOException ignore) {\n+        } finally {", "originalCommit": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMTEzNA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389211134", "bodyText": "What are you expecting to throw this?", "author": "cpmeister", "createdAt": "2020-03-07T01:10:49Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossHRV hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            if (hrv == null) {\n+                return;\n+            }\n+            try {\n+                DanfossHRV danfossHRV = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                hrv.connect();\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossHRV, command));\n+                }\n+            } catch (IllegalArgumentException e) {", "originalCommit": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI1MDc5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389250796", "bodyText": "I had this kind of exceptions in the past (probably due to concurrency issues as I know now), but I'd like to keep that in place to gracefully handle any communication problems in the \"right place\". The exception is originally thrown in sendRequest() method (former DanfossHRV class, now DanfossAirUnitCommunicationController).", "author": "pravussum", "createdAt": "2020-03-07T12:15:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMTEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMzA5MA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389213090", "bodyText": "\ud83e\udd26\u200d\u2642 This isn't what I meant by synchronizing connect()...disconnect() logic. I will elaborate on what I meant.\nRight now all of your communication logic happens in short bursts: connect->send/receive messages -> disconnect.\nThe issue I'm trying to point out is what happens when, lets say, a RefreshCommand and a your scheduled updateAllChannels() happen at the same time? Whichever one calls connect() first will have its socket instance overwritten by the second call to connect(), this will cause a number of problems depending on when the second call occurs. The most important problem is that if you overwrite the socket instance before closing it, it will never get closed! In the worst case this could eventually lead to crashing either openhab or the airunit you are talking to.", "author": "cpmeister", "createdAt": "2020-03-07T01:25:35Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.*;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossHRV} class does the actual network communication with the air unit.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@NonNullByDefault\n+public class DanfossHRV implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossHRV.class);\n+\n+    private InetAddress inetAddr;\n+    private int port;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossHRV(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public synchronized void connect() throws IOException {", "originalCommit": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI1MDY0NA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389250644", "bodyText": "Ah ok, got your point. Very good one indeed. I refactored the whole connection & request handling to encapsulate it in one class (which is used by the the scheduled job and the updateChannel method in turn). The connect & disconnect & request methods are synchronized.\nA broken connection will block one of the scheduler threads until the timeout, though. I take it the scheduler threads are shared between all bindings? My assumption for now is that this won't pose a problem. If it does, is there a \"proper\" way to handle that?", "author": "pravussum", "createdAt": "2020-03-07T12:12:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMzA5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MDQ4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389390489", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    scheduler.schedule(this::discover, 0, TimeUnit.SECONDS);\n          \n          \n            \n                    scheduler.execute(this::discover);", "author": "cpmeister", "createdAt": "2020-03-08T17:42:50Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal.discovery;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Discovery service implementation to scan for available air units in the network via broadcast.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@Component(service = DiscoveryService.class, immediate = true)\n+@NonNullByDefault\n+public class DanfossAirUnitDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int BROADCAST_PORT = 30045;\n+    private static final byte[] DISCOVER_SEND = { 0x0c, 0x00, 0x30, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13 };\n+    private static final byte[] DISCOVER_RECEIVE = { 0x0d, 0x00, 0x07, 0x00, 0x02, 0x02, 0x00 };\n+\n+    private Logger logger = LoggerFactory.getLogger(DanfossAirUnitDiscoveryService.class);\n+\n+    public DanfossAirUnitDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 15, true);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Start Danfoss Air CCM background discovery\");\n+        scheduler.schedule(this::discover, 0, TimeUnit.SECONDS);", "originalCommit": "135ef20d83e815afa86904aabd4bbf102be92315", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MjYxMA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389392610", "bodyText": "IllegalArgumentException should be reserved for invalid or incorrect arguments to a function or constructor. This case is neither of those as you are handling a response message. You should either throw an IOException or return Float.NaN then handle the NaN case elsewhere in your code.", "author": "cpmeister", "createdAt": "2020-03-08T18:12:49Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@SuppressWarnings(\"SameParameterValue\")\n+@NonNullByDefault\n+public class DanfossAirUnit implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n+\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n+    }\n+\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = communicationController.sendRobustRequest(operation, register);\n+        return (short)((resultBytes[0] << 8)  | (resultBytes[1] & 0xFF));\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, byte value) throws IOException {\n+        byte[] valueArray = { value };\n+        communicationController.sendRobustRequest(operation, register, valueArray);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, short value) throws IOException {\n+        communicationController.sendRobustRequest(operation, register, shortToBytes(value));\n+    }\n+\n+    private byte[] shortToBytes(short s) {\n+        return new byte[]{(byte)((s & 0xFF00) >> 8),(byte)(s & 0x00FF)};\n+    }\n+\n+    private short getShort(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return (short) ((result[0] << 8) + (result[1] & 0xff));\n+    }\n+\n+    private float getTemperature(byte[] operation, byte[] register) throws IOException {\n+        short shortTemp = getShort(operation, register);\n+        float temp = ((float) shortTemp) / 100;\n+        if (temp <= -274 || temp > 100) {\n+            throw new IllegalArgumentException(String.format(\"Invalid temperature: %s\", temp));", "originalCommit": "135ef20d83e815afa86904aabd4bbf102be92315", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5Mjg2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389392867", "bodyText": "Is this supposed to be a signed byte value? This code will allow years in the range 1872-2127. Just checking if that is what you are expecting.", "author": "cpmeister", "createdAt": "2020-03-08T18:16:10Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@SuppressWarnings(\"SameParameterValue\")\n+@NonNullByDefault\n+public class DanfossAirUnit implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n+\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n+    }\n+\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = communicationController.sendRobustRequest(operation, register);\n+        return (short)((resultBytes[0] << 8)  | (resultBytes[1] & 0xFF));\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, byte value) throws IOException {\n+        byte[] valueArray = { value };\n+        communicationController.sendRobustRequest(operation, register, valueArray);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, short value) throws IOException {\n+        communicationController.sendRobustRequest(operation, register, shortToBytes(value));\n+    }\n+\n+    private byte[] shortToBytes(short s) {\n+        return new byte[]{(byte)((s & 0xFF00) >> 8),(byte)(s & 0x00FF)};\n+    }\n+\n+    private short getShort(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return (short) ((result[0] << 8) + (result[1] & 0xff));\n+    }\n+\n+    private float getTemperature(byte[] operation, byte[] register) throws IOException {\n+        short shortTemp = getShort(operation, register);\n+        float temp = ((float) shortTemp) / 100;\n+        if (temp <= -274 || temp > 100) {\n+            throw new IllegalArgumentException(String.format(\"Invalid temperature: %s\", temp));\n+        }\n+        return temp;\n+    }\n+\n+    private ZonedDateTime getTimestamp(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return asZonedDateTime(result);\n+    }\n+\n+    private ZonedDateTime asZonedDateTime(byte[] data) {\n+        int second = data[0];\n+        int minute = data[1];\n+        int hour = data[2] & 0x1f;\n+        int day = data[3] & 0x1f;\n+        int month = data[4];\n+        int year = data[5] + 2000;", "originalCommit": "135ef20d83e815afa86904aabd4bbf102be92315", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQxMzkwNw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389413907", "bodyText": "Right now it's working as expected. Got no real documentation of the protocol, though :-(", "author": "pravussum", "createdAt": "2020-03-08T22:47:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5Mjg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MzMxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389393315", "bodyText": "I wouldn't throw an IllegalArgumentException. Similar to reasons I mentioned above. This code is used to process response messages and as such it should be a checked exception like an IOException.", "author": "cpmeister", "createdAt": "2020-03-08T18:22:25Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@SuppressWarnings(\"SameParameterValue\")\n+@NonNullByDefault\n+public class DanfossAirUnit implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n+\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n+    }\n+\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = communicationController.sendRobustRequest(operation, register);\n+        return (short)((resultBytes[0] << 8)  | (resultBytes[1] & 0xFF));\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, byte value) throws IOException {\n+        byte[] valueArray = { value };\n+        communicationController.sendRobustRequest(operation, register, valueArray);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, short value) throws IOException {\n+        communicationController.sendRobustRequest(operation, register, shortToBytes(value));\n+    }\n+\n+    private byte[] shortToBytes(short s) {\n+        return new byte[]{(byte)((s & 0xFF00) >> 8),(byte)(s & 0x00FF)};\n+    }\n+\n+    private short getShort(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return (short) ((result[0] << 8) + (result[1] & 0xff));\n+    }\n+\n+    private float getTemperature(byte[] operation, byte[] register) throws IOException {\n+        short shortTemp = getShort(operation, register);\n+        float temp = ((float) shortTemp) / 100;\n+        if (temp <= -274 || temp > 100) {\n+            throw new IllegalArgumentException(String.format(\"Invalid temperature: %s\", temp));\n+        }\n+        return temp;\n+    }\n+\n+    private ZonedDateTime getTimestamp(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return asZonedDateTime(result);\n+    }\n+\n+    private ZonedDateTime asZonedDateTime(byte[] data) {\n+        int second = data[0];\n+        int minute = data[1];\n+        int hour = data[2] & 0x1f;\n+        int day = data[3] & 0x1f;\n+        int month = data[4];\n+        int year = data[5] + 2000;\n+        try {\n+            return ZonedDateTime.of(year, month, day, hour, minute, second, 0, ZoneId.systemDefault());\n+        } catch (DateTimeException e) {\n+            logger.debug(\"Ignoring invalid timestamp {}.{}.{} {}:{}:{}\", day, month, year, hour, minute, second);\n+            throw new IllegalArgumentException();", "originalCommit": "135ef20d83e815afa86904aabd4bbf102be92315", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MzM0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389393349", "bodyText": "Not UTF-8? Unusual.", "author": "cpmeister", "createdAt": "2020-03-08T18:23:04Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@SuppressWarnings(\"SameParameterValue\")\n+@NonNullByDefault\n+public class DanfossAirUnit implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n+\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n+    }\n+\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = communicationController.sendRobustRequest(operation, register);\n+        return (short)((resultBytes[0] << 8)  | (resultBytes[1] & 0xFF));\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);", "originalCommit": "135ef20d83e815afa86904aabd4bbf102be92315", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQxNDE1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389414153", "bodyText": "Same as above. Right now working as expected  (the devices unit name is reported correctly), but no real documentation.", "author": "pravussum", "createdAt": "2020-03-08T22:50:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MzM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5NDg3OA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389394878", "bodyText": "You shouldn't catch RuntimeException here. If you are trying to catch exceptions that occur in your accessor then then your accessor should throw checked exceptions that you can then handle here.", "author": "cpmeister", "createdAt": "2020-03-08T18:45:34Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                pollingJob = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 5, config.refreshInterval,\n+                        TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+            }\n+        });\n+    }\n+\n+    private void updateAllChannels() {\n+        if (hrv == null) {\n+            return;\n+        }\n+        DanfossAirUnit danfossAirUnit = hrv;\n+        logger.debug(\"Updating DanfossHRV data '{}'\", getThing().getUID());\n+\n+        try {\n+            for (Channel channel : Channel.values()) {\n+                if (Thread.interrupted()) {\n+                    logger.debug(\"Polling thread interrupted...\");\n+                    return;\n+                }\n+                try {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(),\n+                            channel.getReadAccessor().access(danfossAirUnit));\n+                } catch (RuntimeException e) {", "originalCommit": "135ef20d83e815afa86904aabd4bbf102be92315", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQ3MTcxNg==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389471716", "bodyText": "Please move this field above the constructor", "author": "cpmeister", "createdAt": "2020-03-09T05:44:27Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ChannelGroup.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+/**\n+ * Represents a channel group, channels are divided into.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+public enum ChannelGroup {\n+    MAIN(\"main\"),\n+    TEMPS(\"temps\"),\n+    HUMIDITY(\"humidity\"),\n+    RECUPERATOR(\"recuperator\"),\n+    SERVICE(\"service\");\n+\n+    ChannelGroup(String groupName) {\n+        this.groupName = groupName;\n+    }\n+\n+    private String groupName;", "originalCommit": "04f171986cfdf5462a02a68015ddca808913c996", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU3OTQwMg==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390579402", "bodyText": "Putting constants into interfaces is no longer considered a good coding practice.\nI would suggest making this a class and then use static imports instead.", "author": "cpmeister", "createdAt": "2020-03-10T20:06:38Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Commands.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link Commands} interface holds the commands which can be send to the air unit to read/write values or trigger\n+ * actions.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public interface Commands {", "originalCommit": "7ae36564597a2284590a7bbc8bd8fe72bd8cd3a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU3OTcwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390579709", "bodyText": "See above", "author": "cpmeister", "createdAt": "2020-03-10T20:07:11Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitBindingConstants.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link DanfossAirUnitBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public interface DanfossAirUnitBindingConstants {", "originalCommit": "7ae36564597a2284590a7bbc8bd8fe72bd8cd3a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4MjQ1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390582455", "bodyText": "Since your temperature channels now have an item type of Number:Temperature. You should make sure to use QuantityType<Temperature> instead of DecimalType.", "author": "cpmeister", "createdAt": "2020-03-10T20:12:34Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@SuppressWarnings(\"SameParameterValue\")\n+@NonNullByDefault\n+public class DanfossAirUnit implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n+\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n+    }\n+\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = communicationController.sendRobustRequest(operation, register);\n+        return (short)((resultBytes[0] << 8)  | (resultBytes[1] & 0xFF));\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, byte value) throws IOException {\n+        byte[] valueArray = { value };\n+        communicationController.sendRobustRequest(operation, register, valueArray);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, short value) throws IOException {\n+        communicationController.sendRobustRequest(operation, register, shortToBytes(value));\n+    }\n+\n+    private byte[] shortToBytes(short s) {\n+        return new byte[]{(byte)((s & 0xFF00) >> 8),(byte)(s & 0x00FF)};\n+    }\n+\n+    private short getShort(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return (short) ((result[0] << 8) + (result[1] & 0xff));\n+    }\n+\n+    private float getTemperature(byte[] operation, byte[] register) throws IOException, UnexpectedResponseValueException {\n+        short shortTemp = getShort(operation, register);\n+        float temp = ((float) shortTemp) / 100;\n+        if (temp <= -274 || temp > 100) {\n+            throw new UnexpectedResponseValueException(String.format(\"Invalid temperature: %s\", temp));\n+        }\n+        return temp;\n+    }\n+\n+    private ZonedDateTime getTimestamp(byte[] operation, byte[] register) throws IOException, UnexpectedResponseValueException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return asZonedDateTime(result);\n+    }\n+\n+    private ZonedDateTime asZonedDateTime(byte[] data) throws UnexpectedResponseValueException {\n+        int second = data[0];\n+        int minute = data[1];\n+        int hour = data[2] & 0x1f;\n+        int day = data[3] & 0x1f;\n+        int month = data[4];\n+        int year = data[5] + 2000;\n+        try {\n+            return ZonedDateTime.of(year, month, day, hour, minute, second, 0, ZoneId.systemDefault());\n+        } catch (DateTimeException e) {\n+            String msg = String.format(\"Ignoring invalid timestamp %s.%s.%s %s:%s:%s\", day, month, year, hour, minute,\n+                    second);\n+            logger.debug(msg);\n+            throw new UnexpectedResponseValueException(msg);\n+        }\n+    }\n+\n+    private static int asUnsignedByte(byte b) {\n+        return b & 0xFF;\n+    }\n+\n+    private static float asPercentByte(byte b) {\n+        float f = asUnsignedByte(b);\n+        return f * 100 / 255;\n+    }\n+\n+    private void setSetting(byte[] register, short value) throws IOException {\n+        byte[] valueArray = new byte[2];\n+        valueArray[0] = (byte) (value >> 8);\n+        valueArray[1] = (byte) value;\n+\n+        communicationController.sendRobustRequest(REGISTER_1_WRITE, register, valueArray);\n+    }\n+\n+    public String getUnitName() throws IOException {\n+        return getString(REGISTER_1_READ, UNIT_NAME);\n+    }\n+\n+    public String getUnitSerialNumber() throws IOException {\n+        return String.valueOf(getShort(REGISTER_4_READ, UNIT_SERIAL));\n+    }\n+\n+    public StringType getMode() throws IOException {\n+        return new StringType(Mode.values()[getByte(REGISTER_1_READ, MODE)].name());\n+    }\n+\n+    public PercentType getManualFanSpeed() throws IOException {\n+        return new PercentType(BigDecimal.valueOf(getByte(REGISTER_1_READ, MANUAL_FAN_SPEED_STEP) * 10));\n+    }\n+\n+    public DecimalType getSupplyFanSpeed() throws IOException {\n+        return new DecimalType(BigDecimal.valueOf(getWord(REGISTER_4_READ, SUPPLY_FAN_SPEED)));\n+    }\n+\n+    public DecimalType getExtractFanSpeed() throws IOException {\n+        return new DecimalType(BigDecimal.valueOf(getWord(REGISTER_4_READ, EXTRACT_FAN_SPEED)));\n+    }\n+\n+    public PercentType getSupplyFanStep() throws IOException {\n+        return new PercentType(BigDecimal.valueOf(getByte(REGISTER_4_READ, SUPPLY_FAN_STEP)));\n+    }\n+\n+    public PercentType getExtractFanStep() throws IOException {\n+        return new PercentType(BigDecimal.valueOf(getByte(REGISTER_4_READ, EXTRACT_FAN_STEP)));\n+    }\n+\n+    public OnOffType getBoost() throws IOException {\n+        return getBoolean(REGISTER_1_READ, BOOST) ? OnOffType.ON : OnOffType.OFF;\n+    }\n+\n+    public OnOffType getNightCooling() throws IOException {\n+        return getBoolean(REGISTER_1_READ, NIGHT_COOLING) ? OnOffType.ON : OnOffType.OFF;\n+    }\n+\n+    public OnOffType getBypass() throws IOException {\n+        return getBoolean(REGISTER_1_READ, BYPASS) ? OnOffType.ON : OnOffType.OFF;\n+    }\n+\n+    public DecimalType getHumidity() throws IOException {\n+        BigDecimal value = BigDecimal.valueOf(asPercentByte(getByte(REGISTER_1_READ, HUMIDITY)));\n+        return new DecimalType(value.setScale(1, RoundingMode.HALF_UP));\n+    }\n+\n+    public DecimalType getRoomTemperature() throws IOException, UnexpectedResponseValueException {\n+        return getTemperatureAsDecimalType(REGISTER_1_READ, ROOM_TEMPERATURE);\n+    }\n+\n+    public DecimalType getRoomTemperatureCalculated() throws IOException, UnexpectedResponseValueException {\n+        return getTemperatureAsDecimalType(REGISTER_0_READ, ROOM_TEMPERATURE_CALCULATED);\n+    }\n+\n+    public DecimalType getOutdoorTemperature() throws IOException, UnexpectedResponseValueException {\n+        return getTemperatureAsDecimalType(REGISTER_1_READ, OUTDOOR_TEMPERATURE);\n+    }\n+\n+    public DecimalType getSupplyTemperature() throws IOException, UnexpectedResponseValueException {\n+        return getTemperatureAsDecimalType(REGISTER_4_READ, SUPPLY_TEMPERATURE);\n+    }\n+\n+    public DecimalType getExtractTemperature() throws IOException, UnexpectedResponseValueException {\n+        return getTemperatureAsDecimalType(REGISTER_4_READ, EXTRACT_TEMPERATURE);\n+    }\n+\n+    public DecimalType getExhaustTemperature() throws IOException, UnexpectedResponseValueException {\n+        return getTemperatureAsDecimalType(REGISTER_4_READ, EXHAUST_TEMPERATURE);\n+    }", "originalCommit": "7ae36564597a2284590a7bbc8bd8fe72bd8cd3a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4NzQwOA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390587408", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                \"Unknown host: \" + config.host);\n          \n          \n            \n                    }\n          \n          \n            \n                                \"Unknown host: \" + config.host);\n          \n          \n            \n                        return;\n          \n          \n            \n                    }", "author": "cpmeister", "createdAt": "2020-03-10T20:21:51Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+        }", "originalCommit": "7ae36564597a2284590a7bbc8bd8fe72bd8cd3a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1NDQ5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390654495", "bodyText": "Pew, good find, thank you!", "author": "pravussum", "createdAt": "2020-03-10T22:45:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4NzQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4ODU5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390588592", "bodyText": "Shouldn't this be considered a configuration error instead of a communication error?", "author": "cpmeister", "createdAt": "2020-03-10T20:24:02Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,", "originalCommit": "7ae36564597a2284590a7bbc8bd8fe72bd8cd3a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1NTYxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390655619", "bodyText": "Not necessarily. Network might be temporarily down, configured hostname/IP might be wrong - in my opinion \"communication error\" covers both cases, while \"config error\" does not.", "author": "pravussum", "createdAt": "2020-03-10T22:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4ODU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU5MTQ2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390591461", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.debug(\"Disover message sent\");\n          \n          \n            \n                    logger.debug(\"Discover message sent\");", "author": "cpmeister", "createdAt": "2020-03-10T20:29:06Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal.discovery;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Discovery service implementation to scan for available air units in the network via broadcast.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@Component(service = DiscoveryService.class, immediate = true)\n+@NonNullByDefault\n+public class DanfossAirUnitDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int BROADCAST_PORT = 30045;\n+    private static final byte[] DISCOVER_SEND = { 0x0c, 0x00, 0x30, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13 };\n+    private static final byte[] DISCOVER_RECEIVE = { 0x0d, 0x00, 0x07, 0x00, 0x02, 0x02, 0x00 };\n+\n+    private Logger logger = LoggerFactory.getLogger(DanfossAirUnitDiscoveryService.class);\n+\n+    public DanfossAirUnitDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 15, true);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Start Danfoss Air CCM background discovery\");\n+        scheduler.execute(this::discover);\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        logger.debug(\"Start Danfoss Air CCM scan\");\n+        discover();\n+    }\n+\n+    private synchronized void discover() {\n+        logger.debug(\"Try to discover all Danfoss Air CCM devices\");\n+\n+        try (DatagramSocket socket = new DatagramSocket()) {\n+\n+            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n+            while (interfaces.hasMoreElements()) {\n+                NetworkInterface networkInterface = interfaces.nextElement();\n+                if (networkInterface == null || networkInterface.isLoopback() || !networkInterface.isUp()) {\n+                    continue;\n+                }\n+                for (InterfaceAddress interfaceAddress : networkInterface.getInterfaceAddresses()) {\n+                    if (interfaceAddress == null || interfaceAddress.getBroadcast() == null) {\n+                        continue;\n+                    }\n+                    logger.debug(\"Sending broadcast on interface {} to discover Danfoss Air CCM device...\",\n+                            interfaceAddress.getAddress().toString());\n+                    sendBroadcastToDiscoverThing(socket, interfaceAddress.getBroadcast());\n+                }\n+            }\n+\n+        } catch (IOException e) {\n+            logger.debug(\"No Danfoss Air CCM device found. Diagnostic: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void sendBroadcastToDiscoverThing(DatagramSocket socket, InetAddress broadcastAddress) throws IOException {\n+        socket.setBroadcast(true);\n+        socket.setSoTimeout(5000);\n+        // send discover\n+        byte[] sendBuffer = DISCOVER_SEND;\n+        DatagramPacket sendPacket = new DatagramPacket(sendBuffer, sendBuffer.length, broadcastAddress, BROADCAST_PORT);\n+        socket.send(sendPacket);\n+        logger.debug(\"Disover message sent\");", "originalCommit": "7ae36564597a2284590a7bbc8bd8fe72bd8cd3a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYwMDQ4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390600481", "bodyText": "Assuming that you are doing broadcast discovery on a local area network. I don't see why you would expect any response to take up to 5 seconds. Wouldn't 500 milliseconds be more than sufficient?", "author": "cpmeister", "createdAt": "2020-03-10T20:46:37Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal.discovery;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Discovery service implementation to scan for available air units in the network via broadcast.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@Component(service = DiscoveryService.class, immediate = true)\n+@NonNullByDefault\n+public class DanfossAirUnitDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int BROADCAST_PORT = 30045;\n+    private static final byte[] DISCOVER_SEND = { 0x0c, 0x00, 0x30, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13 };\n+    private static final byte[] DISCOVER_RECEIVE = { 0x0d, 0x00, 0x07, 0x00, 0x02, 0x02, 0x00 };\n+\n+    private Logger logger = LoggerFactory.getLogger(DanfossAirUnitDiscoveryService.class);\n+\n+    public DanfossAirUnitDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 15, true);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Start Danfoss Air CCM background discovery\");\n+        scheduler.execute(this::discover);\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        logger.debug(\"Start Danfoss Air CCM scan\");\n+        discover();\n+    }\n+\n+    private synchronized void discover() {\n+        logger.debug(\"Try to discover all Danfoss Air CCM devices\");\n+\n+        try (DatagramSocket socket = new DatagramSocket()) {\n+\n+            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n+            while (interfaces.hasMoreElements()) {\n+                NetworkInterface networkInterface = interfaces.nextElement();\n+                if (networkInterface == null || networkInterface.isLoopback() || !networkInterface.isUp()) {\n+                    continue;\n+                }\n+                for (InterfaceAddress interfaceAddress : networkInterface.getInterfaceAddresses()) {\n+                    if (interfaceAddress == null || interfaceAddress.getBroadcast() == null) {\n+                        continue;\n+                    }\n+                    logger.debug(\"Sending broadcast on interface {} to discover Danfoss Air CCM device...\",\n+                            interfaceAddress.getAddress().toString());\n+                    sendBroadcastToDiscoverThing(socket, interfaceAddress.getBroadcast());\n+                }\n+            }\n+\n+        } catch (IOException e) {\n+            logger.debug(\"No Danfoss Air CCM device found. Diagnostic: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void sendBroadcastToDiscoverThing(DatagramSocket socket, InetAddress broadcastAddress) throws IOException {\n+        socket.setBroadcast(true);\n+        socket.setSoTimeout(5000);", "originalCommit": "7ae36564597a2284590a7bbc8bd8fe72bd8cd3a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MjQ0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422492442", "bodyText": "Could be null is there btw a reason you are not using the nullable annotations? For such classes its almost trivial to implement, see also: https://www.openhab.org/docs/developer/guidelines.html#null-annotations", "author": "martinvw", "createdAt": "2020-05-09T12:54:05Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ChannelGroup.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+/**\n+ * Represents a channel group, channels are divided into.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+public enum ChannelGroup {\n+    MAIN(\"main\"),\n+    TEMPS(\"temps\"),\n+    HUMIDITY(\"humidity\"),\n+    RECUPERATOR(\"recuperator\"),\n+    SERVICE(\"service\");\n+\n+    private String groupName;", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MjU0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422492542", "bodyText": "Please remove this empty line", "author": "martinvw", "createdAt": "2020-05-09T12:55:04Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.*;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5Mjc0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422492749", "bodyText": "It's considered bad practice to both log and (re)throw an exception", "author": "martinvw", "createdAt": "2020-05-09T12:56:52Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.*;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@SuppressWarnings(\"SameParameterValue\")\n+@NonNullByDefault\n+public class DanfossAirUnit {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n+\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n+    }\n+\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = communicationController.sendRobustRequest(operation, register);\n+        return (short)((resultBytes[0] << 8)  | (resultBytes[1] & 0xFF));\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, byte value) throws IOException {\n+        byte[] valueArray = { value };\n+        communicationController.sendRobustRequest(operation, register, valueArray);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, short value) throws IOException {\n+        communicationController.sendRobustRequest(operation, register, shortToBytes(value));\n+    }\n+\n+    private byte[] shortToBytes(short s) {\n+        return new byte[]{(byte)((s & 0xFF00) >> 8),(byte)(s & 0x00FF)};\n+    }\n+\n+    private short getShort(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return (short) ((result[0] << 8) + (result[1] & 0xff));\n+    }\n+\n+    private float getTemperature(byte[] operation, byte[] register) throws IOException, UnexpectedResponseValueException {\n+        short shortTemp = getShort(operation, register);\n+        float temp = ((float) shortTemp) / 100;\n+        if (temp <= -274 || temp > 100) {\n+            throw new UnexpectedResponseValueException(String.format(\"Invalid temperature: %s\", temp));\n+        }\n+        return temp;\n+    }\n+\n+    private ZonedDateTime getTimestamp(byte[] operation, byte[] register) throws IOException, UnexpectedResponseValueException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return asZonedDateTime(result);\n+    }\n+\n+    private ZonedDateTime asZonedDateTime(byte[] data) throws UnexpectedResponseValueException {\n+        int second = data[0];\n+        int minute = data[1];\n+        int hour = data[2] & 0x1f;\n+        int day = data[3] & 0x1f;\n+        int month = data[4];\n+        int year = data[5] + 2000;\n+        try {\n+            return ZonedDateTime.of(year, month, day, hour, minute, second, 0, ZoneId.systemDefault());\n+        } catch (DateTimeException e) {\n+            String msg = String.format(\"Ignoring invalid timestamp %s.%s.%s %s:%s:%s\", day, month, year, hour, minute,\n+                    second);\n+            logger.debug(msg);", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5Mjc5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422492796", "bodyText": "Consider passing the cause of the exception, now you are effectively ignoring the caught exception.", "author": "martinvw", "createdAt": "2020-05-09T12:57:35Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.*;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@SuppressWarnings(\"SameParameterValue\")\n+@NonNullByDefault\n+public class DanfossAirUnit {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n+\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n+    }\n+\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = communicationController.sendRobustRequest(operation, register);\n+        return (short)((resultBytes[0] << 8)  | (resultBytes[1] & 0xFF));\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, byte value) throws IOException {\n+        byte[] valueArray = { value };\n+        communicationController.sendRobustRequest(operation, register, valueArray);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, short value) throws IOException {\n+        communicationController.sendRobustRequest(operation, register, shortToBytes(value));\n+    }\n+\n+    private byte[] shortToBytes(short s) {\n+        return new byte[]{(byte)((s & 0xFF00) >> 8),(byte)(s & 0x00FF)};\n+    }\n+\n+    private short getShort(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return (short) ((result[0] << 8) + (result[1] & 0xff));\n+    }\n+\n+    private float getTemperature(byte[] operation, byte[] register) throws IOException, UnexpectedResponseValueException {\n+        short shortTemp = getShort(operation, register);\n+        float temp = ((float) shortTemp) / 100;\n+        if (temp <= -274 || temp > 100) {\n+            throw new UnexpectedResponseValueException(String.format(\"Invalid temperature: %s\", temp));\n+        }\n+        return temp;\n+    }\n+\n+    private ZonedDateTime getTimestamp(byte[] operation, byte[] register) throws IOException, UnexpectedResponseValueException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return asZonedDateTime(result);\n+    }\n+\n+    private ZonedDateTime asZonedDateTime(byte[] data) throws UnexpectedResponseValueException {\n+        int second = data[0];\n+        int minute = data[1];\n+        int hour = data[2] & 0x1f;\n+        int day = data[3] & 0x1f;\n+        int month = data[4];\n+        int year = data[5] + 2000;\n+        try {\n+            return ZonedDateTime.of(year, month, day, hour, minute, second, 0, ZoneId.systemDefault());\n+        } catch (DateTimeException e) {\n+            String msg = String.format(\"Ignoring invalid timestamp %s.%s.%s %s:%s:%s\", day, month, year, hour, minute,\n+                    second);\n+            logger.debug(msg);\n+            throw new UnexpectedResponseValueException(msg);", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5Mjk2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422492963", "bodyText": "I don't think this has to be logged on info level?", "author": "martinvw", "createdAt": "2020-05-09T12:58:52Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitCommunicationController.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.EMPTY;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.Objects;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitCommunicationController} class does the actual network communication with the air unit.\n+ *\n+ * @author Robert Bach - initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class DanfossAirUnitCommunicationController {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitCommunicationController.class);\n+\n+    private final InetAddress inetAddr;\n+    private final int port;\n+    private boolean connected = false;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossAirUnitCommunicationController(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public synchronized void connect() throws IOException {\n+        if(connected) {\n+            return;\n+        }\n+        socket = new Socket(inetAddr, port);\n+        oStream = socket.getOutputStream();\n+        iStream = socket.getInputStream();\n+        connected = true;\n+    }\n+\n+    public synchronized void disconnect() {\n+        if(!connected) {\n+            return;\n+        }\n+        try {\n+            if (socket != null) {\n+                socket.close();\n+            }\n+        } catch (IOException ioe) {\n+            logger.info(\"Connection to air unit could not be closed gracefully. {}\", ioe.getMessage());", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzA1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493054", "bodyText": "This will throw an NPE when iStream is null and that is likely because it's nullable, is there any reason not to check?", "author": "martinvw", "createdAt": "2020-05-09T12:59:49Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitCommunicationController.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.EMPTY;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.Objects;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitCommunicationController} class does the actual network communication with the air unit.\n+ *\n+ * @author Robert Bach - initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class DanfossAirUnitCommunicationController {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitCommunicationController.class);\n+\n+    private final InetAddress inetAddr;\n+    private final int port;\n+    private boolean connected = false;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossAirUnitCommunicationController(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public synchronized void connect() throws IOException {\n+        if(connected) {\n+            return;\n+        }\n+        socket = new Socket(inetAddr, port);\n+        oStream = socket.getOutputStream();\n+        iStream = socket.getInputStream();\n+        connected = true;\n+    }\n+\n+    public synchronized void disconnect() {\n+        if(!connected) {\n+            return;\n+        }\n+        try {\n+            if (socket != null) {\n+                socket.close();\n+            }\n+        } catch (IOException ioe) {\n+            logger.info(\"Connection to air unit could not be closed gracefully. {}\", ioe.getMessage());\n+        } finally {\n+            socket = null;\n+            iStream = null;\n+            oStream = null;\n+        }\n+        connected = false;\n+    }\n+\n+    public byte[] sendRobustRequest(byte[] operation, byte[] register) throws IOException {\n+        return sendRobustRequest(operation, register, EMPTY);\n+    }\n+\n+    public synchronized byte[] sendRobustRequest(byte[] operation, byte[] register, byte[] value) throws IOException {\n+        connect();\n+        byte[] request = new byte[4 + value.length];\n+        System.arraycopy(operation, 0, request, 0, 2);\n+        System.arraycopy(register, 0, request, 2, 2);\n+        System.arraycopy(value, 0, request, 4, value.length);\n+        try {\n+            return sendRequestInternal(request);\n+        } catch (IOException ioe) {\n+            // retry once if there was connection problem\n+            disconnect();\n+            connect();\n+            return sendRequestInternal(request);\n+        }\n+    }\n+\n+    private synchronized byte[] sendRequestInternal(byte[] request) throws IOException {\n+\n+        Objects.requireNonNull(oStream).write(request);\n+        oStream.flush();\n+\n+        byte[] result = new byte[63];\n+        //noinspection ResultOfMethodCallIgnored\n+        Objects.requireNonNull(iStream).read(result, 0, 63);", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzA2NA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493064", "bodyText": "See below", "author": "martinvw", "createdAt": "2020-05-09T12:59:58Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitCommunicationController.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.EMPTY;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.Objects;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitCommunicationController} class does the actual network communication with the air unit.\n+ *\n+ * @author Robert Bach - initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class DanfossAirUnitCommunicationController {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitCommunicationController.class);\n+\n+    private final InetAddress inetAddr;\n+    private final int port;\n+    private boolean connected = false;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossAirUnitCommunicationController(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public synchronized void connect() throws IOException {\n+        if(connected) {\n+            return;\n+        }\n+        socket = new Socket(inetAddr, port);\n+        oStream = socket.getOutputStream();\n+        iStream = socket.getInputStream();\n+        connected = true;\n+    }\n+\n+    public synchronized void disconnect() {\n+        if(!connected) {\n+            return;\n+        }\n+        try {\n+            if (socket != null) {\n+                socket.close();\n+            }\n+        } catch (IOException ioe) {\n+            logger.info(\"Connection to air unit could not be closed gracefully. {}\", ioe.getMessage());\n+        } finally {\n+            socket = null;\n+            iStream = null;\n+            oStream = null;\n+        }\n+        connected = false;\n+    }\n+\n+    public byte[] sendRobustRequest(byte[] operation, byte[] register) throws IOException {\n+        return sendRobustRequest(operation, register, EMPTY);\n+    }\n+\n+    public synchronized byte[] sendRobustRequest(byte[] operation, byte[] register, byte[] value) throws IOException {\n+        connect();\n+        byte[] request = new byte[4 + value.length];\n+        System.arraycopy(operation, 0, request, 0, 2);\n+        System.arraycopy(register, 0, request, 2, 2);\n+        System.arraycopy(value, 0, request, 4, value.length);\n+        try {\n+            return sendRequestInternal(request);\n+        } catch (IOException ioe) {\n+            // retry once if there was connection problem\n+            disconnect();\n+            connect();\n+            return sendRequestInternal(request);\n+        }\n+    }\n+\n+    private synchronized byte[] sendRequestInternal(byte[] request) throws IOException {\n+\n+        Objects.requireNonNull(oStream).write(request);", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzExNA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493114", "bodyText": "Please put all fields above the constructor", "author": "martinvw", "createdAt": "2020-05-09T13:00:28Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzI2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493263", "bodyText": "I don't think this should be an info log statement especially not without and context and without stack trace. I would propose to provide some context what is the code doing while this fails and pass the exception as parameter.", "author": "martinvw", "createdAt": "2020-05-09T13:01:52Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzI4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493285", "bodyText": "Do you really need to catch the Exception-class or are there more specific exceptions you could catch like the IOException or maybe only RuntimeException's (which is not that good either). The current code and also catching RuntimeException's might 'hide' programming errors like NullPointerExceptions occurring.\nhttps://www.google.nl/search?q=java%20why%20not%20to%20catch%20exception", "author": "martinvw", "createdAt": "2020-05-09T13:02:06Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzMxNg==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493316", "bodyText": "If you catch all Exception you are potentially also catching for example NullPointerExceptions and  they tend to miss a message, so you will be printing the message null which will make it troublesome to debug, in this case it is always better to log the complete stacktrace.", "author": "martinvw", "createdAt": "2020-05-09T13:02:16Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzQ5MA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493490", "bodyText": "I doubt whether info is the proper log level and I suppose updating the thing status makes more sense for average users.", "author": "martinvw", "createdAt": "2020-05-09T13:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzU2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493567", "bodyText": "It's an enum feel free to compare using ==", "author": "martinvw", "createdAt": "2020-05-09T13:04:33Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+            return;\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                pollingJob = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 5, config.refreshInterval,\n+                        TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+            }\n+        });\n+    }\n+\n+    private void updateAllChannels() {\n+        if (hrv == null) {\n+            return;\n+        }\n+        DanfossAirUnit danfossAirUnit = hrv;\n+        logger.debug(\"Updating DanfossHRV data '{}'\", getThing().getUID());\n+\n+        try {\n+            for (Channel channel : Channel.values()) {\n+                if (Thread.interrupted()) {\n+                    logger.debug(\"Polling thread interrupted...\");\n+                    return;\n+                }\n+                try {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(),\n+                            channel.getReadAccessor().access(danfossAirUnit));\n+                } catch(UnexpectedResponseValueException e) {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(), UnDefType.UNDEF);\n+                    logger.debug(\"Cannot update channel {}: an unexpected or invalid response has been received from the air unit: {}\",\n+                            channel.getChannelName(), e.getMessage());\n+                } catch (IOException e) {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(), UnDefType.UNDEF);\n+                    logger.debug(\"Cannot update channel {}: an error occurred retrieving the value: {}\",\n+                            channel.getChannelName(), e.getMessage());\n+                }\n+            }\n+\n+            if (getThing().getStatus().equals(ThingStatus.OFFLINE)) {", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5Mzc2MA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493760", "bodyText": "At first glance, this catches exception before the outer catch can handle them. Should this catch update any status?", "author": "martinvw", "createdAt": "2020-05-09T13:06:14Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+            return;\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                pollingJob = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 5, config.refreshInterval,\n+                        TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+            }\n+        });\n+    }\n+\n+    private void updateAllChannels() {\n+        if (hrv == null) {\n+            return;\n+        }\n+        DanfossAirUnit danfossAirUnit = hrv;\n+        logger.debug(\"Updating DanfossHRV data '{}'\", getThing().getUID());\n+\n+        try {\n+            for (Channel channel : Channel.values()) {\n+                if (Thread.interrupted()) {\n+                    logger.debug(\"Polling thread interrupted...\");\n+                    return;\n+                }\n+                try {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(),\n+                            channel.getReadAccessor().access(danfossAirUnit));\n+                } catch(UnexpectedResponseValueException e) {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(), UnDefType.UNDEF);\n+                    logger.debug(\"Cannot update channel {}: an unexpected or invalid response has been received from the air unit: {}\",\n+                            channel.getChannelName(), e.getMessage());\n+                } catch (IOException e) {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(), UnDefType.UNDEF);", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5Mzc3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493771", "bodyText": "See above check all", "author": "martinvw", "createdAt": "2020-05-09T13:06:28Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+            return;\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                pollingJob = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 5, config.refreshInterval,\n+                        TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+            }\n+        });\n+    }\n+\n+    private void updateAllChannels() {\n+        if (hrv == null) {\n+            return;\n+        }\n+        DanfossAirUnit danfossAirUnit = hrv;\n+        logger.debug(\"Updating DanfossHRV data '{}'\", getThing().getUID());\n+\n+        try {\n+            for (Channel channel : Channel.values()) {\n+                if (Thread.interrupted()) {\n+                    logger.debug(\"Polling thread interrupted...\");\n+                    return;\n+                }\n+                try {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(),\n+                            channel.getReadAccessor().access(danfossAirUnit));\n+                } catch(UnexpectedResponseValueException e) {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(), UnDefType.UNDEF);\n+                    logger.debug(\"Cannot update channel {}: an unexpected or invalid response has been received from the air unit: {}\",\n+                            channel.getChannelName(), e.getMessage());\n+                } catch (IOException e) {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(), UnDefType.UNDEF);\n+                    logger.debug(\"Cannot update channel {}: an error occurred retrieving the value: {}\",\n+                            channel.getChannelName(), e.getMessage());\n+                }\n+            }\n+\n+            if (getThing().getStatus().equals(ThingStatus.OFFLINE)) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (IOException ioe) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+        } catch (Exception e) {", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzkyMA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493920", "bodyText": "If you really need this nested try-catch I would suggest to split of the part of the code that contains the nested try-catch to a separate method. This makes your code more readable and it might also make it more clear which part of the exceptions should be handled inside the method and which in the updateAllChannels method", "author": "martinvw", "createdAt": "2020-05-09T13:07:58Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+            return;\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                pollingJob = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 5, config.refreshInterval,\n+                        TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+            }\n+        });\n+    }\n+\n+    private void updateAllChannels() {\n+        if (hrv == null) {\n+            return;\n+        }\n+        DanfossAirUnit danfossAirUnit = hrv;\n+        logger.debug(\"Updating DanfossHRV data '{}'\", getThing().getUID());\n+\n+        try {\n+            for (Channel channel : Channel.values()) {\n+                if (Thread.interrupted()) {\n+                    logger.debug(\"Polling thread interrupted...\");\n+                    return;\n+                }\n+                try {", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5NDEzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422494139", "bodyText": "If you really need this nested try-catch I would suggest to split of the part of the code that contains the nested try-catch to a separate method. This makes your code more readable and it might also make it more clear which part of the exceptions should be handled inside the method and which in the updateAllChannels method", "author": "martinvw", "createdAt": "2020-05-09T13:10:18Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+            return;\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                pollingJob = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 5, config.refreshInterval,\n+                        TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+            }\n+        });\n+    }\n+\n+    private void updateAllChannels() {\n+        if (hrv == null) {\n+            return;\n+        }\n+        DanfossAirUnit danfossAirUnit = hrv;\n+        logger.debug(\"Updating DanfossHRV data '{}'\", getThing().getUID());\n+\n+        try {\n+            for (Channel channel : Channel.values()) {\n+                if (Thread.interrupted()) {\n+                    logger.debug(\"Polling thread interrupted...\");\n+                    return;\n+                }\n+                try {", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5NDI4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422494286", "bodyText": "Please check for all classes that lack NonNullByDefault annotations whether they can be added easily", "author": "martinvw", "createdAt": "2020-05-09T13:11:39Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Mode.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+/**\n+ * The {@link Mode} enum represents an air unit operation mode.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+public enum Mode {", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5NDQzMw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422494433", "bodyText": "You don't have to call toString it will be called automatically, but only when the logging-level actually applies.", "author": "martinvw", "createdAt": "2020-05-09T13:13:07Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal.discovery;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Discovery service implementation to scan for available air units in the network via broadcast.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@Component(service = DiscoveryService.class, immediate = true)\n+@NonNullByDefault\n+public class DanfossAirUnitDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int BROADCAST_PORT = 30045;\n+    private static final byte[] DISCOVER_SEND = { 0x0c, 0x00, 0x30, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13 };\n+    private static final byte[] DISCOVER_RECEIVE = { 0x0d, 0x00, 0x07, 0x00, 0x02, 0x02, 0x00 };\n+\n+    private Logger logger = LoggerFactory.getLogger(DanfossAirUnitDiscoveryService.class);\n+\n+    public DanfossAirUnitDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 15, true);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Start Danfoss Air CCM background discovery\");\n+        scheduler.execute(this::discover);\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        logger.debug(\"Start Danfoss Air CCM scan\");\n+        discover();\n+    }\n+\n+    private synchronized void discover() {\n+        logger.debug(\"Try to discover all Danfoss Air CCM devices\");\n+\n+        try (DatagramSocket socket = new DatagramSocket()) {\n+\n+            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n+            while (interfaces.hasMoreElements()) {\n+                NetworkInterface networkInterface = interfaces.nextElement();\n+                if (networkInterface == null || networkInterface.isLoopback() || !networkInterface.isUp()) {\n+                    continue;\n+                }\n+                for (InterfaceAddress interfaceAddress : networkInterface.getInterfaceAddresses()) {\n+                    if (interfaceAddress == null || interfaceAddress.getBroadcast() == null) {\n+                        continue;\n+                    }\n+                    logger.debug(\"Sending broadcast on interface {} to discover Danfoss Air CCM device...\",", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5NDY4MA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422494680", "bodyText": "Is this missing a break, because if the device responds it will just keep running or will it always throw an SocketTimeoutException?", "author": "martinvw", "createdAt": "2020-05-09T13:15:35Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal.discovery;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Discovery service implementation to scan for available air units in the network via broadcast.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@Component(service = DiscoveryService.class, immediate = true)\n+@NonNullByDefault\n+public class DanfossAirUnitDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int BROADCAST_PORT = 30045;\n+    private static final byte[] DISCOVER_SEND = { 0x0c, 0x00, 0x30, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13 };\n+    private static final byte[] DISCOVER_RECEIVE = { 0x0d, 0x00, 0x07, 0x00, 0x02, 0x02, 0x00 };\n+\n+    private Logger logger = LoggerFactory.getLogger(DanfossAirUnitDiscoveryService.class);\n+\n+    public DanfossAirUnitDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 15, true);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Start Danfoss Air CCM background discovery\");\n+        scheduler.execute(this::discover);\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        logger.debug(\"Start Danfoss Air CCM scan\");\n+        discover();\n+    }\n+\n+    private synchronized void discover() {\n+        logger.debug(\"Try to discover all Danfoss Air CCM devices\");\n+\n+        try (DatagramSocket socket = new DatagramSocket()) {\n+\n+            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n+            while (interfaces.hasMoreElements()) {\n+                NetworkInterface networkInterface = interfaces.nextElement();\n+                if (networkInterface == null || networkInterface.isLoopback() || !networkInterface.isUp()) {\n+                    continue;\n+                }\n+                for (InterfaceAddress interfaceAddress : networkInterface.getInterfaceAddresses()) {\n+                    if (interfaceAddress == null || interfaceAddress.getBroadcast() == null) {\n+                        continue;\n+                    }\n+                    logger.debug(\"Sending broadcast on interface {} to discover Danfoss Air CCM device...\",\n+                            interfaceAddress.getAddress().toString());\n+                    sendBroadcastToDiscoverThing(socket, interfaceAddress.getBroadcast());\n+                }\n+            }\n+\n+        } catch (IOException e) {\n+            logger.debug(\"No Danfoss Air CCM device found. Diagnostic: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void sendBroadcastToDiscoverThing(DatagramSocket socket, InetAddress broadcastAddress) throws IOException {\n+        socket.setBroadcast(true);\n+        socket.setSoTimeout(500);\n+        // send discover\n+        byte[] sendBuffer = DISCOVER_SEND;\n+        DatagramPacket sendPacket = new DatagramPacket(sendBuffer, sendBuffer.length, broadcastAddress, BROADCAST_PORT);\n+        socket.send(sendPacket);\n+        logger.debug(\"Discover message sent\");\n+\n+        // wait for responses\n+        while (true) {\n+            byte[] receiveBuffer = new byte[7];\n+            DatagramPacket receivePacket = new DatagramPacket(receiveBuffer, receiveBuffer.length);\n+            try {\n+                socket.receive(receivePacket);\n+            } catch (SocketTimeoutException e) {\n+                break; // leave the endless loop\n+            }\n+\n+            byte[] data = receivePacket.getData();\n+            if (Arrays.equals(data, DISCOVER_RECEIVE)) {\n+                logger.debug(\"Discover received correct response\");\n+\n+                String host = receivePacket.getAddress().getHostName();\n+                Map<String, Object> properties = new HashMap<>();\n+                properties.put(\"host\", host);\n+\n+                logger.debug(\"Adding a new Danfoss Air Unit CCM '{}' to inbox\", host);\n+\n+                ThingUID uid = new ThingUID(THING_TYPE_AIRUNIT, String.valueOf(receivePacket.getAddress().hashCode()));\n+\n+                DiscoveryResult result = DiscoveryResultBuilder.create(uid).withRepresentationProperty(\"host\")\n+                        .withProperties(properties).withLabel(\"Danfoss HRV\").build();\n+                thingDiscovered(result);\n+\n+                logger.debug(\"Thing discovered '{}'\", result);", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA3OTQzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r423079431", "bodyText": "It will process packets as long as there is anything to read, otherwise it'll time out and break the loop.", "author": "pravussum", "createdAt": "2020-05-11T14:26:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5NDY4MA=="}], "type": "inlineReview"}, {"oid": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "url": "https://github.com/openhab/openhab-addons/commit/22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "message": "[danfossairunit] initial contribution\n\nSigned-off-by: Robert Bach <openhab@mortalsilence.net>", "committedDate": "2020-05-11T16:09:56Z", "type": "commit"}]}